import * as Se from "https://cdn.skypack.dev/pin/react@v17.0.1-yH0aYV1FOvoIPeKBbHxg/mode=imports,min/optimized/react.js";
import wt, { Component as IU, useEffect as Jc, useCallback as Lv, useContext as PU, useState as nA, useMemo as a1, useRef as AU } from "https://cdn.skypack.dev/pin/react@v17.0.1-yH0aYV1FOvoIPeKBbHxg/mode=imports,min/optimized/react.js";
import * as MU from "https://cdn.skypack.dev/pin/react-dom@v17.0.1-oZ1BXZ5opQ1DbTh7nu9r/mode=imports,min/optimized/react-dom.js";
import rg from "https://cdn.skypack.dev/pin/react-dom@v17.0.1-oZ1BXZ5opQ1DbTh7nu9r/mode=imports,min/optimized/react-dom.js";
import UW from "https://cdn.skypack.dev/pin/react-dom@v17.0.1-oZ1BXZ5opQ1DbTh7nu9r/dist=es2020,mode=imports,min/unoptimized/cjs/react-dom-server.browser.production.min.js";
var Ne = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function zW(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function OO(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function i() {
      if (this instanceof i) {
        var r = [null];
        r.push.apply(r, arguments);
        var o = Function.bind.apply(e, r);
        return new o();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(t, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), t;
}
/**
 * @remix-run/router v1.6.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function li() {
  return li = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, li.apply(this, arguments);
}
var Un;
(function(n) {
  n.Pop = "POP", n.Push = "PUSH", n.Replace = "REPLACE";
})(Un || (Un = {}));
const rA = "popstate";
function FU(n) {
  n === void 0 && (n = {});
  function e(r, o) {
    let {
      pathname: s = "/",
      search: a = "",
      hash: l = ""
    } = Kl(r.location.hash.substr(1));
    return Dv(
      "",
      {
        pathname: s,
        search: a,
        hash: l
      },
      // state defaults to `null` because `window.history.state` does
      o.state && o.state.usr || null,
      o.state && o.state.key || "default"
    );
  }
  function t(r, o) {
    let s = r.document.querySelector("base"), a = "";
    if (s && s.getAttribute("href")) {
      let l = r.location.href, u = l.indexOf("#");
      a = u === -1 ? l : l.slice(0, u);
    }
    return a + "#" + (typeof o == "string" ? o : Cd(o));
  }
  function i(r, o) {
    eh(r.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(o) + ")");
  }
  return WU(e, t, i, n);
}
function Wt(n, e) {
  if (n === !1 || n === null || typeof n > "u")
    throw new Error(e);
}
function eh(n, e) {
  if (!n) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {
    }
  }
}
function kU() {
  return Math.random().toString(36).substr(2, 8);
}
function oA(n, e) {
  return {
    usr: n.state,
    key: n.key,
    idx: e
  };
}
function Dv(n, e, t, i) {
  return t === void 0 && (t = null), li({
    pathname: typeof n == "string" ? n : n.pathname,
    search: "",
    hash: ""
  }, typeof e == "string" ? Kl(e) : e, {
    state: t,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: e && e.key || i || kU()
  });
}
function Cd(n) {
  let {
    pathname: e = "/",
    search: t = "",
    hash: i = ""
  } = n;
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i), e;
}
function Kl(n) {
  let e = {};
  if (n) {
    let t = n.indexOf("#");
    t >= 0 && (e.hash = n.substr(t), n = n.substr(0, t));
    let i = n.indexOf("?");
    i >= 0 && (e.search = n.substr(i), n = n.substr(0, i)), n && (e.pathname = n);
  }
  return e;
}
function WU(n, e, t, i) {
  i === void 0 && (i = {});
  let {
    window: r = document.defaultView,
    v5Compat: o = !1
  } = i, s = r.history, a = Un.Pop, l = null, u = c();
  u == null && (u = 0, s.replaceState(li({}, s.state, {
    idx: u
  }), ""));
  function c() {
    return (s.state || {
      idx: null
    }).idx;
  }
  function h() {
    a = Un.Pop;
    let _ = c(), m = _ == null ? null : _ - u;
    u = _, l && l({
      action: a,
      location: g.location,
      delta: m
    });
  }
  function d(_, m) {
    a = Un.Push;
    let v = Dv(g.location, _, m);
    t && t(v, _), u = c() + 1;
    let C = oA(v, u), y = g.createHref(v);
    try {
      s.pushState(C, "", y);
    } catch (b) {
      if (b instanceof DOMException && b.name === "DataCloneError")
        throw b;
      r.location.assign(y);
    }
    o && l && l({
      action: a,
      location: g.location,
      delta: 1
    });
  }
  function f(_, m) {
    a = Un.Replace;
    let v = Dv(g.location, _, m);
    t && t(v, _), u = c();
    let C = oA(v, u), y = g.createHref(v);
    s.replaceState(C, "", y), o && l && l({
      action: a,
      location: g.location,
      delta: 0
    });
  }
  function p(_) {
    let m = r.location.origin !== "null" ? r.location.origin : r.location.href, v = typeof _ == "string" ? _ : Cd(_);
    return Wt(m, "No window.location.(origin|href) available to create URL for href: " + v), new URL(v, m);
  }
  let g = {
    get action() {
      return a;
    },
    get location() {
      return n(r, s);
    },
    listen(_) {
      if (l)
        throw new Error("A history only accepts one active listener");
      return r.addEventListener(rA, h), l = _, () => {
        r.removeEventListener(rA, h), l = null;
      };
    },
    createHref(_) {
      return e(r, _);
    },
    createURL: p,
    encodeLocation(_) {
      let m = p(_);
      return {
        pathname: m.pathname,
        search: m.search,
        hash: m.hash
      };
    },
    push: d,
    replace: f,
    go(_) {
      return s.go(_);
    }
  };
  return g;
}
var cr;
(function(n) {
  n.data = "data", n.deferred = "deferred", n.redirect = "redirect", n.error = "error";
})(cr || (cr = {}));
const VU = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function BU(n) {
  return n.index === !0;
}
function l1(n, e, t, i) {
  return t === void 0 && (t = []), i === void 0 && (i = {}), n.map((r, o) => {
    let s = [...t, o], a = typeof r.id == "string" ? r.id : s.join("-");
    if (Wt(r.index !== !0 || !r.children, "Cannot specify children on an index route"), Wt(!i[a], 'Found a route id collision on id "' + a + `".  Route id's must be globally unique within Data Router usages`), BU(r)) {
      let l = li({}, r, e(r), {
        id: a
      });
      return i[a] = l, l;
    } else {
      let l = li({}, r, e(r), {
        id: a,
        children: void 0
      });
      return i[a] = l, r.children && (l.children = l1(r.children, e, s, i)), l;
    }
  });
}
function Vf(n, e, t) {
  t === void 0 && (t = "/");
  let i = typeof e == "string" ? Kl(e) : e, r = og(i.pathname || "/", t);
  if (r == null)
    return null;
  let o = jW(n);
  HU(o);
  let s = null;
  for (let a = 0; s == null && a < o.length; ++a)
    s = XU(
      o[a],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      JU(r)
    );
  return s;
}
function jW(n, e, t, i) {
  e === void 0 && (e = []), t === void 0 && (t = []), i === void 0 && (i = "");
  let r = (o, s, a) => {
    let l = {
      relativePath: a === void 0 ? o.path || "" : a,
      caseSensitive: o.caseSensitive === !0,
      childrenIndex: s,
      route: o
    };
    l.relativePath.startsWith("/") && (Wt(l.relativePath.startsWith(i), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + i + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(i.length));
    let u = Vu([i, l.relativePath]), c = t.concat(l);
    o.children && o.children.length > 0 && (Wt(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      o.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + u + '".')
    ), jW(o.children, e, c, u)), !(o.path == null && !o.index) && e.push({
      path: u,
      score: qU(u, o.index),
      routesMeta: c
    });
  };
  return n.forEach((o, s) => {
    var a;
    if (o.path === "" || !((a = o.path) != null && a.includes("?")))
      r(o, s);
    else
      for (let l of $W(o.path))
        r(o, s, l);
  }), e;
}
function $W(n) {
  let e = n.split("/");
  if (e.length === 0)
    return [];
  let [t, ...i] = e, r = t.endsWith("?"), o = t.replace(/\?$/, "");
  if (i.length === 0)
    return r ? [o, ""] : [o];
  let s = $W(i.join("/")), a = [];
  return a.push(...s.map((l) => l === "" ? o : [o, l].join("/"))), r && a.push(...s), a.map((l) => n.startsWith("/") && l === "" ? "/" : l);
}
function HU(n) {
  n.sort((e, t) => e.score !== t.score ? t.score - e.score : YU(e.routesMeta.map((i) => i.childrenIndex), t.routesMeta.map((i) => i.childrenIndex)));
}
const GU = /^:\w+$/, UU = 3, zU = 2, jU = 1, $U = 10, KU = -2, sA = (n) => n === "*";
function qU(n, e) {
  let t = n.split("/"), i = t.length;
  return t.some(sA) && (i += KU), e && (i += zU), t.filter((r) => !sA(r)).reduce((r, o) => r + (GU.test(o) ? UU : o === "" ? jU : $U), i);
}
function YU(n, e) {
  return n.length === e.length && n.slice(0, -1).every((i, r) => i === e[r]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    n[n.length - 1] - e[e.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function XU(n, e) {
  let {
    routesMeta: t
  } = n, i = {}, r = "/", o = [];
  for (let s = 0; s < t.length; ++s) {
    let a = t[s], l = s === t.length - 1, u = r === "/" ? e : e.slice(r.length) || "/", c = ZU({
      path: a.relativePath,
      caseSensitive: a.caseSensitive,
      end: l
    }, u);
    if (!c)
      return null;
    Object.assign(i, c.params);
    let h = a.route;
    o.push({
      // TODO: Can this as be avoided?
      params: i,
      pathname: Vu([r, c.pathname]),
      pathnameBase: nz(Vu([r, c.pathnameBase])),
      route: h
    }), c.pathnameBase !== "/" && (r = Vu([r, c.pathnameBase]));
  }
  return o;
}
function N_e(n, e) {
  e === void 0 && (e = {});
  let t = n;
  t.endsWith("*") && t !== "*" && !t.endsWith("/*") && (eh(!1, 'Route path "' + t + '" will be treated as if it were ' + ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + t.replace(/\*$/, "/*") + '".')), t = t.replace(/\*$/, "/*"));
  const i = t.startsWith("/") ? "/" : "", r = t.split(/\/+/).map((o, s, a) => {
    if (s === a.length - 1 && o === "*")
      return e["*"];
    const u = o.match(/^:(\w+)(\??)$/);
    if (u) {
      const [, c, h] = u;
      let d = e[c];
      return h === "?" ? d ?? "" : (d == null && Wt(!1, 'Missing ":' + c + '" param'), d);
    }
    return o.replace(/\?$/g, "");
  }).filter((o) => !!o);
  return i + r.join("/");
}
function ZU(n, e) {
  typeof n == "string" && (n = {
    path: n,
    caseSensitive: !1,
    end: !0
  });
  let [t, i] = QU(n.path, n.caseSensitive, n.end), r = e.match(t);
  if (!r)
    return null;
  let o = r[0], s = o.replace(/(.)\/+$/, "$1"), a = r.slice(1);
  return {
    params: i.reduce((u, c, h) => {
      if (c === "*") {
        let d = a[h] || "";
        s = o.slice(0, o.length - d.length).replace(/(.)\/+$/, "$1");
      }
      return u[c] = ez(a[h] || "", c), u;
    }, {}),
    pathname: o,
    pathnameBase: s,
    pattern: n
  };
}
function QU(n, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !0), eh(n === "*" || !n.endsWith("*") || n.endsWith("/*"), 'Route path "' + n + '" will be treated as if it were ' + ('"' + n.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + n.replace(/\*$/, "/*") + '".'));
  let i = [], r = "^" + n.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (s, a) => (i.push(a), "/([^\\/]+)"));
  return n.endsWith("*") ? (i.push("*"), r += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? r += "\\/*$" : n !== "" && n !== "/" && (r += "(?:(?=\\/|$))"), [new RegExp(r, e ? void 0 : "i"), i];
}
function JU(n) {
  try {
    return decodeURI(n);
  } catch (e) {
    return eh(!1, 'The URL path "' + n + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), n;
  }
}
function ez(n, e) {
  try {
    return decodeURIComponent(n);
  } catch (t) {
    return eh(!1, 'The value for the URL param "' + e + '" will not be decoded because' + (' the string "' + n + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + t + ").")), n;
  }
}
function og(n, e) {
  if (e === "/")
    return n;
  if (!n.toLowerCase().startsWith(e.toLowerCase()))
    return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length, i = n.charAt(t);
  return i && i !== "/" ? null : n.slice(t) || "/";
}
function tz(n, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: i = "",
    hash: r = ""
  } = typeof n == "string" ? Kl(n) : n;
  return {
    pathname: t ? t.startsWith("/") ? t : iz(t, e) : e,
    search: rz(i),
    hash: oz(r)
  };
}
function iz(n, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return n.split("/").forEach((r) => {
    r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r);
  }), t.length > 1 ? t.join("/") : "/";
}
function VE(n, e, t, i) {
  return "Cannot include a '" + n + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(i) + "].  Please separate it out to the ") + ("`to." + t + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function dS(n) {
  return n.filter((e, t) => t === 0 || e.route.path && e.route.path.length > 0);
}
function xO(n, e, t, i) {
  i === void 0 && (i = !1);
  let r;
  typeof n == "string" ? r = Kl(n) : (r = li({}, n), Wt(!r.pathname || !r.pathname.includes("?"), VE("?", "pathname", "search", r)), Wt(!r.pathname || !r.pathname.includes("#"), VE("#", "pathname", "hash", r)), Wt(!r.search || !r.search.includes("#"), VE("#", "search", "hash", r)));
  let o = n === "" || r.pathname === "", s = o ? "/" : r.pathname, a;
  if (i || s == null)
    a = t;
  else {
    let h = e.length - 1;
    if (s.startsWith("..")) {
      let d = s.split("/");
      for (; d[0] === ".."; )
        d.shift(), h -= 1;
      r.pathname = d.join("/");
    }
    a = h >= 0 ? e[h] : "/";
  }
  let l = tz(r, a), u = s && s !== "/" && s.endsWith("/"), c = (o || s === ".") && t.endsWith("/");
  return !l.pathname.endsWith("/") && (u || c) && (l.pathname += "/"), l;
}
const Vu = (n) => n.join("/").replace(/\/\/+/g, "/"), nz = (n) => n.replace(/\/+$/, "").replace(/^\/*/, "/"), rz = (n) => !n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n, oz = (n) => !n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n, I_e = function(e, t) {
  t === void 0 && (t = 302);
  let i = t;
  typeof i == "number" ? i = {
    status: i
  } : typeof i.status > "u" && (i.status = 302);
  let r = new Headers(i.headers);
  return r.set("Location", e), new Response(null, li({}, i, {
    headers: r
  }));
};
class NO {
  constructor(e, t, i, r) {
    r === void 0 && (r = !1), this.status = e, this.statusText = t || "", this.internal = r, i instanceof Error ? (this.data = i.toString(), this.error = i) : this.data = i;
  }
}
function KW(n) {
  return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.internal == "boolean" && "data" in n;
}
const qW = ["post", "put", "patch", "delete"], sz = new Set(qW), az = ["get", ...qW], lz = new Set(az), uz = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), cz = /* @__PURE__ */ new Set([307, 308]), BE = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0
}, hz = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0
}, aA = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
}, YW = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, dz = (n) => ({
  hasErrorBoundary: !!n.hasErrorBoundary
});
function fz(n) {
  const e = n.window ? n.window : typeof window < "u" ? window : void 0, t = typeof e < "u" && typeof e.document < "u" && typeof e.document.createElement < "u", i = !t;
  Wt(n.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let r;
  if (n.mapRouteProperties)
    r = n.mapRouteProperties;
  else if (n.detectErrorBoundary) {
    let te = n.detectErrorBoundary;
    r = (X) => ({
      hasErrorBoundary: te(X)
    });
  } else
    r = dz;
  let o = {}, s = l1(n.routes, r, void 0, o), a, l = n.basename || "/", u = li({
    v7_normalizeFormMethod: !1,
    v7_prependBasename: !1
  }, n.future), c = null, h = /* @__PURE__ */ new Set(), d = null, f = null, p = null, g = n.hydrationData != null, _ = Vf(s, n.history.location, l), m = null;
  if (_ == null) {
    let te = Oa(404, {
      pathname: n.history.location.pathname
    }), {
      matches: X,
      route: re
    } = pA(s);
    _ = X, m = {
      [re.id]: te
    };
  }
  let v = (
    // All initialMatches need to be loaded before we're ready.  If we have lazy
    // functions around still then we'll need to run them in initialize()
    !_.some((te) => te.route.lazy) && // And we have to either have no loaders or have been provided hydrationData
    (!_.some((te) => te.route.loader) || n.hydrationData != null)
  ), C, y = {
    historyAction: n.history.action,
    location: n.history.location,
    matches: _,
    initialized: v,
    navigation: BE,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: n.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: n.hydrationData && n.hydrationData.loaderData || {},
    actionData: n.hydrationData && n.hydrationData.actionData || null,
    errors: n.hydrationData && n.hydrationData.errors || m,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, b = Un.Pop, L = !1, S, E = !1, D = !1, O = [], T = [], A = /* @__PURE__ */ new Map(), P = 0, G = -1, U = /* @__PURE__ */ new Map(), $ = /* @__PURE__ */ new Set(), k = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Map(), ne = /* @__PURE__ */ new Map(), Ce = !1;
  function ue() {
    return c = n.history.listen((te) => {
      let {
        action: X,
        location: re,
        delta: he
      } = te;
      if (Ce) {
        Ce = !1;
        return;
      }
      eh(ne.size === 0 || he != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let be = ai({
        currentLocation: y.location,
        nextLocation: re,
        historyAction: X
      });
      if (be && he != null) {
        Ce = !0, n.history.go(he * -1), ft(be, {
          state: "blocked",
          location: re,
          proceed() {
            ft(be, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: re
            }), n.history.go(he);
          },
          reset() {
            wi(be), Y({
              blockers: new Map(C.state.blockers)
            });
          }
        });
        return;
      }
      return H(X, re);
    }), y.initialized || H(Un.Pop, y.location), C;
  }
  function B() {
    c && c(), h.clear(), S && S.abort(), y.fetchers.forEach((te, X) => ii(X)), y.blockers.forEach((te, X) => wi(X));
  }
  function z(te) {
    return h.add(te), () => h.delete(te);
  }
  function Y(te) {
    y = li({}, y, te), h.forEach((X) => X(y));
  }
  function x(te, X) {
    var re, he;
    let be = y.actionData != null && y.navigation.formMethod != null && yu(y.navigation.formMethod) && y.navigation.state === "loading" && ((re = te.state) == null ? void 0 : re._isRedirect) !== !0, xe;
    X.actionData ? Object.keys(X.actionData).length > 0 ? xe = X.actionData : xe = null : be ? xe = y.actionData : xe = null;
    let $e = X.loaderData ? fA(y.loaderData, X.loaderData, X.matches || [], X.errors) : y.loaderData;
    for (let [ke] of ne)
      wi(ke);
    let Oe = L === !0 || y.navigation.formMethod != null && yu(y.navigation.formMethod) && ((he = te.state) == null ? void 0 : he._isRedirect) !== !0;
    a && (s = a, a = void 0), Y(li({}, X, {
      actionData: xe,
      loaderData: $e,
      historyAction: b,
      location: te,
      initialized: !0,
      navigation: BE,
      revalidation: "idle",
      restoreScrollPosition: Yt(te, X.matches || y.matches),
      preventScrollReset: Oe,
      blockers: new Map(y.blockers)
    })), E || b === Un.Pop || (b === Un.Push ? n.history.push(te, te.state) : b === Un.Replace && n.history.replace(te, te.state)), b = Un.Pop, L = !1, E = !1, D = !1, O = [], T = [];
  }
  async function M(te, X) {
    if (typeof te == "number") {
      n.history.go(te);
      return;
    }
    let re = u1(y.location, y.matches, l, u.v7_prependBasename, te, X == null ? void 0 : X.fromRouteId, X == null ? void 0 : X.relative), {
      path: he,
      submission: be,
      error: xe
    } = lA(u.v7_normalizeFormMethod, !1, re, X), $e = y.location, Oe = Dv(y.location, he, X && X.state);
    Oe = li({}, Oe, n.history.encodeLocation(Oe));
    let ke = X && X.replace != null ? X.replace : void 0, Et = Un.Push;
    ke === !0 ? Et = Un.Replace : ke === !1 || be != null && yu(be.formMethod) && be.formAction === y.location.pathname + y.location.search && (Et = Un.Replace);
    let Pe = X && "preventScrollReset" in X ? X.preventScrollReset === !0 : void 0, Dt = ai({
      currentLocation: $e,
      nextLocation: Oe,
      historyAction: Et
    });
    if (Dt) {
      ft(Dt, {
        state: "blocked",
        location: Oe,
        proceed() {
          ft(Dt, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: Oe
          }), M(te, X);
        },
        reset() {
          wi(Dt), Y({
            blockers: new Map(y.blockers)
          });
        }
      });
      return;
    }
    return await H(Et, Oe, {
      submission: be,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: xe,
      preventScrollReset: Pe,
      replace: X && X.replace
    });
  }
  function F() {
    if (Nt(), Y({
      revalidation: "loading"
    }), y.navigation.state !== "submitting") {
      if (y.navigation.state === "idle") {
        H(y.historyAction, y.location, {
          startUninterruptedRevalidation: !0
        });
        return;
      }
      H(b || y.historyAction, y.navigation.location, {
        overrideNavigation: y.navigation
      });
    }
  }
  async function H(te, X, re) {
    S && S.abort(), S = null, b = te, E = (re && re.startUninterruptedRevalidation) === !0, Vn(y.location, y.matches), L = (re && re.preventScrollReset) === !0;
    let he = a || s, be = re && re.overrideNavigation, xe = Vf(he, X, l);
    if (!xe) {
      let ni = Oa(404, {
        pathname: X.pathname
      }), {
        matches: We,
        route: hi
      } = pA(he);
      Jn(), x(X, {
        matches: We,
        loaderData: {},
        errors: {
          [hi.id]: ni
        }
      });
      return;
    }
    if (y.initialized && !D && _z(y.location, X) && !(re && re.submission && yu(re.submission.formMethod))) {
      x(X, {
        matches: xe
      });
      return;
    }
    S = new AbortController();
    let $e = Zg(n.history, X, S.signal, re && re.submission), Oe, ke;
    if (re && re.pendingError)
      ke = {
        [Bf(xe).route.id]: re.pendingError
      };
    else if (re && re.submission && yu(re.submission.formMethod)) {
      let ni = await oe($e, X, re.submission, xe, {
        replace: re.replace
      });
      if (ni.shortCircuited)
        return;
      Oe = ni.pendingActionData, ke = ni.pendingActionError, be = li({
        state: "loading",
        location: X
      }, re.submission), $e = new Request($e.url, {
        signal: $e.signal
      });
    }
    let {
      shortCircuited: Et,
      loaderData: Pe,
      errors: Dt
    } = await ve($e, X, xe, be, re && re.submission, re && re.fetcherSubmission, re && re.replace, Oe, ke);
    Et || (S = null, x(X, li({
      matches: xe
    }, Oe ? {
      actionData: Oe
    } : {}, {
      loaderData: Pe,
      errors: Dt
    })));
  }
  async function oe(te, X, re, he, be) {
    Nt();
    let xe = li({
      state: "submitting",
      location: X
    }, re);
    Y({
      navigation: xe
    });
    let $e, Oe = c1(he, X);
    if (!Oe.route.action && !Oe.route.lazy)
      $e = {
        type: cr.error,
        error: Oa(405, {
          method: te.method,
          pathname: X.pathname,
          routeId: Oe.route.id
        })
      };
    else if ($e = await Xg("action", te, Oe, he, o, r, l), te.signal.aborted)
      return {
        shortCircuited: !0
      };
    if (ip($e)) {
      let ke;
      return be && be.replace != null ? ke = be.replace : ke = $e.location === y.location.pathname + y.location.search, await qe(y, $e, {
        submission: re,
        replace: ke
      }), {
        shortCircuited: !0
      };
    }
    if (qm($e)) {
      let ke = Bf(he, Oe.route.id);
      return (be && be.replace) !== !0 && (b = Un.Push), {
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: {},
        pendingActionError: {
          [ke.route.id]: $e.error
        }
      };
    }
    if (Xh($e))
      throw Oa(400, {
        type: "defer-action"
      });
    return {
      pendingActionData: {
        [Oe.route.id]: $e.data
      }
    };
  }
  async function ve(te, X, re, he, be, xe, $e, Oe, ke) {
    let Et = he;
    Et || (Et = li({
      state: "loading",
      location: X,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, be));
    let Pe = be || xe ? be || xe : Et.formMethod && Et.formAction && Et.formData && Et.formEncType ? {
      formMethod: Et.formMethod,
      formAction: Et.formAction,
      formData: Et.formData,
      formEncType: Et.formEncType
    } : void 0, Dt = a || s, [ni, We] = uA(n.history, y, re, Pe, X, D, O, T, k, Dt, l, Oe, ke);
    if (Jn((Ii) => !(re && re.some((di) => di.route.id === Ii)) || ni && ni.some((di) => di.route.id === Ii)), ni.length === 0 && We.length === 0) {
      let Ii = zt();
      return x(X, li({
        matches: re,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: ke || null
      }, Oe ? {
        actionData: Oe
      } : {}, Ii ? {
        fetchers: new Map(y.fetchers)
      } : {})), {
        shortCircuited: !0
      };
    }
    if (!E) {
      We.forEach((di) => {
        let Xi = y.fetchers.get(di.key), rn = {
          state: "loading",
          data: Xi && Xi.data,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          " _hasFetcherDoneAnything ": !0
        };
        y.fetchers.set(di.key, rn);
      });
      let Ii = Oe || y.actionData;
      Y(li({
        navigation: Et
      }, Ii ? Object.keys(Ii).length === 0 ? {
        actionData: null
      } : {
        actionData: Ii
      } : {}, We.length > 0 ? {
        fetchers: new Map(y.fetchers)
      } : {}));
    }
    G = ++P, We.forEach((Ii) => {
      Ii.controller && A.set(Ii.key, Ii.controller);
    });
    let hi = () => We.forEach((Ii) => at(Ii.key));
    S && S.signal.addEventListener("abort", hi);
    let {
      results: Ql,
      loaderResults: Tr,
      fetcherResults: Oo
    } = await Tt(y.matches, re, ni, We, te);
    if (te.signal.aborted)
      return {
        shortCircuited: !0
      };
    S && S.signal.removeEventListener("abort", hi), We.forEach((Ii) => A.delete(Ii.key));
    let oo = gA(Ql);
    if (oo)
      return await qe(y, oo, {
        replace: $e
      }), {
        shortCircuited: !0
      };
    let {
      loaderData: nl,
      errors: Or
    } = dA(y, re, ni, Tr, ke, We, Oo, se);
    se.forEach((Ii, di) => {
      Ii.subscribe((Xi) => {
        (Xi || Ii.done) && se.delete(di);
      });
    });
    let vn = zt(), hh = qi(G), ic = vn || hh || We.length > 0;
    return li({
      loaderData: nl,
      errors: Or
    }, ic ? {
      fetchers: new Map(y.fetchers)
    } : {});
  }
  function Me(te) {
    return y.fetchers.get(te) || hz;
  }
  function ze(te, X, re, he) {
    if (i)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    A.has(te) && at(te);
    let be = a || s, xe = u1(y.location, y.matches, l, u.v7_prependBasename, re, X, he == null ? void 0 : he.relative), $e = Vf(be, xe, l);
    if (!$e) {
      ti(te, X, Oa(404, {
        pathname: xe
      }));
      return;
    }
    let {
      path: Oe,
      submission: ke
    } = lA(u.v7_normalizeFormMethod, !0, xe, he), Et = c1($e, Oe);
    if (L = (he && he.preventScrollReset) === !0, ke && yu(ke.formMethod)) {
      je(te, X, Oe, Et, $e, ke);
      return;
    }
    k.set(te, {
      routeId: X,
      path: Oe
    }), Fe(te, X, Oe, Et, $e, ke);
  }
  async function je(te, X, re, he, be, xe) {
    if (Nt(), k.delete(te), !he.route.action && !he.route.lazy) {
      let rn = Oa(405, {
        method: xe.formMethod,
        pathname: re,
        routeId: X
      });
      ti(te, X, rn);
      return;
    }
    let $e = y.fetchers.get(te), Oe = li({
      state: "submitting"
    }, xe, {
      data: $e && $e.data,
      " _hasFetcherDoneAnything ": !0
    });
    y.fetchers.set(te, Oe), Y({
      fetchers: new Map(y.fetchers)
    });
    let ke = new AbortController(), Et = Zg(n.history, re, ke.signal, xe);
    A.set(te, ke);
    let Pe = await Xg("action", Et, he, be, o, r, l);
    if (Et.signal.aborted) {
      A.get(te) === ke && A.delete(te);
      return;
    }
    if (ip(Pe)) {
      A.delete(te), $.add(te);
      let rn = li({
        state: "loading"
      }, xe, {
        data: void 0,
        " _hasFetcherDoneAnything ": !0
      });
      return y.fetchers.set(te, rn), Y({
        fetchers: new Map(y.fetchers)
      }), qe(y, Pe, {
        submission: xe,
        isFetchActionRedirect: !0
      });
    }
    if (qm(Pe)) {
      ti(te, X, Pe.error);
      return;
    }
    if (Xh(Pe))
      throw Oa(400, {
        type: "defer-action"
      });
    let Dt = y.navigation.location || y.location, ni = Zg(n.history, Dt, ke.signal), We = a || s, hi = y.navigation.state !== "idle" ? Vf(We, y.navigation.location, l) : y.matches;
    Wt(hi, "Didn't find any matches after fetcher action");
    let Ql = ++P;
    U.set(te, Ql);
    let Tr = li({
      state: "loading",
      data: Pe.data
    }, xe, {
      " _hasFetcherDoneAnything ": !0
    });
    y.fetchers.set(te, Tr);
    let [Oo, oo] = uA(
      n.history,
      y,
      hi,
      xe,
      Dt,
      D,
      O,
      T,
      k,
      We,
      l,
      {
        [he.route.id]: Pe.data
      },
      void 0
      // No need to send through errors since we short circuit above
    );
    oo.filter((rn) => rn.key !== te).forEach((rn) => {
      let Jl = rn.key, nc = y.fetchers.get(Jl), Q_ = {
        state: "loading",
        data: nc && nc.data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        " _hasFetcherDoneAnything ": !0
      };
      y.fetchers.set(Jl, Q_), rn.controller && A.set(Jl, rn.controller);
    }), Y({
      fetchers: new Map(y.fetchers)
    });
    let nl = () => oo.forEach((rn) => at(rn.key));
    ke.signal.addEventListener("abort", nl);
    let {
      results: Or,
      loaderResults: vn,
      fetcherResults: hh
    } = await Tt(y.matches, hi, Oo, oo, ni);
    if (ke.signal.aborted)
      return;
    ke.signal.removeEventListener("abort", nl), U.delete(te), A.delete(te), oo.forEach((rn) => A.delete(rn.key));
    let ic = gA(Or);
    if (ic)
      return qe(y, ic);
    let {
      loaderData: Ii,
      errors: di
    } = dA(y, y.matches, Oo, vn, void 0, oo, hh, se);
    if (y.fetchers.has(te)) {
      let rn = {
        state: "idle",
        data: Pe.data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        " _hasFetcherDoneAnything ": !0
      };
      y.fetchers.set(te, rn);
    }
    let Xi = qi(Ql);
    y.navigation.state === "loading" && Ql > G ? (Wt(b, "Expected pending action"), S && S.abort(), x(y.navigation.location, {
      matches: hi,
      loaderData: Ii,
      errors: di,
      fetchers: new Map(y.fetchers)
    })) : (Y(li({
      errors: di,
      loaderData: fA(y.loaderData, Ii, hi, di)
    }, Xi || oo.length > 0 ? {
      fetchers: new Map(y.fetchers)
    } : {})), D = !1);
  }
  async function Fe(te, X, re, he, be, xe) {
    let $e = y.fetchers.get(te), Oe = li({
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, xe, {
      data: $e && $e.data,
      " _hasFetcherDoneAnything ": !0
    });
    y.fetchers.set(te, Oe), Y({
      fetchers: new Map(y.fetchers)
    });
    let ke = new AbortController(), Et = Zg(n.history, re, ke.signal);
    A.set(te, ke);
    let Pe = await Xg("loader", Et, he, be, o, r, l);
    if (Xh(Pe) && (Pe = await JW(Pe, Et.signal, !0) || Pe), A.get(te) === ke && A.delete(te), Et.signal.aborted)
      return;
    if (ip(Pe)) {
      $.add(te), await qe(y, Pe);
      return;
    }
    if (qm(Pe)) {
      let ni = Bf(y.matches, X);
      y.fetchers.delete(te), Y({
        fetchers: new Map(y.fetchers),
        errors: {
          [ni.route.id]: Pe.error
        }
      });
      return;
    }
    Wt(!Xh(Pe), "Unhandled fetcher deferred data");
    let Dt = {
      state: "idle",
      data: Pe.data,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      " _hasFetcherDoneAnything ": !0
    };
    y.fetchers.set(te, Dt), Y({
      fetchers: new Map(y.fetchers)
    });
  }
  async function qe(te, X, re) {
    let {
      submission: he,
      replace: be,
      isFetchActionRedirect: xe
    } = re === void 0 ? {} : re;
    X.revalidate && (D = !0);
    let $e = Dv(
      te.location,
      X.location,
      // TODO: This can be removed once we get rid of useTransition in Remix v2
      li({
        _isRedirect: !0
      }, xe ? {
        _isFetchActionRedirect: !0
      } : {})
    );
    if (Wt($e, "Expected a location on the redirect navigation"), YW.test(X.location) && t) {
      let ni = n.history.createURL(X.location), We = og(ni.pathname, l) == null;
      if (e.location.origin !== ni.origin || We) {
        be ? e.location.replace(X.location) : e.location.assign(X.location);
        return;
      }
    }
    S = null;
    let Oe = be === !0 ? Un.Replace : Un.Push, {
      formMethod: ke,
      formAction: Et,
      formEncType: Pe,
      formData: Dt
    } = te.navigation;
    !he && ke && Et && Dt && Pe && (he = {
      formMethod: ke,
      formAction: Et,
      formEncType: Pe,
      formData: Dt
    }), cz.has(X.status) && he && yu(he.formMethod) ? await H(Oe, $e, {
      submission: li({}, he, {
        formAction: X.location
      }),
      // Preserve this flag across redirects
      preventScrollReset: L
    }) : xe ? await H(Oe, $e, {
      overrideNavigation: {
        state: "loading",
        location: $e,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0
      },
      fetcherSubmission: he,
      // Preserve this flag across redirects
      preventScrollReset: L
    }) : await H(Oe, $e, {
      overrideNavigation: {
        state: "loading",
        location: $e,
        formMethod: he ? he.formMethod : void 0,
        formAction: he ? he.formAction : void 0,
        formEncType: he ? he.formEncType : void 0,
        formData: he ? he.formData : void 0
      },
      // Preserve this flag across redirects
      preventScrollReset: L
    });
  }
  async function Tt(te, X, re, he, be) {
    let xe = await Promise.all([...re.map((ke) => Xg("loader", be, ke, X, o, r, l)), ...he.map((ke) => ke.matches && ke.match && ke.controller ? Xg("loader", Zg(n.history, ke.path, ke.controller.signal), ke.match, ke.matches, o, r, l) : {
      type: cr.error,
      error: Oa(404, {
        pathname: ke.path
      })
    })]), $e = xe.slice(0, re.length), Oe = xe.slice(re.length);
    return await Promise.all([mA(te, re, $e, $e.map(() => be.signal), !1, y.loaderData), mA(te, he.map((ke) => ke.match), Oe, he.map((ke) => ke.controller ? ke.controller.signal : null), !0)]), {
      results: xe,
      loaderResults: $e,
      fetcherResults: Oe
    };
  }
  function Nt() {
    D = !0, O.push(...Jn()), k.forEach((te, X) => {
      A.has(X) && (T.push(X), at(X));
    });
  }
  function ti(te, X, re) {
    let he = Bf(y.matches, X);
    ii(te), Y({
      errors: {
        [he.route.id]: re
      },
      fetchers: new Map(y.fetchers)
    });
  }
  function ii(te) {
    let X = y.fetchers.get(te);
    A.has(te) && !(X && X.state === "loading" && U.has(te)) && at(te), k.delete(te), U.delete(te), $.delete(te), y.fetchers.delete(te);
  }
  function at(te) {
    let X = A.get(te);
    Wt(X, "Expected fetch controller: " + te), X.abort(), A.delete(te);
  }
  function Hi(te) {
    for (let X of te) {
      let he = {
        state: "idle",
        data: Me(X).data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        " _hasFetcherDoneAnything ": !0
      };
      y.fetchers.set(X, he);
    }
  }
  function zt() {
    let te = [], X = !1;
    for (let re of $) {
      let he = y.fetchers.get(re);
      Wt(he, "Expected fetcher: " + re), he.state === "loading" && ($.delete(re), te.push(re), X = !0);
    }
    return Hi(te), X;
  }
  function qi(te) {
    let X = [];
    for (let [re, he] of U)
      if (he < te) {
        let be = y.fetchers.get(re);
        Wt(be, "Expected fetcher: " + re), be.state === "loading" && (at(re), U.delete(re), X.push(re));
      }
    return Hi(X), X.length > 0;
  }
  function Yi(te, X) {
    let re = y.blockers.get(te) || aA;
    return ne.get(te) !== X && ne.set(te, X), re;
  }
  function wi(te) {
    y.blockers.delete(te), ne.delete(te);
  }
  function ft(te, X) {
    let re = y.blockers.get(te) || aA;
    Wt(re.state === "unblocked" && X.state === "blocked" || re.state === "blocked" && X.state === "blocked" || re.state === "blocked" && X.state === "proceeding" || re.state === "blocked" && X.state === "unblocked" || re.state === "proceeding" && X.state === "unblocked", "Invalid blocker state transition: " + re.state + " -> " + X.state), y.blockers.set(te, X), Y({
      blockers: new Map(y.blockers)
    });
  }
  function ai(te) {
    let {
      currentLocation: X,
      nextLocation: re,
      historyAction: he
    } = te;
    if (ne.size === 0)
      return;
    ne.size > 1 && eh(!1, "A router only supports one blocker at a time");
    let be = Array.from(ne.entries()), [xe, $e] = be[be.length - 1], Oe = y.blockers.get(xe);
    if (!(Oe && Oe.state === "proceeding") && $e({
      currentLocation: X,
      nextLocation: re,
      historyAction: he
    }))
      return xe;
  }
  function Jn(te) {
    let X = [];
    return se.forEach((re, he) => {
      (!te || te(he)) && (re.cancel(), X.push(he), se.delete(he));
    }), X;
  }
  function On(te, X, re) {
    if (d = te, p = X, f = re || ((he) => he.key), !g && y.navigation === BE) {
      g = !0;
      let he = Yt(y.location, y.matches);
      he != null && Y({
        restoreScrollPosition: he
      });
    }
    return () => {
      d = null, p = null, f = null;
    };
  }
  function Vn(te, X) {
    if (d && f && p) {
      let re = X.map((be) => vA(be, y.loaderData)), he = f(te, re) || te.key;
      d[he] = p();
    }
  }
  function Yt(te, X) {
    if (d && f && p) {
      let re = X.map((xe) => vA(xe, y.loaderData)), he = f(te, re) || te.key, be = d[he];
      if (typeof be == "number")
        return be;
    }
    return null;
  }
  function To(te) {
    o = {}, a = l1(te, r, void 0, o);
  }
  return C = {
    get basename() {
      return l;
    },
    get state() {
      return y;
    },
    get routes() {
      return s;
    },
    initialize: ue,
    subscribe: z,
    enableScrollRestoration: On,
    navigate: M,
    fetch: ze,
    revalidate: F,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (te) => n.history.createHref(te),
    encodeLocation: (te) => n.history.encodeLocation(te),
    getFetcher: Me,
    deleteFetcher: ii,
    dispose: B,
    getBlocker: Yi,
    deleteBlocker: wi,
    _internalFetchControllers: A,
    _internalActiveDeferreds: se,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes: To
  }, C;
}
function pz(n) {
  return n != null && "formData" in n;
}
function u1(n, e, t, i, r, o, s) {
  let a, l;
  if (o != null && s !== "path") {
    a = [];
    for (let c of e)
      if (a.push(c), c.route.id === o) {
        l = c;
        break;
      }
  } else
    a = e, l = e[e.length - 1];
  let u = xO(r || ".", dS(a).map((c) => c.pathnameBase), og(n.pathname, t) || n.pathname, s === "path");
  return r == null && (u.search = n.search, u.hash = n.hash), (r == null || r === "" || r === ".") && l && l.route.index && !IO(u.search) && (u.search = u.search ? u.search.replace(/^\?/, "?index&") : "?index"), i && t !== "/" && (u.pathname = u.pathname === "/" ? t : Vu([t, u.pathname])), Cd(u);
}
function lA(n, e, t, i) {
  if (!i || !pz(i))
    return {
      path: t
    };
  if (i.formMethod && !wz(i.formMethod))
    return {
      path: t,
      error: Oa(405, {
        method: i.formMethod
      })
    };
  let r;
  if (i.formData) {
    let a = i.formMethod || "get";
    if (r = {
      formMethod: n ? a.toUpperCase() : a.toLowerCase(),
      formAction: QW(t),
      formEncType: i && i.formEncType || "application/x-www-form-urlencoded",
      formData: i.formData
    }, yu(r.formMethod))
      return {
        path: t,
        submission: r
      };
  }
  let o = Kl(t), s = ZW(i.formData);
  return e && o.search && IO(o.search) && s.append("index", ""), o.search = "?" + s, {
    path: Cd(o),
    submission: r
  };
}
function gz(n, e) {
  let t = n;
  if (e) {
    let i = n.findIndex((r) => r.route.id === e);
    i >= 0 && (t = n.slice(0, i));
  }
  return t;
}
function uA(n, e, t, i, r, o, s, a, l, u, c, h, d) {
  let f = d ? Object.values(d)[0] : h ? Object.values(h)[0] : void 0, p = n.createURL(e.location), g = n.createURL(r), _ = d ? Object.keys(d)[0] : void 0, v = gz(t, _).filter((y, b) => {
    if (y.route.lazy)
      return !0;
    if (y.route.loader == null)
      return !1;
    if (mz(e.loaderData, e.matches[b], y) || s.some((E) => E === y.route.id))
      return !0;
    let L = e.matches[b], S = y;
    return cA(y, li({
      currentUrl: p,
      currentParams: L.params,
      nextUrl: g,
      nextParams: S.params
    }, i, {
      actionResult: f,
      defaultShouldRevalidate: (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        o || // Clicked the same link, resubmitted a GET form
        p.pathname + p.search === g.pathname + g.search || // Search params affect all loaders
        p.search !== g.search || XW(L, S)
      )
    }));
  }), C = [];
  return l.forEach((y, b) => {
    if (!t.some((D) => D.route.id === y.routeId))
      return;
    let L = Vf(u, y.path, c);
    if (!L) {
      C.push({
        key: b,
        routeId: y.routeId,
        path: y.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let S = c1(L, y.path);
    if (a.includes(b)) {
      C.push({
        key: b,
        routeId: y.routeId,
        path: y.path,
        matches: L,
        match: S,
        controller: new AbortController()
      });
      return;
    }
    cA(S, li({
      currentUrl: p,
      currentParams: e.matches[e.matches.length - 1].params,
      nextUrl: g,
      nextParams: t[t.length - 1].params
    }, i, {
      actionResult: f,
      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
      defaultShouldRevalidate: o
    })) && C.push({
      key: b,
      routeId: y.routeId,
      path: y.path,
      matches: L,
      match: S,
      controller: new AbortController()
    });
  }), [v, C];
}
function mz(n, e, t) {
  let i = (
    // [a] -> [a, b]
    !e || // [a, b] -> [a, c]
    t.route.id !== e.route.id
  ), r = n[t.route.id] === void 0;
  return i || r;
}
function XW(n, e) {
  let t = n.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    n.pathname !== e.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    t != null && t.endsWith("*") && n.params["*"] !== e.params["*"]
  );
}
function cA(n, e) {
  if (n.route.shouldRevalidate) {
    let t = n.route.shouldRevalidate(e);
    if (typeof t == "boolean")
      return t;
  }
  return e.defaultShouldRevalidate;
}
async function hA(n, e, t) {
  if (!n.lazy)
    return;
  let i = await n.lazy();
  if (!n.lazy)
    return;
  let r = t[n.id];
  Wt(r, "No route found in manifest");
  let o = {};
  for (let s in i) {
    let l = r[s] !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    s !== "hasErrorBoundary";
    eh(!l, 'Route "' + r.id + '" has a static property "' + s + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + s + '" will be ignored.')), !l && !VU.has(s) && (o[s] = i[s]);
  }
  Object.assign(r, o), Object.assign(r, li({}, e(r), {
    lazy: void 0
  }));
}
async function Xg(n, e, t, i, r, o, s, a, l, u) {
  a === void 0 && (a = !1), l === void 0 && (l = !1);
  let c, h, d, f = (_) => {
    let m, v = new Promise((C, y) => m = y);
    return d = () => m(), e.signal.addEventListener("abort", d), Promise.race([_({
      request: e,
      params: t.params,
      context: u
    }), v]);
  };
  try {
    let _ = t.route[n];
    if (t.route.lazy)
      if (_)
        h = (await Promise.all([f(_), hA(t.route, o, r)]))[0];
      else if (await hA(t.route, o, r), _ = t.route[n], _)
        h = await f(_);
      else if (n === "action") {
        let m = new URL(e.url), v = m.pathname + m.search;
        throw Oa(405, {
          method: e.method,
          pathname: v,
          routeId: t.route.id
        });
      } else
        return {
          type: cr.data,
          data: void 0
        };
    else if (_)
      h = await f(_);
    else {
      let m = new URL(e.url), v = m.pathname + m.search;
      throw Oa(404, {
        pathname: v
      });
    }
    Wt(h !== void 0, "You defined " + (n === "action" ? "an action" : "a loader") + " for route " + ('"' + t.route.id + "\" but didn't return anything from your `" + n + "` ") + "function. Please return a value or `null`.");
  } catch (_) {
    c = cr.error, h = _;
  } finally {
    d && e.signal.removeEventListener("abort", d);
  }
  if (yz(h)) {
    let _ = h.status;
    if (uz.has(_)) {
      let C = h.headers.get("Location");
      if (Wt(C, "Redirects returned/thrown from loaders/actions must have a Location header"), !YW.test(C))
        C = u1(new URL(e.url), i.slice(0, i.indexOf(t) + 1), s, !0, C);
      else if (!a) {
        let y = new URL(e.url), b = C.startsWith("//") ? new URL(y.protocol + C) : new URL(C), L = og(b.pathname, s) != null;
        b.origin === y.origin && L && (C = b.pathname + b.search + b.hash);
      }
      if (a)
        throw h.headers.set("Location", C), h;
      return {
        type: cr.redirect,
        status: _,
        location: C,
        revalidate: h.headers.get("X-Remix-Revalidate") !== null
      };
    }
    if (l)
      throw {
        type: c || cr.data,
        response: h
      };
    let m, v = h.headers.get("Content-Type");
    return v && /\bapplication\/json\b/.test(v) ? m = await h.json() : m = await h.text(), c === cr.error ? {
      type: c,
      error: new NO(_, h.statusText, m),
      headers: h.headers
    } : {
      type: cr.data,
      data: m,
      statusCode: h.status,
      headers: h.headers
    };
  }
  if (c === cr.error)
    return {
      type: c,
      error: h
    };
  if (Cz(h)) {
    var p, g;
    return {
      type: cr.deferred,
      deferredData: h,
      statusCode: (p = h.init) == null ? void 0 : p.status,
      headers: ((g = h.init) == null ? void 0 : g.headers) && new Headers(h.init.headers)
    };
  }
  return {
    type: cr.data,
    data: h
  };
}
function Zg(n, e, t, i) {
  let r = n.createURL(QW(e)).toString(), o = {
    signal: t
  };
  if (i && yu(i.formMethod)) {
    let {
      formMethod: s,
      formEncType: a,
      formData: l
    } = i;
    o.method = s.toUpperCase(), o.body = a === "application/x-www-form-urlencoded" ? ZW(l) : l;
  }
  return new Request(r, o);
}
function ZW(n) {
  let e = new URLSearchParams();
  for (let [t, i] of n.entries())
    e.append(t, i instanceof File ? i.name : i);
  return e;
}
function vz(n, e, t, i, r) {
  let o = {}, s = null, a, l = !1, u = {};
  return t.forEach((c, h) => {
    let d = e[h].route.id;
    if (Wt(!ip(c), "Cannot handle redirect results in processLoaderData"), qm(c)) {
      let f = Bf(n, d), p = c.error;
      i && (p = Object.values(i)[0], i = void 0), s = s || {}, s[f.route.id] == null && (s[f.route.id] = p), o[d] = void 0, l || (l = !0, a = KW(c.error) ? c.error.status : 500), c.headers && (u[d] = c.headers);
    } else
      Xh(c) ? (r.set(d, c.deferredData), o[d] = c.deferredData.data) : o[d] = c.data, c.statusCode != null && c.statusCode !== 200 && !l && (a = c.statusCode), c.headers && (u[d] = c.headers);
  }), i && (s = i, o[Object.keys(i)[0]] = void 0), {
    loaderData: o,
    errors: s,
    statusCode: a || 200,
    loaderHeaders: u
  };
}
function dA(n, e, t, i, r, o, s, a) {
  let {
    loaderData: l,
    errors: u
  } = vz(e, t, i, r, a);
  for (let c = 0; c < o.length; c++) {
    let {
      key: h,
      match: d,
      controller: f
    } = o[c];
    Wt(s !== void 0 && s[c] !== void 0, "Did not find corresponding fetcher result");
    let p = s[c];
    if (!(f && f.signal.aborted))
      if (qm(p)) {
        let g = Bf(n.matches, d == null ? void 0 : d.route.id);
        u && u[g.route.id] || (u = li({}, u, {
          [g.route.id]: p.error
        })), n.fetchers.delete(h);
      } else if (ip(p))
        Wt(!1, "Unhandled fetcher revalidation redirect");
      else if (Xh(p))
        Wt(!1, "Unhandled fetcher deferred data");
      else {
        let g = {
          state: "idle",
          data: p.data,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          " _hasFetcherDoneAnything ": !0
        };
        n.fetchers.set(h, g);
      }
  }
  return {
    loaderData: l,
    errors: u
  };
}
function fA(n, e, t, i) {
  let r = li({}, e);
  for (let o of t) {
    let s = o.route.id;
    if (e.hasOwnProperty(s) ? e[s] !== void 0 && (r[s] = e[s]) : n[s] !== void 0 && o.route.loader && (r[s] = n[s]), i && i.hasOwnProperty(s))
      break;
  }
  return r;
}
function Bf(n, e) {
  return (e ? n.slice(0, n.findIndex((i) => i.route.id === e) + 1) : [...n]).reverse().find((i) => i.route.hasErrorBoundary === !0) || n[0];
}
function pA(n) {
  let e = n.find((t) => t.index || !t.path || t.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route: e
    }],
    route: e
  };
}
function Oa(n, e) {
  let {
    pathname: t,
    routeId: i,
    method: r,
    type: o
  } = e === void 0 ? {} : e, s = "Unknown Server Error", a = "Unknown @remix-run/router error";
  return n === 400 ? (s = "Bad Request", r && t && i ? a = "You made a " + r + ' request to "' + t + '" but ' + ('did not provide a `loader` for route "' + i + '", ') + "so there is no way to handle the request." : o === "defer-action" && (a = "defer() is not supported in actions")) : n === 403 ? (s = "Forbidden", a = 'Route "' + i + '" does not match URL "' + t + '"') : n === 404 ? (s = "Not Found", a = 'No route matches URL "' + t + '"') : n === 405 && (s = "Method Not Allowed", r && t && i ? a = "You made a " + r.toUpperCase() + ' request to "' + t + '" but ' + ('did not provide an `action` for route "' + i + '", ') + "so there is no way to handle the request." : r && (a = 'Invalid request method "' + r.toUpperCase() + '"')), new NO(n || 500, s, new Error(a), !0);
}
function gA(n) {
  for (let e = n.length - 1; e >= 0; e--) {
    let t = n[e];
    if (ip(t))
      return t;
  }
}
function QW(n) {
  let e = typeof n == "string" ? Kl(n) : n;
  return Cd(li({}, e, {
    hash: ""
  }));
}
function _z(n, e) {
  return n.pathname !== e.pathname || n.search !== e.search ? !1 : n.hash === "" ? e.hash !== "" : n.hash === e.hash ? !0 : e.hash !== "";
}
function Xh(n) {
  return n.type === cr.deferred;
}
function qm(n) {
  return n.type === cr.error;
}
function ip(n) {
  return (n && n.type) === cr.redirect;
}
function Cz(n) {
  let e = n;
  return e && typeof e == "object" && typeof e.data == "object" && typeof e.subscribe == "function" && typeof e.cancel == "function" && typeof e.resolveData == "function";
}
function yz(n) {
  return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.headers == "object" && typeof n.body < "u";
}
function wz(n) {
  return lz.has(n.toLowerCase());
}
function yu(n) {
  return sz.has(n.toLowerCase());
}
async function mA(n, e, t, i, r, o) {
  for (let s = 0; s < t.length; s++) {
    let a = t[s], l = e[s];
    if (!l)
      continue;
    let u = n.find((h) => h.route.id === l.route.id), c = u != null && !XW(u, l) && (o && o[l.route.id]) !== void 0;
    if (Xh(a) && (r || c)) {
      let h = i[s];
      Wt(h, "Expected an AbortSignal for revalidating fetcher deferred result"), await JW(a, h, r).then((d) => {
        d && (t[s] = d || t[s]);
      });
    }
  }
}
async function JW(n, e, t) {
  if (t === void 0 && (t = !1), !await n.deferredData.resolveData(e)) {
    if (t)
      try {
        return {
          type: cr.data,
          data: n.deferredData.unwrappedData
        };
      } catch (r) {
        return {
          type: cr.error,
          error: r
        };
      }
    return {
      type: cr.data,
      data: n.deferredData.data
    };
  }
}
function IO(n) {
  return new URLSearchParams(n).getAll("index").some((e) => e === "");
}
function vA(n, e) {
  let {
    route: t,
    pathname: i,
    params: r
  } = n;
  return {
    id: t.id,
    pathname: i,
    params: r,
    data: e[t.id],
    handle: t.handle
  };
}
function c1(n, e) {
  let t = typeof e == "string" ? Kl(e).search : e.search;
  if (n[n.length - 1].route.index && IO(t || ""))
    return n[n.length - 1];
  let i = dS(n);
  return i[i.length - 1];
}
/**
 * React Router v6.12.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function yw() {
  return yw = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, yw.apply(this, arguments);
}
const fS = /* @__PURE__ */ Se.createContext(null), eV = /* @__PURE__ */ Se.createContext(null), sg = /* @__PURE__ */ Se.createContext(null), pS = /* @__PURE__ */ Se.createContext(null), Xu = /* @__PURE__ */ Se.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
}), tV = /* @__PURE__ */ Se.createContext(null);
function bz(n, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e;
  v_() || Wt(!1);
  let {
    basename: i,
    navigator: r
  } = Se.useContext(sg), {
    hash: o,
    pathname: s,
    search: a
  } = rV(n, {
    relative: t
  }), l = s;
  return i !== "/" && (l = s === "/" ? i : Vu([i, s])), r.createHref({
    pathname: l,
    search: a,
    hash: o
  });
}
function v_() {
  return Se.useContext(pS) != null;
}
function __() {
  return v_() || Wt(!1), Se.useContext(pS).location;
}
function iV(n) {
  Se.useContext(sg).static || Se.useLayoutEffect(n);
}
function nV() {
  let {
    isDataRoute: n
  } = Se.useContext(Xu);
  return n ? Az() : Sz();
}
function Sz() {
  v_() || Wt(!1);
  let n = Se.useContext(fS), {
    basename: e,
    navigator: t
  } = Se.useContext(sg), {
    matches: i
  } = Se.useContext(Xu), {
    pathname: r
  } = __(), o = JSON.stringify(dS(i).map((l) => l.pathnameBase)), s = Se.useRef(!1);
  return iV(() => {
    s.current = !0;
  }), Se.useCallback(function(l, u) {
    if (u === void 0 && (u = {}), !s.current)
      return;
    if (typeof l == "number") {
      t.go(l);
      return;
    }
    let c = xO(l, JSON.parse(o), r, u.relative === "path");
    n == null && e !== "/" && (c.pathname = c.pathname === "/" ? e : Vu([e, c.pathname])), (u.replace ? t.replace : t.push)(c, u.state, u);
  }, [e, t, o, r, n]);
}
const Ez = /* @__PURE__ */ Se.createContext(null);
function Lz(n) {
  let e = Se.useContext(Xu).outlet;
  return e && /* @__PURE__ */ Se.createElement(Ez.Provider, {
    value: n
  }, e);
}
function P_e() {
  let {
    matches: n
  } = Se.useContext(Xu), e = n[n.length - 1];
  return e ? e.params : {};
}
function rV(n, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e, {
    matches: i
  } = Se.useContext(Xu), {
    pathname: r
  } = __(), o = JSON.stringify(dS(i).map((s) => s.pathnameBase));
  return Se.useMemo(() => xO(n, JSON.parse(o), r, t === "path"), [n, o, r, t]);
}
function A_e(n, e) {
  return oV(n, e);
}
function oV(n, e, t) {
  v_() || Wt(!1);
  let {
    navigator: i
  } = Se.useContext(sg), {
    matches: r
  } = Se.useContext(Xu), o = r[r.length - 1], s = o ? o.params : {};
  o && o.pathname;
  let a = o ? o.pathnameBase : "/";
  o && o.route;
  let l = __(), u;
  if (e) {
    var c;
    let g = typeof e == "string" ? Kl(e) : e;
    a === "/" || (c = g.pathname) != null && c.startsWith(a) || Wt(!1), u = g;
  } else
    u = l;
  let h = u.pathname || "/", d = a === "/" ? h : h.slice(a.length) || "/", f = Vf(n, {
    pathname: d
  }), p = xz(f && f.map((g) => Object.assign({}, g, {
    params: Object.assign({}, s, g.params),
    pathname: Vu([
      a,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(g.pathname).pathname : g.pathname
    ]),
    pathnameBase: g.pathnameBase === "/" ? a : Vu([
      a,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(g.pathnameBase).pathname : g.pathnameBase
    ])
  })), r, t);
  return e && p ? /* @__PURE__ */ Se.createElement(pS.Provider, {
    value: {
      location: yw({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, u),
      navigationType: Un.Pop
    }
  }, p) : p;
}
function Dz() {
  let n = Iz(), e = KW(n) ? n.status + " " + n.statusText : n instanceof Error ? n.message : JSON.stringify(n), t = n instanceof Error ? n.stack : null, r = {
    padding: "0.5rem",
    backgroundColor: "rgba(200,200,200, 0.5)"
  }, o = null;
  return /* @__PURE__ */ Se.createElement(Se.Fragment, null, /* @__PURE__ */ Se.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ Se.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, e), t ? /* @__PURE__ */ Se.createElement("pre", {
    style: r
  }, t) : null, o);
}
const Rz = /* @__PURE__ */ Se.createElement(Dz, null);
class Tz extends Se.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return {
      error: e
    };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error || t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    console.error("React Router caught the following error during render", e, t);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ Se.createElement(Xu.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ Se.createElement(tV.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function Oz(n) {
  let {
    routeContext: e,
    match: t,
    children: i
  } = n, r = Se.useContext(fS);
  return r && r.static && r.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ Se.createElement(Xu.Provider, {
    value: e
  }, i);
}
function xz(n, e, t) {
  var i;
  if (e === void 0 && (e = []), t === void 0 && (t = null), n == null) {
    var r;
    if ((r = t) != null && r.errors)
      n = t.matches;
    else
      return null;
  }
  let o = n, s = (i = t) == null ? void 0 : i.errors;
  if (s != null) {
    let a = o.findIndex((l) => l.route.id && (s == null ? void 0 : s[l.route.id]));
    a >= 0 || Wt(!1), o = o.slice(0, Math.min(o.length, a + 1));
  }
  return o.reduceRight((a, l, u) => {
    let c = l.route.id ? s == null ? void 0 : s[l.route.id] : null, h = null;
    t && (h = l.route.errorElement || Rz);
    let d = e.concat(o.slice(0, u + 1)), f = () => {
      let p;
      return c ? p = h : l.route.Component ? p = /* @__PURE__ */ Se.createElement(l.route.Component, null) : l.route.element ? p = l.route.element : p = a, /* @__PURE__ */ Se.createElement(Oz, {
        match: l,
        routeContext: {
          outlet: a,
          matches: d,
          isDataRoute: t != null
        },
        children: p
      });
    };
    return t && (l.route.ErrorBoundary || l.route.errorElement || u === 0) ? /* @__PURE__ */ Se.createElement(Tz, {
      location: t.location,
      revalidation: t.revalidation,
      component: h,
      error: c,
      children: f(),
      routeContext: {
        outlet: null,
        matches: d,
        isDataRoute: !0
      }
    }) : f();
  }, null);
}
var ww;
(function(n) {
  n.UseBlocker = "useBlocker", n.UseRevalidator = "useRevalidator", n.UseNavigateStable = "useNavigate";
})(ww || (ww = {}));
var Rp;
(function(n) {
  n.UseBlocker = "useBlocker", n.UseLoaderData = "useLoaderData", n.UseActionData = "useActionData", n.UseRouteError = "useRouteError", n.UseNavigation = "useNavigation", n.UseRouteLoaderData = "useRouteLoaderData", n.UseMatches = "useMatches", n.UseRevalidator = "useRevalidator", n.UseNavigateStable = "useNavigate", n.UseRouteId = "useRouteId";
})(Rp || (Rp = {}));
function sV(n) {
  let e = Se.useContext(fS);
  return e || Wt(!1), e;
}
function aV(n) {
  let e = Se.useContext(eV);
  return e || Wt(!1), e;
}
function Nz(n) {
  let e = Se.useContext(Xu);
  return e || Wt(!1), e;
}
function lV(n) {
  let e = Nz(), t = e.matches[e.matches.length - 1];
  return t.route.id || Wt(!1), t.route.id;
}
function Iz() {
  var n;
  let e = Se.useContext(tV), t = aV(Rp.UseRouteError), i = lV(Rp.UseRouteError);
  return e || ((n = t.errors) == null ? void 0 : n[i]);
}
let Pz = 0;
function M_e(n) {
  let {
    router: e
  } = sV(ww.UseBlocker), t = aV(Rp.UseBlocker), [i] = Se.useState(() => String(++Pz)), r = Se.useCallback((s) => typeof n == "function" ? !!n(s) : !!n, [n]), o = e.getBlocker(i, r);
  return Se.useEffect(() => () => e.deleteBlocker(i), [e, i]), t.blockers.get(i) || o;
}
function Az() {
  let {
    router: n
  } = sV(ww.UseNavigateStable), e = lV(Rp.UseNavigateStable), t = Se.useRef(!1);
  return iV(() => {
    t.current = !0;
  }), Se.useCallback(function(r, o) {
    o === void 0 && (o = {}), t.current && (typeof r == "number" ? n.navigate(r) : n.navigate(r, yw({
      fromRouteId: e
    }, o)));
  }, [n, e]);
}
const _A = "startTransition";
function F_e(n) {
  let {
    fallbackElement: e,
    router: t
  } = n, [i, r] = Se.useState(t.state), o = Se.useCallback((u) => {
    _A in Se ? Se[_A](() => r(u)) : r(u);
  }, [r]);
  Se.useLayoutEffect(() => t.subscribe(o), [t, o]);
  let s = Se.useMemo(() => ({
    createHref: t.createHref,
    encodeLocation: t.encodeLocation,
    go: (u) => t.navigate(u),
    push: (u, c, h) => t.navigate(u, {
      state: c,
      preventScrollReset: h == null ? void 0 : h.preventScrollReset
    }),
    replace: (u, c, h) => t.navigate(u, {
      replace: !0,
      state: c,
      preventScrollReset: h == null ? void 0 : h.preventScrollReset
    })
  }), [t]), a = t.basename || "/", l = Se.useMemo(() => ({
    router: t,
    navigator: s,
    static: !1,
    basename: a
  }), [t, s, a]);
  return /* @__PURE__ */ Se.createElement(Se.Fragment, null, /* @__PURE__ */ Se.createElement(fS.Provider, {
    value: l
  }, /* @__PURE__ */ Se.createElement(eV.Provider, {
    value: i
  }, /* @__PURE__ */ Se.createElement(Fz, {
    basename: a,
    location: i.location,
    navigationType: i.historyAction,
    navigator: s
  }, i.initialized ? /* @__PURE__ */ Se.createElement(Mz, {
    routes: t.routes,
    state: i
  }) : e))), null);
}
function Mz(n) {
  let {
    routes: e,
    state: t
  } = n;
  return oV(e, void 0, t);
}
function k_e(n) {
  return Lz(n.context);
}
function Fz(n) {
  let {
    basename: e = "/",
    children: t = null,
    location: i,
    navigationType: r = Un.Pop,
    navigator: o,
    static: s = !1
  } = n;
  v_() && Wt(!1);
  let a = e.replace(/^\/*/, "/"), l = Se.useMemo(() => ({
    basename: a,
    navigator: o,
    static: s
  }), [a, o, s]);
  typeof i == "string" && (i = Kl(i));
  let {
    pathname: u = "/",
    search: c = "",
    hash: h = "",
    state: d = null,
    key: f = "default"
  } = i, p = Se.useMemo(() => {
    let g = og(u, a);
    return g == null ? null : {
      location: {
        pathname: g,
        search: c,
        hash: h,
        state: d,
        key: f
      },
      navigationType: r
    };
  }, [a, u, c, h, d, f, r]);
  return p == null ? null : /* @__PURE__ */ Se.createElement(sg.Provider, {
    value: l
  }, /* @__PURE__ */ Se.createElement(pS.Provider, {
    children: t,
    value: p
  }));
}
var CA;
(function(n) {
  n[n.pending = 0] = "pending", n[n.success = 1] = "success", n[n.error = 2] = "error";
})(CA || (CA = {}));
new Promise(() => {
});
function kz(n) {
  let e = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: n.ErrorBoundary != null || n.errorElement != null
  };
  return n.Component && Object.assign(e, {
    element: /* @__PURE__ */ Se.createElement(n.Component),
    Component: void 0
  }), n.ErrorBoundary && Object.assign(e, {
    errorElement: /* @__PURE__ */ Se.createElement(n.ErrorBoundary),
    ErrorBoundary: void 0
  }), e;
}
var h1 = {}, Wz = {
  get exports() {
    return h1;
  },
  set exports(n) {
    h1 = n;
  }
};
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(n) {
  (function() {
    var e = {}.hasOwnProperty;
    function t() {
      for (var i = [], r = 0; r < arguments.length; r++) {
        var o = arguments[r];
        if (o) {
          var s = typeof o;
          if (s === "string" || s === "number")
            i.push(o);
          else if (Array.isArray(o)) {
            if (o.length) {
              var a = t.apply(null, o);
              a && i.push(a);
            }
          } else if (s === "object")
            if (o.toString === Object.prototype.toString)
              for (var l in o)
                e.call(o, l) && o[l] && i.push(l);
            else
              i.push(o.toString());
        }
      }
      return i.join(" ");
    }
    n.exports ? (t.default = t, n.exports = t) : window.classNames = t;
  })();
})(Wz);
const W_e = h1;
var od = [], Vz = function() {
  return od.some(function(n) {
    return n.activeTargets.length > 0;
  });
}, Bz = function() {
  return od.some(function(n) {
    return n.skippedTargets.length > 0;
  });
}, yA = "ResizeObserver loop completed with undelivered notifications.", Hz = function() {
  var n;
  typeof ErrorEvent == "function" ? n = new ErrorEvent("error", {
    message: yA
  }) : (n = document.createEvent("Event"), n.initEvent("error", !1, !1), n.message = yA), window.dispatchEvent(n);
}, Rv;
(function(n) {
  n.BORDER_BOX = "border-box", n.CONTENT_BOX = "content-box", n.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Rv || (Rv = {}));
var sd = function(n) {
  return Object.freeze(n);
}, Gz = function() {
  function n(e, t) {
    this.inlineSize = e, this.blockSize = t, sd(this);
  }
  return n;
}(), uV = function() {
  function n(e, t, i, r) {
    return this.x = e, this.y = t, this.width = i, this.height = r, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, sd(this);
  }
  return n.prototype.toJSON = function() {
    var e = this, t = e.x, i = e.y, r = e.top, o = e.right, s = e.bottom, a = e.left, l = e.width, u = e.height;
    return { x: t, y: i, top: r, right: o, bottom: s, left: a, width: l, height: u };
  }, n.fromRect = function(e) {
    return new n(e.x, e.y, e.width, e.height);
  }, n;
}(), PO = function(n) {
  return n instanceof SVGElement && "getBBox" in n;
}, cV = function(n) {
  if (PO(n)) {
    var e = n.getBBox(), t = e.width, i = e.height;
    return !t && !i;
  }
  var r = n, o = r.offsetWidth, s = r.offsetHeight;
  return !(o || s || n.getClientRects().length);
}, wA = function(n) {
  var e;
  if (n instanceof Element)
    return !0;
  var t = (e = n == null ? void 0 : n.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView;
  return !!(t && n instanceof t.Element);
}, Uz = function(n) {
  switch (n.tagName) {
    case "INPUT":
      if (n.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, Ym = typeof window < "u" ? window : {}, EC = /* @__PURE__ */ new WeakMap(), bA = /auto|scroll/, zz = /^tb|vertical/, jz = /msie|trident/i.test(Ym.navigator && Ym.navigator.userAgent), _l = function(n) {
  return parseFloat(n || "0");
}, np = function(n, e, t) {
  return n === void 0 && (n = 0), e === void 0 && (e = 0), t === void 0 && (t = !1), new Gz((t ? e : n) || 0, (t ? n : e) || 0);
}, SA = sd({
  devicePixelContentBoxSize: np(),
  borderBoxSize: np(),
  contentBoxSize: np(),
  contentRect: new uV(0, 0, 0, 0)
}), hV = function(n, e) {
  if (e === void 0 && (e = !1), EC.has(n) && !e)
    return EC.get(n);
  if (cV(n))
    return EC.set(n, SA), SA;
  var t = getComputedStyle(n), i = PO(n) && n.ownerSVGElement && n.getBBox(), r = !jz && t.boxSizing === "border-box", o = zz.test(t.writingMode || ""), s = !i && bA.test(t.overflowY || ""), a = !i && bA.test(t.overflowX || ""), l = i ? 0 : _l(t.paddingTop), u = i ? 0 : _l(t.paddingRight), c = i ? 0 : _l(t.paddingBottom), h = i ? 0 : _l(t.paddingLeft), d = i ? 0 : _l(t.borderTopWidth), f = i ? 0 : _l(t.borderRightWidth), p = i ? 0 : _l(t.borderBottomWidth), g = i ? 0 : _l(t.borderLeftWidth), _ = h + u, m = l + c, v = g + f, C = d + p, y = a ? n.offsetHeight - C - n.clientHeight : 0, b = s ? n.offsetWidth - v - n.clientWidth : 0, L = r ? _ + v : 0, S = r ? m + C : 0, E = i ? i.width : _l(t.width) - L - b, D = i ? i.height : _l(t.height) - S - y, O = E + _ + b + v, T = D + m + y + C, A = sd({
    devicePixelContentBoxSize: np(Math.round(E * devicePixelRatio), Math.round(D * devicePixelRatio), o),
    borderBoxSize: np(O, T, o),
    contentBoxSize: np(E, D, o),
    contentRect: new uV(h, l, E, D)
  });
  return EC.set(n, A), A;
}, dV = function(n, e, t) {
  var i = hV(n, t), r = i.borderBoxSize, o = i.contentBoxSize, s = i.devicePixelContentBoxSize;
  switch (e) {
    case Rv.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case Rv.BORDER_BOX:
      return r;
    default:
      return o;
  }
}, $z = function() {
  function n(e) {
    var t = hV(e);
    this.target = e, this.contentRect = t.contentRect, this.borderBoxSize = sd([t.borderBoxSize]), this.contentBoxSize = sd([t.contentBoxSize]), this.devicePixelContentBoxSize = sd([t.devicePixelContentBoxSize]);
  }
  return n;
}(), fV = function(n) {
  if (cV(n))
    return 1 / 0;
  for (var e = 0, t = n.parentNode; t; )
    e += 1, t = t.parentNode;
  return e;
}, Kz = function() {
  var n = 1 / 0, e = [];
  od.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var a = [];
      s.activeTargets.forEach(function(u) {
        var c = new $z(u.target), h = fV(u.target);
        a.push(c), u.lastReportedSize = dV(u.target, u.observedBox), h < n && (n = h);
      }), e.push(function() {
        s.callback.call(s.observer, a, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var t = 0, i = e; t < i.length; t++) {
    var r = i[t];
    r();
  }
  return n;
}, EA = function(n) {
  od.forEach(function(t) {
    t.activeTargets.splice(0, t.activeTargets.length), t.skippedTargets.splice(0, t.skippedTargets.length), t.observationTargets.forEach(function(r) {
      r.isActive() && (fV(r.target) > n ? t.activeTargets.push(r) : t.skippedTargets.push(r));
    });
  });
}, qz = function() {
  var n = 0;
  for (EA(n); Vz(); )
    n = Kz(), EA(n);
  return Bz() && Hz(), n > 0;
}, HE, pV = [], Yz = function() {
  return pV.splice(0).forEach(function(n) {
    return n();
  });
}, Xz = function(n) {
  if (!HE) {
    var e = 0, t = document.createTextNode(""), i = { characterData: !0 };
    new MutationObserver(function() {
      return Yz();
    }).observe(t, i), HE = function() {
      t.textContent = "".concat(e ? e-- : e++);
    };
  }
  pV.push(n), HE();
}, Zz = function(n) {
  Xz(function() {
    requestAnimationFrame(n);
  });
}, Gy = 0, Qz = function() {
  return !!Gy;
}, Jz = 250, e6 = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, LA = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], DA = function(n) {
  return n === void 0 && (n = 0), Date.now() + n;
}, GE = !1, t6 = function() {
  function n() {
    var e = this;
    this.stopped = !0, this.listener = function() {
      return e.schedule();
    };
  }
  return n.prototype.run = function(e) {
    var t = this;
    if (e === void 0 && (e = Jz), !GE) {
      GE = !0;
      var i = DA(e);
      Zz(function() {
        var r = !1;
        try {
          r = qz();
        } finally {
          if (GE = !1, e = i - DA(), !Qz())
            return;
          r ? t.run(1e3) : e > 0 ? t.run(e) : t.start();
        }
      });
    }
  }, n.prototype.schedule = function() {
    this.stop(), this.run();
  }, n.prototype.observe = function() {
    var e = this, t = function() {
      return e.observer && e.observer.observe(document.body, e6);
    };
    document.body ? t() : Ym.addEventListener("DOMContentLoaded", t);
  }, n.prototype.start = function() {
    var e = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), LA.forEach(function(t) {
      return Ym.addEventListener(t, e.listener, !0);
    }));
  }, n.prototype.stop = function() {
    var e = this;
    this.stopped || (this.observer && this.observer.disconnect(), LA.forEach(function(t) {
      return Ym.removeEventListener(t, e.listener, !0);
    }), this.stopped = !0);
  }, n;
}(), d1 = new t6(), RA = function(n) {
  !Gy && n > 0 && d1.start(), Gy += n, !Gy && d1.stop();
}, i6 = function(n) {
  return !PO(n) && !Uz(n) && getComputedStyle(n).display === "inline";
}, n6 = function() {
  function n(e, t) {
    this.target = e, this.observedBox = t || Rv.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return n.prototype.isActive = function() {
    var e = dV(this.target, this.observedBox, !0);
    return i6(this.target) && (this.lastReportedSize = e), this.lastReportedSize.inlineSize !== e.inlineSize || this.lastReportedSize.blockSize !== e.blockSize;
  }, n;
}(), r6 = function() {
  function n(e, t) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = e, this.callback = t;
  }
  return n;
}(), LC = /* @__PURE__ */ new WeakMap(), TA = function(n, e) {
  for (var t = 0; t < n.length; t += 1)
    if (n[t].target === e)
      return t;
  return -1;
}, DC = function() {
  function n() {
  }
  return n.connect = function(e, t) {
    var i = new r6(e, t);
    LC.set(e, i);
  }, n.observe = function(e, t, i) {
    var r = LC.get(e), o = r.observationTargets.length === 0;
    TA(r.observationTargets, t) < 0 && (o && od.push(r), r.observationTargets.push(new n6(t, i && i.box)), RA(1), d1.schedule());
  }, n.unobserve = function(e, t) {
    var i = LC.get(e), r = TA(i.observationTargets, t), o = i.observationTargets.length === 1;
    r >= 0 && (o && od.splice(od.indexOf(i), 1), i.observationTargets.splice(r, 1), RA(-1));
  }, n.disconnect = function(e) {
    var t = this, i = LC.get(e);
    i.observationTargets.slice().forEach(function(r) {
      return t.unobserve(e, r.target);
    }), i.activeTargets.splice(0, i.activeTargets.length);
  }, n;
}(), o6 = function() {
  function n(e) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof e != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    DC.connect(this, e);
  }
  return n.prototype.observe = function(e, t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!wA(e))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    DC.observe(this, e, t);
  }, n.prototype.unobserve = function(e) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!wA(e))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    DC.unobserve(this, e);
  }, n.prototype.disconnect = function() {
    DC.disconnect(this);
  }, n.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, n;
}();
const s6 = wt[typeof document < "u" && document.createElement !== void 0 ? "useLayoutEffect" : "useEffect"], a6 = s6, l6 = (n) => {
  const e = Se.useRef(n);
  return Se.useEffect(() => {
    e.current = n;
  }), e;
}, u6 = l6, c6 = typeof window < "u" && "ResizeObserver" in window ? (
  // @ts-ignore
  window.ResizeObserver
) : o6;
function h6() {
}
function V_e(n, e) {
  const t = f6(), i = u6(e);
  return a6(() => {
    let r = !1;
    const o = n && "current" in n ? n.current : n;
    if (!o)
      return h6;
    function s(a, l) {
      r || i.current(a, l);
    }
    return t.subscribe(o, s), () => {
      r = !0, t.unsubscribe(o, s);
    };
  }, [n, t, i]), t.observer;
}
function d6() {
  let n = !1, e = [];
  const t = /* @__PURE__ */ new Map(), i = new c6((r, o) => {
    e = e.concat(r);
    function s() {
      const a = /* @__PURE__ */ new Set();
      for (let l = 0; l < e.length; l++) {
        if (a.has(e[l].target))
          continue;
        a.add(e[l].target);
        const u = t.get(e[l].target);
        u == null || u.forEach((c) => c(e[l], o));
      }
      e = [], n = !1;
    }
    n || window.requestAnimationFrame(s), n = !0;
  });
  return {
    observer: i,
    subscribe(r, o) {
      var s;
      i.observe(r);
      const a = (s = t.get(r)) !== null && s !== void 0 ? s : [];
      a.push(o), t.set(r, a);
    },
    unsubscribe(r, o) {
      var s;
      const a = (s = t.get(r)) !== null && s !== void 0 ? s : [];
      if (a.length === 1) {
        i.unobserve(r), t.delete(r);
        return;
      }
      const l = a.indexOf(o);
      l !== -1 && a.splice(l, 1), t.set(r, a);
    }
  };
}
let UE;
const f6 = () => UE || (UE = d6());
var gV = {}, mV = {}, ju = {}, p6 = {
  get exports() {
    return ju;
  },
  set exports(n) {
    ju = n;
  }
}, g6 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", m6 = g6, v6 = m6;
function vV() {
}
function _V() {
}
_V.resetWarningCache = vV;
var _6 = function() {
  function n(i, r, o, s, a, l) {
    if (l !== v6) {
      var u = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw u.name = "Invariant Violation", u;
    }
  }
  n.isRequired = n;
  function e() {
    return n;
  }
  var t = {
    array: n,
    bigint: n,
    bool: n,
    func: n,
    number: n,
    object: n,
    string: n,
    symbol: n,
    any: n,
    arrayOf: e,
    element: n,
    elementType: n,
    instanceOf: e,
    node: n,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: _V,
    resetWarningCache: vV
  };
  return t.PropTypes = t, t;
};
p6.exports = _6();
(function(n) {
  var e = Ne && Ne.__extends || function() {
    var a = function(l, u) {
      return a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, h) {
        c.__proto__ = h;
      } || function(c, h) {
        for (var d in h)
          h.hasOwnProperty(d) && (c[d] = h[d]);
      }, a(l, u);
    };
    return function(l, u) {
      a(l, u);
      function c() {
        this.constructor = l;
      }
      l.prototype = u === null ? Object.create(u) : (c.prototype = u.prototype, new c());
    };
  }(), t = Ne && Ne.__assign || function() {
    return t = Object.assign || function(a) {
      for (var l, u = 1, c = arguments.length; u < c; u++) {
        l = arguments[u];
        for (var h in l)
          Object.prototype.hasOwnProperty.call(l, h) && (a[h] = l[h]);
      }
      return a;
    }, t.apply(this, arguments);
  }, i = Ne && Ne.__rest || function(a, l) {
    var u = {};
    for (var c in a)
      Object.prototype.hasOwnProperty.call(a, c) && l.indexOf(c) < 0 && (u[c] = a[c]);
    if (a != null && typeof Object.getOwnPropertySymbols == "function")
      for (var h = 0, c = Object.getOwnPropertySymbols(a); h < c.length; h++)
        l.indexOf(c[h]) < 0 && Object.prototype.propertyIsEnumerable.call(a, c[h]) && (u[c[h]] = a[c[h]]);
    return u;
  };
  n.__esModule = !0, n.FlexView = n.FlexViewInternal = void 0;
  var r = wt, o = ju, s = (
    /** @class */
    function(a) {
      e(l, a);
      function l() {
        return a !== null && a.apply(this, arguments) || this;
      }
      return l.prototype.componentDidMount = function() {
        this.logWarnings();
      }, l.prototype.logWarnings = function() {
        var u = this.props;
        u.basis, u.hAlignContent, u.vAlignContent, u.children, u.column;
      }, l.prototype.getGrow = function() {
        var u = this.props.grow;
        return typeof u == "number" ? u : u ? 1 : 0;
      }, l.prototype.getShrink = function() {
        var u = this.props, c = u.shrink, h = u.basis;
        return typeof c == "number" ? c : c ? 1 : c === !1 || h && h !== "auto" ? 0 : 1;
      }, l.prototype.getBasis = function() {
        var u = this.props.basis;
        if (u) {
          var c = typeof u == "number" || String(parseInt(u, 10)) === u ? "px" : "";
          return u + c;
        }
        return "auto";
      }, l.prototype.getStyle = function() {
        var u = this.props, c = u.column, h = u.wrap, d = u.vAlignContent, f = u.hAlignContent, p = {
          width: this.props.width,
          height: this.props.height,
          marginLeft: this.props.marginLeft,
          marginTop: this.props.marginTop,
          marginRight: this.props.marginRight,
          marginBottom: this.props.marginBottom
        };
        function g(_) {
          switch (_) {
            case "top":
            case "left":
              return "flex-start";
            case "center":
              return "center";
            case "bottom":
            case "right":
              return "flex-end";
          }
        }
        return t(t({
          boxSizing: "border-box",
          // some browsers don't set these by default on flex
          minWidth: 0,
          minHeight: 0,
          // flex properties
          display: "flex",
          flexDirection: c ? "column" : "row",
          flexWrap: h ? "wrap" : "nowrap",
          flex: this.getGrow() + " " + this.getShrink() + " " + this.getBasis(),
          justifyContent: g(c ? d : f),
          alignItems: g(c ? f : d)
        }, p), this.props.style);
      }, l.prototype.getElementProps = function() {
        var u = this.props;
        u.children, u.className, u.style, u.column, u.grow, u.shrink, u.basis, u.wrap, u.vAlignContent, u.hAlignContent, u.width, u.height, u.marginBottom, u.marginTop, u.marginLeft, u.marginRight, u.componentRef, u.component;
        var c = i(u, ["children", "className", "style", "column", "grow", "shrink", "basis", "wrap", "vAlignContent", "hAlignContent", "width", "height", "marginBottom", "marginTop", "marginLeft", "marginRight", "componentRef", "component"]);
        return c;
      }, l.prototype.render = function() {
        return r.createElement(this.props.component || "div", t({ ref: this.props.componentRef, className: this.props.className, style: this.getStyle(), children: this.props.children }, this.getElementProps()));
      }, l.propTypes = {
        children: o.node,
        column: o.bool,
        vAlignContent: o.oneOf(["top", "center", "bottom"]),
        hAlignContent: o.oneOf(["left", "center", "right"]),
        marginLeft: o.oneOfType([o.string, o.number]),
        marginTop: o.oneOfType([o.string, o.number]),
        marginRight: o.oneOfType([o.string, o.number]),
        marginBottom: o.oneOfType([o.string, o.number]),
        grow: o.oneOfType([o.bool, o.number]),
        shrink: o.oneOfType([o.bool, o.number]),
        basis: o.oneOfType([o.string, o.number]),
        wrap: o.bool,
        height: o.oneOfType([o.string, o.number]),
        width: o.oneOfType([o.string, o.number]),
        className: o.string,
        style: o.object,
        component: o.elementType
      }, l;
    }(r.Component)
  );
  n.FlexViewInternal = s, n.FlexView = r.forwardRef(function(a, l) {
    return r.createElement(s, t({}, a, { componentRef: l }));
  }), n.default = n.FlexView;
})(mV);
(function(n) {
  n.__esModule = !0;
  var e = mV;
  n.default = e.FlexView;
})(gV);
const B_e = /* @__PURE__ */ zW(gV);
var bw = {}, C6 = {
  get exports() {
    return bw;
  },
  set exports(n) {
    bw = n;
  }
}, yd = {}, Sw = {}, y6 = {
  get exports() {
    return Sw;
  },
  set exports(n) {
    Sw = n;
  }
}, Ja = {}, Tv = {}, w6 = {
  get exports() {
    return Tv;
  },
  set exports(n) {
    Tv = n;
  }
};
(function(n, e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = a;
  /*!
   * Adapted from jQuery UI core
   *
   * http://jqueryui.com
   *
   * Copyright 2014 jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/category/ui-core/
   */
  var t = /input|select|textarea|button|object|iframe/;
  function i(l) {
    var u = l.offsetWidth <= 0 && l.offsetHeight <= 0;
    if (u && !l.innerHTML)
      return !0;
    try {
      var c = window.getComputedStyle(l);
      return u ? c.getPropertyValue("overflow") !== "visible" || // if 'overflow: visible' set, check if there is actually any overflow
      l.scrollWidth <= 0 && l.scrollHeight <= 0 : c.getPropertyValue("display") == "none";
    } catch {
      return console.warn("Failed to inspect element style"), !1;
    }
  }
  function r(l) {
    for (var u = l, c = l.getRootNode && l.getRootNode(); u && u !== document.body; ) {
      if (c && u === c && (u = c.host.parentNode), i(u))
        return !1;
      u = u.parentNode;
    }
    return !0;
  }
  function o(l, u) {
    var c = l.nodeName.toLowerCase(), h = t.test(c) && !l.disabled || c === "a" && l.href || u;
    return h && r(l);
  }
  function s(l) {
    var u = l.getAttribute("tabindex");
    u === null && (u = void 0);
    var c = isNaN(u);
    return (c || u >= 0) && o(l, !c);
  }
  function a(l) {
    var u = [].slice.call(l.querySelectorAll("*"), 0).reduce(function(c, h) {
      return c.concat(h.shadowRoot ? a(h.shadowRoot) : [h]);
    }, []);
    return u.filter(s);
  }
  n.exports = e.default;
})(w6, Tv);
Object.defineProperty(Ja, "__esModule", {
  value: !0
});
Ja.resetState = L6;
Ja.log = D6;
Ja.handleBlur = Ov;
Ja.handleFocus = xv;
Ja.markForFocusLater = R6;
Ja.returnFocus = T6;
Ja.popWithoutFocus = O6;
Ja.setupScopedFocus = x6;
Ja.teardownScopedFocus = N6;
var b6 = Tv, S6 = E6(b6);
function E6(n) {
  return n && n.__esModule ? n : { default: n };
}
var Tp = [], Hf = null, f1 = !1;
function L6() {
  Tp = [];
}
function D6() {
}
function Ov() {
  f1 = !0;
}
function xv() {
  if (f1) {
    if (f1 = !1, !Hf)
      return;
    setTimeout(function() {
      if (!Hf.contains(document.activeElement)) {
        var n = (0, S6.default)(Hf)[0] || Hf;
        n.focus();
      }
    }, 0);
  }
}
function R6() {
  Tp.push(document.activeElement);
}
function T6() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, e = null;
  try {
    Tp.length !== 0 && (e = Tp.pop(), e.focus({ preventScroll: n }));
    return;
  } catch {
    console.warn(["You tried to return focus to", e, "but it is not in the DOM anymore"].join(" "));
  }
}
function O6() {
  Tp.length > 0 && Tp.pop();
}
function x6(n) {
  Hf = n, window.addEventListener ? (window.addEventListener("blur", Ov, !1), document.addEventListener("focus", xv, !0)) : (window.attachEvent("onBlur", Ov), document.attachEvent("onFocus", xv));
}
function N6() {
  Hf = null, window.addEventListener ? (window.removeEventListener("blur", Ov), document.removeEventListener("focus", xv)) : (window.detachEvent("onBlur", Ov), document.detachEvent("onFocus", xv));
}
var Ew = {}, I6 = {
  get exports() {
    return Ew;
  },
  set exports(n) {
    Ew = n;
  }
};
(function(n, e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = s;
  var t = Tv, i = r(t);
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function o() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
    return a.activeElement.shadowRoot ? o(a.activeElement.shadowRoot) : a.activeElement;
  }
  function s(a, l) {
    var u = (0, i.default)(a);
    if (!u.length) {
      l.preventDefault();
      return;
    }
    var c = void 0, h = l.shiftKey, d = u[0], f = u[u.length - 1], p = o();
    if (a === p) {
      if (!h)
        return;
      c = f;
    }
    if (f === p && !h && (c = d), d === p && h && (c = f), c) {
      l.preventDefault(), c.focus();
      return;
    }
    var g = /(\bChrome\b|\bSafari\b)\//.exec(navigator.userAgent), _ = g != null && g[1] != "Chrome" && /\biPod\b|\biPad\b/g.exec(navigator.userAgent) == null;
    if (_) {
      var m = u.indexOf(p);
      if (m > -1 && (m += h ? -1 : 1), c = u[m], typeof c > "u") {
        l.preventDefault(), c = h ? f : d, c.focus();
        return;
      }
      l.preventDefault(), c.focus();
    }
  }
  n.exports = e.default;
})(I6, Ew);
var el = {}, P6 = function() {
}, A6 = P6, qa = {}, p1 = {}, M6 = {
  get exports() {
    return p1;
  },
  set exports(n) {
    p1 = n;
  }
};
/*!
  Copyright (c) 2015 Jed Watson.
  Based on code that is Copyright 2013-2015, Facebook, Inc.
  All rights reserved.
*/
(function(n) {
  (function() {
    var e = !!(typeof window < "u" && window.document && window.document.createElement), t = {
      canUseDOM: e,
      canUseWorkers: typeof Worker < "u",
      canUseEventListeners: e && !!(window.addEventListener || window.attachEvent),
      canUseViewport: e && !!window.screen
    };
    n.exports ? n.exports = t : window.ExecutionEnvironment = t;
  })();
})(M6);
Object.defineProperty(qa, "__esModule", {
  value: !0
});
qa.canUseDOM = qa.SafeNodeList = qa.SafeHTMLCollection = void 0;
var F6 = p1, k6 = W6(F6);
function W6(n) {
  return n && n.__esModule ? n : { default: n };
}
var gS = k6.default, V6 = gS.canUseDOM ? window.HTMLElement : {};
qa.SafeHTMLCollection = gS.canUseDOM ? window.HTMLCollection : {};
qa.SafeNodeList = gS.canUseDOM ? window.NodeList : {};
qa.canUseDOM = gS.canUseDOM;
qa.default = V6;
Object.defineProperty(el, "__esModule", {
  value: !0
});
el.resetState = z6;
el.log = j6;
el.assertNodeList = CV;
el.setElement = $6;
el.validateElement = AO;
el.hide = K6;
el.show = q6;
el.documentNotReadyOrSSRTesting = Y6;
var B6 = A6, H6 = U6(B6), G6 = qa;
function U6(n) {
  return n && n.__esModule ? n : { default: n };
}
var ia = null;
function z6() {
  ia && (ia.removeAttribute ? ia.removeAttribute("aria-hidden") : ia.length != null ? ia.forEach(function(n) {
    return n.removeAttribute("aria-hidden");
  }) : document.querySelectorAll(ia).forEach(function(n) {
    return n.removeAttribute("aria-hidden");
  })), ia = null;
}
function j6() {
}
function CV(n, e) {
  if (!n || !n.length)
    throw new Error("react-modal: No elements were found for selector " + e + ".");
}
function $6(n) {
  var e = n;
  if (typeof e == "string" && G6.canUseDOM) {
    var t = document.querySelectorAll(e);
    CV(t, e), e = t;
  }
  return ia = e || ia, ia;
}
function AO(n) {
  var e = n || ia;
  return e ? Array.isArray(e) || e instanceof HTMLCollection || e instanceof NodeList ? e : [e] : ((0, H6.default)(!1, ["react-modal: App element is not defined.", "Please use `Modal.setAppElement(el)` or set `appElement={el}`.", "This is needed so screen readers don't see main content", "when modal is opened. It is not recommended, but you can opt-out", "by setting `ariaHideApp={false}`."].join(" ")), []);
}
function K6(n) {
  var e = !0, t = !1, i = void 0;
  try {
    for (var r = AO(n)[Symbol.iterator](), o; !(e = (o = r.next()).done); e = !0) {
      var s = o.value;
      s.setAttribute("aria-hidden", "true");
    }
  } catch (a) {
    t = !0, i = a;
  } finally {
    try {
      !e && r.return && r.return();
    } finally {
      if (t)
        throw i;
    }
  }
}
function q6(n) {
  var e = !0, t = !1, i = void 0;
  try {
    for (var r = AO(n)[Symbol.iterator](), o; !(e = (o = r.next()).done); e = !0) {
      var s = o.value;
      s.removeAttribute("aria-hidden");
    }
  } catch (a) {
    t = !0, i = a;
  } finally {
    try {
      !e && r.return && r.return();
    } finally {
      if (t)
        throw i;
    }
  }
}
function Y6() {
  ia = null;
}
var ag = {};
Object.defineProperty(ag, "__esModule", {
  value: !0
});
ag.resetState = X6;
ag.log = Z6;
var Xm = {}, Zm = {};
function OA(n, e) {
  n.classList.remove(e);
}
function X6() {
  var n = document.getElementsByTagName("html")[0];
  for (var e in Xm)
    OA(n, Xm[e]);
  var t = document.body;
  for (var i in Zm)
    OA(t, Zm[i]);
  Xm = {}, Zm = {};
}
function Z6() {
}
var Q6 = function(e, t) {
  return e[t] || (e[t] = 0), e[t] += 1, t;
}, J6 = function(e, t) {
  return e[t] && (e[t] -= 1), t;
}, e8 = function(e, t, i) {
  i.forEach(function(r) {
    Q6(t, r), e.add(r);
  });
}, t8 = function(e, t, i) {
  i.forEach(function(r) {
    J6(t, r), t[r] === 0 && e.remove(r);
  });
};
ag.add = function(e, t) {
  return e8(e.classList, e.nodeName.toLowerCase() == "html" ? Xm : Zm, t.split(" "));
};
ag.remove = function(e, t) {
  return t8(e.classList, e.nodeName.toLowerCase() == "html" ? Xm : Zm, t.split(" "));
};
var lg = {};
Object.defineProperty(lg, "__esModule", {
  value: !0
});
lg.log = n8;
lg.resetState = r8;
function i8(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
var yV = function n() {
  var e = this;
  i8(this, n), this.register = function(t) {
    e.openInstances.indexOf(t) === -1 && (e.openInstances.push(t), e.emit("register"));
  }, this.deregister = function(t) {
    var i = e.openInstances.indexOf(t);
    i !== -1 && (e.openInstances.splice(i, 1), e.emit("deregister"));
  }, this.subscribe = function(t) {
    e.subscribers.push(t);
  }, this.emit = function(t) {
    e.subscribers.forEach(function(i) {
      return i(
        t,
        // shallow copy to avoid accidental mutation
        e.openInstances.slice()
      );
    });
  }, this.openInstances = [], this.subscribers = [];
}, Lw = new yV();
function n8() {
  console.log("portalOpenInstances ----------"), console.log(Lw.openInstances.length), Lw.openInstances.forEach(function(n) {
    return console.log(n);
  }), console.log("end portalOpenInstances ----------");
}
function r8() {
  Lw = new yV();
}
lg.default = Lw;
var MO = {};
Object.defineProperty(MO, "__esModule", {
  value: !0
});
MO.resetState = l8;
MO.log = u8;
var o8 = lg, s8 = a8(o8);
function a8(n) {
  return n && n.__esModule ? n : { default: n };
}
var Ur = void 0, xa = void 0, ad = [];
function l8() {
  for (var n = [Ur, xa], e = 0; e < n.length; e++) {
    var t = n[e];
    t && t.parentNode && t.parentNode.removeChild(t);
  }
  Ur = xa = null, ad = [];
}
function u8() {
  console.log("bodyTrap ----------"), console.log(ad.length);
  for (var n = [Ur, xa], e = 0; e < n.length; e++) {
    var t = n[e], i = t || {};
    console.log(i.nodeName, i.className, i.id);
  }
  console.log("edn bodyTrap ----------");
}
function xA() {
  ad.length !== 0 && ad[ad.length - 1].focusContent();
}
function c8(n, e) {
  !Ur && !xa && (Ur = document.createElement("div"), Ur.setAttribute("data-react-modal-body-trap", ""), Ur.style.position = "absolute", Ur.style.opacity = "0", Ur.setAttribute("tabindex", "0"), Ur.addEventListener("focus", xA), xa = Ur.cloneNode(), xa.addEventListener("focus", xA)), ad = e, ad.length > 0 ? (document.body.firstChild !== Ur && document.body.insertBefore(Ur, document.body.firstChild), document.body.lastChild !== xa && document.body.appendChild(xa)) : (Ur.parentElement && Ur.parentElement.removeChild(Ur), xa.parentElement && xa.parentElement.removeChild(xa));
}
s8.default.subscribe(c8);
(function(n, e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = Object.assign || function(G) {
    for (var U = 1; U < arguments.length; U++) {
      var $ = arguments[U];
      for (var k in $)
        Object.prototype.hasOwnProperty.call($, k) && (G[k] = $[k]);
    }
    return G;
  }, i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(G) {
    return typeof G;
  } : function(G) {
    return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G;
  }, r = function() {
    function G(U, $) {
      for (var k = 0; k < $.length; k++) {
        var se = $[k];
        se.enumerable = se.enumerable || !1, se.configurable = !0, "value" in se && (se.writable = !0), Object.defineProperty(U, se.key, se);
      }
    }
    return function(U, $, k) {
      return $ && G(U.prototype, $), k && G(U, k), U;
    };
  }(), o = wt, s = ju, a = b(s), l = Ja, u = y(l), c = Ew, h = b(c), d = el, f = y(d), p = ag, g = y(p), _ = qa, m = b(_), v = lg, C = b(v);
  function y(G) {
    if (G && G.__esModule)
      return G;
    var U = {};
    if (G != null)
      for (var $ in G)
        Object.prototype.hasOwnProperty.call(G, $) && (U[$] = G[$]);
    return U.default = G, U;
  }
  function b(G) {
    return G && G.__esModule ? G : { default: G };
  }
  function L(G, U) {
    if (!(G instanceof U))
      throw new TypeError("Cannot call a class as a function");
  }
  function S(G, U) {
    if (!G)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return U && (typeof U == "object" || typeof U == "function") ? U : G;
  }
  function E(G, U) {
    if (typeof U != "function" && U !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof U);
    G.prototype = Object.create(U && U.prototype, { constructor: { value: G, enumerable: !1, writable: !0, configurable: !0 } }), U && (Object.setPrototypeOf ? Object.setPrototypeOf(G, U) : G.__proto__ = U);
  }
  var D = {
    overlay: "ReactModal__Overlay",
    content: "ReactModal__Content"
  }, O = 9, T = 27, A = 0, P = function(G) {
    E(U, G);
    function U($) {
      L(this, U);
      var k = S(this, (U.__proto__ || Object.getPrototypeOf(U)).call(this, $));
      return k.setOverlayRef = function(se) {
        k.overlay = se, k.props.overlayRef && k.props.overlayRef(se);
      }, k.setContentRef = function(se) {
        k.content = se, k.props.contentRef && k.props.contentRef(se);
      }, k.afterClose = function() {
        var se = k.props, ne = se.appElement, Ce = se.ariaHideApp, ue = se.htmlOpenClassName, B = se.bodyOpenClassName;
        B && g.remove(document.body, B), ue && g.remove(document.getElementsByTagName("html")[0], ue), Ce && A > 0 && (A -= 1, A === 0 && f.show(ne)), k.props.shouldFocusAfterRender && (k.props.shouldReturnFocusAfterClose ? (u.returnFocus(k.props.preventScroll), u.teardownScopedFocus()) : u.popWithoutFocus()), k.props.onAfterClose && k.props.onAfterClose(), C.default.deregister(k);
      }, k.open = function() {
        k.beforeOpen(), k.state.afterOpen && k.state.beforeClose ? (clearTimeout(k.closeTimer), k.setState({ beforeClose: !1 })) : (k.props.shouldFocusAfterRender && (u.setupScopedFocus(k.node), u.markForFocusLater()), k.setState({ isOpen: !0 }, function() {
          k.openAnimationFrame = requestAnimationFrame(function() {
            k.setState({ afterOpen: !0 }), k.props.isOpen && k.props.onAfterOpen && k.props.onAfterOpen({
              overlayEl: k.overlay,
              contentEl: k.content
            });
          });
        }));
      }, k.close = function() {
        k.props.closeTimeoutMS > 0 ? k.closeWithTimeout() : k.closeWithoutTimeout();
      }, k.focusContent = function() {
        return k.content && !k.contentHasFocus() && k.content.focus({ preventScroll: !0 });
      }, k.closeWithTimeout = function() {
        var se = Date.now() + k.props.closeTimeoutMS;
        k.setState({ beforeClose: !0, closesAt: se }, function() {
          k.closeTimer = setTimeout(k.closeWithoutTimeout, k.state.closesAt - Date.now());
        });
      }, k.closeWithoutTimeout = function() {
        k.setState({
          beforeClose: !1,
          isOpen: !1,
          afterOpen: !1,
          closesAt: null
        }, k.afterClose);
      }, k.handleKeyDown = function(se) {
        se.keyCode === O && (0, h.default)(k.content, se), k.props.shouldCloseOnEsc && se.keyCode === T && (se.stopPropagation(), k.requestClose(se));
      }, k.handleOverlayOnClick = function(se) {
        k.shouldClose === null && (k.shouldClose = !0), k.shouldClose && k.props.shouldCloseOnOverlayClick && (k.ownerHandlesClose() ? k.requestClose(se) : k.focusContent()), k.shouldClose = null;
      }, k.handleContentOnMouseUp = function() {
        k.shouldClose = !1;
      }, k.handleOverlayOnMouseDown = function(se) {
        !k.props.shouldCloseOnOverlayClick && se.target == k.overlay && se.preventDefault();
      }, k.handleContentOnClick = function() {
        k.shouldClose = !1;
      }, k.handleContentOnMouseDown = function() {
        k.shouldClose = !1;
      }, k.requestClose = function(se) {
        return k.ownerHandlesClose() && k.props.onRequestClose(se);
      }, k.ownerHandlesClose = function() {
        return k.props.onRequestClose;
      }, k.shouldBeClosed = function() {
        return !k.state.isOpen && !k.state.beforeClose;
      }, k.contentHasFocus = function() {
        return document.activeElement === k.content || k.content.contains(document.activeElement);
      }, k.buildClassName = function(se, ne) {
        var Ce = (typeof ne > "u" ? "undefined" : i(ne)) === "object" ? ne : {
          base: D[se],
          afterOpen: D[se] + "--after-open",
          beforeClose: D[se] + "--before-close"
        }, ue = Ce.base;
        return k.state.afterOpen && (ue = ue + " " + Ce.afterOpen), k.state.beforeClose && (ue = ue + " " + Ce.beforeClose), typeof ne == "string" && ne ? ue + " " + ne : ue;
      }, k.attributesFromObject = function(se, ne) {
        return Object.keys(ne).reduce(function(Ce, ue) {
          return Ce[se + "-" + ue] = ne[ue], Ce;
        }, {});
      }, k.state = {
        afterOpen: !1,
        beforeClose: !1
      }, k.shouldClose = null, k.moveFromContentToOverlay = null, k;
    }
    return r(U, [{
      key: "componentDidMount",
      value: function() {
        this.props.isOpen && this.open();
      }
    }, {
      key: "componentDidUpdate",
      value: function(k, se) {
        this.props.isOpen && !k.isOpen ? this.open() : !this.props.isOpen && k.isOpen && this.close(), this.props.shouldFocusAfterRender && this.state.isOpen && !se.isOpen && this.focusContent();
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.state.isOpen && this.afterClose(), clearTimeout(this.closeTimer), cancelAnimationFrame(this.openAnimationFrame);
      }
    }, {
      key: "beforeOpen",
      value: function() {
        var k = this.props, se = k.appElement, ne = k.ariaHideApp, Ce = k.htmlOpenClassName, ue = k.bodyOpenClassName;
        ue && g.add(document.body, ue), Ce && g.add(document.getElementsByTagName("html")[0], Ce), ne && (A += 1, f.hide(se)), C.default.register(this);
      }
      // Don't steal focus from inner elements
    }, {
      key: "render",
      value: function() {
        var k = this.props, se = k.id, ne = k.className, Ce = k.overlayClassName, ue = k.defaultStyles, B = k.children, z = ne ? {} : ue.content, Y = Ce ? {} : ue.overlay;
        if (this.shouldBeClosed())
          return null;
        var x = {
          ref: this.setOverlayRef,
          className: this.buildClassName("overlay", Ce),
          style: t({}, Y, this.props.style.overlay),
          onClick: this.handleOverlayOnClick,
          onMouseDown: this.handleOverlayOnMouseDown
        }, M = t({
          id: se,
          ref: this.setContentRef,
          style: t({}, z, this.props.style.content),
          className: this.buildClassName("content", ne),
          tabIndex: "-1",
          onKeyDown: this.handleKeyDown,
          onMouseDown: this.handleContentOnMouseDown,
          onMouseUp: this.handleContentOnMouseUp,
          onClick: this.handleContentOnClick,
          role: this.props.role,
          "aria-label": this.props.contentLabel
        }, this.attributesFromObject("aria", t({ modal: !0 }, this.props.aria)), this.attributesFromObject("data", this.props.data || {}), {
          "data-testid": this.props.testId
        }), F = this.props.contentElement(M, B);
        return this.props.overlayElement(x, F);
      }
    }]), U;
  }(o.Component);
  P.defaultProps = {
    style: {
      overlay: {},
      content: {}
    },
    defaultStyles: {}
  }, P.propTypes = {
    isOpen: a.default.bool.isRequired,
    defaultStyles: a.default.shape({
      content: a.default.object,
      overlay: a.default.object
    }),
    style: a.default.shape({
      content: a.default.object,
      overlay: a.default.object
    }),
    className: a.default.oneOfType([a.default.string, a.default.object]),
    overlayClassName: a.default.oneOfType([a.default.string, a.default.object]),
    bodyOpenClassName: a.default.string,
    htmlOpenClassName: a.default.string,
    ariaHideApp: a.default.bool,
    appElement: a.default.oneOfType([a.default.instanceOf(m.default), a.default.instanceOf(_.SafeHTMLCollection), a.default.instanceOf(_.SafeNodeList), a.default.arrayOf(a.default.instanceOf(m.default))]),
    onAfterOpen: a.default.func,
    onAfterClose: a.default.func,
    onRequestClose: a.default.func,
    closeTimeoutMS: a.default.number,
    shouldFocusAfterRender: a.default.bool,
    shouldCloseOnOverlayClick: a.default.bool,
    shouldReturnFocusAfterClose: a.default.bool,
    preventScroll: a.default.bool,
    role: a.default.string,
    contentLabel: a.default.string,
    aria: a.default.object,
    data: a.default.object,
    children: a.default.node,
    shouldCloseOnEsc: a.default.bool,
    overlayRef: a.default.func,
    contentRef: a.default.func,
    id: a.default.string,
    overlayElement: a.default.func,
    contentElement: a.default.func,
    testId: a.default.string
  }, e.default = P, n.exports = e.default;
})(y6, Sw);
function wV() {
  var n = this.constructor.getDerivedStateFromProps(this.props, this.state);
  n != null && this.setState(n);
}
function bV(n) {
  function e(t) {
    var i = this.constructor.getDerivedStateFromProps(n, t);
    return i ?? null;
  }
  this.setState(e.bind(this));
}
function SV(n, e) {
  try {
    var t = this.props, i = this.state;
    this.props = n, this.state = e, this.__reactInternalSnapshotFlag = !0, this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      t,
      i
    );
  } finally {
    this.props = t, this.state = i;
  }
}
wV.__suppressDeprecationWarning = !0;
bV.__suppressDeprecationWarning = !0;
SV.__suppressDeprecationWarning = !0;
function h8(n) {
  var e = n.prototype;
  if (!e || !e.isReactComponent)
    throw new Error("Can only polyfill class components");
  if (typeof n.getDerivedStateFromProps != "function" && typeof e.getSnapshotBeforeUpdate != "function")
    return n;
  var t = null, i = null, r = null;
  if (typeof e.componentWillMount == "function" ? t = "componentWillMount" : typeof e.UNSAFE_componentWillMount == "function" && (t = "UNSAFE_componentWillMount"), typeof e.componentWillReceiveProps == "function" ? i = "componentWillReceiveProps" : typeof e.UNSAFE_componentWillReceiveProps == "function" && (i = "UNSAFE_componentWillReceiveProps"), typeof e.componentWillUpdate == "function" ? r = "componentWillUpdate" : typeof e.UNSAFE_componentWillUpdate == "function" && (r = "UNSAFE_componentWillUpdate"), t !== null || i !== null || r !== null) {
    var o = n.displayName || n.name, s = typeof n.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
    throw Error(
      `Unsafe legacy lifecycles will not be called for components using new component APIs.

` + o + " uses " + s + " but also contains the following legacy lifecycles:" + (t !== null ? `
  ` + t : "") + (i !== null ? `
  ` + i : "") + (r !== null ? `
  ` + r : "") + `

The above lifecycles should be removed. Learn more about this warning here:
https://fb.me/react-async-component-lifecycle-hooks`
    );
  }
  if (typeof n.getDerivedStateFromProps == "function" && (e.componentWillMount = wV, e.componentWillReceiveProps = bV), typeof e.getSnapshotBeforeUpdate == "function") {
    if (typeof e.componentDidUpdate != "function")
      throw new Error(
        "Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype"
      );
    e.componentWillUpdate = SV;
    var a = e.componentDidUpdate;
    e.componentDidUpdate = function(u, c, h) {
      var d = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : h;
      a.call(this, u, c, d);
    };
  }
  return n;
}
const d8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  polyfill: h8
}, Symbol.toStringTag, { value: "Module" })), f8 = /* @__PURE__ */ OO(d8);
Object.defineProperty(yd, "__esModule", {
  value: !0
});
yd.bodyOpenClassName = yd.portalClassName = void 0;
var NA = Object.assign || function(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e];
    for (var i in t)
      Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
  }
  return n;
}, p8 = function() {
  function n(e, t) {
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
    }
  }
  return function(e, t, i) {
    return t && n(e.prototype, t), i && n(e, i), e;
  };
}(), EV = wt, Dw = C_(EV), g8 = rg, Rw = C_(g8), m8 = ju, mt = C_(m8), v8 = Sw, IA = C_(v8), _8 = el, C8 = w8(_8), kc = qa, PA = C_(kc), y8 = f8;
function w8(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}
function C_(n) {
  return n && n.__esModule ? n : { default: n };
}
function b8(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function AA(n, e) {
  if (!n)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : n;
}
function S8(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  n.prototype = Object.create(e && e.prototype, { constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e);
}
var E8 = yd.portalClassName = "ReactModalPortal", L8 = yd.bodyOpenClassName = "ReactModal__Body--open", Wh = kc.canUseDOM && Rw.default.createPortal !== void 0, MA = function(e) {
  return document.createElement(e);
}, FA = function() {
  return Wh ? Rw.default.createPortal : Rw.default.unstable_renderSubtreeIntoContainer;
};
function RC(n) {
  return n();
}
var y_ = function(n) {
  S8(e, n);
  function e() {
    var t, i, r, o;
    b8(this, e);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return o = (i = (r = AA(this, (t = e.__proto__ || Object.getPrototypeOf(e)).call.apply(t, [this].concat(a))), r), r.removePortal = function() {
      !Wh && Rw.default.unmountComponentAtNode(r.node);
      var u = RC(r.props.parentSelector);
      u && u.contains(r.node) ? u.removeChild(r.node) : console.warn('React-Modal: "parentSelector" prop did not returned any DOM element. Make sure that the parent element is unmounted to avoid any memory leaks.');
    }, r.portalRef = function(u) {
      r.portal = u;
    }, r.renderPortal = function(u) {
      var c = FA(), h = c(r, Dw.default.createElement(IA.default, NA({ defaultStyles: e.defaultStyles }, u)), r.node);
      r.portalRef(h);
    }, i), AA(r, o);
  }
  return p8(e, [{
    key: "componentDidMount",
    value: function() {
      if (kc.canUseDOM) {
        Wh || (this.node = MA("div")), this.node.className = this.props.portalClassName;
        var i = RC(this.props.parentSelector);
        i.appendChild(this.node), !Wh && this.renderPortal(this.props);
      }
    }
  }, {
    key: "getSnapshotBeforeUpdate",
    value: function(i) {
      var r = RC(i.parentSelector), o = RC(this.props.parentSelector);
      return { prevParent: r, nextParent: o };
    }
  }, {
    key: "componentDidUpdate",
    value: function(i, r, o) {
      if (kc.canUseDOM) {
        var s = this.props, a = s.isOpen, l = s.portalClassName;
        i.portalClassName !== l && (this.node.className = l);
        var u = o.prevParent, c = o.nextParent;
        c !== u && (u.removeChild(this.node), c.appendChild(this.node)), !(!i.isOpen && !a) && !Wh && this.renderPortal(this.props);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      if (!(!kc.canUseDOM || !this.node || !this.portal)) {
        var i = this.portal.state, r = Date.now(), o = i.isOpen && this.props.closeTimeoutMS && (i.closesAt || r + this.props.closeTimeoutMS);
        o ? (i.beforeClose || this.portal.closeWithTimeout(), setTimeout(this.removePortal, o - r)) : this.removePortal();
      }
    }
  }, {
    key: "render",
    value: function() {
      if (!kc.canUseDOM || !Wh)
        return null;
      !this.node && Wh && (this.node = MA("div"));
      var i = FA();
      return i(Dw.default.createElement(IA.default, NA({
        ref: this.portalRef,
        defaultStyles: e.defaultStyles
      }, this.props)), this.node);
    }
  }], [{
    key: "setAppElement",
    value: function(i) {
      C8.setElement(i);
    }
    /* eslint-disable react/no-unused-prop-types */
    /* eslint-enable react/no-unused-prop-types */
  }]), e;
}(EV.Component);
y_.propTypes = {
  isOpen: mt.default.bool.isRequired,
  style: mt.default.shape({
    content: mt.default.object,
    overlay: mt.default.object
  }),
  portalClassName: mt.default.string,
  bodyOpenClassName: mt.default.string,
  htmlOpenClassName: mt.default.string,
  className: mt.default.oneOfType([mt.default.string, mt.default.shape({
    base: mt.default.string.isRequired,
    afterOpen: mt.default.string.isRequired,
    beforeClose: mt.default.string.isRequired
  })]),
  overlayClassName: mt.default.oneOfType([mt.default.string, mt.default.shape({
    base: mt.default.string.isRequired,
    afterOpen: mt.default.string.isRequired,
    beforeClose: mt.default.string.isRequired
  })]),
  appElement: mt.default.oneOfType([mt.default.instanceOf(PA.default), mt.default.instanceOf(kc.SafeHTMLCollection), mt.default.instanceOf(kc.SafeNodeList), mt.default.arrayOf(mt.default.instanceOf(PA.default))]),
  onAfterOpen: mt.default.func,
  onRequestClose: mt.default.func,
  closeTimeoutMS: mt.default.number,
  ariaHideApp: mt.default.bool,
  shouldFocusAfterRender: mt.default.bool,
  shouldCloseOnOverlayClick: mt.default.bool,
  shouldReturnFocusAfterClose: mt.default.bool,
  preventScroll: mt.default.bool,
  parentSelector: mt.default.func,
  aria: mt.default.object,
  data: mt.default.object,
  role: mt.default.string,
  contentLabel: mt.default.string,
  shouldCloseOnEsc: mt.default.bool,
  overlayRef: mt.default.func,
  contentRef: mt.default.func,
  id: mt.default.string,
  overlayElement: mt.default.func,
  contentElement: mt.default.func
};
y_.defaultProps = {
  isOpen: !1,
  portalClassName: E8,
  bodyOpenClassName: L8,
  role: "dialog",
  ariaHideApp: !0,
  closeTimeoutMS: 0,
  shouldFocusAfterRender: !0,
  shouldCloseOnEsc: !0,
  shouldCloseOnOverlayClick: !0,
  shouldReturnFocusAfterClose: !0,
  preventScroll: !1,
  parentSelector: function() {
    return document.body;
  },
  overlayElement: function(e, t) {
    return Dw.default.createElement(
      "div",
      e,
      t
    );
  },
  contentElement: function(e, t) {
    return Dw.default.createElement(
      "div",
      e,
      t
    );
  }
};
y_.defaultStyles = {
  overlay: {
    position: "fixed",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(255, 255, 255, 0.75)"
  },
  content: {
    position: "absolute",
    top: "40px",
    left: "40px",
    right: "40px",
    bottom: "40px",
    border: "1px solid #ccc",
    background: "#fff",
    overflow: "auto",
    WebkitOverflowScrolling: "touch",
    borderRadius: "4px",
    outline: "none",
    padding: "20px"
  }
};
(0, y8.polyfill)(y_);
yd.default = y_;
(function(n, e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = yd, i = r(t);
  function r(o) {
    return o && o.__esModule ? o : { default: o };
  }
  e.default = i.default, n.exports = e.default;
})(C6, bw);
const H_e = /* @__PURE__ */ zW(bw);
var rp = {}, D8 = {
  get exports() {
    return rp;
  },
  set exports(n) {
    rp = n;
  }
};
/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.13.3
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 20.07.2022
 */
(function(n) {
  (function(e, t) {
    n.exports = t(e, e.document, void 0);
  })(
    typeof window < "u" ? window : Ne,
    function(e, t, i) {
      var r = "OverlayScrollbars", o = {
        o: "object",
        f: "function",
        a: "array",
        s: "string",
        b: "boolean",
        n: "number",
        u: "undefined",
        z: "null"
        //d : 'date',
        //e : 'error',
        //r : 'regexp',
        //y : 'symbol'
      }, s = {
        c: "class",
        s: "style",
        i: "id",
        l: "length",
        p: "prototype",
        ti: "tabindex",
        oH: "offsetHeight",
        cH: "clientHeight",
        sH: "scrollHeight",
        oW: "offsetWidth",
        cW: "clientWidth",
        sW: "scrollWidth",
        hOP: "hasOwnProperty",
        bCR: "getBoundingClientRect"
      }, a = function() {
        var g = {}, _ = {}, m = ["-webkit-", "-moz-", "-o-", "-ms-"], v = ["WebKit", "Moz", "O", "MS"];
        function C(y) {
          return y.charAt(0).toUpperCase() + y.slice(1);
        }
        return {
          _cssPrefixes: m,
          _jsPrefixes: v,
          _cssProperty: function(y) {
            var b = _[y];
            if (_[s.hOP](y))
              return b;
            for (var L = C(y), S = t.createElement("div")[s.s], E, D = 0, O, T; D < m.length; D++)
              for (T = m[D].replace(/-/g, ""), E = [
                y,
                //transition
                m[D] + y,
                //-webkit-transition
                T + L,
                //webkitTransition
                C(T) + L
                //WebkitTransition
              ], O = 0; O < E[s.l]; O++)
                if (S[E[O]] !== i) {
                  b = E[O];
                  break;
                }
            return _[y] = b, b;
          },
          _cssPropertyValue: function(y, b, L) {
            var S = y + " " + b, E = _[S];
            if (_[s.hOP](S))
              return E;
            for (var D = t.createElement("div")[s.s], O = b.split(" "), T = L || "", A = 0, P = -1, G; A < O[s.l]; A++)
              for (; P < a._cssPrefixes[s.l]; P++)
                if (G = P < 0 ? O[A] : a._cssPrefixes[P] + O[A], D.cssText = y + ":" + G + T, D[s.l]) {
                  E = G;
                  break;
                }
            return _[S] = E, E;
          },
          _jsAPI: function(y, b, L) {
            var S = 0, E = g[y];
            if (!g[s.hOP](y)) {
              for (E = e[y]; S < v[s.l]; S++)
                E = E || e[(b ? v[S] : v[S].toLowerCase()) + C(y)];
              g[y] = E;
            }
            return E || L;
          }
        };
      }(), l = function() {
        function g(m) {
          return m ? e.innerWidth || t.documentElement[s.cW] || t.body[s.cW] : e.innerHeight || t.documentElement[s.cH] || t.body[s.cH];
        }
        function _(m, v) {
          if (typeof m != o.f)
            throw "Can't bind function!";
          var C = s.p, y = Array[C].slice.call(arguments, 2), b = function() {
          }, L = function() {
            return m.apply(this instanceof b ? this : v, y.concat(Array[C].slice.call(arguments)));
          };
          return m[C] && (b[C] = m[C]), L[C] = new b(), L;
        }
        return {
          /**
           * Gets the current window width.
           * @returns {Number|number} The current window width in pixel.
           */
          wW: _(g, 0, !0),
          /**
           * Gets the current window height.
           * @returns {Number|number} The current window height in pixel.
           */
          wH: _(g, 0),
          /**
           * Gets the MutationObserver Object or undefined if not supported.
           * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.
           */
          mO: _(a._jsAPI, 0, "MutationObserver", !0),
          /**
           * Gets the ResizeObserver Object or undefined if not supported.
           * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.
           */
          rO: _(a._jsAPI, 0, "ResizeObserver", !0),
          /**
           * Gets the RequestAnimationFrame method or it's corresponding polyfill.
           * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.
           */
          rAF: _(a._jsAPI, 0, "requestAnimationFrame", !1, function(m) {
            return e.setTimeout(m, 1e3 / 60);
          }),
          /**
           * Gets the CancelAnimationFrame method or it's corresponding polyfill.
           * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.
           */
          cAF: _(a._jsAPI, 0, "cancelAnimationFrame", !1, function(m) {
            return e.clearTimeout(m);
          }),
          /**
           * Gets the current time.
           * @returns {number} The current time.
           */
          now: function() {
            return Date.now && Date.now() || (/* @__PURE__ */ new Date()).getTime();
          },
          /**
           * Stops the propagation of the given event.
           * @param event The event of which the propagation shall be stoped.
           */
          stpP: function(m) {
            m.stopPropagation ? m.stopPropagation() : m.cancelBubble = !0;
          },
          /**
           * Prevents the default action of the given event.
           * @param event The event of which the default action shall be prevented.
           */
          prvD: function(m) {
            m.preventDefault && m.cancelable ? m.preventDefault() : m.returnValue = !1;
          },
          /**
           * Gets the pageX and pageY values of the given mouse event.
           * @param event The mouse event of which the pageX and pageX shall be got.
           * @returns {{x: number, y: number}} x = pageX value, y = pageY value.
           */
          page: function(m) {
            m = m.originalEvent || m;
            var v = "page", C = "client", y = "X", b = "Y", L = m.target || m.srcElement || t, S = L.ownerDocument || t, E = S.documentElement, D = S.body;
            if (m.touches !== i) {
              var O = m.touches[0];
              return {
                x: O[v + y],
                y: O[v + b]
              };
            }
            return !m[v + y] && m[C + y] && m[C + y] != null ? {
              x: m[C + y] + (E && E.scrollLeft || D && D.scrollLeft || 0) - (E && E.clientLeft || D && D.clientLeft || 0),
              y: m[C + b] + (E && E.scrollTop || D && D.scrollTop || 0) - (E && E.clientTop || D && D.clientTop || 0)
            } : {
              x: m[v + y],
              y: m[v + b]
            };
          },
          /**
           * Gets the clicked mouse button of the given mouse event.
           * @param event The mouse event of which the clicked button shal be got.
           * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)
           */
          mBtn: function(m) {
            var v = m.button;
            return !m.which && v !== i ? v & 1 ? 1 : v & 2 ? 3 : v & 4 ? 2 : 0 : m.which;
          },
          /**
           * Checks whether a item is in the given array and returns its index.
           * @param item The item of which the position in the array shall be determined.
           * @param arr The array.
           * @returns {number} The zero based index of the item or -1 if the item isn't in the array.
           */
          inA: function(m, v) {
            for (var C = 0; C < v[s.l]; C++)
              try {
                if (v[C] === m)
                  return C;
              } catch {
              }
            return -1;
          },
          /**
           * Returns true if the given value is a array.
           * @param arr The potential array.
           * @returns {boolean} True if the given value is a array, false otherwise.
           */
          isA: function(m) {
            var v = Array.isArray;
            return v ? v(m) : this.type(m) == o.a;
          },
          /**
           * Determine the internal JavaScript [[Class]] of the given object.
           * @param obj The object of which the type shall be determined.
           * @returns {string} The type of the given object.
           */
          type: function(m) {
            return m === i || m === null ? m + "" : Object[s.p].toString.call(m).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
          },
          bind: _
          /**
          	                 * Gets the vendor-prefixed CSS property by the given name.
          	                 * For example the given name is "transform" and you're using a old Firefox browser then the returned value would be "-moz-transform".
          	                 * If the browser doesn't need a vendor-prefix, then the returned string is the given name.
          	                 * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.
          	                 * @param propName The unprefixed CSS property name.
          	                 * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.
          
          	                cssProp: function(propName) {
          	                    return VENDORS._cssProperty(propName);
          	                }
          	                */
        };
      }(), u = Math, c = e.jQuery, h = function() {
        var g = {
          p: u.PI,
          c: u.cos,
          s: u.sin,
          w: u.pow,
          t: u.sqrt,
          n: u.asin,
          a: u.abs,
          o: 1.70158
        };
        return {
          swing: function(_, m, v, C, y) {
            return 0.5 - g.c(_ * g.p) / 2;
          },
          linear: function(_, m, v, C, y) {
            return _;
          },
          easeInQuad: function(_, m, v, C, y) {
            return C * (m /= y) * m + v;
          },
          easeOutQuad: function(_, m, v, C, y) {
            return -C * (m /= y) * (m - 2) + v;
          },
          easeInOutQuad: function(_, m, v, C, y) {
            return (m /= y / 2) < 1 ? C / 2 * m * m + v : -C / 2 * (--m * (m - 2) - 1) + v;
          },
          easeInCubic: function(_, m, v, C, y) {
            return C * (m /= y) * m * m + v;
          },
          easeOutCubic: function(_, m, v, C, y) {
            return C * ((m = m / y - 1) * m * m + 1) + v;
          },
          easeInOutCubic: function(_, m, v, C, y) {
            return (m /= y / 2) < 1 ? C / 2 * m * m * m + v : C / 2 * ((m -= 2) * m * m + 2) + v;
          },
          easeInQuart: function(_, m, v, C, y) {
            return C * (m /= y) * m * m * m + v;
          },
          easeOutQuart: function(_, m, v, C, y) {
            return -C * ((m = m / y - 1) * m * m * m - 1) + v;
          },
          easeInOutQuart: function(_, m, v, C, y) {
            return (m /= y / 2) < 1 ? C / 2 * m * m * m * m + v : -C / 2 * ((m -= 2) * m * m * m - 2) + v;
          },
          easeInQuint: function(_, m, v, C, y) {
            return C * (m /= y) * m * m * m * m + v;
          },
          easeOutQuint: function(_, m, v, C, y) {
            return C * ((m = m / y - 1) * m * m * m * m + 1) + v;
          },
          easeInOutQuint: function(_, m, v, C, y) {
            return (m /= y / 2) < 1 ? C / 2 * m * m * m * m * m + v : C / 2 * ((m -= 2) * m * m * m * m + 2) + v;
          },
          easeInSine: function(_, m, v, C, y) {
            return -C * g.c(m / y * (g.p / 2)) + C + v;
          },
          easeOutSine: function(_, m, v, C, y) {
            return C * g.s(m / y * (g.p / 2)) + v;
          },
          easeInOutSine: function(_, m, v, C, y) {
            return -C / 2 * (g.c(g.p * m / y) - 1) + v;
          },
          easeInExpo: function(_, m, v, C, y) {
            return m == 0 ? v : C * g.w(2, 10 * (m / y - 1)) + v;
          },
          easeOutExpo: function(_, m, v, C, y) {
            return m == y ? v + C : C * (-g.w(2, -10 * m / y) + 1) + v;
          },
          easeInOutExpo: function(_, m, v, C, y) {
            return m == 0 ? v : m == y ? v + C : (m /= y / 2) < 1 ? C / 2 * g.w(2, 10 * (m - 1)) + v : C / 2 * (-g.w(2, -10 * --m) + 2) + v;
          },
          easeInCirc: function(_, m, v, C, y) {
            return -C * (g.t(1 - (m /= y) * m) - 1) + v;
          },
          easeOutCirc: function(_, m, v, C, y) {
            return C * g.t(1 - (m = m / y - 1) * m) + v;
          },
          easeInOutCirc: function(_, m, v, C, y) {
            return (m /= y / 2) < 1 ? -C / 2 * (g.t(1 - m * m) - 1) + v : C / 2 * (g.t(1 - (m -= 2) * m) + 1) + v;
          },
          easeInElastic: function(_, m, v, C, y) {
            var b = g.o, L = 0, S = C;
            return m == 0 ? v : (m /= y) == 1 ? v + C : (L || (L = y * 0.3), S < g.a(C) ? (S = C, b = L / 4) : b = L / (2 * g.p) * g.n(C / S), -(S * g.w(2, 10 * (m -= 1)) * g.s((m * y - b) * (2 * g.p) / L)) + v);
          },
          easeOutElastic: function(_, m, v, C, y) {
            var b = g.o, L = 0, S = C;
            return m == 0 ? v : (m /= y) == 1 ? v + C : (L || (L = y * 0.3), S < g.a(C) ? (S = C, b = L / 4) : b = L / (2 * g.p) * g.n(C / S), S * g.w(2, -10 * m) * g.s((m * y - b) * (2 * g.p) / L) + C + v);
          },
          easeInOutElastic: function(_, m, v, C, y) {
            var b = g.o, L = 0, S = C;
            return m == 0 ? v : (m /= y / 2) == 2 ? v + C : (L || (L = y * (0.3 * 1.5)), S < g.a(C) ? (S = C, b = L / 4) : b = L / (2 * g.p) * g.n(C / S), m < 1 ? -0.5 * (S * g.w(2, 10 * (m -= 1)) * g.s((m * y - b) * (2 * g.p) / L)) + v : S * g.w(2, -10 * (m -= 1)) * g.s((m * y - b) * (2 * g.p) / L) * 0.5 + C + v);
          },
          easeInBack: function(_, m, v, C, y, b) {
            return b = b || g.o, C * (m /= y) * m * ((b + 1) * m - b) + v;
          },
          easeOutBack: function(_, m, v, C, y, b) {
            return b = b || g.o, C * ((m = m / y - 1) * m * ((b + 1) * m + b) + 1) + v;
          },
          easeInOutBack: function(_, m, v, C, y, b) {
            return b = b || g.o, (m /= y / 2) < 1 ? C / 2 * (m * m * (((b *= 1.525) + 1) * m - b)) + v : C / 2 * ((m -= 2) * m * (((b *= 1.525) + 1) * m + b) + 2) + v;
          },
          easeInBounce: function(_, m, v, C, y) {
            return C - this.easeOutBounce(_, y - m, 0, C, y) + v;
          },
          easeOutBounce: function(_, m, v, C, y) {
            var b = 7.5625;
            return (m /= y) < 1 / 2.75 ? C * (b * m * m) + v : m < 2 / 2.75 ? C * (b * (m -= 1.5 / 2.75) * m + 0.75) + v : m < 2.5 / 2.75 ? C * (b * (m -= 2.25 / 2.75) * m + 0.9375) + v : C * (b * (m -= 2.625 / 2.75) * m + 0.984375) + v;
          },
          easeInOutBounce: function(_, m, v, C, y) {
            return m < y / 2 ? this.easeInBounce(_, m * 2, 0, C, y) * 0.5 + v : this.easeOutBounce(_, m * 2 - y, 0, C, y) * 0.5 + C * 0.5 + v;
          }
        };
      }(), d = function() {
        var g = /[^\x20\t\r\n\f]+/g, _ = " ", m = "", v = "scrollLeft", C = "scrollTop", y = [], b = l.type, L = {
          animationIterationCount: !0,
          columnCount: !0,
          fillOpacity: !0,
          flexGrow: !0,
          flexShrink: !0,
          fontWeight: !0,
          lineHeight: !0,
          opacity: !0,
          order: !0,
          orphans: !0,
          widows: !0,
          zIndex: !0,
          zoom: !0
        };
        function S() {
          var x, M, F, H, oe, ve, Me = arguments[0] || {}, ze = 1, je = arguments[s.l], Fe = !1;
          for (b(Me) == o.b && (Fe = Me, Me = arguments[1] || {}, ze = 2), b(Me) != o.o && !b(Me) == o.f && (Me = {}), je === ze && (Me = Y, --ze); ze < je; ze++)
            if ((oe = arguments[ze]) != null)
              for (H in oe)
                x = Me[H], F = oe[H], Me !== F && (Fe && F && (T(F) || (M = l.isA(F))) ? (M ? (M = !1, ve = x && l.isA(x) ? x : []) : ve = x && T(x) ? x : {}, Me[H] = S(Fe, ve, F)) : F !== i && (Me[H] = F));
          return Me;
        }
        function E(x, M, F) {
          for (var H = F || 0; H < M[s.l]; H++)
            if (M[H] === x)
              return H;
          return -1;
        }
        function D(x) {
          return b(x) == o.f;
        }
        function O(x) {
          for (var M in x)
            return !1;
          return !0;
        }
        function T(x) {
          if (!x || b(x) != o.o)
            return !1;
          var M, F = s.p, H = Object[F].hasOwnProperty, oe = H.call(x, "constructor"), ve = x.constructor && x.constructor[F] && H.call(x.constructor[F], "isPrototypeOf");
          if (x.constructor && !oe && !ve)
            return !1;
          for (M in x)
            ;
          return b(M) == o.u || H.call(x, M);
        }
        function A(x, M) {
          var F = 0;
          if (P(x))
            for (; F < x[s.l] && M.call(x[F], F, x[F]) !== !1; F++)
              ;
          else
            for (F in x)
              if (M.call(x[F], F, x[F]) === !1)
                break;
          return x;
        }
        function P(x) {
          var M = !!x && [s.l] in x && x[s.l], F = b(x);
          return D(F) ? !1 : F == o.a || M === 0 || b(M) == o.n && M > 0 && M - 1 in x;
        }
        function G(x) {
          var M = x.match(g) || [];
          return M.join(_);
        }
        function U(x, M) {
          for (var F = (x.parentNode || t).querySelectorAll(M) || [], H = F[s.l]; H--; )
            if (F[H] == x)
              return !0;
          return !1;
        }
        function $(x, M, F) {
          if (l.isA(F))
            for (var H = 0; H < F[s.l]; H++)
              $(x, M, F[H]);
          else
            b(F) == o.s ? x.insertAdjacentHTML(M, F) : x.insertAdjacentElement(M, F.nodeType ? F : F[0]);
        }
        function k(x, M, F) {
          try {
            x[s.s][M] !== i && (x[s.s][M] = se(M, F));
          } catch {
          }
        }
        function se(x, M) {
          return !L[x.toLowerCase()] && b(M) == o.n && (M += "px"), M;
        }
        function ne(x, M) {
          var F, H;
          M !== !1 && x.q.splice(0, 1), x.q[s.l] > 0 ? (H = x.q[0], ue(x.el, H.props, H.duration, H.easing, H.complete, !0)) : (F = E(x, y), F > -1 && y.splice(F, 1));
        }
        function Ce(x, M, F) {
          M === v || M === C ? x[M] = F : k(x, M, F);
        }
        function ue(x, M, F, H, oe, ve) {
          var Me = T(F), ze = {}, je = {}, Fe = 0, qe, Tt, Nt, ti, ii, at;
          for (Me ? (H = F.easing, F.start, Nt = F.progress, ti = F.step, ii = F.specialEasing, oe = F.complete, at = F.duration) : at = F, ii = ii || {}, at = at || 400, H = H || "swing", ve = ve || !1; Fe < y[s.l]; Fe++)
            if (y[Fe].el === x) {
              Tt = y[Fe];
              break;
            }
          Tt || (Tt = {
            el: x,
            q: []
          }, y.push(Tt));
          for (qe in M)
            qe === v || qe === C ? ze[qe] = x[qe] : ze[qe] = Y(x).css(qe);
          for (qe in ze)
            ze[qe] !== M[qe] && M[qe] !== i && (je[qe] = M[qe]);
          if (O(je))
            ve && ne(Tt);
          else {
            var Hi, zt, qi, Yi, wi, ft, ai, Jn, On, Vn = ve ? 0 : E(Yt, Tt.q), Yt = {
              props: je,
              duration: Me ? F : at,
              easing: H,
              complete: oe
            };
            if (Vn === -1 && (Vn = Tt.q[s.l], Tt.q.push(Yt)), Vn === 0)
              if (at > 0)
                ai = l.now(), Jn = function() {
                  Hi = l.now(), On = Hi - ai, zt = Yt.stop || On >= at, qi = 1 - (u.max(0, ai + at - Hi) / at || 0);
                  for (qe in je)
                    Yi = parseFloat(ze[qe]), wi = parseFloat(je[qe]), ft = (wi - Yi) * h[ii[qe] || H](qi, qi * at, 0, 1, at) + Yi, Ce(x, qe, ft), D(ti) && ti(ft, {
                      elem: x,
                      prop: qe,
                      start: Yi,
                      now: ft,
                      end: wi,
                      pos: qi,
                      options: {
                        easing: H,
                        speacialEasing: ii,
                        duration: at,
                        complete: oe,
                        step: ti
                      },
                      startTime: ai
                    });
                  D(Nt) && Nt({}, qi, u.max(0, at - On)), zt ? (ne(Tt), D(oe) && oe()) : Yt.frame = l.rAF()(Jn);
                }, Yt.frame = l.rAF()(Jn);
              else {
                for (qe in je)
                  Ce(x, qe, je[qe]);
                ne(Tt);
              }
          }
        }
        function B(x, M, F) {
          for (var H, oe, ve, Me = 0; Me < y[s.l]; Me++)
            if (H = y[Me], H.el === x) {
              if (H.q[s.l] > 0) {
                if (oe = H.q[0], oe.stop = !0, l.cAF()(oe.frame), H.q.splice(0, 1), F)
                  for (ve in oe.props)
                    Ce(x, ve, oe.props[ve]);
                M ? H.q = [] : ne(H, !1);
              }
              break;
            }
        }
        function z(x) {
          return !!(x[s.oW] || x[s.oH] || x.getClientRects()[s.l]);
        }
        function Y(x) {
          if (arguments[s.l] === 0)
            return this;
          var M = new Y(), F = x, H = 0, oe, ve;
          if (b(x) == o.s)
            for (F = [], x.charAt(0) === "<" ? (ve = t.createElement("div"), ve.innerHTML = x, oe = ve.children) : oe = t.querySelectorAll(x); H < oe[s.l]; H++)
              F.push(oe[H]);
          if (F) {
            for (b(F) != o.s && (!P(F) || F === e || F === F.self) && (F = [F]), H = 0; H < F[s.l]; H++)
              M[H] = F[H];
            M[s.l] = F[s.l];
          }
          return M;
        }
        return Y[s.p] = {
          //EVENTS:
          on: function(x, M) {
            x = (x || m).match(g) || [m];
            var F = x[s.l], H = 0, oe;
            return this.each(function() {
              oe = this;
              try {
                if (oe.addEventListener)
                  for (; H < F; H++)
                    oe.addEventListener(x[H], M);
                else if (oe.detachEvent)
                  for (; H < F; H++)
                    oe.attachEvent("on" + x[H], M);
              } catch {
              }
            });
          },
          off: function(x, M) {
            x = (x || m).match(g) || [m];
            var F = x[s.l], H = 0, oe;
            return this.each(function() {
              oe = this;
              try {
                if (oe.removeEventListener)
                  for (; H < F; H++)
                    oe.removeEventListener(x[H], M);
                else if (oe.detachEvent)
                  for (; H < F; H++)
                    oe.detachEvent("on" + x[H], M);
              } catch {
              }
            });
          },
          one: function(x, M) {
            return x = (x || m).match(g) || [m], this.each(function() {
              var F = Y(this);
              Y.each(x, function(H, oe) {
                var ve = function(Me) {
                  M.call(this, Me), F.off(oe, ve);
                };
                F.on(oe, ve);
              });
            });
          },
          trigger: function(x) {
            var M, F;
            return this.each(function() {
              M = this, t.createEvent ? (F = t.createEvent("HTMLEvents"), F.initEvent(x, !0, !1), M.dispatchEvent(F)) : M.fireEvent("on" + x);
            });
          },
          //DOM NODE INSERTING / REMOVING:
          append: function(x) {
            return this.each(function() {
              $(this, "beforeend", x);
            });
          },
          prepend: function(x) {
            return this.each(function() {
              $(this, "afterbegin", x);
            });
          },
          before: function(x) {
            return this.each(function() {
              $(this, "beforebegin", x);
            });
          },
          after: function(x) {
            return this.each(function() {
              $(this, "afterend", x);
            });
          },
          remove: function() {
            return this.each(function() {
              var x = this, M = x.parentNode;
              M != null && M.removeChild(x);
            });
          },
          unwrap: function() {
            var x = [], M, F, H;
            for (this.each(function() {
              H = this.parentNode, E(H, x) === -1 && x.push(H);
            }), M = 0; M < x[s.l]; M++) {
              for (F = x[M], H = F.parentNode; F.firstChild; )
                H.insertBefore(F.firstChild, F);
              H.removeChild(F);
            }
            return this;
          },
          wrapAll: function(x) {
            for (var M, F = this, H = Y(x)[0], oe = H, ve = F[0].parentNode, Me = F[0].previousSibling; oe.childNodes[s.l] > 0; )
              oe = oe.childNodes[0];
            for (M = 0; F[s.l] - M; oe.firstChild === F[0] && M++)
              oe.appendChild(F[M]);
            var ze = Me ? Me.nextSibling : ve.firstChild;
            return ve.insertBefore(H, ze), this;
          },
          wrapInner: function(x) {
            return this.each(function() {
              var M = Y(this), F = M.contents();
              F[s.l] ? F.wrapAll(x) : M.append(x);
            });
          },
          wrap: function(x) {
            return this.each(function() {
              Y(this).wrapAll(x);
            });
          },
          //DOM NODE MANIPULATION / INFORMATION:
          css: function(x, M) {
            var F, H, oe, ve = e.getComputedStyle;
            return b(x) == o.s ? M === i ? (F = this[0], oe = ve ? ve(F, null) : F.currentStyle[x], ve ? oe != null ? oe.getPropertyValue(x) : F[s.s][x] : oe) : this.each(function() {
              k(this, x, M);
            }) : this.each(function() {
              for (H in x)
                k(this, H, x[H]);
            });
          },
          hasClass: function(x) {
            for (var M, F = 0, H = _ + x + _, oe; M = this[F++]; ) {
              if (oe = M.classList, oe && oe.contains(x))
                return !0;
              if (M.nodeType === 1 && (_ + G(M.className + m) + _).indexOf(H) > -1)
                return !0;
            }
            return !1;
          },
          addClass: function(x) {
            var M, F, H, oe, ve, Me, ze, je, Fe = 0, qe = 0;
            if (x) {
              for (M = x.match(g) || []; F = this[Fe++]; )
                if (je = F.classList, ze === i && (ze = je !== i), ze)
                  for (; ve = M[qe++]; )
                    je.add(ve);
                else if (oe = F.className + m, H = F.nodeType === 1 && _ + G(oe) + _, H) {
                  for (; ve = M[qe++]; )
                    H.indexOf(_ + ve + _) < 0 && (H += ve + _);
                  Me = G(H), oe !== Me && (F.className = Me);
                }
            }
            return this;
          },
          removeClass: function(x) {
            var M, F, H, oe, ve, Me, ze, je, Fe = 0, qe = 0;
            if (x) {
              for (M = x.match(g) || []; F = this[Fe++]; )
                if (je = F.classList, ze === i && (ze = je !== i), ze)
                  for (; ve = M[qe++]; )
                    je.remove(ve);
                else if (oe = F.className + m, H = F.nodeType === 1 && _ + G(oe) + _, H) {
                  for (; ve = M[qe++]; )
                    for (; H.indexOf(_ + ve + _) > -1; )
                      H = H.replace(_ + ve + _, _);
                  Me = G(H), oe !== Me && (F.className = Me);
                }
            }
            return this;
          },
          hide: function() {
            return this.each(function() {
              this[s.s].display = "none";
            });
          },
          show: function() {
            return this.each(function() {
              this[s.s].display = "block";
            });
          },
          attr: function(x, M) {
            for (var F = 0, H; H = this[F++]; ) {
              if (M === i)
                return H.getAttribute(x);
              H.setAttribute(x, M);
            }
            return this;
          },
          removeAttr: function(x) {
            return this.each(function() {
              this.removeAttribute(x);
            });
          },
          offset: function() {
            var x = this[0], M = x[s.bCR](), F = e.pageXOffset || t.documentElement[v], H = e.pageYOffset || t.documentElement[C];
            return {
              top: M.top + H,
              left: M.left + F
            };
          },
          position: function() {
            var x = this[0];
            return {
              top: x.offsetTop,
              left: x.offsetLeft
            };
          },
          scrollLeft: function(x) {
            for (var M = 0, F; F = this[M++]; ) {
              if (x === i)
                return F[v];
              F[v] = x;
            }
            return this;
          },
          scrollTop: function(x) {
            for (var M = 0, F; F = this[M++]; ) {
              if (x === i)
                return F[C];
              F[C] = x;
            }
            return this;
          },
          val: function(x) {
            var M = this[0];
            return x ? (M.value = x, this) : M.value;
          },
          //DOM TRAVERSAL / FILTERING:
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          eq: function(x) {
            return Y(this[x >= 0 ? x : this[s.l] + x]);
          },
          find: function(x) {
            var M = [], F;
            return this.each(function() {
              var H = this, oe = H.querySelectorAll(x);
              for (F = 0; F < oe[s.l]; F++)
                M.push(oe[F]);
            }), Y(M);
          },
          children: function(x) {
            var M = [], F, H, oe;
            return this.each(function() {
              for (H = this.children, oe = 0; oe < H[s.l]; oe++)
                F = H[oe], x ? (F.matches && F.matches(x) || U(F, x)) && M.push(F) : M.push(F);
            }), Y(M);
          },
          parent: function(x) {
            var M = [], F;
            return this.each(function() {
              F = this.parentNode, (!x || Y(F).is(x)) && M.push(F);
            }), Y(M);
          },
          is: function(x) {
            var M, F;
            for (F = 0; F < this[s.l]; F++) {
              if (M = this[F], x === ":visible")
                return z(M);
              if (x === ":hidden")
                return !z(M);
              if (M.matches && M.matches(x) || U(M, x))
                return !0;
            }
            return !1;
          },
          contents: function() {
            var x = [], M, F;
            return this.each(function() {
              for (M = this.childNodes, F = 0; F < M[s.l]; F++)
                x.push(M[F]);
            }), Y(x);
          },
          each: function(x) {
            return A(this, x);
          },
          //ANIMATION:
          animate: function(x, M, F, H) {
            return this.each(function() {
              ue(this, x, M, F, H);
            });
          },
          stop: function(x, M) {
            return this.each(function() {
              B(this, x, M);
            });
          }
        }, S(Y, {
          extend: S,
          inArray: E,
          isEmptyObject: O,
          isPlainObject: T,
          each: A
        }), Y;
      }(), f = function() {
        var g = [], _ = "__overlayScrollbars__";
        return function(m, v) {
          var C = arguments[s.l];
          if (C < 1)
            return g;
          if (v)
            m[_] = v, g.push(m);
          else {
            var y = l.inA(m, g);
            if (y > -1)
              if (C > 1)
                delete m[_], g.splice(y, 1);
              else
                return g[y][_];
          }
        };
      }(), p = function() {
        var g, _, m, v = [], C = function() {
          var E = l.type, D = [
            o.b,
            //boolean
            o.n,
            //number
            o.s,
            //string
            o.a,
            //array
            o.o,
            //object
            o.f,
            //function
            o.z
            //null
          ], O = " ", T = ":", A = [o.z, o.s], P = o.n, G = [o.z, o.b], U = [!0, o.b], $ = [!1, o.b], k = [null, [o.z, o.f]], se = [["img"], [o.s, o.a, o.z]], ne = [["style", "class"], [o.s, o.a, o.z]], Ce = "n:none b:both h:horizontal v:vertical", ue = "v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden", B = "v:visible h:hidden a:auto", z = "n:never s:scroll l:leave m:move", Y = {
            className: ["os-theme-dark", A],
            //null || string
            resize: ["none", Ce],
            //none || both  || horizontal || vertical || n || b || h || v
            sizeAutoCapable: U,
            //true || false
            clipAlways: U,
            //true || false
            normalizeRTL: U,
            //true || false
            paddingAbsolute: $,
            //true || false
            autoUpdate: [null, G],
            //true || false || null
            autoUpdateInterval: [33, P],
            //number
            updateOnLoad: se,
            //string || array || null
            nativeScrollbarsOverlaid: {
              showNativeScrollbars: $,
              //true || false
              initialize: U
              //true || false
            },
            overflowBehavior: {
              x: ["scroll", ue],
              //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
              y: ["scroll", ue]
              //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
            },
            scrollbars: {
              visibility: ["auto", B],
              //visible || hidden || auto || v || h || a
              autoHide: ["never", z],
              //never || scroll || leave || move || n || s || l || m
              autoHideDelay: [800, P],
              //number
              dragScrolling: U,
              //true || false
              clickScrolling: $,
              //true || false
              touchSupport: U,
              //true || false
              snapHandle: $
              //true || false
            },
            textarea: {
              dynWidth: $,
              //true || false
              dynHeight: $,
              //true || false
              inheritedAttrs: ne
              //string || array || null
            },
            callbacks: {
              onInitialized: k,
              //null || function
              onInitializationWithdrawn: k,
              //null || function
              onDestroyed: k,
              //null || function
              onScrollStart: k,
              //null || function
              onScroll: k,
              //null || function
              onScrollStop: k,
              //null || function
              onOverflowChanged: k,
              //null || function
              onOverflowAmountChanged: k,
              //null || function
              onDirectionChanged: k,
              //null || function
              onContentSizeChanged: k,
              //null || function
              onHostSizeChanged: k,
              //null || function
              onUpdated: k
              //null || function
            }
          }, x = function(M) {
            var F = function(H) {
              var oe, ve, Me;
              for (oe in H)
                H[s.hOP](oe) && (ve = H[oe], Me = E(ve), Me == o.a ? H[oe] = ve[M ? 1 : 0] : Me == o.o && (H[oe] = F(ve)));
              return H;
            };
            return F(d.extend(!0, {}, Y));
          };
          return {
            _defaults: x(),
            _template: x(!0),
            /**
             * Validates the passed object by the passed template.
             * @param obj The object which shall be validated.
             * @param template The template which defines the allowed values and types.
             * @param writeErrors True if errors shall be logged to the console.
             * @param diffObj If a object is passed then only valid differences to this object will be returned.
             * @returns {{}} A object which contains two objects called "default" and "prepared" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.
             */
            _validate: function(M, F, H, oe) {
              var ve = {}, Me = {}, ze = d.extend(!0, {}, M), je = d.inArray, Fe = d.isEmptyObject, qe = function(Tt, Nt, ti, ii, at, Hi) {
                for (var zt in Nt)
                  if (Nt[s.hOP](zt) && Tt[s.hOP](zt)) {
                    var qi = !1, Yi = !1, wi = Nt[zt], ft = E(wi), ai = ft == o.o, Jn = l.isA(wi) ? wi : [wi], On = ti[zt], Vn = Tt[zt], Yt = E(Vn), To = Hi ? Hi + "." : "", te = 'The option "' + To + zt + `" wasn't set, because`, X = [], re = [], he, be, xe, $e, Oe, ke, Et, Pe;
                    if (On = On === i ? {} : On, ai && Yt == o.o)
                      ii[zt] = {}, at[zt] = {}, qe(Vn, wi, On, ii[zt], at[zt], To + zt), d.each([Tt, ii, at], function(Dt, ni) {
                        Fe(ni[zt]) && delete ni[zt];
                      });
                    else if (!ai) {
                      for (ke = 0; ke < Jn[s.l]; ke++)
                        if (Oe = Jn[ke], ft = E(Oe), xe = ft == o.s && je(Oe, D) === -1, xe)
                          for (X.push(o.s), he = Oe.split(O), re = re.concat(he), Et = 0; Et < he[s.l]; Et++) {
                            for (be = he[Et].split(T), $e = be[0], Pe = 0; Pe < be[s.l]; Pe++)
                              if (Vn === be[Pe]) {
                                qi = !0;
                                break;
                              }
                            if (qi)
                              break;
                          }
                        else if (X.push(Oe), Yt === Oe) {
                          qi = !0;
                          break;
                        }
                      qi ? (Yi = Vn !== On, Yi && (ii[zt] = Vn), (xe ? je(On, be) < 0 : Yi) && (at[zt] = xe ? $e : Vn)) : H && console.warn(te + " it doesn't accept the type [ " + Yt.toUpperCase() + ' ] with the value of "' + Vn + `".\r
Accepted types are: [ ` + X.join(", ").toUpperCase() + " ]." + (re[length] > 0 ? `\r
Valid strings are: [ ` + re.join(", ").split(T).join(", ") + " ]." : "")), delete Tt[zt];
                    }
                  }
              };
              return qe(ze, F, oe || {}, ve, Me), !Fe(ze) && H && console.warn(`The following options are discarded due to invalidity:\r
` + e.JSON.stringify(ze, null, 2)), {
                _default: ve,
                _prepared: Me
              };
            }
          };
        }();
        function y() {
          _ || (_ = new b(C._defaults)), m || (m = new L(_));
        }
        function b(E) {
          var D = this, O = "overflow", T = "hidden", A = "scroll", P = d("body"), G = d('<div id="os-dummy-scrollbar-size"><div></div></div>'), U = G[0], $ = d(G.children("div").eq(0));
          P.append(G), G.hide().show();
          var k = Ce(U), se = {
            x: k.x === 0,
            y: k.y === 0
          }, ne = function() {
            var ue = e.navigator.userAgent, B = "indexOf", z = "substring", Y = ue[B]("MSIE "), x = ue[B]("Trident/"), M = ue[B]("Edge/"), F = ue[B]("rv:"), H, oe = parseInt;
            return Y > 0 ? H = oe(ue[z](Y + 5, ue[B](".", Y)), 10) : x > 0 ? H = oe(ue[z](F + 3, ue[B](".", F)), 10) : M > 0 && (H = oe(ue[z](M + 5, ue[B](".", M)), 10)), H;
          }();
          d.extend(D, {
            defaultOptions: E,
            msie: ne,
            autoUpdateLoop: !1,
            autoUpdateRecommended: !l.mO(),
            nativeScrollbarSize: k,
            nativeScrollbarIsOverlaid: se,
            nativeScrollbarStyling: function() {
              var ue = !1;
              G.addClass("os-viewport-native-scrollbars-invisible");
              try {
                ue = G.css("scrollbar-width") === "none" && (ne > 9 || !ne) || e.getComputedStyle(U, "::-webkit-scrollbar").getPropertyValue("display") === "none";
              } catch {
              }
              return ue;
            }(),
            overlayScrollbarDummySize: { x: 30, y: 30 },
            cssCalc: a._cssPropertyValue("width", "calc", "(1px)") || null,
            restrictedMeasuring: function() {
              G.css(O, T);
              var ue = {
                w: U[s.sW],
                h: U[s.sH]
              };
              G.css(O, "visible");
              var B = {
                w: U[s.sW],
                h: U[s.sH]
              };
              return ue.w - B.w !== 0 || ue.h - B.h !== 0;
            }(),
            rtlScrollBehavior: function() {
              G.css({ "overflow-y": T, "overflow-x": A, direction: "rtl" }).scrollLeft(0);
              var ue = G.offset(), B = $.offset();
              G.scrollLeft(-999);
              var z = $.offset();
              return {
                //origin direction = determines if the zero scroll position is on the left or right side
                //'i' means 'invert' (i === true means that the axis must be inverted to be correct)
                //true = on the left side
                //false = on the right side
                i: ue.left === B.left,
                //negative = determines if the maximum scroll is positive or negative
                //'n' means 'negate' (n === true means that the axis must be negated to be correct)
                //true = negative
                //false = positive
                n: B.left !== z.left
              };
            }(),
            supportTransform: !!a._cssProperty("transform"),
            supportTransition: !!a._cssProperty("transition"),
            supportPassiveEvents: function() {
              var ue = !1;
              try {
                e.addEventListener("test", null, Object.defineProperty({}, "passive", {
                  get: function() {
                    ue = !0;
                  }
                }));
              } catch {
              }
              return ue;
            }(),
            supportResizeObserver: !!l.rO(),
            supportMutationObserver: !!l.mO()
          }), G.removeAttr(s.s).remove(), function() {
            if (se.x && se.y)
              return;
            var ue = u.abs, B = l.wW(), z = l.wH(), Y = F(), x = function() {
              if (f().length > 0) {
                var H = l.wW(), oe = l.wH(), ve = H - B, Me = oe - z;
                if (ve === 0 && Me === 0)
                  return;
                var ze = u.round(H / (B / 100)), je = u.round(oe / (z / 100)), Fe = ue(ve), qe = ue(Me), Tt = ue(ze), Nt = ue(je), ti = F(), ii = Fe > 2 && qe > 2, at = !M(Tt, Nt), Hi = ti !== Y && Y > 0, zt = ii && at && Hi, qi = D.nativeScrollbarSize, Yi;
                zt && (P.append(G), Yi = D.nativeScrollbarSize = Ce(G[0]), G.remove(), (qi.x !== Yi.x || qi.y !== Yi.y) && d.each(f(), function() {
                  f(this) && f(this).update("zoom");
                })), B = H, z = oe, Y = ti;
              }
            };
            function M(H, oe) {
              var ve = ue(H), Me = ue(oe);
              return !(ve === Me || ve + 1 === Me || ve - 1 === Me);
            }
            function F() {
              var H = e.screen.deviceXDPI || 0, oe = e.screen.logicalXDPI || 1;
              return e.devicePixelRatio || H / oe;
            }
            d(e).on("resize", x);
          }();
          function Ce(ue) {
            return {
              x: ue[s.oH] - ue[s.cH],
              y: ue[s.oW] - ue[s.cW]
            };
          }
        }
        function L(E) {
          var D = this, O = d.inArray, T = l.now, A = "autoUpdate", P = A + "Interval", G = s.l, U = [], $ = [], k = !1, se = 33, ne = se, Ce = T(), ue, B = function() {
            if (U[G] > 0 && k) {
              ue = l.rAF()(function() {
                B();
              });
              var z = T(), Y = z - Ce, x, M, F, H, oe, ve;
              if (Y > ne) {
                Ce = z - Y % ne, x = se;
                for (var Me = 0; Me < U[G]; Me++)
                  M = U[Me], M !== i && (F = M.options(), H = F[A], oe = u.max(1, F[P]), ve = T(), (H === !0 || H === null) && ve - $[Me] > oe && (M.update("auto"), $[Me] = new Date(ve += oe)), x = u.max(1, u.min(x, oe)));
                ne = x;
              }
            } else
              ne = se;
          };
          D.add = function(z) {
            O(z, U) === -1 && (U.push(z), $.push(T()), U[G] > 0 && !k && (k = !0, E.autoUpdateLoop = k, B()));
          }, D.remove = function(z) {
            var Y = O(z, U);
            Y > -1 && ($.splice(Y, 1), U.splice(Y, 1), U[G] === 0 && k && (k = !1, E.autoUpdateLoop = k, ue !== i && (l.cAF()(ue), ue = -1)));
          };
        }
        function S(E, D, O, T, A) {
          var P = l.type, G = d.inArray, U = d.each, $ = new g(), k = d[s.p];
          if (!zP(E))
            return;
          if (f(E)) {
            var se = f(E);
            return se.options(D), se;
          }
          var ne, Ce, ue, B, z, Y, x, M, F, H, oe, ve, Me, ze, je, Fe, qe, Tt, Nt, ti, ii, at, Hi, zt, qi, Yi, wi, ft, ai, Jn = {}, On = {}, Vn = {}, Yt = {}, To = {}, te = "-hidden", X = "margin-", re = "padding-", he = "border-", be = "top", xe = "right", $e = "bottom", Oe = "left", ke = "min-", Et = "max-", Pe = "width", Dt = "height", ni = "float", We = "", hi = "auto", Ql = "sync", Tr = "scroll", Oo = "100%", oo = "x", nl = "y", Or = ".", vn = " ", hh = "scrollbar", ic = "-horizontal", Ii = "-vertical", di = Tr + "Left", Xi = Tr + "Top", rn = "mousedown touchstart", Jl = "mouseup touchend touchcancel", nc = "mousemove touchmove", Q_ = "mouseenter", UI = "mouseleave", U0 = "keydown", z0 = "keyup", Ng = "selectstart", j0 = "transitionend webkitTransitionEnd oTransitionEnd", $0 = "__overlayScrollbarsRO__", so = "os-", zI = so + "html", kr = so + "host", J_ = kr + "-foreign", K0 = kr + "-textarea", jI = kr + "-" + hh + ic + te, $I = kr + "-" + hh + Ii + te, KI = kr + "-transition", qI = kr + "-rtl", q0 = kr + "-resize-disabled", eC = kr + "-scrolling", Ig = kr + "-overflow", Ig = kr + "-overflow", YI = Ig + "-x", XI = Ig + "-y", tC = so + "textarea", Z7 = tC + "-cover", Y0 = so + "padding", iC = so + "viewport", X0 = iC + "-native-scrollbars-invisible", ZI = iC + "-native-scrollbars-overlaid", Z0 = so + "content", Q7 = so + "content-arrange", J7 = so + "content-glue", eU = so + "size-auto-observer", dh = so + "resize-observer", nC = so + "resize-observer-item", QI = nC + "-final", rC = so + "text-inherit", eu = so + hh, JI = eu + "-track", eP = JI + "-off", tP = eu + "-handle", iP = tP + "-off", nP = eu + "-unusable", Pg = eu + "-" + hi + te, Q0 = eu + "-corner", Ag = Q0 + "-resize", rP = Ag + "-both", oP = Ag + ic, sP = Ag + Ii, tU = eu + ic, iU = eu + Ii, fh = so + "dragging", oC = so + "theme-none", J0 = [
            X0,
            ZI,
            eP,
            iP,
            nP,
            Pg,
            Ag,
            rP,
            oP,
            sP,
            fh
          ].join(vn), eE = [], tE = [s.ti], aP, Mg, Bn, tu = {}, nU = "added removed on contract", lP, ph = {}, uP, cP = 42, iE = "load", gh = [], sC, rl, nf, mh, jt, rt, Ca, ya, Ps, It, un, iu, Wr, nu, ao, vh, aC, Fg, _h, lC, kg, Wg, rf, rc, qo, uC, cC, oc, Ch, As, Vg, yh, hP, ol, Bg, Ms, sc, dP, nE, fP, pP, gP, mP, vP, _P, CP, of, sf, rE, oE, yP, wP, bP, SP, EP, LP, sE, DP, ru, Hg, aE, hC, lE, RP, TP, OP, ac, xP = {}, dC, fC, uE, cE, sl, NP = ["wrap", "cols", "rows"], hE = [s.i, s.c, s.s, "open"].concat(tE), dE = [], fE, IP, PP, pE, gE, lc, Fs, wh, mE, uc, pC, gC, vE, _E;
          function xo(N, W, K, Z, ie) {
            var ce = l.isA(W) && l.isA(K), me = Z ? "removeEventListener" : "addEventListener", Re = Z ? "off" : "on", De = ce ? !1 : W.split(vn), Te = 0, nt = d.isPlainObject(ie), Ye = oe && (nt ? ie._passive : ie) || !1, gt = nt && (ie._capture || !1), Lt = oe ? {
              passive: Ye,
              capture: gt
            } : gt;
            if (ce)
              for (; Te < W[s.l]; Te++)
                xo(N, W[Te], K[Te], Z, ie);
            else
              for (; Te < De[s.l]; Te++)
                oe ? N[0][me](De[Te], K, Lt) : N[Re](De[Te], K);
          }
          function wa(N, W, K, Z) {
            xo(N, W, K, !1, Z), dE.push(l.bind(xo, 0, N, W, K, !0, Z));
          }
          function mC(N, W) {
            if (N) {
              var K = l.rO(), Z = "animationstart mozAnimationStart webkitAnimationStart MSAnimationStart", ie = "childNodes", ce = 3333333, me = function() {
                N[Xi](ce)[di](ft ? ue.n ? -ce : ue.i ? 0 : ce : ce), W();
              };
              if (W) {
                if (ve) {
                  var Re = N.addClass("observed").append(Xo(dh)).contents()[0], De = Re[$0] = new K(me);
                  De.observe(Re);
                } else if (z > 9 || !B) {
                  N.prepend(
                    Xo(
                      dh,
                      Xo(
                        { c: nC, dir: "ltr" },
                        Xo(
                          nC,
                          Xo(QI)
                        ) + Xo(
                          nC,
                          Xo({ c: QI, style: "width: 200%; height: 200%" })
                        )
                      )
                    )
                  );
                  var Te = N[0][ie][0][ie][0], nt = d(Te[ie][1]), Ye = d(Te[ie][0]), gt = d(Ye[0][ie][0]), Lt = Te[s.oW], $t = Te[s.oH], lt, Xt, Pt, Zi, Nr = 2, _n = T.nativeScrollbarSize, uo = function() {
                    Ye[di](ce)[Xi](ce), nt[di](ce)[Xi](ce);
                  }, er = function() {
                    Xt = 0, lt && (Lt = Pt, $t = Zi, me());
                  }, Nn = function(bi) {
                    return Pt = Te[s.oW], Zi = Te[s.oH], lt = Pt != Lt || Zi != $t, bi && lt && !Xt ? (l.cAF()(Xt), Xt = l.rAF()(er)) : bi || er(), uo(), bi && (l.prvD(bi), l.stpP(bi)), !1;
                  }, In = {}, cn = {};
                  bh(cn, We, [
                    -((_n.y + 1) * Nr),
                    _n.x * -Nr,
                    _n.y * -Nr,
                    -((_n.x + 1) * Nr)
                  ]), d(Te).css(cn), Ye.on(Tr, Nn), nt.on(Tr, Nn), N.on(Z, function() {
                    Nn(!1);
                  }), In[Pe] = ce, In[Dt] = ce, gt.css(In), uo();
                } else {
                  var Hn = rf.attachEvent, Ea = z !== i;
                  if (Hn)
                    N.prepend(Xo(dh)), af(N, Or + dh)[0].attachEvent("onresize", me);
                  else {
                    var hn = rf.createElement(o.o);
                    hn.setAttribute(s.ti, "-1"), hn.setAttribute(s.c, dh), hn.onload = function() {
                      var bi = this.contentDocument.defaultView;
                      bi.addEventListener("resize", me), bi.document.documentElement.style.display = "none";
                    }, hn.type = "text/html", Ea && N.prepend(hn), hn.data = "about:blank", Ea || N.prepend(hn), N.on(Z, me);
                  }
                }
                if (N[0] === cC) {
                  var Vs = function() {
                    var bi = rt.css("direction"), He = {}, Qi = 0, Ji = !1;
                    return bi !== mP && (bi === "ltr" ? (He[Oe] = 0, He[xe] = hi, Qi = ce) : (He[Oe] = hi, He[xe] = 0, Qi = ue.n ? -ce : ue.i ? 0 : ce), ya.children().eq(0).css(He), ya[di](Qi)[Xi](ce), mP = bi, Ji = !0), Ji;
                  };
                  Vs(), wa(N, Tr, function(bi) {
                    return Vs() && ba(), l.prvD(bi), l.stpP(bi), !1;
                  });
                }
              } else if (ve) {
                var Re = N.contents()[0], Pi = Re[$0];
                Pi && (Pi.disconnect(), delete Re[$0]);
              } else
                su(N.children(Or + dh).eq(0));
            }
          }
          function rU() {
            if (Me) {
              var N = 11, W = l.mO(), K = l.now(), Z, ie, ce, me, Re, De, Te, nt, Ye, gt;
              uE = function(Lt) {
                var $t = !1, lt = !1, Xt, Pt = [];
                return ze && !ai && (U(Lt, function() {
                  Xt = this, Z = Xt.target, ie = Xt.attributeName, ce = ie === s.c, me = Xt.oldValue, Re = Z.className, Nt && ce && !lt && me.indexOf(J_) > -1 && Re.indexOf(J_) < 0 && (De = UP(!0), qo.className = Re.split(vn).concat(me.split(vn).filter(function(Zi) {
                    return Zi.match(De);
                  })).join(vn), $t = lt = !0), $t || ($t = ce ? WP(me, Re) : ie === s.s ? me !== Z[s.s].cssText : !0), Pt.push(ie);
                }), bE(Pt), $t && $.update(lt || hi)), $t;
              }, cE = function(Lt) {
                var $t = !1, lt;
                return ze && !ai && (U(Lt, function() {
                  return lt = this, $t = aU(lt), !$t;
                }), $t && (nt = l.now(), Ye = sc || Ms, gt = function() {
                  je || (K = nt, Fe && SE(), Ye ? ba() : $.update(hi));
                }, clearTimeout(Te), N <= 0 || nt - K > N || !Ye ? gt() : Te = setTimeout(gt, N))), $t;
              }, dC = new W(uE), fC = new W(cE);
            }
          }
          function AP() {
            Me && !sl && (dC.observe(qo, {
              attributes: !0,
              attributeOldValue: !0,
              attributeFilter: hE
            }), fC.observe(Fe ? rc : As, {
              attributes: !0,
              attributeOldValue: !0,
              subtree: !Fe,
              childList: !Fe,
              characterData: !Fe,
              attributeFilter: Fe ? NP : hE
            }), sl = !0);
          }
          function CE() {
            Me && sl && (dC.disconnect(), fC.disconnect(), sl = !1);
          }
          function oU() {
            if (!ai) {
              var N, W = {
                w: cC[s.sW],
                h: cC[s.sH]
              };
              N = Sh(W, bP), bP = W, N && ba({ _hostSizeChanged: !0 });
            }
          }
          function MP() {
            wh && al(!0);
          }
          function FP() {
            wh && !mh.hasClass(fh) && al(!1);
          }
          function sU() {
            Fs && (al(!0), clearTimeout(PP), PP = setTimeout(function() {
              Fs && !je && al(!1);
            }, 100));
          }
          function Gg(N) {
            return l.prvD(N), !1;
          }
          function yE(N) {
            if (!je) {
              var W = N.target, K = d(N.target), Z = d.inArray(W, gh);
              Z > -1 && gh.splice(Z, 1), $P(function(ie, ce) {
                K.is(ce) && ba({ _contentSizeChanged: !0 });
              });
            }
          }
          function wE(N) {
            N || wE(!0), xo(
              rt,
              nc.split(vn)[0],
              sU,
              !Fs || N,
              !0
            ), xo(
              rt,
              [Q_, UI],
              [MP, FP],
              !wh || N,
              !0
            ), !ze && !N && rt.one("mouseover", MP);
          }
          function kP() {
            var N = {};
            return qe && iu && (N.w = ll(iu.css(ke + Pe)), N.h = ll(iu.css(ke + Dt)), N.c = Sh(N, ac), N.f = !0), ac = N, !!N.c;
          }
          function WP(N, W) {
            var K = typeof W == o.s ? W.split(vn) : [], Z = typeof N == o.s ? N.split(vn) : [], ie = pU(Z, K), ce = G(oC, ie), me, Re;
            if (ce > -1 && ie.splice(ce, 1), ie[s.l] > 0) {
              for (Re = UP(!0, !0), me = 0; me < ie.length; me++)
                if (!ie[me].match(Re))
                  return !0;
            }
            return !1;
          }
          function aU(N) {
            var W = N.attributeName, K = N.target, Z = N.type, ie = "closest";
            if (K === As)
              return W === null;
            if (Z === "attributes" && (W === s.c || W === s.s) && !Fe) {
              if (W === s.c && d(K).hasClass(kr))
                return WP(N.oldValue, K.className);
              if (typeof K[ie] != o.f)
                return !0;
              if (K[ie](Or + dh) !== null || K[ie](Or + eu) !== null || K[ie](Or + Q0) !== null)
                return !1;
            }
            return !0;
          }
          function lU() {
            if (ai)
              return !1;
            var N = jP(), W = Fe && Ms && !hC ? jt.val().length : 0, K = !sl && Ms && !Fe, Z = {}, ie, ce, me, Re;
            return K && (ie = un.css(ni), Z[ni] = ft ? xe : Oe, Z[Pe] = hi, un.css(Z)), Re = {
              w: N[s.sW] + W,
              h: N[s.sH] + W
            }, K && (Z[ni] = ie, Z[Pe] = Oo, un.css(Z)), ce = kP(), me = Sh(Re, wP), wP = Re, me || ce;
          }
          function uU() {
            if (!(ai || sl)) {
              var N, W, K, Z = [], ie = [
                {
                  _elem: rt,
                  _attrs: hE.concat(":visible")
                },
                {
                  _elem: Fe ? jt : i,
                  _attrs: NP
                }
              ];
              return U(ie, function(ce, me) {
                N = me._elem, N && U(me._attrs, function(Re, De) {
                  W = De.charAt(0) === ":" ? N.is(De) : N.attr(De), K = xP[De], Sh(W, K) && Z.push(De), xP[De] = W;
                });
              }), bE(Z), Z[s.l] > 0;
            }
          }
          function cU(N) {
            if (!ze)
              return !0;
            var W = "flex-grow", K = "flex-shrink", Z = "flex-basis", ie = [
              Pe,
              ke + Pe,
              Et + Pe,
              X + Oe,
              X + xe,
              Oe,
              xe,
              "font-weight",
              "word-spacing",
              W,
              K,
              Z
            ], ce = [
              re + Oe,
              re + xe,
              he + Oe + Pe,
              he + xe + Pe
            ], me = [
              Dt,
              ke + Dt,
              Et + Dt,
              X + be,
              X + $e,
              be,
              $e,
              "line-height",
              W,
              K,
              Z
            ], Re = [
              re + be,
              re + $e,
              he + be + Pe,
              he + $e + Pe
            ], De = "s", Te = "v-s", nt = of.x === De || of.x === Te, Ye = of.y === De || of.y === Te, gt = !1, Lt = function($t, lt) {
              for (var Xt = 0; Xt < $t[s.l]; Xt++)
                if ($t[Xt] === lt)
                  return !0;
              return !1;
            };
            return Ye && (gt = Lt(me, N), !gt && !ti && (gt = Lt(Re, N))), nt && !gt && (gt = Lt(ie, N), !gt && !ti && (gt = Lt(ce, N))), gt;
          }
          function bE(N) {
            N = N || tE, U(N, function(W, K) {
              if (l.inA(K, tE) > -1) {
                var Z = jt.attr(K);
                P(Z) == o.s ? It.attr(K, Z) : It.removeAttr(K);
              }
            });
          }
          function SE() {
            if (!ai) {
              var N = !hC, W = Yt.w, K = Yt.h, Z = {}, ie = Ms || N, ce, me, Re, De;
              return Z[ke + Pe] = We, Z[ke + Dt] = We, Z[Pe] = hi, jt.css(Z), ce = rc[s.oW], me = ie ? u.max(ce, rc[s.sW] - 1) : 1, Z[Pe] = Ms ? hi : Oo, Z[ke + Pe] = Oo, Z[Dt] = hi, jt.css(Z), Re = rc[s.oH], De = u.max(Re, rc[s.sH] - 1), Z[Pe] = me, Z[Dt] = De, nu.css(Z), Z[ke + Pe] = W, Z[ke + Dt] = K, jt.css(Z), {
                _originalWidth: ce,
                _originalHeight: Re,
                _dynamicWidth: me,
                _dynamicHeight: De
              };
            }
          }
          function ba(N) {
            clearTimeout(uP), N = N || {}, ph._hostSizeChanged |= N._hostSizeChanged, ph._contentSizeChanged |= N._contentSizeChanged, ph._force |= N._force;
            var W = l.now(), K = !!ph._hostSizeChanged, Z = !!ph._contentSizeChanged, ie = !!ph._force, ce = N._changedOptions, me = ze && !je && !ie && !ce && W - lP < cP && !sc && !Ms, Re;
            if (me && (uP = setTimeout(ba, cP)), !(je || me || ai && !ce || ze && !ie && (Re = rt.is(":hidden")) || rt.css("display") === "inline")) {
              lP = W, ph = {}, Y && !(ne.x && ne.y) ? (M.x = 0, M.y = 0) : M = lo({}, T.nativeScrollbarSize), To = {
                x: (M.x + (ne.x ? 0 : 3)) * 3,
                y: (M.y + (ne.y ? 0 : 3)) * 3
              }, ce = ce || {};
              var De = function() {
                return Sh.apply(this, [].slice.call(arguments).concat([ie]));
              }, Te = {
                x: It[di](),
                y: It[Xi]()
              }, nt = Bn.scrollbars, Ye = Bn.textarea, gt = nt.visibility, Lt = De(gt, SP), $t = nt.autoHide, lt = De($t, EP), Xt = nt.clickScrolling, Pt = De(Xt, LP), Zi = nt.dragScrolling, Nr = De(Zi, sE), _n = Bn.className, uo = De(_n, Hg), er = Bn.resize, Nn = De(er, DP) && !qe, In = Bn.paddingAbsolute, cn = De(In, vP), Hn = Bn.clipAlways, Ea = De(Hn, _P), hn = Bn.sizeAutoCapable && !qe, Vs = De(hn, yP), Pi = Bn.nativeScrollbarsOverlaid.showNativeScrollbars, bi = De(Pi, rE), He = Bn.autoUpdate, Qi = De(He, oE), Ji = Bn.overflowBehavior, Zo = De(Ji, of, ie), au = Ye.dynWidth, Eh = De(OP, au), co = Ye.dynHeight, ul = De(TP, co);
              if (gE = $t === "n", lc = $t === "s", Fs = $t === "m", wh = $t === "l", pE = nt.autoHideDelay, aE = Hg, pC = er === "n", gC = er === "b", vE = er === "h", _E = er === "v", ru = Bn.normalizeRTL, Pi = Pi && ne.x && ne.y, SP = gt, EP = $t, LP = Xt, sE = Zi, Hg = _n, DP = er, vP = In, _P = Hn, yP = hn, rE = Pi, oE = He, of = lo({}, Ji), OP = au, TP = co, ol = ol || { x: !1, y: !1 }, uo && (xr(rt, aE + vn + oC), xn(rt, _n !== i && _n !== null && _n.length > 0 ? _n : oC)), Qi && (He === !0 || He === null && B ? (CE(), A.add($)) : (A.remove($), AP())), Vs)
                if (hn)
                  if (Wr ? Wr.show() : (Wr = d(Xo(J7)), Ps.before(Wr)), ii)
                    Ca.show();
                  else {
                    Ca = d(Xo(eU)), uC = Ca[0], Wr.before(Ca);
                    var cl = { w: -1, h: -1 };
                    mC(Ca, function() {
                      var Dh = {
                        w: uC[s.oW],
                        h: uC[s.oH]
                      };
                      Sh(Dh, cl) && (ze && sc && Dh.h > 0 || Ms && Dh.w > 0 || ze && !sc && Dh.h === 0 || !Ms && Dh.w === 0) && ba(), cl = Dh;
                    }), ii = !0, x !== null && Ca.css(Dt, x + "(100% + 1px)");
                  }
                else
                  ii && Ca.hide(), Wr && Wr.hide();
              ie && (ya.find("*").trigger(Tr), ii && Ca.find("*").trigger(Tr)), Re = Re === i ? rt.is(":hidden") : Re;
              var Qo = Fe ? jt.attr("wrap") !== "off" : !1, zg = De(Qo, hC), Jo = rt.css("direction"), Vr = De(Jo, gP), lu = rt.css("box-sizing"), es = De(lu, dP), on = OE(re), vr;
              try {
                vr = ii ? uC[s.bCR]() : null;
              } catch {
                return;
              }
              ft = Jo === "rtl", ti = lu === "border-box";
              var _r = ft ? Oe : xe, Zt = ft ? xe : Oe, Bs = !1, cc = ii && rt.css(ni) !== "none" ? u.round(vr.right - vr.left) === 0 && (In ? !0 : qo[s.cW] - at > 0) : !1;
              if (hn && !cc) {
                var Lh = qo[s.oW], uu = Wr.css(Pe);
                Wr.css(Pe, hi);
                var hl = qo[s.oW];
                Wr.css(Pe, uu), Bs = Lh !== hl, Bs || (Wr.css(Pe, Lh + 1), hl = qo[s.oW], Wr.css(Pe, uu), Bs = Lh !== hl);
              }
              var Bt = (cc || Bs) && hn && !Re, Cr = De(Bt, Ms), cu = !Bt && Ms, Gi = ii && hn && !Re ? u.round(vr.bottom - vr.top) === 0 : !1, yr = De(Gi, sc), Hs = !Gi && sc, jg = Bt && ti || !ti, vC = Gi && ti || !ti, Gs = OE(he, "-" + Pe, !jg, !vC), dl = OE(X), Qe = {}, tt = {}, Cn = function() {
                return {
                  w: qo[s.cW],
                  h: qo[s.cH]
                };
              }, Br = function() {
                return {
                  w: oc[s.oW] + u.max(0, As[s.cW] - As[s.sW]),
                  h: oc[s.oH] + u.max(0, As[s.cH] - As[s.sH])
                };
              }, _i = at = on.l + on.r, Us = Hi = on.t + on.b;
              if (_i *= In ? 1 : 0, Us *= In ? 1 : 0, on.c = De(on, nE), zt = Gs.l + Gs.r, qi = Gs.t + Gs.b, Gs.c = De(Gs, fP), Yi = dl.l + dl.r, wi = dl.t + dl.b, dl.c = De(dl, pP), hC = Qo, gP = Jo, dP = lu, Ms = Bt, sc = Gi, nE = on, fP = Gs, pP = dl, Vr && ii && Ca.css(ni, Zt), on.c || Vr || cn || Cr || yr || es || Vs) {
                var Pn = {}, ho = {}, hc = [on.t, on.r, on.b, on.l];
                bh(tt, X, [-on.t, -on.r, -on.b, -on.l]), In ? (bh(Pn, We, hc), bh(Fe ? ho : Qe, re)) : (bh(Pn, We), bh(Fe ? ho : Qe, re, hc)), Ps.css(Pn), jt.css(ho);
              }
              Yt = Br();
              var en = Fe ? SE() : !1, zs = Fe && De(en, RP), fl = Fe && en ? {
                w: au ? en._dynamicWidth : en._originalWidth,
                h: co ? en._dynamicHeight : en._originalHeight
              } : {};
              if (RP = en, Gi && (yr || cn || es || on.c || Gs.c) ? Qe[Dt] = hi : (yr || cn) && (Qe[Dt] = Oo), Bt && (Cr || cn || es || on.c || Gs.c || Vr) ? (Qe[Pe] = hi, tt[Et + Pe] = Oo) : (Cr || cn) && (Qe[Pe] = Oo, Qe[ni] = We, tt[Et + Pe] = We), Bt ? (tt[Pe] = hi, Qe[Pe] = a._cssPropertyValue(Pe, "max-content intrinsic") || hi, Qe[ni] = Zt) : tt[Pe] = We, Gi ? tt[Dt] = fl.h || As[s.cH] : tt[Dt] = We, hn && Wr.css(tt), un.css(Qe), Qe = {}, tt = {}, K || Z || zs || Vr || es || cn || Cr || Bt || yr || Gi || bi || Zo || Ea || Nn || Lt || lt || Nr || Pt || Eh || ul || zg) {
                var tr = "overflow", hu = tr + "-x", pl = tr + "-y", dc = "hidden", js = "visible";
                if (!Y) {
                  var gl = {}, IE = ol.y && Bg.ys && !Pi ? ne.y ? It.css(_r) : -M.y : 0, _U = ol.x && Bg.xs && !Pi ? ne.x ? It.css($e) : -M.x : 0;
                  bh(gl, We), It.css(gl);
                }
                var fc = jP(), $g = {
                  //use clientSize because natively overlaidScrollbars add borders
                  w: fl.w || fc[s.cW],
                  h: fl.h || fc[s.cH]
                }, KP = {
                  w: fc[s.sW],
                  h: fc[s.sH]
                };
                Y || (gl[$e] = Hs ? We : _U, gl[_r] = cu ? We : IE, It.css(gl)), Yt = Br();
                var Kg = Cn(), PE = {
                  w: Kg.w - Yi - zt - (ti ? 0 : at),
                  h: Kg.h - wi - qi - (ti ? 0 : Hi)
                }, lf = {
                  //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually
                  //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding
                  w: u.max((Bt ? $g.w : KP.w) + _i, PE.w),
                  h: u.max((Gi ? $g.h : KP.h) + Us, PE.h)
                };
                if (lf.c = De(lf, CP), CP = lf, hn) {
                  (lf.c || Gi || Bt) && (tt[Pe] = lf.w, tt[Dt] = lf.h, Fe || ($g = {
                    //use clientSize because natively overlaidScrollbars add borders
                    w: fc[s.cW],
                    h: fc[s.cH]
                  }));
                  var qP = {}, YP = function(yn) {
                    var Ir = ks(yn), $s = Ir._w_h, dn = Ir._width_height, Qt = yn ? Bt : Gi, La = yn ? zt : qi, Rh = yn ? at : Hi, WE = yn ? Yi : wi, SC = Yt[$s] - La - WE - (ti ? 0 : Rh);
                    (!Qt || !Qt && Gs.c) && (tt[dn] = PE[$s] - 1), Qt && $g[$s] < SC && (!(yn && Fe) || !Qo) && (Fe && (qP[dn] = ll(nu.css(dn)) - 1), tt[dn] -= 1), $g[$s] > 0 && (tt[dn] = u.max(1, tt[dn]));
                  };
                  YP(!0), YP(!1), Fe && nu.css(qP), Wr.css(tt);
                }
                Bt && (Qe[Pe] = Oo), Bt && !ti && !sl && (Qe[ni] = "none"), un.css(Qe), Qe = {};
                var pc = {
                  w: fc[s.sW],
                  h: fc[s.sH]
                };
                pc.c = Z = De(pc, yh), yh = pc, Yt = Br(), Kg = Cn(), K = De(Kg, Vg), Vg = Kg;
                var AE = Fe && (Yt.w === 0 || Yt.h === 0), _C = sf, uf = {}, qg = {}, XP = {}, ml = {}, tn = {}, Ai = {}, Yg = {}, ZP = oc[s.bCR](), QP = function(yn) {
                  var Ir = ks(yn), $s = ks(!yn), dn = $s._x_y, Qt = Ir._x_y, La = Ir._w_h, Rh = Ir._width_height, WE = Tr + Ir._Left_Top + "Max", SC = ZP[Rh] ? u.abs(ZP[Rh] - Yt[La]) : 0, NU = _C && _C[Qt] > 0 && Ch[WE] === 0;
                  uf[Qt] = Ji[Qt] === "v-s", qg[Qt] = Ji[Qt] === "v-h", XP[Qt] = Ji[Qt] === "s", ml[Qt] = u.max(0, u.round((pc[La] - Yt[La]) * 100) / 100), ml[Qt] *= AE || NU && SC > 0 && SC < 1 ? 0 : 1, tn[Qt] = ml[Qt] > 0, Ai[Qt] = uf[Qt] || qg[Qt] ? tn[dn] && !uf[dn] && !qg[dn] : tn[Qt], Ai[Qt + "s"] = Ai[Qt] ? XP[Qt] || uf[Qt] : !1, Yg[Qt] = tn[Qt] && Ai[Qt + "s"];
                };
                if (QP(!0), QP(!1), ml.c = De(ml, sf), sf = ml, tn.c = De(tn, ol), ol = tn, Ai.c = De(Ai, Bg), Bg = Ai, ne.x || ne.y) {
                  var CU = "px solid transparent", ME = {}, du = {}, CC = ie, FE;
                  (tn.x || tn.y) && (du.w = ne.y && tn.y ? pc.w + Ce.y : We, du.h = ne.x && tn.x ? pc.h + Ce.x : We, CC = De(du, hP), hP = du), (tn.c || Ai.c || pc.c || Vr || Cr || yr || Bt || Gi || bi) && (Qe[X + Zt] = Qe[he + Zt] = We, FE = function(yn) {
                    var Ir = ks(yn), $s = ks(!yn), dn = Ir._x_y, Qt = yn ? $e : _r, La = yn ? Gi : Bt;
                    ne[dn] && tn[dn] && Ai[dn + "s"] ? (Qe[X + Qt] = La ? Pi ? We : Ce[dn] : We, Qe[he + Qt] = (!yn || !La) && !Pi ? Ce[dn] + CU : We) : (du[$s._w_h] = Qe[X + Qt] = Qe[he + Qt] = We, CC = !0);
                  }, Y ? Ws(It, X0, !Pi) : (FE(!0), FE(!1))), Pi && (du.w = du.h = We, CC = !0), CC && !Y && (ME[Pe] = Ai.y ? du.w : We, ME[Dt] = Ai.x ? du.h : We, iu || (iu = d(Xo(Q7)), It.prepend(iu)), iu.css(ME)), un.css(Qe);
                }
                var ir = {}, Pn = {}, kE;
                if ((K || tn.c || Ai.c || pc.c || Zo || es || bi || Vr || Ea || yr) && (ir[Zt] = We, kE = function(yn) {
                  var Ir = ks(yn), $s = ks(!yn), dn = Ir._x_y, Qt = Ir._X_Y, La = yn ? $e : _r, Rh = function() {
                    ir[La] = We, Jn[$s._w_h] = 0;
                  };
                  tn[dn] && Ai[dn + "s"] ? (ir[tr + Qt] = Tr, Pi || Y ? Rh() : (ir[La] = -(ne[dn] ? Ce[dn] : M[dn]), Jn[$s._w_h] = ne[dn] ? Ce[$s._x_y] : 0)) : (ir[tr + Qt] = We, Rh());
                }, kE(!0), kE(!1), !Y && (Yt.h < To.x || Yt.w < To.y) && (tn.x && Ai.x && !ne.x || tn.y && Ai.y && !ne.y) ? (ir[re + be] = To.x, ir[X + be] = -To.x, ir[re + Zt] = To.y, ir[X + Zt] = -To.y) : ir[re + be] = ir[X + be] = ir[re + Zt] = ir[X + Zt] = We, ir[re + _r] = ir[X + _r] = We, tn.x && Ai.x || tn.y && Ai.y || AE ? Fe && AE && (Pn[hu] = Pn[pl] = dc) : (!Hn || qg.x || uf.x || qg.y || uf.y) && (Fe && (Pn[hu] = Pn[pl] = We), ir[hu] = ir[pl] = js), Ps.css(Pn), It.css(ir), ir = {}, (tn.c || es || Cr || yr) && !(ne.x && ne.y))) {
                  var yC = As[s.s];
                  yC.webkitTransform = "scale(1)", yC.display = "run-in", As[s.oH], yC.display = We, yC.webkitTransform = We;
                }
                if (Qe = {}, Vr || Cr || yr)
                  if (ft && Bt) {
                    var yU = un.css(ni), JP = u.round(un.css(ni, We).css(Oe, We).position().left);
                    un.css(ni, yU);
                    var wU = u.round(un.position().left);
                    JP !== wU && (Qe[Oe] = JP);
                  } else
                    Qe[Oe] = We;
                if (un.css(Qe), Fe && Z) {
                  var vl = gU();
                  if (vl) {
                    var eA = lE === i ? !0 : vl._rows !== lE._rows, tA = vl._cursorRow, bU = vl._cursorColumn, SU = vl._widestRow, EU = vl._rows, LU = vl._columns, DU = vl._cursorPosition, RU = vl._cursorMax, iA = DU >= RU && fE, wC = {
                      x: !Qo && bU === LU && tA === SU ? sf.x : -1,
                      y: (Qo ? iA || eA && (_C && Te.y === _C.y) : (iA || eA) && tA === EU) ? sf.y : -1
                    };
                    Te.x = wC.x > -1 ? ft && ru && ue.i ? 0 : wC.x : Te.x, Te.y = wC.y > -1 ? wC.y : Te.y;
                  }
                  lE = vl;
                }
                ft && ue.i && ne.y && tn.x && ru && (Te.x += Jn.w || 0), Bt && rt[di](0), Gi && rt[Xi](0), It[di](Te.x)[Xi](Te.y);
                var TU = gt === "v", OU = gt === "h", xU = gt === "a", bC = function(yn, Ir) {
                  Ir = Ir === i ? yn : Ir, HP(!0, yn, Yg.x), HP(!1, Ir, Yg.y);
                };
                Ws(rt, Ig, Ai.x || Ai.y), Ws(rt, YI, Ai.x), Ws(rt, XI, Ai.y), Vr && !qe && Ws(rt, qI, ft), qe && xn(rt, q0), Nn && (Ws(rt, q0, pC), Ws(ao, Ag, !pC), Ws(ao, rP, gC), Ws(ao, oP, vE), Ws(ao, sP, _E)), (Lt || Zo || Ai.c || tn.c || bi) && (Pi ? bi && (xr(rt, eC), Pi && bC(!1)) : xU ? bC(Yg.x, Yg.y) : TU ? bC(!0) : OU && bC(!1)), (lt || bi) && (wE(!wh && !Fs), al(gE, !gE)), (K || ml.c || yr || Cr || Nn || es || cn || bi || Vr) && (RE(!0), Sa(!0), RE(!1), Sa(!1)), Pt && GP(!0, Xt), Nr && GP(!1, Zi), Yo("onDirectionChanged", {
                  isRTL: ft,
                  dir: Jo
                }, Vr), Yo("onHostSizeChanged", {
                  width: Vg.w,
                  height: Vg.h
                }, K), Yo("onContentSizeChanged", {
                  width: yh.w,
                  height: yh.h
                }, Z), Yo("onOverflowChanged", {
                  x: tn.x,
                  y: tn.y,
                  xScrollable: Ai.xs,
                  yScrollable: Ai.ys,
                  clipped: Ai.x || Ai.y
                }, tn.c || Ai.c), Yo("onOverflowAmountChanged", {
                  x: ml.x,
                  y: ml.y
                }, ml.c);
              }
              qe && ac && (ol.c || ac.c) && (ac.f || kP(), ne.y && ol.x && un.css(ke + Pe, ac.w + Ce.y), ne.x && ol.y && un.css(ke + Dt, ac.h + Ce.x), ac.c = !1), ze && ce.updateOnLoad && VP(), Yo("onUpdated", { forced: ie });
            }
          }
          function VP() {
            Fe || $P(function(N, W) {
              un.find(W).each(function(K, Z) {
                l.inA(Z, gh) < 0 && (gh.push(Z), d(Z).off(iE, yE).on(iE, yE));
              });
            });
          }
          function EE(N) {
            var W = C._validate(N, C._template, !0, Mg);
            return Mg = lo({}, Mg, W._default), Bn = lo({}, Bn, W._prepared), W._prepared;
          }
          function LE(N) {
            var W = "parent", K = "os-resize-observer-host", Z = tC + vn + rC, ie = Fe ? vn + rC : We, ce = Bn.textarea.inheritedAttrs, me = {}, Re = function() {
              var nt = N ? jt : rt;
              U(me, function(Ye, gt) {
                P(gt) == o.s && (Ye == s.c ? nt.addClass(gt) : nt.attr(Ye, gt));
              });
            }, De = [
              kr,
              J_,
              K0,
              q0,
              qI,
              jI,
              $I,
              KI,
              eC,
              Ig,
              YI,
              XI,
              oC,
              tC,
              rC,
              Hg
            ].join(vn), Te = {};
            rt = rt || (Fe ? Nt ? jt[W]()[W]()[W]()[W]() : d(Xo(K0)) : jt), un = un || ou(Z0 + ie), It = It || ou(iC + ie), Ps = Ps || ou(Y0 + ie), ya = ya || ou(K), nu = nu || (Fe ? ou(Z7) : i), Nt && xn(rt, J_), N && xr(rt, De), ce = P(ce) == o.s ? ce.split(vn) : ce, l.isA(ce) && Fe && U(ce, function(nt, Ye) {
              P(Ye) == o.s && (me[Ye] = N ? rt.attr(Ye) : jt.attr(Ye));
            }), N ? (Nt && ze ? (ya.children().remove(), U([Ps, It, un, nu], function(nt, Ye) {
              Ye && xr(Ye.removeAttr(s.s), J0);
            }), xn(rt, Fe ? K0 : kr)) : (su(ya), un.contents().unwrap().unwrap().unwrap(), Fe && (jt.unwrap(), su(rt), su(nu), Re())), Fe && jt.removeAttr(s.s), qe && xr(nf, zI)) : (Fe && (Bn.sizeAutoCapable || (Te[Pe] = jt.css(Pe), Te[Dt] = jt.css(Dt)), Nt || jt.addClass(rC).wrap(rt), rt = jt[W]().css(Te)), Nt || (xn(jt, Fe ? Z : kr), rt.wrapInner(un).wrapInner(It).wrapInner(Ps).prepend(ya), un = af(rt, Or + Z0), It = af(rt, Or + iC), Ps = af(rt, Or + Y0), Fe && (un.prepend(nu), Re())), Y && xn(It, X0), ne.x && ne.y && xn(It, ZI), qe && xn(nf, zI), cC = ya[0], qo = rt[0], oc = Ps[0], Ch = It[0], As = un[0], bE());
          }
          function hU() {
            var N = [
              112,
              113,
              114,
              115,
              116,
              117,
              118,
              119,
              120,
              121,
              123,
              //F1 to F12
              33,
              34,
              //page up, page down
              37,
              38,
              39,
              40,
              //left, up, right, down arrows
              16,
              17,
              18,
              19,
              20,
              144
              //Shift, Ctrl, Alt, Pause, CapsLock, NumLock
            ], W = [], K, Z, ie = 175, ce = "focus";
            function me(lt) {
              SE(), $.update(hi), lt && B && clearInterval(K);
            }
            function Re(lt) {
              return jt[di](ue.i && ru ? 9999999 : 0), jt[Xi](0), l.prvD(lt), l.stpP(lt), !1;
            }
            function De(lt) {
              setTimeout(function() {
                je || me();
              }, 50);
            }
            function Te() {
              fE = !0, xn(rt, ce);
            }
            function nt() {
              fE = !1, W = [], xr(rt, ce), me(!0);
            }
            function Ye(lt) {
              var Xt = lt.keyCode;
              G(Xt, N) < 0 && (W[s.l] || (me(), K = setInterval(me, 1e3 / 60)), G(Xt, W) < 0 && W.push(Xt));
            }
            function gt(lt) {
              var Xt = lt.keyCode, Pt = G(Xt, W);
              G(Xt, N) < 0 && (Pt > -1 && W.splice(Pt, 1), W[s.l] || me(!0));
            }
            function Lt(lt) {
              oE !== !0 && (lt = lt.originalEvent || lt, cU(lt.propertyName) && $.update(hi));
            }
            function $t(lt) {
              ai || (Z !== i ? clearTimeout(Z) : ((lc || Fs) && al(!0), Ug() || xn(rt, eC), Yo("onScrollStart", lt)), uc || (Sa(!0), Sa(!1)), Yo("onScroll", lt), Z = setTimeout(function() {
                je || (clearTimeout(Z), Z = i, (lc || Fs) && al(!1), Ug() || xr(rt, eC), Yo("onScrollStop", lt));
              }, ie));
            }
            Fe ? (z > 9 || !B ? wa(jt, "input", me) : wa(
              jt,
              [U0, z0],
              [Ye, gt]
            ), wa(
              jt,
              [Tr, "drop", ce, ce + "out"],
              [Re, De, Te, nt]
            )) : wa(un, j0, Lt), wa(It, Tr, $t, !0);
          }
          function DE(N) {
            var W = function(ce) {
              var me = ce ? tU : iU, Re = ou(eu + vn + me, !0), De = ou(JI, Re), Te = ou(tP, Re);
              return !Nt && !N && (Re.append(De), De.append(Te)), {
                _scrollbar: Re,
                _track: De,
                _handle: Te
              };
            };
            function K(ce) {
              var me = ks(ce), Re = me._scrollbar, De = me._track, Te = me._handle;
              Nt && ze ? U([Re, De, Te], function(nt, Ye) {
                xr(Ye.removeAttr(s.s), J0);
              }) : su(Re || W(ce)._scrollbar);
            }
            var Z, ie;
            N ? (K(!0), K()) : (Z = W(!0), ie = W(), vh = Z._scrollbar, aC = Z._track, Fg = Z._handle, _h = ie._scrollbar, lC = ie._track, kg = ie._handle, Nt || (Ps.after(_h), Ps.after(vh)));
          }
          function BP(N) {
            var W = ks(N), K = W._info, Z = Wg.top !== Wg, ie = W._x_y, ce = W._X_Y, me = Tr + W._Left_Top, Re = "active", De = "snapHandle", Te = "click", nt = 1, Ye = [16, 17], gt, Lt, $t, lt;
            function Xt(He) {
              return z && Z ? He["screen" + ce] : l.page(He)[ie];
            }
            function Pt(He) {
              return Bn.scrollbars[He];
            }
            function Zi() {
              nt = 0.5;
            }
            function Nr() {
              nt = 1;
            }
            function _n(He) {
              l.stpP(He);
            }
            function uo(He) {
              G(He.keyCode, Ye) > -1 && Zi();
            }
            function er(He) {
              G(He.keyCode, Ye) > -1 && Nr();
            }
            function Nn(He) {
              var Qi = He.originalEvent || He, Ji = Qi.touches !== i;
              return ai || je || Ug() || !sE || Ji && !Pt("touchSupport") ? !1 : l.mBtn(He) === 1 || Ji;
            }
            function In(He) {
              if (Nn(He)) {
                var Qi = K._trackLength, Ji = K._handleLength, Zo = K._maxScroll, au = (Xt(He) - $t) * lt, Eh = au / (Qi - Ji), co = Zo * Eh;
                co = isFinite(co) ? co : 0, ft && N && !ue.i && (co *= -1), It[me](u.round(Lt + co)), uc && Sa(N, Lt + co), oe || l.prvD(He);
              } else
                cn(He);
            }
            function cn(He) {
              if (He = He || He.originalEvent, xo(
                rl,
                [nc, Jl, U0, z0, Ng],
                [In, cn, uo, er, Gg],
                !0
              ), l.rAF()(function() {
                xo(rl, Te, _n, !0, { _capture: !0 });
              }), uc && Sa(N, !0), uc = !1, xr(mh, fh), xr(W._handle, Re), xr(W._track, Re), xr(W._scrollbar, Re), Lt = i, $t = i, lt = 1, Nr(), gt !== i && ($.scrollStop(), clearTimeout(gt), gt = i), He) {
                var Qi = qo[s.bCR](), Ji = He.clientX >= Qi.left && He.clientX <= Qi.right && He.clientY >= Qi.top && He.clientY <= Qi.bottom;
                Ji || FP(), (lc || Fs) && al(!1);
              }
            }
            function Hn(He) {
              Nn(He) && Ea(He);
            }
            function Ea(He) {
              Lt = It[me](), Lt = isNaN(Lt) ? 0 : Lt, (ft && N && !ue.n || !ft) && (Lt = Lt < 0 ? 0 : Lt), lt = xE()[ie], $t = Xt(He), uc = !Pt(De), xn(mh, fh), xn(W._handle, Re), xn(W._scrollbar, Re), xo(
                rl,
                [nc, Jl, Ng],
                [In, cn, Gg]
              ), l.rAF()(function() {
                xo(rl, Te, _n, !1, { _capture: !0 });
              }), (z || !Tt) && l.prvD(He), l.stpP(He);
            }
            function hn(He) {
              if (Nn(He)) {
                var Qi = W._info._handleLength / Math.round(u.min(1, Yt[W._w_h] / yh[W._w_h]) * W._info._trackLength), Ji = u.round(Yt[W._w_h] * Qi), Zo = 270 * Qi, au = 400 * Qi, Eh = W._track.offset()[W._left_top], co = He.ctrlKey, ul = He.shiftKey, cl = ul && co, Qo = !0, zg = "linear", Jo, Vr, lu = function(vr) {
                  uc && Sa(N, vr);
                }, es = function() {
                  lu(), Ea(He);
                }, on = function() {
                  if (!je) {
                    var vr = ($t - Eh) * lt, _r = K._handleOffset, Zt = K._trackLength, Bs = K._handleLength, cc = K._maxScroll, Lh = K._currentScroll, uu = Zo * nt, hl = Qo ? u.max(au, uu) : uu, Bt = cc * ((vr - Bs / 2) / (Zt - Bs)), Cr = ft && N && (!ue.i && !ue.n || ru), cu = Cr ? _r < vr : _r > vr, Gi = {}, yr = {
                      easing: zg,
                      step: function(Hs) {
                        uc && (It[me](Hs), Sa(N, Hs));
                      }
                    };
                    Bt = isFinite(Bt) ? Bt : 0, Bt = ft && N && !ue.i ? cc - Bt : Bt, ul ? (It[me](Bt), cl ? (Bt = It[me](), It[me](Lh), Bt = Cr && ue.i ? cc - Bt : Bt, Bt = Cr && ue.n ? -Bt : Bt, Gi[ie] = Bt, $.scroll(Gi, lo(yr, {
                      duration: 130,
                      complete: es
                    }))) : es()) : (Jo = Qo ? cu : Jo, Vr = Cr ? Jo ? _r + Bs >= vr : _r <= vr : Jo ? _r <= vr : _r + Bs >= vr, Vr ? (clearTimeout(gt), $.scrollStop(), gt = i, lu(!0)) : (gt = setTimeout(on, hl), Gi[ie] = (Jo ? "-=" : "+=") + Ji, $.scroll(Gi, lo(yr, {
                      duration: uu
                    }))), Qo = !1);
                  }
                };
                co && Zi(), lt = xE()[ie], $t = l.page(He)[ie], uc = !Pt(De), xn(mh, fh), xn(W._track, Re), xn(W._scrollbar, Re), xo(
                  rl,
                  [Jl, U0, z0, Ng],
                  [cn, uo, er, Gg]
                ), on(), l.prvD(He), l.stpP(He);
              }
            }
            function Vs(He) {
              mE = !0, (lc || Fs) && al(!0);
            }
            function Pi(He) {
              mE = !1, (lc || Fs) && al(!1);
            }
            function bi(He) {
              l.stpP(He);
            }
            wa(
              W._handle,
              rn,
              Hn
            ), wa(
              W._track,
              [rn, Q_, UI],
              [hn, Vs, Pi]
            ), wa(
              W._scrollbar,
              rn,
              bi
            ), F && wa(W._scrollbar, j0, function(He) {
              He.target === W._scrollbar[0] && (RE(N), Sa(N));
            });
          }
          function HP(N, W, K) {
            var Z = N ? jI : $I, ie = N ? vh : _h;
            Ws(rt, Z, !W), Ws(ie, nP, !K);
          }
          function al(N, W) {
            if (clearTimeout(IP), N)
              xr(vh, Pg), xr(_h, Pg);
            else {
              var K, Z = "active", ie = function() {
                !mE && !je && (K = Fg.hasClass(Z) || kg.hasClass(Z), !K && (lc || Fs || wh) && xn(vh, Pg), !K && (lc || Fs || wh) && xn(_h, Pg));
              };
              pE > 0 && W !== !0 ? IP = setTimeout(ie, pE) : ie();
            }
          }
          function RE(N) {
            var W = {}, K = ks(N), Z = K._info, ie = 1e6, ce = u.min(1, Yt[K._w_h] / yh[K._w_h]);
            W[K._width_height] = u.floor(ce * 100 * ie) / ie + "%", Ug() || K._handle.css(W), Z._handleLength = K._handle[0]["offset" + K._Width_Height], Z._handleLengthRatio = ce;
          }
          function Sa(N, W) {
            var K = P(W) == o.b, Z = 250, ie = ft && N, ce = ks(N), me = ce._info, Re = "translate(", De = a._cssProperty("transform"), Te = a._cssProperty("transition"), nt = N ? It[di]() : It[Xi](), Ye = W === i || K ? nt : W, gt = me._handleLength, Lt = ce._track[0]["offset" + ce._Width_Height], $t = Lt - gt, lt = {}, Xt, Pt, Zi = (Ch[Tr + ce._Width_Height] - Ch["client" + ce._Width_Height]) * (ue.n && ie ? -1 : 1), Nr = function(cn) {
              return isNaN(cn / Zi) ? 0 : u.max(0, u.min(1, cn / Zi));
            }, _n = function(cn) {
              var Hn = $t * cn;
              return Hn = isNaN(Hn) ? 0 : Hn, Hn = ie && !ue.i ? Lt - gt - Hn : Hn, Hn = u.max(0, Hn), Hn;
            }, uo = Nr(nt), er = Nr(Ye), Nn = _n(er), In = _n(uo);
            me._maxScroll = Zi, me._currentScroll = nt, me._currentScrollRatio = uo, H ? (Xt = ie ? -(Lt - gt - Nn) : Nn, Pt = N ? Re + Xt + "px, 0)" : Re + "0, " + Xt + "px)", lt[De] = Pt, F && (lt[Te] = K && u.abs(Nn - me._handleOffset) > 1 ? fU(ce._handle) + ", " + (De + vn + Z + "ms") : We)) : lt[ce._left_top] = Nn, Ug() || (ce._handle.css(lt), H && F && K && ce._handle.one(j0, function() {
              je || ce._handle.css(Te, We);
            })), me._handleOffset = Nn, me._snappedHandleOffset = In, me._trackLength = Lt;
          }
          function GP(N, W) {
            var K = W ? "removeClass" : "addClass", Z = N ? aC : Fg, ie = N ? lC : kg, ce = N ? eP : iP;
            Z[K](ce), ie[K](ce);
          }
          function ks(N) {
            return {
              _width_height: N ? Pe : Dt,
              _Width_Height: N ? "Width" : "Height",
              _left_top: N ? Oe : be,
              _Left_Top: N ? "Left" : "Top",
              _x_y: N ? oo : nl,
              _X_Y: N ? "X" : "Y",
              _w_h: N ? "w" : "h",
              _l_t: N ? "l" : "t",
              _track: N ? aC : lC,
              _handle: N ? Fg : kg,
              _scrollbar: N ? vh : _h,
              _info: N ? On : Vn
            };
          }
          function TE(N) {
            ao = ao || ou(Q0, !0), N ? Nt && ze ? xr(ao.removeAttr(s.s), J0) : su(ao) : Nt || rt.append(ao);
          }
          function dU() {
            var N = Wg.top !== Wg, W = {}, K = {}, Z = {}, ie;
            function ce(Te) {
              if (Re(Te)) {
                var nt = De(Te), Ye = {};
                (vE || gC) && (Ye[Pe] = K.w + (nt.x - W.x) * Z.x), (_E || gC) && (Ye[Dt] = K.h + (nt.y - W.y) * Z.y), rt.css(Ye), l.stpP(Te);
              } else
                me(Te);
            }
            function me(Te) {
              var nt = Te !== i;
              xo(
                rl,
                [Ng, nc, Jl],
                [Gg, ce, me],
                !0
              ), xr(mh, fh), ao.releaseCapture && ao.releaseCapture(), nt && (ie && AP(), $.update(hi)), ie = !1;
            }
            function Re(Te) {
              var nt = Te.originalEvent || Te, Ye = nt.touches !== i;
              return ai || je ? !1 : l.mBtn(Te) === 1 || Ye;
            }
            function De(Te) {
              return z && N ? { x: Te.screenX, y: Te.screenY } : l.page(Te);
            }
            wa(ao, rn, function(Te) {
              Re(Te) && !pC && (sl && (ie = !0, CE()), W = De(Te), K.w = qo[s.oW] - (ti ? 0 : at), K.h = qo[s.oH] - (ti ? 0 : Hi), Z = xE(), xo(
                rl,
                [Ng, nc, Jl],
                [Gg, ce, me]
              ), xn(mh, fh), ao.setCapture && ao.setCapture(), l.prvD(Te), l.stpP(Te));
            });
          }
          function Yo(N, W, K) {
            if (K !== !1)
              if (ze) {
                var Z = Bn.callbacks[N], ie = N, ce;
                ie.substr(0, 2) === "on" && (ie = ie.substr(2, 1).toLowerCase() + ie.substr(3)), P(Z) == o.f && Z.call($, W), U(tu, function() {
                  ce = this, P(ce.on) == o.f && ce.on(ie, W);
                });
              } else
                je || eE.push({ n: N, a: W });
          }
          function bh(N, W, K) {
            W = W || We, K = K || [We, We, We, We], N[W + be] = K[0], N[W + xe] = K[1], N[W + $e] = K[2], N[W + Oe] = K[3];
          }
          function OE(N, W, K, Z) {
            return W = W || We, N = N || We, {
              t: Z ? 0 : ll(rt.css(N + be + W)),
              r: K ? 0 : ll(rt.css(N + xe + W)),
              b: Z ? 0 : ll(rt.css(N + $e + W)),
              l: K ? 0 : ll(rt.css(N + Oe + W))
            };
          }
          function fU(N) {
            var W = a._cssProperty("transition"), K = N.css(W);
            if (K)
              return K;
            for (var Z = "\\s*(([^,(]+(\\(.+?\\))?)+)[\\s,]*", ie = new RegExp(Z), ce = new RegExp("^(" + Z + ")+$"), me = "property duration timing-function delay".split(" "), Re = [], De, Te, nt = 0, Ye, gt = function(Lt) {
              if (De = [], !Lt.match(ce))
                return Lt;
              for (; Lt.match(ie); )
                De.push(RegExp.$1), Lt = Lt.replace(ie, We);
              return De;
            }; nt < me[s.l]; nt++)
              for (Te = gt(N.css(W + "-" + me[nt])), Ye = 0; Ye < Te[s.l]; Ye++)
                Re[Ye] = (Re[Ye] ? Re[Ye] + vn : We) + Te[Ye];
            return Re.join(", ");
          }
          function UP(N, W) {
            var K, Z, ie, ce = function(me, Re) {
              if (ie = "", Re && typeof me == o.s)
                for (Z = me.split(vn), K = 0; K < Z[s.l]; K++)
                  ie += "|" + Z[K] + "$";
              return ie;
            };
            return new RegExp(
              "(^" + kr + "([-_].+|)$)" + ce(Hg, N) + ce(aE, W),
              "g"
            );
          }
          function xE() {
            var N = oc[s.bCR]();
            return {
              x: H && 1 / (u.round(N.width) / oc[s.oW]) || 1,
              y: H && 1 / (u.round(N.height) / oc[s.oH]) || 1
            };
          }
          function zP(N) {
            var W = "ownerDocument", K = "HTMLElement", Z = N && N[W] && N[W].parentWindow || e;
            return typeof Z[K] == o.o ? N instanceof Z[K] : (
              //DOM2
              N && typeof N == o.o && N !== null && N.nodeType === 1 && typeof N.nodeName == o.s
            );
          }
          function pU(N, W) {
            var K = [], Z = [], ie, ce;
            for (ie = 0; ie < N.length; ie++)
              K[N[ie]] = !0;
            for (ie = 0; ie < W.length; ie++)
              K[W[ie]] ? delete K[W[ie]] : K[W[ie]] = !0;
            for (ce in K)
              Z.push(ce);
            return Z;
          }
          function ll(N, W) {
            var K = W ? parseFloat(N) : parseInt(N, 10);
            return isNaN(K) ? 0 : K;
          }
          function gU() {
            var N = rc.selectionStart;
            if (N !== i) {
              var W = jt.val(), K = W[s.l], Z = W.split(`
`), ie = Z[s.l], ce = W.substr(0, N).split(`
`), me = 0, Re = 0, De = ce[s.l], Te = ce[ce[s.l] - 1][s.l], nt, Ye;
              for (Ye = 0; Ye < Z[s.l]; Ye++)
                nt = Z[Ye][s.l], nt > Re && (me = Ye + 1, Re = nt);
              return {
                _cursorRow: De,
                //cursorRow
                _cursorColumn: Te,
                //cursorCol
                _rows: ie,
                //rows
                _columns: Re,
                //cols
                _widestRow: me,
                //wRow
                _cursorPosition: N,
                //pos
                _cursorMax: K
                //max
              };
            }
          }
          function Ug() {
            return rE && ne.x && ne.y;
          }
          function jP() {
            return Fe ? nu[0] : As;
          }
          function Xo(N, W) {
            return "<div " + (N ? P(N) == o.s ? 'class="' + N + '"' : function() {
              var K, Z = We;
              if (d.isPlainObject(N))
                for (K in N)
                  Z += (K === "c" ? "class" : K) + '="' + N[K] + '" ';
              return Z;
            }() : We) + ">" + (W || We) + "</div>";
          }
          function ou(N, W) {
            var K = P(W) == o.b, Z = K ? rt : W || rt;
            return Nt && !Z[s.l] ? null : Nt ? Z[K ? "children" : "find"](Or + N.replace(/\s/g, Or)).eq(0) : d(Xo(N));
          }
          function NE(N, W) {
            for (var K = W.split(Or), Z = 0, ie; Z < K.length; Z++) {
              if (!N[s.hOP](K[Z]))
                return;
              ie = N[K[Z]], Z < K.length && P(ie) == o.o && (N = ie);
            }
            return ie;
          }
          function mU(N, W, K) {
            for (var Z = W.split(Or), ie = Z.length, ce = 0, me = {}, Re = me; ce < ie; ce++)
              me = me[Z[ce]] = ce + 1 < ie ? {} : K;
            d.extend(N, Re, !0);
          }
          function $P(N) {
            var W = Bn.updateOnLoad;
            W = P(W) == o.s ? W.split(vn) : W, l.isA(W) && !je && U(W, N);
          }
          function Sh(N, W, K) {
            if (K)
              return K;
            if (P(N) == o.o && P(W) == o.o) {
              for (var Z in N)
                if (Z !== "c")
                  if (N[s.hOP](Z) && W[s.hOP](Z)) {
                    if (Sh(N[Z], W[Z]))
                      return !0;
                  } else
                    return !0;
            } else
              return N !== W;
            return !1;
          }
          function lo() {
            return d.extend.apply(this, [!0].concat([].slice.call(arguments)));
          }
          function xn(N, W) {
            return k.addClass.call(N, W);
          }
          function xr(N, W) {
            return k.removeClass.call(N, W);
          }
          function Ws(N, W, K) {
            return K ? xn(N, W) : xr(N, W);
          }
          function su(N) {
            return k.remove.call(N);
          }
          function af(N, W) {
            return k.find.call(N, W).eq(0);
          }
          $.sleep = function() {
            ai = !0;
          }, $.update = function(N) {
            if (!je) {
              var W, K, Z = P(N) == o.s, ie, ce, me;
              return Z ? N === hi ? (W = uU(), K = lU(), ie = W || K, ie && ba({
                _contentSizeChanged: K,
                _changedOptions: ze ? i : Bn
              })) : N === Ql ? sl ? (ce = uE(dC.takeRecords()), me = cE(fC.takeRecords())) : ce = $.update(hi) : N === "zoom" && ba({
                _hostSizeChanged: !0,
                _contentSizeChanged: !0
              }) : (N = ai || N, ai = !1, (!$.update(Ql) || N) && ba({ _force: N })), VP(), ie || ce || me;
            }
          }, $.options = function(N, W) {
            var K = {}, Z;
            if (d.isEmptyObject(N) || !d.isPlainObject(N))
              if (P(N) == o.s)
                if (arguments.length > 1)
                  mU(K, N, W), Z = EE(K);
                else
                  return NE(Mg, N);
              else
                return Mg;
            else
              Z = EE(N);
            d.isEmptyObject(Z) || ba({ _changedOptions: Z });
          }, $.destroy = function() {
            if (!je) {
              A.remove($), CE(), mC(ya), mC(Ca);
              for (var N in tu)
                $.removeExt(N);
              for (; dE[s.l] > 0; )
                dE.pop()();
              wE(!0), Wr && su(Wr), iu && su(iu), ii && su(Ca), DE(!0), TE(!0), LE(!0);
              for (var W = 0; W < gh[s.l]; W++)
                d(gh[W]).off(iE, yE);
              gh = i, je = !0, ai = !0, f(E, 0), Yo("onDestroyed");
            }
          }, $.scroll = function(N, W, K, Z) {
            if (arguments.length === 0 || N === i) {
              var ie = On, ce = Vn, me = ru && ft && ue.i, Re = ru && ft && ue.n, De = ie._currentScroll, Te = ie._currentScrollRatio, nt = ie._maxScroll;
              return Te = me ? 1 - Te : Te, De = me ? nt - De : De, De *= Re ? -1 : 1, nt *= Re ? -1 : 1, {
                position: {
                  x: De,
                  y: ce._currentScroll
                },
                ratio: {
                  x: Te,
                  y: ce._currentScrollRatio
                },
                max: {
                  x: nt,
                  y: ce._maxScroll
                },
                handleOffset: {
                  x: ie._handleOffset,
                  y: ce._handleOffset
                },
                handleLength: {
                  x: ie._handleLength,
                  y: ce._handleLength
                },
                handleLengthRatio: {
                  x: ie._handleLengthRatio,
                  y: ce._handleLengthRatio
                },
                trackLength: {
                  x: ie._trackLength,
                  y: ce._trackLength
                },
                snappedHandleOffset: {
                  x: ie._snappedHandleOffset,
                  y: ce._snappedHandleOffset
                },
                isRTL: ft,
                isRTLNormalized: ru
              };
            }
            $.update(Ql);
            var Ye = ru, gt = [oo, Oe, "l"], Lt = [nl, be, "t"], $t = ["+=", "-=", "*=", "/="], lt = P(W) == o.o, Xt = lt ? W.complete : Z, Pt, Zi = {}, Nr = {}, _n, uo, er, Nn = "end", In = "begin", cn = "center", Hn = "nearest", Ea = "always", hn = "never", Vs = "ifneeded", Pi = s.l, bi, He, Qi, Ji, Zo, au = [oo, nl, "xy", "yx"], Eh = [In, Nn, cn, Hn], co = [Ea, hn, Vs], ul = N[s.hOP]("el"), cl = ul ? N.el : N, Qo = cl instanceof d || c ? cl instanceof c : !1, zg = Qo ? !1 : zP(cl), Jo = function() {
              _n && Sa(!0), uo && Sa(!1);
            }, Vr = P(Xt) != o.f ? i : function() {
              Jo(), Xt();
            };
            function lu(Qe, tt) {
              for (Pt = 0; Pt < tt[Pi]; Pt++)
                if (Qe === tt[Pt])
                  return !0;
              return !1;
            }
            function es(Qe, tt) {
              var Cn = Qe ? gt : Lt;
              if (tt = P(tt) == o.s || P(tt) == o.n ? [tt, tt] : tt, l.isA(tt))
                return Qe ? tt[0] : tt[1];
              if (P(tt) == o.o) {
                for (Pt = 0; Pt < Cn[Pi]; Pt++)
                  if (Cn[Pt] in tt)
                    return tt[Cn[Pt]];
              }
            }
            function on(Qe, tt) {
              var Cn = P(tt) == o.s, Br, _i, Us = Qe ? On : Vn, Pn = Us._currentScroll, ho = Us._maxScroll, hc = " * ", en, zs = ft && Qe, fl = zs && ue.n && !Ye, tr = "replace", hu = eval, pl;
              if (Cn ? (tt[Pi] > 2 && (pl = tt.substr(0, 2), G(pl, $t) > -1 && (Br = pl)), tt = Br ? tt.substr(2) : tt, tt = tt[tr](/min/g, 0)[tr](/</g, 0)[tr](/max/g, (fl ? "-" : We) + Oo)[tr](/>/g, (fl ? "-" : We) + Oo)[tr](/px/g, We)[tr](/%/g, hc + ho * (zs && ue.n ? -1 : 1) / 100)[tr](/vw/g, hc + Yt.w)[tr](/vh/g, hc + Yt.h), _i = ll(isNaN(tt) ? ll(hu(tt), !0).toFixed() : tt)) : _i = tt, _i !== i && !isNaN(_i) && P(_i) == o.n) {
                var dc = Ye && zs, js = Pn * (dc && ue.n ? -1 : 1), gl = dc && ue.i, IE = dc && ue.n;
                switch (js = gl ? ho - js : js, Br) {
                  case "+=":
                    en = js + _i;
                    break;
                  case "-=":
                    en = js - _i;
                    break;
                  case "*=":
                    en = js * _i;
                    break;
                  case "/=":
                    en = js / _i;
                    break;
                  default:
                    en = _i;
                    break;
                }
                en = gl ? ho - en : en, en *= IE ? -1 : 1, en = zs && ue.n ? u.min(0, u.max(ho, en)) : u.max(0, u.min(ho, en));
              }
              return en === Pn ? i : en;
            }
            function vr(Qe, tt, Cn, Br) {
              var _i = [Cn, Cn], Us = P(Qe), Pn, ho;
              if (Us == tt)
                Qe = [Qe, Qe];
              else if (Us == o.a) {
                if (Pn = Qe[Pi], Pn > 2 || Pn < 1)
                  Qe = _i;
                else
                  for (Pn === 1 && (Qe[1] = Cn), Pt = 0; Pt < Pn; Pt++)
                    if (ho = Qe[Pt], P(ho) != tt || !lu(ho, Br)) {
                      Qe = _i;
                      break;
                    }
              } else
                Us == o.o ? Qe = [Qe[oo] || Cn, Qe[nl] || Cn] : Qe = _i;
              return { x: Qe[0], y: Qe[1] };
            }
            function _r(Qe) {
              var tt = [], Cn, Br, _i = [be, xe, $e, Oe];
              for (Pt = 0; Pt < Qe[Pi] && Pt !== _i[Pi]; Pt++)
                Cn = Qe[Pt], Br = P(Cn), Br == o.b ? tt.push(Cn ? ll(Zo.css(X + _i[Pt])) : 0) : tt.push(Br == o.n ? Cn : 0);
              return tt;
            }
            if (Qo || zg) {
              var Zt = ul ? N.margin : 0, Bs = ul ? N.axis : 0, cc = ul ? N.scroll : 0, Lh = ul ? N.block : 0, uu = [0, 0, 0, 0], hl = P(Zt), Bt;
              if (Zo = Qo ? cl : d(cl), Zo[Pi] > 0) {
                hl == o.n || hl == o.b ? Zt = _r([Zt, Zt, Zt, Zt]) : hl == o.a ? (Bt = Zt[Pi], Bt === 2 ? Zt = _r([Zt[0], Zt[1], Zt[0], Zt[1]]) : Bt >= 4 ? Zt = _r(Zt) : Zt = uu) : hl == o.o ? Zt = _r([Zt[be], Zt[xe], Zt[$e], Zt[Oe]]) : Zt = uu, bi = lu(Bs, au) ? Bs : "xy", He = vr(cc, o.s, Ea, co), Qi = vr(Lh, o.s, In, Eh), Ji = Zt;
                var Cr = {
                  l: On._currentScroll,
                  t: Vn._currentScroll
                }, cu = Ps.offset(), Gi = Zo.offset(), yr = {
                  x: He.x == hn || bi == nl,
                  y: He.y == hn || bi == oo
                };
                Gi[be] -= Ji[0], Gi[Oe] -= Ji[3];
                var Hs = {
                  x: u.round(Gi[Oe] - cu[Oe] + Cr.l),
                  y: u.round(Gi[be] - cu[be] + Cr.t)
                };
                if (ft && (!ue.n && !ue.i && (Hs.x = u.round(cu[Oe] - Gi[Oe] + Cr.l)), ue.n && Ye && (Hs.x *= -1), ue.i && Ye && (Hs.x = u.round(cu[Oe] - Gi[Oe] + (On._maxScroll - Cr.l)))), Qi.x != In || Qi.y != In || He.x == Vs || He.y == Vs || ft) {
                  var jg = Zo[0], vC = H ? jg[s.bCR]() : {
                    width: jg[s.oW],
                    height: jg[s.oH]
                  }, Gs = {
                    w: vC[Pe] + Ji[3] + Ji[1],
                    h: vC[Dt] + Ji[0] + Ji[2]
                  }, dl = function(Qe) {
                    var tt = ks(Qe), Cn = tt._w_h, Br = tt._left_top, _i = tt._x_y, Us = Qi[_i] == (Qe && ft ? In : Nn), Pn = Qi[_i] == cn, ho = Qi[_i] == Hn, hc = He[_i] == hn, en = He[_i] == Vs, zs = Yt[Cn], fl = cu[Br], tr = Gs[Cn], hu = Gi[Br], pl = Pn ? 2 : 1, dc = hu + tr / 2, js = fl + zs / 2, gl = tr <= zs && hu >= fl && hu + tr <= fl + zs;
                    hc ? yr[_i] = !0 : yr[_i] || ((ho || en) && (yr[_i] = en ? gl : !1, Us = tr < zs ? dc > js : dc < js), Hs[_i] -= Us || Pn ? (zs / pl - tr / pl) * (Qe && ft && Ye ? -1 : 1) : 0);
                  };
                  dl(!0), dl(!1);
                }
                yr.y && delete Hs.y, yr.x && delete Hs.x, N = Hs;
              }
            }
            Zi[di] = on(!0, es(!0, N)), Zi[Xi] = on(!1, es(!1, N)), _n = Zi[di] !== i, uo = Zi[Xi] !== i, (_n || uo) && (W > 0 || lt) ? lt ? (W.complete = Vr, It.animate(Zi, W)) : (er = {
              duration: W,
              complete: Vr
            }, l.isA(K) || d.isPlainObject(K) ? (Nr[di] = K[0] || K.x, Nr[Xi] = K[1] || K.y, er.specialEasing = Nr) : er.easing = K, It.animate(Zi, er)) : (_n && It[di](Zi[di]), uo && It[Xi](Zi[Xi]), Jo());
          }, $.scrollStop = function(N, W, K) {
            return It.stop(N, W, K), $;
          }, $.getElements = function(N) {
            var W = {
              target: rc,
              host: qo,
              padding: oc,
              viewport: Ch,
              content: As,
              scrollbarHorizontal: {
                scrollbar: vh[0],
                track: aC[0],
                handle: Fg[0]
              },
              scrollbarVertical: {
                scrollbar: _h[0],
                track: lC[0],
                handle: kg[0]
              },
              scrollbarCorner: ao[0]
            };
            return P(N) == o.s ? NE(W, N) : W;
          }, $.getState = function(N) {
            function W(Z) {
              if (!d.isPlainObject(Z))
                return Z;
              var ie = lo({}, Z), ce = function(me, Re) {
                ie[s.hOP](me) && (ie[Re] = ie[me], delete ie[me]);
              };
              return ce("w", Pe), ce("h", Dt), delete ie.c, ie;
            }
            var K = {
              destroyed: !!W(je),
              sleeping: !!W(ai),
              autoUpdate: W(!sl),
              widthAuto: W(Ms),
              heightAuto: W(sc),
              padding: W(nE),
              overflowAmount: W(sf),
              hideOverflow: W(Bg),
              hasOverflow: W(ol),
              contentScrollSize: W(yh),
              viewportSize: W(Yt),
              hostSize: W(Vg),
              documentMixed: W(Tt)
            };
            return P(N) == o.s ? NE(K, N) : K;
          }, $.ext = function(N) {
            var W, K = nU.split(" "), Z = 0;
            if (P(N) == o.s) {
              if (tu[s.hOP](N))
                for (W = lo({}, tu[N]); Z < K.length; Z++)
                  delete W[K[Z]];
            } else {
              W = {};
              for (Z in tu)
                W[Z] = lo({}, $.ext(Z));
            }
            return W;
          }, $.addExt = function(N, W) {
            var K = g.extension(N), Z, ie, ce, me, Re = !0;
            if (K) {
              if (tu[s.hOP](N))
                return $.ext(N);
              if (Z = K.extensionFactory.call(
                $,
                lo({}, K.defaultOptions),
                d,
                l
              ), Z && (ce = Z.contract, P(ce) == o.f && (me = ce(e), Re = P(me) == o.b ? me : Re), Re))
                return tu[N] = Z, ie = Z.added, P(ie) == o.f && ie(W), $.ext(N);
            } else
              console.warn('A extension with the name "' + N + `" isn't registered.`);
          }, $.removeExt = function(N) {
            var W = tu[N], K;
            return W ? (delete tu[N], K = W.removed, P(K) == o.f && K(), !0) : !1;
          };
          function vU(N, W, K) {
            aP = T.defaultOptions, Y = T.nativeScrollbarStyling, M = lo({}, T.nativeScrollbarSize), ne = lo({}, T.nativeScrollbarIsOverlaid), Ce = lo({}, T.overlayScrollbarDummySize), ue = lo({}, T.rtlScrollBehavior), EE(lo({}, aP, W)), x = T.cssCalc, z = T.msie, B = T.autoUpdateRecommended, F = T.supportTransition, H = T.supportTransform, oe = T.supportPassiveEvents, ve = T.supportResizeObserver, Me = T.supportMutationObserver, T.restrictedMeasuring, rl = d(N.ownerDocument), rf = rl[0], sC = d(rf.defaultView || rf.parentWindow), Wg = sC[0], nf = af(rl, "html"), mh = af(nf, "body"), jt = d(N), rc = jt[0], Fe = jt.is("textarea"), qe = jt.is("body"), Tt = rf !== t, Nt = Fe ? jt.hasClass(tC) && jt.parent().hasClass(Z0) : jt.hasClass(kr) && jt.children(Or + Y0)[s.l];
            var Z, ie;
            return ne.x && ne.y && !Bn.nativeScrollbarsOverlaid.initialize ? (ze = !0, Yo("onInitializationWithdrawn"), Nt && (LE(!0), DE(!0), TE(!0)), ze = !1, je = !0, ai = !0, $) : (qe && (Z = {}, Z.l = u.max(jt[di](), nf[di](), sC[di]()), Z.t = u.max(jt[Xi](), nf[Xi](), sC[Xi]()), ie = function() {
              It.removeAttr(s.ti), xo(It, rn, ie, !0, !0);
            }), LE(), DE(), TE(), hU(), BP(!0), BP(!1), dU(), rU(), mC(ya, oU), qe && (It[di](Z.l)[Xi](Z.t), t.activeElement == N && Ch.focus && (It.attr(s.ti, "-1"), Ch.focus(), xo(It, rn, ie, !1, !0))), $.update(hi), ze = !0, Yo("onInitialized"), U(eE, function(ce, me) {
              Yo(me.n, me.a);
            }), eE = [], P(K) == o.s && (K = [K]), l.isA(K) ? U(K, function(ce, me) {
              $.addExt(me);
            }) : d.isPlainObject(K) && U(K, function(ce, me) {
              $.addExt(ce, me);
            }), setTimeout(function() {
              F && !je && xn(rt, KI);
            }, 333), $);
          }
          return g.valid(vU(E, D, O)) && f(E, $), $;
        }
        return g = e[r] = function(E, D, O) {
          if (arguments[s.l] === 0)
            return this;
          var T = [], A = d.isPlainObject(D), P, G;
          return E ? (E = E[s.l] != i ? E : [E[0] || E], y(), E[s.l] > 0 && (A ? d.each(E, function(U, $) {
            P = $, P !== i && T.push(S(P, D, O, _, m));
          }) : d.each(E, function(U, $) {
            P = f($), (D === "!" && g.valid(P) || l.type(D) == o.f && D($, P) || D === i) && T.push(P);
          }), G = T[s.l] === 1 ? T[0] : T), G) : A || !D ? G : T;
        }, g.globals = function() {
          y();
          var E = d.extend(!0, {}, _);
          return delete E.msie, E;
        }, g.defaultOptions = function(E) {
          y();
          var D = _.defaultOptions;
          if (E === i)
            return d.extend(!0, {}, D);
          _.defaultOptions = d.extend(!0, {}, D, C._validate(E, C._template, !0, D)._default);
        }, g.valid = function(E) {
          return E instanceof g && !E.getState().destroyed;
        }, g.extension = function(E, D, O) {
          var T = l.type(E) == o.s, A = arguments[s.l], P = 0;
          if (A < 1 || !T)
            return d.extend(!0, { length: v[s.l] }, v);
          if (T) {
            if (l.type(D) == o.f)
              v.push({
                name: E,
                extensionFactory: D,
                defaultOptions: O
              });
            else
              for (; P < v[s.l]; P++)
                if (v[P].name === E)
                  if (A > 1)
                    v.splice(P, 1);
                  else
                    return d.extend(!0, {}, v[P]);
          }
        }, g;
      }();
      return c && c.fn && (c.fn.overlayScrollbars = function(g, _) {
        var m = this;
        return c.isPlainObject(g) ? (c.each(m, function() {
          p(this, g, _);
        }), m) : p(m, g);
      }), p;
    }
  );
})(D8);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function R8(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
}
class G_e extends IU {
  constructor(e) {
    super(e), this._osInstance = null, this._osTargetRef = wt.createRef();
  }
  osInstance() {
    return this._osInstance;
  }
  osTarget() {
    return this._osTargetRef.current || null;
  }
  componentDidMount() {
    this._osInstance = rp(this.osTarget(), this.props.options || {}, this.props.extensions), kA(this._osInstance, this.props.className);
  }
  componentWillUnmount() {
    rp.valid(this._osInstance) && (this._osInstance.destroy(), this._osInstance = null);
  }
  componentDidUpdate(e) {
    rp.valid(this._osInstance) && (this._osInstance.options(this.props.options), e.className !== this.props.className && kA(this._osInstance, this.props.className));
  }
  render() {
    const e = this.props, t = R8(e, ["options", "extensions", "children", "className"]);
    return wt.createElement(
      "div",
      Object.assign({ className: "os-host" }, t, { ref: this._osTargetRef }),
      wt.createElement("div", { className: "os-resize-observer-host" }),
      wt.createElement(
        "div",
        { className: "os-padding" },
        wt.createElement(
          "div",
          { className: "os-viewport" },
          wt.createElement("div", { className: "os-content" }, this.props.children)
        )
      ),
      wt.createElement(
        "div",
        { className: "os-scrollbar os-scrollbar-horizontal " },
        wt.createElement(
          "div",
          { className: "os-scrollbar-track" },
          wt.createElement("div", { className: "os-scrollbar-handle" })
        )
      ),
      wt.createElement(
        "div",
        { className: "os-scrollbar os-scrollbar-vertical" },
        wt.createElement(
          "div",
          { className: "os-scrollbar-track" },
          wt.createElement("div", { className: "os-scrollbar-handle" })
        )
      ),
      wt.createElement("div", { className: "os-scrollbar-corner" })
    );
  }
}
function kA(n, e) {
  if (rp.valid(n)) {
    const { host: t } = n.getElements(), i = new RegExp(`(^os-host([-_].+|)$)|${n.options().className.replace(/\s/g, "$|")}$`, "g"), r = t.className.split(" ").filter((o) => o.match(i)).join(" ");
    t.className = `${r} ${e || ""}`;
  }
}
var WA = function(e) {
  return e.reduce(function(t, i) {
    var r = i[0], o = i[1];
    return t[r] = o, t;
  }, {});
}, VA = typeof window < "u" && window.document && window.document.createElement ? Se.useLayoutEffect : Se.useEffect, Ho = "top", pa = "bottom", ga = "right", Go = "left", FO = "auto", w_ = [Ho, pa, ga, Go], Op = "start", Nv = "end", T8 = "clippingParents", LV = "viewport", Qg = "popper", O8 = "reference", BA = /* @__PURE__ */ w_.reduce(function(n, e) {
  return n.concat([e + "-" + Op, e + "-" + Nv]);
}, []), DV = /* @__PURE__ */ [].concat(w_, [FO]).reduce(function(n, e) {
  return n.concat([e, e + "-" + Op, e + "-" + Nv]);
}, []), x8 = "beforeRead", N8 = "read", I8 = "afterRead", P8 = "beforeMain", A8 = "main", M8 = "afterMain", F8 = "beforeWrite", k8 = "write", W8 = "afterWrite", V8 = [x8, N8, I8, P8, A8, M8, F8, k8, W8];
function Hl(n) {
  return n ? (n.nodeName || "").toLowerCase() : null;
}
function ma(n) {
  if (n == null)
    return window;
  if (n.toString() !== "[object Window]") {
    var e = n.ownerDocument;
    return e && e.defaultView || window;
  }
  return n;
}
function wd(n) {
  var e = ma(n).Element;
  return n instanceof e || n instanceof Element;
}
function da(n) {
  var e = ma(n).HTMLElement;
  return n instanceof e || n instanceof HTMLElement;
}
function kO(n) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = ma(n).ShadowRoot;
  return n instanceof e || n instanceof ShadowRoot;
}
function B8(n) {
  var e = n.state;
  Object.keys(e.elements).forEach(function(t) {
    var i = e.styles[t] || {}, r = e.attributes[t] || {}, o = e.elements[t];
    !da(o) || !Hl(o) || (Object.assign(o.style, i), Object.keys(r).forEach(function(s) {
      var a = r[s];
      a === !1 ? o.removeAttribute(s) : o.setAttribute(s, a === !0 ? "" : a);
    }));
  });
}
function H8(n) {
  var e = n.state, t = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function() {
    Object.keys(e.elements).forEach(function(i) {
      var r = e.elements[i], o = e.attributes[i] || {}, s = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : t[i]), a = s.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !da(r) || !Hl(r) || (Object.assign(r.style, a), Object.keys(o).forEach(function(l) {
        r.removeAttribute(l);
      }));
    });
  };
}
const G8 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: B8,
  effect: H8,
  requires: ["computeStyles"]
};
function Al(n) {
  return n.split("-")[0];
}
var ld = Math.max, Tw = Math.min, xp = Math.round;
function g1() {
  var n = navigator.userAgentData;
  return n != null && n.brands ? n.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function RV() {
  return !/^((?!chrome|android).)*safari/i.test(g1());
}
function Np(n, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  var i = n.getBoundingClientRect(), r = 1, o = 1;
  e && da(n) && (r = n.offsetWidth > 0 && xp(i.width) / n.offsetWidth || 1, o = n.offsetHeight > 0 && xp(i.height) / n.offsetHeight || 1);
  var s = wd(n) ? ma(n) : window, a = s.visualViewport, l = !RV() && t, u = (i.left + (l && a ? a.offsetLeft : 0)) / r, c = (i.top + (l && a ? a.offsetTop : 0)) / o, h = i.width / r, d = i.height / o;
  return {
    width: h,
    height: d,
    top: c,
    right: u + h,
    bottom: c + d,
    left: u,
    x: u,
    y: c
  };
}
function WO(n) {
  var e = Np(n), t = n.offsetWidth, i = n.offsetHeight;
  return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - i) <= 1 && (i = e.height), {
    x: n.offsetLeft,
    y: n.offsetTop,
    width: t,
    height: i
  };
}
function TV(n, e) {
  var t = e.getRootNode && e.getRootNode();
  if (n.contains(e))
    return !0;
  if (t && kO(t)) {
    var i = e;
    do {
      if (i && n.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function $u(n) {
  return ma(n).getComputedStyle(n);
}
function U8(n) {
  return ["table", "td", "th"].indexOf(Hl(n)) >= 0;
}
function ah(n) {
  return ((wd(n) ? n.ownerDocument : (
    // $FlowFixMe[prop-missing]
    n.document
  )) || window.document).documentElement;
}
function mS(n) {
  return Hl(n) === "html" ? n : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    n.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    n.parentNode || // DOM Element detected
    (kO(n) ? n.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    ah(n)
  );
}
function HA(n) {
  return !da(n) || // https://github.com/popperjs/popper-core/issues/837
  $u(n).position === "fixed" ? null : n.offsetParent;
}
function z8(n) {
  var e = /firefox/i.test(g1()), t = /Trident/i.test(g1());
  if (t && da(n)) {
    var i = $u(n);
    if (i.position === "fixed")
      return null;
  }
  var r = mS(n);
  for (kO(r) && (r = r.host); da(r) && ["html", "body"].indexOf(Hl(r)) < 0; ) {
    var o = $u(r);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || e && o.willChange === "filter" || e && o.filter && o.filter !== "none")
      return r;
    r = r.parentNode;
  }
  return null;
}
function b_(n) {
  for (var e = ma(n), t = HA(n); t && U8(t) && $u(t).position === "static"; )
    t = HA(t);
  return t && (Hl(t) === "html" || Hl(t) === "body" && $u(t).position === "static") ? e : t || z8(n) || e;
}
function VO(n) {
  return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y";
}
function Qm(n, e, t) {
  return ld(n, Tw(e, t));
}
function j8(n, e, t) {
  var i = Qm(n, e, t);
  return i > t ? t : i;
}
function OV() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function xV(n) {
  return Object.assign({}, OV(), n);
}
function NV(n, e) {
  return e.reduce(function(t, i) {
    return t[i] = n, t;
  }, {});
}
var $8 = function(e, t) {
  return e = typeof e == "function" ? e(Object.assign({}, t.rects, {
    placement: t.placement
  })) : e, xV(typeof e != "number" ? e : NV(e, w_));
};
function K8(n) {
  var e, t = n.state, i = n.name, r = n.options, o = t.elements.arrow, s = t.modifiersData.popperOffsets, a = Al(t.placement), l = VO(a), u = [Go, ga].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!o || !s)) {
    var h = $8(r.padding, t), d = WO(o), f = l === "y" ? Ho : Go, p = l === "y" ? pa : ga, g = t.rects.reference[c] + t.rects.reference[l] - s[l] - t.rects.popper[c], _ = s[l] - t.rects.reference[l], m = b_(o), v = m ? l === "y" ? m.clientHeight || 0 : m.clientWidth || 0 : 0, C = g / 2 - _ / 2, y = h[f], b = v - d[c] - h[p], L = v / 2 - d[c] / 2 + C, S = Qm(y, L, b), E = l;
    t.modifiersData[i] = (e = {}, e[E] = S, e.centerOffset = S - L, e);
  }
}
function q8(n) {
  var e = n.state, t = n.options, i = t.element, r = i === void 0 ? "[data-popper-arrow]" : i;
  r != null && (typeof r == "string" && (r = e.elements.popper.querySelector(r), !r) || TV(e.elements.popper, r) && (e.elements.arrow = r));
}
const Y8 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: K8,
  effect: q8,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Ip(n) {
  return n.split("-")[1];
}
var X8 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Z8(n) {
  var e = n.x, t = n.y, i = window, r = i.devicePixelRatio || 1;
  return {
    x: xp(e * r) / r || 0,
    y: xp(t * r) / r || 0
  };
}
function GA(n) {
  var e, t = n.popper, i = n.popperRect, r = n.placement, o = n.variation, s = n.offsets, a = n.position, l = n.gpuAcceleration, u = n.adaptive, c = n.roundOffsets, h = n.isFixed, d = s.x, f = d === void 0 ? 0 : d, p = s.y, g = p === void 0 ? 0 : p, _ = typeof c == "function" ? c({
    x: f,
    y: g
  }) : {
    x: f,
    y: g
  };
  f = _.x, g = _.y;
  var m = s.hasOwnProperty("x"), v = s.hasOwnProperty("y"), C = Go, y = Ho, b = window;
  if (u) {
    var L = b_(t), S = "clientHeight", E = "clientWidth";
    if (L === ma(t) && (L = ah(t), $u(L).position !== "static" && a === "absolute" && (S = "scrollHeight", E = "scrollWidth")), L = L, r === Ho || (r === Go || r === ga) && o === Nv) {
      y = pa;
      var D = h && L === b && b.visualViewport ? b.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        L[S]
      );
      g -= D - i.height, g *= l ? 1 : -1;
    }
    if (r === Go || (r === Ho || r === pa) && o === Nv) {
      C = ga;
      var O = h && L === b && b.visualViewport ? b.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        L[E]
      );
      f -= O - i.width, f *= l ? 1 : -1;
    }
  }
  var T = Object.assign({
    position: a
  }, u && X8), A = c === !0 ? Z8({
    x: f,
    y: g
  }) : {
    x: f,
    y: g
  };
  if (f = A.x, g = A.y, l) {
    var P;
    return Object.assign({}, T, (P = {}, P[y] = v ? "0" : "", P[C] = m ? "0" : "", P.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + g + "px)" : "translate3d(" + f + "px, " + g + "px, 0)", P));
  }
  return Object.assign({}, T, (e = {}, e[y] = v ? g + "px" : "", e[C] = m ? f + "px" : "", e.transform = "", e));
}
function Q8(n) {
  var e = n.state, t = n.options, i = t.gpuAcceleration, r = i === void 0 ? !0 : i, o = t.adaptive, s = o === void 0 ? !0 : o, a = t.roundOffsets, l = a === void 0 ? !0 : a, u = {
    placement: Al(e.placement),
    variation: Ip(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: r,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, GA(Object.assign({}, u, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: s,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, GA(Object.assign({}, u, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const J8 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Q8,
  data: {}
};
var TC = {
  passive: !0
};
function e9(n) {
  var e = n.state, t = n.instance, i = n.options, r = i.scroll, o = r === void 0 ? !0 : r, s = i.resize, a = s === void 0 ? !0 : s, l = ma(e.elements.popper), u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return o && u.forEach(function(c) {
    c.addEventListener("scroll", t.update, TC);
  }), a && l.addEventListener("resize", t.update, TC), function() {
    o && u.forEach(function(c) {
      c.removeEventListener("scroll", t.update, TC);
    }), a && l.removeEventListener("resize", t.update, TC);
  };
}
const t9 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: e9,
  data: {}
};
var i9 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Uy(n) {
  return n.replace(/left|right|bottom|top/g, function(e) {
    return i9[e];
  });
}
var n9 = {
  start: "end",
  end: "start"
};
function UA(n) {
  return n.replace(/start|end/g, function(e) {
    return n9[e];
  });
}
function BO(n) {
  var e = ma(n), t = e.pageXOffset, i = e.pageYOffset;
  return {
    scrollLeft: t,
    scrollTop: i
  };
}
function HO(n) {
  return Np(ah(n)).left + BO(n).scrollLeft;
}
function r9(n, e) {
  var t = ma(n), i = ah(n), r = t.visualViewport, o = i.clientWidth, s = i.clientHeight, a = 0, l = 0;
  if (r) {
    o = r.width, s = r.height;
    var u = RV();
    (u || !u && e === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: a + HO(n),
    y: l
  };
}
function o9(n) {
  var e, t = ah(n), i = BO(n), r = (e = n.ownerDocument) == null ? void 0 : e.body, o = ld(t.scrollWidth, t.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), s = ld(t.scrollHeight, t.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), a = -i.scrollLeft + HO(n), l = -i.scrollTop;
  return $u(r || t).direction === "rtl" && (a += ld(t.clientWidth, r ? r.clientWidth : 0) - o), {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
function GO(n) {
  var e = $u(n), t = e.overflow, i = e.overflowX, r = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(t + r + i);
}
function IV(n) {
  return ["html", "body", "#document"].indexOf(Hl(n)) >= 0 ? n.ownerDocument.body : da(n) && GO(n) ? n : IV(mS(n));
}
function Jm(n, e) {
  var t;
  e === void 0 && (e = []);
  var i = IV(n), r = i === ((t = n.ownerDocument) == null ? void 0 : t.body), o = ma(i), s = r ? [o].concat(o.visualViewport || [], GO(i) ? i : []) : i, a = e.concat(s);
  return r ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Jm(mS(s)))
  );
}
function m1(n) {
  return Object.assign({}, n, {
    left: n.x,
    top: n.y,
    right: n.x + n.width,
    bottom: n.y + n.height
  });
}
function s9(n, e) {
  var t = Np(n, !1, e === "fixed");
  return t.top = t.top + n.clientTop, t.left = t.left + n.clientLeft, t.bottom = t.top + n.clientHeight, t.right = t.left + n.clientWidth, t.width = n.clientWidth, t.height = n.clientHeight, t.x = t.left, t.y = t.top, t;
}
function zA(n, e, t) {
  return e === LV ? m1(r9(n, t)) : wd(e) ? s9(e, t) : m1(o9(ah(n)));
}
function a9(n) {
  var e = Jm(mS(n)), t = ["absolute", "fixed"].indexOf($u(n).position) >= 0, i = t && da(n) ? b_(n) : n;
  return wd(i) ? e.filter(function(r) {
    return wd(r) && TV(r, i) && Hl(r) !== "body";
  }) : [];
}
function l9(n, e, t, i) {
  var r = e === "clippingParents" ? a9(n) : [].concat(e), o = [].concat(r, [t]), s = o[0], a = o.reduce(function(l, u) {
    var c = zA(n, u, i);
    return l.top = ld(c.top, l.top), l.right = Tw(c.right, l.right), l.bottom = Tw(c.bottom, l.bottom), l.left = ld(c.left, l.left), l;
  }, zA(n, s, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function PV(n) {
  var e = n.reference, t = n.element, i = n.placement, r = i ? Al(i) : null, o = i ? Ip(i) : null, s = e.x + e.width / 2 - t.width / 2, a = e.y + e.height / 2 - t.height / 2, l;
  switch (r) {
    case Ho:
      l = {
        x: s,
        y: e.y - t.height
      };
      break;
    case pa:
      l = {
        x: s,
        y: e.y + e.height
      };
      break;
    case ga:
      l = {
        x: e.x + e.width,
        y: a
      };
      break;
    case Go:
      l = {
        x: e.x - t.width,
        y: a
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var u = r ? VO(r) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (o) {
      case Op:
        l[u] = l[u] - (e[c] / 2 - t[c] / 2);
        break;
      case Nv:
        l[u] = l[u] + (e[c] / 2 - t[c] / 2);
        break;
    }
  }
  return l;
}
function Iv(n, e) {
  e === void 0 && (e = {});
  var t = e, i = t.placement, r = i === void 0 ? n.placement : i, o = t.strategy, s = o === void 0 ? n.strategy : o, a = t.boundary, l = a === void 0 ? T8 : a, u = t.rootBoundary, c = u === void 0 ? LV : u, h = t.elementContext, d = h === void 0 ? Qg : h, f = t.altBoundary, p = f === void 0 ? !1 : f, g = t.padding, _ = g === void 0 ? 0 : g, m = xV(typeof _ != "number" ? _ : NV(_, w_)), v = d === Qg ? O8 : Qg, C = n.rects.popper, y = n.elements[p ? v : d], b = l9(wd(y) ? y : y.contextElement || ah(n.elements.popper), l, c, s), L = Np(n.elements.reference), S = PV({
    reference: L,
    element: C,
    strategy: "absolute",
    placement: r
  }), E = m1(Object.assign({}, C, S)), D = d === Qg ? E : L, O = {
    top: b.top - D.top + m.top,
    bottom: D.bottom - b.bottom + m.bottom,
    left: b.left - D.left + m.left,
    right: D.right - b.right + m.right
  }, T = n.modifiersData.offset;
  if (d === Qg && T) {
    var A = T[r];
    Object.keys(O).forEach(function(P) {
      var G = [ga, pa].indexOf(P) >= 0 ? 1 : -1, U = [Ho, pa].indexOf(P) >= 0 ? "y" : "x";
      O[P] += A[U] * G;
    });
  }
  return O;
}
function u9(n, e) {
  e === void 0 && (e = {});
  var t = e, i = t.placement, r = t.boundary, o = t.rootBoundary, s = t.padding, a = t.flipVariations, l = t.allowedAutoPlacements, u = l === void 0 ? DV : l, c = Ip(i), h = c ? a ? BA : BA.filter(function(p) {
    return Ip(p) === c;
  }) : w_, d = h.filter(function(p) {
    return u.indexOf(p) >= 0;
  });
  d.length === 0 && (d = h);
  var f = d.reduce(function(p, g) {
    return p[g] = Iv(n, {
      placement: g,
      boundary: r,
      rootBoundary: o,
      padding: s
    })[Al(g)], p;
  }, {});
  return Object.keys(f).sort(function(p, g) {
    return f[p] - f[g];
  });
}
function c9(n) {
  if (Al(n) === FO)
    return [];
  var e = Uy(n);
  return [UA(n), e, UA(e)];
}
function h9(n) {
  var e = n.state, t = n.options, i = n.name;
  if (!e.modifiersData[i]._skip) {
    for (var r = t.mainAxis, o = r === void 0 ? !0 : r, s = t.altAxis, a = s === void 0 ? !0 : s, l = t.fallbackPlacements, u = t.padding, c = t.boundary, h = t.rootBoundary, d = t.altBoundary, f = t.flipVariations, p = f === void 0 ? !0 : f, g = t.allowedAutoPlacements, _ = e.options.placement, m = Al(_), v = m === _, C = l || (v || !p ? [Uy(_)] : c9(_)), y = [_].concat(C).reduce(function(Y, x) {
      return Y.concat(Al(x) === FO ? u9(e, {
        placement: x,
        boundary: c,
        rootBoundary: h,
        padding: u,
        flipVariations: p,
        allowedAutoPlacements: g
      }) : x);
    }, []), b = e.rects.reference, L = e.rects.popper, S = /* @__PURE__ */ new Map(), E = !0, D = y[0], O = 0; O < y.length; O++) {
      var T = y[O], A = Al(T), P = Ip(T) === Op, G = [Ho, pa].indexOf(A) >= 0, U = G ? "width" : "height", $ = Iv(e, {
        placement: T,
        boundary: c,
        rootBoundary: h,
        altBoundary: d,
        padding: u
      }), k = G ? P ? ga : Go : P ? pa : Ho;
      b[U] > L[U] && (k = Uy(k));
      var se = Uy(k), ne = [];
      if (o && ne.push($[A] <= 0), a && ne.push($[k] <= 0, $[se] <= 0), ne.every(function(Y) {
        return Y;
      })) {
        D = T, E = !1;
        break;
      }
      S.set(T, ne);
    }
    if (E)
      for (var Ce = p ? 3 : 1, ue = function(x) {
        var M = y.find(function(F) {
          var H = S.get(F);
          if (H)
            return H.slice(0, x).every(function(oe) {
              return oe;
            });
        });
        if (M)
          return D = M, "break";
      }, B = Ce; B > 0; B--) {
        var z = ue(B);
        if (z === "break")
          break;
      }
    e.placement !== D && (e.modifiersData[i]._skip = !0, e.placement = D, e.reset = !0);
  }
}
const d9 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: h9,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function jA(n, e, t) {
  return t === void 0 && (t = {
    x: 0,
    y: 0
  }), {
    top: n.top - e.height - t.y,
    right: n.right - e.width + t.x,
    bottom: n.bottom - e.height + t.y,
    left: n.left - e.width - t.x
  };
}
function $A(n) {
  return [Ho, ga, pa, Go].some(function(e) {
    return n[e] >= 0;
  });
}
function f9(n) {
  var e = n.state, t = n.name, i = e.rects.reference, r = e.rects.popper, o = e.modifiersData.preventOverflow, s = Iv(e, {
    elementContext: "reference"
  }), a = Iv(e, {
    altBoundary: !0
  }), l = jA(s, i), u = jA(a, r, o), c = $A(l), h = $A(u);
  e.modifiersData[t] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: u,
    isReferenceHidden: c,
    hasPopperEscaped: h
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": c,
    "data-popper-escaped": h
  });
}
const p9 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: f9
};
function g9(n, e, t) {
  var i = Al(n), r = [Go, Ho].indexOf(i) >= 0 ? -1 : 1, o = typeof t == "function" ? t(Object.assign({}, e, {
    placement: n
  })) : t, s = o[0], a = o[1];
  return s = s || 0, a = (a || 0) * r, [Go, ga].indexOf(i) >= 0 ? {
    x: a,
    y: s
  } : {
    x: s,
    y: a
  };
}
function m9(n) {
  var e = n.state, t = n.options, i = n.name, r = t.offset, o = r === void 0 ? [0, 0] : r, s = DV.reduce(function(c, h) {
    return c[h] = g9(h, e.rects, o), c;
  }, {}), a = s[e.placement], l = a.x, u = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[i] = s;
}
const v9 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: m9
};
function _9(n) {
  var e = n.state, t = n.name;
  e.modifiersData[t] = PV({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
const C9 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: _9,
  data: {}
};
function y9(n) {
  return n === "x" ? "y" : "x";
}
function w9(n) {
  var e = n.state, t = n.options, i = n.name, r = t.mainAxis, o = r === void 0 ? !0 : r, s = t.altAxis, a = s === void 0 ? !1 : s, l = t.boundary, u = t.rootBoundary, c = t.altBoundary, h = t.padding, d = t.tether, f = d === void 0 ? !0 : d, p = t.tetherOffset, g = p === void 0 ? 0 : p, _ = Iv(e, {
    boundary: l,
    rootBoundary: u,
    padding: h,
    altBoundary: c
  }), m = Al(e.placement), v = Ip(e.placement), C = !v, y = VO(m), b = y9(y), L = e.modifiersData.popperOffsets, S = e.rects.reference, E = e.rects.popper, D = typeof g == "function" ? g(Object.assign({}, e.rects, {
    placement: e.placement
  })) : g, O = typeof D == "number" ? {
    mainAxis: D,
    altAxis: D
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, D), T = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, A = {
    x: 0,
    y: 0
  };
  if (L) {
    if (o) {
      var P, G = y === "y" ? Ho : Go, U = y === "y" ? pa : ga, $ = y === "y" ? "height" : "width", k = L[y], se = k + _[G], ne = k - _[U], Ce = f ? -E[$] / 2 : 0, ue = v === Op ? S[$] : E[$], B = v === Op ? -E[$] : -S[$], z = e.elements.arrow, Y = f && z ? WO(z) : {
        width: 0,
        height: 0
      }, x = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : OV(), M = x[G], F = x[U], H = Qm(0, S[$], Y[$]), oe = C ? S[$] / 2 - Ce - H - M - O.mainAxis : ue - H - M - O.mainAxis, ve = C ? -S[$] / 2 + Ce + H + F + O.mainAxis : B + H + F + O.mainAxis, Me = e.elements.arrow && b_(e.elements.arrow), ze = Me ? y === "y" ? Me.clientTop || 0 : Me.clientLeft || 0 : 0, je = (P = T == null ? void 0 : T[y]) != null ? P : 0, Fe = k + oe - je - ze, qe = k + ve - je, Tt = Qm(f ? Tw(se, Fe) : se, k, f ? ld(ne, qe) : ne);
      L[y] = Tt, A[y] = Tt - k;
    }
    if (a) {
      var Nt, ti = y === "x" ? Ho : Go, ii = y === "x" ? pa : ga, at = L[b], Hi = b === "y" ? "height" : "width", zt = at + _[ti], qi = at - _[ii], Yi = [Ho, Go].indexOf(m) !== -1, wi = (Nt = T == null ? void 0 : T[b]) != null ? Nt : 0, ft = Yi ? zt : at - S[Hi] - E[Hi] - wi + O.altAxis, ai = Yi ? at + S[Hi] + E[Hi] - wi - O.altAxis : qi, Jn = f && Yi ? j8(ft, at, ai) : Qm(f ? ft : zt, at, f ? ai : qi);
      L[b] = Jn, A[b] = Jn - at;
    }
    e.modifiersData[i] = A;
  }
}
const b9 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: w9,
  requiresIfExists: ["offset"]
};
function S9(n) {
  return {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  };
}
function E9(n) {
  return n === ma(n) || !da(n) ? BO(n) : S9(n);
}
function L9(n) {
  var e = n.getBoundingClientRect(), t = xp(e.width) / n.offsetWidth || 1, i = xp(e.height) / n.offsetHeight || 1;
  return t !== 1 || i !== 1;
}
function D9(n, e, t) {
  t === void 0 && (t = !1);
  var i = da(e), r = da(e) && L9(e), o = ah(e), s = Np(n, r, t), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !t) && ((Hl(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  GO(o)) && (a = E9(e)), da(e) ? (l = Np(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : o && (l.x = HO(o))), {
    x: s.left + a.scrollLeft - l.x,
    y: s.top + a.scrollTop - l.y,
    width: s.width,
    height: s.height
  };
}
function R9(n) {
  var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), i = [];
  n.forEach(function(o) {
    e.set(o.name, o);
  });
  function r(o) {
    t.add(o.name);
    var s = [].concat(o.requires || [], o.requiresIfExists || []);
    s.forEach(function(a) {
      if (!t.has(a)) {
        var l = e.get(a);
        l && r(l);
      }
    }), i.push(o);
  }
  return n.forEach(function(o) {
    t.has(o.name) || r(o);
  }), i;
}
function T9(n) {
  var e = R9(n);
  return V8.reduce(function(t, i) {
    return t.concat(e.filter(function(r) {
      return r.phase === i;
    }));
  }, []);
}
function O9(n) {
  var e;
  return function() {
    return e || (e = new Promise(function(t) {
      Promise.resolve().then(function() {
        e = void 0, t(n());
      });
    })), e;
  };
}
function x9(n) {
  var e = n.reduce(function(t, i) {
    var r = t[i.name];
    return t[i.name] = r ? Object.assign({}, r, i, {
      options: Object.assign({}, r.options, i.options),
      data: Object.assign({}, r.data, i.data)
    }) : i, t;
  }, {});
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}
var KA = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function qA() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return !e.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function N9(n) {
  n === void 0 && (n = {});
  var e = n, t = e.defaultModifiers, i = t === void 0 ? [] : t, r = e.defaultOptions, o = r === void 0 ? KA : r;
  return function(a, l, u) {
    u === void 0 && (u = o);
    var c = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, KA, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, h = [], d = !1, f = {
      state: c,
      setOptions: function(m) {
        var v = typeof m == "function" ? m(c.options) : m;
        g(), c.options = Object.assign({}, o, c.options, v), c.scrollParents = {
          reference: wd(a) ? Jm(a) : a.contextElement ? Jm(a.contextElement) : [],
          popper: Jm(l)
        };
        var C = T9(x9([].concat(i, c.options.modifiers)));
        return c.orderedModifiers = C.filter(function(y) {
          return y.enabled;
        }), p(), f.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!d) {
          var m = c.elements, v = m.reference, C = m.popper;
          if (qA(v, C)) {
            c.rects = {
              reference: D9(v, b_(C), c.options.strategy === "fixed"),
              popper: WO(C)
            }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(O) {
              return c.modifiersData[O.name] = Object.assign({}, O.data);
            });
            for (var y = 0; y < c.orderedModifiers.length; y++) {
              if (c.reset === !0) {
                c.reset = !1, y = -1;
                continue;
              }
              var b = c.orderedModifiers[y], L = b.fn, S = b.options, E = S === void 0 ? {} : S, D = b.name;
              typeof L == "function" && (c = L({
                state: c,
                options: E,
                name: D,
                instance: f
              }) || c);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: O9(function() {
        return new Promise(function(_) {
          f.forceUpdate(), _(c);
        });
      }),
      destroy: function() {
        g(), d = !0;
      }
    };
    if (!qA(a, l))
      return f;
    f.setOptions(u).then(function(_) {
      !d && u.onFirstUpdate && u.onFirstUpdate(_);
    });
    function p() {
      c.orderedModifiers.forEach(function(_) {
        var m = _.name, v = _.options, C = v === void 0 ? {} : v, y = _.effect;
        if (typeof y == "function") {
          var b = y({
            state: c,
            name: m,
            instance: f,
            options: C
          }), L = function() {
          };
          h.push(b || L);
        }
      });
    }
    function g() {
      h.forEach(function(_) {
        return _();
      }), h = [];
    }
    return f;
  };
}
var I9 = [t9, C9, J8, G8, v9, d9, b9, Y8, p9], P9 = /* @__PURE__ */ N9({
  defaultModifiers: I9
}), A9 = typeof Element < "u", M9 = typeof Map == "function", F9 = typeof Set == "function", k9 = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function zy(n, e) {
  if (n === e)
    return !0;
  if (n && e && typeof n == "object" && typeof e == "object") {
    if (n.constructor !== e.constructor)
      return !1;
    var t, i, r;
    if (Array.isArray(n)) {
      if (t = n.length, t != e.length)
        return !1;
      for (i = t; i-- !== 0; )
        if (!zy(n[i], e[i]))
          return !1;
      return !0;
    }
    var o;
    if (M9 && n instanceof Map && e instanceof Map) {
      if (n.size !== e.size)
        return !1;
      for (o = n.entries(); !(i = o.next()).done; )
        if (!e.has(i.value[0]))
          return !1;
      for (o = n.entries(); !(i = o.next()).done; )
        if (!zy(i.value[1], e.get(i.value[0])))
          return !1;
      return !0;
    }
    if (F9 && n instanceof Set && e instanceof Set) {
      if (n.size !== e.size)
        return !1;
      for (o = n.entries(); !(i = o.next()).done; )
        if (!e.has(i.value[0]))
          return !1;
      return !0;
    }
    if (k9 && ArrayBuffer.isView(n) && ArrayBuffer.isView(e)) {
      if (t = n.length, t != e.length)
        return !1;
      for (i = t; i-- !== 0; )
        if (n[i] !== e[i])
          return !1;
      return !0;
    }
    if (n.constructor === RegExp)
      return n.source === e.source && n.flags === e.flags;
    if (n.valueOf !== Object.prototype.valueOf)
      return n.valueOf() === e.valueOf();
    if (n.toString !== Object.prototype.toString)
      return n.toString() === e.toString();
    if (r = Object.keys(n), t = r.length, t !== Object.keys(e).length)
      return !1;
    for (i = t; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(e, r[i]))
        return !1;
    if (A9 && n instanceof Element)
      return !1;
    for (i = t; i-- !== 0; )
      if (!((r[i] === "_owner" || r[i] === "__v" || r[i] === "__o") && n.$$typeof) && !zy(n[r[i]], e[r[i]]))
        return !1;
    return !0;
  }
  return n !== n && e !== e;
}
var W9 = function(e, t) {
  try {
    return zy(e, t);
  } catch (i) {
    if ((i.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw i;
  }
}, V9 = [], U_e = function(e, t, i) {
  i === void 0 && (i = {});
  var r = Se.useRef(null), o = {
    onFirstUpdate: i.onFirstUpdate,
    placement: i.placement || "bottom",
    strategy: i.strategy || "absolute",
    modifiers: i.modifiers || V9
  }, s = Se.useState({
    styles: {
      popper: {
        position: o.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), a = s[0], l = s[1], u = Se.useMemo(function() {
    return {
      name: "updateState",
      enabled: !0,
      phase: "write",
      fn: function(f) {
        var p = f.state, g = Object.keys(p.elements);
        MU.flushSync(function() {
          l({
            styles: WA(g.map(function(_) {
              return [_, p.styles[_] || {}];
            })),
            attributes: WA(g.map(function(_) {
              return [_, p.attributes[_]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []), c = Se.useMemo(function() {
    var d = {
      onFirstUpdate: o.onFirstUpdate,
      placement: o.placement,
      strategy: o.strategy,
      modifiers: [].concat(o.modifiers, [u, {
        name: "applyStyles",
        enabled: !1
      }])
    };
    return W9(r.current, d) ? r.current || d : (r.current = d, d);
  }, [o.onFirstUpdate, o.placement, o.strategy, o.modifiers, u]), h = Se.useRef();
  return VA(function() {
    h.current && h.current.setOptions(c);
  }, [c]), VA(function() {
    if (!(e == null || t == null)) {
      var d = i.createPopper || P9, f = d(e, t, c);
      return h.current = f, function() {
        f.destroy(), h.current = null;
      };
    }
  }, [e, t, i.createPopper]), {
    state: h.current ? h.current.state : null,
    styles: a.styles,
    attributes: a.attributes,
    update: h.current ? h.current.update : null,
    forceUpdate: h.current ? h.current.forceUpdate : null
  };
};
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function op(n) {
  return n == null || n === "" ? null : n;
}
function de(n, e) {
  return e === void 0 && (e = !1), n != null && (n !== "" || e);
}
function Je(n) {
  return !de(n);
}
function ds(n) {
  return n == null || n.length === 0;
}
function UO(n) {
  return n != null && typeof n.toString == "function" ? n.toString() : null;
}
function sa(n) {
  if (n !== void 0) {
    if (n === null || n === "")
      return null;
    if (typeof n == "number")
      return isNaN(n) ? void 0 : n;
    var e = parseInt(n, 10);
    return isNaN(e) ? void 0 : e;
  }
}
function Iu(n) {
  if (n !== void 0)
    return n === null || n === "" ? !1 : typeof n == "boolean" ? n : /true/i.test(n);
}
function B9(n) {
  if (!(n == null || n === ""))
    return n;
}
function H9(n, e) {
  return n == null && e == null ? !0 : n == null && e != null || n != null && e == null ? !1 : n === e;
}
function G9(n, e) {
  var t = n ? JSON.stringify(n) : null, i = e ? JSON.stringify(e) : null;
  return t === i;
}
function v1(n, e, t) {
  t === void 0 && (t = !1);
  var i = n == null, r = e == null;
  if (n && n.toNumber && (n = n.toNumber()), e && e.toNumber && (e = e.toNumber()), i && r)
    return 0;
  if (i)
    return -1;
  if (r)
    return 1;
  function o(s, a) {
    return s > a ? 1 : s < a ? -1 : 0;
  }
  if (typeof n != "string" || !t)
    return o(n, e);
  try {
    return n.localeCompare(e);
  } catch {
    return o(n, e);
  }
}
function Gd(n) {
  if (n instanceof Set || n instanceof Map) {
    var e = [];
    return n.forEach(function(t) {
      return e.push(t);
    }), e;
  }
  return Object.values(n);
}
const U9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attrToBoolean: Iu,
  attrToNumber: sa,
  attrToString: B9,
  defaultComparator: v1,
  exists: de,
  jsonEquals: G9,
  makeNull: op,
  missing: Je,
  missingOrEmpty: ds,
  referenceCompare: H9,
  toStringOrNull: UO,
  values: Gd
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var AV = (
  /** @class */
  function() {
    function n() {
      this.existingKeys = {};
    }
    return n.prototype.addExistingKeys = function(e) {
      for (var t = 0; t < e.length; t++)
        this.existingKeys[e[t]] = !0;
    }, n.prototype.getUniqueKey = function(e, t) {
      e = UO(e);
      for (var i = 0; ; ) {
        var r = void 0;
        if (e ? (r = e, i !== 0 && (r += "_" + i)) : t ? (r = t, i !== 0 && (r += "_" + i)) : r = "" + i, !this.existingKeys[r])
          return this.existingKeys[r] = !0, r;
        i++;
      }
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function pi(n, e) {
  n != null && (Array.isArray(n) ? n.forEach(function(t, i) {
    return e("" + i, t);
  }) : Object.keys(n).forEach(function(t) {
    return e(t, n[t]);
  }));
}
function zO(n) {
  for (var e = {}, t = Object.keys(n), i = 0; i < t.length; i++) {
    var r = t[i], o = n[r];
    e[r] = o;
  }
  return e;
}
function z9(n) {
  return JSON.parse(JSON.stringify(n));
}
function Ow(n, e) {
  if (n) {
    var t = n, i = {};
    return Object.keys(t).forEach(function(r) {
      if (!(e && e.indexOf(r) >= 0)) {
        var o = t[r], s = Pp(o) && o.constructor === Object;
        s ? i[r] = Ow(o) : i[r] = o;
      }
    }), i;
  }
}
function MV(n, e) {
  return n[e];
}
function FV(n, e, t) {
  n[e] = t;
}
function j9(n, e) {
  for (var t = [], i = 2; i < arguments.length; i++)
    t[i - 2] = arguments[i];
  t.forEach(function(r) {
    return kV(n, e, r);
  });
}
function kV(n, e, t, i) {
  var r = MV(n, t);
  r !== void 0 && FV(e, t, i ? i(r) : r);
}
function WV(n) {
  var e = {};
  return n.filter(function(t) {
    return t != null;
  }).forEach(function(t) {
    Object.keys(t).forEach(function(i) {
      return e[i] = null;
    });
  }), Object.keys(e);
}
function Ya(n) {
  if (!n)
    return [];
  var e = Object;
  if (typeof e.values == "function")
    return e.values(n);
  var t = [];
  for (var i in n)
    n.hasOwnProperty(i) && n.propertyIsEnumerable(i) && t.push(n[i]);
  return t;
}
function aa(n, e, t, i) {
  t === void 0 && (t = !0), i === void 0 && (i = !1), de(e) && pi(e, function(r, o) {
    var s = n[r];
    if (s !== o) {
      if (i) {
        var a = s == null && o != null;
        if (a) {
          var l = typeof o == "object" && o.constructor === Object, u = l;
          u && (s = {}, n[r] = s);
        }
      }
      Pp(o) && Pp(s) && !Array.isArray(s) ? aa(s, o, t, i) : (t || o !== void 0) && (n[r] = o);
    }
  });
}
function $9(n) {
  return Je(n) || Object.keys(n).length === 0;
}
function K9(n, e, t) {
  if (n == null)
    return t;
  for (var i = e.split("."), r = n; i.length > 1; )
    if (r = r[i.shift()], r == null)
      return t;
  var o = r[i[0]];
  return o ?? t;
}
function q9(n, e, t) {
  if (n != null) {
    for (var i = e.split("."), r = n; i.length > 1; )
      if (r = r[i.shift()], r == null)
        return;
    r[i[0]] = t;
  }
}
function VV(n) {
  return Object.freeze(n), Gd(n).forEach(function(e) {
    (Pp(e) || typeof e == "function") && VV(e);
  }), n;
}
function xw(n, e, t) {
  if (!(!e || !n)) {
    if (!t)
      return n[e];
    for (var i = e.split("."), r = n, o = 0; o < i.length; o++) {
      if (r == null)
        return;
      r = r[i[o]];
    }
    return r;
  }
}
function BV(n, e) {
  Object.keys(n).forEach(function(r) {
    var o = n[r];
    typeof o == "object" && (n[r] = void 0);
  });
  var t = Object.getPrototypeOf(n), i = {};
  Object.keys(t).forEach(function(r) {
    var o = t[r];
    if (typeof o == "function") {
      var s = function() {
        console.warn("AG Grid: " + e + " function " + r + `() cannot be called as the grid has been destroyed.
                     Please don't call grid API functions on destroyed grids - as a matter of fact you shouldn't
                     be keeping the API reference, your application has a memory leak! Remove the API reference
                     when the grid is destroyed.`);
      };
      i[r] = { value: s, writable: !0 };
    }
  }), Object.defineProperties(n, i);
}
function Pp(n) {
  return typeof n == "object" && n !== null;
}
const Y9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cloneObject: zO,
  copyPropertiesIfPresent: j9,
  copyPropertyIfPresent: kV,
  deepCloneDefinition: Ow,
  deepCloneObject: z9,
  deepFreeze: VV,
  get: K9,
  getAllKeysInObjects: WV,
  getAllValuesInObject: Ya,
  getProperty: MV,
  getValueUsingField: xw,
  isNonNullObject: Pp,
  iterateObject: pi,
  mergeDeep: aa,
  missingOrEmptyObject: $9,
  removeAllReferences: BV,
  set: q9,
  setProperty: FV
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var X9 = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, Z9 = /([^\s,]+)/g, YA = {};
function mi(n, e) {
  YA[e] || (n(), YA[e] = !0);
}
function vS(n) {
  if (n.name)
    return n.name;
  var e = /function\s+([^\(]+)/.exec(n.toString());
  return e && e.length === 2 ? e[1].trim() : null;
}
function Q9(n) {
  var e = n.toString().replace(X9, "");
  return e.slice(e.indexOf("(") + 1, e.indexOf(")")).match(Z9) || [];
}
function jO(n) {
  return !!(n && n.constructor && n.call && n.apply);
}
function HV(n) {
  GV(n, 400);
}
var zE = [], jE = !1;
function _1(n) {
  zE.push(n), !jE && (jE = !0, window.setTimeout(function() {
    var e = zE.slice();
    zE.length = 0, jE = !1, e.forEach(function(t) {
      return t();
    });
  }, 0));
}
function GV(n, e) {
  e === void 0 && (e = 0), n.length > 0 && window.setTimeout(function() {
    return n.forEach(function(t) {
      return t();
    });
  }, e);
}
function th(n, e, t) {
  t === void 0 && (t = !1);
  var i;
  return function() {
    for (var r = [], o = 0; o < arguments.length; o++)
      r[o] = arguments[o];
    var s = this, a = t && !i;
    window.clearTimeout(i), i = window.setTimeout(function() {
      i = null, t || n.apply(s, r);
    }, e), a && n.apply(s, r);
  };
}
function UV(n, e, t, i) {
  t === void 0 && (t = 100);
  var r = (/* @__PURE__ */ new Date()).getTime(), o = null, s = !1, a = function() {
    var l = (/* @__PURE__ */ new Date()).getTime() - r > t;
    (n() || l) && (e(), s = !0, o != null && (window.clearInterval(o), o = null), l && i && console.warn(i));
  };
  a(), s || (o = window.setInterval(a, 10));
}
function J9() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  return function(t) {
    return n.reduce(function(i, r) {
      return r(i);
    }, t);
  };
}
function zV(n) {
  n && n();
}
const ej = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  callIfPresent: zV,
  compose: J9,
  debounce: th,
  doOnce: mi,
  executeAfter: GV,
  executeInAWhile: HV,
  executeNextVMTurn: _1,
  getFunctionName: vS,
  getFunctionParameters: Q9,
  isFunction: jO,
  waitUntil: UV
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var jV = (
  /** @class */
  function() {
    function n(e, t) {
      if (this.beanWrappers = {}, this.destroyed = !1, !(!e || !e.beanClasses)) {
        this.contextParams = e, this.logger = t, this.logger.log(">> creating ag-Application Context"), this.createBeans();
        var i = this.getBeanInstances();
        this.wireBeans(i), this.logger.log(">> ag-Application Context ready - component is alive");
      }
    }
    return n.prototype.getBeanInstances = function() {
      return Gd(this.beanWrappers).map(function(e) {
        return e.beanInstance;
      });
    }, n.prototype.createBean = function(e, t) {
      if (!e)
        throw Error("Can't wire to bean since it is null");
      return this.wireBeans([e], t), e;
    }, n.prototype.wireBeans = function(e, t) {
      this.autoWireBeans(e), this.methodWireBeans(e), this.callLifeCycleMethods(e, "preConstructMethods"), de(t) && e.forEach(t), this.callLifeCycleMethods(e, "postConstructMethods");
    }, n.prototype.createBeans = function() {
      var e = this;
      this.contextParams.beanClasses.forEach(this.createBeanWrapper.bind(this)), pi(this.beanWrappers, function(i, r) {
        var o;
        r.bean.__agBeanMetaData && r.bean.__agBeanMetaData.autowireMethods && r.bean.__agBeanMetaData.autowireMethods.agConstructor && (o = r.bean.__agBeanMetaData.autowireMethods.agConstructor);
        var s = e.getBeansForParameters(o, r.bean.name), a = tj(r.bean, s);
        r.beanInstance = a;
      });
      var t = Object.keys(this.beanWrappers).join(", ");
      this.logger.log("created beans: " + t);
    }, n.prototype.createBeanWrapper = function(e) {
      var t = e.__agBeanMetaData;
      if (!t) {
        var i = void 0;
        e.prototype.constructor ? i = vS(e.prototype.constructor) : i = "" + e, console.error("Context item " + i + " is not a bean");
        return;
      }
      var r = {
        bean: e,
        beanInstance: null,
        beanName: t.beanName
      };
      this.beanWrappers[t.beanName] = r;
    }, n.prototype.autoWireBeans = function(e) {
      var t = this;
      e.forEach(function(i) {
        t.forEachMetaDataInHierarchy(i, function(r, o) {
          var s = r.agClassAttributes;
          s && s.forEach(function(a) {
            var l = t.lookupBeanInstance(o, a.beanName, a.optional);
            i[a.attributeName] = l;
          });
        });
      });
    }, n.prototype.methodWireBeans = function(e) {
      var t = this;
      e.forEach(function(i) {
        t.forEachMetaDataInHierarchy(i, function(r, o) {
          pi(r.autowireMethods, function(s, a) {
            if (s !== "agConstructor") {
              var l = t.getBeansForParameters(a, o);
              i[s].apply(i, l);
            }
          });
        });
      });
    }, n.prototype.forEachMetaDataInHierarchy = function(e, t) {
      for (var i = Object.getPrototypeOf(e); i != null; ) {
        var r = i.constructor;
        if (r.hasOwnProperty("__agBeanMetaData")) {
          var o = r.__agBeanMetaData, s = this.getBeanName(r);
          t(o, s);
        }
        i = Object.getPrototypeOf(i);
      }
    }, n.prototype.getBeanName = function(e) {
      if (e.__agBeanMetaData && e.__agBeanMetaData.beanName)
        return e.__agBeanMetaData.beanName;
      var t = e.toString(), i = t.substring(9, t.indexOf("("));
      return i;
    }, n.prototype.getBeansForParameters = function(e, t) {
      var i = this, r = [];
      return e && pi(e, function(o, s) {
        var a = i.lookupBeanInstance(t, s);
        r[Number(o)] = a;
      }), r;
    }, n.prototype.lookupBeanInstance = function(e, t, i) {
      if (i === void 0 && (i = !1), t === "context")
        return this;
      if (this.contextParams.providedBeanInstances && this.contextParams.providedBeanInstances.hasOwnProperty(t))
        return this.contextParams.providedBeanInstances[t];
      var r = this.beanWrappers[t];
      return r ? r.beanInstance : (i || console.error("AG Grid: unable to find bean reference " + t + " while initialising " + e), null);
    }, n.prototype.callLifeCycleMethods = function(e, t) {
      var i = this;
      e.forEach(function(r) {
        return i.callLifeCycleMethodsOnBean(r, t);
      });
    }, n.prototype.callLifeCycleMethodsOnBean = function(e, t, i) {
      var r = {};
      this.forEachMetaDataInHierarchy(e, function(s) {
        var a = s[t];
        a && a.forEach(function(l) {
          l != i && (r[l] = !0);
        });
      });
      var o = Object.keys(r);
      o.forEach(function(s) {
        return e[s]();
      });
    }, n.prototype.getBean = function(e) {
      return this.lookupBeanInstance("getBean", e, !0);
    }, n.prototype.destroy = function() {
      if (!this.destroyed) {
        this.logger.log(">> Shutting down ag-Application Context");
        var e = this.getBeanInstances();
        this.destroyBeans(e), this.contextParams.providedBeanInstances = null, this.destroyed = !0, this.logger.log(">> ag-Application Context shut down - component is dead");
      }
    }, n.prototype.destroyBean = function(e) {
      e && this.destroyBeans([e]);
    }, n.prototype.destroyBeans = function(e) {
      var t = this;
      return e ? (e.forEach(function(i) {
        t.callLifeCycleMethodsOnBean(i, "preDestroyMethods", "destroy");
        var r = i;
        typeof r.destroy == "function" && r.destroy();
      }), []) : [];
    }, n;
  }()
);
function tj(n, e) {
  var t = [null].concat(e), i = n.bind.apply(n, t);
  return new i();
}
function C1(n, e, t) {
  var i = bd(n.constructor);
  i.preConstructMethods || (i.preConstructMethods = []), i.preConstructMethods.push(e);
}
function Ee(n, e, t) {
  var i = bd(n.constructor);
  i.postConstructMethods || (i.postConstructMethods = []), i.postConstructMethods.push(e);
}
function Lo(n, e, t) {
  var i = bd(n.constructor);
  i.preDestroyMethods || (i.preDestroyMethods = []), i.preDestroyMethods.push(e);
}
function Ke(n) {
  return function(e) {
    var t = bd(e);
    t.beanName = n;
  };
}
function R(n) {
  return function(e, t, i) {
    $V(e, n, !1, e, t, null);
  };
}
function fi(n) {
  return function(e, t, i) {
    $V(e, n, !0, e, t, null);
  };
}
function $V(n, e, t, i, r, o) {
  if (e === null) {
    console.error("AG Grid: Autowired name should not be null");
    return;
  }
  if (typeof o == "number") {
    console.error("AG Grid: Autowired should be on an attribute");
    return;
  }
  var s = bd(n.constructor);
  s.agClassAttributes || (s.agClassAttributes = []), s.agClassAttributes.push({
    attributeName: r,
    beanName: e,
    optional: t
  });
}
function wo(n) {
  return function(e, t, i) {
    var r = typeof e == "function" ? e : e.constructor, o;
    if (typeof i == "number") {
      var s = void 0;
      t ? (o = bd(r), s = t) : (o = bd(r), s = "agConstructor"), o.autowireMethods || (o.autowireMethods = {}), o.autowireMethods[s] || (o.autowireMethods[s] = {}), o.autowireMethods[s][i] = n;
    }
  };
}
function bd(n) {
  return n.hasOwnProperty("__agBeanMetaData") || (n.__agBeanMetaData = {}), n.__agBeanMetaData;
}
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var XA = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, OC = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, Zu = (
  /** @class */
  function() {
    function n() {
      this.allSyncListeners = /* @__PURE__ */ new Map(), this.allAsyncListeners = /* @__PURE__ */ new Map(), this.globalSyncListeners = /* @__PURE__ */ new Set(), this.globalAsyncListeners = /* @__PURE__ */ new Set(), this.asyncFunctionsQueue = [], this.scheduled = !1, this.firedEvents = {};
    }
    return n.prototype.setBeans = function(e, t, i, r) {
      if (r === void 0 && (r = null), this.frameworkOverrides = i, r) {
        var o = t.useAsyncEvents();
        this.addGlobalListener(r, o);
      }
    }, n.prototype.getListeners = function(e, t, i) {
      var r = t ? this.allAsyncListeners : this.allSyncListeners, o = r.get(e);
      return !o && i && (o = /* @__PURE__ */ new Set(), r.set(e, o)), o;
    }, n.prototype.noRegisteredListenersExist = function() {
      return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
    }, n.prototype.addEventListener = function(e, t, i) {
      i === void 0 && (i = !1), this.getListeners(e, i, !0).add(t);
    }, n.prototype.removeEventListener = function(e, t, i) {
      i === void 0 && (i = !1);
      var r = this.getListeners(e, i, !1);
      if (r && (r.delete(t), r.size === 0)) {
        var o = i ? this.allAsyncListeners : this.allSyncListeners;
        o.delete(e);
      }
    }, n.prototype.addGlobalListener = function(e, t) {
      t === void 0 && (t = !1), (t ? this.globalAsyncListeners : this.globalSyncListeners).add(e);
    }, n.prototype.removeGlobalListener = function(e, t) {
      t === void 0 && (t = !1), (t ? this.globalAsyncListeners : this.globalSyncListeners).delete(e);
    }, n.prototype.dispatchEvent = function(e) {
      this.dispatchToListeners(e, !0), this.dispatchToListeners(e, !1), this.firedEvents[e.type] = !0;
    }, n.prototype.dispatchEventOnce = function(e) {
      this.firedEvents[e.type] || this.dispatchEvent(e);
    }, n.prototype.dispatchToListeners = function(e, t) {
      var i = this, r = e.type, o = function(l) {
        return l.forEach(function(u) {
          t ? i.dispatchAsync(function() {
            return u(e);
          }) : u(e);
        });
      }, s = this.getListeners(r, t, !1);
      s && o(s);
      var a = t ? this.globalAsyncListeners : this.globalSyncListeners;
      a.forEach(function(l) {
        t ? i.dispatchAsync(function() {
          return i.frameworkOverrides.dispatchEvent(r, function() {
            return l(r, e);
          }, !0);
        }) : i.frameworkOverrides.dispatchEvent(r, function() {
          return l(r, e);
        }, !0);
      });
    }, n.prototype.dispatchAsync = function(e) {
      this.asyncFunctionsQueue.push(e), this.scheduled || (window.setTimeout(this.flushAsyncQueue.bind(this), 0), this.scheduled = !0);
    }, n.prototype.flushAsyncQueue = function() {
      this.scheduled = !1;
      var e = this.asyncFunctionsQueue.slice();
      this.asyncFunctionsQueue = [], e.forEach(function(t) {
        return t();
      });
    }, XA([
      OC(0, wo("loggerFactory")),
      OC(1, wo("gridOptionsWrapper")),
      OC(2, wo("frameworkOverrides")),
      OC(3, wo("globalEventListener"))
    ], n.prototype, "setBeans", null), n = XA([
      Ke("eventService")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var q = (
  /** @class */
  function() {
    function n() {
    }
    return n.ROW_BUFFER_SIZE = 10, n.LAYOUT_INTERVAL = 500, n.BATCH_WAIT_MILLIS = 50, n.EXPORT_TYPE_DRAG_COPY = "dragCopy", n.EXPORT_TYPE_CLIPBOARD = "clipboard", n.EXPORT_TYPE_EXCEL = "excel", n.EXPORT_TYPE_CSV = "csv", n.ROW_MODEL_TYPE_INFINITE = "infinite", n.ROW_MODEL_TYPE_VIEWPORT = "viewport", n.ROW_MODEL_TYPE_CLIENT_SIDE = "clientSide", n.ROW_MODEL_TYPE_SERVER_SIDE = "serverSide", n.ALWAYS = "always", n.ONLY_WHEN_GROUPING = "onlyWhenGrouping", n.PINNED_TOP = "top", n.PINNED_BOTTOM = "bottom", n.DOM_LAYOUT_NORMAL = "normal", n.DOM_LAYOUT_PRINT = "print", n.DOM_LAYOUT_AUTO_HEIGHT = "autoHeight", n.GROUP_AUTO_COLUMN_ID = "ag-Grid-AutoColumn", n.SOURCE_PASTE = "paste", n.PINNED_RIGHT = "right", n.PINNED_LEFT = "left", n.SORT_ASC = "asc", n.SORT_DESC = "desc", n.INPUT_SELECTOR = "input, select, button, textarea", n.FOCUSABLE_SELECTOR = "[tabindex], input, select, button, textarea", n.FOCUSABLE_EXCLUDE = ".ag-hidden, .ag-hidden *, [disabled], .ag-disabled, .ag-disabled *", n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var ct;
(function(n) {
  n.CommunityCoreModule = "@ag-grid-community/core", n.CommunityAllModules = "@ag-grid-community/all", n.InfiniteRowModelModule = "@ag-grid-community/infinite-row-model", n.ClientSideRowModelModule = "@ag-grid-community/client-side-row-model", n.CsvExportModule = "@ag-grid-community/csv-export", n.EnterpriseCoreModule = "@ag-grid-enterprise/core", n.EnterpriseAllModules = "@ag-grid-enterprise/all", n.RowGroupingModule = "@ag-grid-enterprise/row-grouping", n.ColumnToolPanelModule = "@ag-grid-enterprise/column-tool-panel", n.FiltersToolPanelModule = "@ag-grid-enterprise/filter-tool-panel", n.MenuModule = "@ag-grid-enterprise/menu", n.SetFilterModule = "@ag-grid-enterprise/set-filter", n.MultiFilterModule = "@ag-grid-enterprise/multi-filter", n.StatusBarModule = "@ag-grid-enterprise/status-bar", n.SideBarModule = "@ag-grid-enterprise/side-bar", n.RangeSelectionModule = "@ag-grid-enterprise/range-selection", n.MasterDetailModule = "@ag-grid-enterprise/master-detail", n.RichSelectModule = "@ag-grid-enterprise/rich-select", n.GridChartsModule = "@ag-grid-enterprise/charts", n.ViewportRowModelModule = "@ag-grid-enterprise/viewport-row-model", n.ServerSideRowModelModule = "@ag-grid-enterprise/server-side-row-model", n.ExcelExportModule = "@ag-grid-enterprise/excel-export", n.ClipboardModule = "@ag-grid-enterprise/clipboard", n.SparklinesModule = "@ag-grid-enterprise/sparklines", n.AngularModule = "@ag-grid-community/angular", n.ReactModule = "@ag-grid-community/react", n.VueModule = "@ag-grid-community/vue", n.PolymerModule = "@ag-grid-community/polymer";
})(ct || (ct = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var pt = (
  /** @class */
  function() {
    function n() {
    }
    return n.register = function(e, t) {
      t === void 0 && (t = !0), n.modulesMap[e.moduleName] = e, n.moduleBased === void 0 ? n.moduleBased = t : n.moduleBased !== t && mi(function() {
        console.warn("AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms."), console.warn("Please see https://www.ag-grid.com/javascript-grid/packages-modules/ for more information.");
      }, "ModulePackageCheck");
    }, n.registerModules = function(e, t) {
      t === void 0 && (t = !0), e && e.forEach(function(i) {
        return n.register(i, t);
      });
    }, n.assertRegistered = function(e, t) {
      if (this.isRegistered(e))
        return !0;
      var i = t + e, r;
      return n.moduleBased ? r = "AG Grid: unable to use " + t + " as module " + e + " is not present. Please see: https://www.ag-grid.com/javascript-grid/modules/" : r = "AG Grid: unable to use " + t + " as package 'ag-grid-enterprise' is not present. Please see: https://www.ag-grid.com/javascript-grid/packages/", mi(function() {
        console.warn(r);
      }, i), !1;
    }, n.isRegistered = function(e) {
      return !!n.modulesMap[e];
    }, n.getRegisteredModules = function() {
      return Gd(n.modulesMap);
    }, n.isPackageBased = function() {
      return !n.moduleBased;
    }, n.modulesMap = {}, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var cf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, ij = 0, Gt = (
  /** @class */
  function() {
    function n(e, t, i, r) {
      this.instanceId = ij++, this.moving = !1, this.menuVisible = !1, this.filterActive = !1, this.eventService = new Zu(), this.rowGroupActive = !1, this.pivotActive = !1, this.aggregationActive = !1, this.colDef = e, this.userProvidedColDef = t, this.colId = i, this.primary = r, this.setState(e);
    }
    return n.prototype.getInstanceId = function() {
      return this.instanceId;
    }, n.prototype.setState = function(e) {
      e.sort !== void 0 ? (e.sort === q.SORT_ASC || e.sort === q.SORT_DESC) && (this.sort = e.sort) : (e.initialSort === q.SORT_ASC || e.initialSort === q.SORT_DESC) && (this.sort = e.initialSort);
      var t = sa(e.sortIndex), i = sa(e.initialSortIndex);
      t !== void 0 ? t !== null && (this.sortIndex = t) : i !== null && (this.sortIndex = i);
      var r = Iu(e.hide), o = Iu(e.initialHide);
      r !== void 0 ? this.visible = !r : this.visible = !o, e.pinned !== void 0 ? this.setPinned(e.pinned) : this.setPinned(e.initialPinned);
      var s = sa(e.flex), a = sa(e.initialFlex);
      s !== void 0 ? this.flex = s : a !== void 0 && (this.flex = a);
    }, n.prototype.setColDef = function(e, t) {
      this.colDef = e, this.userProvidedColDef = t, this.initMinAndMaxWidths(), this.initDotNotation();
    }, n.prototype.getUserProvidedColDef = function() {
      return this.userProvidedColDef;
    }, n.prototype.setParent = function(e) {
      this.parent = e;
    }, n.prototype.getParent = function() {
      return this.parent;
    }, n.prototype.setOriginalParent = function(e) {
      this.originalParent = e;
    }, n.prototype.getOriginalParent = function() {
      return this.originalParent;
    }, n.prototype.initialise = function() {
      this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.validate();
    }, n.prototype.initDotNotation = function() {
      var e = this.gridOptionsWrapper.isSuppressFieldDotNotation();
      this.fieldContainsDots = de(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !e, this.tooltipFieldContainsDots = de(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !e;
    }, n.prototype.initMinAndMaxWidths = function() {
      var e = this.colDef;
      this.minWidth = this.columnUtils.calculateColMinWidth(e), this.maxWidth = this.columnUtils.calculateColMaxWidth(e);
    }, n.prototype.resetActualWidth = function(e) {
      e === void 0 && (e = "api");
      var t = this.columnUtils.calculateColInitialWidth(this.colDef);
      this.setActualWidth(t, e, !0);
    }, n.prototype.isEmptyGroup = function() {
      return !1;
    }, n.prototype.isRowGroupDisplayed = function(e) {
      if (Je(this.colDef) || Je(this.colDef.showRowGroup))
        return !1;
      var t = this.colDef.showRowGroup === !0, i = this.colDef.showRowGroup === e;
      return t || i;
    }, n.prototype.isPrimary = function() {
      return this.primary;
    }, n.prototype.isFilterAllowed = function() {
      var e = !!this.colDef.filter || !!this.colDef.filterFramework;
      return this.primary && e;
    }, n.prototype.isFieldContainsDots = function() {
      return this.fieldContainsDots;
    }, n.prototype.isTooltipFieldContainsDots = function() {
      return this.tooltipFieldContainsDots;
    }, n.prototype.validate = function() {
      var e = this.colDef;
      function t(s, a, l) {
        mi(function() {
          l ? console.warn(s, l) : mi(function() {
            return console.warn(s);
          }, a);
        }, a);
      }
      var i = this.gridOptionsWrapper.isRowModelDefault();
      if (i && !pt.isRegistered(ct.RowGroupingModule)) {
        var r = ["enableRowGroup", "rowGroup", "rowGroupIndex", "enablePivot", "enableValue", "pivot", "pivotIndex", "aggFunc"];
        r.forEach(function(s) {
          de(e[s]) && (pt.isPackageBased() ? t("AG Grid: " + s + " is only valid in ag-grid-enterprise, your column definition should not have " + s, "ColumnRowGroupingMissing" + s) : t("AG Grid: " + s + " is only valid with AG Grid Enterprise Module " + ct.RowGroupingModule + " - your column definition should not have " + s, "ColumnRowGroupingMissing" + s));
        });
      }
      if (pt.isRegistered(ct.RichSelectModule) || this.colDef.cellEditor === "agRichSelect" && (pt.isPackageBased() ? t("AG Grid: " + this.colDef.cellEditor + " can only be used with ag-grid-enterprise", "ColumnRichSelectMissing") : t("AG Grid: " + this.colDef.cellEditor + " can only be used with AG Grid Enterprise Module " + ct.RichSelectModule, "ColumnRichSelectMissing")), this.gridOptionsWrapper.isTreeData()) {
        var o = ["rowGroup", "rowGroupIndex", "pivot", "pivotIndex"];
        o.forEach(function(s) {
          de(e[s]) && t("AG Grid: " + s + " is not possible when doing tree data, your column definition should not have " + s, "TreeDataCannotRowGroup");
        });
      }
      de(this.colDef.width) && typeof this.colDef.width != "number" && t("AG Grid: colDef.width should be a number, not " + typeof this.colDef.width, "ColumnCheck_asdfawef"), e.pinnedRowCellRenderer && t("AG Grid: pinnedRowCellRenderer no longer exists, use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned. This was an unfortunate (but necessary) change we had to do to allow future plans we have of re-skinng the data grid in frameworks such as React, Angular and Vue. See https://www.ag-grid.com/javascript-grid/cell-rendering/#many-renderers-one-column", "colDef.pinnedRowCellRenderer-deprecated"), e.pinnedRowCellRendererParams && t("AG Grid: pinnedRowCellRenderer no longer exists, use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned. This was an unfortunate (but necessary) change we had to do to allow future plans we have of re-skinng the data grid in frameworks such as React, Angular and Vue. See https://www.ag-grid.com/javascript-grid/cell-rendering/#many-renderers-one-column", "colDef.pinnedRowCellRenderer-deprecated"), e.pinnedRowCellRendererFramework && t("AG Grid: pinnedRowCellRenderer no longer exists, use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned. This was an unfortunate (but necessary) change we had to do to allow future plans we have of re-skinng the data grid in frameworks such as React, Angular and Vue. See https://www.ag-grid.com/javascript-grid/cell-rendering/#many-renderers-one-column", "colDef.pinnedRowCellRenderer-deprecated"), e.pinnedRowValueGetter && t("AG Grid: pinnedRowCellRenderer is deprecated, use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned. This was an unfortunate (but necessary) change we had to do to allow future plans we have of re-skinng the data grid in frameworks such as React, Angular and Vue.", "colDef.pinnedRowCellRenderer-deprecated");
    }, n.prototype.addEventListener = function(e, t) {
      this.eventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.eventService.removeEventListener(e, t);
    }, n.prototype.createColumnFunctionCallbackParams = function(e) {
      return {
        node: e,
        data: e.data,
        column: this,
        colDef: this.colDef,
        context: this.gridOptionsWrapper.getContext(),
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi()
      };
    }, n.prototype.isSuppressNavigable = function(e) {
      if (typeof this.colDef.suppressNavigable == "boolean")
        return this.colDef.suppressNavigable;
      if (typeof this.colDef.suppressNavigable == "function") {
        var t = this.createColumnFunctionCallbackParams(e), i = this.colDef.suppressNavigable;
        return i(t);
      }
      return !1;
    }, n.prototype.isCellEditable = function(e) {
      return e.group && !this.gridOptionsWrapper.isEnableGroupEdit() ? !1 : this.isColumnFunc(e, this.colDef.editable);
    }, n.prototype.isSuppressFillHandle = function() {
      return !!Iu(this.colDef.suppressFillHandle);
    }, n.prototype.isAutoHeight = function() {
      return !!Iu(this.colDef.autoHeight);
    }, n.prototype.isRowDrag = function(e) {
      return this.isColumnFunc(e, this.colDef.rowDrag);
    }, n.prototype.isDndSource = function(e) {
      return this.isColumnFunc(e, this.colDef.dndSource);
    }, n.prototype.isCellCheckboxSelection = function(e) {
      return this.isColumnFunc(e, this.colDef.checkboxSelection);
    }, n.prototype.isSuppressPaste = function(e) {
      return this.isColumnFunc(e, this.colDef ? this.colDef.suppressPaste : null);
    }, n.prototype.isResizable = function() {
      return !!Iu(this.colDef.resizable);
    }, n.prototype.isColumnFunc = function(e, t) {
      if (typeof t == "boolean")
        return t;
      if (typeof t == "function") {
        var i = this.createColumnFunctionCallbackParams(e), r = t;
        return r(i);
      }
      return !1;
    }, n.prototype.setMoving = function(e, t) {
      t === void 0 && (t = "api"), this.moving = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_MOVING_CHANGED, t));
    }, n.prototype.createColumnEvent = function(e, t) {
      return {
        api: this.gridApi,
        columnApi: this.columnApi,
        type: e,
        column: this,
        columns: [this],
        source: t
      };
    }, n.prototype.isMoving = function() {
      return this.moving;
    }, n.prototype.getSort = function() {
      return this.sort;
    }, n.prototype.setSort = function(e, t) {
      t === void 0 && (t = "api"), this.sort !== e && (this.sort = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_SORT_CHANGED, t)));
    }, n.prototype.setMenuVisible = function(e, t) {
      t === void 0 && (t = "api"), this.menuVisible !== e && (this.menuVisible = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_MENU_VISIBLE_CHANGED, t)));
    }, n.prototype.isMenuVisible = function() {
      return this.menuVisible;
    }, n.prototype.isSortAscending = function() {
      return this.sort === q.SORT_ASC;
    }, n.prototype.isSortDescending = function() {
      return this.sort === q.SORT_DESC;
    }, n.prototype.isSortNone = function() {
      return Je(this.sort);
    }, n.prototype.isSorting = function() {
      return de(this.sort);
    }, n.prototype.getSortIndex = function() {
      return this.sortIndex;
    }, n.prototype.setSortIndex = function(e) {
      this.sortIndex = e;
    }, n.prototype.setAggFunc = function(e) {
      this.aggFunc = e;
    }, n.prototype.getAggFunc = function() {
      return this.aggFunc;
    }, n.prototype.getLeft = function() {
      return this.left;
    }, n.prototype.getOldLeft = function() {
      return this.oldLeft;
    }, n.prototype.getRight = function() {
      return this.left + this.actualWidth;
    }, n.prototype.setLeft = function(e, t) {
      t === void 0 && (t = "api"), this.oldLeft = this.left, this.left !== e && (this.left = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_LEFT_CHANGED, t)));
    }, n.prototype.isFilterActive = function() {
      return this.filterActive;
    }, n.prototype.setFilterActive = function(e, t, i) {
      t === void 0 && (t = "api"), this.filterActive !== e && (this.filterActive = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_FILTER_ACTIVE_CHANGED, t)));
      var r = this.createColumnEvent(n.EVENT_FILTER_CHANGED, t);
      i && aa(r, i), this.eventService.dispatchEvent(r);
    }, n.prototype.setPinned = function(e) {
      e === !0 || e === q.PINNED_LEFT ? this.pinned = q.PINNED_LEFT : e === q.PINNED_RIGHT ? this.pinned = q.PINNED_RIGHT : this.pinned = null;
    }, n.prototype.setFirstRightPinned = function(e, t) {
      t === void 0 && (t = "api"), this.firstRightPinned !== e && (this.firstRightPinned = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_FIRST_RIGHT_PINNED_CHANGED, t)));
    }, n.prototype.setLastLeftPinned = function(e, t) {
      t === void 0 && (t = "api"), this.lastLeftPinned !== e && (this.lastLeftPinned = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_LAST_LEFT_PINNED_CHANGED, t)));
    }, n.prototype.isFirstRightPinned = function() {
      return this.firstRightPinned;
    }, n.prototype.isLastLeftPinned = function() {
      return this.lastLeftPinned;
    }, n.prototype.isPinned = function() {
      return this.pinned === q.PINNED_LEFT || this.pinned === q.PINNED_RIGHT;
    }, n.prototype.isPinnedLeft = function() {
      return this.pinned === q.PINNED_LEFT;
    }, n.prototype.isPinnedRight = function() {
      return this.pinned === q.PINNED_RIGHT;
    }, n.prototype.getPinned = function() {
      return this.pinned;
    }, n.prototype.setVisible = function(e, t) {
      t === void 0 && (t = "api");
      var i = e === !0;
      this.visible !== i && (this.visible = i, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_VISIBLE_CHANGED, t)));
    }, n.prototype.isVisible = function() {
      return this.visible;
    }, n.prototype.getColDef = function() {
      return this.colDef;
    }, n.prototype.getColumnGroupShow = function() {
      return this.colDef.columnGroupShow;
    }, n.prototype.getColId = function() {
      return this.colId;
    }, n.prototype.getId = function() {
      return this.getColId();
    }, n.prototype.getUniqueId = function() {
      return this.getId();
    }, n.prototype.getDefinition = function() {
      return this.colDef;
    }, n.prototype.getActualWidth = function() {
      return this.actualWidth;
    }, n.prototype.createBaseColDefParams = function(e) {
      var t = {
        node: e,
        data: e.data,
        colDef: this.colDef,
        column: this,
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        context: this.gridOptionsWrapper.getContext()
      };
      return t;
    }, n.prototype.getColSpan = function(e) {
      if (Je(this.colDef.colSpan))
        return 1;
      var t = this.createBaseColDefParams(e), i = this.colDef.colSpan(t);
      return Math.max(i, 1);
    }, n.prototype.getRowSpan = function(e) {
      if (Je(this.colDef.rowSpan))
        return 1;
      var t = this.createBaseColDefParams(e), i = this.colDef.rowSpan(t);
      return Math.max(i, 1);
    }, n.prototype.setActualWidth = function(e, t, i) {
      t === void 0 && (t = "api"), i === void 0 && (i = !1), this.minWidth != null && (e = Math.max(e, this.minWidth)), this.maxWidth != null && (e = Math.min(e, this.maxWidth)), this.actualWidth !== e && (this.actualWidth = e, this.flex && t !== "flex" && t !== "gridInitializing" && (this.flex = null), i || this.fireColumnWidthChangedEvent(t));
    }, n.prototype.fireColumnWidthChangedEvent = function(e) {
      this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_WIDTH_CHANGED, e));
    }, n.prototype.isGreaterThanMax = function(e) {
      return this.maxWidth != null ? e > this.maxWidth : !1;
    }, n.prototype.getMinWidth = function() {
      return this.minWidth;
    }, n.prototype.getMaxWidth = function() {
      return this.maxWidth;
    }, n.prototype.getFlex = function() {
      return this.flex || 0;
    }, n.prototype.setFlex = function(e) {
      this.flex !== e && (this.flex = e);
    }, n.prototype.setMinimum = function(e) {
      e === void 0 && (e = "api"), de(this.minWidth) && this.setActualWidth(this.minWidth, e);
    }, n.prototype.setRowGroupActive = function(e, t) {
      t === void 0 && (t = "api"), this.rowGroupActive !== e && (this.rowGroupActive = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_ROW_GROUP_CHANGED, t)));
    }, n.prototype.isRowGroupActive = function() {
      return this.rowGroupActive;
    }, n.prototype.setPivotActive = function(e, t) {
      t === void 0 && (t = "api"), this.pivotActive !== e && (this.pivotActive = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_PIVOT_CHANGED, t)));
    }, n.prototype.isPivotActive = function() {
      return this.pivotActive;
    }, n.prototype.isAnyFunctionActive = function() {
      return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
    }, n.prototype.isAnyFunctionAllowed = function() {
      return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
    }, n.prototype.setValueActive = function(e, t) {
      t === void 0 && (t = "api"), this.aggregationActive !== e && (this.aggregationActive = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_VALUE_CHANGED, t)));
    }, n.prototype.isValueActive = function() {
      return this.aggregationActive;
    }, n.prototype.isAllowPivot = function() {
      return this.colDef.enablePivot === !0;
    }, n.prototype.isAllowValue = function() {
      return this.colDef.enableValue === !0;
    }, n.prototype.isAllowRowGroup = function() {
      return this.colDef.enableRowGroup === !0;
    }, n.prototype.getMenuTabs = function(e) {
      var t = this.getColDef().menuTabs;
      return t == null && (t = e), t;
    }, n.prototype.isLockPosition = function() {
      return console.warn("AG Grid: since v21, col.isLockPosition() should not be used, please use col.getColDef().lockPosition instead."), this.colDef ? !!this.colDef.lockPosition : !1;
    }, n.prototype.isLockVisible = function() {
      return console.warn("AG Grid: since v21, col.isLockVisible() should not be used, please use col.getColDef().lockVisible instead."), this.colDef ? !!this.colDef.lockVisible : !1;
    }, n.prototype.isLockPinned = function() {
      return console.warn("AG Grid: since v21, col.isLockPinned() should not be used, please use col.getColDef().lockPinned instead."), this.colDef ? !!this.colDef.lockPinned : !1;
    }, n.EVENT_MOVING_CHANGED = "movingChanged", n.EVENT_LEFT_CHANGED = "leftChanged", n.EVENT_WIDTH_CHANGED = "widthChanged", n.EVENT_LAST_LEFT_PINNED_CHANGED = "lastLeftPinnedChanged", n.EVENT_FIRST_RIGHT_PINNED_CHANGED = "firstRightPinnedChanged", n.EVENT_VISIBLE_CHANGED = "visibleChanged", n.EVENT_FILTER_CHANGED = "filterChanged", n.EVENT_FILTER_ACTIVE_CHANGED = "filterActiveChanged", n.EVENT_SORT_CHANGED = "sortChanged", n.EVENT_MENU_VISIBLE_CHANGED = "menuVisibleChanged", n.EVENT_ROW_GROUP_CHANGED = "columnRowGroupChanged", n.EVENT_PIVOT_CHANGED = "columnPivotChanged", n.EVENT_VALUE_CHANGED = "columnValueChanged", cf([
      R("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), cf([
      R("columnUtils")
    ], n.prototype, "columnUtils", void 0), cf([
      R("columnApi")
    ], n.prototype, "columnApi", void 0), cf([
      R("gridApi")
    ], n.prototype, "gridApi", void 0), cf([
      R("context")
    ], n.prototype, "context", void 0), cf([
      Ee
    ], n.prototype, "initialise", null), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function KV() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  for (var t = 0; t < n.length; t++) {
    var i = n[t];
    if (de(i))
      return i;
  }
  return null;
}
function nj(n) {
  return n != null && n.length > 0;
}
function Di(n) {
  if (!(!n || !n.length))
    return n[n.length - 1];
}
function ud(n, e, t) {
  return n == null && e == null ? !0 : n != null && e != null && n.length === e.length && n.every(function(i, r) {
    return t ? t(i, e[r]) : e[r] === i;
  });
}
function rj(n, e) {
  return ud(n, e);
}
function oj(n, e) {
  return ud(n, e);
}
function qV(n) {
  return n.sort(function(e, t) {
    return e - t;
  });
}
function sj(n, e) {
  if (n)
    for (var t = n.length - 2; t >= 0; t--) {
      var i = n[t] === e, r = n[t + 1] === e;
      i && r && n.splice(t + 1, 1);
    }
}
function qr(n, e) {
  var t = n.indexOf(e);
  t >= 0 && n.splice(t, 1);
}
function $O(n, e) {
  e.forEach(function(t) {
    return qr(n, t);
  });
}
function Pv(n, e, t) {
  n.splice(t, 0, e);
}
function aj(n, e, t) {
  if (!(n == null || e == null))
    for (var i = e.length - 1; i >= 0; i--) {
      var r = e[i];
      Pv(n, r, t);
    }
}
function y1(n, e, t) {
  $O(n, e), e.slice().reverse().forEach(function(i) {
    return Pv(n, i, t);
  });
}
function Cs(n, e) {
  return n.indexOf(e) > -1;
}
function lj(n) {
  return [].concat.apply([], n);
}
function w1(n, e) {
  e == null || n == null || e.forEach(function(t) {
    return n.push(t);
  });
}
function uj(n) {
  return n.map(UO);
}
function cj(n, e) {
  if (n != null)
    for (var t = n.length - 1; t >= 0; t--)
      e(n[t], t);
}
const hj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  areEqual: ud,
  compareArrays: rj,
  existsAndNotEmpty: nj,
  firstExistingValue: KV,
  flatten: lj,
  forEachReverse: cj,
  includes: Cs,
  insertArrayIntoArray: aj,
  insertIntoArray: Pv,
  last: Di,
  moveInArray: y1,
  pushAll: w1,
  removeAllFromArray: $O,
  removeFromArray: qr,
  removeRepeatsFromArray: sj,
  shallowCompare: oj,
  sortNumerically: qV,
  toStrings: uj
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var dj = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Yr = (
  /** @class */
  function() {
    function n(e, t, i, r) {
      this.displayedChildren = [], this.localEventService = new Zu(), this.groupId = t, this.instanceId = i, this.providedColumnGroup = e, this.pinned = r;
    }
    return n.createUniqueId = function(e, t) {
      return e + "_" + t;
    }, n.prototype.reset = function() {
      this.parent = null, this.children = null, this.displayedChildren = null;
    }, n.prototype.getParent = function() {
      return this.parent;
    }, n.prototype.setParent = function(e) {
      this.parent = e;
    }, n.prototype.getUniqueId = function() {
      return n.createUniqueId(this.groupId, this.instanceId);
    }, n.prototype.isEmptyGroup = function() {
      return this.displayedChildren.length === 0;
    }, n.prototype.isMoving = function() {
      var e = this.getProvidedColumnGroup().getLeafColumns();
      return !e || e.length === 0 ? !1 : e.every(function(t) {
        return t.isMoving();
      });
    }, n.prototype.checkLeft = function() {
      if (this.displayedChildren.forEach(function(r) {
        r instanceof n && r.checkLeft();
      }), this.displayedChildren.length > 0)
        if (this.gridOptionsWrapper.isEnableRtl()) {
          var e = Di(this.displayedChildren), t = e.getLeft();
          this.setLeft(t);
        } else {
          var i = this.displayedChildren[0].getLeft();
          this.setLeft(i);
        }
      else
        this.setLeft(null);
    }, n.prototype.getLeft = function() {
      return this.left;
    }, n.prototype.getOldLeft = function() {
      return this.oldLeft;
    }, n.prototype.setLeft = function(e) {
      this.oldLeft = e, this.left !== e && (this.left = e, this.localEventService.dispatchEvent(this.createAgEvent(n.EVENT_LEFT_CHANGED)));
    }, n.prototype.getPinned = function() {
      return this.pinned;
    }, n.prototype.createAgEvent = function(e) {
      return { type: e };
    }, n.prototype.addEventListener = function(e, t) {
      this.localEventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.localEventService.removeEventListener(e, t);
    }, n.prototype.getGroupId = function() {
      return this.groupId;
    }, n.prototype.getInstanceId = function() {
      return this.instanceId;
    }, n.prototype.isChildInThisGroupDeepSearch = function(e) {
      var t = !1;
      return this.children.forEach(function(i) {
        e === i && (t = !0), i instanceof n && i.isChildInThisGroupDeepSearch(e) && (t = !0);
      }), t;
    }, n.prototype.getActualWidth = function() {
      var e = 0;
      return this.displayedChildren && this.displayedChildren.forEach(function(t) {
        e += t.getActualWidth();
      }), e;
    }, n.prototype.isResizable = function() {
      if (!this.displayedChildren)
        return !1;
      var e = !1;
      return this.displayedChildren.forEach(function(t) {
        t.isResizable() && (e = !0);
      }), e;
    }, n.prototype.getMinWidth = function() {
      var e = 0;
      return this.displayedChildren.forEach(function(t) {
        e += t.getMinWidth() || 0;
      }), e;
    }, n.prototype.addChild = function(e) {
      this.children || (this.children = []), this.children.push(e);
    }, n.prototype.getDisplayedChildren = function() {
      return this.displayedChildren;
    }, n.prototype.getLeafColumns = function() {
      var e = [];
      return this.addLeafColumns(e), e;
    }, n.prototype.getDisplayedLeafColumns = function() {
      var e = [];
      return this.addDisplayedLeafColumns(e), e;
    }, n.prototype.getDefinition = function() {
      return this.providedColumnGroup.getColGroupDef();
    }, n.prototype.getColGroupDef = function() {
      return this.providedColumnGroup.getColGroupDef();
    }, n.prototype.isPadding = function() {
      return this.providedColumnGroup.isPadding();
    }, n.prototype.isExpandable = function() {
      return this.providedColumnGroup.isExpandable();
    }, n.prototype.isExpanded = function() {
      return this.providedColumnGroup.isExpanded();
    }, n.prototype.setExpanded = function(e) {
      this.providedColumnGroup.setExpanded(e);
    }, n.prototype.addDisplayedLeafColumns = function(e) {
      this.displayedChildren.forEach(function(t) {
        t instanceof Gt ? e.push(t) : t instanceof n && t.addDisplayedLeafColumns(e);
      });
    }, n.prototype.addLeafColumns = function(e) {
      this.children.forEach(function(t) {
        t instanceof Gt ? e.push(t) : t instanceof n && t.addLeafColumns(e);
      });
    }, n.prototype.getChildren = function() {
      return this.children;
    }, n.prototype.getColumnGroupShow = function() {
      return this.providedColumnGroup.getColumnGroupShow();
    }, n.prototype.getProvidedColumnGroup = function() {
      return this.providedColumnGroup;
    }, n.prototype.getOriginalColumnGroup = function() {
      return console.warn("AG Grid: columnGroup.getOriginalColumnGroup() is deprecated due to a method rename, use columnGroup.getProvidedColumnGroup() instead"), this.getProvidedColumnGroup();
    }, n.prototype.getPaddingLevel = function() {
      var e = this.getParent();
      return !this.isPadding() || !e || !e.isPadding() ? 0 : 1 + e.getPaddingLevel();
    }, n.prototype.calculateDisplayedColumns = function() {
      var e = this;
      this.displayedChildren = [];
      for (var t = this; t != null && t.isPadding(); )
        t = t.getParent();
      var i = t ? t.providedColumnGroup.isExpandable() : !1;
      if (!i) {
        this.displayedChildren = this.children, this.localEventService.dispatchEvent(this.createAgEvent(n.EVENT_DISPLAYED_CHILDREN_CHANGED));
        return;
      }
      this.children.forEach(function(r) {
        var o = r instanceof n && (!r.displayedChildren || !r.displayedChildren.length);
        if (!o) {
          var s = r.getColumnGroupShow();
          switch (s) {
            case n.HEADER_GROUP_SHOW_OPEN:
              t.providedColumnGroup.isExpanded() && e.displayedChildren.push(r);
              break;
            case n.HEADER_GROUP_SHOW_CLOSED:
              t.providedColumnGroup.isExpanded() || e.displayedChildren.push(r);
              break;
            default:
              e.displayedChildren.push(r);
              break;
          }
        }
      }), this.localEventService.dispatchEvent(this.createAgEvent(n.EVENT_DISPLAYED_CHILDREN_CHANGED));
    }, n.HEADER_GROUP_SHOW_OPEN = "open", n.HEADER_GROUP_SHOW_CLOSED = "closed", n.EVENT_LEFT_CHANGED = "leftChanged", n.EVENT_DISPLAYED_CHILDREN_CHANGED = "displayedChildrenChanged", dj([
      R("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var fn = (
  /** @class */
  function() {
    function n(e, t, i, r) {
      this.localEventService = new Zu(), this.expandable = !1, this.colGroupDef = e, this.groupId = t, this.expanded = !!e && !!e.openByDefault, this.padding = i, this.level = r;
    }
    return n.prototype.setOriginalParent = function(e) {
      this.originalParent = e;
    }, n.prototype.getOriginalParent = function() {
      return this.originalParent;
    }, n.prototype.getLevel = function() {
      return this.level;
    }, n.prototype.isVisible = function() {
      return this.children ? this.children.some(function(e) {
        return e.isVisible();
      }) : !1;
    }, n.prototype.isPadding = function() {
      return this.padding;
    }, n.prototype.setExpanded = function(e) {
      this.expanded = e === void 0 ? !1 : e;
      var t = {
        type: n.EVENT_EXPANDED_CHANGED
      };
      this.localEventService.dispatchEvent(t);
    }, n.prototype.isExpandable = function() {
      return this.expandable;
    }, n.prototype.isExpanded = function() {
      return this.expanded;
    }, n.prototype.getGroupId = function() {
      return this.groupId;
    }, n.prototype.getId = function() {
      return this.getGroupId();
    }, n.prototype.setChildren = function(e) {
      this.children = e;
    }, n.prototype.getChildren = function() {
      return this.children;
    }, n.prototype.getColGroupDef = function() {
      return this.colGroupDef;
    }, n.prototype.getLeafColumns = function() {
      var e = [];
      return this.addLeafColumns(e), e;
    }, n.prototype.addLeafColumns = function(e) {
      this.children && this.children.forEach(function(t) {
        t instanceof Gt ? e.push(t) : t instanceof n && t.addLeafColumns(e);
      });
    }, n.prototype.getColumnGroupShow = function() {
      var e = this.colGroupDef;
      if (e)
        return e.columnGroupShow;
    }, n.prototype.setupExpandable = function() {
      var e = this;
      this.setExpandable(), this.getLeafColumns().forEach(function(t) {
        return t.addEventListener(Gt.EVENT_VISIBLE_CHANGED, e.onColumnVisibilityChanged.bind(e));
      });
    }, n.prototype.setExpandable = function() {
      if (!this.isPadding()) {
        for (var e = !1, t = !1, i = !1, r = this.findChildrenRemovingPadding(), o = 0, s = r.length; o < s; o++) {
          var a = r[o];
          if (a.isVisible()) {
            var l = a.getColumnGroupShow();
            l === Yr.HEADER_GROUP_SHOW_OPEN ? (e = !0, i = !0) : l === Yr.HEADER_GROUP_SHOW_CLOSED ? (t = !0, i = !0) : (e = !0, t = !0);
          }
        }
        var u = e && t && i;
        if (this.expandable !== u) {
          this.expandable = u;
          var c = {
            type: n.EVENT_EXPANDABLE_CHANGED
          };
          this.localEventService.dispatchEvent(c);
        }
      }
    }, n.prototype.findChildrenRemovingPadding = function() {
      var e = [], t = function(i) {
        i.forEach(function(r) {
          var o = r instanceof n && r.isPadding();
          o ? t(r.children) : e.push(r);
        });
      };
      return t(this.children), e;
    }, n.prototype.onColumnVisibilityChanged = function() {
      this.setExpandable();
    }, n.prototype.addEventListener = function(e, t) {
      this.localEventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.localEventService.removeEventListener(e, t);
    }, n.EVENT_EXPANDED_CHANGED = "expandedChanged", n.EVENT_EXPANDABLE_CHANGED = "expandableChanged", n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var fj = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
};
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var YV = "__ag_Grid_Stop_Propagation", pj = ["touchstart", "touchend", "touchmove", "touchcancel"], $E = {};
function Ap(n) {
  n[YV] = !0;
}
function Ml(n) {
  return n[YV] === !0;
}
var KO = function() {
  var n = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  }, e = function(t) {
    if (typeof $E[t] == "boolean")
      return $E[t];
    var i = document.createElement(n[t] || "div");
    return t = "on" + t, $E[t] = t in i;
  };
  return e;
}();
function Nw(n, e, t) {
  for (var i = e.target; i; ) {
    var r = n.getDomData(i, t);
    if (r)
      return r;
    i = i.parentElement;
  }
  return null;
}
function gj(n, e) {
  n.addEventListener("changed", e), n.addEventListener("paste", e), n.addEventListener("input", e);
}
function Iw(n, e) {
  return !e || !n ? !1 : qO(e).indexOf(n) >= 0;
}
function XV(n) {
  for (var e = [], t = n.target; t; )
    e.push(t), t = t.parentElement;
  return e;
}
function mj(n) {
  n.__agGridEventPath = qO(n);
}
function qO(n) {
  var e = n;
  return e.path ? e.path : e.composedPath ? e.composedPath() : e.__agGridEventPath ? e.__agGridEventPath : XV(n);
}
function ZV(n, e, t, i) {
  var r = Cs(pj, t), o = r ? { passive: !0 } : void 0;
  n && n.addEventListener && n.addEventListener(e, t, i, o);
}
const vj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addAgGridEventPath: mj,
  addChangeListener: gj,
  addSafePassiveEventListener: ZV,
  createEventPath: XV,
  getCtrlForEvent: Nw,
  getEventPath: qO,
  isElementInEventPath: Iw,
  isEventSupported: KO,
  isStopPropagationForAgGrid: Ml,
  stopPropagationForAgGrid: Ap
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Jg = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, we = (
  /** @class */
  function() {
    function n() {
      var e = this;
      this.destroyFunctions = [], this.destroyed = !1, this.__v_skip = !0, this.isAlive = function() {
        return !e.destroyed;
      };
    }
    return n.prototype.getFrameworkOverrides = function() {
      return this.frameworkOverrides;
    }, n.prototype.getContext = function() {
      return this.context;
    }, n.prototype.destroy = function() {
      this.destroyFunctions.forEach(function(e) {
        return e();
      }), this.destroyFunctions.length = 0, this.destroyed = !0, this.dispatchEvent({ type: n.EVENT_DESTROYED });
    }, n.prototype.addEventListener = function(e, t) {
      this.localEventService || (this.localEventService = new Zu()), this.localEventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.localEventService && this.localEventService.removeEventListener(e, t);
    }, n.prototype.dispatchEventAsync = function(e) {
      var t = this;
      window.setTimeout(function() {
        return t.dispatchEvent(e);
      }, 0);
    }, n.prototype.dispatchEvent = function(e) {
      this.localEventService && this.localEventService.dispatchEvent(e);
    }, n.prototype.addManagedListener = function(e, t, i) {
      var r = this;
      if (!this.destroyed) {
        e instanceof HTMLElement ? ZV(this.getFrameworkOverrides(), e, t, i) : e.addEventListener(t, i);
        var o = function() {
          return e.removeEventListener(t, i), r.destroyFunctions = r.destroyFunctions.filter(function(s) {
            return s !== o;
          }), null;
        };
        return this.destroyFunctions.push(o), o;
      }
    }, n.prototype.addDestroyFunc = function(e) {
      this.isAlive() ? this.destroyFunctions.push(e) : e();
    }, n.prototype.createManagedBean = function(e, t) {
      var i = this.createBean(e, t);
      return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), i;
    }, n.prototype.createBean = function(e, t, i) {
      return (t || this.getContext()).createBean(e, i);
    }, n.prototype.destroyBean = function(e, t) {
      return (t || this.getContext()).destroyBean(e);
    }, n.prototype.destroyBeans = function(e, t) {
      var i = this;
      return e && e.forEach(function(r) {
        return i.destroyBean(r, t);
      }), [];
    }, n.EVENT_DESTROYED = "destroyed", Jg([
      R("frameworkOverrides")
    ], n.prototype, "frameworkOverrides", void 0), Jg([
      R("context")
    ], n.prototype, "context", void 0), Jg([
      R("eventService")
    ], n.prototype, "eventService", void 0), Jg([
      R("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), Jg([
      Lo
    ], n.prototype, "destroy", null), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var _j = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), KE = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Cj = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, QV = (
  /** @class */
  function(n) {
    _j(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setBeans = function(t) {
      this.logger = t.create("ColumnFactory");
    }, e.prototype.createColumnTree = function(t, i, r) {
      var o = new AV(), s = this.extractExistingTreeData(r), a = s.existingCols, l = s.existingGroups, u = s.existingColKeys;
      o.addExistingKeys(u);
      var c = this.recursivelyCreateColumns(t, 0, i, a, o, l), h = this.findMaxDept(c, 0);
      this.logger.log("Number of levels for grouped columns is " + h);
      var d = this.balanceColumnTree(c, 0, h, o), f = function(p, g) {
        p instanceof fn && p.setupExpandable(), p.setOriginalParent(g);
      };
      return this.columnUtils.depthFirstOriginalTreeSearch(null, d, f), {
        columnTree: d,
        treeDept: h
      };
    }, e.prototype.extractExistingTreeData = function(t) {
      var i = [], r = [], o = [];
      return t && this.columnUtils.depthFirstOriginalTreeSearch(null, t, function(s) {
        if (s instanceof fn) {
          var a = s;
          r.push(a);
        } else {
          var l = s;
          o.push(l.getId()), i.push(l);
        }
      }), { existingCols: i, existingGroups: r, existingColKeys: o };
    }, e.prototype.createForAutoGroups = function(t, i) {
      var r = this, o = [];
      return t.forEach(function(s) {
        var a = r.createAutoGroupTreeItem(i, s);
        o.push(a);
      }), o;
    }, e.prototype.createAutoGroupTreeItem = function(t, i) {
      for (var r = this.findDepth(t), o = i, s = r - 1; s >= 0; s--) {
        var a = new fn(null, "FAKE_PATH_" + i.getId() + "}_" + s, !0, s);
        this.context.createBean(a), a.setChildren([o]), o.setOriginalParent(a), o = a;
      }
      return o;
    }, e.prototype.findDepth = function(t) {
      for (var i = 0, r = t; r && r[0] && r[0] instanceof fn; )
        i++, r = r[0].getChildren();
      return i;
    }, e.prototype.balanceColumnTree = function(t, i, r, o) {
      for (var s = [], a = 0; a < t.length; a++) {
        var l = t[a];
        if (l instanceof fn) {
          var u = l, c = this.balanceColumnTree(u.getChildren(), i + 1, r, o);
          u.setChildren(c), s.push(u);
        } else {
          for (var h = void 0, d = void 0, f = r - 1; f >= i; f--) {
            var p = o.getUniqueKey(null, null), g = this.createMergedColGroupDef(null), _ = new fn(g, p, !0, i);
            this.context.createBean(_), d && d.setChildren([_]), d = _, h || (h = d);
          }
          if (h && d) {
            s.push(h);
            var m = t.some(function(v) {
              return v instanceof fn;
            });
            if (m) {
              d.setChildren([l]);
              continue;
            } else {
              d.setChildren(t);
              break;
            }
          }
          s.push(l);
        }
      }
      return s;
    }, e.prototype.findMaxDept = function(t, i) {
      for (var r = i, o = 0; o < t.length; o++) {
        var s = t[o];
        if (s instanceof fn) {
          var a = s, l = this.findMaxDept(a.getChildren(), i + 1);
          r < l && (r = l);
        }
      }
      return r;
    }, e.prototype.recursivelyCreateColumns = function(t, i, r, o, s, a) {
      var l = this, u = [];
      return t && t.forEach(function(c) {
        var h;
        l.isColumnGroup(c) ? h = l.createColumnGroup(r, c, i, o, s, a) : h = l.createColumn(r, c, o, s), u.push(h);
      }), u;
    }, e.prototype.createColumnGroup = function(t, i, r, o, s, a) {
      var l = this.createMergedColGroupDef(i), u = s.getUniqueKey(l.groupId || null, null), c = new fn(l, u, !1, r);
      this.context.createBean(c);
      var h = this.findExistingGroup(i, a);
      h && h.isExpanded() && c.setExpanded(!0);
      var d = this.recursivelyCreateColumns(l.children, r + 1, t, o, s, a);
      return c.setChildren(d), c;
    }, e.prototype.createMergedColGroupDef = function(t) {
      var i = {};
      return Object.assign(i, this.gridOptionsWrapper.getDefaultColGroupDef()), Object.assign(i, t), this.checkForDeprecatedItems(i), i;
    }, e.prototype.createColumn = function(t, i, r, o) {
      var s = this.mergeColDefs(i);
      this.checkForDeprecatedItems(s);
      var a = this.findExistingColumn(i, r);
      if (a)
        a.setColDef(s, i), this.applyColumnState(a, s);
      else {
        var l = o.getUniqueKey(s.colId, s.field);
        a = new Gt(s, i, l, t), this.context.createBean(a);
      }
      return a;
    }, e.prototype.applyColumnState = function(t, i) {
      var r = sa(i.flex);
      r !== void 0 && t.setFlex(r);
      var o = t.getFlex() <= 0;
      if (o) {
        var s = sa(i.width);
        if (s != null)
          t.setActualWidth(s);
        else {
          var a = t.getActualWidth();
          t.setActualWidth(a);
        }
      }
      i.sort !== void 0 && (i.sort == q.SORT_ASC || i.sort == q.SORT_DESC ? t.setSort(i.sort) : t.setSort(void 0));
      var l = sa(i.sortIndex);
      l !== void 0 && t.setSortIndex(l);
      var u = Iu(i.hide);
      u !== void 0 && t.setVisible(!u), i.pinned !== void 0 && t.setPinned(i.pinned);
    }, e.prototype.findExistingColumn = function(t, i) {
      var r = (i || []).find(function(o) {
        var s = o.getUserProvidedColDef();
        if (!s)
          return !1;
        var a = t.colId != null, l = t.field != null;
        return a ? o.getId() === t.colId : l ? s.field === t.field : s === t;
      });
      return i && r && qr(i, r), r || null;
    }, e.prototype.findExistingGroup = function(t, i) {
      var r = i.find(function(o) {
        var s = o.getColGroupDef();
        if (!s)
          return !1;
        var a = t.groupId != null;
        return a ? o.getId() === t.groupId : !1;
      });
      return r && qr(i, r), r || null;
    }, e.prototype.mergeColDefs = function(t) {
      var i = {}, r = this.gridOptionsWrapper.getDefaultColDef();
      aa(i, r, !1, !0);
      var o = t.type;
      return o || (o = r && r.type), o && this.assignColumnTypes(o, i), aa(i, t, !1, !0), i;
    }, e.prototype.assignColumnTypes = function(t, i) {
      var r = [];
      if (t instanceof Array) {
        var o = t.some(function(l) {
          return typeof l != "string";
        });
        o ? console.warn("AG Grid: if colDef.type is supplied an array it should be of type 'string[]'") : r = t;
      } else if (typeof t == "string")
        r = t.split(",");
      else {
        console.warn("AG Grid: colDef.type should be of type 'string' | 'string[]'");
        return;
      }
      var s = Object.assign({}, fj), a = this.gridOptionsWrapper.getColumnTypes() || {};
      pi(a, function(l, u) {
        l in s ? console.warn("AG Grid: the column type '" + l + "' is a default column type and cannot be overridden.") : s[l] = u;
      }), r.forEach(function(l) {
        var u = s[l.trim()];
        u ? aa(i, u, !1, !0) : console.warn("AG Grid: colDef.type '" + l + "' does not correspond to defined gridOptions.columnTypes");
      });
    }, e.prototype.checkForDeprecatedItems = function(t) {
      if (t) {
        var i = t;
        i.group !== void 0 && console.warn("AG Grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3"), i.headerGroup !== void 0 && console.warn("AG Grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3"), i.headerGroupShow !== void 0 && console.warn("AG Grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3"), i.suppressRowGroup !== void 0 && console.warn("AG Grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead"), i.suppressAggregation !== void 0 && console.warn("AG Grid: colDef.suppressAggregation is deprecated, please use colDef.type instead"), (i.suppressRowGroup || i.suppressAggregation) && console.warn("AG Grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead"), i.displayName && (console.warn("AG Grid: Found displayName " + i.displayName + ", please use headerName instead, displayName is deprecated."), i.headerName = i.displayName);
      }
    }, e.prototype.isColumnGroup = function(t) {
      return t.children !== void 0;
    }, KE([
      R("columnUtils")
    ], e.prototype, "columnUtils", void 0), KE([
      Cj(0, wo("loggerFactory"))
    ], e.prototype, "setBeans", null), e = KE([
      Ke("columnFactory")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var I = (
  /** @class */
  function() {
    function n() {
    }
    return n.EVENT_COLUMN_EVERYTHING_CHANGED = "columnEverythingChanged", n.EVENT_NEW_COLUMNS_LOADED = "newColumnsLoaded", n.EVENT_COLUMN_PIVOT_MODE_CHANGED = "columnPivotModeChanged", n.EVENT_COLUMN_ROW_GROUP_CHANGED = "columnRowGroupChanged", n.EVENT_EXPAND_COLLAPSE_ALL = "expandOrCollapseAll", n.EVENT_COLUMN_PIVOT_CHANGED = "columnPivotChanged", n.EVENT_GRID_COLUMNS_CHANGED = "gridColumnsChanged", n.EVENT_COLUMN_VALUE_CHANGED = "columnValueChanged", n.EVENT_COLUMN_MOVED = "columnMoved", n.EVENT_COLUMN_VISIBLE = "columnVisible", n.EVENT_COLUMN_PINNED = "columnPinned", n.EVENT_COLUMN_GROUP_OPENED = "columnGroupOpened", n.EVENT_COLUMN_RESIZED = "columnResized", n.EVENT_DISPLAYED_COLUMNS_CHANGED = "displayedColumnsChanged", n.EVENT_VIRTUAL_COLUMNS_CHANGED = "virtualColumnsChanged", n.EVENT_ASYNC_TRANSACTIONS_FLUSHED = "asyncTransactionsFlushed", n.EVENT_ROW_GROUP_OPENED = "rowGroupOpened", n.EVENT_ROW_DATA_CHANGED = "rowDataChanged", n.EVENT_ROW_DATA_UPDATED = "rowDataUpdated", n.EVENT_PINNED_ROW_DATA_CHANGED = "pinnedRowDataChanged", n.EVENT_RANGE_SELECTION_CHANGED = "rangeSelectionChanged", n.EVENT_CHART_CREATED = "chartCreated", n.EVENT_CHART_RANGE_SELECTION_CHANGED = "chartRangeSelectionChanged", n.EVENT_CHART_OPTIONS_CHANGED = "chartOptionsChanged", n.EVENT_CHART_DESTROYED = "chartDestroyed", n.EVENT_TOOL_PANEL_VISIBLE_CHANGED = "toolPanelVisibleChanged", n.EVENT_COLUMN_PANEL_ITEM_DRAG_START = "columnPanelItemDragStart", n.EVENT_COLUMN_PANEL_ITEM_DRAG_END = "columnPanelItemDragEnd", n.EVENT_MODEL_UPDATED = "modelUpdated", n.EVENT_PASTE_START = "pasteStart", n.EVENT_PASTE_END = "pasteEnd", n.EVENT_FILL_START = "fillStart", n.EVENT_FILL_END = "fillEnd", n.EVENT_CELL_CLICKED = "cellClicked", n.EVENT_CELL_DOUBLE_CLICKED = "cellDoubleClicked", n.EVENT_CELL_MOUSE_DOWN = "cellMouseDown", n.EVENT_CELL_CONTEXT_MENU = "cellContextMenu", n.EVENT_CELL_VALUE_CHANGED = "cellValueChanged", n.EVENT_CELL_EDIT_REQUEST = "cellEditRequest", n.EVENT_ROW_VALUE_CHANGED = "rowValueChanged", n.EVENT_CELL_FOCUSED = "cellFocused", n.EVENT_ROW_SELECTED = "rowSelected", n.EVENT_SELECTION_CHANGED = "selectionChanged", n.EVENT_CELL_KEY_DOWN = "cellKeyDown", n.EVENT_CELL_KEY_PRESS = "cellKeyPress", n.EVENT_CELL_MOUSE_OVER = "cellMouseOver", n.EVENT_CELL_MOUSE_OUT = "cellMouseOut", n.EVENT_FILTER_CHANGED = "filterChanged", n.EVENT_FILTER_MODIFIED = "filterModified", n.EVENT_FILTER_OPENED = "filterOpened", n.EVENT_SORT_CHANGED = "sortChanged", n.EVENT_VIRTUAL_ROW_REMOVED = "virtualRowRemoved", n.EVENT_ROW_CLICKED = "rowClicked", n.EVENT_ROW_DOUBLE_CLICKED = "rowDoubleClicked", n.EVENT_GRID_READY = "gridReady", n.EVENT_GRID_SIZE_CHANGED = "gridSizeChanged", n.EVENT_VIEWPORT_CHANGED = "viewportChanged", n.EVENT_SCROLLBAR_WIDTH_CHANGED = "scrollbarWidthChanged", n.EVENT_FIRST_DATA_RENDERED = "firstDataRendered", n.EVENT_DRAG_STARTED = "dragStarted", n.EVENT_DRAG_STOPPED = "dragStopped", n.EVENT_CHECKBOX_CHANGED = "checkboxChanged", n.EVENT_ROW_EDITING_STARTED = "rowEditingStarted", n.EVENT_ROW_EDITING_STOPPED = "rowEditingStopped", n.EVENT_CELL_EDITING_STARTED = "cellEditingStarted", n.EVENT_CELL_EDITING_STOPPED = "cellEditingStopped", n.EVENT_BODY_SCROLL = "bodyScroll", n.EVENT_BODY_SCROLL_END = "bodyScrollEnd", n.EVENT_HEIGHT_SCALE_CHANGED = "heightScaleChanged", n.EVENT_PAGINATION_CHANGED = "paginationChanged", n.EVENT_COMPONENT_STATE_CHANGED = "componentStateChanged", n.EVENT_BODY_HEIGHT_CHANGED = "bodyHeightChanged", n.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED = "displayedColumnsWidthChanged", n.EVENT_SCROLL_VISIBILITY_CHANGED = "scrollVisibilityChanged", n.EVENT_COLUMN_HOVER_CHANGED = "columnHoverChanged", n.EVENT_FLASH_CELLS = "flashCells", n.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED = "paginationPixelOffsetChanged", n.EVENT_DISPLAYED_ROWS_CHANGED = "displayedRowsChanged", n.EVENT_LEFT_PINNED_WIDTH_CHANGED = "leftPinnedWidthChanged", n.EVENT_RIGHT_PINNED_WIDTH_CHANGED = "rightPinnedWidthChanged", n.EVENT_ROW_CONTAINER_HEIGHT_CHANGED = "rowContainerHeightChanged", n.EVENT_ROW_DRAG_ENTER = "rowDragEnter", n.EVENT_ROW_DRAG_MOVE = "rowDragMove", n.EVENT_ROW_DRAG_LEAVE = "rowDragLeave", n.EVENT_ROW_DRAG_END = "rowDragEnd", n.EVENT_POPUP_TO_FRONT = "popupToFront", n.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST = "columnRowGroupChangeRequest", n.EVENT_COLUMN_PIVOT_CHANGE_REQUEST = "columnPivotChangeRequest", n.EVENT_COLUMN_VALUE_CHANGE_REQUEST = "columnValueChangeRequest", n.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST = "columnAggFuncChangeRequest", n.EVENT_KEYBOARD_FOCUS = "keyboardFocus", n.EVENT_MOUSE_FOCUS = "mouseFocus", n.EVENT_STORE_UPDATED = "storeUpdated", n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var JV = (
  /** @class */
  function() {
    function n() {
      this.existingIds = {};
    }
    return n.prototype.getInstanceIdForKey = function(e) {
      var t = this.existingIds[e], i;
      return typeof t != "number" ? i = 0 : i = t + 1, this.existingIds[e] = i, i;
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var yj = /[&<>"']/g, wj = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function bj(n) {
  var e = String.fromCharCode;
  function t(h) {
    var d = [];
    if (!h)
      return [];
    for (var f = h.length, p = 0, g, _; p < f; )
      g = h.charCodeAt(p++), g >= 55296 && g <= 56319 && p < f ? (_ = h.charCodeAt(p++), (_ & 64512) == 56320 ? d.push(((g & 1023) << 10) + (_ & 1023) + 65536) : (d.push(g), p--)) : d.push(g);
    return d;
  }
  function i(h) {
    if (h >= 55296 && h <= 57343)
      throw Error("Lone surrogate U+" + h.toString(16).toUpperCase() + " is not a scalar value");
  }
  function r(h, d) {
    return e(h >> d & 63 | 128);
  }
  function o(h) {
    if (h >= 0 && h <= 31 && h !== 10) {
      var d = h.toString(16).toUpperCase(), f = d.padStart(4, "0");
      return "_x" + f + "_";
    }
    if (!(h & 4294967168))
      return e(h);
    var p = "";
    return h & 4294965248 ? h & 4294901760 ? h & 4292870144 || (p = e(h >> 18 & 7 | 240), p += r(h, 12), p += r(h, 6)) : (i(h), p = e(h >> 12 & 15 | 224), p += r(h, 6)) : p = e(h >> 6 & 31 | 192), p += e(h & 63 | 128), p;
  }
  for (var s = t(n), a = s.length, l = -1, u, c = ""; ++l < a; )
    u = s[l], c += o(u);
  return c;
}
function eB(n) {
  return n == null ? null : n.replace(/([A-Z])/g, function(e) {
    return "-" + e[0].toLowerCase();
  });
}
function tB(n) {
  return n == null ? null : n.replace(/-([a-z])/g, function(e) {
    return e[1].toUpperCase();
  });
}
function b1(n) {
  return n[0].toUpperCase() + n.substr(1).toLowerCase();
}
function Gl(n) {
  return n == null ? null : n.toString().toString().replace(yj, function(e) {
    return wj[e];
  });
}
function YO(n) {
  if (!n || n == null)
    return null;
  var e = /([A-Z])([A-Z])([a-z])|([a-z])([A-Z])/g, t = n.replace(e, "$1$4 $2$3$5").replace(".", " ").split(" ");
  return t.map(function(i) {
    return i.substring(0, 1).toUpperCase() + (i.length > 1 ? i.substring(1, i.length) : "");
  }).join(" ");
}
const Sj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  camelCaseToHumanText: YO,
  camelCaseToHyphen: eB,
  capitalise: b1,
  escapeString: Gl,
  hyphenToCamelCase: tB,
  utf8_encode: bj
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function Wc(n) {
  var e = /* @__PURE__ */ new Map();
  return n.forEach(function(t) {
    return e.set(t[0], t[1]);
  }), e;
}
function Ej(n, e) {
  var t = /* @__PURE__ */ new Map();
  return n.forEach(function(i) {
    return t.set(e(i), i);
  }), t;
}
function Lj(n) {
  var e = [];
  return n.forEach(function(t, i) {
    return e.push(i);
  }), e;
}
const Dj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  convertToMap: Wc,
  keys: Lj,
  mapById: Ej
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Rj = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), nr = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Tj = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, ZA = globalThis && globalThis.__values || function(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], i = 0;
  if (t)
    return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function() {
        return n && i >= n.length && (n = void 0), { value: n && n[i++], done: !n };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Oj = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, QA = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(Oj(arguments[e]));
  return n;
}, iB = (
  /** @class */
  function(n) {
    Rj(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.primaryHeaderRowCount = 0, t.secondaryHeaderRowCount = 0, t.secondaryColumnsPresent = !1, t.gridHeaderRowCount = 0, t.displayedColumnsLeft = [], t.displayedColumnsRight = [], t.displayedColumnsCenter = [], t.displayedColumns = [], t.displayedColumnsAndGroupsMap = {}, t.viewportColumns = [], t.viewportColumnsCenter = [], t.autoHeightActiveAtLeastOnce = !1, t.rowGroupColumns = [], t.valueColumns = [], t.pivotColumns = [], t.ready = !1, t.autoGroupsNeedBuilding = !1, t.forceRecreateAutoGroups = !1, t.pivotMode = !1, t.bodyWidth = 0, t.leftWidth = 0, t.rightWidth = 0, t.bodyWidthDirty = !0, t.colDefVersion = 0, t.flexColsCalculatedAtLestOnce = !1, t;
    }
    return e.prototype.init = function() {
      var t = this;
      this.suppressColumnVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation();
      var i = this.gridOptionsWrapper.isPivotMode();
      this.isPivotSettingAllowed(i) && (this.pivotMode = i), this.usingTreeData = this.gridOptionsWrapper.isTreeData(), this.addManagedListener(this.gridOptionsWrapper, "autoGroupColumnDef", function() {
        return t.onAutoGroupColumnDefChanged();
      }), this.addManagedListener(this.gridOptionsWrapper, "defaultColDef", function() {
        return t.onDefaultColDefChanged();
      });
    }, e.prototype.onAutoGroupColumnDefChanged = function() {
      this.autoGroupsNeedBuilding = !0, this.forceRecreateAutoGroups = !0, this.updateGridColumns(), this.updateDisplayedColumns("gridOptionsChanged");
    }, e.prototype.onDefaultColDefChanged = function() {
      this.colDefVersion++, this.forceRecreateAutoGroups = !0, this.createColumnsFromColumnDefs(!0);
    }, e.prototype.getColDefVersion = function() {
      return this.colDefVersion;
    }, e.prototype.setColumnDefs = function(t, i) {
      i === void 0 && (i = "api");
      var r = !!this.columnDefs;
      this.colDefVersion++, this.columnDefs = t, this.createColumnsFromColumnDefs(r, i);
    }, e.prototype.createColumnsFromColumnDefs = function(t, i) {
      var r = this;
      i === void 0 && (i = "api");
      var o = t ? this.compareColumnStatesAndRaiseEvents(i) : void 0;
      this.valueCache.expire(), this.autoGroupsNeedBuilding = !0;
      var s = this.primaryColumns, a = this.primaryColumnTree, l = this.columnFactory.createColumnTree(this.columnDefs, !0, a);
      this.primaryColumnTree = l.columnTree, this.primaryHeaderRowCount = l.treeDept + 1, this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree), this.primaryColumnsMap = {}, this.primaryColumns.forEach(function(h) {
        return r.primaryColumnsMap[h.getId()] = h;
      }), this.extractRowGroupColumns(i, s), this.extractPivotColumns(i, s), this.extractValueColumns(i, s), this.ready = !0;
      var u = this.gridColsArePrimary === void 0, c = this.gridColsArePrimary || u;
      c && (this.updateGridColumns(), t && !this.gridOptionsWrapper.isMaintainColumnOrder() && this.orderGridColumnsLikePrimary(), this.updateDisplayedColumns(i), this.checkViewportColumns()), this.dispatchEverythingChanged(i), o && o(), this.dispatchNewColumnsLoaded();
    }, e.prototype.dispatchNewColumnsLoaded = function() {
      var t = {
        type: I.EVENT_NEW_COLUMNS_LOADED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(t);
    }, e.prototype.dispatchEverythingChanged = function(t) {
      t === void 0 && (t = "api");
      var i = {
        type: I.EVENT_COLUMN_EVERYTHING_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi,
        source: t
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.orderGridColumnsLikePrimary = function() {
      var t = this, i = this.primaryColumns;
      i && this.gridColumns.sort(function(r, o) {
        var s = i.indexOf(r), a = i.indexOf(o), l = s >= 0, u = a >= 0;
        if (l && u)
          return s - a;
        if (l)
          return 1;
        if (u)
          return -1;
        var c = t.gridColumns.indexOf(r), h = t.gridColumns.indexOf(o);
        return c - h;
      });
    }, e.prototype.getAllDisplayedAutoHeightCols = function() {
      return this.displayedAutoHeightCols;
    }, e.prototype.setViewport = function() {
      this.gridOptionsWrapper.isEnableRtl() ? (this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth, this.viewportRight = this.bodyWidth - this.scrollPosition) : (this.viewportLeft = this.scrollPosition, this.viewportRight = this.scrollWidth + this.scrollPosition);
    }, e.prototype.getDisplayedColumnsStartingAt = function(t) {
      for (var i = t, r = []; i != null; )
        r.push(i), i = this.getDisplayedColAfter(i);
      return r;
    }, e.prototype.checkViewportColumns = function() {
      if (this.displayedColumnsCenter != null) {
        var t = this.viewportColumns.map(function(o) {
          return o.getId();
        }).join("#");
        this.extractViewport();
        var i = this.viewportColumns.map(function(o) {
          return o.getId();
        }).join("#");
        if (t !== i) {
          var r = {
            type: I.EVENT_VIRTUAL_COLUMNS_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
          };
          this.eventService.dispatchEvent(r);
        }
      }
    }, e.prototype.setViewportPosition = function(t, i) {
      (t !== this.scrollWidth || i !== this.scrollPosition || this.bodyWidthDirty) && (this.scrollWidth = t, this.scrollPosition = i, this.bodyWidthDirty = !0, this.setViewport(), this.ready && this.checkViewportColumns());
    }, e.prototype.isPivotMode = function() {
      return this.pivotMode;
    }, e.prototype.isPivotSettingAllowed = function(t) {
      return t && this.gridOptionsWrapper.isTreeData() ? (console.warn("AG Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'"), !1) : !0;
    }, e.prototype.setPivotMode = function(t, i) {
      if (i === void 0 && (i = "api"), !(t === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode))) {
        this.pivotMode = t, this.autoGroupsNeedBuilding = !0, this.updateGridColumns(), this.updateDisplayedColumns(i);
        var r = {
          type: I.EVENT_COLUMN_PIVOT_MODE_CHANGED,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(r);
      }
    }, e.prototype.getSecondaryPivotColumn = function(t, i) {
      if (!this.secondaryColumnsPresent || !this.secondaryColumns)
        return null;
      var r = this.getPrimaryColumn(i), o = null;
      return this.secondaryColumns.forEach(function(s) {
        var a = s.getColDef().pivotKeys, l = s.getColDef().pivotValueColumn, u = ud(a, t), c = l === r;
        u && c && (o = s);
      }), o;
    }, e.prototype.setBeans = function(t) {
      this.logger = t.create("columnModel");
    }, e.prototype.setFirstRightAndLastLeftPinned = function(t) {
      var i, r;
      this.gridOptionsWrapper.isEnableRtl() ? (i = this.displayedColumnsLeft ? this.displayedColumnsLeft[0] : null, r = this.displayedColumnsRight ? Di(this.displayedColumnsRight) : null) : (i = this.displayedColumnsLeft ? Di(this.displayedColumnsLeft) : null, r = this.displayedColumnsRight ? this.displayedColumnsRight[0] : null), this.gridColumns.forEach(function(o) {
        o.setLastLeftPinned(o === i, t), o.setFirstRightPinned(o === r, t);
      });
    }, e.prototype.autoSizeColumns = function(t) {
      var i = this, r = t.columns, o = t.skipHeader, s = t.skipHeaderGroups, a = t.stopAtGroup, l = t.source, u = l === void 0 ? "api" : l;
      this.animationFrameService.flushAllFrames();
      for (var c = [], h = -1, d = o ?? this.gridOptionsWrapper.isSkipHeaderOnAutoSize(), f = s ?? d; h !== 0; )
        h = 0, this.actionOnGridColumns(r, function(p) {
          if (c.indexOf(p) >= 0)
            return !1;
          var g = i.autoWidthCalculator.getPreferredWidthForColumn(p, d);
          if (g > 0) {
            var _ = i.normaliseColumnWidth(p, g);
            p.setActualWidth(_, u), c.push(p), h++;
          }
          return !0;
        }, u);
      f || this.autoSizeColumnGroupsByColumns(r, a), this.fireColumnResizedEvent(c, !0, "autosizeColumns");
    }, e.prototype.fireColumnResizedEvent = function(t, i, r, o) {
      if (o === void 0 && (o = null), t && t.length) {
        var s = {
          type: I.EVENT_COLUMN_RESIZED,
          columns: t,
          column: t.length === 1 ? t[0] : null,
          flexColumns: o,
          finished: i,
          api: this.gridApi,
          columnApi: this.columnApi,
          source: r
        };
        this.eventService.dispatchEvent(s);
      }
    }, e.prototype.autoSizeColumn = function(t, i, r) {
      r === void 0 && (r = "api"), t && this.autoSizeColumns({ columns: [t], skipHeader: i, skipHeaderGroups: !0, source: r });
    }, e.prototype.autoSizeColumnGroupsByColumns = function(t, i) {
      var r, o, s, a, l = /* @__PURE__ */ new Set(), u = this.getGridColumns(t);
      u.forEach(function(v) {
        for (var C = v.getParent(); C && C != i; )
          C.isPadding() || l.add(C), C = C.getParent();
      });
      var c, h = [];
      try {
        for (var d = ZA(l), f = d.next(); !f.done; f = d.next()) {
          var p = f.value;
          try {
            for (var g = (s = void 0, ZA(this.ctrlsService.getHeaderRowContainerCtrls())), _ = g.next(); !_.done; _ = g.next()) {
              var m = _.value;
              if (c = m.getHeaderCtrlForColumn(p), c)
                break;
            }
          } catch (v) {
            s = { error: v };
          } finally {
            try {
              _ && !_.done && (a = g.return) && a.call(g);
            } finally {
              if (s)
                throw s.error;
            }
          }
          c && c.resizeLeafColumnsToFit();
        }
      } catch (v) {
        r = { error: v };
      } finally {
        try {
          f && !f.done && (o = d.return) && o.call(d);
        } finally {
          if (r)
            throw r.error;
        }
      }
      return h;
    }, e.prototype.autoSizeAllColumns = function(t, i) {
      i === void 0 && (i = "api");
      var r = this.getAllDisplayedColumns();
      this.autoSizeColumns({ columns: r, skipHeader: t, source: i });
    }, e.prototype.getColumnsFromTree = function(t) {
      var i = [], r = function(o) {
        for (var s = 0; s < o.length; s++) {
          var a = o[s];
          a instanceof Gt ? i.push(a) : a instanceof fn && r(a.getChildren());
        }
      };
      return r(t), i;
    }, e.prototype.getAllDisplayedTrees = function() {
      return this.displayedTreeLeft && this.displayedTreeRight && this.displayedTreeCentre ? this.displayedTreeLeft.concat(this.displayedTreeCentre).concat(this.displayedTreeRight) : null;
    }, e.prototype.getPrimaryColumnTree = function() {
      return this.primaryColumnTree;
    }, e.prototype.getHeaderRowCount = function() {
      return this.gridHeaderRowCount;
    }, e.prototype.getDisplayedTreeLeft = function() {
      return this.displayedTreeLeft;
    }, e.prototype.getDisplayedTreeRight = function() {
      return this.displayedTreeRight;
    }, e.prototype.getDisplayedTreeCentre = function() {
      return this.displayedTreeCentre;
    }, e.prototype.isColumnDisplayed = function(t) {
      return this.getAllDisplayedColumns().indexOf(t) >= 0;
    }, e.prototype.getAllDisplayedColumns = function() {
      return this.displayedColumns;
    }, e.prototype.getViewportColumns = function() {
      return this.viewportColumns;
    }, e.prototype.getDisplayedLeftColumnsForRow = function(t) {
      return this.colSpanActive ? this.getDisplayedColumnsForRow(t, this.displayedColumnsLeft) : this.displayedColumnsLeft;
    }, e.prototype.getDisplayedRightColumnsForRow = function(t) {
      return this.colSpanActive ? this.getDisplayedColumnsForRow(t, this.displayedColumnsRight) : this.displayedColumnsRight;
    }, e.prototype.getDisplayedColumnsForRow = function(t, i, r, o) {
      for (var s = [], a = null, l = function(h) {
        var d = i[h], f = i.length - h, p = Math.min(d.getColSpan(t), f), g = [d];
        if (p > 1) {
          for (var _ = p - 1, m = 1; m <= _; m++)
            g.push(i[h + m]);
          h += _;
        }
        var v;
        if (r ? (v = !1, g.forEach(function(y) {
          r(y) && (v = !0);
        })) : v = !0, v) {
          if (s.length === 0 && a) {
            var C = o ? o(d) : !1;
            C && s.push(a);
          }
          s.push(d);
        }
        a = d, u = h;
      }, u, c = 0; c < i.length; c++)
        l(c), c = u;
      return s;
    }, e.prototype.getViewportCenterColumnsForRow = function(t) {
      var i = this;
      if (!this.colSpanActive)
        return this.viewportColumnsCenter;
      var r = function(s) {
        var a = s.getLeft();
        return de(a) && a > i.viewportLeft;
      }, o = this.suppressColumnVirtualisation ? null : this.isColumnInViewport.bind(this);
      return this.getDisplayedColumnsForRow(t, this.displayedColumnsCenter, o, r);
    }, e.prototype.getAriaColumnIndex = function(t) {
      return this.getAllGridColumns().indexOf(t) + 1;
    }, e.prototype.isColumnInViewport = function(t) {
      if (t.isAutoHeight())
        return !0;
      var i = t.getLeft() || 0, r = i + t.getActualWidth(), o = this.viewportLeft - 200, s = this.viewportRight + 200, a = i < o && r < o, l = i > s && r > s;
      return !a && !l;
    }, e.prototype.getDisplayedColumnsLeftWidth = function() {
      return this.getWidthOfColsInList(this.displayedColumnsLeft);
    }, e.prototype.getDisplayedColumnsRightWidth = function() {
      return this.getWidthOfColsInList(this.displayedColumnsRight);
    }, e.prototype.updatePrimaryColumnList = function(t, i, r, o, s, a) {
      var l = this;
      if (a === void 0 && (a = "api"), !(!t || ds(t))) {
        var u = !1;
        if (t.forEach(function(h) {
          var d = l.getPrimaryColumn(h);
          if (d) {
            if (r) {
              if (i.indexOf(d) >= 0)
                return;
              i.push(d);
            } else {
              if (i.indexOf(d) < 0)
                return;
              qr(i, d);
            }
            o(d), u = !0;
          }
        }), !!u) {
          this.autoGroupsNeedBuilding && this.updateGridColumns(), this.updateDisplayedColumns(a);
          var c = {
            type: s,
            columns: i,
            column: i.length === 1 ? i[0] : null,
            api: this.gridApi,
            columnApi: this.columnApi,
            source: a
          };
          this.eventService.dispatchEvent(c);
        }
      }
    }, e.prototype.setRowGroupColumns = function(t, i) {
      i === void 0 && (i = "api"), this.autoGroupsNeedBuilding = !0, this.setPrimaryColumnList(t, this.rowGroupColumns, I.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this), i);
    }, e.prototype.setRowGroupActive = function(t, i, r) {
      t !== i.isRowGroupActive() && (i.setRowGroupActive(t, r), !t && !this.gridOptionsWrapper.isSuppressMakeColumnVisibleAfterUnGroup() && i.setVisible(!0, r));
    }, e.prototype.addRowGroupColumn = function(t, i) {
      i === void 0 && (i = "api"), t && this.addRowGroupColumns([t], i);
    }, e.prototype.addRowGroupColumns = function(t, i) {
      i === void 0 && (i = "api"), this.autoGroupsNeedBuilding = !0, this.updatePrimaryColumnList(t, this.rowGroupColumns, !0, this.setRowGroupActive.bind(this, !0), I.EVENT_COLUMN_ROW_GROUP_CHANGED, i);
    }, e.prototype.removeRowGroupColumns = function(t, i) {
      i === void 0 && (i = "api"), this.autoGroupsNeedBuilding = !0, this.updatePrimaryColumnList(t, this.rowGroupColumns, !1, this.setRowGroupActive.bind(this, !1), I.EVENT_COLUMN_ROW_GROUP_CHANGED, i);
    }, e.prototype.removeRowGroupColumn = function(t, i) {
      i === void 0 && (i = "api"), t && this.removeRowGroupColumns([t], i);
    }, e.prototype.addPivotColumns = function(t, i) {
      i === void 0 && (i = "api"), this.updatePrimaryColumnList(t, this.pivotColumns, !0, function(r) {
        return r.setPivotActive(!0, i);
      }, I.EVENT_COLUMN_PIVOT_CHANGED, i);
    }, e.prototype.setPivotColumns = function(t, i) {
      i === void 0 && (i = "api"), this.setPrimaryColumnList(t, this.pivotColumns, I.EVENT_COLUMN_PIVOT_CHANGED, function(r, o) {
        o.setPivotActive(r, i);
      }, i);
    }, e.prototype.addPivotColumn = function(t, i) {
      i === void 0 && (i = "api"), this.addPivotColumns([t], i);
    }, e.prototype.removePivotColumns = function(t, i) {
      i === void 0 && (i = "api"), this.updatePrimaryColumnList(t, this.pivotColumns, !1, function(r) {
        return r.setPivotActive(!1, i);
      }, I.EVENT_COLUMN_PIVOT_CHANGED, i);
    }, e.prototype.removePivotColumn = function(t, i) {
      i === void 0 && (i = "api"), this.removePivotColumns([t], i);
    }, e.prototype.setPrimaryColumnList = function(t, i, r, o, s) {
      var a = this;
      i.length = 0, de(t) && t.forEach(function(l) {
        var u = a.getPrimaryColumn(l);
        u && i.push(u);
      }), (this.primaryColumns || []).forEach(function(l) {
        var u = i.indexOf(l) >= 0;
        o(u, l);
      }), this.autoGroupsNeedBuilding && this.updateGridColumns(), this.updateDisplayedColumns(s), this.fireColumnEvent(r, i, s);
    }, e.prototype.setValueColumns = function(t, i) {
      i === void 0 && (i = "api"), this.setPrimaryColumnList(t, this.valueColumns, I.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this), i);
    }, e.prototype.setValueActive = function(t, i, r) {
      if (t !== i.isValueActive() && (i.setValueActive(t, r), t && !i.getAggFunc())) {
        var o = this.aggFuncService.getDefaultAggFunc(i);
        i.setAggFunc(o);
      }
    }, e.prototype.addValueColumns = function(t, i) {
      i === void 0 && (i = "api"), this.updatePrimaryColumnList(t, this.valueColumns, !0, this.setValueActive.bind(this, !0), I.EVENT_COLUMN_VALUE_CHANGED, i);
    }, e.prototype.addValueColumn = function(t, i) {
      i === void 0 && (i = "api"), t && this.addValueColumns([t], i);
    }, e.prototype.removeValueColumn = function(t, i) {
      i === void 0 && (i = "api"), this.removeValueColumns([t], i);
    }, e.prototype.removeValueColumns = function(t, i) {
      i === void 0 && (i = "api"), this.updatePrimaryColumnList(t, this.valueColumns, !1, this.setValueActive.bind(this, !1), I.EVENT_COLUMN_VALUE_CHANGED, i);
    }, e.prototype.normaliseColumnWidth = function(t, i) {
      var r = t.getMinWidth();
      de(r) && i < r && (i = r);
      var o = t.getMaxWidth();
      return de(o) && t.isGreaterThanMax(i) && (i = o), i;
    }, e.prototype.getPrimaryOrGridColumn = function(t) {
      var i = this.getPrimaryColumn(t);
      return i || this.getGridColumn(t);
    }, e.prototype.setColumnWidths = function(t, i, r, o) {
      var s = this;
      o === void 0 && (o = "api");
      var a = [];
      t.forEach(function(l) {
        var u = s.getPrimaryOrGridColumn(l.key);
        if (u) {
          a.push({
            width: l.newWidth,
            ratios: [1],
            columns: [u]
          });
          var c = s.gridOptionsWrapper.getColResizeDefault() === "shift";
          if (c && (i = !i), i) {
            var h = s.getDisplayedColAfter(u);
            if (!h)
              return;
            var d = u.getActualWidth() - l.newWidth, f = h.getActualWidth() + d;
            a.push({
              width: f,
              ratios: [1],
              columns: [h]
            });
          }
        }
      }), a.length !== 0 && this.resizeColumnSets({
        resizeSets: a,
        finished: r,
        source: o
      });
    }, e.prototype.checkMinAndMaxWidthsForSet = function(t) {
      var i = t.columns, r = t.width, o = 0, s = 0, a = !0;
      i.forEach(function(c) {
        var h = c.getMinWidth();
        o += h || 0;
        var d = c.getMaxWidth();
        de(d) && d > 0 ? s += d : a = !1;
      });
      var l = r >= o, u = !a || r <= s;
      return l && u;
    }, e.prototype.resizeColumnSets = function(t) {
      var i = this, r = t.resizeSets, o = t.finished, s = t.source, a = !r || r.every(function(p) {
        return i.checkMinAndMaxWidthsForSet(p);
      });
      if (!a) {
        if (o) {
          var l = r && r.length > 0 ? r[0].columns : null;
          this.fireColumnResizedEvent(l, o, s);
        }
        return;
      }
      var u = [], c = [];
      r.forEach(function(p) {
        var g = p.width, _ = p.columns, m = p.ratios, v = {}, C = {};
        _.forEach(function(E) {
          return c.push(E);
        });
        for (var y = !0, b = 0, L = function() {
          if (b++, b > 1e3)
            return console.error("AG Grid: infinite loop in resizeColumnSets"), "break";
          y = !1;
          var E = [], D = 0, O = g;
          _.forEach(function(A, P) {
            var G = C[A.getId()];
            if (G)
              O -= v[A.getId()];
            else {
              E.push(A);
              var U = m[P];
              D += U;
            }
          });
          var T = 1 / D;
          E.forEach(function(A, P) {
            var G = P === E.length - 1, U;
            G ? U = O : (U = Math.round(m[P] * g * T), O -= U);
            var $ = A.getMinWidth(), k = A.getMaxWidth();
            de($) && U < $ ? (U = $, C[A.getId()] = !0, y = !0) : de(k) && k > 0 && U > k && (U = k, C[A.getId()] = !0, y = !0), v[A.getId()] = U;
          });
        }; y; ) {
          var S = L();
          if (S === "break")
            break;
        }
        _.forEach(function(E) {
          var D = v[E.getId()], O = E.getActualWidth();
          O !== D && (E.setActualWidth(D, s), u.push(E));
        });
      });
      var h = u.length > 0, d = this.refreshFlexedColumns({ resizingCols: c, skipSetLeft: !0 });
      h && (this.setLeftValues(s), this.updateBodyWidths(), this.checkViewportColumns());
      var f = c.concat(d);
      (h || o) && this.fireColumnResizedEvent(f, o, s, d);
    }, e.prototype.setColumnAggFunc = function(t, i, r) {
      if (r === void 0 && (r = "api"), !!t) {
        var o = this.getPrimaryColumn(t);
        o && (o.setAggFunc(i), this.fireColumnEvent(I.EVENT_COLUMN_VALUE_CHANGED, [o], r));
      }
    }, e.prototype.fireColumnEvent = function(t, i, r) {
      var o = {
        type: t,
        columns: i,
        column: i && i.length == 1 ? i[0] : null,
        api: this.gridApi,
        columnApi: this.columnApi,
        source: r
      };
      this.eventService.dispatchEvent(o);
    }, e.prototype.moveRowGroupColumn = function(t, i, r) {
      r === void 0 && (r = "api");
      var o = this.rowGroupColumns[t];
      this.rowGroupColumns.splice(t, 1), this.rowGroupColumns.splice(i, 0, o);
      var s = {
        type: I.EVENT_COLUMN_ROW_GROUP_CHANGED,
        columns: this.rowGroupColumns,
        column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,
        api: this.gridApi,
        columnApi: this.columnApi,
        source: r
      };
      this.eventService.dispatchEvent(s);
    }, e.prototype.moveColumns = function(t, i, r) {
      if (r === void 0 && (r = "api"), this.columnAnimationService.start(), i > this.gridColumns.length - t.length) {
        console.warn("AG Grid: tried to insert columns in invalid location, toIndex = " + i), console.warn("AG Grid: remember that you should not count the moving columns when calculating the new index");
        return;
      }
      var o = this.getGridColumns(t), s = !this.doesMovePassRules(o, i);
      if (!s) {
        y1(this.gridColumns, o, i), this.updateDisplayedColumns(r);
        var a = {
          type: I.EVENT_COLUMN_MOVED,
          columns: o,
          column: o.length === 1 ? o[0] : null,
          toIndex: i,
          api: this.gridApi,
          columnApi: this.columnApi,
          source: r
        };
        this.eventService.dispatchEvent(a), this.columnAnimationService.finish();
      }
    }, e.prototype.doesMovePassRules = function(t, i) {
      var r = this.gridColumns.slice();
      return y1(r, t, i), !(!this.doesMovePassMarryChildren(r) || !this.doesMovePassLockedPositions(r));
    }, e.prototype.sortColumnsLikeGridColumns = function(t) {
      var i = this;
      if (!(!t || t.length <= 1)) {
        var r = t.filter(function(o) {
          return i.gridColumns.indexOf(o) < 0;
        }).length > 0;
        r || t.sort(function(o, s) {
          var a = i.gridColumns.indexOf(o), l = i.gridColumns.indexOf(s);
          return a - l;
        });
      }
    }, e.prototype.doesMovePassLockedPositions = function(t) {
      var i = !1, r = !0;
      return t.forEach(function(o) {
        o.getColDef().lockPosition ? i && (r = !1) : i = !0;
      }), r;
    }, e.prototype.doesMovePassMarryChildren = function(t) {
      var i = !0;
      return this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function(r) {
        if (r instanceof fn) {
          var o = r, s = o.getColGroupDef(), a = s && s.marryChildren;
          if (a) {
            var l = [];
            o.getLeafColumns().forEach(function(f) {
              var p = t.indexOf(f);
              l.push(p);
            });
            var u = Math.max.apply(Math, l), c = Math.min.apply(Math, l), h = u - c, d = o.getLeafColumns().length - 1;
            h > d && (i = !1);
          }
        }
      }), i;
    }, e.prototype.moveColumn = function(t, i, r) {
      r === void 0 && (r = "api"), this.moveColumns([t], i, r);
    }, e.prototype.moveColumnByIndex = function(t, i, r) {
      r === void 0 && (r = "api");
      var o = this.gridColumns[t];
      this.moveColumn(o, i, r);
    }, e.prototype.getColumnDefs = function() {
      var t = this;
      if (this.primaryColumns) {
        var i = this.primaryColumns.slice();
        return this.gridColsArePrimary ? i.sort(function(r, o) {
          return t.gridColumns.indexOf(r) - t.gridColumns.indexOf(o);
        }) : this.lastPrimaryOrder && i.sort(function(r, o) {
          return t.lastPrimaryOrder.indexOf(r) - t.lastPrimaryOrder.indexOf(o);
        }), this.columnDefFactory.buildColumnDefs(i, this.rowGroupColumns, this.pivotColumns);
      }
    }, e.prototype.getBodyContainerWidth = function() {
      return this.bodyWidth;
    }, e.prototype.getContainerWidth = function(t) {
      switch (t) {
        case q.PINNED_LEFT:
          return this.leftWidth;
        case q.PINNED_RIGHT:
          return this.rightWidth;
        default:
          return this.bodyWidth;
      }
    }, e.prototype.updateBodyWidths = function() {
      var t = this.getWidthOfColsInList(this.displayedColumnsCenter), i = this.getWidthOfColsInList(this.displayedColumnsLeft), r = this.getWidthOfColsInList(this.displayedColumnsRight);
      this.bodyWidthDirty = this.bodyWidth !== t;
      var o = this.bodyWidth !== t || this.leftWidth !== i || this.rightWidth !== r;
      if (o) {
        this.bodyWidth = t, this.leftWidth = i, this.rightWidth = r;
        var s = {
          type: I.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(s);
      }
    }, e.prototype.getValueColumns = function() {
      return this.valueColumns ? this.valueColumns : [];
    }, e.prototype.getPivotColumns = function() {
      return this.pivotColumns ? this.pivotColumns : [];
    }, e.prototype.isPivotActive = function() {
      return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;
    }, e.prototype.getRowGroupColumns = function() {
      return this.rowGroupColumns ? this.rowGroupColumns : [];
    }, e.prototype.getDisplayedCenterColumns = function() {
      return this.displayedColumnsCenter;
    }, e.prototype.getDisplayedLeftColumns = function() {
      return this.displayedColumnsLeft;
    }, e.prototype.getDisplayedRightColumns = function() {
      return this.displayedColumnsRight;
    }, e.prototype.getDisplayedColumns = function(t) {
      switch (t) {
        case q.PINNED_LEFT:
          return this.getDisplayedLeftColumns();
        case q.PINNED_RIGHT:
          return this.getDisplayedRightColumns();
        default:
          return this.getDisplayedCenterColumns();
      }
    }, e.prototype.getAllPrimaryColumns = function() {
      return this.primaryColumns ? this.primaryColumns.slice() : null;
    }, e.prototype.getSecondaryColumns = function() {
      return this.secondaryColumns ? this.secondaryColumns.slice() : null;
    }, e.prototype.getAllColumnsForQuickFilter = function() {
      return this.columnsForQuickFilter;
    }, e.prototype.getAllGridColumns = function() {
      return this.gridColumns;
    }, e.prototype.isEmpty = function() {
      return ds(this.gridColumns);
    }, e.prototype.isRowGroupEmpty = function() {
      return ds(this.rowGroupColumns);
    }, e.prototype.setColumnVisible = function(t, i, r) {
      r === void 0 && (r = "api"), this.setColumnsVisible([t], i, r);
    }, e.prototype.setColumnsVisible = function(t, i, r) {
      var o = this;
      i === void 0 && (i = !1), r === void 0 && (r = "api"), this.columnAnimationService.start(), this.actionOnGridColumns(t, function(s) {
        return s.isVisible() !== i ? (s.setVisible(i, r), !0) : !1;
      }, r, function() {
        var s = {
          type: I.EVENT_COLUMN_VISIBLE,
          visible: i,
          column: null,
          columns: null,
          api: o.gridApi,
          columnApi: o.columnApi,
          source: r
        };
        return s;
      }), this.columnAnimationService.finish();
    }, e.prototype.setColumnPinned = function(t, i, r) {
      r === void 0 && (r = "api"), t && this.setColumnsPinned([t], i, r);
    }, e.prototype.setColumnsPinned = function(t, i, r) {
      var o = this;
      if (r === void 0 && (r = "api"), this.gridOptionsWrapper.getDomLayout() === "print") {
        console.warn("Changing the column pinning status is not allowed with domLayout='print'");
        return;
      }
      this.columnAnimationService.start();
      var s;
      i === !0 || i === q.PINNED_LEFT ? s = q.PINNED_LEFT : i === q.PINNED_RIGHT ? s = q.PINNED_RIGHT : s = null, this.actionOnGridColumns(t, function(a) {
        return a.getPinned() !== s ? (a.setPinned(s), !0) : !1;
      }, r, function() {
        var a = {
          type: I.EVENT_COLUMN_PINNED,
          pinned: s,
          column: null,
          columns: null,
          api: o.gridApi,
          columnApi: o.columnApi,
          source: r
        };
        return a;
      }), this.columnAnimationService.finish();
    }, e.prototype.actionOnGridColumns = function(t, i, r, o) {
      var s = this;
      if (!ds(t)) {
        var a = [];
        if (t.forEach(function(u) {
          var c = s.getGridColumn(u);
          if (c) {
            var h = i(c);
            h !== !1 && a.push(c);
          }
        }), !!a.length && (this.updateDisplayedColumns(r), de(o) && o)) {
          var l = o();
          l.columns = a, l.column = a.length === 1 ? a[0] : null, this.eventService.dispatchEvent(l);
        }
      }
    }, e.prototype.getDisplayedColBefore = function(t) {
      var i = this.getAllDisplayedColumns(), r = i.indexOf(t);
      return r > 0 ? i[r - 1] : null;
    }, e.prototype.getDisplayedColAfter = function(t) {
      var i = this.getAllDisplayedColumns(), r = i.indexOf(t);
      return r < i.length - 1 ? i[r + 1] : null;
    }, e.prototype.getDisplayedGroupAfter = function(t) {
      return this.getDisplayedGroupAtDirection(t, "After");
    }, e.prototype.getDisplayedGroupBefore = function(t) {
      return this.getDisplayedGroupAtDirection(t, "Before");
    }, e.prototype.getDisplayedGroupAtDirection = function(t, i) {
      for (var r = t.getProvidedColumnGroup().getLevel() + t.getPaddingLevel(), o = t.getDisplayedLeafColumns(), s = i === "After" ? Di(o) : o[0], a = "getDisplayedCol" + i; ; ) {
        var l = this[a](s);
        if (!l)
          return null;
        var u = this.getColumnGroupAtLevel(l, r);
        if (u !== t)
          return u;
      }
    }, e.prototype.getColumnGroupAtLevel = function(t, i) {
      for (var r = t.getParent(), o, s; ; ) {
        var a = r.getProvidedColumnGroup();
        if (o = a.getLevel(), s = r.getPaddingLevel(), o + s <= i)
          break;
        r = r.getParent();
      }
      return r;
    }, e.prototype.isPinningLeft = function() {
      return this.displayedColumnsLeft.length > 0;
    }, e.prototype.isPinningRight = function() {
      return this.displayedColumnsRight.length > 0;
    }, e.prototype.getPrimaryAndSecondaryAndAutoColumns = function() {
      var t = this.primaryColumns ? this.primaryColumns.slice(0) : [];
      return this.groupAutoColumns && de(this.groupAutoColumns) && this.groupAutoColumns.forEach(function(i) {
        return t.push(i);
      }), this.secondaryColumnsPresent && this.secondaryColumns && this.secondaryColumns.forEach(function(i) {
        return t.push(i);
      }), t;
    }, e.prototype.createStateItemFromColumn = function(t) {
      var i = t.isRowGroupActive() ? this.rowGroupColumns.indexOf(t) : null, r = t.isPivotActive() ? this.pivotColumns.indexOf(t) : null, o = t.isValueActive() ? t.getAggFunc() : null, s = t.getSort() != null ? t.getSort() : null, a = t.getSortIndex() != null ? t.getSortIndex() : null, l = t.getFlex() != null && t.getFlex() > 0 ? t.getFlex() : null, u = {
        colId: t.getColId(),
        width: t.getActualWidth(),
        hide: !t.isVisible(),
        pinned: t.getPinned(),
        sort: s,
        sortIndex: a,
        aggFunc: o,
        rowGroup: t.isRowGroupActive(),
        rowGroupIndex: i,
        pivot: t.isPivotActive(),
        pivotIndex: r,
        flex: l
      };
      return u;
    }, e.prototype.getColumnState = function() {
      if (Je(this.primaryColumns) || !this.isAlive())
        return [];
      var t = this.getPrimaryAndSecondaryAndAutoColumns(), i = t.map(this.createStateItemFromColumn.bind(this));
      return this.pivotMode || this.orderColumnStateList(i), i;
    }, e.prototype.getPrimaryAndAutoGroupCols = function() {
      return this.groupAutoColumns ? QA(this.primaryColumns || [], this.groupAutoColumns) : this.primaryColumns;
    }, e.prototype.orderColumnStateList = function(t) {
      var i = Wc(this.gridColumns.map(function(r, o) {
        return [r.getColId(), o];
      }));
      t.sort(function(r, o) {
        var s = i.has(r.colId) ? i.get(r.colId) : -1, a = i.has(o.colId) ? i.get(o.colId) : -1;
        return s - a;
      });
    }, e.prototype.resetColumnState = function(t) {
      t === void 0 && (t = "api");
      var i = this.getColumnsFromTree(this.primaryColumnTree), r = [], o = 1e3, s = 1e3, a = [];
      this.groupAutoColumns && (a = a.concat(this.groupAutoColumns)), i && (a = a.concat(i)), a.forEach(function(l) {
        var u = function(S, E) {
          return S ?? E ?? null;
        }, c = l.getColDef(), h = u(c.sort, c.initialSort), d = u(c.sortIndex, c.initialSortIndex), f = u(c.hide, c.initialHide), p = u(c.pinned, c.initialPinned), g = u(c.width, c.initialWidth), _ = u(c.flex, c.initialFlex), m = u(c.rowGroupIndex, c.initialRowGroupIndex), v = u(c.rowGroup, c.initialRowGroup);
        m == null && (v == null || v == !1) && (m = null, v = null);
        var C = u(c.pivotIndex, c.initialPivotIndex), y = u(c.pivot, c.initialPivot);
        C == null && (y == null || y == !1) && (C = null, y = null);
        var b = u(c.aggFunc, c.initialAggFunc), L = {
          colId: l.getColId(),
          sort: h,
          sortIndex: d,
          hide: f,
          pinned: p,
          width: g,
          flex: _,
          rowGroup: v,
          rowGroupIndex: m,
          pivot: y,
          pivotIndex: C,
          aggFunc: b
        };
        Je(m) && v && (L.rowGroupIndex = o++), Je(C) && y && (L.pivotIndex = s++), r.push(L);
      }), this.applyColumnState({ state: r, applyOrder: !0 }, t);
    }, e.prototype.applyColumnState = function(t, i) {
      var r = this;
      if (i === void 0 && (i = "api"), ds(this.primaryColumns))
        return !1;
      if (t && t.state && !t.state.forEach)
        return console.warn("AG Grid: applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state."), !1;
      this.columnAnimationService.start();
      var o = this.compareColumnStatesAndRaiseEvents(i);
      this.autoGroupsNeedBuilding = !0;
      var s = this.primaryColumns.slice(), a = !0, l = {}, u = {}, c = [], h = this.rowGroupColumns.slice(), d = this.pivotColumns.slice();
      t.state && t.state.forEach(function(_) {
        var m = q.GROUP_AUTO_COLUMN_ID, v = _.colId || "", C = v.startsWith(m);
        if (C) {
          c.push(_);
          return;
        }
        var y = r.getPrimaryColumn(v);
        y ? (r.syncColumnWithStateItem(y, _, t.defaultState, l, u, !1, i), qr(s, y)) : a = !1;
      });
      var f = function(_) {
        return r.syncColumnWithStateItem(_, null, t.defaultState, l, u, !1, i);
      };
      s.forEach(f);
      var p = function(_, m, v, C) {
        var y = _[v.getId()], b = _[C.getId()], L = y != null, S = b != null;
        if (L && S)
          return y - b;
        if (L)
          return -1;
        if (S)
          return 1;
        var E = m.indexOf(v), D = m.indexOf(C), O = E >= 0, T = D >= 0;
        return O && T ? E - D : O ? -1 : 1;
      };
      this.rowGroupColumns.sort(p.bind(this, l, h)), this.pivotColumns.sort(p.bind(this, u, d)), this.updateGridColumns();
      var g = this.groupAutoColumns ? this.groupAutoColumns.slice() : [];
      return c.forEach(function(_) {
        var m = r.getAutoColumn(_.colId);
        qr(g, m), r.syncColumnWithStateItem(m, _, t.defaultState, null, null, !0, i);
      }), g.forEach(f), this.applyOrderAfterApplyState(t), this.updateDisplayedColumns(i), this.dispatchEverythingChanged(i), o(), this.columnAnimationService.finish(), a;
    }, e.prototype.applyOrderAfterApplyState = function(t) {
      if (!(!this.gridColsArePrimary || !t.applyOrder || !t.state)) {
        var i = [], r = {}, o = {};
        this.gridColumns.forEach(function(a) {
          return o[a.getId()] = a;
        }), t.state.forEach(function(a) {
          if (!(!a.colId || r[a.colId])) {
            var l = o[a.colId];
            l && (i.push(l), r[a.colId] = !0);
          }
        });
        var s = 0;
        if (this.gridColumns.forEach(function(a) {
          var l = a.getColId(), u = r[l] != null;
          if (!u) {
            var c = l.startsWith(q.GROUP_AUTO_COLUMN_ID);
            c ? Pv(i, a, s++) : i.push(a);
          }
        }), i = this.putFixedColumnsFirst(i), !this.doesMovePassMarryChildren(i)) {
          console.warn("AG Grid: Applying column order broke a group where columns should be married together. Applying new order has been discarded.");
          return;
        }
        this.gridColumns = i;
      }
    }, e.prototype.compareColumnStatesAndRaiseEvents = function(t) {
      var i = this, r = {
        rowGroupColumns: this.rowGroupColumns.slice(),
        pivotColumns: this.pivotColumns.slice(),
        valueColumns: this.valueColumns.slice()
      }, o = this.getColumnState(), s = {};
      return o.forEach(function(a) {
        s[a.colId] = a;
      }), function() {
        if (!i.gridOptionsWrapper.isSuppressColumnStateEvents()) {
          var a = i.getPrimaryAndAutoGroupCols(), l = function(m, v, C, y) {
            var b = v.map(y), L = C.map(y), S = ud(b, L);
            if (!S) {
              var E = {
                type: m,
                columns: C,
                column: C.length === 1 ? C[0] : null,
                api: i.gridApi,
                columnApi: i.columnApi,
                source: t
              };
              i.eventService.dispatchEvent(E);
            }
          }, u = function(m) {
            var v = [];
            return (a || []).forEach(function(C) {
              var y = s[C.getColId()];
              y && m(y, C) && v.push(C);
            }), v;
          }, c = function(m) {
            return m.getColId();
          };
          l(I.EVENT_COLUMN_ROW_GROUP_CHANGED, r.rowGroupColumns, i.rowGroupColumns, c), l(I.EVENT_COLUMN_PIVOT_CHANGED, r.pivotColumns, i.pivotColumns, c);
          var h = function(m, v) {
            var C = m.aggFunc != null, y = C != v.isValueActive(), b = C && m.aggFunc != v.getAggFunc();
            return y || b;
          }, d = u(h);
          d.length > 0 && i.fireColumnEvent(I.EVENT_COLUMN_VALUE_CHANGED, i.valueColumns, t);
          var f = function(m, v) {
            return m.width != v.getActualWidth();
          };
          i.fireColumnResizedEvent(u(f), !0, t);
          var p = function(m, v) {
            return m.pinned != v.getPinned();
          };
          i.raiseColumnPinnedEvent(u(p), t);
          var g = function(m, v) {
            return m.hide == v.isVisible();
          };
          i.raiseColumnVisibleEvent(u(g), t);
          var _ = function(m, v) {
            return m.sort != v.getSort() || m.sortIndex != v.getSortIndex();
          };
          u(_).length > 0 && i.sortController.dispatchSortChangedEvents(), i.raiseColumnMovedEvent(o, t);
        }
      };
    }, e.prototype.raiseColumnPinnedEvent = function(t, i) {
      if (t.length) {
        var r = t.length === 1 ? t[0] : null, o = this.getCommonValue(t, function(a) {
          return a.getPinned();
        }), s = {
          type: I.EVENT_COLUMN_PINNED,
          // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
          pinned: o ?? null,
          columns: t,
          column: r,
          api: this.gridApi,
          columnApi: this.columnApi,
          source: i
        };
        this.eventService.dispatchEvent(s);
      }
    }, e.prototype.getCommonValue = function(t, i) {
      if (!(!t || t.length == 0)) {
        for (var r = i(t[0]), o = 1; o < t.length; o++)
          if (r !== i(t[o]))
            return;
        return r;
      }
    }, e.prototype.raiseColumnVisibleEvent = function(t, i) {
      if (t.length) {
        var r = t.length === 1 ? t[0] : null, o = this.getCommonValue(t, function(a) {
          return a.isVisible();
        }), s = {
          type: I.EVENT_COLUMN_VISIBLE,
          visible: o,
          columns: t,
          column: r,
          api: this.gridApi,
          columnApi: this.columnApi,
          source: i
        };
        this.eventService.dispatchEvent(s);
      }
    }, e.prototype.raiseColumnMovedEvent = function(t, i) {
      var r = this, o = this.getColumnState(), s = {};
      o.forEach(function(d) {
        return s[d.colId] = d;
      });
      var a = {};
      t.forEach(function(d) {
        s[d.colId] && (a[d.colId] = !0);
      });
      var l = t.filter(function(d) {
        return a[d.colId];
      }), u = o.filter(function(d) {
        return a[d.colId];
      }), c = [];
      if (u.forEach(function(d, f) {
        var p = l && l[f];
        if (p && p.colId !== d.colId) {
          var g = r.getGridColumn(p.colId);
          g && c.push(g);
        }
      }), !!c.length) {
        var h = {
          type: I.EVENT_COLUMN_MOVED,
          columns: c,
          column: null,
          api: this.gridApi,
          columnApi: this.columnApi,
          source: i
        };
        this.eventService.dispatchEvent(h);
      }
    }, e.prototype.syncColumnWithStateItem = function(t, i, r, o, s, a, l) {
      if (t) {
        var u = function(D, O) {
          var T = { value1: void 0, value2: void 0 }, A = !1;
          return i && (i[D] !== void 0 && (T.value1 = i[D], A = !0), de(O) && i[O] !== void 0 && (T.value2 = i[O], A = !0)), !A && r && (r[D] !== void 0 && (T.value1 = r[D]), de(O) && r[O] !== void 0 && (T.value2 = r[O])), T;
        }, c = u("hide").value1;
        c !== void 0 && t.setVisible(!c, l);
        var h = u("pinned").value1;
        h !== void 0 && t.setPinned(h);
        var d = this.columnUtils.calculateColMinWidth(t.getColDef()), f = u("flex").value1;
        f !== void 0 && t.setFlex(f);
        var p = t.getFlex() <= 0;
        if (p) {
          var g = u("width").value1;
          g != null && d != null && g >= d && t.setActualWidth(g, l);
        }
        var _ = u("sort").value1;
        _ !== void 0 && (_ === q.SORT_DESC || _ === q.SORT_ASC ? t.setSort(_) : t.setSort(void 0));
        var m = u("sortIndex").value1;
        if (m !== void 0 && t.setSortIndex(m), !a) {
          var v = u("aggFunc").value1;
          v !== void 0 && (typeof v == "string" ? (t.setAggFunc(v), t.isValueActive() || (t.setValueActive(!0, l), this.valueColumns.push(t))) : (de(v) && console.warn("AG Grid: stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON."), t.isValueActive() && (t.setValueActive(!1, l), qr(this.valueColumns, t))));
          var C = u("rowGroup", "rowGroupIndex"), y = C.value1, b = C.value2;
          (y !== void 0 || b !== void 0) && (typeof b == "number" || y ? (t.isRowGroupActive() || (t.setRowGroupActive(!0, l), this.rowGroupColumns.push(t)), o && typeof b == "number" && (o[t.getId()] = b)) : t.isRowGroupActive() && (t.setRowGroupActive(!1, l), qr(this.rowGroupColumns, t)));
          var L = u("pivot", "pivotIndex"), S = L.value1, E = L.value2;
          (S !== void 0 || E !== void 0) && (typeof E == "number" || S ? (t.isPivotActive() || (t.setPivotActive(!0, l), this.pivotColumns.push(t)), s && typeof E == "number" && (s[t.getId()] = E)) : t.isPivotActive() && (t.setPivotActive(!1, l), qr(this.pivotColumns, t)));
        }
      }
    }, e.prototype.getGridColumns = function(t) {
      return this.getColumns(t, this.getGridColumn.bind(this));
    }, e.prototype.getColumns = function(t, i) {
      var r = [];
      return t && t.forEach(function(o) {
        var s = i(o);
        s && r.push(s);
      }), r;
    }, e.prototype.getColumnWithValidation = function(t) {
      if (t == null)
        return null;
      var i = this.getGridColumn(t);
      return i || console.warn("AG Grid: could not find column " + t), i;
    }, e.prototype.getPrimaryColumn = function(t) {
      return this.primaryColumns ? this.getColumn(t, this.primaryColumns, this.primaryColumnsMap) : null;
    }, e.prototype.getGridColumn = function(t) {
      return this.getColumn(t, this.gridColumns, this.gridColumnsMap);
    }, e.prototype.getColumn = function(t, i, r) {
      if (!t)
        return null;
      if (typeof t == "string" && r[t])
        return r[t];
      for (var o = 0; o < i.length; o++)
        if (this.columnsMatch(i[o], t))
          return i[o];
      return this.getAutoColumn(t);
    }, e.prototype.getAutoColumn = function(t) {
      var i = this;
      return !this.groupAutoColumns || !de(this.groupAutoColumns) || Je(this.groupAutoColumns) ? null : this.groupAutoColumns.find(function(r) {
        return i.columnsMatch(r, t);
      }) || null;
    }, e.prototype.columnsMatch = function(t, i) {
      var r = t === i, o = t.getColDef() === i, s = t.getColId() == i;
      return r || o || s;
    }, e.prototype.getDisplayNameForColumn = function(t, i, r) {
      if (r === void 0 && (r = !1), !t)
        return null;
      var o = this.getHeaderName(t.getColDef(), t, null, null, i);
      return r ? this.wrapHeaderNameWithAggFunc(t, o) : o;
    }, e.prototype.getDisplayNameForProvidedColumnGroup = function(t, i, r) {
      var o = i ? i.getColGroupDef() : null;
      return o ? this.getHeaderName(o, null, t, i, r) : null;
    }, e.prototype.getDisplayNameForColumnGroup = function(t, i) {
      return this.getDisplayNameForProvidedColumnGroup(t, t.getProvidedColumnGroup(), i);
    }, e.prototype.getHeaderName = function(t, i, r, o, s) {
      var a = t.headerValueGetter;
      if (a) {
        var l = {
          colDef: t,
          column: i,
          columnGroup: r,
          providedColumnGroup: o,
          location: s,
          api: this.gridOptionsWrapper.getApi(),
          context: this.gridOptionsWrapper.getContext()
        };
        return typeof a == "function" ? a(l) : typeof a == "string" ? this.expressionService.evaluate(a, l) : (console.warn("ag-grid: headerValueGetter must be a function or a string"), "");
      } else {
        if (t.headerName != null)
          return t.headerName;
        if (t.field)
          return YO(t.field);
      }
      return "";
    }, e.prototype.wrapHeaderNameWithAggFunc = function(t, i) {
      if (this.gridOptionsWrapper.isSuppressAggFuncInHeader())
        return i;
      var r = t.getColDef().pivotValueColumn, o = de(r), s = null, a;
      if (o)
        s = r ? r.getAggFunc() : null, a = !0;
      else {
        var l = t.isValueActive(), u = this.pivotMode || !this.isRowGroupEmpty();
        l && u ? (s = t.getAggFunc(), a = !0) : a = !1;
      }
      if (a) {
        var c = typeof s == "string" ? s : "func", h = this.gridOptionsWrapper.getLocaleTextFunc(), d = h(c, c);
        return d + "(" + i + ")";
      }
      return i;
    }, e.prototype.getColumnGroup = function(t, i) {
      if (!t)
        return null;
      if (t instanceof Yr)
        return t;
      var r = this.getAllDisplayedTrees(), o = typeof i == "number", s = null;
      return this.columnUtils.depthFirstAllColumnTreeSearch(r, function(a) {
        if (a instanceof Yr) {
          var l = a, u = void 0;
          o ? u = t === l.getGroupId() && i === l.getInstanceId() : u = t === l.getGroupId(), u && (s = l);
        }
      }), s;
    }, e.prototype.isReady = function() {
      return this.ready;
    }, e.prototype.extractValueColumns = function(t, i) {
      this.valueColumns = this.extractColumns(
        i,
        this.valueColumns,
        function(r, o) {
          return r.setValueActive(o, t);
        },
        // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null
        function() {
        },
        function() {
        },
        // aggFunc is a string, so return it's existence
        function(r) {
          var o = r.aggFunc;
          if (o === null || o === "")
            return null;
          if (o !== void 0)
            return !!o;
        },
        function(r) {
          return r.initialAggFunc != null && r.initialAggFunc != "";
        }
      ), this.valueColumns.forEach(function(r) {
        var o = r.getColDef();
        o.aggFunc != null && o.aggFunc != "" ? r.setAggFunc(o.aggFunc) : r.getAggFunc() || r.setAggFunc(o.initialAggFunc);
      });
    }, e.prototype.extractRowGroupColumns = function(t, i) {
      this.rowGroupColumns = this.extractColumns(i, this.rowGroupColumns, function(r, o) {
        return r.setRowGroupActive(o, t);
      }, function(r) {
        return r.rowGroupIndex;
      }, function(r) {
        return r.initialRowGroupIndex;
      }, function(r) {
        return r.rowGroup;
      }, function(r) {
        return r.initialRowGroup;
      });
    }, e.prototype.extractColumns = function(t, i, r, o, s, a, l) {
      t === void 0 && (t = []), i === void 0 && (i = []);
      var u = [], c = [];
      (this.primaryColumns || []).forEach(function(f) {
        var p = t.indexOf(f) < 0, g = f.getColDef(), _ = Iu(a(g)), m = Iu(l(g)), v = sa(o(g)), C = sa(s(g)), y, b = _ !== void 0, L = v !== void 0, S = m !== void 0, E = C !== void 0;
        if (b ? y = _ : L ? v === null ? y = !1 : y = v >= 0 : p ? S ? y = m : E ? y = C != null && C >= 0 : y = !1 : y = i.indexOf(f) >= 0, y) {
          var D = p ? v != null || C != null : v != null;
          D ? u.push(f) : c.push(f);
        }
      });
      var h = function(f) {
        var p = o(f.getColDef()), g = s(f.getColDef());
        return p ?? g;
      };
      u.sort(function(f, p) {
        var g = h(f), _ = h(p);
        return g === _ ? 0 : g < _ ? -1 : 1;
      });
      var d = [].concat(u);
      return i.forEach(function(f) {
        c.indexOf(f) >= 0 && d.push(f);
      }), c.forEach(function(f) {
        d.indexOf(f) < 0 && d.push(f);
      }), i.forEach(function(f) {
        d.indexOf(f) < 0 && r(f, !1);
      }), d.forEach(function(f) {
        i.indexOf(f) < 0 && r(f, !0);
      }), d;
    }, e.prototype.extractPivotColumns = function(t, i) {
      this.pivotColumns = this.extractColumns(i, this.pivotColumns, function(r, o) {
        return r.setPivotActive(o, t);
      }, function(r) {
        return r.pivotIndex;
      }, function(r) {
        return r.initialPivotIndex;
      }, function(r) {
        return r.pivot;
      }, function(r) {
        return r.initialPivot;
      });
    }, e.prototype.resetColumnGroupState = function(t) {
      t === void 0 && (t = "api");
      var i = [];
      this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, function(r) {
        if (r instanceof fn) {
          var o = r.getColGroupDef(), s = {
            groupId: r.getGroupId(),
            open: o ? o.openByDefault : void 0
          };
          i.push(s);
        }
      }), this.setColumnGroupState(i, t);
    }, e.prototype.getColumnGroupState = function() {
      var t = [];
      return this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function(i) {
        if (i instanceof fn) {
          var r = i;
          t.push({
            groupId: r.getGroupId(),
            open: r.isExpanded()
          });
        }
      }), t;
    }, e.prototype.setColumnGroupState = function(t, i) {
      var r = this;
      i === void 0 && (i = "api"), this.columnAnimationService.start();
      var o = [];
      t.forEach(function(s) {
        var a = s.groupId, l = s.open, u = r.getProvidedColumnGroup(a);
        u && u.isExpanded() !== l && (r.logger.log("columnGroupOpened(" + u.getGroupId() + "," + l + ")"), u.setExpanded(l), o.push(u));
      }), this.updateGroupsAndDisplayedColumns(i), this.setFirstRightAndLastLeftPinned(i), o.forEach(function(s) {
        var a = {
          type: I.EVENT_COLUMN_GROUP_OPENED,
          columnGroup: s,
          api: r.gridApi,
          columnApi: r.columnApi
        };
        r.eventService.dispatchEvent(a);
      }), this.columnAnimationService.finish();
    }, e.prototype.setColumnGroupOpened = function(t, i, r) {
      r === void 0 && (r = "api");
      var o;
      t instanceof fn ? o = t.getId() : o = t || "", this.setColumnGroupState([{ groupId: o, open: i }], r);
    }, e.prototype.getProvidedColumnGroup = function(t) {
      typeof t != "string" && console.error("AG Grid: group key must be a string");
      var i = null;
      return this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function(r) {
        if (r instanceof fn) {
          var o = r;
          o.getId() === t && (i = o);
        }
      }), i;
    }, e.prototype.calculateColumnsForDisplay = function() {
      var t = this, i;
      return this.pivotMode && !this.secondaryColumnsPresent ? i = this.gridColumns.filter(function(r) {
        var o = t.groupAutoColumns && Cs(t.groupAutoColumns, r), s = t.valueColumns && Cs(t.valueColumns, r);
        return o || s;
      }) : i = this.gridColumns.filter(function(r) {
        var o = t.groupAutoColumns && Cs(t.groupAutoColumns, r);
        return o || r.isVisible();
      }), i;
    }, e.prototype.checkColSpanActiveInCols = function(t) {
      var i = !1;
      return t.forEach(function(r) {
        de(r.getColDef().colSpan) && (i = !0);
      }), i;
    }, e.prototype.calculateColumnsForGroupDisplay = function() {
      var t = this;
      this.groupDisplayColumns = [];
      var i = function(r) {
        var o = r.getColDef();
        o && de(o.showRowGroup) && t.groupDisplayColumns.push(r);
      };
      this.gridColumns.forEach(i), this.groupAutoColumns && this.groupAutoColumns.forEach(i);
    }, e.prototype.getGroupDisplayColumns = function() {
      return this.groupDisplayColumns;
    }, e.prototype.updateDisplayedColumns = function(t) {
      var i = this.calculateColumnsForDisplay();
      this.buildDisplayedTrees(i), this.calculateColumnsForGroupDisplay(), this.updateGroupsAndDisplayedColumns(t), this.setFirstRightAndLastLeftPinned(t);
    }, e.prototype.isSecondaryColumnsPresent = function() {
      return this.secondaryColumnsPresent;
    }, e.prototype.setSecondaryColumns = function(t, i) {
      i === void 0 && (i = "api");
      var r = t && t.length > 0;
      if (!(!r && !this.secondaryColumnsPresent)) {
        if (r) {
          this.processSecondaryColumnDefinitions(t);
          var o = this.columnFactory.createColumnTree(t, !1);
          this.secondaryBalancedTree = o.columnTree, this.secondaryHeaderRowCount = o.treeDept + 1, this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree), this.secondaryColumnsPresent = !0;
        } else
          this.secondaryBalancedTree = null, this.secondaryHeaderRowCount = -1, this.secondaryColumns = null, this.secondaryColumnsPresent = !1;
        this.updateGridColumns(), this.updateDisplayedColumns(i);
      }
    }, e.prototype.processSecondaryColumnDefinitions = function(t) {
      var i = this.gridOptionsWrapper.getProcessSecondaryColDefFunc(), r = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();
      if (!(!i && !r)) {
        var o = function(s) {
          s.forEach(function(a) {
            var l = de(a.children);
            if (l) {
              var u = a;
              r && r(u), o(u.children);
            } else {
              var c = a;
              i && i(c);
            }
          });
        };
        t && o(t);
      }
    }, e.prototype.updateGridColumns = function() {
      var t = this;
      this.gridColsArePrimary && (this.lastPrimaryOrder = this.gridColumns), this.secondaryColumns && this.secondaryBalancedTree ? (this.gridBalancedTree = this.secondaryBalancedTree.slice(), this.gridHeaderRowCount = this.secondaryHeaderRowCount, this.gridColumns = this.secondaryColumns.slice(), this.gridColsArePrimary = !1) : this.primaryColumns && (this.gridBalancedTree = this.primaryColumnTree.slice(), this.gridHeaderRowCount = this.primaryHeaderRowCount, this.gridColumns = this.primaryColumns.slice(), this.gridColsArePrimary = !0, this.orderGridColsLikeLastPrimary()), this.addAutoGroupToGridColumns(), this.gridColumns = this.putFixedColumnsFirst(this.gridColumns), this.setupQuickFilterColumns(), this.clearDisplayedAndViewportColumns(), this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns), this.gridColumnsMap = {}, this.gridColumns.forEach(function(r) {
        return t.gridColumnsMap[r.getId()] = r;
      }), this.setAutoHeightActive();
      var i = {
        type: I.EVENT_GRID_COLUMNS_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.setAutoHeightActive = function() {
      if (this.autoHeightActive = this.gridColumns.filter(function(o) {
        return o.isAutoHeight();
      }).length > 0, this.autoHeightActive) {
        this.autoHeightActiveAtLeastOnce = !0;
        var t = this.rowModel.getType(), i = t === q.ROW_MODEL_TYPE_CLIENT_SIDE || t === q.ROW_MODEL_TYPE_SERVER_SIDE;
        if (!i) {
          var r = "AG Grid - autoHeight columns only work with Client Side Row Model and Server Side Row Model.";
          mi(function() {
            return console.warn(r);
          }, "autoHeightActive.wrongRowModel");
        }
      }
    }, e.prototype.orderGridColsLikeLastPrimary = function() {
      if (!Je(this.lastPrimaryOrder)) {
        var t = Wc(this.lastPrimaryOrder.map(function(u, c) {
          return [u, c];
        })), i = !0;
        if (this.gridColumns.forEach(function(u) {
          t.has(u) && (i = !1);
        }), !i) {
          var r = Wc(this.gridColumns.map(function(u) {
            return [u, !0];
          })), o = this.lastPrimaryOrder.filter(function(u) {
            return r.has(u);
          }), s = Wc(o.map(function(u) {
            return [u, !0];
          })), a = this.gridColumns.filter(function(u) {
            return !s.has(u);
          }), l = o.slice();
          a.forEach(function(u) {
            var c = u.getOriginalParent();
            if (!c) {
              l.push(u);
              return;
            }
            for (var h = []; !h.length && c; ) {
              var d = c.getLeafColumns();
              d.forEach(function(g) {
                var _ = l.indexOf(g) >= 0, m = h.indexOf(g) < 0;
                _ && m && h.push(g);
              }), c = c.getOriginalParent();
            }
            if (!h.length) {
              l.push(u);
              return;
            }
            var f = h.map(function(g) {
              return l.indexOf(g);
            }), p = Math.max.apply(Math, QA(f));
            Pv(l, u, p + 1);
          }), this.gridColumns = l;
        }
      }
    }, e.prototype.isPrimaryColumnGroupsPresent = function() {
      return this.primaryHeaderRowCount > 1;
    }, e.prototype.setupQuickFilterColumns = function() {
      this.groupAutoColumns ? this.columnsForQuickFilter = (this.primaryColumns || []).concat(this.groupAutoColumns) : this.primaryColumns && (this.columnsForQuickFilter = this.primaryColumns);
    }, e.prototype.putFixedColumnsFirst = function(t) {
      var i = t.filter(function(o) {
        return o.getColDef().lockPosition;
      }), r = t.filter(function(o) {
        return !o.getColDef().lockPosition;
      });
      return i.concat(r);
    }, e.prototype.addAutoGroupToGridColumns = function() {
      if (this.createGroupAutoColumnsIfNeeded(), !Je(this.groupAutoColumns)) {
        this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;
        var t = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);
        this.gridBalancedTree = t.concat(this.gridBalancedTree);
      }
    }, e.prototype.clearDisplayedAndViewportColumns = function() {
      this.displayedTreeLeft = [], this.displayedTreeRight = [], this.displayedTreeCentre = [], this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {}, this.displayedColumnsLeft = [], this.displayedColumnsRight = [], this.displayedColumnsCenter = [], this.displayedColumns = [], this.viewportColumns = [];
    }, e.prototype.updateGroupsAndDisplayedColumns = function(t) {
      this.updateOpenClosedVisibilityInColumnGroups(), this.deriveDisplayedColumns(t), this.refreshFlexedColumns(), this.extractViewport(), this.updateBodyWidths();
      var i = {
        type: I.EVENT_DISPLAYED_COLUMNS_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.deriveDisplayedColumns = function(t) {
      this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeLeft, this.displayedColumnsLeft), this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeCentre, this.displayedColumnsCenter), this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeRight, this.displayedColumnsRight), this.joinDisplayedColumns(), this.setLeftValues(t), this.displayedAutoHeightCols = this.displayedColumns.filter(function(i) {
        return i.isAutoHeight();
      });
    }, e.prototype.isAutoRowHeightActive = function() {
      return this.autoHeightActive;
    }, e.prototype.wasAutoRowHeightEverActive = function() {
      return this.autoHeightActiveAtLeastOnce;
    }, e.prototype.joinDisplayedColumns = function() {
      this.gridOptionsWrapper.isEnableRtl() ? this.displayedColumns = this.displayedColumnsRight.concat(this.displayedColumnsCenter).concat(this.displayedColumnsLeft) : this.displayedColumns = this.displayedColumnsLeft.concat(this.displayedColumnsCenter).concat(this.displayedColumnsRight);
    }, e.prototype.setLeftValues = function(t) {
      this.setLeftValuesOfColumns(t), this.setLeftValuesOfGroups();
    }, e.prototype.setLeftValuesOfColumns = function(t) {
      var i = this;
      if (this.primaryColumns) {
        var r = this.primaryColumns.slice(0), o = this.gridOptionsWrapper.isEnableRtl();
        [
          this.displayedColumnsLeft,
          this.displayedColumnsRight,
          this.displayedColumnsCenter
        ].forEach(function(s) {
          if (o) {
            var a = i.getWidthOfColsInList(s);
            s.forEach(function(u) {
              a -= u.getActualWidth(), u.setLeft(a, t);
            });
          } else {
            var l = 0;
            s.forEach(function(u) {
              u.setLeft(l, t), l += u.getActualWidth();
            });
          }
          $O(r, s);
        }), r.forEach(function(s) {
          s.setLeft(null, t);
        });
      }
    }, e.prototype.setLeftValuesOfGroups = function() {
      [
        this.displayedTreeLeft,
        this.displayedTreeRight,
        this.displayedTreeCentre
      ].forEach(function(t) {
        t.forEach(function(i) {
          if (i instanceof Yr) {
            var r = i;
            r.checkLeft();
          }
        });
      });
    }, e.prototype.derivedDisplayedColumnsFromDisplayedTree = function(t, i) {
      i.length = 0, this.columnUtils.depthFirstDisplayedColumnTreeSearch(t, function(r) {
        r instanceof Gt && i.push(r);
      });
    }, e.prototype.extractViewportColumns = function() {
      this.suppressColumnVirtualisation ? this.viewportColumnsCenter = this.displayedColumnsCenter : this.viewportColumnsCenter = this.filterOutColumnsWithinViewport(), this.viewportColumns = this.viewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight);
    }, e.prototype.getVirtualHeaderGroupRow = function(t, i) {
      var r;
      switch (t) {
        case q.PINNED_LEFT:
          r = this.viewportRowLeft[i];
          break;
        case q.PINNED_RIGHT:
          r = this.viewportRowRight[i];
          break;
        default:
          r = this.viewportRowCenter[i];
          break;
      }
      return Je(r) && (r = []), r;
    }, e.prototype.extractViewportRows = function() {
      this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {};
      var t = {};
      this.viewportColumns.forEach(function(r) {
        return t[r.getId()] = !0;
      });
      var i = function(r, o, s) {
        for (var a = !1, l = 0; l < r.length; l++) {
          var u = r[l], c = !1;
          if (u instanceof Gt)
            c = t[u.getId()] === !0;
          else {
            var h = u, d = h.getDisplayedChildren();
            d && (c = i(d, o, s + 1));
          }
          c && (a = !0, o[s] || (o[s] = []), o[s].push(u));
        }
        return a;
      };
      i(this.displayedTreeLeft, this.viewportRowLeft, 0), i(this.displayedTreeRight, this.viewportRowRight, 0), i(this.displayedTreeCentre, this.viewportRowCenter, 0);
    }, e.prototype.extractViewport = function() {
      this.extractViewportColumns(), this.extractViewportRows();
    }, e.prototype.filterOutColumnsWithinViewport = function() {
      return this.displayedColumnsCenter.filter(this.isColumnInViewport.bind(this));
    }, e.prototype.refreshFlexedColumns = function(t) {
      var i = this;
      t === void 0 && (t = {});
      var r = t.source ? t.source : "flex";
      if (t.viewportWidth != null && (this.flexViewportWidth = t.viewportWidth), !this.flexViewportWidth)
        return [];
      var o = -1;
      t.resizingCols && t.resizingCols.forEach(function(y) {
        var b = i.displayedColumnsCenter.indexOf(y);
        o < b && (o = b);
      });
      var s = function(y) {
        var b = i.displayedColumnsCenter.indexOf(y) > o;
        return y.getFlex() && b;
      }, a = this.displayedColumnsCenter.filter(function(y) {
        return !s(y);
      }), l = this.displayedColumnsCenter.filter(function(y) {
        return s(y);
      }), u = [];
      if (!l.length)
        return [];
      var c = [], h;
      e:
        for (; ; ) {
          var d = l.reduce(function(y, b) {
            return y + b.getFlex();
          }, 0);
          h = this.flexViewportWidth - this.getWidthOfColsInList(a);
          for (var f = 0; f < l.length; f++) {
            var p = l[f], g = h * p.getFlex() / d, _ = 0, m = p.getMinWidth(), v = p.getMaxWidth();
            if (de(m) && g < m ? _ = m : de(v) && g > v && (_ = v), _) {
              p.setActualWidth(_, r), qr(l, p), u.push(p), a.push(p);
              continue e;
            }
            c[f] = Math.round(g);
          }
          break;
        }
      var C = h;
      return l.forEach(function(y, b) {
        y.setActualWidth(Math.min(c[b], C), r), u.push(y), C -= c[b];
      }), t.skipSetLeft || this.setLeftValues(r), t.updateBodyWidths && this.updateBodyWidths(), t.fireResizedEvent && this.fireColumnResizedEvent(u, !0, r, l), this.flexColsCalculatedAtLestOnce || (this.gridOptionsWrapper.isRowModelDefault() && this.rowModel.resetRowHeights(), this.flexColsCalculatedAtLestOnce = !0), l;
    }, e.prototype.sizeColumnsToFit = function(t, i, r) {
      i === void 0 && (i = "sizeColumnsToFit");
      var o = this.getAllDisplayedColumns();
      if (!(t <= 0 || !o.length)) {
        var s = [], a = [];
        o.forEach(function(C) {
          C.getColDef().suppressSizeToFit === !0 ? a.push(C) : s.push(C);
        });
        var l = s.slice(0), u = !1, c = function(C) {
          qr(s, C), a.push(C);
        };
        for (s.forEach(function(C) {
          return C.resetActualWidth(i);
        }); !u; ) {
          u = !0;
          var h = t - this.getWidthOfColsInList(a);
          if (h <= 0)
            s.forEach(function(C) {
              C.setMinimum(i);
            });
          else
            for (var d = h / this.getWidthOfColsInList(s), f = h, p = s.length - 1; p >= 0; p--) {
              var g = s[p], _ = g.getMinWidth(), m = g.getMaxWidth(), v = Math.round(g.getActualWidth() * d);
              de(_) && v < _ ? (v = _, c(g), u = !1) : de(m) && g.isGreaterThanMax(v) ? (v = m, c(g), u = !1) : p === 0 && (v = f), g.setActualWidth(v, i, !0), f -= v;
            }
        }
        l.forEach(function(C) {
          C.fireColumnWidthChangedEvent(i);
        }), this.setLeftValues(i), this.updateBodyWidths(), !r && this.fireColumnResizedEvent(l, !0, i);
      }
    }, e.prototype.buildDisplayedTrees = function(t) {
      var i = [], r = [], o = [];
      t.forEach(function(a) {
        switch (a.getPinned()) {
          case "left":
            i.push(a);
            break;
          case "right":
            r.push(a);
            break;
          default:
            o.push(a);
            break;
        }
      });
      var s = new JV();
      this.displayedTreeLeft = this.displayedGroupCreator.createDisplayedGroups(i, this.gridBalancedTree, s, q.PINNED_LEFT, this.displayedTreeLeft), this.displayedTreeRight = this.displayedGroupCreator.createDisplayedGroups(r, this.gridBalancedTree, s, q.PINNED_RIGHT, this.displayedTreeRight), this.displayedTreeCentre = this.displayedGroupCreator.createDisplayedGroups(o, this.gridBalancedTree, s, null, this.displayedTreeCentre), this.updateDisplayedMap();
    }, e.prototype.updateDisplayedMap = function() {
      var t = this;
      this.displayedColumnsAndGroupsMap = {};
      var i = function(r) {
        t.displayedColumnsAndGroupsMap[r.getUniqueId()] = r;
      };
      this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeCentre, i), this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeLeft, i), this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeRight, i);
    }, e.prototype.isDisplayed = function(t) {
      var i = this.displayedColumnsAndGroupsMap[t.getUniqueId()];
      return i === t;
    }, e.prototype.updateOpenClosedVisibilityInColumnGroups = function() {
      var t = this.getAllDisplayedTrees();
      this.columnUtils.depthFirstAllColumnTreeSearch(t, function(i) {
        if (i instanceof Yr) {
          var r = i;
          r.calculateDisplayedColumns();
        }
      });
    }, e.prototype.getGroupAutoColumns = function() {
      return this.groupAutoColumns;
    }, e.prototype.createGroupAutoColumnsIfNeeded = function() {
      if (this.autoGroupsNeedBuilding) {
        this.autoGroupsNeedBuilding = !1;
        var t = this.gridOptionsWrapper.isGroupUseEntireRow(this.pivotMode), i = this.pivotMode ? this.gridOptionsWrapper.isPivotSuppressAutoColumn() : this.gridOptionsWrapper.isGroupSuppressAutoColumn(), r = this.rowGroupColumns.length > 0 || this.usingTreeData, o = r && !i && !t;
        if (o) {
          var s = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns), a = !this.autoColsEqual(s, this.groupAutoColumns);
          (a || this.forceRecreateAutoGroups) && (this.groupAutoColumns = s);
        } else
          this.groupAutoColumns = null;
      }
    }, e.prototype.autoColsEqual = function(t, i) {
      return ud(t, i, function(r, o) {
        return r.getColId() === o.getColId();
      });
    }, e.prototype.getWidthOfColsInList = function(t) {
      return t.reduce(function(i, r) {
        return i + r.getActualWidth();
      }, 0);
    }, e.prototype.getGridBalancedTree = function() {
      return this.gridBalancedTree;
    }, e.prototype.hasFloatingFilters = function() {
      if (!this.gridColumns)
        return !1;
      var t = this.gridColumns.some(function(i) {
        return i.getColDef().floatingFilter;
      });
      return t;
    }, e.prototype.getFirstDisplayedColumn = function() {
      var t = this.gridOptionsWrapper.isEnableRtl(), i = [
        "getDisplayedLeftColumns",
        "getDisplayedCenterColumns",
        "getDisplayedRightColumns"
      ];
      t && i.reverse();
      for (var r = 0; r < i.length; r++) {
        var o = this[i[r]]();
        if (o.length)
          return t ? Di(o) : o[0];
      }
      return null;
    }, nr([
      R("expressionService")
    ], e.prototype, "expressionService", void 0), nr([
      R("columnFactory")
    ], e.prototype, "columnFactory", void 0), nr([
      R("displayedGroupCreator")
    ], e.prototype, "displayedGroupCreator", void 0), nr([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), nr([
      R("autoWidthCalculator")
    ], e.prototype, "autoWidthCalculator", void 0), nr([
      R("columnUtils")
    ], e.prototype, "columnUtils", void 0), nr([
      R("columnAnimationService")
    ], e.prototype, "columnAnimationService", void 0), nr([
      R("autoGroupColService")
    ], e.prototype, "autoGroupColService", void 0), nr([
      fi("aggFuncService")
    ], e.prototype, "aggFuncService", void 0), nr([
      fi("valueCache")
    ], e.prototype, "valueCache", void 0), nr([
      fi("animationFrameService")
    ], e.prototype, "animationFrameService", void 0), nr([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), nr([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), nr([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), nr([
      R("sortController")
    ], e.prototype, "sortController", void 0), nr([
      R("columnDefFactory")
    ], e.prototype, "columnDefFactory", void 0), nr([
      Ee
    ], e.prototype, "init", null), nr([
      Tj(0, wo("loggerFactory"))
    ], e.prototype, "setBeans", null), e = nr([
      Ke("columnModel")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var xj = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Nj = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, nB = (
  /** @class */
  function(n) {
    xj(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.calculateColMinWidth = function(t) {
      return t.minWidth != null ? t.minWidth : this.gridOptionsWrapper.getMinColWidth();
    }, e.prototype.calculateColMaxWidth = function(t) {
      return t.maxWidth != null ? t.maxWidth : this.gridOptionsWrapper.getMaxColWidth() || Number.MAX_SAFE_INTEGER;
    }, e.prototype.calculateColInitialWidth = function(t) {
      var i = this.calculateColMinWidth(t), r = this.calculateColMaxWidth(t), o, s = sa(t.width), a = sa(t.initialWidth);
      return s != null ? o = s : a != null ? o = a : o = this.gridOptionsWrapper.getColWidth(), Math.max(Math.min(o, r), i);
    }, e.prototype.getOriginalPathForColumn = function(t, i) {
      var r = [], o = !1, s = function(a, l) {
        for (var u = 0; u < a.length; u++) {
          if (o)
            return;
          var c = a[u];
          if (c instanceof fn) {
            var h = c;
            s(h.getChildren(), l + 1), r[l] = c;
          } else
            c === t && (o = !0);
        }
      };
      return s(i, 0), o ? r : null;
    }, e.prototype.depthFirstOriginalTreeSearch = function(t, i, r) {
      var o = this;
      i && i.forEach(function(s) {
        s instanceof fn && o.depthFirstOriginalTreeSearch(s, s.getChildren(), r), r(s, t);
      });
    }, e.prototype.depthFirstAllColumnTreeSearch = function(t, i) {
      var r = this;
      t && t.forEach(function(o) {
        o instanceof Yr && r.depthFirstAllColumnTreeSearch(o.getChildren(), i), i(o);
      });
    }, e.prototype.depthFirstDisplayedColumnTreeSearch = function(t, i) {
      var r = this;
      t && t.forEach(function(o) {
        o instanceof Yr && r.depthFirstDisplayedColumnTreeSearch(o.getDisplayedChildren(), i), i(o);
      });
    }, e = Nj([
      Ke("columnUtils")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Ij = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Pj = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, rB = (
  /** @class */
  function(n) {
    Ij(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.createDisplayedGroups = function(t, i, r, o, s) {
      var a = this, l = [], u, c, h = this.mapOldGroupsById(s);
      return t.forEach(function(d) {
        for (var f = a.getOriginalPathForColumn(i, d), p = [], g = !c, _ = 0; _ < f.length; _++)
          if (g || f[_] !== c[_]) {
            var m = a.createColumnGroup(f[_], r, h, o);
            p[_] = m, _ == 0 ? l.push(m) : p[_ - 1].addChild(m);
          } else
            p[_] = u[_];
        var v = p.length === 0;
        if (v)
          l.push(d);
        else {
          var C = Di(p);
          C.addChild(d);
        }
        u = p, c = f;
      }), this.setupParentsIntoColumns(l, null), l;
    }, e.prototype.createColumnGroup = function(t, i, r, o) {
      var s = t.getGroupId(), a = i.getInstanceIdForKey(s), l = Yr.createUniqueId(s, a), u = r[l];
      return u && u.getProvidedColumnGroup() !== t && (u = null), de(u) ? u.reset() : (u = new Yr(t, s, a, o), this.context.createBean(u)), u;
    }, e.prototype.mapOldGroupsById = function(t) {
      var i = {}, r = function(o) {
        o.forEach(function(s) {
          if (s instanceof Yr) {
            var a = s;
            i[s.getUniqueId()] = a, r(a.getChildren());
          }
        });
      };
      return t && r(t), i;
    }, e.prototype.setupParentsIntoColumns = function(t, i) {
      var r = this;
      t.forEach(function(o) {
        if (o.setParent(i), o instanceof Yr) {
          var s = o;
          r.setupParentsIntoColumns(s.getChildren(), s);
        }
      });
    }, e.prototype.getOriginalPathForColumn = function(t, i) {
      var r = [], o = !1, s = function(a, l) {
        for (var u = 0; u < a.length; u++) {
          if (o)
            return;
          var c = a[u];
          if (c instanceof fn) {
            var h = c;
            s(h.getChildren(), l + 1), r[l] = c;
          } else
            c === i && (o = !0);
        }
      };
      return s(t, 0), o ? r : (console.warn("AG Grid: could not get path"), null);
    }, e = Pj([
      Ke("displayedGroupCreator")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Aj = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, Mj = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(Aj(arguments[e]));
  return n;
}, Ol = (
  /** @class */
  function() {
    function n() {
    }
    return n.STRING_PROPERTIES = [
      "sortingOrder",
      "rowClass",
      "rowSelection",
      "overlayLoadingTemplate",
      "overlayNoRowsTemplate",
      "quickFilterText",
      "rowModelType",
      "editType",
      "domLayout",
      "clipboardDelimiter",
      "rowGroupPanelShow",
      "multiSortKey",
      "pivotColumnGroupTotals",
      "pivotRowTotals",
      "pivotPanelShow",
      "fillHandleDirection",
      "serverSideStoreType",
      "groupDisplayType",
      "treeDataDisplayType"
    ], n.OBJECT_PROPERTIES = [
      "components",
      "frameworkComponents",
      "rowStyle",
      "context",
      "autoGroupColumnDef",
      "localeText",
      "icons",
      "datasource",
      "serverSideDatasource",
      "viewportDatasource",
      "groupRowRendererParams",
      "aggFuncs",
      "fullWidthCellRendererParams",
      "defaultColGroupDef",
      "defaultColDef",
      "defaultExportParams",
      "defaultCsvExportParams",
      "defaultExcelExportParams",
      "columnTypes",
      "rowClassRules",
      "detailCellRendererParams",
      "loadingCellRendererParams",
      "loadingOverlayComponentParams",
      "noRowsOverlayComponentParams",
      "popupParent",
      "colResizeDefault",
      "statusBar",
      "sideBar",
      "chartThemeOverrides",
      "customChartThemes"
    ], n.ARRAY_PROPERTIES = [
      "alignedGrids",
      "rowData",
      "columnDefs",
      "excelStyles",
      "pinnedTopRowData",
      "pinnedBottomRowData",
      "chartThemes"
    ], n.NUMBER_PROPERTIES = [
      "rowHeight",
      "detailRowHeight",
      "rowBuffer",
      "colWidth",
      "headerHeight",
      "groupHeaderHeight",
      "floatingFiltersHeight",
      "pivotHeaderHeight",
      "pivotGroupHeaderHeight",
      "groupDefaultExpanded",
      "minColWidth",
      "maxColWidth",
      "viewportRowModelPageSize",
      "viewportRowModelBufferSize",
      "autoSizePadding",
      "maxBlocksInCache",
      "maxConcurrentDatasourceRequests",
      "tooltipShowDelay",
      "tooltipHideDelay",
      "cacheOverflowSize",
      "paginationPageSize",
      "cacheBlockSize",
      "infiniteInitialRowCount",
      "scrollbarWidth",
      "batchUpdateWaitMillis",
      "asyncTransactionWaitMillis",
      "blockLoadDebounceMillis",
      "keepDetailRowsCount",
      "undoRedoCellEditingLimit",
      "cellFlashDelay",
      "cellFadeDelay",
      "tabIndex"
    ], n.BOOLEAN_PROPERTIES = [
      "suppressMakeColumnVisibleAfterUnGroup",
      "suppressRowClickSelection",
      "suppressCellSelection",
      "suppressCellFocus",
      "suppressHorizontalScroll",
      "alwaysShowHorizontalScroll",
      "alwaysShowVerticalScroll",
      "debug",
      "enableBrowserTooltips",
      "enableCellExpressions",
      "angularCompileRows",
      "angularCompileFilters",
      "groupSuppressAutoColumn",
      "groupSelectsChildren",
      "groupIncludeFooter",
      "groupIncludeTotalFooter",
      "groupUseEntireRow",
      "groupSuppressBlankHeader",
      "suppressMenuHide",
      "suppressRowDeselection",
      "unSortIcon",
      "suppressMultiSort",
      "singleClickEdit",
      "suppressLoadingOverlay",
      "suppressNoRowsOverlay",
      "suppressAutoSize",
      "skipHeaderOnAutoSize",
      "suppressParentsInRowNodes",
      "suppressColumnMoveAnimation",
      "suppressMovableColumns",
      "suppressFieldDotNotation",
      "enableRangeSelection",
      "enableRangeHandle",
      "enableFillHandle",
      "suppressClearOnFillReduction",
      "deltaSort",
      "suppressTouch",
      "suppressAsyncEvents",
      "allowContextMenuWithControlKey",
      "suppressContextMenu",
      "rememberGroupStateWhenNewData",
      "enableCellChangeFlash",
      "suppressDragLeaveHidesColumns",
      "suppressMiddleClickScrolls",
      "suppressPreventDefaultOnMouseWheel",
      "suppressCopyRowsToClipboard",
      "copyHeadersToClipboard",
      "copyGroupHeadersToClipboard",
      "pivotMode",
      "suppressAggFuncInHeader",
      "suppressColumnVirtualisation",
      "suppressAggAtRootLevel",
      "suppressFocusAfterRefresh",
      "functionsPassive",
      "functionsReadOnly",
      "animateRows",
      "groupSelectsFiltered",
      "groupRemoveSingleChildren",
      "groupRemoveLowestSingleChildren",
      "enableRtl",
      "suppressClickEdit",
      "rowDragEntireRow",
      "rowDragManaged",
      "suppressRowDrag",
      "suppressMoveWhenRowDragging",
      "rowDragMultiRow",
      "enableGroupEdit",
      "embedFullWidthRows",
      "deprecatedEmbedFullWidthRows",
      "suppressPaginationPanel",
      "groupHideOpenParents",
      "groupMultiAutoColumn",
      "pagination",
      "stopEditingWhenGridLosesFocus",
      "paginationAutoPageSize",
      "suppressScrollOnNewData",
      "suppressScrollWhenPopupsAreOpen",
      "purgeClosedRowNodes",
      "cacheQuickFilter",
      "deltaRowDataMode",
      "ensureDomOrder",
      "accentedSort",
      "suppressChangeDetection",
      "valueCache",
      "valueCacheNeverExpires",
      "aggregateOnlyChangedColumns",
      "suppressAnimationFrame",
      "suppressExcelExport",
      "suppressCsvExport",
      "treeData",
      "masterDetail",
      "suppressMultiRangeSelection",
      "enterMovesDownAfterEdit",
      "enterMovesDown",
      "suppressPropertyNamesCheck",
      "rowMultiSelectWithClick",
      "suppressEnterpriseResetOnNewColumns",
      "suppressRowHoverHighlight",
      "suppressRowTransform",
      "suppressClipboardPaste",
      "suppressLastEmptyLineOnPaste",
      "serverSideSortingAlwaysResets",
      "suppressSetColumnStateEvents",
      "suppressColumnStateEvents",
      "enableCharts",
      "deltaColumnMode",
      "suppressMaintainUnsortedOrder",
      "enableCellTextSelection",
      "suppressBrowserResizeObserver",
      "suppressMaxRenderedRowRestriction",
      "excludeChildrenWhenTreeDataFiltering",
      "tooltipMouseTrack",
      "keepDetailRows",
      "paginateChildRows",
      "preventDefaultOnContextMenu",
      "undoRedoCellEditing",
      "allowDragFromColumnsToolPanel",
      "immutableData",
      "immutableColumns",
      "pivotSuppressAutoColumn",
      "suppressExpandablePivotGroups",
      "applyColumnDefOrder",
      "debounceVerticalScrollbar",
      "detailRowAutoHeight",
      "serverSideFilteringAlwaysResets",
      "suppressAggFilteredOnly",
      "showOpenedGroup",
      "suppressClipboardApi",
      "suppressModelUpdateAfterUpdateTransaction",
      "stopEditingWhenCellsLoseFocus",
      "maintainColumnOrder",
      "groupMaintainOrder",
      "columnHoverHighlight",
      "reactUi",
      "suppressReactUi",
      "readOnlyEdit",
      "suppressRowVirtualisation"
    ], n.FUNCTION_PROPERTIES = [
      "localeTextFunc",
      "groupRowInnerRenderer",
      "groupRowInnerRendererFramework",
      "groupRowRenderer",
      "groupRowRendererFramework",
      "isExternalFilterPresent",
      "getRowHeight",
      "doesExternalFilterPass",
      "getRowClass",
      "getRowStyle",
      "getContextMenuItems",
      "getMainMenuItems",
      "processRowPostCreate",
      "processCellForClipboard",
      "groupRowAggNodes",
      "getRowNodeId",
      "isFullWidthCell",
      "fullWidthCellRenderer",
      "fullWidthCellRendererFramework",
      "processSecondaryColDef",
      "processSecondaryColGroupDef",
      "getBusinessKeyForNode",
      "sendToClipboard",
      "navigateToNextHeader",
      "tabToNextHeader",
      "navigateToNextCell",
      "tabToNextCell",
      "processCellFromClipboard",
      "getDocument",
      "postProcessPopup",
      "getChildCount",
      "getDataPath",
      "loadingCellRenderer",
      "loadingCellRendererFramework",
      "loadingOverlayComponent",
      "loadingOverlayComponentFramework",
      "noRowsOverlayComponent",
      "noRowsOverlayComponentFramework",
      "detailCellRenderer",
      "detailCellRendererFramework",
      "isRowMaster",
      "isRowSelectable",
      "postSort",
      "processHeaderForClipboard",
      "processGroupHeaderForClipboard",
      "paginationNumberFormatter",
      "processDataFromClipboard",
      "getServerSideGroupKey",
      "isServerSideGroup",
      "suppressKeyboardEvent",
      "createChartContainer",
      "getChartToolbarItems",
      "fillOperation",
      "isApplyServerSideTransaction",
      "getServerSideStoreParams",
      "isServerSideGroupOpenByDefault",
      "isGroupOpenByDefault",
      "defaultGroupSortComparator",
      "defaultGroupOrderComparator",
      "loadingCellRendererSelector",
      "getRowId"
    ], n.ALL_PROPERTIES = Mj(n.ARRAY_PROPERTIES, n.OBJECT_PROPERTIES, n.STRING_PROPERTIES, n.NUMBER_PROPERTIES, n.FUNCTION_PROPERTIES, n.BOOLEAN_PROPERTIES), n.FRAMEWORK_PROPERTIES = [
      "__ob__",
      "__v_skip",
      "__metadata__",
      "mappedColumnProperties",
      "hasChildColumns",
      "toColDef",
      "createColDefFromGridColumn"
    ], n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var S1 = globalThis && globalThis.__assign || function() {
  return S1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, S1.apply(this, arguments);
}, Fj = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, JA = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(Fj(arguments[e]));
  return n;
}, zc = (
  /** @class */
  function() {
    function n() {
    }
    return n.getEventCallbacks = function() {
      return n.EVENT_CALLBACKS || (n.EVENT_CALLBACKS = n.EVENTS.map(function(e) {
        return n.getCallbackForEvent(e);
      })), n.EVENT_CALLBACKS;
    }, n.copyAttributesToGridOptions = function(e, t, i) {
      typeof e != "object" && (e = {});
      var r = e, o = function(s) {
        return typeof t[s] < "u";
      };
      return JA(n.ARRAY_PROPERTIES, n.STRING_PROPERTIES, n.OBJECT_PROPERTIES, n.FUNCTION_PROPERTIES, n.getEventCallbacks()).filter(o).forEach(function(s) {
        return r[s] = t[s];
      }), n.BOOLEAN_PROPERTIES.filter(o).forEach(function(s) {
        return r[s] = n.toBoolean(t[s]);
      }), n.NUMBER_PROPERTIES.filter(o).forEach(function(s) {
        return r[s] = n.toNumber(t[s]);
      }), e;
    }, n.getCallbackForEvent = function(e) {
      return !e || e.length < 2 ? e : "on" + e[0].toUpperCase() + e.substr(1);
    }, n.processOnChange = function(e, t, i, r) {
      if (e) {
        var o = S1({}, e), s = t, a = function(c) {
          return o[c];
        };
        JA(n.ARRAY_PROPERTIES, n.OBJECT_PROPERTIES, n.STRING_PROPERTIES, n.getEventCallbacks()).filter(a).forEach(function(c) {
          return s[c] = o[c].currentValue;
        }), n.BOOLEAN_PROPERTIES.filter(a).forEach(function(c) {
          return s[c] = n.toBoolean(o[c].currentValue);
        }), n.NUMBER_PROPERTIES.filter(a).forEach(function(c) {
          return s[c] = n.toNumber(o[c].currentValue);
        }), o.enableCellTextSelection && (i.setEnableCellTextSelection(n.toBoolean(o.enableCellTextSelection.currentValue)), delete o.enableCellTextSelection), o.quickFilterText && (i.setQuickFilter(o.quickFilterText.currentValue), delete o.quickFilterText), o.autoGroupColumnDef && (i.setAutoGroupColumnDef(o.autoGroupColumnDef.currentValue, "gridOptionsChanged"), delete o.autoGroupColumnDef), o.columnDefs && (i.setColumnDefs(o.columnDefs.currentValue, "gridOptionsChanged"), delete o.columnDefs), o.defaultColDef && (i.setDefaultColDef(o.defaultColDef.currentValue, "gridOptionsChanged"), delete o.defaultColDef), o.paginationPageSize && (i.paginationSetPageSize(n.toNumber(o.paginationPageSize.currentValue)), delete o.paginationPageSize), o.pivotMode && (r.setPivotMode(n.toBoolean(o.pivotMode.currentValue)), delete o.pivotMode), o.groupRemoveSingleChildren && (i.setGroupRemoveSingleChildren(n.toBoolean(o.groupRemoveSingleChildren.currentValue)), delete o.groupRemoveSingleChildren), o.suppressRowDrag && (i.setSuppressRowDrag(n.toBoolean(o.suppressRowDrag.currentValue)), delete o.suppressRowDrag), o.suppressMoveWhenRowDragging && (i.setSuppressMoveWhenRowDragging(n.toBoolean(o.suppressMoveWhenRowDragging.currentValue)), delete o.suppressMoveWhenRowDragging), o.suppressRowClickSelection && (i.setSuppressRowClickSelection(n.toBoolean(o.suppressRowClickSelection.currentValue)), delete o.suppressRowClickSelection), o.suppressClipboardPaste && (i.setSuppressClipboardPaste(n.toBoolean(o.suppressClipboardPaste.currentValue)), delete o.suppressClipboardPaste), o.headerHeight && (i.setHeaderHeight(n.toNumber(o.headerHeight.currentValue)), delete o.headerHeight);
        var l = i;
        Object.keys(o).forEach(function(c) {
          var h = "set" + c.charAt(0).toUpperCase() + c.substring(1);
          l[h] && l[h](e[c].currentValue);
        });
        var u = {
          type: I.EVENT_COMPONENT_STATE_CHANGED,
          api: t.api,
          columnApi: t.columnApi
        };
        pi(e, function(c, h) {
          u[c] = h;
        }), i.dispatchEvent(u);
      }
    }, n.toBoolean = function(e) {
      return typeof e == "boolean" ? e : typeof e == "string" ? e.toUpperCase() === "TRUE" || e == "" : !1;
    }, n.toNumber = function(e) {
      if (typeof e == "number")
        return e;
      if (typeof e == "string")
        return Number(e);
    }, n.EVENTS = [], n.PUBLIC_EVENTS = [], n.EXCLUDED_INTERNAL_EVENTS = [], n.STRING_PROPERTIES = Ol.STRING_PROPERTIES, n.OBJECT_PROPERTIES = Ol.OBJECT_PROPERTIES, n.ARRAY_PROPERTIES = Ol.ARRAY_PROPERTIES, n.NUMBER_PROPERTIES = Ol.NUMBER_PROPERTIES, n.BOOLEAN_PROPERTIES = Ol.BOOLEAN_PROPERTIES, n.FUNCTION_PROPERTIES = Ol.FUNCTION_PROPERTIES, n.ALL_PROPERTIES = Ol.ALL_PROPERTIES, n;
  }()
);
zc.EVENTS = Gd(I);
zc.EXCLUDED_INTERNAL_EVENTS = [
  I.EVENT_SCROLLBAR_WIDTH_CHANGED,
  I.EVENT_CHECKBOX_CHANGED,
  I.EVENT_HEIGHT_SCALE_CHANGED,
  I.EVENT_BODY_HEIGHT_CHANGED,
  I.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,
  I.EVENT_SCROLL_VISIBILITY_CHANGED,
  I.EVENT_COLUMN_HOVER_CHANGED,
  I.EVENT_FLASH_CELLS,
  I.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED,
  I.EVENT_DISPLAYED_ROWS_CHANGED,
  I.EVENT_LEFT_PINNED_WIDTH_CHANGED,
  I.EVENT_RIGHT_PINNED_WIDTH_CHANGED,
  I.EVENT_ROW_CONTAINER_HEIGHT_CHANGED,
  I.EVENT_POPUP_TO_FRONT,
  I.EVENT_KEYBOARD_FOCUS,
  I.EVENT_MOUSE_FOCUS,
  I.EVENT_STORE_UPDATED,
  I.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
  I.EVENT_COLUMN_PANEL_ITEM_DRAG_END,
  I.EVENT_FILL_START,
  I.EVENT_FILL_END
];
zc.PUBLIC_EVENTS = zc.EVENTS.filter(function(n) {
  return !Cs(zc.EXCLUDED_INTERNAL_EVENTS, n);
});
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var kj = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Wj = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, oB = (
  /** @class */
  function(n) {
    kj(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.componentsMappedByName = {}, t;
    }
    return e.prototype.setupComponents = function(t) {
      var i = this;
      t && t.forEach(function(r) {
        return i.addComponent(r);
      });
    }, e.prototype.addComponent = function(t) {
      var i = t.componentName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), r = i.toUpperCase();
      this.componentsMappedByName[r] = t.componentClass;
    }, e.prototype.getComponentClass = function(t) {
      return this.componentsMappedByName[t];
    }, e = Wj([
      Ke("agStackComponentsRegistry")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Vj = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, Bj = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(Vj(arguments[e]));
  return n;
}, E1 = (
  /** @class */
  function() {
    function n() {
    }
    return n.STRING_PROPERTIES = [
      "headerName",
      "columnGroupShow",
      "headerClass",
      "toolPanelClass",
      "headerValueGetter",
      "pivotKeys",
      "groupId",
      "colId",
      "sort",
      "initialSort",
      "field",
      "type",
      "tooltipComponent",
      "tooltipField",
      "headerTooltip",
      "cellClass",
      "showRowGroup",
      "template",
      "templateUrl",
      "filter",
      "initialAggFunc",
      "aggFunc",
      "pinned",
      "initialPinned",
      "chartDataType",
      "cellEditorPopupPosition"
    ], n.OBJECT_PROPERTIES = [
      "headerGroupComponent",
      "headerGroupComponentFramework",
      "headerGroupComponentParams",
      "cellStyle",
      "cellRenderer",
      "cellRendererParams",
      "cellRendererFramework",
      "cellEditor",
      "cellEditorFramework",
      "cellEditorParams",
      "pinnedRowCellRendererFramework",
      "pinnedRowCellRendererParams",
      "filterFramework",
      "filterParams",
      "pivotValueColumn",
      "headerComponent",
      "headerComponentFramework",
      "headerComponentParams",
      "floatingFilterComponent",
      "floatingFilterComponentParams",
      "floatingFilterComponentFramework",
      "floatingFilterFramework",
      "tooltipComponent",
      "tooltipComponentParams",
      "tooltipComponentFramework",
      "refData",
      "columnsMenuParams"
    ], n.ARRAY_PROPERTIES = [
      "children",
      "sortingOrder",
      "allowedAggFuncs",
      "menuTabs",
      "pivotTotalColumnIds",
      "cellClassRules",
      "icons"
    ], n.NUMBER_PROPERTIES = [
      "sortedAt",
      "sortIndex",
      "initialSortIndex",
      "flex",
      "initialFlex",
      "width",
      "initialWidth",
      "minWidth",
      "maxWidth",
      "rowGroupIndex",
      "initialRowGroupIndex",
      "pivotIndex",
      "initialPivotIndex"
    ], n.BOOLEAN_PROPERTIES = [
      "suppressCellFlash",
      "suppressColumnsToolPanel",
      "suppressFiltersToolPanel",
      "openByDefault",
      "marryChildren",
      "hide",
      "initialHide",
      "rowGroup",
      "initialRowGroup",
      "pivot",
      "initialPivot",
      "checkboxSelection",
      "headerCheckboxSelection",
      "headerCheckboxSelectionFilteredOnly",
      "suppressMenu",
      "suppressMovable",
      "lockPosition",
      "lockVisible",
      "lockPinned",
      "unSortIcon",
      "suppressSizeToFit",
      "suppressAutoSize",
      "enableRowGroup",
      "enablePivot",
      "enableValue",
      "editable",
      "suppressPaste",
      "suppressNavigable",
      "enableCellChangeFlash",
      "rowDrag",
      "dndSource",
      "autoHeight",
      "wrapText",
      "sortable",
      "resizable",
      "singleClickEdit",
      "floatingFilter",
      "cellEditorPopup",
      "suppressFillHandle"
    ], n.FUNCTION_PROPERTIES = [
      "dndSourceOnRowDrag",
      "valueGetter",
      "valueSetter",
      "filterValueGetter",
      "keyCreator",
      "pinnedRowCellRenderer",
      "valueFormatter",
      "pinnedRowValueFormatter",
      "valueParser",
      "comparator",
      "equals",
      "pivotComparator",
      "suppressKeyboardEvent",
      "suppressHeaderKeyboardEvent",
      "colSpan",
      "rowSpan",
      "getQuickFilterText",
      "newValueHandler",
      "onCellValueChanged",
      "onCellClicked",
      "onCellDoubleClicked",
      "onCellContextMenu",
      "rowDragText",
      "tooltipValueGetter",
      "tooltipComponent",
      "tooltipComponentFramework",
      "cellRendererSelector",
      "cellEditorSelector"
    ], n.ALL_PROPERTIES = Bj(n.ARRAY_PROPERTIES, n.OBJECT_PROPERTIES, n.STRING_PROPERTIES, n.NUMBER_PROPERTIES, n.FUNCTION_PROPERTIES, n.BOOLEAN_PROPERTIES), n.FRAMEWORK_PROPERTIES = [
      "__ob__",
      "__v_skip",
      "__metadata__",
      "mappedColumnProperties",
      "hasChildColumns",
      "toColDef",
      "createColDefFromGridColumn"
    ], n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var eM = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, If = (
  /** @class */
  function() {
    function n(e, t, i, r) {
      r === void 0 && (r = 1), this.r = Math.min(1, Math.max(0, e || 0)), this.g = Math.min(1, Math.max(0, t || 0)), this.b = Math.min(1, Math.max(0, i || 0)), this.a = Math.min(1, Math.max(0, r || 0));
    }
    return n.fromString = function(e) {
      if (e.indexOf("#") >= 0)
        return n.fromHexString(e);
      var t = n.nameToHex[e];
      if (t)
        return n.fromHexString(t);
      if (e.indexOf("rgb") >= 0)
        return n.fromRgbaString(e);
      throw new Error("Invalid color string: '" + e + "'");
    }, n.parseHex = function(e) {
      e = e.replace(/ /g, "").slice(1);
      var t;
      switch (e.length) {
        case 6:
        case 8:
          t = [];
          for (var i = 0; i < e.length; i += 2)
            t.push(parseInt("" + e[i] + e[i + 1], 16));
          break;
        case 3:
        case 4:
          t = e.split("").map(function(r) {
            return parseInt(r, 16);
          }).map(function(r) {
            return r + r * 16;
          });
          break;
      }
      if (t.length >= 3 && t.every(function(r) {
        return r >= 0;
      }))
        return t.length === 3 && t.push(255), t;
    }, n.fromHexString = function(e) {
      var t = n.parseHex(e);
      if (t) {
        var i = eM(t, 4), r = i[0], o = i[1], s = i[2], a = i[3];
        return new n(r / 255, o / 255, s / 255, a / 255);
      }
      throw new Error("Malformed hexadecimal color string: '" + e + "'");
    }, n.stringToRgba = function(e) {
      for (var t = eM([NaN, NaN], 2), i = t[0], r = t[1], o = 0; o < e.length; o++) {
        var s = e[o];
        if (!i && s === "(")
          i = o;
        else if (s === ")") {
          r = o;
          break;
        }
      }
      var a = i && r && e.substring(i + 1, r);
      if (a) {
        for (var l = a.split(","), u = [], o = 0; o < l.length; o++) {
          var c = l[o], h = parseFloat(c);
          if (isNaN(h))
            return;
          c.indexOf("%") >= 0 ? (h = Math.max(0, Math.min(100, h)), h /= 100) : o === 3 ? h = Math.max(0, Math.min(1, h)) : (h = Math.max(0, Math.min(255, h)), h /= 255), u.push(h);
        }
        return u;
      }
    }, n.fromRgbaString = function(e) {
      var t = n.stringToRgba(e);
      if (t) {
        if (t.length === 3)
          return new n(t[0], t[1], t[2]);
        if (t.length === 4)
          return new n(t[0], t[1], t[2], t[3]);
      }
      throw new Error("Malformed rgb/rgba color string: '" + e + "'");
    }, n.fromArray = function(e) {
      if (e.length === 4)
        return new n(e[0], e[1], e[2], e[3]);
      if (e.length === 3)
        return new n(e[0], e[1], e[2]);
      throw new Error("The given array should contain 3 or 4 color components (numbers).");
    }, n.fromHSB = function(e, t, i, r) {
      r === void 0 && (r = 1);
      var o = n.HSBtoRGB(e, t, i);
      return new n(o[0], o[1], o[2], r);
    }, n.padHex = function(e) {
      return e.length === 1 ? "0" + e : e;
    }, n.prototype.toHexString = function() {
      var e = "#" + n.padHex(Math.round(this.r * 255).toString(16)) + n.padHex(Math.round(this.g * 255).toString(16)) + n.padHex(Math.round(this.b * 255).toString(16));
      return this.a < 1 && (e += n.padHex(Math.round(this.a * 255).toString(16))), e;
    }, n.prototype.toRgbaString = function(e) {
      e === void 0 && (e = 3);
      var t = [
        Math.round(this.r * 255),
        Math.round(this.g * 255),
        Math.round(this.b * 255)
      ], i = Math.pow(10, e);
      return this.a !== 1 ? (t.push(Math.round(this.a * i) / i), "rgba(" + t.join(", ") + ")") : "rgb(" + t.join(", ") + ")";
    }, n.prototype.toString = function() {
      return this.a === 1 ? this.toHexString() : this.toRgbaString();
    }, n.prototype.toHSB = function() {
      return n.RGBtoHSB(this.r, this.g, this.b);
    }, n.RGBtoHSB = function(e, t, i) {
      var r = Math.min(e, t, i), o = Math.max(e, t, i), s = o !== 0 ? (o - r) / o : 0, a = NaN;
      if (r !== o) {
        var l = o - r, u = (o - e) / l, c = (o - t) / l, h = (o - i) / l;
        e === o ? a = h - c : t === o ? a = 2 + u - h : a = 4 + c - u, a /= 6, a < 0 && (a = a + 1);
      }
      return [a * 360, s, o];
    }, n.HSBtoRGB = function(e, t, i) {
      isNaN(e) && (e = 0), e = (e % 360 + 360) % 360 / 360;
      var r = 0, o = 0, s = 0;
      if (t === 0)
        r = o = s = i;
      else {
        var a = (e - Math.floor(e)) * 6, l = a - Math.floor(a), u = i * (1 - t), c = i * (1 - t * l), h = i * (1 - t * (1 - l));
        switch (a >> 0) {
          case 0:
            r = i, o = h, s = u;
            break;
          case 1:
            r = c, o = i, s = u;
            break;
          case 2:
            r = u, o = i, s = h;
            break;
          case 3:
            r = u, o = c, s = i;
            break;
          case 4:
            r = h, o = u, s = i;
            break;
          case 5:
            r = i, o = u, s = c;
            break;
        }
      }
      return [r, o, s];
    }, n.prototype.derive = function(e, t, i, r) {
      var o = n.RGBtoHSB(this.r, this.g, this.b), s = o[2];
      s == 0 && i > 1 && (s = 0.05);
      var a = ((o[0] + e) % 360 + 360) % 360, l = Math.max(Math.min(o[1] * t, 1), 0);
      s = Math.max(Math.min(s * i, 1), 0);
      var u = Math.max(Math.min(this.a * r, 1), 0), c = n.HSBtoRGB(a, l, s);
      return c.push(u), n.fromArray(c);
    }, n.prototype.brighter = function() {
      return this.derive(0, 1, 1 / 0.7, 1);
    }, n.prototype.darker = function() {
      return this.derive(0, 1, 0.7, 1);
    }, n.nameToHex = Object.freeze({
      aliceblue: "#F0F8FF",
      antiquewhite: "#FAEBD7",
      aqua: "#00FFFF",
      aquamarine: "#7FFFD4",
      azure: "#F0FFFF",
      beige: "#F5F5DC",
      bisque: "#FFE4C4",
      black: "#000000",
      blanchedalmond: "#FFEBCD",
      blue: "#0000FF",
      blueviolet: "#8A2BE2",
      brown: "#A52A2A",
      burlywood: "#DEB887",
      cadetblue: "#5F9EA0",
      chartreuse: "#7FFF00",
      chocolate: "#D2691E",
      coral: "#FF7F50",
      cornflowerblue: "#6495ED",
      cornsilk: "#FFF8DC",
      crimson: "#DC143C",
      cyan: "#00FFFF",
      darkblue: "#00008B",
      darkcyan: "#008B8B",
      darkgoldenrod: "#B8860B",
      darkgray: "#A9A9A9",
      darkgreen: "#006400",
      darkgrey: "#A9A9A9",
      darkkhaki: "#BDB76B",
      darkmagenta: "#8B008B",
      darkolivegreen: "#556B2F",
      darkorange: "#FF8C00",
      darkorchid: "#9932CC",
      darkred: "#8B0000",
      darksalmon: "#E9967A",
      darkseagreen: "#8FBC8F",
      darkslateblue: "#483D8B",
      darkslategray: "#2F4F4F",
      darkslategrey: "#2F4F4F",
      darkturquoise: "#00CED1",
      darkviolet: "#9400D3",
      deeppink: "#FF1493",
      deepskyblue: "#00BFFF",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1E90FF",
      firebrick: "#B22222",
      floralwhite: "#FFFAF0",
      forestgreen: "#228B22",
      fuchsia: "#FF00FF",
      gainsboro: "#DCDCDC",
      ghostwhite: "#F8F8FF",
      gold: "#FFD700",
      goldenrod: "#DAA520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#ADFF2F",
      grey: "#808080",
      honeydew: "#F0FFF0",
      hotpink: "#FF69B4",
      indianred: "#CD5C5C",
      indigo: "#4B0082",
      ivory: "#FFFFF0",
      khaki: "#F0E68C",
      lavender: "#E6E6FA",
      lavenderblush: "#FFF0F5",
      lawngreen: "#7CFC00",
      lemonchiffon: "#FFFACD",
      lightblue: "#ADD8E6",
      lightcoral: "#F08080",
      lightcyan: "#E0FFFF",
      lightgoldenrodyellow: "#FAFAD2",
      lightgray: "#D3D3D3",
      lightgreen: "#90EE90",
      lightgrey: "#D3D3D3",
      lightpink: "#FFB6C1",
      lightsalmon: "#FFA07A",
      lightseagreen: "#20B2AA",
      lightskyblue: "#87CEFA",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#B0C4DE",
      lightyellow: "#FFFFE0",
      lime: "#00FF00",
      limegreen: "#32CD32",
      linen: "#FAF0E6",
      magenta: "#FF00FF",
      maroon: "#800000",
      mediumaquamarine: "#66CDAA",
      mediumblue: "#0000CD",
      mediumorchid: "#BA55D3",
      mediumpurple: "#9370DB",
      mediumseagreen: "#3CB371",
      mediumslateblue: "#7B68EE",
      mediumspringgreen: "#00FA9A",
      mediumturquoise: "#48D1CC",
      mediumvioletred: "#C71585",
      midnightblue: "#191970",
      mintcream: "#F5FFFA",
      mistyrose: "#FFE4E1",
      moccasin: "#FFE4B5",
      navajowhite: "#FFDEAD",
      navy: "#000080",
      oldlace: "#FDF5E6",
      olive: "#808000",
      olivedrab: "#6B8E23",
      orange: "#FFA500",
      orangered: "#FF4500",
      orchid: "#DA70D6",
      palegoldenrod: "#EEE8AA",
      palegreen: "#98FB98",
      paleturquoise: "#AFEEEE",
      palevioletred: "#DB7093",
      papayawhip: "#FFEFD5",
      peachpuff: "#FFDAB9",
      peru: "#CD853F",
      pink: "#FFC0CB",
      plum: "#DDA0DD",
      powderblue: "#B0E0E6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#FF0000",
      rosybrown: "#BC8F8F",
      royalblue: "#4169E1",
      saddlebrown: "#8B4513",
      salmon: "#FA8072",
      sandybrown: "#F4A460",
      seagreen: "#2E8B57",
      seashell: "#FFF5EE",
      sienna: "#A0522D",
      silver: "#C0C0C0",
      skyblue: "#87CEEB",
      slateblue: "#6A5ACD",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#FFFAFA",
      springgreen: "#00FF7F",
      steelblue: "#4682B4",
      tan: "#D2B48C",
      teal: "#008080",
      thistle: "#D8BFD8",
      tomato: "#FF6347",
      turquoise: "#40E0D0",
      violet: "#EE82EE",
      wheat: "#F5DEB3",
      white: "#FFFFFF",
      whitesmoke: "#F5F5F5",
      yellow: "#FFFF00",
      yellowgreen: "#9ACD32"
    }), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function sB(n, e) {
  e === void 0 && (e = ",");
  var t = [], i = function(d) {
    return d === "\r" || d === `
`;
  }, r = !1;
  if (n === "")
    return [[""]];
  for (var o = function(d, f, p) {
    var g = n[p - 1], _ = n[p], m = n[p + 1], v = function() {
      t[d] || (t[d] = []), t[d][f] || (t[d][f] = "");
    };
    if (v(), _ === '"') {
      if (r)
        return m === '"' ? (t[d][f] += '"', p++) : r = !1, s = d, a = f, l = p, "continue";
      if (g === void 0 || g === e || i(g))
        return r = !0, s = d, a = f, l = p, "continue";
    }
    if (!r) {
      if (_ === e)
        return f++, v(), s = d, a = f, l = p, "continue";
      if (i(_))
        return f = 0, d++, v(), _ === "\r" && m === `
` && p++, s = d, a = f, l = p, "continue";
    }
    t[d][f] += _, s = d, a = f, l = p;
  }, s, a, l, u = 0, c = 0, h = 0; h < n.length; h++)
    o(u, c, h), u = s, c = a, h = l;
  return t;
}
const Hj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  stringToArray: sB
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Gj = globalThis && globalThis.__values || function(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], i = 0;
  if (t)
    return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function() {
        return n && i >= n.length && (n = void 0), { value: n && n[i++], done: !n };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, qE, YE, XE, ZE, QE, JE, L1, D1;
function Uj() {
  return YE === void 0 && (YE = /*@cc_on!@*/
  !!document.documentMode), YE;
}
function _S() {
  return XE === void 0 && (XE = !Uj() && !!window.StyleMedia), XE;
}
function CS() {
  return qE === void 0 && (qE = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), qE;
}
function S_() {
  if (ZE === void 0) {
    var n = window;
    ZE = !!n.chrome && (!!n.chrome.webstore || !!n.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }
  return ZE;
}
function XO() {
  if (QE === void 0) {
    var n = window;
    QE = typeof n.InstallTrigger < "u";
  }
  return QE;
}
function ug() {
  return JE === void 0 && (JE = (/iPad|iPhone|iPod/.test(navigator.platform) || // eslint-disable-next-line
  navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // @ts-ignore
  !window.MSStream), JE;
}
function Pw(n) {
  if (!n)
    return null;
  var e = n.tabIndex, t = n.getAttribute("tabIndex");
  return e === -1 && (t === null || t === "" && !XO()) ? null : e.toString();
}
function aB() {
  if (!document.body)
    return -1;
  var n = 1e6, e = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9, t = document.createElement("div");
  for (document.body.appendChild(t); ; ) {
    var i = n * 2;
    if (t.style.height = i + "px", i > e || t.clientHeight !== i)
      break;
    n = i;
  }
  return document.body.removeChild(t), n;
}
function lB() {
  return D1 == null && uB(), D1;
}
function uB() {
  var n = document.body, e = document.createElement("div");
  e.style.width = e.style.height = "100px", e.style.opacity = "0", e.style.overflow = "scroll", e.style.msOverflowStyle = "scrollbar", e.style.position = "absolute", n.appendChild(e);
  var t = e.offsetWidth - e.clientWidth;
  t === 0 && e.clientWidth === 0 && (t = null), e.parentNode && e.parentNode.removeChild(e), t != null && (D1 = t, L1 = t === 0);
}
function cB() {
  return L1 == null && uB(), L1;
}
function zj() {
  var n, e, t = ["webkit", "moz", "o", "ms"], i = document.createElement("div"), r = document.getElementsByTagName("body")[0], o = !1, s;
  r.appendChild(i), i.setAttribute("style", t.map(function(c) {
    return "-" + c + "-overflow-scrolling: touch";
  }).concat("overflow-scrolling: touch").join(";"));
  var a = window.getComputedStyle(i);
  if (a.overflowScrolling === "touch" && (o = !0), !o)
    try {
      for (var l = Gj(t), u = l.next(); !u.done; u = l.next())
        if (s = u.value, a[s + "OverflowScrolling"] === "touch") {
          o = !0;
          break;
        }
    } catch (c) {
      n = { error: c };
    } finally {
      try {
        u && !u.done && (e = l.return) && e.call(l);
      } finally {
        if (n)
          throw n.error;
      }
    }
  return i.parentNode && i.parentNode.removeChild(i), o;
}
function hB() {
  return document.body ? document.body.clientWidth : window.innerHeight ? window.innerWidth : document.documentElement && document.documentElement.clientWidth ? document.documentElement.clientWidth : -1;
}
function dB() {
  return document.body ? document.body.clientHeight : window.innerHeight ? window.innerHeight : document.documentElement && document.documentElement.clientHeight ? document.documentElement.clientHeight : -1;
}
const jj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getBodyHeight: dB,
  getBodyWidth: hB,
  getMaxDivHeight: aB,
  getScrollbarWidth: lB,
  getTabIndex: Pw,
  hasOverflowScrolling: zj,
  isBrowserChrome: S_,
  isBrowserEdge: _S,
  isBrowserFirefox: XO,
  isBrowserSafari: CS,
  isIOSUserAgent: ug,
  isInvisibleScrollbar: cB
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var xC;
function $j(n, e, t) {
  for (var i = n.parentElement, r = i && i.firstChild; r; )
    e && r.classList.toggle(e, r === n), t && r.classList.toggle(t, r !== n), r = r.nextSibling;
}
function fB(n) {
  var e = Element.prototype.matches || Element.prototype.msMatchesSelector, t = e.call(n, q.INPUT_SELECTOR), i = e.call(n, q.FOCUSABLE_EXCLUDE), r = hg(n), o = t && !i && r;
  return o;
}
function Wi(n, e) {
  n.classList.toggle("ag-hidden", !e);
}
function pB(n, e) {
  n.classList.toggle("ag-invisible", !e);
}
function Mp(n, e) {
  var t = "disabled", i = e ? function(r) {
    return r.setAttribute(t, "");
  } : function(r) {
    return r.removeAttribute(t);
  };
  i(n), ix(n.querySelectorAll("input"), function(r) {
    return i(r);
  });
}
function yS(n, e, t) {
  for (var i = 0; n; ) {
    if (n.classList.contains(e))
      return !0;
    if (n = n.parentElement, t && ++i > t)
      break;
  }
  return !1;
}
function cg(n) {
  var e = window.getComputedStyle(n), t = e.height, i = e.width, r = e.paddingTop, o = e.paddingRight, s = e.paddingBottom, a = e.paddingLeft, l = e.marginTop, u = e.marginRight, c = e.marginBottom, h = e.marginLeft, d = e.boxSizing;
  return {
    height: parseFloat(t),
    width: parseFloat(i),
    paddingTop: parseFloat(r),
    paddingRight: parseFloat(o),
    paddingBottom: parseFloat(s),
    paddingLeft: parseFloat(a),
    marginTop: parseFloat(l),
    marginRight: parseFloat(u),
    marginBottom: parseFloat(c),
    marginLeft: parseFloat(h),
    boxSizing: d
  };
}
function E_(n) {
  var e = cg(n);
  return e.boxSizing === "border-box" ? e.height - e.paddingTop - e.paddingBottom : e.height;
}
function wS(n) {
  var e = cg(n);
  return e.boxSizing === "border-box" ? e.width - e.paddingLeft - e.paddingRight : e.width;
}
function ZO(n) {
  var e = cg(n), t = e.marginBottom + e.marginTop;
  return Math.ceil(n.offsetHeight + t);
}
function bS(n) {
  var e = cg(n), t = e.marginLeft + e.marginRight;
  return Math.ceil(n.offsetWidth + t);
}
function Av() {
  if (typeof xC == "boolean")
    return xC;
  var n = document.createElement("div");
  return n.style.direction = "rtl", n.style.width = "1px", n.style.height = "1px", n.style.position = "fixed", n.style.top = "0px", n.style.overflow = "hidden", n.dir = "rtl", n.innerHTML = /* html */
  `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`, document.body.appendChild(n), n.scrollLeft = 1, xC = Math.floor(n.scrollLeft) === 0, document.body.removeChild(n), xC;
}
function Mv(n, e) {
  var t = n.scrollLeft;
  return e && (t = Math.abs(t), S_() && !Av() && (t = n.scrollWidth - n.clientWidth - t)), t;
}
function Aw(n, e, t) {
  t && (Av() ? e *= -1 : (CS() || S_()) && (e = n.scrollWidth - n.clientWidth - e)), n.scrollLeft = e;
}
function ys(n) {
  for (; n && n.firstChild; )
    n.removeChild(n.firstChild);
}
function Kj(n, e) {
  Ha(n.querySelector(e));
}
function Ha(n) {
  n && n.parentNode && n.parentNode.removeChild(n);
}
function hg(n) {
  return n.offsetParent !== null;
}
function Dr(n) {
  if (DOMParser !== null) {
    var e = new DOMParser(), t = e.parseFromString(n, "text/html");
    return t.body.firstChild;
  }
  var i = document.createElement("div");
  return i.innerHTML = (n || "").trim(), i.firstChild;
}
function qj(n, e) {
  n.lastChild ? n.insertAdjacentHTML("afterbegin", e) : n.innerHTML = e;
}
function Yj(n, e) {
  if (n.attributes && n.attributes[e]) {
    var t = n.attributes[e];
    return t.value;
  }
  return null;
}
function R1(n) {
  return n && n.clientHeight ? n.clientHeight : 0;
}
function T1(n) {
  return n && n.clientWidth ? n.clientWidth : 0;
}
function QO(n, e, t) {
  t && t.nextSibling === e || (t ? t.nextSibling ? n.insertBefore(e, t.nextSibling) : n.appendChild(e) : n.firstChild && n.firstChild !== e && n.insertAdjacentElement("afterbegin", e));
}
function JO(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t], r = n.children[t];
    r !== i && n.insertBefore(i, r);
  }
}
function gB(n, e, t) {
  t ? t.insertAdjacentElement("afterend", e) : n.firstChild ? n.insertAdjacentElement("afterbegin", e) : n.appendChild(e);
}
function Xj(n, e) {
  de(n.firstChild) ? n.insertBefore(e, n.firstChild) : n.appendChild(e);
}
function ex(n, e) {
  e && Object.keys(e).forEach(function(t) {
    var i = tB(t);
    i && (n.style[i] = e[t]);
  });
}
function O1(n) {
  return n.clientWidth < n.scrollWidth;
}
function mB(n) {
  return n.clientHeight < n.scrollHeight;
}
function L_(n, e) {
  e === "flex" ? (n.style.removeProperty("width"), n.style.removeProperty("minWidth"), n.style.removeProperty("maxWidth"), n.style.flex = "1 1 auto") : Ul(n, e);
}
function Ul(n, e) {
  e = tx(e), n.style.width = e.toString(), n.style.maxWidth = e.toString(), n.style.minWidth = e.toString();
}
function Zj(n, e) {
  e === "flex" ? (n.style.removeProperty("height"), n.style.removeProperty("minHeight"), n.style.removeProperty("maxHeight"), n.style.flex = "1 1 auto") : cd(n, e);
}
function cd(n, e) {
  e = tx(e), n.style.height = e.toString(), n.style.maxHeight = e.toString(), n.style.minHeight = e.toString();
}
function tx(n) {
  return typeof n == "number" ? n + "px" : n;
}
function vB(n) {
  return typeof Node == "function" ? n instanceof Node : n && typeof n == "object" && typeof n.nodeType == "number" && typeof n.nodeName == "string";
}
function _B(n) {
  return typeof HTMLElement == "function" ? n instanceof HTMLElement : n && Pp(n) && n.nodeType === 1 && typeof n.nodeName == "string";
}
function D_(n) {
  return vB(n) || _B(n);
}
function CB(n) {
  if (n == null)
    return [];
  var e = [];
  return ix(n, function(t) {
    return e.push(t);
  }), e;
}
function yB(n, e) {
  if (n)
    for (var t = 0; t < n.length; t++) {
      var i = n[t];
      e(i.name, i.value);
    }
}
function Qj(n, e) {
  typeof e == "boolean" ? (n.checked = e, n.indeterminate = !1) : n.indeterminate = !0;
}
function ev(n, e, t) {
  t == null ? n.removeAttribute(e) : n.setAttribute(e, t.toString());
}
function ix(n, e) {
  if (n != null)
    for (var t = 0; t < n.length; t++)
      e(n[t]);
}
const Jj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addOrRemoveAttribute: ev,
  addStylesToElement: ex,
  appendHtml: qj,
  clearElement: ys,
  copyNodeList: CB,
  ensureDomOrder: QO,
  formatSize: tx,
  getAbsoluteHeight: ZO,
  getAbsoluteWidth: bS,
  getElementAttribute: Yj,
  getElementSize: cg,
  getInnerHeight: E_,
  getInnerWidth: wS,
  getScrollLeft: Mv,
  insertWithDomOrder: gB,
  isElement: _B,
  isElementChildOfClass: yS,
  isFocusableFormField: fB,
  isHorizontalScrollShowing: O1,
  isNode: vB,
  isNodeOrElement: D_,
  isRtlNegativeScroll: Av,
  isVerticalScrollShowing: mB,
  isVisible: hg,
  iterateNamedNodeMap: yB,
  loadTemplate: Dr,
  nodeListForEach: ix,
  offsetHeight: R1,
  offsetWidth: T1,
  prependDC: Xj,
  radioCssClass: $j,
  removeElement: Kj,
  removeFromParent: Ha,
  setCheckboxState: Qj,
  setDisabled: Mp,
  setDisplayed: Wi,
  setDomChildOrder: JO,
  setElementHeight: Zj,
  setElementWidth: L_,
  setFixedHeight: cd,
  setFixedWidth: Ul,
  setScrollLeft: Aw,
  setVisible: pB
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function e$(n) {
  var e = /function (.{1,})\(/, t = n.toString(), i = e.exec(t);
  return i && i.length > 1 ? i[1] : "";
}
function t$(n) {
  var e = n.length, t = 0;
  if (e <= 1)
    return n;
  for (var i = 0; i < n.length; i++) {
    var r = n[i], o = r.toString().split("e-");
    if (o.length > 1) {
      t = Math.max(t, parseInt(o[1], 10));
      continue;
    }
    Math.floor(r) !== r && (t = Math.max(t, r.toString().split(".")[1].length));
  }
  for (var s = 0, a = 0, l = 0, u = 0, c = 0, h = 0; h < e; h++)
    c = n[h], s += h, a += c, u += h * h, l += h * c;
  for (var d = (e * l - s * a) / (e * u - s * s), f = a / e - d * s / e, p = [], h = 0; h <= e; h++)
    p.push(parseFloat((h * d + f).toFixed(t)));
  return p;
}
function i$(n) {
  if (!n)
    return "";
  var e = [];
  return pi(n, function(t, i) {
    var r = eB(t);
    e.push(r + ": " + i + ";");
  }), e.join(" ");
}
function n$(n) {
  var e = document.createElement("div"), t = document.querySelector("#__ag__message");
  if (e.innerHTML = n, !t) {
    var i = '<div id="__ag__message" style="display: inline-block; position: absolute; top: 0px; left: 0px; color: white; background-color: black; z-index: 20; padding: 2px; border: 1px solid darkred; height: 200px; overflow-y: auto;"></div>';
    t = Dr(i), document.body && document.body.appendChild(t);
  }
  t.insertBefore(e, t.children[0]);
}
function r$(n, e) {
  n.then(function(t) {
    var i = t.getGui();
    i != null && (typeof i == "object" ? e.appendChild(i) : e.innerHTML = i);
  });
}
const o$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindCellRendererToHtmlElement: r$,
  cssStyleObjectToMarkup: i$,
  findLineByLeastSquares: t$,
  getNameOfClass: e$,
  message: n$
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function Mr(n, e, t) {
  n.setAttribute(wB(e), t.toString());
}
function dg(n, e) {
  n.removeAttribute(wB(e));
}
function wB(n) {
  return "aria-" + n;
}
function So(n, e) {
  e ? n.setAttribute("role", e) : n.removeAttribute("role");
}
function bB(n) {
  var e;
  return n.isSortAscending() ? e = "ascending" : n.isSortDescending() ? e = "descending" : e = "none", e;
}
function SB(n) {
  return parseInt(n.getAttribute("aria-level"), 10);
}
function EB(n) {
  return parseInt(n.getAttribute("aria-posinset"), 10);
}
function s$(n) {
  return n.getAttribute("aria-describedby") || "";
}
function Ud(n, e) {
  var t = "label";
  e ? Mr(n, t, e) : dg(n, t);
}
function nx(n, e) {
  var t = "labelledby";
  e ? Mr(n, t, e) : dg(n, t);
}
function SS(n, e) {
  var t = "describedby";
  e ? Mr(n, t, e) : dg(n, t);
}
function LB(n, e) {
  Mr(n, "level", e);
}
function Gf(n, e) {
  Mr(n, "disabled", e);
}
function _s(n, e) {
  Mr(n, "expanded", e);
}
function a$(n) {
  dg(n, "expanded");
}
function rx(n, e) {
  Mr(n, "setsize", e);
}
function ox(n, e) {
  Mr(n, "posinset", e);
}
function DB(n, e) {
  Mr(n, "multiselectable", e);
}
function RB(n, e) {
  Mr(n, "rowcount", e);
}
function sx(n, e) {
  Mr(n, "rowindex", e);
}
function TB(n, e) {
  Mr(n, "colcount", e);
}
function ax(n, e) {
  Mr(n, "colindex", e);
}
function OB(n, e) {
  Mr(n, "colspan", e);
}
function xB(n, e) {
  Mr(n, "sort", e);
}
function NB(n) {
  dg(n, "sort");
}
function Fp(n, e) {
  var t = "selected";
  e ? Mr(n, t, e) : dg(n, t);
}
function IB(n, e) {
  Mr(n, "checked", e === void 0 ? "mixed" : e);
}
const l$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAriaDescribedBy: s$,
  getAriaLevel: SB,
  getAriaPosInSet: EB,
  getAriaSortState: bB,
  removeAriaExpanded: a$,
  removeAriaSort: NB,
  setAriaChecked: IB,
  setAriaColCount: TB,
  setAriaColIndex: ax,
  setAriaColSpan: OB,
  setAriaDescribedBy: SS,
  setAriaDisabled: Gf,
  setAriaExpanded: _s,
  setAriaLabel: Ud,
  setAriaLabelledBy: nx,
  setAriaLevel: LB,
  setAriaMultiSelectable: DB,
  setAriaPosInSet: ox,
  setAriaRole: So,
  setAriaRowCount: RB,
  setAriaRowIndex: sx,
  setAriaSelected: Fp,
  setAriaSetSize: rx,
  setAriaSort: xB
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function x1(n, e) {
  return n.toString().padStart(e, "0");
}
function PB(n, e) {
  for (var t = [], i = n; i <= e; i++)
    t.push(i);
  return t;
}
function Mw(n) {
  return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
}
function u$(n) {
  return typeof n == "string" && (n = parseInt(n, 10)), typeof n == "number" ? Math.floor(n) : null;
}
function c$(n, e) {
  for (var t = "", i = 0; i < e; i++)
    t += String.fromCharCode(n & 255), n >>>= 8;
  return t;
}
function h$(n, e, t) {
  return typeof n != "number" ? "" : lx(Math.round(n * 100) / 100, e, t);
}
function lx(n, e, t) {
  return typeof n != "number" ? "" : n.toString().replace(".", t).replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + e);
}
function d$(n) {
  return n == null ? null : n.reduce(function(e, t) {
    return e + t;
  }, 0);
}
const f$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cleanNumber: u$,
  createArrayOfNumbers: PB,
  decToHex: c$,
  formatNumberCommas: lx,
  formatNumberTwoDecimalPlacesAndCommas: h$,
  isNumeric: Mw,
  padStartWidthZeros: x1,
  sum: d$
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var eL = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
};
function Vc(n, e, t) {
  if (e === void 0 && (e = !0), t === void 0 && (t = "-"), !n)
    return null;
  var i = [n.getFullYear(), n.getMonth() + 1, n.getDate()].map(function(r) {
    return x1(r, 2);
  }).join(t);
  return e && (i += " " + [n.getHours(), n.getMinutes(), n.getSeconds()].map(function(r) {
    return x1(r, 2);
  }).join(":")), i;
}
function Bc(n) {
  if (!n)
    return null;
  var e = eL(n.split(" "), 2), t = e[0], i = e[1];
  if (!t)
    return null;
  var r = t.split("-").map(function(p) {
    return parseInt(p, 10);
  });
  if (r.filter(function(p) {
    return !isNaN(p);
  }).length !== 3)
    return null;
  var o = eL(r, 3), s = o[0], a = o[1], l = o[2], u = new Date(s, a - 1, l);
  if (u.getFullYear() !== s || u.getMonth() !== a - 1 || u.getDate() !== l)
    return null;
  if (!i || i === "00:00:00")
    return u;
  var c = eL(i.split(":").map(function(p) {
    return parseInt(p, 10);
  }), 3), h = c[0], d = c[1], f = c[2];
  return h >= 0 && h < 24 && u.setHours(h), d >= 0 && d < 60 && u.setMinutes(d), f >= 0 && f < 60 && u.setSeconds(f), u;
}
const p$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseDateTimeFromString: Bc,
  serialiseDate: Vc
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function AB(n, e, t) {
  var i = {}, r = n.filter(function(o) {
    return !e.some(function(s) {
      return s === o;
    });
  });
  return r.length > 0 && r.forEach(function(o) {
    return i[o] = MB(o, t);
  }), i;
}
function MB(n, e, t, i) {
  var r = i ? kB : FB, o = e.map(function(s) {
    return {
      value: s,
      relevance: r(n.toLowerCase(), s.toLocaleLowerCase())
    };
  });
  return o.sort(function(s, a) {
    return a.relevance - s.relevance;
  }), t && (o = o.filter(function(s) {
    return s.relevance !== 0;
  })), o.map(function(s) {
    return s.value;
  });
}
function N1(n) {
  var e = n.toLowerCase(), t = new Array(e.length - 1), i, r, o;
  for (i = r = 0, o = t.length; r <= o; i = r += 1)
    t[i] = e.slice(i, i + 2);
  return t;
}
function FB(n, e) {
  if (n.length === 0 && e.length === 0)
    return 0;
  var t = N1(n), i = N1(e), r = t.length + i.length, o = 0, s, a;
  for (s = 0, a = t.length; s < a; s++) {
    var l = t[s], u = void 0, c = void 0;
    for (u = 0, c = i.length; u < c; u++) {
      var h = i[u];
      l === h && o++;
    }
  }
  return o > 0 ? 2 * o / r : 0;
}
function kB(n, e) {
  for (var t = n.replace(/\s/g, ""), i = e.replace(/\s/g, ""), r = 0, o = 0, s = 0; s < t.length; s++) {
    var a = i.indexOf(t[s], o);
    a !== -1 && (o = a, r += 100 - o * 100 / 1e4 * 100);
  }
  return r;
}
const g$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fuzzyCheckStrings: AB,
  fuzzySuggestions: MB,
  get_bigrams: N1,
  string_distances: FB,
  string_weighted_distances: kB
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var WB = {
  // header column group shown when expanded (click to contract)
  columnGroupOpened: "expanded",
  // header column group shown when contracted (click to expand)
  columnGroupClosed: "contracted",
  // tool panel column group contracted (click to expand)
  columnSelectClosed: "tree-closed",
  // tool panel column group expanded (click to contract)
  columnSelectOpen: "tree-open",
  // column tool panel header expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  columnSelectIndeterminate: "tree-indeterminate",
  // shown on ghost icon while dragging column to the side of the grid to pin
  columnMovePin: "pin",
  // shown on ghost icon while dragging over part of the page that is not a drop zone
  columnMoveHide: "eye-slash",
  // shown on ghost icon while dragging columns to reorder
  columnMoveMove: "arrows",
  // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
  columnMoveLeft: "left",
  // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
  columnMoveRight: "right",
  // shown on ghost icon while dragging over Row Groups drop zone
  columnMoveGroup: "group",
  // shown on ghost icon while dragging over Values drop zone
  columnMoveValue: "aggregation",
  // shown on ghost icon while dragging over pivot drop zone
  columnMovePivot: "pivot",
  // shown on ghost icon while dragging over drop zone that doesn't support it, e.g.
  //     string column over aggregation drop zone
  dropNotAllowed: "not-allowed",
  // shown on row group when contracted (click to expand)
  groupContracted: "tree-closed",
  // shown on row group when expanded (click to contract)
  groupExpanded: "tree-open",
  // context menu chart item
  chart: "chart",
  // chart window title bar
  close: "cross",
  // X (remove) on column 'pill' after adding it to a drop zone list
  cancel: "cancel",
  // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
  check: "tick",
  // "go to first" button in pagination controls
  first: "first",
  // "go to previous" button in pagination controls
  previous: "previous",
  // "go to next" button in pagination controls
  next: "next",
  // "go to last" button in pagination controls
  last: "last",
  // shown on top right of chart when chart is linked to range data (click to unlink)
  linked: "linked",
  // shown on top right of chart when chart is not linked to range data (click to link)
  unlinked: "unlinked",
  // "Choose colour" button on chart settings tab
  colorPicker: "color-picker",
  // rotating spinner shown by the loading cell renderer
  groupLoading: "loading",
  // button to launch enterprise column menu
  menu: "menu",
  // filter tool panel tab
  filter: "filter",
  // column tool panel tab
  columns: "columns",
  // button in chart regular size window title bar (click to maximise)
  maximize: "maximize",
  // button in chart maximised window title bar (click to make regular size)
  minimize: "minimize",
  // "Pin column" item in column header menu
  menuPin: "pin",
  // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
  menuValue: "aggregation",
  // "Group by {column-name}" item in column header menu
  menuAddRowGroup: "group",
  // "Un-Group by {column-name}" item in column header menu
  menuRemoveRowGroup: "group",
  // context menu copy item
  clipboardCopy: "copy",
  // context menu paste item
  clipboardPaste: "paste",
  // identifies the pivot drop zone
  pivotPanel: "pivot",
  // "Row groups" drop zone in column tool panel
  rowGroupPanel: "group",
  // columns tool panel Values drop zone
  valuePanel: "aggregation",
  // drag handle used to pick up draggable columns
  columnDrag: "grip",
  // drag handle used to pick up draggable rows
  rowDrag: "grip",
  // context menu export item
  save: "save",
  // csv export
  csvExport: "csv",
  // excel export,
  excelExport: "excel",
  // icon on dropdown editors
  smallDown: "small-down",
  // version of small-right used in RTL mode
  smallLeft: "small-left",
  // separater between column 'pills' when you add multiple columns to the header drop zone
  smallRight: "small-right",
  smallUp: "small-up",
  // show on column header when column is sorted ascending
  sortAscending: "asc",
  // show on column header when column is sorted descending
  sortDescending: "desc",
  // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
  sortUnSort: "none"
};
function Js(n, e, t) {
  var i = Kn(n, e, t);
  if (i && i.className.indexOf("ag-icon") > -1)
    return i;
  var r = document.createElement("span");
  return r.appendChild(i), r;
}
function Kn(n, e, t, i) {
  var r = null, o = t && t.getColDef().icons;
  if (o && (r = o[n]), e && !r) {
    var s = e.getIcons();
    s && (r = s[n]);
  }
  if (r) {
    var a = void 0;
    if (typeof r == "function")
      a = r();
    else if (typeof r == "string")
      a = r;
    else
      throw new Error("icon from grid options needs to be a string or a function");
    if (typeof a == "string")
      return Dr(a);
    if (D_(a))
      return a;
    console.warn("AG Grid: iconRenderer should return back a string or a dom object");
  } else {
    var l = document.createElement("span"), u = WB[n];
    return u || (i ? u = n : (console.warn("AG Grid: Did not find icon " + n), u = "")), l.setAttribute("class", "ag-icon ag-icon-" + u), l.setAttribute("unselectable", "on"), So(l, "presentation"), l;
  }
}
const m$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createIcon: Js,
  createIconNoSpan: Kn,
  iconNameClassMap: WB
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var v$ = "Del", _$ = 46;
function VB(n) {
  if (n.altKey || n.ctrlKey || n.metaKey)
    return !1;
  var e = n.key.length === 1, t = C$(n);
  return e || t;
}
function Fw(n, e, t, i, r) {
  var o = n.getSuppressKeyboardEventFunc(), s = i ? i.getColDef().suppressKeyboardEvent : void 0;
  if (!o && !s)
    return !1;
  var a = {
    event: e,
    editing: r,
    column: i,
    api: n.getApi(),
    node: t,
    data: t.data,
    colDef: i.getColDef(),
    context: n.getContext(),
    columnApi: n.getColumnApi()
  };
  if (s) {
    var l = s(a);
    if (l)
      return !0;
  }
  return o ? o(a) : !1;
}
function BB(n, e, t, i) {
  var r = i.getDefinition(), o = r && r.suppressHeaderKeyboardEvent;
  if (!de(o))
    return !1;
  var s = {
    api: n.getApi(),
    columnApi: n.getColumnApi(),
    context: n.getContext(),
    colDef: r,
    column: i,
    headerRowIndex: t,
    event: e
  };
  return !!o(s);
}
function C$(n) {
  return _S() && n.key === v$ && n.charCode === _$;
}
const y$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isEventFromPrintableCharacter: VB,
  isUserSuppressingHeaderKeyboardEvent: BB,
  isUserSuppressingKeyboardEvent: Fw
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function ux(n, e, t) {
  if (t === 0)
    return !1;
  var i = Math.abs(n.clientX - e.clientX), r = Math.abs(n.clientY - e.clientY);
  return Math.max(i, r) <= t;
}
const w$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  areEventsNear: ux
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function b$(n, e) {
  if (n) {
    for (var t = function(a, l) {
      var u = e[a.id], c = e[l.id], h = u !== void 0, d = c !== void 0, f = h && d, p = !h && !d;
      return f ? u - c : p ? a.__objectId - l.__objectId : h ? 1 : -1;
    }, i, r, o = !1, s = 0; s < n.length - 1; s++)
      if (i = n[s], r = n[s + 1], t(i, r) > 0) {
        o = !0;
        break;
      }
    o && n.sort(t);
  }
}
function S$(n, e) {
  var t = [];
  i(n);
  function i(r) {
    r && r.forEach(function(o) {
      if (o.group || o.hasChildren()) {
        t.push(o.key);
        var s = t.join("|");
        e(o, s), i(o.childrenAfterGroup), t.pop();
      }
    });
  }
}
const E$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sortRowNodesByOrder: b$,
  traverseNodesWithKey: S$
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function cx(n) {
  var e = /* @__PURE__ */ new Set();
  return n.forEach(function(t) {
    return e.add(t);
  }), e;
}
const L$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  convertToSet: cx
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var wn = globalThis && globalThis.__assign || function() {
  return wn = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, wn.apply(this, arguments);
}, D$ = wn(wn(wn(wn(wn(wn(wn(wn(wn(wn(wn(wn(wn(wn(wn(wn(wn(wn(wn(wn({}, o$), l$), hj), jj), Hj), p$), Jj), vj), ej), g$), U9), m$), y$), Dj), w$), f$), Y9), E$), L$), Sj), Sd = D$;
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var ES = (
  /** @class */
  function() {
    function n(e, t) {
      e === void 0 && (e = 0), t === void 0 && (t = 1), this.nextValue = e, this.step = t;
    }
    return n.prototype.next = function() {
      var e = this.nextValue;
      return this.nextValue += this.step, e;
    }, n.prototype.peek = function() {
      return this.nextValue;
    }, n.prototype.skip = function(e) {
      this.nextValue += e;
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Zh;
(function(n) {
  n[n.IN_PROGRESS = 0] = "IN_PROGRESS", n[n.RESOLVED = 1] = "RESOLVED";
})(Zh || (Zh = {}));
var ko = (
  /** @class */
  function() {
    function n(e) {
      var t = this;
      this.status = Zh.IN_PROGRESS, this.resolution = null, this.waiters = [], e(function(i) {
        return t.onDone(i);
      }, function(i) {
        return t.onReject(i);
      });
    }
    return n.all = function(e) {
      return new n(function(t) {
        var i = e.length, r = new Array(i);
        e.forEach(function(o, s) {
          o.then(function(a) {
            r[s] = a, i--, i === 0 && t(r);
          });
        });
      });
    }, n.resolve = function(e) {
      return e === void 0 && (e = null), new n(function(t) {
        return t(e);
      });
    }, n.prototype.then = function(e) {
      var t = this;
      return new n(function(i) {
        t.status === Zh.RESOLVED ? i(e(t.resolution)) : t.waiters.push(function(r) {
          return i(e(r));
        });
      });
    }, n.prototype.resolveNow = function(e, t) {
      return this.status === Zh.RESOLVED ? t(this.resolution) : e;
    }, n.prototype.onDone = function(e) {
      this.status = Zh.RESOLVED, this.resolution = e, this.waiters.forEach(function(t) {
        return t(e);
      });
    }, n.prototype.onReject = function(e) {
      console.warn("TBI");
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var R$ = (
  /** @class */
  function() {
    function n() {
      this.timestamp = (/* @__PURE__ */ new Date()).getTime();
    }
    return n.prototype.print = function(e) {
      var t = (/* @__PURE__ */ new Date()).getTime() - this.timestamp;
      console.info(e + " = " + t), this.timestamp = (/* @__PURE__ */ new Date()).getTime();
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var T$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), I1 = globalThis && globalThis.__assign || function() {
  return I1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, I1.apply(this, arguments);
}, em = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Ta;
(function(n) {
  n[n.NOTHING = 0] = "NOTHING", n[n.WAITING_TO_SHOW = 1] = "WAITING_TO_SHOW", n[n.SHOWING = 2] = "SHOWING";
})(Ta || (Ta = {}));
var LS = (
  /** @class */
  function(n) {
    T$(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.DEFAULT_SHOW_TOOLTIP_DELAY = 2e3, i.DEFAULT_HIDE_TOOLTIP_DELAY = 1e4, i.SHOW_QUICK_TOOLTIP_DIFF = 1e3, i.FADE_OUT_TOOLTIP_TIMEOUT = 1e3, i.state = Ta.NOTHING, i.tooltipInstanceCount = 0, i.tooltipMouseTrack = !1, i.parentComp = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.tooltipShowDelay = this.gridOptionsWrapper.getTooltipDelay("show") || this.DEFAULT_SHOW_TOOLTIP_DELAY, this.tooltipHideDelay = this.gridOptionsWrapper.getTooltipDelay("hide") || this.DEFAULT_HIDE_TOOLTIP_DELAY, this.tooltipMouseTrack = this.gridOptionsWrapper.isTooltipMouseTrack();
      var t = this.parentComp.getGui();
      this.addManagedListener(t, "mouseenter", this.onMouseEnter.bind(this)), this.addManagedListener(t, "mouseleave", this.onMouseLeave.bind(this)), this.addManagedListener(t, "mousemove", this.onMouseMove.bind(this)), this.addManagedListener(t, "mousedown", this.onMouseDown.bind(this)), this.addManagedListener(t, "keydown", this.onKeyDown.bind(this));
    }, e.prototype.destroy = function() {
      this.setToDoNothing(), n.prototype.destroy.call(this);
    }, e.prototype.onMouseEnter = function(t) {
      if (!ug() && this.state == Ta.NOTHING) {
        var i = this.isLastTooltipHiddenRecently() ? 200 : this.tooltipShowDelay;
        this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), i), this.lastMouseEvent = t, this.state = Ta.WAITING_TO_SHOW;
      }
    }, e.prototype.onMouseLeave = function() {
      this.setToDoNothing();
    }, e.prototype.onKeyDown = function() {
      this.setToDoNothing();
    }, e.prototype.setToDoNothing = function() {
      this.state === Ta.SHOWING && this.hideTooltip(), this.clearTimeouts(), this.state = Ta.NOTHING;
    }, e.prototype.onMouseMove = function(t) {
      this.lastMouseEvent = t, this.tooltipMouseTrack && this.state === Ta.SHOWING && this.tooltipComp && this.positionTooltipUnderLastMouseEvent();
    }, e.prototype.onMouseDown = function() {
      this.setToDoNothing();
    }, e.prototype.hideTooltip = function() {
      this.tooltipComp && (this.destroyTooltipComp(), e.lastTooltipHideTime = (/* @__PURE__ */ new Date()).getTime()), this.state = Ta.NOTHING;
    }, e.prototype.destroyTooltipComp = function() {
      var t = this;
      this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
      var i = this.tooltipPopupDestroyFunc, r = this.tooltipComp;
      window.setTimeout(function() {
        i(), t.getContext().destroyBean(r);
      }, this.FADE_OUT_TOOLTIP_TIMEOUT), this.tooltipPopupDestroyFunc = void 0, this.tooltipComp = void 0;
    }, e.prototype.isLastTooltipHiddenRecently = function() {
      var t = (/* @__PURE__ */ new Date()).getTime(), i = e.lastTooltipHideTime;
      return t - i < this.SHOW_QUICK_TOOLTIP_DIFF;
    }, e.prototype.showTooltip = function() {
      var t = I1({ api: this.gridApi, columnApi: this.columnApi, context: this.gridOptionsWrapper.getContext() }, this.parentComp.getTooltipParams());
      if (!de(t.value)) {
        this.setToDoNothing();
        return;
      }
      this.state = Ta.SHOWING, this.tooltipInstanceCount++;
      var i = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount), r = this.userComponentFactory.getTooltipCompDetails(t);
      r.newAgStackInstance().then(i);
    }, e.prototype.newTooltipComponentCallback = function(t, i) {
      var r = this.state !== Ta.SHOWING || this.tooltipInstanceCount !== t;
      if (r) {
        this.getContext().destroyBean(i);
        return;
      }
      var o = i.getGui();
      this.tooltipComp = i, o.classList.contains("ag-tooltip") || o.classList.add("ag-tooltip-custom");
      var s = this.gridOptionsWrapper.getLocaleTextFunc(), a = this.popupService.addPopup({
        eChild: o,
        ariaLabel: s("ariaLabelTooltip", "Tooltip")
      });
      a && (this.tooltipPopupDestroyFunc = a.hideFunc), this.positionTooltipUnderLastMouseEvent(), this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.tooltipHideDelay);
    }, e.prototype.positionTooltipUnderLastMouseEvent = function() {
      this.popupService.positionPopupUnderMouseEvent({
        type: "tooltip",
        mouseEvent: this.lastMouseEvent,
        ePopup: this.tooltipComp.getGui(),
        nudgeY: 18
      });
    }, e.prototype.clearTimeouts = function() {
      this.showTooltipTimeoutId && (window.clearTimeout(this.showTooltipTimeoutId), this.showTooltipTimeoutId = void 0), this.hideTooltipTimeoutId && (window.clearTimeout(this.hideTooltipTimeoutId), this.hideTooltipTimeoutId = void 0);
    }, em([
      R("popupService")
    ], e.prototype, "popupService", void 0), em([
      R("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), em([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), em([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), em([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var O$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), tL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, x$ = new ES(), HB = (
  /** @class */
  function() {
    function n(e) {
      this.cssClassStates = {}, this.getGui = e;
    }
    return n.prototype.addCssClass = function(e) {
      var t = this.cssClassStates[e] !== !0;
      t && e.length && (this.getGui().classList.add(e), this.cssClassStates[e] = !0);
    }, n.prototype.removeCssClass = function(e) {
      var t = this.cssClassStates[e] !== !1;
      t && e.length && (this.getGui().classList.remove(e), this.cssClassStates[e] = !1);
    }, n.prototype.containsCssClass = function(e) {
      return this.getGui().classList.contains(e);
    }, n.prototype.addOrRemoveCssClass = function(e, t) {
      var i = this.cssClassStates[e] !== t;
      i && e.length && (this.getGui().classList.toggle(e, t), this.cssClassStates[e] = t);
    }, n;
  }()
), St = (
  /** @class */
  function(n) {
    O$(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.displayed = !0, i.visible = !0, i.compId = x$.next(), i.cssClassManager = new HB(function() {
        return i.eGui;
      }), t && i.setTemplate(t), i;
    }
    return e.prototype.preConstructOnComponent = function() {
      this.usingBrowserTooltips = this.gridOptionsWrapper.isEnableBrowserTooltips();
    }, e.prototype.getCompId = function() {
      return this.compId;
    }, e.prototype.getTooltipParams = function() {
      return {
        value: this.tooltipText,
        location: "UNKNOWN"
      };
    }, e.prototype.setTooltip = function(t) {
      var i = this, r = function() {
        i.usingBrowserTooltips ? i.getGui().removeAttribute("title") : i.tooltipFeature = i.destroyBean(i.tooltipFeature);
      }, o = function() {
        i.usingBrowserTooltips ? i.getGui().setAttribute("title", i.tooltipText) : i.tooltipFeature = i.createBean(new LS(i));
      };
      this.tooltipText != t && (this.tooltipText && r(), t != null && (this.tooltipText = t, this.tooltipText && o()));
    }, e.prototype.createChildComponentsFromTags = function(t, i) {
      var r = this, o = CB(t.childNodes);
      o.forEach(function(s) {
        if (s instanceof HTMLElement) {
          var a = r.createComponentFromElement(s, function(u) {
            var c = u.getGui();
            c && r.copyAttributesFromNode(s, u.getGui());
          }, i);
          if (a) {
            if (a.addItems && s.children.length) {
              r.createChildComponentsFromTags(s, i);
              var l = Array.prototype.slice.call(s.children);
              a.addItems(l);
            }
            r.swapComponentForNode(a, t, s);
          } else
            s.childNodes && r.createChildComponentsFromTags(s, i);
        }
      });
    }, e.prototype.createComponentFromElement = function(t, i, r) {
      var o = t.nodeName, s = r ? r[t.getAttribute("ref")] : void 0, a = this.agStackComponentsRegistry.getComponentClass(o);
      if (a) {
        e.elementGettingCreated = t;
        var l = new a(s);
        return l.setParentComponent(this), this.createBean(l, null, i), l;
      }
      return null;
    }, e.prototype.copyAttributesFromNode = function(t, i) {
      yB(t.attributes, function(r, o) {
        return i.setAttribute(r, o);
      });
    }, e.prototype.swapComponentForNode = function(t, i, r) {
      var o = t.getGui();
      i.replaceChild(o, r), i.insertBefore(document.createComment(r.nodeName), o), this.addDestroyFunc(this.destroyBean.bind(this, t)), this.swapInComponentForQuerySelectors(t, r);
    }, e.prototype.swapInComponentForQuerySelectors = function(t, i) {
      var r = this;
      this.iterateOverQuerySelectors(function(o) {
        r[o.attributeName] === i && (r[o.attributeName] = t);
      });
    }, e.prototype.iterateOverQuerySelectors = function(t) {
      for (var i = Object.getPrototypeOf(this); i != null; ) {
        var r = i.__agComponentMetaData, o = vS(i.constructor);
        r && r[o] && r[o].querySelectors && r[o].querySelectors.forEach(function(s) {
          return t(s);
        }), i = Object.getPrototypeOf(i);
      }
    }, e.prototype.setTemplate = function(t, i) {
      var r = Dr(t);
      this.setTemplateFromElement(r, i);
    }, e.prototype.setTemplateFromElement = function(t, i) {
      this.eGui = t, this.eGui.__agComponent = this, this.wireQuerySelectors(), this.getContext() && this.createChildComponentsFromTags(this.getGui(), i);
    }, e.prototype.createChildComponentsPreConstruct = function() {
      this.getGui() && this.createChildComponentsFromTags(this.getGui());
    }, e.prototype.wireQuerySelectors = function() {
      var t = this;
      if (this.eGui) {
        var i = this;
        this.iterateOverQuerySelectors(function(r) {
          var o = function(l) {
            return i[r.attributeName] = l;
          }, s = r.refSelector && t.eGui.getAttribute("ref") === r.refSelector;
          if (s)
            o(t.eGui);
          else {
            var a = t.eGui.querySelector(r.querySelector);
            a && o(a.__agComponent || a);
          }
        });
      }
    }, e.prototype.getGui = function() {
      return this.eGui;
    }, e.prototype.getFocusableElement = function() {
      return this.eGui;
    }, e.prototype.setParentComponent = function(t) {
      this.parentComponent = t;
    }, e.prototype.getParentComponent = function() {
      return this.parentComponent;
    }, e.prototype.setGui = function(t) {
      this.eGui = t;
    }, e.prototype.queryForHtmlElement = function(t) {
      return this.eGui.querySelector(t);
    }, e.prototype.queryForHtmlInputElement = function(t) {
      return this.eGui.querySelector(t);
    }, e.prototype.appendChild = function(t, i) {
      if (i || (i = this.eGui), t != null)
        if (D_(t))
          i.appendChild(t);
        else {
          var r = t;
          i.appendChild(r.getGui()), this.addDestroyFunc(this.destroyBean.bind(this, r));
        }
    }, e.prototype.isDisplayed = function() {
      return this.displayed;
    }, e.prototype.setVisible = function(t) {
      t !== this.visible && (this.visible = t, pB(this.eGui, t));
    }, e.prototype.setDisplayed = function(t) {
      if (t !== this.displayed) {
        this.displayed = t, Wi(this.eGui, t);
        var i = {
          type: e.EVENT_DISPLAYED_CHANGED,
          visible: this.displayed
        };
        this.dispatchEvent(i);
      }
    }, e.prototype.destroy = function() {
      this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), n.prototype.destroy.call(this);
    }, e.prototype.addGuiEventListener = function(t, i) {
      var r = this;
      this.eGui.addEventListener(t, i), this.addDestroyFunc(function() {
        return r.eGui.removeEventListener(t, i);
      });
    }, e.prototype.addCssClass = function(t) {
      this.cssClassManager.addCssClass(t);
    }, e.prototype.removeCssClass = function(t) {
      this.cssClassManager.removeCssClass(t);
    }, e.prototype.containsCssClass = function(t) {
      return this.cssClassManager.containsCssClass(t);
    }, e.prototype.addOrRemoveCssClass = function(t, i) {
      this.cssClassManager.addOrRemoveCssClass(t, i);
    }, e.prototype.getAttribute = function(t) {
      var i = this.eGui;
      return i ? i.getAttribute(t) : null;
    }, e.prototype.getRefElement = function(t) {
      return this.queryForHtmlElement('[ref="' + t + '"]');
    }, e.EVENT_DISPLAYED_CHANGED = "displayedChanged", tL([
      R("agStackComponentsRegistry")
    ], e.prototype, "agStackComponentsRegistry", void 0), tL([
      C1
    ], e.prototype, "preConstructOnComponent", null), tL([
      C1
    ], e.prototype, "createChildComponentsPreConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function N$(n) {
  return GB.bind(this, n, void 0);
}
function fe(n) {
  return GB.bind(this, "[ref=" + n + "]", n);
}
function GB(n, e, t, i, r) {
  if (n === null) {
    console.error("AG Grid: QuerySelector selector should not be null");
    return;
  }
  if (typeof r == "number") {
    console.error("AG Grid: QuerySelector should be on an attribute");
    return;
  }
  I$(t, "querySelectors", {
    attributeName: i,
    querySelector: n,
    refSelector: e
  });
}
function I$(n, e, t) {
  var i = P$(n, vS(n.constructor));
  i[e] || (i[e] = []), i[e].push(t);
}
function P$(n, e) {
  return n.__agComponentMetaData || (n.__agComponentMetaData = {}), n.__agComponentMetaData[e] || (n.__agComponentMetaData[e] = {}), n.__agComponentMetaData[e];
}
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var A$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), tM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, M$ = (
  /** @class */
  function(n) {
    A$(e, n);
    function e() {
      return n.call(
        this,
        /* html */
        `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eFloatingFilterText"></ag-input-text-field>
            </div>`
      ) || this;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.init = function(t) {
      this.params = t;
      var i = this.columnModel.getDisplayNameForColumn(t.column, "header", !0), r = this.gridOptionsWrapper.getLocaleTextFunc();
      this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(i + " " + r("ariaFilterInput", "Filter Input"));
    }, e.prototype.onParentModelChanged = function(t) {
      var i = this;
      if (!t) {
        this.eFloatingFilterText.setValue("");
        return;
      }
      this.params.parentFilterInstance(function(r) {
        if (r.getModelAsString) {
          var o = r.getModelAsString(t);
          i.eFloatingFilterText.setValue(o);
        }
      });
    }, tM([
      fe("eFloatingFilterText")
    ], e.prototype, "eFloatingFilterText", void 0), tM([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var UB = (
  /** @class */
  function() {
    function n(e, t, i, r) {
      var o = this;
      this.alive = !0, this.context = e, this.eParent = r;
      var s = t.getDateCompDetails(i), a = s.newAgStackInstance();
      a.then(function(l) {
        if (!o.alive) {
          e.destroyBean(l);
          return;
        }
        o.dateComp = l, l && (r.appendChild(l.getGui()), l.afterGuiAttached && l.afterGuiAttached(), o.tempValue && l.setDate(o.tempValue), o.disabled != null && o.setDateCompDisabled(o.disabled));
      });
    }
    return n.prototype.destroy = function() {
      this.alive = !1, this.dateComp = this.context.destroyBean(this.dateComp);
    }, n.prototype.getDate = function() {
      return this.dateComp ? this.dateComp.getDate() : this.tempValue;
    }, n.prototype.setDate = function(e) {
      this.dateComp ? this.dateComp.setDate(e) : this.tempValue = e;
    }, n.prototype.setDisabled = function(e) {
      this.dateComp ? this.setDateCompDisabled(e) : this.disabled = e;
    }, n.prototype.setDisplayed = function(e) {
      Wi(this.eParent, e);
    }, n.prototype.setInputPlaceholder = function(e) {
      this.dateComp && this.dateComp.setInputPlaceholder && this.dateComp.setInputPlaceholder(e);
    }, n.prototype.setInputAriaLabel = function(e) {
      this.dateComp && this.dateComp.setInputAriaLabel && this.dateComp.setInputAriaLabel(e);
    }, n.prototype.afterGuiAttached = function(e) {
      this.dateComp && typeof this.dateComp.afterGuiAttached == "function" && this.dateComp.afterGuiAttached(e);
    }, n.prototype.setDateCompDisabled = function(e) {
      this.dateComp != null && this.dateComp.setDisabled != null && this.dateComp.setDisabled(e);
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var P1 = globalThis && globalThis.__assign || function() {
  return P1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, P1.apply(this, arguments);
}, zB = (
  /** @class */
  function() {
    function n() {
      this.customFilterOptions = {};
    }
    return n.prototype.init = function(e, t) {
      this.filterOptions = e.filterOptions || t, this.mapCustomOptions(), this.selectDefaultItem(e), this.checkForDeprecatedParams();
    }, n.prototype.checkForDeprecatedParams = function() {
      this.filterOptions.some(function(e) {
        return typeof e != "string" && e.test != null;
      }) && console.warn("AG Grid: [IFilterOptionDef] since v26.2.0, test() has been replaced with predicate()."), this.filterOptions.some(function(e) {
        return typeof e != "string" && e.hideFilterInput != null;
      }) && console.warn("AG Grid: [IFilterOptionDef] since v26.2.0, useOfHideFilterInput has been replaced with numberOfInputs.");
    }, n.prototype.getFilterOptions = function() {
      return this.filterOptions;
    }, n.prototype.mapCustomOptions = function() {
      var e = this;
      this.filterOptions && this.filterOptions.forEach(function(t) {
        if (typeof t != "string") {
          var i = [["displayKey"], ["displayName"], ["predicate", "test"]], r = function(a) {
            return a.some(function(l) {
              return t[l] != null;
            }) ? !0 : (console.warn("AG Grid: ignoring FilterOptionDef as it doesn't contain one of '" + a + "'"), !1);
          };
          if (!i.every(r)) {
            e.filterOptions = e.filterOptions.filter(function(a) {
              return a === t;
            }) || [];
            return;
          }
          var o = t.test, s = P1({}, t);
          o != null && t.predicate == null && (s.predicate = function(a, l) {
            return o(a[0], l);
          }, delete s.test), s.hideFilterInput && s.numberOfInputs == null && (s.numberOfInputs = 0, delete s.hideFilterInput), e.customFilterOptions[t.displayKey] = s;
        }
      });
    }, n.prototype.selectDefaultItem = function(e) {
      if (e.defaultOption)
        this.defaultOption = e.defaultOption;
      else if (this.filterOptions.length >= 1) {
        var t = this.filterOptions[0];
        typeof t == "string" ? this.defaultOption = t : t.displayKey ? this.defaultOption = t.displayKey : console.warn("AG Grid: invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'");
      } else
        console.warn("AG Grid: no filter options for filter");
    }, n.prototype.getDefaultOption = function() {
      return this.defaultOption;
    }, n.prototype.getCustomOption = function(e) {
      return this.customFilterOptions[e];
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var F$ = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose One",
  equals: "Equals",
  notEqual: "Not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "In range",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equals",
  greaterThanOrEqual: "Greater than or equals",
  contains: "Contains",
  notContains: "Not contains",
  startsWith: "Starts with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd"
};
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var pe = (
  /** @class */
  function() {
    function n() {
    }
    return n.BACKSPACE = "Backspace", n.TAB = "Tab", n.ENTER = "Enter", n.ESCAPE = "Escape", n.SPACE = " ", n.LEFT = "ArrowLeft", n.UP = "ArrowUp", n.RIGHT = "ArrowRight", n.DOWN = "ArrowDown", n.DELETE = "Delete", n.A = "A", n.C = "C", n.V = "V", n.D = "D", n.Z = "Z", n.Y = "Y", n.F2 = "F2", n.PAGE_UP = "PageUp", n.PAGE_DOWN = "PageDown", n.PAGE_HOME = "Home", n.PAGE_END = "End", n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var k$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), A1 = globalThis && globalThis.__assign || function() {
  return A1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, A1.apply(this, arguments);
}, iM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Qu = (
  /** @class */
  function(n) {
    k$(e, n);
    function e(t, i) {
      i === void 0 && (i = {});
      var r = n.call(this) || this;
      return r.eFocusableElement = t, r.callbacks = i, r.callbacks = A1({ shouldStopEventPropagation: function() {
        return !1;
      }, onTabKeyDown: function(o) {
        if (!o.defaultPrevented) {
          var s = r.focusService.findNextFocusableElement(r.eFocusableElement, !1, o.shiftKey);
          s && (s.focus(), o.preventDefault());
        }
      } }, i), r;
    }
    return e.prototype.postConstruct = function() {
      this.eFocusableElement.classList.add(e.FOCUS_MANAGED_CLASS), this.addKeyDownListeners(this.eFocusableElement), this.callbacks.onFocusIn && this.addManagedListener(this.eFocusableElement, "focusin", this.callbacks.onFocusIn), this.callbacks.onFocusOut && this.addManagedListener(this.eFocusableElement, "focusout", this.callbacks.onFocusOut);
    }, e.prototype.addKeyDownListeners = function(t) {
      var i = this;
      this.addManagedListener(t, "keydown", function(r) {
        if (!(r.defaultPrevented || Ml(r))) {
          if (i.callbacks.shouldStopEventPropagation(r)) {
            Ap(r);
            return;
          }
          r.key === pe.TAB ? i.callbacks.onTabKeyDown(r) : i.callbacks.handleKeyDown && i.callbacks.handleKeyDown(r);
        }
      });
    }, e.FOCUS_MANAGED_CLASS = "ag-focus-managed", iM([
      R("focusService")
    ], e.prototype, "focusService", void 0), iM([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var W$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), iL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Fv = (
  /** @class */
  function(n) {
    W$(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.filterNameKey = t, i.applyActive = !1, i.hidePopup = null, i.appliedModel = null, i;
    }
    return e.prototype.postConstruct = function() {
      this.resetTemplate(), this.createManagedBean(new Qu(this.getFocusableElement(), {
        handleKeyDown: this.handleKeyDown.bind(this)
      }));
    }, e.prototype.handleKeyDown = function(t) {
    }, e.prototype.getFilterTitle = function() {
      return this.translate(this.filterNameKey);
    }, e.prototype.isFilterActive = function() {
      return !!this.appliedModel;
    }, e.prototype.resetTemplate = function(t) {
      var i = (
        /* html */
        `
            <div class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-` + this.getCssIdentifier() + `-body-wrapper">
                    ` + this.createBodyTemplate() + `
                </div>
            </div>`
      );
      this.setTemplate(i, t);
    }, e.prototype.isReadOnly = function() {
      return !!this.providedFilterParams.readOnly;
    }, e.prototype.init = function(t) {
      var i = this;
      this.setParams(t), this.resetUiToDefaults(!0).then(function() {
        i.updateUiVisibility(), i.setupOnBtApplyDebounce();
      });
    }, e.prototype.setParams = function(t) {
      this.providedFilterParams = t, this.applyActive = e.isUseApplyButton(t), this.createButtonPanel();
    }, e.prototype.createButtonPanel = function() {
      var t = this, i = this.providedFilterParams.buttons;
      if (!(!i || i.length < 1 || this.isReadOnly())) {
        var r = document.createElement("div");
        r.classList.add("ag-filter-apply-panel");
        var o = function(s) {
          var a, l;
          switch (s) {
            case "apply":
              a = t.translate("applyFilter"), l = function(c) {
                return t.onBtApply(!1, !1, c);
              };
              break;
            case "clear":
              a = t.translate("clearFilter"), l = function() {
                return t.onBtClear();
              };
              break;
            case "reset":
              a = t.translate("resetFilter"), l = function() {
                return t.onBtReset();
              };
              break;
            case "cancel":
              a = t.translate("cancelFilter"), l = function(c) {
                t.onBtCancel(c);
              };
              break;
            default:
              console.warn("AG Grid: Unknown button type specified");
              return;
          }
          var u = Dr(
            /* html */
            `<button
                    type="button"
                    ref="` + s + `FilterButton"
                    class="ag-standard-button ag-filter-apply-panel-button"
                >` + a + `
                </button>`
          );
          r.appendChild(u), t.addManagedListener(u, "click", l);
        };
        cx(i).forEach(function(s) {
          return o(s);
        }), this.getGui().appendChild(r);
      }
    }, e.prototype.getDefaultDebounceMs = function() {
      return 0;
    }, e.prototype.setupOnBtApplyDebounce = function() {
      var t = e.getDebounceMs(this.providedFilterParams, this.getDefaultDebounceMs());
      this.onBtApplyDebounce = th(this.onBtApply.bind(this), t);
    }, e.prototype.getModel = function() {
      return this.appliedModel ? this.appliedModel : null;
    }, e.prototype.setModel = function(t) {
      var i = this, r = t != null ? this.setModelIntoUi(t) : this.resetUiToDefaults();
      return r.then(function() {
        i.updateUiVisibility(), i.applyModel();
      });
    }, e.prototype.onBtCancel = function(t) {
      var i = this, r = this.getModel(), o = function() {
        i.onUiChanged(!1, "prevent"), i.providedFilterParams.closeOnApply && i.close(t);
      };
      r != null ? this.setModelIntoUi(r).then(o) : this.resetUiToDefaults().then(o);
    }, e.prototype.onBtClear = function() {
      var t = this;
      this.resetUiToDefaults().then(function() {
        return t.onUiChanged();
      });
    }, e.prototype.onBtReset = function() {
      this.onBtClear(), this.onBtApply();
    }, e.prototype.applyModel = function() {
      var t = this.getModelFromUi();
      if (!this.isModelValid(t))
        return !1;
      var i = this.appliedModel;
      return this.appliedModel = t, !this.areModelsEqual(i, t);
    }, e.prototype.isModelValid = function(t) {
      return !0;
    }, e.prototype.onBtApply = function(t, i, r) {
      t === void 0 && (t = !1), i === void 0 && (i = !1), this.applyModel() && this.providedFilterParams.filterChangedCallback({ afterFloatingFilter: t, afterDataChange: i });
      var o = this.providedFilterParams.closeOnApply;
      o && this.applyActive && !t && !i && this.close(r);
    }, e.prototype.onNewRowsLoaded = function() {
    }, e.prototype.close = function(t) {
      if (this.hidePopup) {
        var i = t, r = i && i.key, o;
        (r === "Enter" || r === "Space") && (o = { keyboardEvent: i }), this.hidePopup(o), this.hidePopup = null;
      }
    }, e.prototype.onUiChanged = function(t, i) {
      if (t === void 0 && (t = !1), this.updateUiVisibility(), this.providedFilterParams.filterModifiedCallback(), this.applyActive && !this.isReadOnly) {
        var r = this.isModelValid(this.getModelFromUi());
        Mp(this.getRefElement("applyFilterButton"), !r);
      }
      t && !i || i === "immediately" ? this.onBtApply(t) : (!this.applyActive && !i || i === "debounce") && this.onBtApplyDebounce();
    }, e.prototype.afterGuiAttached = function(t) {
      t != null && (this.hidePopup = t.hidePopup);
    }, e.getDebounceMs = function(t, i) {
      return e.isUseApplyButton(t) ? (t.debounceMs != null && console.warn("AG Grid: debounceMs is ignored when apply button is present"), 0) : t.debounceMs != null ? t.debounceMs : i;
    }, e.isUseApplyButton = function(t) {
      return !!t.buttons && t.buttons.indexOf("apply") >= 0;
    }, e.prototype.destroy = function() {
      this.hidePopup = null, n.prototype.destroy.call(this);
    }, e.prototype.translate = function(t) {
      var i = this.gridOptionsWrapper.getLocaleTextFunc();
      return i(t, F$[t]);
    }, e.prototype.getCellValue = function(t) {
      var i = this.providedFilterParams, r = i.api, o = i.colDef, s = i.column, a = i.columnApi, l = i.context;
      return this.providedFilterParams.valueGetter({
        api: r,
        colDef: o,
        column: s,
        columnApi: a,
        context: l,
        data: t.data,
        getValue: function(u) {
          return t.data[u];
        },
        node: t
      });
    }, iL([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), iL([
      R("valueService")
    ], e.prototype, "valueService", void 0), iL([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var V$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), B$ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, hx = (
  /** @class */
  function(n) {
    V$(e, n);
    function e(t, i) {
      var r = n.call(this, i) || this;
      return r.labelSeparator = "", r.labelAlignment = "left", r.label = "", r.config = t || {}, r;
    }
    return e.prototype.postConstruct = function() {
      this.addCssClass("ag-labeled"), this.eLabel.classList.add("ag-label");
      var t = this.config, i = t.labelSeparator, r = t.label, o = t.labelWidth, s = t.labelAlignment;
      i != null && this.setLabelSeparator(i), r != null && this.setLabel(r), o != null && this.setLabelWidth(o), this.setLabelAlignment(s || this.labelAlignment), this.refreshLabel();
    }, e.prototype.refreshLabel = function() {
      ys(this.eLabel), typeof this.label == "string" ? this.eLabel.innerText = this.label + this.labelSeparator : this.label && this.eLabel.appendChild(this.label), this.label === "" ? (this.eLabel.classList.add("ag-hidden"), So(this.eLabel, "presentation")) : (this.eLabel.classList.remove("ag-hidden"), So(this.eLabel, null));
    }, e.prototype.setLabelSeparator = function(t) {
      return this.labelSeparator === t ? this : (this.labelSeparator = t, this.label != null && this.refreshLabel(), this);
    }, e.prototype.getLabelId = function() {
      return this.eLabel.id = this.eLabel.id || "ag-" + this.getCompId() + "-label", this.eLabel.id;
    }, e.prototype.getLabel = function() {
      return this.label;
    }, e.prototype.setLabel = function(t) {
      return this.label === t ? this : (this.label = t, this.refreshLabel(), this);
    }, e.prototype.setLabelAlignment = function(t) {
      var i = this.getGui(), r = i.classList;
      return r.toggle("ag-label-align-left", t === "left"), r.toggle("ag-label-align-right", t === "right"), r.toggle("ag-label-align-top", t === "top"), this;
    }, e.prototype.setLabelWidth = function(t) {
      return this.label == null ? this : (L_(this.eLabel, t), this);
    }, B$([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var H$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Fl = (
  /** @class */
  function(n) {
    H$(e, n);
    function e(t, i, r) {
      var o = n.call(this, t, i) || this;
      return o.className = r, o.disabled = !1, o;
    }
    return e.prototype.postConstruct = function() {
      n.prototype.postConstruct.call(this), this.className && this.addCssClass(this.className);
    }, e.prototype.onValueChange = function(t) {
      var i = this;
      return this.addManagedListener(this, e.EVENT_CHANGED, function() {
        return t(i.getValue());
      }), this;
    }, e.prototype.getWidth = function() {
      return this.getGui().clientWidth;
    }, e.prototype.setWidth = function(t) {
      return Ul(this.getGui(), t), this;
    }, e.prototype.getPreviousValue = function() {
      return this.previousValue;
    }, e.prototype.getValue = function() {
      return this.value;
    }, e.prototype.setValue = function(t, i) {
      return this.value === t ? this : (this.previousValue = this.value, this.value = t, i || this.dispatchEvent({ type: e.EVENT_CHANGED }), this);
    }, e.prototype.setDisabled = function(t) {
      t = !!t;
      var i = this.getGui();
      return Mp(i, t), i.classList.toggle("ag-disabled", t), this.disabled = t, this;
    }, e.prototype.isDisabled = function() {
      return !!this.disabled;
    }, e.EVENT_CHANGED = "valueChange", e;
  }(hx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var G$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), NC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, jB = (
  /** @class */
  function(n) {
    G$(e, n);
    function e(t, i, r, o) {
      var s = n.call(
        this,
        t,
        /* html */
        `<div class="ag-picker-field" role="presentation">
                <div ref="eLabel"></div>
                <div ref="eWrapper"
                    class="ag-wrapper ag-picker-field-wrapper"
                    tabIndex="-1"
                    aria-expanded="false"
                    ` + (o ? 'role="' + o + '"' : "") + `
                >
                    <div ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`,
        i
      ) || this;
      return s.pickerIcon = r, s.isPickerDisplayed = !1, s.isDestroyingPicker = !1, s.skipClick = !1, s;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      n.prototype.postConstruct.call(this);
      var i = this.getCompId() + "-display";
      this.eDisplayField.setAttribute("id", i), SS(this.eWrapper, i);
      var r = function() {
        if (t.skipClick) {
          t.skipClick = !1;
          return;
        }
        t.isDisabled() || (t.pickerComponent = t.showPicker());
      }, o = this.getGui();
      if (this.addManagedListener(o, "mousedown", function(a) {
        !t.skipClick && t.pickerComponent && t.pickerComponent.isAlive() && hg(t.pickerComponent.getGui()) && o.contains(a.target) && (t.skipClick = !0);
      }), this.addManagedListener(o, "keydown", function(a) {
        switch (a.key) {
          case pe.UP:
          case pe.DOWN:
          case pe.ENTER:
          case pe.SPACE:
            r();
          case pe.ESCAPE:
            t.isPickerDisplayed && a.preventDefault();
            break;
        }
      }), this.addManagedListener(this.eWrapper, "click", r), this.addManagedListener(this.eLabel, "click", r), this.pickerIcon) {
        var s = Kn(this.pickerIcon, this.gridOptionsWrapper);
        s && this.eIcon.appendChild(s);
      }
    }, e.prototype.refreshLabel = function() {
      de(this.getLabel()) ? nx(this.eWrapper, this.getLabelId()) : this.eWrapper.removeAttribute("aria-labelledby"), n.prototype.refreshLabel.call(this);
    }, e.prototype.setAriaLabel = function(t) {
      return Ud(this.eWrapper, t), this;
    }, e.prototype.setInputWidth = function(t) {
      return L_(this.eWrapper, t), this;
    }, e.prototype.getFocusableElement = function() {
      return this.eWrapper;
    }, NC([
      fe("eLabel")
    ], e.prototype, "eLabel", void 0), NC([
      fe("eWrapper")
    ], e.prototype, "eWrapper", void 0), NC([
      fe("eDisplayField")
    ], e.prototype, "eDisplayField", void 0), NC([
      fe("eIcon")
    ], e.prototype, "eIcon", void 0), e;
  }(Fl)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var U$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), z$ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, nM = (
  /** @class */
  function(n) {
    U$(e, n);
    function e(t) {
      t === void 0 && (t = "default");
      var i = n.call(
        this,
        /* html */
        '<div class="ag-list ag-' + t + '-list" role="listbox"></div>'
      ) || this;
      return i.cssIdentifier = t, i.options = [], i.itemEls = [], i;
    }
    return e.prototype.init = function() {
      this.addManagedListener(this.getGui(), "keydown", this.handleKeyDown.bind(this));
    }, e.prototype.handleKeyDown = function(t) {
      var i = t.key;
      switch (i) {
        case pe.ENTER:
          if (!this.highlightedEl)
            this.setValue(this.getValue());
          else {
            var r = this.itemEls.indexOf(this.highlightedEl);
            this.setValueByIndex(r);
          }
          break;
        case pe.DOWN:
        case pe.UP:
          var o = i === pe.DOWN, s = void 0;
          if (t.preventDefault(), !this.highlightedEl)
            s = this.itemEls[o ? 0 : this.itemEls.length - 1];
          else {
            var a = this.itemEls.indexOf(this.highlightedEl), l = a + (o ? 1 : -1);
            l = Math.min(Math.max(l, 0), this.itemEls.length - 1), s = this.itemEls[l];
          }
          this.highlightItem(s);
          break;
      }
    }, e.prototype.addOptions = function(t) {
      var i = this;
      return t.forEach(function(r) {
        return i.addOption(r);
      }), this;
    }, e.prototype.addOption = function(t) {
      var i = t.value, r = t.text, o = Gl(r || i);
      return this.options.push({ value: i, text: o }), this.renderOption(i, o), this.updateIndices(), this;
    }, e.prototype.updateIndices = function() {
      var t = this.getGui().querySelectorAll(".ag-list-item");
      t.forEach(function(i, r) {
        ox(i, r + 1), rx(i, t.length);
      });
    }, e.prototype.renderOption = function(t, i) {
      var r = this, o = document.createElement("div");
      So(o, "option"), o.classList.add("ag-list-item", "ag-" + this.cssIdentifier + "-list-item"), o.innerHTML = "<span>" + i + "</span>", o.tabIndex = -1, this.itemEls.push(o), this.addManagedListener(o, "mouseover", function() {
        return r.highlightItem(o);
      }), this.addManagedListener(o, "mouseleave", function() {
        return r.clearHighlighted();
      }), this.addManagedListener(o, "click", function() {
        return r.setValue(t);
      }), this.getGui().appendChild(o);
    }, e.prototype.setValue = function(t, i) {
      if (this.value === t)
        return this.fireItemSelected(), this;
      if (t == null)
        return this.reset(), this;
      var r = this.options.findIndex(function(s) {
        return s.value === t;
      });
      if (r !== -1) {
        var o = this.options[r];
        this.value = o.value, this.displayValue = o.text != null ? o.text : o.value, this.highlightItem(this.itemEls[r]), i || this.fireChangeEvent();
      }
      return this;
    }, e.prototype.setValueByIndex = function(t) {
      return this.setValue(this.options[t].value);
    }, e.prototype.getValue = function() {
      return this.value;
    }, e.prototype.getDisplayValue = function() {
      return this.displayValue;
    }, e.prototype.refreshHighlighted = function() {
      var t = this;
      this.clearHighlighted();
      var i = this.options.findIndex(function(r) {
        return r.value === t.value;
      });
      i !== -1 && this.highlightItem(this.itemEls[i]);
    }, e.prototype.reset = function() {
      this.value = null, this.displayValue = null, this.clearHighlighted(), this.fireChangeEvent();
    }, e.prototype.highlightItem = function(t) {
      t.offsetParent && (this.clearHighlighted(), this.highlightedEl = t, this.highlightedEl.classList.add(e.ACTIVE_CLASS), Fp(this.highlightedEl, !0), this.highlightedEl.focus());
    }, e.prototype.clearHighlighted = function() {
      !this.highlightedEl || !this.highlightedEl.offsetParent || (this.highlightedEl.classList.remove(e.ACTIVE_CLASS), Fp(this.highlightedEl, !1), this.highlightedEl = null);
    }, e.prototype.fireChangeEvent = function() {
      this.dispatchEvent({ type: Fl.EVENT_CHANGED }), this.fireItemSelected();
    }, e.prototype.fireItemSelected = function() {
      this.dispatchEvent({ type: e.EVENT_ITEM_SELECTED });
    }, e.EVENT_ITEM_SELECTED = "selectedItem", e.ACTIVE_CLASS = "ag-active-item", z$([
      Ee
    ], e.prototype, "init", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var j$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), rM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, dx = (
  /** @class */
  function(n) {
    j$(e, n);
    function e(t) {
      return n.call(this, t, "ag-select", "smallDown", "listbox") || this;
    }
    return e.prototype.init = function() {
      var t = this;
      this.listComponent = this.createBean(new nM("select")), this.listComponent.setParentComponent(this), this.eWrapper.tabIndex = 0, this.listComponent.addManagedListener(this.listComponent, nM.EVENT_ITEM_SELECTED, function() {
        t.hideList && t.hideList();
      }), this.listComponent.addManagedListener(this.listComponent, Fl.EVENT_CHANGED, function() {
        t.setValue(t.listComponent.getValue(), !1, !0), t.hideList && t.hideList();
      });
    }, e.prototype.showPicker = function() {
      var t = this, i = this.listComponent.getGui(), r = this.gridOptionsWrapper.getDocument(), o = this.addManagedListener(r.body, "wheel", function(u) {
        !i.contains(u.target) && t.hideList && t.hideList();
      }), s = this.addManagedListener(i, "focusout", function(u) {
        !i.contains(u.relatedTarget) && t.hideList && t.hideList();
      }), a = this.gridOptionsWrapper.getLocaleTextFunc(), l = this.popupService.addPopup({
        modal: !0,
        eChild: i,
        closeOnEsc: !0,
        closedCallback: function() {
          t.hideList = null, t.isPickerDisplayed = !1, s(), o(), t.isAlive() && (_s(t.eWrapper, !1), t.getFocusableElement().focus());
        },
        ariaLabel: a("ariaLabelSelectField", "Select Field")
      });
      return l && (this.hideList = l.hideFunc), this.isPickerDisplayed = !0, L_(i, bS(this.eWrapper)), _s(this.eWrapper, !0), i.style.maxHeight = E_(this.popupService.getPopupParent()) + "px", i.style.position = "absolute", this.popupService.positionPopupUnderComponent({
        type: "ag-list",
        eventSource: this.eWrapper,
        ePopup: i,
        keepWithinBounds: !0
      }), this.listComponent.refreshHighlighted(), this.listComponent;
    }, e.prototype.addOptions = function(t) {
      var i = this;
      return t.forEach(function(r) {
        return i.addOption(r);
      }), this;
    }, e.prototype.addOption = function(t) {
      return this.listComponent.addOption(t), this;
    }, e.prototype.setValue = function(t, i, r) {
      if (this.value === t)
        return this;
      r || this.listComponent.setValue(t, !0);
      var o = this.listComponent.getValue();
      return o === this.getValue() ? this : (this.eDisplayField.innerHTML = this.listComponent.getDisplayValue(), n.prototype.setValue.call(this, t, i));
    }, e.prototype.destroy = function() {
      this.hideList && this.hideList(), this.destroyBean(this.listComponent), n.prototype.destroy.call(this);
    }, rM([
      R("popupService")
    ], e.prototype, "popupService", void 0), rM([
      Ee
    ], e.prototype, "init", null), e;
  }(jB)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var $$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), nL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Pu = (
  /** @class */
  function(n) {
    $$(e, n);
    function e(t, i, r, o) {
      r === void 0 && (r = "text"), o === void 0 && (o = "input");
      var s = n.call(
        this,
        t,
        /* html */
        `
            <div role="presentation">
                <div ref="eLabel" class="ag-input-field-label"></div>
                <div ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <` + o + ' ref="eInput" class="ag-input-field-input"></' + o + `>
                </div>
            </div>`,
        i
      ) || this;
      return s.inputType = r, s.displayFieldTag = o, s;
    }
    return e.prototype.postConstruct = function() {
      n.prototype.postConstruct.call(this), this.setInputType(), this.eLabel.classList.add(this.className + "-label"), this.eWrapper.classList.add(this.className + "-input-wrapper"), this.eInput.classList.add(this.className + "-input"), this.addCssClass("ag-input-field"), this.eInput.id = this.eInput.id || "ag-" + this.getCompId() + "-input";
      var t = this.config, i = t.width, r = t.value;
      i != null && this.setWidth(i), r != null && this.setValue(r), this.addInputListeners();
    }, e.prototype.refreshLabel = function() {
      de(this.getLabel()) ? nx(this.eInput, this.getLabelId()) : this.eInput.removeAttribute("aria-labelledby"), n.prototype.refreshLabel.call(this);
    }, e.prototype.addInputListeners = function() {
      var t = this;
      this.addManagedListener(this.eInput, "input", function(i) {
        return t.setValue(i.target.value);
      });
    }, e.prototype.setInputType = function() {
      this.displayFieldTag === "input" && this.eInput.setAttribute("type", this.inputType);
    }, e.prototype.getInputElement = function() {
      return this.eInput;
    }, e.prototype.setInputWidth = function(t) {
      return L_(this.eWrapper, t), this;
    }, e.prototype.setInputName = function(t) {
      return this.getInputElement().setAttribute("name", t), this;
    }, e.prototype.getFocusableElement = function() {
      return this.eInput;
    }, e.prototype.setMaxLength = function(t) {
      var i = this.eInput;
      return i.maxLength = t, this;
    }, e.prototype.setInputPlaceholder = function(t) {
      return ev(this.eInput, "placeholder", t), this;
    }, e.prototype.setInputAriaLabel = function(t) {
      return Ud(this.eInput, t), this;
    }, e.prototype.setDisabled = function(t) {
      return Mp(this.eInput, t), n.prototype.setDisabled.call(this, t);
    }, nL([
      fe("eLabel")
    ], e.prototype, "eLabel", void 0), nL([
      fe("eWrapper")
    ], e.prototype, "eWrapper", void 0), nL([
      fe("eInput")
    ], e.prototype, "eInput", void 0), e;
  }(Fl)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var K$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Th = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, jr;
(function(n) {
  n[n.One = 0] = "One", n[n.Two = 1] = "Two";
})(jr || (jr = {}));
var bn = (
  /** @class */
  function(n) {
    K$(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getNumberOfInputs = function(t) {
      var i = this.optionsFactory.getCustomOption(t);
      if (i) {
        var r = i.numberOfInputs;
        return r ?? 1;
      }
      var o = [
        e.EMPTY,
        e.NOT_BLANK,
        e.BLANK
      ];
      return t && o.indexOf(t) >= 0 ? 0 : t === e.IN_RANGE ? 2 : 1;
    }, e.prototype.onFloatingFilterChanged = function(t, i) {
      this.setTypeFromFloatingFilter(t), this.setValueFromFloatingFilter(i), this.onUiChanged(!0);
    }, e.prototype.setTypeFromFloatingFilter = function(t) {
      this.eType1.setValue(t), this.eType2.setValue(this.optionsFactory.getDefaultOption()), (this.isDefaultOperator("AND") ? this.eJoinOperatorAnd : this.eJoinOperatorOr).setValue(!0);
    }, e.prototype.getModelFromUi = function() {
      return this.isConditionUiComplete(jr.One) ? this.isAllowTwoConditions() && this.isConditionUiComplete(jr.Two) ? {
        filterType: this.getFilterType(),
        operator: this.getJoinOperator(),
        condition1: this.createCondition(jr.One),
        condition2: this.createCondition(jr.Two)
      } : this.createCondition(jr.One) : null;
    }, e.prototype.getConditionTypes = function() {
      return [
        this.eType1.getValue(),
        this.eType2.getValue()
      ];
    }, e.prototype.getJoinOperator = function() {
      return this.eJoinOperatorOr.getValue() === !0 ? "OR" : "AND";
    }, e.prototype.areModelsEqual = function(t, i) {
      if (!t && !i)
        return !0;
      if (!t && i || t && !i)
        return !1;
      var r = !t.operator, o = !i.operator, s = !r && o || r && !o;
      if (s)
        return !1;
      var a;
      if (r) {
        var l = t, u = i;
        a = this.areSimpleModelsEqual(l, u);
      } else {
        var c = t, h = i;
        a = c.operator === h.operator && this.areSimpleModelsEqual(c.condition1, h.condition1) && this.areSimpleModelsEqual(c.condition2, h.condition2);
      }
      return a;
    }, e.prototype.setModelIntoUi = function(t) {
      var i = t.operator;
      if (i) {
        var r = t, o = r.operator === "OR";
        this.eJoinOperatorAnd.setValue(!o), this.eJoinOperatorOr.setValue(o), this.eType1.setValue(r.condition1.type), this.eType2.setValue(r.condition2.type), this.setConditionIntoUi(r.condition1, jr.One), this.setConditionIntoUi(r.condition2, jr.Two);
      } else {
        var s = t;
        this.eJoinOperatorAnd.setValue(this.isDefaultOperator("AND")), this.eJoinOperatorOr.setValue(this.isDefaultOperator("OR")), this.eType1.setValue(s.type), this.eType2.setValue(this.optionsFactory.getDefaultOption()), this.setConditionIntoUi(s, jr.One), this.setConditionIntoUi(null, jr.Two);
      }
      return ko.resolve();
    }, e.prototype.doesFilterPass = function(t) {
      var i = this, r = this.getModel();
      if (r == null)
        return !0;
      var o = r.operator, s = [];
      if (o) {
        var a = r;
        s.push(a.condition1, a.condition2);
      } else
        s.push(r);
      var l = o && o === "OR" ? "some" : "every";
      return s[l](function(u) {
        return i.individualConditionPasses(t, u);
      });
    }, e.prototype.setParams = function(t) {
      n.prototype.setParams.call(this, t), this.optionsFactory = new zB(), this.optionsFactory.init(t, this.getDefaultFilterOptions()), this.allowTwoConditions = !t.suppressAndOrCondition, this.alwaysShowBothConditions = !!t.alwaysShowBothConditions, this.defaultJoinOperator = this.getDefaultJoinOperator(t.defaultJoinOperator), this.putOptionsIntoDropdown(), this.addChangedListeners();
    }, e.prototype.getDefaultJoinOperator = function(t) {
      return Cs(["AND", "OR"], t) ? t : "AND";
    }, e.prototype.putOptionsIntoDropdown = function() {
      var t = this, i = this.optionsFactory.getFilterOptions(), r = [this.eType1, this.eType2];
      i.forEach(function(o) {
        var s = typeof o == "string" ? t.createBoilerplateListOption(o) : t.createCustomListOption(o);
        r.forEach(function(a) {
          return a.addOption(s);
        });
      }), r.forEach(function(o) {
        return o.setDisabled(i.length <= 1);
      });
    }, e.prototype.createBoilerplateListOption = function(t) {
      return { value: t, text: this.translate(t) };
    }, e.prototype.createCustomListOption = function(t) {
      var i = t.displayKey, r = this.optionsFactory.getCustomOption(t.displayKey);
      return {
        value: i,
        text: r ? this.gridOptionsWrapper.getLocaleTextFunc()(r.displayKey, r.displayName) : this.translate(i)
      };
    }, e.prototype.isAllowTwoConditions = function() {
      return this.allowTwoConditions;
    }, e.prototype.createBodyTemplate = function() {
      return (
        /* html */
        `
            <ag-select class="ag-filter-select" ref="eOptions1"></ag-select>
            ` + this.createValueTemplate(jr.One) + `
            <div class="ag-filter-condition" ref="eJoinOperatorPanel">
               <ag-radio-button ref="eJoinOperatorAnd" class="ag-filter-condition-operator ag-filter-condition-operator-and"></ag-radio-button>
               <ag-radio-button ref="eJoinOperatorOr" class="ag-filter-condition-operator ag-filter-condition-operator-or"></ag-radio-button>
            </div>
            <ag-select class="ag-filter-select" ref="eOptions2"></ag-select>
            ` + this.createValueTemplate(jr.Two)
      );
    }, e.prototype.getCssIdentifier = function() {
      return "simple-filter";
    }, e.prototype.updateUiVisibility = function() {
      var t = this, i = [
        [this.eType1],
        [this.eType2, this.eJoinOperatorPanel, this.eJoinOperatorAnd, this.eJoinOperatorOr]
      ], r = [this.eCondition1Body, this.eCondition2Body];
      i.forEach(function(o, s) {
        var a = t.isConditionVisible(s), l = t.isConditionDisabled(s);
        o.forEach(function(u) {
          u instanceof Pu || u instanceof dx ? (u.setDisabled(l), u.setDisplayed(a)) : (Mp(u, l), Wi(u, a));
        });
      }), r.forEach(function(o, s) {
        Wi(o, t.isConditionBodyVisible(s));
      }), this.forEachInput(function(o, s, a, l) {
        t.setElementDisplayed(o, s < l), t.setElementDisabled(o, t.isConditionDisabled(a));
      }), this.resetPlaceholder();
    }, e.prototype.afterGuiAttached = function(t) {
      if (n.prototype.afterGuiAttached.call(this, t), this.resetPlaceholder(), !t || !t.suppressFocus && !this.isReadOnly()) {
        var i = this.getInputs()[0][0];
        if (!i)
          return;
        i instanceof Pu && i.getInputElement().focus();
      }
    }, e.prototype.resetPlaceholder = function() {
      var t = this, i = this.gridOptionsWrapper.getLocaleTextFunc();
      this.forEachInput(function(r, o, s, a) {
        if (r instanceof Pu) {
          var l = o === 0 && a > 1 ? "inRangeStart" : o === 0 ? "filterOoo" : "inRangeEnd", u = o === 0 && a > 1 ? i("ariaFilterFromValue", "Filter from value") : o === 0 ? i("ariaFilterValue", "Filter Value") : i("ariaFilterToValue", "Filter to Value");
          r.setInputPlaceholder(t.translate(l)), r.setInputAriaLabel(u);
        }
      });
    }, e.prototype.setElementValue = function(t, i, r) {
      t instanceof Pu && t.setValue(i != null ? String(i) : null, r);
    }, e.prototype.setElementDisplayed = function(t, i) {
      t instanceof St && Wi(t.getGui(), i);
    }, e.prototype.setElementDisabled = function(t, i) {
      t instanceof St && Mp(t.getGui(), i);
    }, e.prototype.attachElementOnChange = function(t, i) {
      t instanceof Pu && t.onValueChange(i);
    }, e.prototype.forEachInput = function(t) {
      var i = this, r = this.getInputs();
      this.getConditionTypes().forEach(function(o, s) {
        for (var a = i.getNumberOfInputs(o), l = 0; l < r[s].length; l++) {
          var u = r[s][l];
          u != null && t(u, l, s, a);
        }
      });
    }, e.prototype.isConditionVisible = function(t) {
      return t === 0 ? !0 : this.allowTwoConditions ? this.isReadOnly() ? this.isConditionUiComplete(t) : this.alwaysShowBothConditions ? !0 : this.isConditionUiComplete(t - 1) : !1;
    }, e.prototype.isConditionDisabled = function(t) {
      return this.isReadOnly() || !this.isConditionVisible(t) ? !0 : t === 0 ? !1 : !this.isConditionUiComplete(t - 1);
    }, e.prototype.isConditionBodyVisible = function(t) {
      if (!this.isConditionVisible(t))
        return !1;
      var i = this.getConditionTypes()[t], r = this.getNumberOfInputs(i);
      return r > 0;
    }, e.prototype.isConditionUiComplete = function(t) {
      var i = this.getConditionTypes()[t];
      return !(i === e.EMPTY || this.getValues(t).some(function(r) {
        return r == null;
      }));
    }, e.prototype.resetUiToDefaults = function(t) {
      var i = this, r = this.gridOptionsWrapper.getLocaleTextFunc(), o = r("ariaFilteringOperator", "Filtering operator"), s = "ag-simple-filter-and-or-" + this.getCompId(), a = this.optionsFactory.getDefaultOption();
      return this.eType1.setValue(a, t).setAriaLabel(o).setDisabled(this.isReadOnly()), this.eType2.setValue(this.optionsFactory.getDefaultOption(), t).setAriaLabel(o).setDisabled(this.isReadOnly()), this.eJoinOperatorAnd.setValue(this.isDefaultOperator("AND"), t).setName(s).setLabel(this.translate("andCondition")).setDisabled(this.isReadOnly()), this.eJoinOperatorOr.setValue(this.isDefaultOperator("OR"), t).setName(s).setLabel(this.translate("orCondition")).setDisabled(this.isReadOnly()), this.forEachInput(function(l) {
        i.setElementValue(l, null, t), i.setElementDisabled(l, i.isReadOnly());
      }), this.resetPlaceholder(), ko.resolve();
    }, e.prototype.setConditionIntoUi = function(t, i) {
      var r = this, o = this.mapValuesFromModel(t);
      this.forEachInput(function(s, a, l, u) {
        l === i && r.setElementValue(s, o[a] != null ? o[a] : null);
      });
    }, e.prototype.setValueFromFloatingFilter = function(t) {
      var i = this;
      this.forEachInput(function(r, o, s, a) {
        i.setElementValue(r, o === 0 && s === 0 ? t : null);
      });
    }, e.prototype.isDefaultOperator = function(t) {
      return t === this.defaultJoinOperator;
    }, e.prototype.addChangedListeners = function() {
      var t = this;
      if (!this.isReadOnly()) {
        var i = function() {
          return t.onUiChanged();
        };
        this.eType1.onValueChange(i), this.eType2.onValueChange(i), this.eJoinOperatorOr.onValueChange(i), this.eJoinOperatorAnd.onValueChange(i), this.forEachInput(function(r) {
          t.attachElementOnChange(r, i);
        });
      }
    }, e.prototype.individualConditionPasses = function(t, i) {
      var r = this.getCellValue(t.node), o = this.mapValuesFromModel(i), s = this.optionsFactory.getCustomOption(i.type), a = this.evaluateCustomFilter(s, o, r);
      return a ?? (r == null ? this.evaluateNullValue(i.type) : this.evaluateNonNullValue(o, r, i, t));
    }, e.prototype.evaluateCustomFilter = function(t, i, r) {
      if (t != null) {
        var o = t.predicate;
        if (o != null && !i.some(function(s) {
          return s == null;
        }))
          return o(i, r);
      }
    }, e.prototype.isBlank = function(t) {
      return t == null || typeof t == "string" && t.trim().length === 0;
    }, e.EMPTY = "empty", e.BLANK = "blank", e.NOT_BLANK = "notBlank", e.EQUALS = "equals", e.NOT_EQUAL = "notEqual", e.LESS_THAN = "lessThan", e.LESS_THAN_OR_EQUAL = "lessThanOrEqual", e.GREATER_THAN = "greaterThan", e.GREATER_THAN_OR_EQUAL = "greaterThanOrEqual", e.IN_RANGE = "inRange", e.CONTAINS = "contains", e.NOT_CONTAINS = "notContains", e.STARTS_WITH = "startsWith", e.ENDS_WITH = "endsWith", Th([
      fe("eOptions1")
    ], e.prototype, "eType1", void 0), Th([
      fe("eOptions2")
    ], e.prototype, "eType2", void 0), Th([
      fe("eJoinOperatorPanel")
    ], e.prototype, "eJoinOperatorPanel", void 0), Th([
      fe("eJoinOperatorAnd")
    ], e.prototype, "eJoinOperatorAnd", void 0), Th([
      fe("eJoinOperatorOr")
    ], e.prototype, "eJoinOperatorOr", void 0), Th([
      fe("eCondition1Body")
    ], e.prototype, "eCondition1Body", void 0), Th([
      fe("eCondition2Body")
    ], e.prototype, "eCondition2Body", void 0), e;
  }(Fv)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var q$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ur = (
  /** @class */
  function(n) {
    q$(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setParams = function(t) {
      n.prototype.setParams.call(this, t), this.scalarFilterParams = t;
    }, e.prototype.evaluateNullValue = function(t) {
      switch (t) {
        case e.EQUALS:
        case e.NOT_EQUAL:
          if (this.scalarFilterParams.includeBlanksInEquals)
            return !0;
          break;
        case e.GREATER_THAN:
        case e.GREATER_THAN_OR_EQUAL:
          if (this.scalarFilterParams.includeBlanksInGreaterThan)
            return !0;
          break;
        case e.LESS_THAN:
        case e.LESS_THAN_OR_EQUAL:
          if (this.scalarFilterParams.includeBlanksInLessThan)
            return !0;
          break;
        case e.IN_RANGE:
          if (this.scalarFilterParams.includeBlanksInRange)
            return !0;
          break;
        case e.BLANK:
          return !0;
        case e.NOT_BLANK:
          return !1;
      }
      return !1;
    }, e.prototype.evaluateNonNullValue = function(t, i, r) {
      var o = this.comparator(), s = t[0] != null ? o(t[0], i) : 0;
      switch (r.type) {
        case e.EQUALS:
          return s === 0;
        case e.NOT_EQUAL:
          return s !== 0;
        case e.GREATER_THAN:
          return s > 0;
        case e.GREATER_THAN_OR_EQUAL:
          return s >= 0;
        case e.LESS_THAN:
          return s < 0;
        case e.LESS_THAN_OR_EQUAL:
          return s <= 0;
        case e.IN_RANGE: {
          var a = o(t[1], i);
          return this.scalarFilterParams.inRangeInclusive ? s >= 0 && a <= 0 : s > 0 && a < 0;
        }
        case e.BLANK:
          return this.isBlank(i);
        case e.NOT_BLANK:
          return !this.isBlank(i);
        default:
          return console.warn('AG Grid: Unexpected type of filter "' + r.type + '", it looks like the filter was configured with incorrect Filter Options'), !0;
      }
    }, e;
  }(bn)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Y$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), M1 = globalThis && globalThis.__assign || function() {
  return M1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, M1.apply(this, arguments);
}, tm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, oM = 1e3, sM = 1 / 0, fx = (
  /** @class */
  function(n) {
    Y$(e, n);
    function e() {
      var t = n.call(this, "dateFilter") || this;
      return t.minValidYear = oM, t.maxValidYear = sM, t;
    }
    return e.prototype.afterGuiAttached = function(t) {
      n.prototype.afterGuiAttached.call(this, t), this.dateCondition1FromComp.afterGuiAttached(t);
    }, e.prototype.mapValuesFromModel = function(t) {
      var i = t || {}, r = i.dateFrom, o = i.dateTo, s = i.type;
      return [
        r && Bc(r) || null,
        o && Bc(o) || null
      ].slice(0, this.getNumberOfInputs(s));
    }, e.prototype.comparator = function() {
      return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this);
    }, e.prototype.defaultComparator = function(t, i) {
      var r = i;
      return i == null || r < t ? -1 : r > t ? 1 : 0;
    }, e.prototype.setParams = function(t) {
      n.prototype.setParams.call(this, t), this.dateFilterParams = t;
      var i = function(r, o) {
        if (t[r] != null)
          if (isNaN(t[r]))
            console.warn("AG Grid: DateFilter " + r + " is not a number");
          else
            return t[r] == null ? o : Number(t[r]);
        return o;
      };
      this.minValidYear = i("minValidYear", oM), this.maxValidYear = i("maxValidYear", sM), this.minValidYear > this.maxValidYear && console.warn("AG Grid: DateFilter minValidYear should be <= maxValidYear"), this.createDateComponents();
    }, e.prototype.createDateComponents = function() {
      var t = this, i = function(r) {
        return new UB(t.getContext(), t.userComponentFactory, {
          onDateChanged: function() {
            return t.onUiChanged();
          },
          filterParams: t.dateFilterParams
        }, r);
      };
      this.dateCondition1FromComp = i(this.eCondition1PanelFrom), this.dateCondition1ToComp = i(this.eCondition1PanelTo), this.dateCondition2FromComp = i(this.eCondition2PanelFrom), this.dateCondition2ToComp = i(this.eCondition2PanelTo), this.addDestroyFunc(function() {
        t.forEachInput(function(r) {
          return r.destroy();
        });
      });
    }, e.prototype.setElementValue = function(t, i, r) {
      t.setDate(i);
    }, e.prototype.setElementDisplayed = function(t, i) {
      t.setDisplayed(i);
    }, e.prototype.setElementDisabled = function(t, i) {
      t.setDisabled(i);
    }, e.prototype.getDefaultFilterOptions = function() {
      return e.DEFAULT_FILTER_OPTIONS;
    }, e.prototype.createValueTemplate = function(t) {
      var i = t === jr.One ? "1" : "2";
      return (
        /* html */
        `
            <div class="ag-filter-body" ref="eCondition` + i + `Body">
                <div class="ag-filter-from ag-filter-date-from" ref="eCondition` + i + `PanelFrom"></div>
                <div class="ag-filter-to ag-filter-date-to" ref="eCondition` + i + `PanelTo"></div>
            </div>`
      );
    }, e.prototype.isConditionUiComplete = function(t) {
      var i = this;
      if (!n.prototype.isConditionUiComplete.call(this, t))
        return !1;
      var r = function(s) {
        return s != null && s.getUTCFullYear() >= i.minValidYear && s.getUTCFullYear() <= i.maxValidYear;
      }, o = !0;
      return this.forEachInput(function(s, a, l, u) {
        l !== t || !o || a >= u || (o = o && r(s.getDate()));
      }), o;
    }, e.prototype.areSimpleModelsEqual = function(t, i) {
      return t.dateFrom === i.dateFrom && t.dateTo === i.dateTo && t.type === i.type;
    }, e.prototype.getFilterType = function() {
      return "date";
    }, e.prototype.createCondition = function(t) {
      var i = this.getConditionTypes()[t], r = {}, o = this.getValues(t);
      return o.length > 0 && (r.dateFrom = Vc(o[0])), o.length > 1 && (r.dateTo = Vc(o[1])), M1({ dateFrom: null, dateTo: null, filterType: this.getFilterType(), type: i }, r);
    }, e.prototype.resetPlaceholder = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = this.translate("dateFormatOoo"), r = t("ariaFilterValue", "Filter Value");
      this.forEachInput(function(o) {
        o.setInputPlaceholder(i), o.setInputAriaLabel(r);
      });
    }, e.prototype.getInputs = function() {
      return [
        [this.dateCondition1FromComp, this.dateCondition1ToComp],
        [this.dateCondition2FromComp, this.dateCondition2ToComp]
      ];
    }, e.prototype.getValues = function(t) {
      var i = [];
      return this.forEachInput(function(r, o, s, a) {
        t === s && o < a && i.push(r.getDate());
      }), i;
    }, e.DEFAULT_FILTER_OPTIONS = [
      ur.EQUALS,
      ur.GREATER_THAN,
      ur.LESS_THAN,
      ur.NOT_EQUAL,
      ur.IN_RANGE,
      ur.BLANK,
      ur.NOT_BLANK
    ], tm([
      fe("eCondition1PanelFrom")
    ], e.prototype, "eCondition1PanelFrom", void 0), tm([
      fe("eCondition1PanelTo")
    ], e.prototype, "eCondition1PanelTo", void 0), tm([
      fe("eCondition2PanelFrom")
    ], e.prototype, "eCondition2PanelFrom", void 0), tm([
      fe("eCondition2PanelTo")
    ], e.prototype, "eCondition2PanelTo", void 0), tm([
      R("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), e;
  }(ur)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var X$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), $B = (
  /** @class */
  function(n) {
    X$(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getDefaultDebounceMs = function() {
      return 0;
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.getTextFromModel = function(t) {
      if (!t)
        return null;
      var i = t.operator != null;
      if (i) {
        var r = t, o = r || {}, s = o.condition1, a = o.condition2, l = this.optionsFactory.getCustomOption(s.type), u = this.optionsFactory.getCustomOption(a.type);
        return [
          this.conditionToString(s, l),
          r.operator,
          this.conditionToString(a, u)
        ].join(" ");
      } else {
        var c = t, h = this.optionsFactory.getCustomOption(c.type), d = h || {}, f = d.displayKey, p = d.displayName, g = d.numberOfInputs;
        return f && p && g === 0 ? (this.gridOptionsWrapper.getLocaleTextFunc()(f, p), p) : this.conditionToString(c, h);
      }
    }, e.prototype.isEventFromFloatingFilter = function(t) {
      return t && t.afterFloatingFilter;
    }, e.prototype.getLastType = function() {
      return this.lastType;
    }, e.prototype.isReadOnly = function() {
      return this.readOnly;
    }, e.prototype.setLastTypeFromModel = function(t) {
      if (!t) {
        this.lastType = this.optionsFactory.getDefaultOption();
        return;
      }
      var i = t.operator, r;
      if (i) {
        var o = t;
        r = o.condition1;
      } else
        r = t;
      this.lastType = r.type;
    }, e.prototype.canWeEditAfterModelFromParentFilter = function(t) {
      if (!t)
        return this.isTypeEditable(this.lastType);
      var i = t.operator;
      if (i)
        return !1;
      var r = t;
      return this.isTypeEditable(r.type);
    }, e.prototype.init = function(t) {
      this.optionsFactory = new zB(), this.optionsFactory.init(t.filterParams, this.getDefaultFilterOptions()), this.lastType = this.optionsFactory.getDefaultOption(), this.readOnly = !!t.filterParams.readOnly;
      var i = this.isTypeEditable(this.lastType);
      this.setEditable(i);
    }, e.prototype.doesFilterHaveSingleInput = function(t) {
      var i = this.optionsFactory.getCustomOption(t), r = (i || {}).numberOfInputs;
      return r == null || r == 1;
    }, e.prototype.isTypeEditable = function(t) {
      var i = [
        bn.IN_RANGE,
        bn.EMPTY,
        bn.BLANK,
        bn.NOT_BLANK
      ];
      return !!t && !this.isReadOnly() && this.doesFilterHaveSingleInput(t) && i.indexOf(t) < 0;
    }, e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Z$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), rL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Q$ = (
  /** @class */
  function(n) {
    Z$(e, n);
    function e() {
      return n.call(
        this,
        /* html */
        `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eReadOnlyText"></ag-input-text-field>
                <div ref="eDateWrapper" style="display: flex;"></div>
            </div>`
      ) || this;
    }
    return e.prototype.getDefaultFilterOptions = function() {
      return fx.DEFAULT_FILTER_OPTIONS;
    }, e.prototype.conditionToString = function(t, i) {
      var r = t.type, o = (i || {}).numberOfInputs, s = r == bn.IN_RANGE || o === 2, a = Bc(t.dateFrom), l = Bc(t.dateTo);
      return s ? Vc(a, !1) + "-" + Vc(l, !1) : a != null ? "" + Vc(a, !1) : "" + r;
    }, e.prototype.init = function(t) {
      n.prototype.init.call(this, t), this.params = t, this.createDateComponent();
      var i = this.gridOptionsWrapper.getLocaleTextFunc();
      this.eReadOnlyText.setDisabled(!0).setInputAriaLabel(i("ariaDateFilterInput", "Date Filter Input"));
    }, e.prototype.setEditable = function(t) {
      Wi(this.eDateWrapper, t), Wi(this.eReadOnlyText.getGui(), !t);
    }, e.prototype.onParentModelChanged = function(t, i) {
      if (!this.isEventFromFloatingFilter(i)) {
        n.prototype.setLastTypeFromModel.call(this, t);
        var r = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(t);
        if (this.setEditable(r), r) {
          if (t) {
            var o = t;
            this.dateComp.setDate(Bc(o.dateFrom));
          } else
            this.dateComp.setDate(null);
          this.eReadOnlyText.setValue("");
        } else
          this.eReadOnlyText.setValue(this.getTextFromModel(t)), this.dateComp.setDate(null);
      }
    }, e.prototype.onDateChanged = function() {
      var t = this, i = this.dateComp.getDate(), r = Vc(i);
      this.params.parentFilterInstance(function(o) {
        if (o) {
          var s = Bc(r);
          o.onFloatingFilterChanged(t.getLastType() || null, s);
        }
      });
    }, e.prototype.createDateComponent = function() {
      var t = this, i = Fv.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs()), r = {
        onDateChanged: th(this.onDateChanged.bind(this), i),
        filterParams: this.params.column.getColDef().filterParams
      };
      this.dateComp = new UB(this.getContext(), this.userComponentFactory, r, this.eDateWrapper), this.addDestroyFunc(function() {
        return t.dateComp.destroy();
      });
    }, rL([
      R("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), rL([
      fe("eReadOnlyText")
    ], e.prototype, "eReadOnlyText", void 0), rL([
      fe("eDateWrapper")
    ], e.prototype, "eDateWrapper", void 0), e;
  }($B)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var J$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), eK = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, tK = (
  /** @class */
  function(n) {
    J$(e, n);
    function e() {
      return n.call(
        this,
        /* html */
        `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" ref="eDateInput"></ag-input-text-field>
            </div>`
      ) || this;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.init = function(t) {
      var i = this, r = this.gridOptionsWrapper.getDocument(), o = this.eDateInput.getInputElement();
      this.shouldUseBrowserDatePicker(t) && (o.type = "date"), this.addManagedListener(o, "mousedown", function() {
        i.eDateInput.isDisabled() || o.focus();
      }), this.addManagedListener(o, "input", function(u) {
        u.target === r.activeElement && (i.eDateInput.isDisabled() || t.onDateChanged());
      });
      var s = t.filterParams || {}, a = s.minValidYear, l = s.maxValidYear;
      a && (o.min = a + "-01-01"), l && (o.max = l + "-12-31");
    }, e.prototype.getDate = function() {
      return Bc(this.eDateInput.getValue());
    }, e.prototype.setDate = function(t) {
      this.eDateInput.setValue(Vc(t, !1));
    }, e.prototype.setInputPlaceholder = function(t) {
      this.eDateInput.setInputPlaceholder(t);
    }, e.prototype.setDisabled = function(t) {
      this.eDateInput.setDisabled(t);
    }, e.prototype.afterGuiAttached = function(t) {
      (!t || !t.suppressFocus) && this.eDateInput.getInputElement().focus();
    }, e.prototype.shouldUseBrowserDatePicker = function(t) {
      return t.filterParams && t.filterParams.browserDatePicker != null ? t.filterParams.browserDatePicker : S_() || XO();
    }, eK([
      fe("eDateInput")
    ], e.prototype, "eDateInput", void 0), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var iK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), IC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, px = (
  /** @class */
  function(n) {
    iK(e, n);
    function e() {
      return n.call(this, "numberFilter") || this;
    }
    return e.prototype.mapValuesFromModel = function(t) {
      var i = t || {}, r = i.filter, o = i.filterTo, s = i.type;
      return [
        r ?? null,
        o ?? null
      ].slice(0, this.getNumberOfInputs(s));
    }, e.prototype.getDefaultDebounceMs = function() {
      return 500;
    }, e.prototype.comparator = function() {
      return function(t, i) {
        return t === i ? 0 : t < i ? 1 : -1;
      };
    }, e.prototype.setParams = function(t) {
      this.numberFilterParams = t;
      var i = this.getAllowedCharPattern();
      if (i) {
        var r = { allowedCharPattern: i };
        this.resetTemplate({
          "eValue-index0-1": r,
          "eValue-index1-1": r,
          "eValue-index0-2": r,
          "eValue-index1-2": r
        });
      }
      n.prototype.setParams.call(this, t);
    }, e.prototype.getDefaultFilterOptions = function() {
      return e.DEFAULT_FILTER_OPTIONS;
    }, e.prototype.createValueTemplate = function(t) {
      var i = t === jr.One ? "1" : "2", r = this.getAllowedCharPattern(), o = r ? "ag-input-text-field" : "ag-input-number-field";
      return (
        /* html */
        `
            <div class="ag-filter-body" ref="eCondition` + i + `Body" role="presentation">
                <` + o + ' class="ag-filter-from ag-filter-filter" ref="eValue-index0-' + i + '"></' + o + `>
                <` + o + ' class="ag-filter-to ag-filter-filter" ref="eValue-index1-' + i + '"></' + o + `>
            </div>`
      );
    }, e.prototype.getValues = function(t) {
      var i = this, r = [];
      return this.forEachInput(function(o, s, a, l) {
        t === a && s < l && r.push(i.stringToFloat(o.getValue()));
      }), r;
    }, e.prototype.areSimpleModelsEqual = function(t, i) {
      return t.filter === i.filter && t.filterTo === i.filterTo && t.type === i.type;
    }, e.prototype.getFilterType = function() {
      return "number";
    }, e.prototype.stringToFloat = function(t) {
      if (typeof t == "number")
        return t;
      var i = op(t);
      return i != null && i.trim() === "" && (i = null), this.numberFilterParams.numberParser ? this.numberFilterParams.numberParser(i) : i == null || i.trim() === "-" ? null : parseFloat(i);
    }, e.prototype.createCondition = function(t) {
      var i = this.getConditionTypes()[t], r = {
        filterType: this.getFilterType(),
        type: i
      }, o = this.getValues(t);
      return o.length > 0 && (r.filter = o[0]), o.length > 1 && (r.filterTo = o[1]), r;
    }, e.prototype.getInputs = function() {
      return [
        [this.eValueFrom1, this.eValueTo1],
        [this.eValueFrom2, this.eValueTo2]
      ];
    }, e.prototype.getAllowedCharPattern = function() {
      var t = (this.numberFilterParams || {}).allowedCharPattern;
      return t || (!S_() && !_S() ? "\\d\\-\\." : null);
    }, e.DEFAULT_FILTER_OPTIONS = [
      ur.EQUALS,
      ur.NOT_EQUAL,
      ur.LESS_THAN,
      ur.LESS_THAN_OR_EQUAL,
      ur.GREATER_THAN,
      ur.GREATER_THAN_OR_EQUAL,
      ur.IN_RANGE,
      ur.BLANK,
      ur.NOT_BLANK
    ], IC([
      fe("eValue-index0-1")
    ], e.prototype, "eValueFrom1", void 0), IC([
      fe("eValue-index1-1")
    ], e.prototype, "eValueTo1", void 0), IC([
      fe("eValue-index0-2")
    ], e.prototype, "eValueFrom2", void 0), IC([
      fe("eValue-index1-2")
    ], e.prototype, "eValueTo2", void 0), e;
  }(ur)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var nK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), kw = globalThis && globalThis.__assign || function() {
  return kw = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, kw.apply(this, arguments);
}, PC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, DS = (
  /** @class */
  function(n) {
    nK(e, n);
    function e() {
      return n.call(this, "textFilter") || this;
    }
    return e.trimInput = function(t) {
      var i = t && t.trim();
      return i === "" ? t : i;
    }, e.prototype.getDefaultDebounceMs = function() {
      return 500;
    }, e.prototype.setParams = function(t) {
      n.prototype.setParams.call(this, t), this.textFilterParams = t, this.matcher = this.getTextMatcher(), this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? e.DEFAULT_FORMATTER : e.DEFAULT_LOWERCASE_FORMATTER);
    }, e.prototype.getTextMatcher = function() {
      var t = this.textFilterParams.textCustomComparator;
      return t ? (Sd.doOnce(function() {
        return console.warn("AG Grid - textCustomComparator is deprecated, use textMatcher instead.");
      }, "textCustomComparator.deprecated"), function(i) {
        var r = i.filterOption, o = i.value, s = i.filterText;
        return t(r, o, s);
      }) : this.textFilterParams.textMatcher || e.DEFAULT_MATCHER;
    }, e.prototype.createCondition = function(t) {
      var i = this.getConditionTypes()[t], r = {
        filterType: this.getFilterType(),
        type: i
      }, o = this.getValues(t);
      return o.length > 0 && (r.filter = o[0]), o.length > 1 && (r.filterTo = o[1]), r;
    }, e.prototype.getFilterType = function() {
      return "text";
    }, e.prototype.areSimpleModelsEqual = function(t, i) {
      return t.filter === i.filter && t.filterTo === i.filterTo && t.type === i.type;
    }, e.prototype.getInputs = function() {
      return [
        [this.eValueFrom1, this.eValueTo1],
        [this.eValueFrom2, this.eValueTo2]
      ];
    }, e.prototype.getValues = function(t) {
      var i = this, r = [];
      return this.forEachInput(function(o, s, a, l) {
        if (t === a && s < l) {
          var u = op(o.getValue()), c = (i.textFilterParams.trimInput ? e.trimInput(u) : u) || null;
          r.push(c), o.setValue(c, !0);
        }
      }), r;
    }, e.prototype.getDefaultFilterOptions = function() {
      return e.DEFAULT_FILTER_OPTIONS;
    }, e.prototype.createValueTemplate = function(t) {
      var i = t === jr.One ? "1" : "2";
      return (
        /* html */
        `
            <div class="ag-filter-body" ref="eCondition` + i + `Body" role="presentation">
                <ag-input-text-field class=".ag-filter-from ag-filter-filter" ref="eValue-index0-` + i + `"></ag-input-text-field>
                <ag-input-text-field class="ag-filter-to ag-filter-filter" ref="eValue-index1-` + i + `"></ag-input-text-field>
            </div>`
      );
    }, e.prototype.mapValuesFromModel = function(t) {
      var i = t || {}, r = i.filter, o = i.filterTo, s = i.type;
      return [
        r || null,
        o || null
      ].slice(0, this.getNumberOfInputs(s));
    }, e.prototype.evaluateNullValue = function(t) {
      var i = [
        bn.NOT_EQUAL,
        bn.NOT_CONTAINS,
        bn.BLANK
      ];
      return t ? i.indexOf(t) >= 0 : !1;
    }, e.prototype.evaluateNonNullValue = function(t, i, r, o) {
      var s = this, a = t.map(function(m) {
        return s.formatter(m);
      }) || [], l = this.formatter(i), u = this.textFilterParams, c = u.api, h = u.colDef, d = u.column, f = u.columnApi, p = u.context, g = u.textFormatter;
      if (r.type === bn.BLANK)
        return this.isBlank(i);
      if (r.type === bn.NOT_BLANK)
        return !this.isBlank(i);
      var _ = {
        api: c,
        colDef: h,
        column: d,
        columnApi: f,
        context: p,
        node: o.node,
        data: o.data,
        filterOption: r.type,
        value: l,
        textFormatter: g
      };
      return a.some(function(m) {
        return s.matcher(kw(kw({}, _), { filterText: m }));
      });
    }, e.DEFAULT_FILTER_OPTIONS = [
      bn.CONTAINS,
      bn.NOT_CONTAINS,
      bn.EQUALS,
      bn.NOT_EQUAL,
      bn.STARTS_WITH,
      bn.ENDS_WITH,
      bn.BLANK,
      bn.NOT_BLANK
    ], e.DEFAULT_FORMATTER = function(t) {
      return t;
    }, e.DEFAULT_LOWERCASE_FORMATTER = function(t) {
      return t == null ? null : t.toString().toLowerCase();
    }, e.DEFAULT_MATCHER = function(t) {
      var i = t.filterOption, r = t.value, o = t.filterText;
      if (o == null)
        return !1;
      switch (i) {
        case e.CONTAINS:
          return r.indexOf(o) >= 0;
        case e.NOT_CONTAINS:
          return r.indexOf(o) < 0;
        case e.EQUALS:
          return r === o;
        case e.NOT_EQUAL:
          return r != o;
        case e.STARTS_WITH:
          return r.indexOf(o) === 0;
        case e.ENDS_WITH:
          var s = r.lastIndexOf(o);
          return s >= 0 && s === r.length - o.length;
        default:
          return !1;
      }
    }, PC([
      fe("eValue-index0-1")
    ], e.prototype, "eValueFrom1", void 0), PC([
      fe("eValue-index1-1")
    ], e.prototype, "eValueTo1", void 0), PC([
      fe("eValue-index0-2")
    ], e.prototype, "eValueFrom2", void 0), PC([
      fe("eValue-index1-2")
    ], e.prototype, "eValueTo2", void 0), e;
  }(bn)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var rK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), oL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, KB = (
  /** @class */
  function(n) {
    rK(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      this.resetTemplate();
    }, e.prototype.resetTemplate = function(t) {
      this.setTemplate(
        /* html */
        `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eFloatingFilterInput"></ag-input-text-field>
            </div>
        `,
        t
      );
    }, e.prototype.getDefaultDebounceMs = function() {
      return 500;
    }, e.prototype.onParentModelChanged = function(t, i) {
      this.isEventFromFloatingFilter(i) || (this.setLastTypeFromModel(t), this.eFloatingFilterInput.setValue(this.getTextFromModel(t)), this.setEditable(this.canWeEditAfterModelFromParentFilter(t)));
    }, e.prototype.init = function(t) {
      n.prototype.init.call(this, t), this.params = t, this.applyActive = Fv.isUseApplyButton(this.params.filterParams);
      var i = this.params.filterParams.allowedCharPattern;
      if (i != null && this.resetTemplate({ eFloatingFilterInput: { allowedCharPattern: i } }), !this.isReadOnly()) {
        var r = Fv.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs()), o = th(this.syncUpWithParentFilter.bind(this), r), s = this.eFloatingFilterInput.getGui();
        this.addManagedListener(s, "input", o), this.addManagedListener(s, "keypress", o), this.addManagedListener(s, "keydown", o);
      }
      var a = t.column.getDefinition();
      (this.isReadOnly() || a.filterParams && a.filterParams.filterOptions && a.filterParams.filterOptions.length === 1 && a.filterParams.filterOptions[0] === "inRange") && this.eFloatingFilterInput.setDisabled(!0);
      var l = this.columnModel.getDisplayNameForColumn(t.column, "header", !0), u = this.gridOptionsWrapper.getLocaleTextFunc();
      this.eFloatingFilterInput.setInputAriaLabel(l + " " + u("ariaFilterInput", "Filter Input"));
    }, e.prototype.syncUpWithParentFilter = function(t) {
      var i = this, r = t.key === pe.ENTER;
      if (!(this.applyActive && !r)) {
        var o = this.eFloatingFilterInput.getValue();
        this.params.filterParams.trimInput && (o = DS.trimInput(o), this.eFloatingFilterInput.setValue(o, !0)), this.params.parentFilterInstance(function(s) {
          s && s.onFloatingFilterChanged(i.getLastType() || null, o || null);
        });
      }
    }, e.prototype.conditionToString = function(t, i) {
      var r = (i || {}).numberOfInputs, o = t.type == bn.IN_RANGE || r === 2;
      return o ? t.filter + "-" + t.filterTo : t.filter != null ? "" + t.filter : "" + t.type;
    }, e.prototype.setEditable = function(t) {
      this.eFloatingFilterInput.setDisabled(!t);
    }, oL([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), oL([
      fe("eFloatingFilterInput")
    ], e.prototype, "eFloatingFilterInput", void 0), oL([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }($B)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var oK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), sK = (
  /** @class */
  function(n) {
    oK(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getDefaultFilterOptions = function() {
      return px.DEFAULT_FILTER_OPTIONS;
    }, e;
  }(KB)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var aK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), qB = (
  /** @class */
  function(n) {
    aK(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getDefaultFilterOptions = function() {
      return DS.DEFAULT_FILTER_OPTIONS;
    }, e;
  }(KB)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var la = (
  /** @class */
  function() {
    function n(e, t) {
      var i = this;
      t === void 0 && (t = !1), this.destroyFuncs = [], this.touching = !1, this.eventService = new Zu(), this.eElement = e, this.preventMouseClick = t;
      var r = this.onTouchStart.bind(this), o = this.onTouchMove.bind(this), s = this.onTouchEnd.bind(this);
      this.eElement.addEventListener("touchstart", r, { passive: !0 }), this.eElement.addEventListener("touchmove", o, { passive: !0 }), this.eElement.addEventListener("touchend", s, { passive: !1 }), this.destroyFuncs.push(function() {
        i.eElement.removeEventListener("touchstart", r, { passive: !0 }), i.eElement.removeEventListener("touchmove", o, { passive: !0 }), i.eElement.removeEventListener("touchend", s, { passive: !1 });
      });
    }
    return n.prototype.getActiveTouch = function(e) {
      for (var t = 0; t < e.length; t++) {
        var i = e[t].identifier === this.touchStart.identifier;
        if (i)
          return e[t];
      }
      return null;
    }, n.prototype.addEventListener = function(e, t) {
      this.eventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.eventService.removeEventListener(e, t);
    }, n.prototype.onTouchStart = function(e) {
      var t = this;
      if (!this.touching) {
        this.touchStart = e.touches[0], this.touching = !0, this.moved = !1;
        var i = this.touchStart;
        window.setTimeout(function() {
          var r = t.touchStart === i;
          if (t.touching && r && !t.moved) {
            t.moved = !0;
            var o = {
              type: n.EVENT_LONG_TAP,
              touchStart: t.touchStart,
              touchEvent: e
            };
            t.eventService.dispatchEvent(o);
          }
        }, 500);
      }
    }, n.prototype.onTouchMove = function(e) {
      if (this.touching) {
        var t = this.getActiveTouch(e.touches);
        if (t) {
          var i = !ux(t, this.touchStart, 4);
          i && (this.moved = !0);
        }
      }
    }, n.prototype.onTouchEnd = function(e) {
      if (this.touching) {
        if (!this.moved) {
          var t = {
            type: n.EVENT_TAP,
            touchStart: this.touchStart
          };
          this.eventService.dispatchEvent(t), this.checkForDoubleTap();
        }
        this.preventMouseClick && e.preventDefault(), this.touching = !1;
      }
    }, n.prototype.checkForDoubleTap = function() {
      var e = (/* @__PURE__ */ new Date()).getTime();
      if (this.lastTapTime && this.lastTapTime > 0) {
        var t = e - this.lastTapTime;
        if (t > n.DOUBLE_TAP_MILLIS) {
          var i = {
            type: n.EVENT_DOUBLE_TAP,
            touchStart: this.touchStart
          };
          this.eventService.dispatchEvent(i), this.lastTapTime = null;
        } else
          this.lastTapTime = e;
      } else
        this.lastTapTime = e;
    }, n.prototype.destroy = function() {
      this.destroyFuncs.forEach(function(e) {
        return e();
      });
    }, n.EVENT_TAP = "tap", n.EVENT_DOUBLE_TAP = "doubleTap", n.EVENT_LONG_TAP = "longTap", n.DOUBLE_TAP_MILLIS = 500, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var lK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Cl = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, uK = (
  /** @class */
  function(n) {
    lK(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.lastMovingChanged = 0, t;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.refresh = function(t) {
      return this.params = t, this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || this.workOutSort() != this.currentSort ? !1 : (this.setDisplayName(t), !0);
    }, e.prototype.workOutTemplate = function() {
      var t = KV(this.params.template, e.TEMPLATE);
      return t = t && t.trim ? t.trim() : t, t;
    }, e.prototype.init = function(t) {
      this.params = t, this.currentTemplate = this.workOutTemplate(), this.setTemplate(this.currentTemplate), this.setupTap(), this.setupIcons(t.column), this.setMenu(), this.setupSort(), this.setupFilterIcon(), this.setDisplayName(t);
    }, e.prototype.setDisplayName = function(t) {
      if (this.currentDisplayName != t.displayName) {
        this.currentDisplayName = t.displayName;
        var i = Gl(this.currentDisplayName);
        this.eText && (this.eText.innerHTML = i);
      }
    }, e.prototype.setupIcons = function(t) {
      this.addInIcon("sortAscending", this.eSortAsc, t), this.addInIcon("sortDescending", this.eSortDesc, t), this.addInIcon("sortUnSort", this.eSortNone, t), this.addInIcon("menu", this.eMenu, t), this.addInIcon("filter", this.eFilter, t);
    }, e.prototype.addInIcon = function(t, i, r) {
      if (i != null) {
        var o = Kn(t, this.gridOptionsWrapper, r);
        o && i.appendChild(o);
      }
    }, e.prototype.setupTap = function() {
      var t = this, i = this.gridOptionsWrapper;
      if (!i.isSuppressTouch()) {
        var r = new la(this.getGui(), !0), o = i.isSuppressMenuHide(), s = o && de(this.eMenu), a = s ? new la(this.eMenu, !0) : r;
        if (this.params.enableMenu) {
          var l = s ? "EVENT_TAP" : "EVENT_LONG_TAP", u = function(h) {
            i.getApi().showColumnMenuAfterMouseClick(t.params.column, h.touchStart);
          };
          this.addManagedListener(a, la[l], u);
        }
        if (this.params.enableSorting) {
          var c = function(h) {
            var d = h.touchStart.target;
            o && t.eMenu.contains(d) || t.sortController.progressSort(t.params.column, !1, "uiColumnSorted");
          };
          this.addManagedListener(r, la.EVENT_TAP, c);
        }
        this.addDestroyFunc(function() {
          return r.destroy();
        }), s && this.addDestroyFunc(function() {
          return a.destroy();
        });
      }
    }, e.prototype.workOutShowMenu = function() {
      var t = !this.gridOptionsWrapper.isSuppressMenuHide(), i = ug() && t, r = this.params.enableMenu && !i;
      return r;
    }, e.prototype.setMenu = function() {
      var t = this;
      if (this.eMenu) {
        if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) {
          Ha(this.eMenu);
          return;
        }
        var i = this.gridOptionsWrapper.isSuppressMenuHide();
        this.addManagedListener(this.eMenu, "click", function() {
          return t.showMenu(t.eMenu);
        }), this.eMenu.classList.toggle("ag-header-menu-always-show", i);
      }
    }, e.prototype.showMenu = function(t) {
      t || (t = this.eMenu), this.menuFactory.showMenuAfterButtonClick(this.params.column, t, "columnMenu");
    }, e.prototype.removeSortIcons = function() {
      Ha(this.eSortAsc), Ha(this.eSortDesc), Ha(this.eSortNone), Ha(this.eSortOrder);
    }, e.prototype.workOutSort = function() {
      return this.params.enableSorting;
    }, e.prototype.setupSort = function() {
      var t = this;
      if (this.currentSort = this.params.enableSorting, !this.currentSort) {
        this.removeSortIcons();
        return;
      }
      var i = this.gridOptionsWrapper.isMultiSortKeyCtrl();
      this.addManagedListener(this.params.column, Gt.EVENT_MOVING_CHANGED, function() {
        t.lastMovingChanged = (/* @__PURE__ */ new Date()).getTime();
      }), this.eLabel && this.addManagedListener(this.eLabel, "click", function(r) {
        var o = t.params.column.isMoving(), s = (/* @__PURE__ */ new Date()).getTime(), a = s - t.lastMovingChanged < 50, l = o || a;
        if (!l) {
          var u = i ? r.ctrlKey || r.metaKey : r.shiftKey;
          t.params.progressSort(u);
        }
      }), this.addManagedListener(this.params.column, Gt.EVENT_SORT_CHANGED, this.onSortChanged.bind(this)), this.onSortChanged(), this.addManagedListener(this.eventService, I.EVENT_SORT_CHANGED, this.setMultiSortOrder.bind(this)), this.setMultiSortOrder();
    }, e.prototype.onSortChanged = function() {
      if (this.addOrRemoveCssClass("ag-header-cell-sorted-asc", this.params.column.isSortAscending()), this.addOrRemoveCssClass("ag-header-cell-sorted-desc", this.params.column.isSortDescending()), this.addOrRemoveCssClass("ag-header-cell-sorted-none", this.params.column.isSortNone()), this.eSortAsc && this.eSortAsc.classList.toggle("ag-hidden", !this.params.column.isSortAscending()), this.eSortDesc && this.eSortDesc.classList.toggle("ag-hidden", !this.params.column.isSortDescending()), this.eSortNone) {
        var t = !this.params.column.getColDef().unSortIcon && !this.gridOptionsWrapper.isUnSortIcon();
        this.eSortNone.classList.toggle("ag-hidden", t || !this.params.column.isSortNone());
      }
    }, e.prototype.setMultiSortOrder = function() {
      if (this.eSortOrder) {
        var t = this.params.column, i = this.sortController.getColumnsWithSortingOrdered(), r = i.indexOf(t), o = i.length > 1, s = t.isSorting() && o;
        Wi(this.eSortOrder, s), r >= 0 ? this.eSortOrder.innerHTML = (r + 1).toString() : ys(this.eSortOrder);
      }
    }, e.prototype.setupFilterIcon = function() {
      this.eFilter && (this.addManagedListener(this.params.column, Gt.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.onFilterChanged());
    }, e.prototype.onFilterChanged = function() {
      var t = this.params.column.isFilterActive();
      this.eFilter.classList.toggle("ag-hidden", !t);
    }, e.TEMPLATE = `<div class="ag-cell-label-container" role="presentation">
            <span ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
            <div ref="eLabel" class="ag-header-cell-label" role="presentation">
                <span ref="eText" class="ag-header-cell-text"></span>
                <span ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
                <span ref="eSortOrder" class="ag-header-icon ag-header-label-icon ag-sort-order" aria-hidden="true"></span>
                <span ref="eSortAsc" class="ag-header-icon ag-header-label-icon ag-sort-ascending-icon" aria-hidden="true"></span>
                <span ref="eSortDesc" class="ag-header-icon ag-header-label-icon ag-sort-descending-icon" aria-hidden="true"></span>
                <span ref="eSortNone" class="ag-header-icon ag-header-label-icon ag-sort-none-icon" aria-hidden="true"></span>
            </div>
        </div>`, Cl([
      R("sortController")
    ], e.prototype, "sortController", void 0), Cl([
      R("menuFactory")
    ], e.prototype, "menuFactory", void 0), Cl([
      fe("eFilter")
    ], e.prototype, "eFilter", void 0), Cl([
      fe("eSortAsc")
    ], e.prototype, "eSortAsc", void 0), Cl([
      fe("eSortDesc")
    ], e.prototype, "eSortDesc", void 0), Cl([
      fe("eSortNone")
    ], e.prototype, "eSortNone", void 0), Cl([
      fe("eSortOrder")
    ], e.prototype, "eSortOrder", void 0), Cl([
      fe("eMenu")
    ], e.prototype, "eMenu", void 0), Cl([
      fe("eLabel")
    ], e.prototype, "eLabel", void 0), Cl([
      fe("eText")
    ], e.prototype, "eText", void 0), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var cK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), sL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, hK = (
  /** @class */
  function(n) {
    cK(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.init = function(t) {
      this.params = t, this.checkWarnings(), this.setupLabel(), this.addGroupExpandIcon(), this.setupExpandIcons();
    }, e.prototype.checkWarnings = function() {
      var t = this.params;
      if (t.template) {
        var i = "AG Grid: A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)";
        mi(function() {
          return console.warn(i);
        }, "HeaderGroupComp.templateNotSupported");
      }
    }, e.prototype.setupExpandIcons = function() {
      var t = this;
      this.addInIcon("columnGroupOpened", "agOpened"), this.addInIcon("columnGroupClosed", "agClosed");
      var i = function(s) {
        if (!Ml(s)) {
          var a = !t.params.columnGroup.isExpanded();
          t.columnModel.setColumnGroupOpened(t.params.columnGroup.getProvidedColumnGroup(), a, "uiColumnExpanded");
        }
      };
      this.addTouchAndClickListeners(this.eCloseIcon, i), this.addTouchAndClickListeners(this.eOpenIcon, i);
      var r = function(s) {
        Ap(s);
      };
      this.addManagedListener(this.eCloseIcon, "dblclick", r), this.addManagedListener(this.eOpenIcon, "dblclick", r), this.addManagedListener(this.getGui(), "dblclick", i), this.updateIconVisibility();
      var o = this.params.columnGroup.getProvidedColumnGroup();
      this.addManagedListener(o, fn.EVENT_EXPANDED_CHANGED, this.updateIconVisibility.bind(this)), this.addManagedListener(o, fn.EVENT_EXPANDABLE_CHANGED, this.updateIconVisibility.bind(this));
    }, e.prototype.addTouchAndClickListeners = function(t, i) {
      var r = new la(t, !0);
      this.addManagedListener(r, la.EVENT_TAP, i), this.addDestroyFunc(function() {
        return r.destroy();
      }), this.addManagedListener(t, "click", i);
    }, e.prototype.updateIconVisibility = function() {
      var t = this.params.columnGroup;
      if (t.isExpandable()) {
        var i = this.params.columnGroup.isExpanded();
        Wi(this.eOpenIcon, i), Wi(this.eCloseIcon, !i);
      } else
        Wi(this.eOpenIcon, !1), Wi(this.eCloseIcon, !1);
    }, e.prototype.addInIcon = function(t, i) {
      var r = Kn(t, this.gridOptionsWrapper, null);
      r && this.getRefElement(i).appendChild(r);
    }, e.prototype.addGroupExpandIcon = function() {
      if (!this.params.columnGroup.isExpandable()) {
        Wi(this.eOpenIcon, !1), Wi(this.eCloseIcon, !1);
        return;
      }
    }, e.prototype.setupLabel = function() {
      var t = this.params.displayName;
      if (de(t)) {
        var i = Gl(t);
        this.getRefElement("agLabel").innerHTML = i;
      }
    }, e.TEMPLATE = `<div class="ag-header-group-cell-label" ref="agContainer" role="presentation">
            <span ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`, sL([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), sL([
      fe("agOpened")
    ], e.prototype, "eOpenIcon", void 0), sL([
      fe("agClosed")
    ], e.prototype, "eCloseIcon", void 0), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var dK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), fg = (
  /** @class */
  function(n) {
    dK(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.isPopup = function() {
      return !0;
    }, e.prototype.setParentComponent = function(t) {
      t.addCssClass("ag-has-popup"), n.prototype.setParentComponent.call(this, t);
    }, e.prototype.destroy = function() {
      var t = this.parentComponent, i = t && t.isAlive();
      i && t.getGui().classList.remove("ag-has-popup"), n.prototype.destroy.call(this);
    }, e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var fK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), pK = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, YB = (
  /** @class */
  function(n) {
    fK(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.init = function(t) {
      this.params = t, this.focusAfterAttached = t.cellStartedEdit, this.eTextArea.setMaxLength(t.maxLength || 200).setCols(t.cols || 60).setRows(t.rows || 10), de(t.value) && this.eTextArea.setValue(t.value.toString(), !0), this.addGuiEventListener("keydown", this.onKeyDown.bind(this));
    }, e.prototype.onKeyDown = function(t) {
      var i = t.key;
      (i === pe.LEFT || i === pe.UP || i === pe.RIGHT || i === pe.DOWN || t.shiftKey && i === pe.ENTER) && t.stopPropagation();
    }, e.prototype.afterGuiAttached = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc();
      this.eTextArea.setInputAriaLabel(t("ariaInputEditor", "Input Editor")), this.focusAfterAttached && this.eTextArea.getFocusableElement().focus();
    }, e.prototype.getValue = function() {
      return this.params.parseValue(this.eTextArea.getValue());
    }, e.TEMPLATE = `<div class="ag-large-text" tabindex="0">
            <ag-input-text-area ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`, pK([
      fe("eTextArea")
    ], e.prototype, "eTextArea", void 0), e;
  }(fg)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), aM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, gx = (
  /** @class */
  function(n) {
    gK(e, n);
    function e() {
      var t = n.call(this, '<div class="ag-cell-edit-wrapper"><ag-select class="ag-cell-editor" ref="eSelect"></ag-select></div>') || this;
      return t.startedByEnter = !1, t;
    }
    return e.prototype.init = function(t) {
      var i = this;
      if (this.focusAfterAttached = t.cellStartedEdit, Je(t.values)) {
        console.warn("AG Grid: no values found for select cellEditor");
        return;
      }
      this.startedByEnter = t.eventKey != null ? t.eventKey === pe.ENTER : !1;
      var r = !1;
      t.values.forEach(function(o) {
        var s = { value: o }, a = i.valueFormatterService.formatValue(t.column, null, null, o), l = a != null;
        s.text = l ? a : o, i.eSelect.addOption(s), r = r || t.value === o;
      }), r ? this.eSelect.setValue(t.value, !0) : t.values.length && this.eSelect.setValue(t.values[0], !0), this.gridOptionsWrapper.isFullRowEdit() || this.eSelect.onValueChange(function() {
        return t.stopEditing();
      });
    }, e.prototype.afterGuiAttached = function() {
      this.focusAfterAttached && this.eSelect.getFocusableElement().focus(), this.startedByEnter && this.eSelect.showPicker();
    }, e.prototype.focusIn = function() {
      this.eSelect.getFocusableElement().focus();
    }, e.prototype.getValue = function() {
      return this.eSelect.getValue();
    }, e.prototype.isPopup = function() {
      return !1;
    }, aM([
      R("valueFormatterService")
    ], e.prototype, "valueFormatterService", void 0), aM([
      fe("eSelect")
    ], e.prototype, "eSelect", void 0), e;
  }(fg)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var mK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), XB = (
  /** @class */
  function(n) {
    mK(e, n);
    function e() {
      var t = n.call(this) || this;
      return mi(function() {
        return console.warn('AG Grid: The PopupSelectCellEditor (agPopupSelectCellEditor) is deprecated. Instead use {cellEditor: "agSelectCellEditor", cellEditorPopup: true} ');
      }, "PopupSelectCellEditor.deprecated"), t;
    }
    return e.prototype.isPopup = function() {
      return !0;
    }, e;
  }(gx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var vK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _K = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Ww = (
  /** @class */
  function(n) {
    vK(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.init = function(t) {
      this.params = t;
      var i = this.eInput, r;
      t.cellStartedEdit ? (this.focusAfterAttached = !0, t.eventKey === pe.BACKSPACE || t.eventKey === pe.DELETE ? r = "" : t.charPress ? r = t.charPress : (r = this.getStartValue(t), t.eventKey !== pe.F2 && (this.highlightAllOnFocus = !0))) : (this.focusAfterAttached = !1, r = this.getStartValue(t)), r != null && i.setValue(r, !0), this.addManagedListener(i.getGui(), "keydown", function(o) {
        var s = o.key;
        (s === pe.PAGE_UP || s === pe.PAGE_DOWN) && o.preventDefault();
      });
    }, e.prototype.afterGuiAttached = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = this.eInput;
      if (i.setInputAriaLabel(t("ariaInputEditor", "Input Editor")), !!this.focusAfterAttached) {
        CS() || i.getFocusableElement().focus();
        var r = i.getInputElement();
        if (this.highlightAllOnFocus)
          r.select();
        else {
          var o = i.getValue(), s = de(o) && o.length || 0;
          s && r.setSelectionRange(s, s);
        }
      }
    }, e.prototype.focusIn = function() {
      var t = this.eInput, i = t.getFocusableElement(), r = t.getInputElement();
      i.focus(), r.select();
    }, e.prototype.getValue = function() {
      var t = this.eInput;
      return this.params.parseValue(t.getValue());
    }, e.prototype.getStartValue = function(t) {
      var i = t.useFormatter || t.column.getColDef().refData;
      return i ? t.formatValue(t.value) : t.value;
    }, e.prototype.isPopup = function() {
      return !1;
    }, e.TEMPLATE = '<div class="ag-cell-edit-wrapper"><ag-input-text-field class="ag-cell-editor" ref="eInput"></ag-input-text-field></div>', _K([
      fe("eInput")
    ], e.prototype, "eInput", void 0), e;
  }(fg)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var CK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ZB = (
  /** @class */
  function(n) {
    CK(e, n);
    function e() {
      var t = n.call(this) || this;
      return mi(function() {
        return console.warn('AG Grid: The PopupTextCellEditor (agPopupTextCellEditor) is deprecated. Instead use {cellEditor: "agTextCellEditor", cellEditorPopup: true} ');
      }, "PopupTextCellEditor.deprecated"), t;
    }
    return e.prototype.isPopup = function() {
      return !0;
    }, e;
  }(Ww)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var yK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wK = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, bK = "", SK = "", QB = (
  /** @class */
  function(n) {
    yK(e, n);
    function e() {
      var t = n.call(this, e.TEMPLATE) || this;
      return t.refreshCount = 0, t;
    }
    return e.prototype.init = function(t) {
      this.eValue = this.queryForHtmlElement(".ag-value-change-value"), this.eDelta = this.queryForHtmlElement(".ag-value-change-delta"), this.refresh(t);
    }, e.prototype.showDelta = function(t, i) {
      var r = Math.abs(i), o = t.formatValue(r), s = de(o) ? o : r, a = i >= 0;
      a ? this.eDelta.innerHTML = bK + s : this.eDelta.innerHTML = SK + s, this.eDelta.classList.toggle("ag-value-change-delta-up", a), this.eDelta.classList.toggle("ag-value-change-delta-down", !a);
    }, e.prototype.setTimerToRemoveDelta = function() {
      var t = this;
      this.refreshCount++;
      var i = this.refreshCount;
      window.setTimeout(function() {
        i === t.refreshCount && t.hideDeltaValue();
      }, 2e3);
    }, e.prototype.hideDeltaValue = function() {
      this.eValue.classList.remove("ag-value-change-value-highlight"), ys(this.eDelta);
    }, e.prototype.refresh = function(t) {
      var i = t.value;
      if (i === this.lastValue || (de(t.valueFormatted) ? this.eValue.innerHTML = t.valueFormatted : de(t.value) ? this.eValue.innerHTML = i : ys(this.eValue), this.filterManager.isSuppressFlashingCellsBecauseFiltering()))
        return !1;
      if (typeof i == "number" && typeof this.lastValue == "number") {
        var r = i - this.lastValue;
        this.showDelta(t, r);
      }
      return this.lastValue && this.eValue.classList.add("ag-value-change-value-highlight"), this.setTimerToRemoveDelta(), this.lastValue = i, !0;
    }, e.TEMPLATE = '<span><span class="ag-value-change-delta"></span><span class="ag-value-change-value"></span></span>', wK([
      R("filterManager")
    ], e.prototype, "filterManager", void 0), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var EK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), LK = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, JB = (
  /** @class */
  function(n) {
    EK(e, n);
    function e() {
      var t = n.call(this, e.TEMPLATE) || this;
      return t.refreshCount = 0, t.eCurrent = t.queryForHtmlElement(".ag-value-slide-current"), t;
    }
    return e.prototype.init = function(t) {
      this.refresh(t);
    }, e.prototype.addSlideAnimation = function() {
      var t = this;
      this.refreshCount++;
      var i = this.refreshCount;
      this.ePrevious && this.getGui().removeChild(this.ePrevious), this.ePrevious = Dr('<span class="ag-value-slide-previous ag-value-slide-out"></span>'), this.ePrevious.innerHTML = this.eCurrent.innerHTML, this.getGui().insertBefore(this.ePrevious, this.eCurrent), window.setTimeout(function() {
        i === t.refreshCount && t.ePrevious.classList.add("ag-value-slide-out-end");
      }, 50), window.setTimeout(function() {
        i === t.refreshCount && (t.getGui().removeChild(t.ePrevious), t.ePrevious = null);
      }, 3e3);
    }, e.prototype.refresh = function(t) {
      var i = t.value;
      return Je(i) && (i = ""), i === this.lastValue || this.filterManager.isSuppressFlashingCellsBecauseFiltering() ? !1 : (this.addSlideAnimation(), this.lastValue = i, de(t.valueFormatted) ? this.eCurrent.innerHTML = t.valueFormatted : de(t.value) ? this.eCurrent.innerHTML = i : ys(this.eCurrent), !0);
    }, e.TEMPLATE = `<span>
            <span class="ag-value-slide-current"></span>
        </span>`, LK([
      R("filterManager")
    ], e.prototype, "filterManager", void 0), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Ed;
(function(n) {
  n[n.Above = 0] = "Above", n[n.Below = 1] = "Below";
})(Ed || (Ed = {}));
var kt = (
  /** @class */
  function() {
    function n(e) {
      this.rowIndex = null, this.key = null, this.childrenMapped = {}, this.displayed = !1, this.rowTop = null, this.oldRowTop = null, this.selectable = !0, this.__objectId = n.OBJECT_ID_SEQUENCE++, this.__autoHeights = {}, this.alreadyRendered = !1, this.highlighted = null, this.selected = !1, this.beans = e;
    }
    return n.prototype.setData = function(e) {
      this.setDataCommon(e, !1);
    }, n.prototype.updateData = function(e) {
      this.setDataCommon(e, !0);
    }, n.prototype.setDataCommon = function(e, t) {
      var i = this.data;
      this.data = e, this.beans.valueCache.onDataChanged(), this.updateDataOnDetailNode(), this.checkRowSelectable();
      var r = this.createDataChangedEvent(e, i, t);
      this.dispatchLocalEvent(r);
    }, n.prototype.updateDataOnDetailNode = function() {
      this.detailNode && (this.detailNode.data = this.data);
    }, n.prototype.createDataChangedEvent = function(e, t, i) {
      return {
        type: n.EVENT_DATA_CHANGED,
        node: this,
        oldData: t,
        newData: e,
        update: i
      };
    }, n.prototype.createLocalRowEvent = function(e) {
      return {
        type: e,
        node: this
      };
    }, n.prototype.getRowIndexString = function() {
      return this.rowPinned === q.PINNED_TOP ? "t-" + this.rowIndex : this.rowPinned === q.PINNED_BOTTOM ? "b-" + this.rowIndex : this.rowIndex.toString();
    }, n.prototype.createDaemonNode = function() {
      var e = new n(this.beans);
      return e.id = this.id, e.data = this.data, e.daemon = !0, e.selected = this.selected, e.level = this.level, e;
    }, n.prototype.setDataAndId = function(e, t) {
      var i = de(this.id) ? this.createDaemonNode() : null, r = this.data;
      this.data = e, this.updateDataOnDetailNode(), this.setId(t), this.beans.selectionService.syncInRowNode(this, i), this.checkRowSelectable();
      var o = this.createDataChangedEvent(e, r, !1);
      this.dispatchLocalEvent(o);
    }, n.prototype.checkRowSelectable = function() {
      var e = this.beans.gridOptionsWrapper.getIsRowSelectableFunc();
      this.setRowSelectable(e ? e(this) : !0);
    }, n.prototype.setRowSelectable = function(e) {
      this.selectable !== e && (this.selectable = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_SELECTABLE_CHANGED)));
    }, n.prototype.setId = function(e) {
      var t = this.beans.gridOptionsWrapper.getRowIdFunc();
      if (t)
        if (this.data) {
          var i = this.getGroupKeys(!0);
          this.id = t({
            api: this.beans.gridApi,
            columnApi: this.beans.columnApi,
            data: this.data,
            parentKeys: i.length > 0 ? i : void 0,
            level: this.level
          }), this.id !== null && typeof this.id == "string" && this.id.startsWith(n.ID_PREFIX_ROW_GROUP) && console.error("AG Grid: Row IDs cannot start with " + n.ID_PREFIX_ROW_GROUP + ", this is a reserved prefix for AG Grid's row grouping feature."), this.id !== null && typeof this.id != "string" && (this.id = "" + this.id);
        } else
          this.id = void 0;
      else
        this.id = e;
    }, n.prototype.getGroupKeys = function(e) {
      e === void 0 && (e = !1);
      var t = [], i = this;
      for (e && (i = i.parent); i && i.level >= 0; )
        t.push(i.key), i = i.parent;
      return t.reverse(), t;
    }, n.prototype.isPixelInRange = function(e) {
      return !de(this.rowTop) || !de(this.rowHeight) ? !1 : e >= this.rowTop && e < this.rowTop + this.rowHeight;
    }, n.prototype.setFirstChild = function(e) {
      this.firstChild !== e && (this.firstChild = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_FIRST_CHILD_CHANGED)));
    }, n.prototype.setLastChild = function(e) {
      this.lastChild !== e && (this.lastChild = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_LAST_CHILD_CHANGED)));
    }, n.prototype.setChildIndex = function(e) {
      this.childIndex !== e && (this.childIndex = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_CHILD_INDEX_CHANGED)));
    }, n.prototype.setRowTop = function(e) {
      this.oldRowTop = this.rowTop, this.rowTop !== e && (this.rowTop = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_TOP_CHANGED)), this.setDisplayed(e !== null));
    }, n.prototype.clearRowTopAndRowIndex = function() {
      this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null);
    }, n.prototype.setDisplayed = function(e) {
      this.displayed !== e && (this.displayed = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_DISPLAYED_CHANGED)));
    }, n.prototype.setDragging = function(e) {
      this.dragging !== e && (this.dragging = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_DRAGGING_CHANGED)));
    }, n.prototype.setHighlighted = function(e) {
      e !== this.highlighted && (this.highlighted = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_HIGHLIGHT_CHANGED)));
    }, n.prototype.setAllChildrenCount = function(e) {
      this.allChildrenCount !== e && (this.allChildrenCount = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_ALL_CHILDREN_COUNT_CHANGED)));
    }, n.prototype.setMaster = function(e) {
      this.master !== e && (this.master && !e && (this.expanded = !1), this.master = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_MASTER_CHANGED)));
    }, n.prototype.setGroup = function(e) {
      this.group !== e && (this.group && !e && (this.expanded = !1), this.group = e, this.updateHasChildren(), this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_GROUP_CHANGED)));
    }, n.prototype.setRowHeight = function(e, t) {
      t === void 0 && (t = !1), this.rowHeight = e, this.rowHeightEstimated = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_HEIGHT_CHANGED));
    }, n.prototype.setRowAutoHeight = function(e, t) {
      this.__autoHeights || (this.__autoHeights = {});
      var i = this.__autoHeights;
      i[t.getId()] = e, e != null && (this.checkAutoHeightsDebounced == null && (this.checkAutoHeightsDebounced = th(this.checkAutoHeights.bind(this), 1)), this.checkAutoHeightsDebounced());
    }, n.prototype.checkAutoHeights = function() {
      var e = !1, t = !0, i = 0, r = this.__autoHeights;
      if (r != null) {
        var o = this.beans.columnModel.getAllDisplayedAutoHeightCols();
        if (o.forEach(function(a) {
          var l = r[a.getId()];
          if (l == null) {
            e = !0;
            return;
          }
          t = !1, l > i && (i = l);
        }), !e && ((t || i < 10) && (i = this.beans.gridOptionsWrapper.getRowHeightForNode(this).height), i != this.rowHeight)) {
          this.setRowHeight(i);
          var s = this.beans.rowModel;
          s.onRowHeightChanged && s.onRowHeightChanged();
        }
      }
    }, n.prototype.setRowIndex = function(e) {
      this.rowIndex !== e && (this.rowIndex = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_ROW_INDEX_CHANGED)));
    }, n.prototype.setUiLevel = function(e) {
      this.uiLevel !== e && (this.uiLevel = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_UI_LEVEL_CHANGED)));
    }, n.prototype.setExpanded = function(e) {
      if (this.expanded !== e) {
        this.expanded = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_EXPANDED_CHANGED));
        var t = Object.assign({}, this.createGlobalRowEvent(I.EVENT_ROW_GROUP_OPENED), {
          expanded: e
        });
        this.beans.rowNodeEventThrottle.dispatchExpanded(t), this.beans.gridOptionsWrapper.isGroupIncludeFooter() && this.beans.rowRenderer.refreshCells({ rowNodes: [this] });
      }
    }, n.prototype.createGlobalRowEvent = function(e) {
      return {
        type: e,
        node: this,
        data: this.data,
        rowIndex: this.rowIndex,
        rowPinned: this.rowPinned,
        context: this.beans.gridOptionsWrapper.getContext(),
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi()
      };
    }, n.prototype.dispatchLocalEvent = function(e) {
      this.eventService && this.eventService.dispatchEvent(e);
    }, n.prototype.setDataValue = function(e, t, i) {
      var r = this.beans.columnModel.getPrimaryColumn(e), o = this.beans.valueService.getValue(r, this);
      this.beans.valueService.setValue(this, r, t, i), this.dispatchCellChangedEvent(r, t, o);
    }, n.prototype.setGroupValue = function(e, t) {
      var i = this.beans.columnModel.getGridColumn(e);
      Je(this.groupData) && (this.groupData = {});
      var r = i.getColId(), o = this.groupData[r];
      o !== t && (this.groupData[r] = t, this.dispatchCellChangedEvent(i, t, o));
    }, n.prototype.setAggData = function(e) {
      var t = this, i = WV([this.aggData, e]), r = this.aggData;
      this.aggData = e, this.eventService && i.forEach(function(o) {
        var s = t.beans.columnModel.getGridColumn(o), a = t.aggData ? t.aggData[o] : void 0, l = r ? r[o] : void 0;
        t.dispatchCellChangedEvent(s, a, l);
      });
    }, n.prototype.updateHasChildren = function() {
      var e = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
      e !== this.__hasChildren && (this.__hasChildren = !!e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_HAS_CHILDREN_CHANGED)));
    }, n.prototype.hasChildren = function() {
      return this.__hasChildren == null && this.updateHasChildren(), this.__hasChildren;
    }, n.prototype.isEmptyRowGroupNode = function() {
      return this.group && ds(this.childrenAfterGroup);
    }, n.prototype.dispatchCellChangedEvent = function(e, t, i) {
      var r = {
        type: n.EVENT_CELL_CHANGED,
        node: this,
        column: e,
        newValue: t,
        oldValue: i
      };
      this.dispatchLocalEvent(r);
    }, n.prototype.resetQuickFilterAggregateText = function() {
      this.quickFilterAggregateText = null;
    }, n.prototype.isExpandable = function() {
      return !!(this.hasChildren() && !this.footer || this.master);
    }, n.prototype.isSelected = function() {
      return this.footer ? this.sibling.isSelected() : this.selected;
    }, n.prototype.depthFirstSearch = function(e) {
      this.childrenAfterGroup && this.childrenAfterGroup.forEach(function(t) {
        return t.depthFirstSearch(e);
      }), e(this);
    }, n.prototype.calculateSelectedFromChildren = function() {
      var e = !1, t = !1, i = !1, r;
      if (this.childrenAfterGroup)
        for (var o = 0; o < this.childrenAfterGroup.length; o++) {
          var s = this.childrenAfterGroup[o];
          if (s.selectable) {
            var a = s.isSelected();
            switch (a) {
              case !0:
                e = !0;
                break;
              case !1:
                t = !0;
                break;
              default:
                i = !0;
                break;
            }
          }
        }
      i ? r = void 0 : e && !t ? r = !0 : !e && t ? r = !1 : r = void 0, this.selectThisNode(r);
    }, n.prototype.setSelectedInitialValue = function(e) {
      this.selected = e;
    }, n.prototype.setSelected = function(e, t, i) {
      t === void 0 && (t = !1), i === void 0 && (i = !1), this.setSelectedParams({
        newValue: e,
        clearSelection: t,
        suppressFinishActions: i,
        rangeSelect: !1
      });
    }, n.prototype.isRowPinned = function() {
      return this.rowPinned === q.PINNED_TOP || this.rowPinned === q.PINNED_BOTTOM;
    }, n.prototype.setSelectedParams = function(e) {
      var t = this.beans.gridOptionsWrapper.isGroupSelectsChildren(), i = e.newValue === !0, r = e.clearSelection === !0, o = e.suppressFinishActions === !0, s = e.rangeSelect === !0, a = t && e.groupSelectsFiltered === !0;
      if (this.id === void 0)
        return console.warn("AG Grid: cannot select node until id for node is known"), 0;
      if (this.rowPinned)
        return console.warn("AG Grid: cannot select pinned rows"), 0;
      if (this.footer)
        return this.sibling.setSelectedParams(e);
      if (s && this.beans.selectionService.getLastSelectedNode()) {
        var l = this.beans.selectionService.getLastSelectedNode() !== this, u = this.beans.gridOptionsWrapper.isRowSelectionMulti();
        if (l && u) {
          var c = this.doRowRangeSelection(e.newValue);
          return this.beans.selectionService.setLastSelectedNode(this), c;
        }
      }
      var h = 0, d = a && this.group;
      if (!d) {
        var f = this.selectThisNode(i);
        f && h++;
      }
      if (t && this.group && (h += this.selectChildNodes(i, a)), !o) {
        var p = i && (r || !this.beans.gridOptionsWrapper.isRowSelectionMulti());
        if (p && (h += this.beans.selectionService.clearOtherNodes(this)), h > 0) {
          this.beans.selectionService.updateGroupsFromChildrenSelections();
          var g = {
            type: I.EVENT_SELECTION_CHANGED,
            api: this.beans.gridApi,
            columnApi: this.beans.columnApi
          };
          this.beans.eventService.dispatchEvent(g);
        }
        i && this.beans.selectionService.setLastSelectedNode(this);
      }
      return h;
    }, n.prototype.doRowRangeSelection = function(e) {
      var t = this;
      e === void 0 && (e = !0);
      var i = this.beans.gridOptionsWrapper.isGroupSelectsChildren(), r = this.beans.selectionService.getLastSelectedNode(), o = this.beans.rowModel.getNodesInRangeForSelection(this, r), s = 0;
      o.forEach(function(l) {
        if (!(l.group && i || e === !1 && t === l)) {
          var u = l.selectThisNode(e);
          u && s++;
        }
      }), this.beans.selectionService.updateGroupsFromChildrenSelections();
      var a = {
        type: I.EVENT_SELECTION_CHANGED,
        api: this.beans.gridApi,
        columnApi: this.beans.columnApi
      };
      return this.beans.eventService.dispatchEvent(a), s;
    }, n.prototype.isParentOfNode = function(e) {
      for (var t = this.parent; t; ) {
        if (t === e)
          return !0;
        t = t.parent;
      }
      return !1;
    }, n.prototype.selectThisNode = function(e) {
      var t = !this.selectable && e, i = this.selected === e;
      if (t || i)
        return !1;
      this.selected = e, this.eventService && this.dispatchLocalEvent(this.createLocalRowEvent(n.EVENT_ROW_SELECTED));
      var r = this.createGlobalRowEvent(I.EVENT_ROW_SELECTED);
      return this.beans.eventService.dispatchEvent(r), !0;
    }, n.prototype.selectChildNodes = function(e, t) {
      var i = t ? this.childrenAfterFilter : this.childrenAfterGroup;
      if (Je(i))
        return 0;
      for (var r = 0, o = 0; o < i.length; o++)
        r += i[o].setSelectedParams({
          newValue: e,
          clearSelection: !1,
          suppressFinishActions: !0,
          groupSelectsFiltered: t
        });
      return r;
    }, n.prototype.addEventListener = function(e, t) {
      this.eventService || (this.eventService = new Zu()), this.eventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.eventService && (this.eventService.removeEventListener(e, t), this.eventService.noRegisteredListenersExist() && (this.eventService = null));
    }, n.prototype.onMouseEnter = function() {
      this.dispatchLocalEvent(this.createLocalRowEvent(n.EVENT_MOUSE_ENTER));
    }, n.prototype.onMouseLeave = function() {
      this.dispatchLocalEvent(this.createLocalRowEvent(n.EVENT_MOUSE_LEAVE));
    }, n.prototype.getFirstChildOfFirstChild = function(e) {
      for (var t = this, i = !0, r = !1, o = null; i && !r; ) {
        var s = t.parent, a = de(s) && t.firstChild;
        a ? s.rowGroupColumn === e && (r = !0, o = s) : i = !1, t = s;
      }
      return r ? o : null;
    }, n.prototype.isFullWidthCell = function() {
      var e = this.beans.gridOptionsWrapper.getIsFullWidthCellFunc();
      return e ? e(this) : !1;
    }, n.prototype.getRoute = function() {
      if (this.key != null) {
        for (var e = [], t = this; t.key != null; )
          e.push(t.key), t = t.parent;
        return e.reverse();
      }
    }, n.ID_PREFIX_ROW_GROUP = "row-group-", n.ID_PREFIX_TOP_PINNED = "t-", n.ID_PREFIX_BOTTOM_PINNED = "b-", n.OBJECT_ID_SEQUENCE = 0, n.EVENT_ROW_SELECTED = "rowSelected", n.EVENT_DATA_CHANGED = "dataChanged", n.EVENT_CELL_CHANGED = "cellChanged", n.EVENT_ALL_CHILDREN_COUNT_CHANGED = "allChildrenCountChanged", n.EVENT_MASTER_CHANGED = "masterChanged", n.EVENT_GROUP_CHANGED = "groupChanged", n.EVENT_MOUSE_ENTER = "mouseEnter", n.EVENT_MOUSE_LEAVE = "mouseLeave", n.EVENT_HEIGHT_CHANGED = "heightChanged", n.EVENT_TOP_CHANGED = "topChanged", n.EVENT_DISPLAYED_CHANGED = "displayedChanged", n.EVENT_FIRST_CHILD_CHANGED = "firstChildChanged", n.EVENT_LAST_CHILD_CHANGED = "lastChildChanged", n.EVENT_CHILD_INDEX_CHANGED = "childIndexChanged", n.EVENT_ROW_INDEX_CHANGED = "rowIndexChanged", n.EVENT_EXPANDED_CHANGED = "expandedChanged", n.EVENT_HAS_CHILDREN_CHANGED = "hasChildrenChanged", n.EVENT_SELECTABLE_CHANGED = "selectableChanged", n.EVENT_UI_LEVEL_CHANGED = "uiLevelChanged", n.EVENT_HIGHLIGHT_CHANGED = "rowHighlightChanged", n.EVENT_DRAGGING_CHANGED = "draggingChanged", n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var DK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), lM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, mx = (
  /** @class */
  function(n) {
    DK(e, n);
    function e() {
      return n.call(
        this,
        /* html*/
        `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
            </div>`
      ) || this;
    }
    return e.prototype.postConstruct = function() {
      this.eCheckbox.setPassive(!0);
    }, e.prototype.getCheckboxId = function() {
      return this.eCheckbox.getInputElement().id;
    }, e.prototype.onDataChanged = function() {
      this.onSelectionChanged();
    }, e.prototype.onSelectableChanged = function() {
      this.showOrHideSelect();
    }, e.prototype.onSelectionChanged = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = this.rowNode.isSelected(), r = i === void 0 ? t("ariaIndeterminate", "indeterminate") : i === !0 ? t("ariaChecked", "checked") : t("ariaUnchecked", "unchecked"), o = t("ariaRowToggleSelection", "Press Space to toggle row selection");
      this.eCheckbox.setValue(i, !0), this.eCheckbox.setInputAriaLabel(o + " (" + r + ")");
    }, e.prototype.onCheckedClicked = function(t) {
      var i = this.gridOptionsWrapper.isGroupSelectsFiltered(), r = this.rowNode.setSelectedParams({ newValue: !1, rangeSelect: t.shiftKey, groupSelectsFiltered: i });
      return r;
    }, e.prototype.onUncheckedClicked = function(t) {
      var i = this.gridOptionsWrapper.isGroupSelectsFiltered(), r = this.rowNode.setSelectedParams({ newValue: !0, rangeSelect: t.shiftKey, groupSelectsFiltered: i });
      return r;
    }, e.prototype.init = function(t) {
      var i = this;
      this.rowNode = t.rowNode, this.column = t.column, this.onSelectionChanged(), this.addGuiEventListener("click", function(a) {
        return Ap(a);
      }), this.addGuiEventListener("dblclick", function(a) {
        return Ap(a);
      }), this.addManagedListener(this.eCheckbox.getInputElement(), "click", function(a) {
        var l = i.eCheckbox.getValue(), u = i.eCheckbox.getPreviousValue();
        if (u === void 0 || l === void 0) {
          var c = i.onUncheckedClicked(a || {});
          c === 0 && i.onCheckedClicked(a);
        } else
          l ? i.onCheckedClicked(a) : i.onUncheckedClicked(a || {});
      }), this.addManagedListener(this.rowNode, kt.EVENT_ROW_SELECTED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_DATA_CHANGED, this.onDataChanged.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_SELECTABLE_CHANGED, this.onSelectableChanged.bind(this));
      var r = this.gridOptionsWrapper.getIsRowSelectableFunc(), o = r || this.checkboxCallbackExists();
      if (o) {
        var s = this.showOrHideSelect.bind(this);
        this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, s), this.addManagedListener(this.rowNode, kt.EVENT_DATA_CHANGED, s), this.addManagedListener(this.rowNode, kt.EVENT_CELL_CHANGED, s), this.showOrHideSelect();
      }
      this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
    }, e.prototype.showOrHideSelect = function() {
      var t = this.rowNode.selectable;
      t && this.checkboxCallbackExists() && (t = this.column.isCellCheckboxSelection(this.rowNode)), this.setVisible(t);
    }, e.prototype.checkboxCallbackExists = function() {
      var t = this.column ? this.column.getColDef() : null;
      return !!t && typeof t.checkboxSelection == "function";
    }, lM([
      fe("eCheckbox")
    ], e.prototype, "eCheckbox", void 0), lM([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var RK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Oh = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, uM = globalThis && globalThis.__values || function(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], i = 0;
  if (t)
    return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function() {
        return n && i >= n.length && (n = void 0), { value: n && n[i++], done: !n };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, ws;
(function(n) {
  n[n.ToolPanel = 0] = "ToolPanel", n[n.HeaderCell = 1] = "HeaderCell", n[n.RowDrag = 2] = "RowDrag", n[n.ChartPanel = 3] = "ChartPanel";
})(ws || (ws = {}));
var Ld;
(function(n) {
  n[n.Up = 0] = "Up", n[n.Down = 1] = "Down";
})(Ld || (Ld = {}));
var ka;
(function(n) {
  n[n.Left = 0] = "Left", n[n.Right = 1] = "Right";
})(ka || (ka = {}));
var _o = (
  /** @class */
  function(n) {
    RK(e, n);
    function e() {
      var i = n !== null && n.apply(this, arguments) || this;
      return i.dragSourceAndParamsList = [], i.dropTargets = [], i;
    }
    t = e, e.prototype.init = function() {
      this.ePinnedIcon = Js("columnMovePin", this.gridOptionsWrapper, null), this.eHideIcon = Js("columnMoveHide", this.gridOptionsWrapper, null), this.eMoveIcon = Js("columnMoveMove", this.gridOptionsWrapper, null), this.eLeftIcon = Js("columnMoveLeft", this.gridOptionsWrapper, null), this.eRightIcon = Js("columnMoveRight", this.gridOptionsWrapper, null), this.eGroupIcon = Js("columnMoveGroup", this.gridOptionsWrapper, null), this.eAggregateIcon = Js("columnMoveValue", this.gridOptionsWrapper, null), this.ePivotIcon = Js("columnMovePivot", this.gridOptionsWrapper, null), this.eDropNotAllowedIcon = Js("dropNotAllowed", this.gridOptionsWrapper, null);
    }, e.prototype.addDragSource = function(i, r) {
      r === void 0 && (r = !1);
      var o = {
        eElement: i.eElement,
        dragStartPixels: i.dragStartPixels,
        onDragStart: this.onDragStart.bind(this, i),
        onDragStop: this.onDragStop.bind(this),
        onDragging: this.onDragging.bind(this)
      };
      this.dragSourceAndParamsList.push({ params: o, dragSource: i }), this.dragService.addDragSource(o, r);
    }, e.prototype.removeDragSource = function(i) {
      var r = this.dragSourceAndParamsList.find(function(o) {
        return o.dragSource === i;
      });
      r && (this.dragService.removeDragSource(r.params), qr(this.dragSourceAndParamsList, r));
    }, e.prototype.clearDragSourceParamsList = function() {
      var i = this;
      this.dragSourceAndParamsList.forEach(function(r) {
        return i.dragService.removeDragSource(r.params);
      }), this.dragSourceAndParamsList.length = 0;
    }, e.prototype.nudge = function() {
      this.dragging && this.onDragging(this.eventLastTime, !0);
    }, e.prototype.onDragStart = function(i, r) {
      this.dragging = !0, this.dragSource = i, this.eventLastTime = r, this.dragItem = this.dragSource.getDragItem(), this.lastDropTarget = this.dragSource.dragSourceDropTarget, this.dragSource.onDragStarted && this.dragSource.onDragStarted(), this.createGhost();
    }, e.prototype.onDragStop = function(i) {
      if (this.eventLastTime = null, this.dragging = !1, this.dragSource.onDragStopped && this.dragSource.onDragStopped(), this.lastDropTarget && this.lastDropTarget.onDragStop) {
        var r = this.createDropTargetEvent(this.lastDropTarget, i, null, null, !1);
        this.lastDropTarget.onDragStop(r);
      }
      this.lastDropTarget = null, this.dragItem = null, this.removeGhost();
    }, e.prototype.onDragging = function(i, r) {
      var o = this, s = this.getHorizontalDirection(i), a = this.getVerticalDirection(i);
      this.eventLastTime = i, this.positionGhost(i);
      var l = this.dropTargets.filter(function(d) {
        return o.isMouseOnDropTarget(i, d);
      }), u = l.length, c = null;
      if (u > 0 && (c = u === 1 ? l[0] : l.reduce(function(d, f) {
        if (!d)
          return f;
        var p = d.getContainer(), g = f.getContainer();
        return p.contains(g) ? f : d;
      })), c !== this.lastDropTarget)
        this.leaveLastTargetIfExists(i, s, a, r), this.enterDragTargetIfExists(c, i, s, a, r), this.lastDropTarget = c;
      else if (c && c.onDragging) {
        var h = this.createDropTargetEvent(c, i, s, a, r);
        c.onDragging(h);
      }
    }, e.prototype.enterDragTargetIfExists = function(i, r, o, s, a) {
      if (i) {
        if (i.onDragEnter) {
          var l = this.createDropTargetEvent(i, r, o, s, a);
          i.onDragEnter(l);
        }
        this.setGhostIcon(i.getIconName ? i.getIconName() : null);
      }
    }, e.prototype.leaveLastTargetIfExists = function(i, r, o, s) {
      if (this.lastDropTarget) {
        if (this.lastDropTarget.onDragLeave) {
          var a = this.createDropTargetEvent(this.lastDropTarget, i, r, o, s);
          this.lastDropTarget.onDragLeave(a);
        }
        this.setGhostIcon(null);
      }
    }, e.prototype.getAllContainersFromDropTarget = function(i) {
      var r = i.getSecondaryContainers ? i.getSecondaryContainers() : null, o = [[i.getContainer()]];
      return r ? o.concat(r) : o;
    }, e.prototype.allContainersIntersect = function(i, r) {
      var o, s;
      try {
        for (var a = uM(r), l = a.next(); !l.done; l = a.next()) {
          var u = l.value, c = u.getBoundingClientRect();
          if (c.width === 0 || c.height === 0)
            return !1;
          var h = i.clientX >= c.left && i.clientX < c.right, d = i.clientY >= c.top && i.clientY < c.bottom;
          if (!h || !d)
            return !1;
        }
      } catch (f) {
        o = { error: f };
      } finally {
        try {
          l && !l.done && (s = a.return) && s.call(a);
        } finally {
          if (o)
            throw o.error;
        }
      }
      return !0;
    }, e.prototype.isMouseOnDropTarget = function(i, r) {
      var o, s, a = this.getAllContainersFromDropTarget(r), l = !1;
      try {
        for (var u = uM(a), c = u.next(); !c.done; c = u.next()) {
          var h = c.value;
          if (this.allContainersIntersect(i, h)) {
            l = !0;
            break;
          }
        }
      } catch (d) {
        o = { error: d };
      } finally {
        try {
          c && !c.done && (s = u.return) && s.call(u);
        } finally {
          if (o)
            throw o.error;
        }
      }
      return l && r.isInterestedIn(this.dragSource.type);
    }, e.prototype.addDropTarget = function(i) {
      this.dropTargets.push(i);
    }, e.prototype.removeDropTarget = function(i) {
      this.dropTargets = this.dropTargets.filter(function(r) {
        return r.getContainer() !== i.getContainer();
      });
    }, e.prototype.hasExternalDropZones = function() {
      return this.dropTargets.some(function(i) {
        return i.external;
      });
    }, e.prototype.findExternalZone = function(i) {
      var r = this.dropTargets.filter(function(o) {
        return o.external;
      });
      return r.find(function(o) {
        return o.getContainer() === i.getContainer();
      }) || null;
    }, e.prototype.getHorizontalDirection = function(i) {
      var r = this.eventLastTime && this.eventLastTime.clientX, o = i.clientX;
      return r === o ? null : r > o ? ka.Left : ka.Right;
    }, e.prototype.getVerticalDirection = function(i) {
      var r = this.eventLastTime && this.eventLastTime.clientY, o = i.clientY;
      return r === o ? null : r > o ? Ld.Up : Ld.Down;
    }, e.prototype.createDropTargetEvent = function(i, r, o, s, a) {
      var l = i.getContainer(), u = l.getBoundingClientRect(), c = this, h = c.gridApi, d = c.columnApi, f = c.dragItem, p = c.dragSource, g = r.clientX - u.left, _ = r.clientY - u.top;
      return { event: r, x: g, y: _, vDirection: s, hDirection: o, dragSource: p, fromNudge: a, dragItem: f, api: h, columnApi: d, dropZoneTarget: l };
    }, e.prototype.positionGhost = function(i) {
      var r = this.eGhost;
      if (r) {
        var o = r.getBoundingClientRect(), s = o.height, a = hB() - 2, l = dB() - 2, u = i.pageY - s / 2, c = i.pageX - 10, h = this.gridOptionsWrapper.getDocument(), d = h.defaultView || window, f = d.pageYOffset || h.documentElement.scrollTop, p = d.pageXOffset || h.documentElement.scrollLeft;
        a > 0 && c + r.clientWidth > a + p && (c = a + p - r.clientWidth), c < 0 && (c = 0), l > 0 && u + r.clientHeight > l + f && (u = l + f - r.clientHeight), u < 0 && (u = 0), r.style.left = c + "px", r.style.top = u + "px";
      }
    }, e.prototype.removeGhost = function() {
      this.eGhost && this.eGhostParent && this.eGhostParent.removeChild(this.eGhost), this.eGhost = null;
    }, e.prototype.createGhost = function() {
      this.eGhost = Dr(t.GHOST_TEMPLATE);
      var i = this.environment.getTheme().theme;
      i && this.eGhost.classList.add(i), this.eGhostIcon = this.eGhost.querySelector(".ag-dnd-ghost-icon"), this.setGhostIcon(null);
      var r = this.eGhost.querySelector(".ag-dnd-ghost-label"), o = this.dragSource.dragItemName;
      jO(o) && (o = o()), r.innerHTML = Gl(o) || "", this.eGhost.style.height = "25px", this.eGhost.style.top = "20px", this.eGhost.style.left = "20px";
      var s = this.gridOptionsWrapper.getDocument(), a = null;
      try {
        a = s.fullscreenElement;
      } catch {
      } finally {
        a || (a = s.querySelector("body"));
      }
      this.eGhostParent = a, this.eGhostParent ? this.eGhostParent.appendChild(this.eGhost) : console.warn("AG Grid: could not find document body, it is needed for dragging columns");
    }, e.prototype.setGhostIcon = function(i, r) {
      r === void 0 && (r = !1), ys(this.eGhostIcon);
      var o = null;
      switch (i || (i = this.dragSource.defaultIconName || t.ICON_NOT_ALLOWED), i) {
        case t.ICON_PINNED:
          o = this.ePinnedIcon;
          break;
        case t.ICON_MOVE:
          o = this.eMoveIcon;
          break;
        case t.ICON_LEFT:
          o = this.eLeftIcon;
          break;
        case t.ICON_RIGHT:
          o = this.eRightIcon;
          break;
        case t.ICON_GROUP:
          o = this.eGroupIcon;
          break;
        case t.ICON_AGGREGATE:
          o = this.eAggregateIcon;
          break;
        case t.ICON_PIVOT:
          o = this.ePivotIcon;
          break;
        case t.ICON_NOT_ALLOWED:
          o = this.eDropNotAllowedIcon;
          break;
        case t.ICON_HIDE:
          o = this.eHideIcon;
          break;
      }
      this.eGhostIcon.classList.toggle("ag-shake-left-to-right", r), !(o === this.eHideIcon && this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns()) && o && this.eGhostIcon.appendChild(o);
    };
    var t;
    return e.ICON_PINNED = "pinned", e.ICON_MOVE = "move", e.ICON_LEFT = "left", e.ICON_RIGHT = "right", e.ICON_GROUP = "group", e.ICON_AGGREGATE = "aggregate", e.ICON_PIVOT = "pivot", e.ICON_NOT_ALLOWED = "notAllowed", e.ICON_HIDE = "hide", e.GHOST_TEMPLATE = `<div class="ag-dnd-ghost ag-unselectable">
            <span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
            <div class="ag-dnd-ghost-label"></div>
        </div>`, Oh([
      R("dragService")
    ], e.prototype, "dragService", void 0), Oh([
      R("environment")
    ], e.prototype, "environment", void 0), Oh([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), Oh([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), Oh([
      Ee
    ], e.prototype, "init", null), Oh([
      Lo
    ], e.prototype, "clearDragSourceParamsList", null), e = t = Oh([
      Ke("dragAndDropService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var RS = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), tv = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Vw = (
  /** @class */
  function(n) {
    RS(e, n);
    function e(t, i, r, o, s, a) {
      var l = n.call(this) || this;
      return l.cellValueFn = t, l.rowNode = i, l.column = r, l.customGui = o, l.dragStartPixels = s, l.suppressVisibilityChange = a, l.dragSource = null, l;
    }
    return e.prototype.isCustomGui = function() {
      return this.customGui != null;
    }, e.prototype.postConstruct = function() {
      if (this.customGui ? this.setDragElement(this.customGui, this.dragStartPixels) : (this.setTemplate(
        /* html */
        '<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>'
      ), this.getGui().appendChild(Kn("rowDrag", this.beans.gridOptionsWrapper, null)), this.addDragSource()), this.checkCompatibility(), !this.suppressVisibilityChange) {
        var t = this.beans.gridOptionsWrapper.isRowDragManaged() ? new OK(this, this.beans, this.rowNode, this.column) : new TK(this, this.beans, this.rowNode, this.column);
        this.createManagedBean(t, this.beans.context);
      }
    }, e.prototype.setDragElement = function(t, i) {
      this.setTemplateFromElement(t), this.addDragSource(i);
    }, e.prototype.getSelectedCount = function() {
      var t = this.beans.gridOptionsWrapper.isRowDragMultiRow();
      if (!t)
        return 1;
      var i = this.beans.selectionService.getSelectedNodes();
      return i.indexOf(this.rowNode) !== -1 ? i.length : 1;
    }, e.prototype.checkCompatibility = function() {
      var t = this.beans.gridOptionsWrapper.isRowDragManaged(), i = this.beans.gridOptionsWrapper.isTreeData();
      i && t && mi(function() {
        return console.warn("AG Grid: If using row drag with tree data, you cannot have rowDragManaged=true");
      }, "RowDragComp.managedAndTreeData");
    }, e.prototype.addDragSource = function(t) {
      var i = this;
      t === void 0 && (t = 4), this.dragSource && this.removeDragSource();
      var r = {
        rowNode: this.rowNode,
        columns: this.column ? [this.column] : void 0,
        defaultTextValue: this.cellValueFn()
      }, o = this.column && this.column.getColDef().rowDragText, s = this.gridOptionsWrapper.getLocaleTextFunc();
      this.dragSource = {
        type: ws.RowDrag,
        eElement: this.getGui(),
        dragItemName: function() {
          var a = i.getSelectedCount();
          return o ? o(r, a) : a === 1 ? i.cellValueFn() : a + " " + s("rowDragRows", "rows");
        },
        getDragItem: function() {
          return r;
        },
        dragStartPixels: t,
        dragSourceDomDataKey: this.beans.gridOptionsWrapper.getDomDataKey()
      }, this.beans.dragAndDropService.addDragSource(this.dragSource, !0);
    }, e.prototype.removeDragSource = function() {
      this.dragSource && this.beans.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null;
    }, tv([
      R("beans")
    ], e.prototype, "beans", void 0), tv([
      Ee
    ], e.prototype, "postConstruct", null), tv([
      Lo
    ], e.prototype, "removeDragSource", null), e;
  }(St)
), eH = (
  /** @class */
  function(n) {
    RS(e, n);
    function e(t, i, r) {
      var o = n.call(this) || this;
      return o.parent = t, o.rowNode = i, o.column = r, o;
    }
    return e.prototype.setDisplayedOrVisible = function(t) {
      if (t)
        this.parent.setDisplayed(!1);
      else {
        var i = !0, r = !1;
        this.column && (i = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui(), r = jO(this.column.getColDef().rowDrag)), r ? (this.parent.setDisplayed(!0), this.parent.setVisible(i)) : (this.parent.setDisplayed(i), this.parent.setVisible(!0));
      }
    }, e;
  }(we)
), TK = (
  /** @class */
  function(n) {
    RS(e, n);
    function e(t, i, r, o) {
      var s = n.call(this, t, r, o) || this;
      return s.beans = i, s;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.beans.gridOptionsWrapper, "suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, I.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this)), this.workOutVisibility();
    }, e.prototype.onSuppressRowDrag = function() {
      this.workOutVisibility();
    }, e.prototype.workOutVisibility = function() {
      var t = this.beans.gridOptionsWrapper.isSuppressRowDrag();
      this.setDisplayedOrVisible(t);
    }, tv([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(eH)
), OK = (
  /** @class */
  function(n) {
    RS(e, n);
    function e(t, i, r, o) {
      var s = n.call(this, t, r, o) || this;
      return s.beans = i, s;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.beans.eventService, I.EVENT_SORT_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, I.EVENT_FILTER_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, I.EVENT_COLUMN_ROW_GROUP_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, I.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.gridOptionsWrapper, "suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.workOutVisibility();
    }, e.prototype.onSuppressRowDrag = function() {
      this.workOutVisibility();
    }, e.prototype.workOutVisibility = function() {
      var t = this.beans.ctrlsService.getGridBodyCtrl(), i = t.getRowDragFeature(), r = i && i.shouldPreventRowMove(), o = this.beans.gridOptionsWrapper.isSuppressRowDrag(), s = this.beans.dragAndDropService.hasExternalDropZones(), a = r && !s || o;
      this.setDisplayedOrVisible(a);
    }, tv([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(eH)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var xK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Bw = globalThis && globalThis.__assign || function() {
  return Bw = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, Bw.apply(this, arguments);
}, im = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, tH = (
  /** @class */
  function(n) {
    xK(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t, i, r, o, s, a, l) {
      this.params = l, this.eGui = i, this.eCheckbox = r, this.eExpanded = o, this.eContracted = s, this.comp = t, this.compClass = a;
      var u = this.isTopLevelFooter(), c = this.isEmbeddedRowMismatch(), h = l.value == null, d = !1;
      if (this.gridOptionsWrapper.isGroupIncludeFooter() && this.gridOptionsWrapper.isGroupHideOpenParents()) {
        var f = l.node;
        if (f.footer) {
          var p = l.colDef && l.colDef.showRowGroup, g = f.rowGroupColumn && f.rowGroupColumn.getColId();
          d = p !== g;
        }
      }
      this.cellIsBlank = u ? !1 : c || h || d, !this.cellIsBlank && (this.setupShowingValueForOpenedParent(), this.findDisplayedGroupNode(), this.addFullWidthRowDraggerIfNeeded(), this.addExpandAndContract(), this.addCheckboxIfNeeded(), this.addValueElement(), this.setupIndent());
    }, e.prototype.isTopLevelFooter = function() {
      if (!this.gridOptionsWrapper.isGroupIncludeTotalFooter() || this.params.value != null || this.params.node.level != -1)
        return !1;
      var t = this.params.colDef, i = t == null;
      if (i || t.showRowGroup === !0)
        return !0;
      var r = this.columnModel.getRowGroupColumns();
      if (!r || r.length === 0)
        return !0;
      var o = r[0];
      return o.getId() === t.showRowGroup;
    }, e.prototype.isEmbeddedRowMismatch = function() {
      if (!this.params.fullWidth || !this.gridOptionsWrapper.isEmbedFullWidthRows())
        return !1;
      var t = this.params.pinned === q.PINNED_LEFT, i = this.params.pinned === q.PINNED_RIGHT, r = !t && !i;
      return this.gridOptionsWrapper.isEnableRtl() ? this.columnModel.isPinningLeft() ? !i : !r : this.columnModel.isPinningLeft() ? !t : !r;
    }, e.prototype.findDisplayedGroupNode = function() {
      var t = this.params.column, i = this.params.node;
      if (this.showingValueForOpenedParent)
        for (var r = i.parent; r != null; ) {
          if (r.rowGroupColumn && t.isRowGroupDisplayed(r.rowGroupColumn.getId())) {
            this.displayedGroupNode = r;
            break;
          }
          r = r.parent;
        }
      Je(this.displayedGroupNode) && (this.displayedGroupNode = i);
    }, e.prototype.setupShowingValueForOpenedParent = function() {
      var t = this.params.node, i = this.params.column;
      if (!this.gridOptionsWrapper.isGroupHideOpenParents()) {
        this.showingValueForOpenedParent = !1;
        return;
      }
      if (!t.groupData) {
        this.showingValueForOpenedParent = !1;
        return;
      }
      var r = t.rowGroupColumn != null;
      if (r) {
        var o = t.rowGroupColumn.getId(), s = i.isRowGroupDisplayed(o);
        if (s) {
          this.showingValueForOpenedParent = !1;
          return;
        }
      }
      var a = t.groupData[i.getId()] != null;
      this.showingValueForOpenedParent = a;
    }, e.prototype.addValueElement = function() {
      this.displayedGroupNode.footer ? this.addFooterValue() : (this.addGroupValue(), this.addChildCount());
    }, e.prototype.addGroupValue = function() {
      var t = this.adjustParamsWithDetailsFromRelatedColumn(), i = this.getInnerCompDetails(t), r = t.valueFormatted, o = t.value, s = r ?? o;
      this.comp.setInnerRenderer(i, s);
    }, e.prototype.adjustParamsWithDetailsFromRelatedColumn = function() {
      var t = this.displayedGroupNode.rowGroupColumn, i = this.params.column;
      if (!t)
        return this.params;
      var r = i != null;
      if (r) {
        var o = i.isRowGroupDisplayed(t.getId());
        if (!o)
          return this.params;
      }
      var s = this.params, a = this.params, l = a.value, u = a.scope, c = a.node, h = this.valueFormatterService.formatValue(t, c, u, l), d = Bw(Bw({}, s), { valueFormatted: h });
      return d;
    }, e.prototype.addFooterValue = function() {
      var t = this.params.footerValueGetter, i = "";
      if (t) {
        var r = zO(this.params);
        r.value = this.params.value, typeof t == "function" ? i = t(r) : typeof t == "string" ? i = this.expressionService.evaluate(t, r) : console.warn("AG Grid: footerValueGetter should be either a function or a string (expression)");
      } else
        i = "Total " + (this.params.value != null ? this.params.value : "");
      var o = this.getInnerCompDetails(this.params);
      this.comp.setInnerRenderer(o, i);
    }, e.prototype.getInnerCompDetails = function(t) {
      var i = this;
      if (t.fullWidth)
        return this.userComponentFactory.getFullWidthGroupRowInnerCellRenderer(this.gridOptions.groupRowRendererParams, t);
      var r = this.userComponentFactory.getInnerRendererDetails(t, t), o = function(c) {
        return c && c.componentClass == i.compClass;
      };
      if (r && !o(r))
        return r;
      var s = this.displayedGroupNode.rowGroupColumn, a = s ? s.getColDef() : void 0;
      if (a) {
        var l = this.userComponentFactory.getCellRendererDetails(a, t);
        if (l && !o(l))
          return l;
        if (o(l) && a.cellRendererParams && a.cellRendererParams.innerRenderer) {
          var u = this.userComponentFactory.getInnerRendererDetails(a.cellRendererParams, t);
          return u;
        }
      }
    }, e.prototype.addChildCount = function() {
      this.params.suppressCount || (this.addManagedListener(this.displayedGroupNode, kt.EVENT_ALL_CHILDREN_COUNT_CHANGED, this.updateChildCount.bind(this)), this.updateChildCount());
    }, e.prototype.updateChildCount = function() {
      var t = this.displayedGroupNode.allChildrenCount, i = this.isShowRowGroupForThisRow(), r = i && t != null && t >= 0, o = r ? "(" + t + ")" : "";
      this.comp.setChildCount(o);
    }, e.prototype.isShowRowGroupForThisRow = function() {
      if (this.gridOptionsWrapper.isTreeData())
        return !0;
      var t = this.displayedGroupNode.rowGroupColumn;
      if (!t)
        return !1;
      var i = this.params.column, r = i == null || i.isRowGroupDisplayed(t.getId());
      return r;
    }, e.prototype.addExpandAndContract = function() {
      var t = this.params, i = Kn("groupExpanded", this.gridOptionsWrapper, null), r = Kn("groupContracted", this.gridOptionsWrapper, null);
      i && this.eExpanded.appendChild(i), r && this.eContracted.appendChild(r);
      var o = t.eGridCell;
      !this.gridOptionsWrapper.isEnableGroupEdit() && this.isExpandable() && !t.suppressDoubleClickExpand && this.addManagedListener(o, "dblclick", this.onCellDblClicked.bind(this)), this.addManagedListener(this.eExpanded, "click", this.onExpandClicked.bind(this)), this.addManagedListener(this.eContracted, "click", this.onExpandClicked.bind(this)), this.addManagedListener(o, "keydown", this.onKeyDown.bind(this)), this.addManagedListener(t.node, kt.EVENT_EXPANDED_CHANGED, this.showExpandAndContractIcons.bind(this)), this.showExpandAndContractIcons();
      var s = this.onRowNodeIsExpandableChanged.bind(this);
      this.addManagedListener(this.displayedGroupNode, kt.EVENT_ALL_CHILDREN_COUNT_CHANGED, s), this.addManagedListener(this.displayedGroupNode, kt.EVENT_MASTER_CHANGED, s), this.addManagedListener(this.displayedGroupNode, kt.EVENT_GROUP_CHANGED, s), this.addManagedListener(this.displayedGroupNode, kt.EVENT_HAS_CHILDREN_CHANGED, s);
    }, e.prototype.onExpandClicked = function(t) {
      Ml(t) || (Ap(t), this.onExpandOrContract());
    }, e.prototype.onExpandOrContract = function() {
      var t = this.displayedGroupNode, i = !t.expanded;
      t.setExpanded(i);
    }, e.prototype.isExpandable = function() {
      if (this.showingValueForOpenedParent)
        return !0;
      var t = this.displayedGroupNode, i = this.columnModel.isPivotMode() && t.leafGroup, r = t.isExpandable() && !t.footer && !i;
      if (!r)
        return !1;
      var o = this.params.column, s = o != null && typeof o.getColDef().showRowGroup == "string";
      if (s) {
        var a = this.isShowRowGroupForThisRow();
        return a;
      }
      return !0;
    }, e.prototype.showExpandAndContractIcons = function() {
      var t = this, i = t.params, r = t.displayedGroupNode, o = t.columnModel, s = i.node, a = this.isExpandable();
      if (a) {
        var l = this.showingValueForOpenedParent ? !0 : s.expanded;
        this.comp.setExpandedDisplayed(l), this.comp.setContractedDisplayed(!l);
      } else
        this.comp.setExpandedDisplayed(!1), this.comp.setContractedDisplayed(!1);
      var u = o.isPivotMode(), c = u && r.leafGroup, h = a && !c, d = s.footer && s.level === -1;
      this.comp.addOrRemoveCssClass("ag-cell-expandable", h), this.comp.addOrRemoveCssClass("ag-row-group", h), u ? this.comp.addOrRemoveCssClass("ag-pivot-leaf-group", c) : d || this.comp.addOrRemoveCssClass("ag-row-group-leaf-indent", !h);
    }, e.prototype.onRowNodeIsExpandableChanged = function() {
      this.showExpandAndContractIcons(), this.setIndent();
    }, e.prototype.setupIndent = function() {
      var t = this.params.node, i = this.params.suppressPadding;
      i || (this.addManagedListener(t, kt.EVENT_UI_LEVEL_CHANGED, this.setIndent.bind(this)), this.setIndent());
    }, e.prototype.setIndent = function() {
      if (!this.gridOptionsWrapper.isGroupHideOpenParents()) {
        var t = this.params, i = t.node, r = !!t.colDef, o = this.gridOptionsWrapper.isTreeData(), s = !r || o || t.colDef.showRowGroup === !0, a = s ? i.uiLevel : 0, l = t.padding >= 0;
        l && mi(function() {
          return console.warn("AG Grid: cellRendererParams.padding no longer works, it was deprecated in since v14.2 and removed in v26, configuring padding for groupCellRenderer should be done with Sass variables and themes. Please see the AG Grid documentation page for Themes, in particular the property $row-group-indent-size.");
        }, "groupCellRenderer->doDeprecatedWay"), this.indentClass && this.comp.addOrRemoveCssClass(this.indentClass, !1), this.indentClass = "ag-row-group-indent-" + a, this.comp.addOrRemoveCssClass(this.indentClass, !0);
      }
    }, e.prototype.addFullWidthRowDraggerIfNeeded = function() {
      var t = this;
      if (!(!this.params.fullWidth || !this.params.rowDrag)) {
        var i = new Vw(function() {
          return t.params.value;
        }, this.params.node);
        this.createManagedBean(i, this.context), this.eGui.insertAdjacentElement("afterbegin", i.getGui());
      }
    }, e.prototype.isUserWantsSelected = function() {
      var t = this.params.checkbox;
      return typeof t == "function" ? t(this.params) : t === !0;
    }, e.prototype.addCheckboxIfNeeded = function() {
      var t = this, i = this.displayedGroupNode, r = this.isUserWantsSelected() && // footers cannot be selected
      !i.footer && // pinned rows cannot be selected
      !i.rowPinned && // details cannot be selected
      !i.detail;
      if (r) {
        var o = new mx();
        this.getContext().createBean(o), o.init({ rowNode: i, column: this.params.column }), this.eCheckbox.appendChild(o.getGui()), this.addDestroyFunc(function() {
          return t.getContext().destroyBean(o);
        });
      }
      this.comp.setCheckboxVisible(r);
    }, e.prototype.onKeyDown = function(t) {
      var i = t.key === pe.ENTER;
      if (!(!i || this.params.suppressEnterExpand)) {
        var r = this.params.column && this.params.column.isCellEditable(this.params.node);
        r || this.onExpandOrContract();
      }
    }, e.prototype.onCellDblClicked = function(t) {
      if (!Ml(t)) {
        var i = Iw(this.eExpanded, t) || Iw(this.eContracted, t);
        i || this.onExpandOrContract();
      }
    }, im([
      R("expressionService")
    ], e.prototype, "expressionService", void 0), im([
      R("valueFormatterService")
    ], e.prototype, "valueFormatterService", void 0), im([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), im([
      R("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), im([
      R("gridOptions")
    ], e.prototype, "gridOptions", void 0), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var NK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), nm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, F1 = (
  /** @class */
  function(n) {
    NK(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.init = function(t) {
      var i = this, r = {
        setInnerRenderer: function(l, u) {
          return i.setRenderDetails(l, u);
        },
        setChildCount: function(l) {
          return i.eChildCount.innerHTML = l;
        },
        addOrRemoveCssClass: function(l, u) {
          return i.addOrRemoveCssClass(l, u);
        },
        setContractedDisplayed: function(l) {
          return Wi(i.eContracted, l);
        },
        setExpandedDisplayed: function(l) {
          return Wi(i.eExpanded, l);
        },
        setCheckboxVisible: function(l) {
          return i.eCheckbox.classList.toggle("ag-invisible", !l);
        }
      }, o = this.createManagedBean(new tH()), s = !t.colDef, a = this.getGui();
      o.init(r, a, this.eCheckbox, this.eExpanded, this.eContracted, this.constructor, t), s && So(a, "gridcell");
    }, e.prototype.setRenderDetails = function(t, i) {
      var r = this;
      if (t) {
        var o = t.newAgStackInstance();
        if (!o)
          return;
        o.then(function(s) {
          if (s) {
            var a = function() {
              return r.context.destroyBean(s);
            };
            r.isAlive() ? (r.eValue.appendChild(s.getGui()), r.addDestroyFunc(a)) : a();
          }
        });
      } else
        this.eValue.innerText = i;
    }, e.prototype.destroy = function() {
      this.getContext().destroyBean(this.innerCellRenderer), n.prototype.destroy.call(this);
    }, e.prototype.refresh = function() {
      return !1;
    }, e.TEMPLATE = `<span class="ag-cell-wrapper">
            <span class="ag-group-expanded" ref="eExpanded"></span>
            <span class="ag-group-contracted" ref="eContracted"></span>
            <span class="ag-group-checkbox ag-invisible" ref="eCheckbox"></span>
            <span class="ag-group-value" ref="eValue"></span>
            <span class="ag-group-child-count" ref="eChildCount"></span>
        </span>`, nm([
      fe("eExpanded")
    ], e.prototype, "eExpanded", void 0), nm([
      fe("eContracted")
    ], e.prototype, "eContracted", void 0), nm([
      fe("eCheckbox")
    ], e.prototype, "eCheckbox", void 0), nm([
      fe("eValue")
    ], e.prototype, "eValue", void 0), nm([
      fe("eChildCount")
    ], e.prototype, "eChildCount", void 0), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var IK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), cM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, PK = (
  /** @class */
  function(n) {
    IK(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.init = function(t) {
      t.node.failedLoad ? this.setupFailed() : this.setupLoading();
    }, e.prototype.setupFailed = function() {
      this.eLoadingText.innerText = "ERR";
    }, e.prototype.setupLoading = function() {
      var t = Kn("groupLoading", this.gridOptionsWrapper, null);
      t && this.eLoadingIcon.appendChild(t);
      var i = this.gridOptionsWrapper.getLocaleTextFunc();
      this.eLoadingText.innerText = i("loadingOoo", "Loading");
    }, e.prototype.refresh = function(t) {
      return !1;
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.TEMPLATE = `<div class="ag-loading">
            <span class="ag-loading-icon" ref="eLoadingIcon"></span>
            <span class="ag-loading-text" ref="eLoadingText"></span>
        </div>`, cM([
      fe("eLoadingIcon")
    ], e.prototype, "eLoadingIcon", void 0), cM([
      fe("eLoadingText")
    ], e.prototype, "eLoadingText", void 0), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var AK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), MK = (
  /** @class */
  function(n) {
    AK(e, n);
    function e() {
      return n.call(this) || this;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.init = function(t) {
      var i = this.gridOptionsWrapper.getOverlayLoadingTemplate() ? this.gridOptionsWrapper.getOverlayLoadingTemplate() : e.DEFAULT_LOADING_OVERLAY_TEMPLATE, r = this.gridOptionsWrapper.getLocaleTextFunc(), o = i.replace("[LOADING...]", r("loadingOoo", "Loading..."));
      this.setTemplate(o);
    }, e.DEFAULT_LOADING_OVERLAY_TEMPLATE = '<span class="ag-overlay-loading-center">[LOADING...]</span>', e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var FK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), kK = (
  /** @class */
  function(n) {
    FK(e, n);
    function e() {
      return n.call(this) || this;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.init = function(t) {
      var i = this.gridOptionsWrapper.getOverlayNoRowsTemplate() ? this.gridOptionsWrapper.getOverlayNoRowsTemplate() : e.DEFAULT_NO_ROWS_TEMPLATE, r = this.gridOptionsWrapper.getLocaleTextFunc(), o = i.replace("[NO_ROWS_TO_SHOW]", r("noRowsToShow", "No Rows To Show"));
      this.setTemplate(o);
    }, e.DEFAULT_NO_ROWS_TEMPLATE = '<span class="ag-overlay-no-rows-center">[NO_ROWS_TO_SHOW]</span>', e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var WK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), VK = (
  /** @class */
  function(n) {
    WK(e, n);
    function e() {
      return n.call(
        this,
        /* html */
        '<div class="ag-tooltip"></div>'
      ) || this;
    }
    return e.prototype.init = function(t) {
      var i = t.value;
      this.getGui().innerHTML = Gl(i);
    }, e;
  }(fg)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var BK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), AC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, iH = (
  /** @class */
  function(n) {
    BK(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.agGridDefaults = {
        //date
        agDateInput: tK,
        //header
        agColumnHeader: uK,
        agColumnGroupHeader: hK,
        //floating filters
        agTextColumnFloatingFilter: qB,
        agNumberColumnFloatingFilter: sK,
        agDateColumnFloatingFilter: Q$,
        agReadOnlyFloatingFilter: M$,
        // renderers
        agAnimateShowChangeCellRenderer: QB,
        agAnimateSlideCellRenderer: JB,
        agGroupCellRenderer: F1,
        agGroupRowRenderer: F1,
        agLoadingCellRenderer: PK,
        //editors
        agCellEditor: Ww,
        agTextCellEditor: Ww,
        agSelectCellEditor: gx,
        agPopupTextCellEditor: ZB,
        agPopupSelectCellEditor: XB,
        agLargeTextCellEditor: YB,
        //filter
        agTextColumnFilter: DS,
        agNumberColumnFilter: px,
        agDateColumnFilter: fx,
        //overlays
        agLoadingOverlay: MK,
        agNoRowsOverlay: kK,
        // tooltips
        agTooltipComponent: VK
      }, t.agDeprecatedNames = {
        set: {
          newComponentName: "agSetColumnFilter",
          propertyHolder: "filter"
        },
        text: {
          newComponentName: "agTextColumnFilter",
          propertyHolder: "filter"
        },
        number: {
          newComponentName: "agNumberColumnFilter",
          propertyHolder: "filter"
        },
        date: {
          newComponentName: "agDateColumnFilter",
          propertyHolder: "filter"
        },
        group: {
          newComponentName: "agGroupCellRenderer",
          propertyHolder: "cellRenderer"
        },
        animateShowChange: {
          newComponentName: "agAnimateShowChangeCellRenderer",
          propertyHolder: "cellRenderer"
        },
        animateSlide: {
          newComponentName: "agAnimateSlideCellRenderer",
          propertyHolder: "cellRenderer"
        },
        select: {
          newComponentName: "agSelectCellEditor",
          propertyHolder: "cellEditor"
        },
        largeText: {
          newComponentName: "agLargeTextCellEditor",
          propertyHolder: "cellEditor"
        },
        popupSelect: {
          newComponentName: "agPopupSelectCellEditor",
          propertyHolder: "cellEditor"
        },
        popupText: {
          newComponentName: "agPopupTextCellEditor",
          propertyHolder: "cellEditor"
        },
        richSelect: {
          newComponentName: "agRichSelectCellEditor",
          propertyHolder: "cellEditor"
        },
        headerComponent: {
          newComponentName: "agColumnHeader",
          propertyHolder: "headerComponent"
        }
      }, t.jsComps = {}, t.fwComps = {}, t;
    }
    return e.prototype.init = function() {
      var t = this;
      this.gridOptions.components != null && pi(this.gridOptions.components, function(i, r) {
        return t.registerJsComponent(i, r);
      }), this.gridOptions.frameworkComponents != null && pi(this.gridOptions.frameworkComponents, function(i, r) {
        return t.registerFwComponent(i, r);
      });
    }, e.prototype.registerDefaultComponent = function(t, i) {
      var r = this.translateIfDeprecated(t);
      if (this.agGridDefaults[r]) {
        console.error("Trying to overwrite a default component. You should call registerComponent");
        return;
      }
      this.agGridDefaults[r] = i;
    }, e.prototype.registerJsComponent = function(t, i) {
      var r = this.translateIfDeprecated(t);
      if (this.fwComps[r]) {
        console.error("Trying to register a component that you have already registered for frameworks: " + r);
        return;
      }
      this.jsComps[r] = i;
    }, e.prototype.registerFwComponent = function(t, i) {
      var r = "AG Grid: As of v27, registering components via grid property frameworkComponents is deprecated. Instead register both JavaScript AND Framework Components via the components property.";
      mi(function() {
        return console.warn(r);
      }, "UserComponentRegistry.frameworkComponentsDeprecated");
      var o = this.translateIfDeprecated(t);
      this.fwComps[o] = i;
    }, e.prototype.retrieve = function(t) {
      var i = this.translateIfDeprecated(t), r = function(c, h) {
        return { componentFromFramework: h, component: c };
      }, o = this.getFrameworkOverrides().frameworkComponent(i);
      if (o != null)
        return r(o, !0);
      var s = this.fwComps[i];
      if (s)
        return r(s, !0);
      var a = this.jsComps[i];
      if (a) {
        var l = this.getFrameworkOverrides().isFrameworkComponent(a);
        return r(a, l);
      }
      var u = this.agGridDefaults[i];
      return u ? r(u, !1) : (Object.keys(this.agGridDefaults).indexOf(i) < 0 && console.warn("AG Grid: Looking for component [" + i + "] but it wasn't found."), null);
    }, e.prototype.translateIfDeprecated = function(t) {
      var i = this.agDeprecatedNames[t];
      return i != null ? (mi(function() {
        console.warn("ag-grid. Since v15.0 component names have been renamed to be namespaced. You should rename " + i.propertyHolder + ":" + t + " to " + i.propertyHolder + ":" + i.newComponentName);
      }, "DEPRECATE_COMPONENT_" + t), i.newComponentName) : t;
    }, AC([
      R("gridOptions")
    ], e.prototype, "gridOptions", void 0), AC([
      R("agComponentUtils")
    ], e.prototype, "agComponentUtils", void 0), AC([
      Ee
    ], e.prototype, "init", null), e = AC([
      Ke("userComponentRegistry")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var HK = {
  propertyName: "dateComponent",
  cellRenderer: !1
}, GK = {
  propertyName: "headerComponent",
  cellRenderer: !1
}, UK = {
  propertyName: "headerGroupComponent",
  cellRenderer: !1
}, hM = {
  propertyName: "cellRenderer",
  cellRenderer: !0
}, zK = {
  propertyName: "cellEditor",
  cellRenderer: !1
}, dM = {
  propertyName: "innerRenderer",
  cellRenderer: !0
}, jK = {
  propertyName: "loadingOverlayComponent",
  cellRenderer: !1
}, $K = {
  propertyName: "noRowsOverlayComponent",
  cellRenderer: !1
}, KK = {
  propertyName: "tooltipComponent",
  cellRenderer: !1
}, k1 = {
  propertyName: "filter",
  cellRenderer: !1
}, qK = {
  propertyName: "floatingFilterComponent",
  cellRenderer: !1
}, YK = {
  propertyName: "toolPanel",
  cellRenderer: !1
}, XK = {
  propertyName: "statusPanel",
  cellRenderer: !1
}, ZK = {
  propertyName: "fullWidthCellRenderer",
  cellRenderer: !0
}, QK = {
  propertyName: "loadingCellRenderer",
  cellRenderer: !0
}, JK = {
  propertyName: "groupRowRenderer",
  cellRenderer: !0
}, eq = {
  propertyName: "detailCellRenderer",
  cellRenderer: !0
};
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var nH = (
  /** @class */
  function() {
    function n() {
    }
    return n.getFloatingFilterType = function(e) {
      return this.filterToFloatingFilterMapping[e];
    }, n.filterToFloatingFilterMapping = {
      set: "agSetColumnFloatingFilter",
      agSetColumnFilter: "agSetColumnFloatingFilter",
      multi: "agMultiColumnFloatingFilter",
      agMultiColumnFilter: "agMultiColumnFloatingFilter",
      number: "agNumberColumnFloatingFilter",
      agNumberColumnFilter: "agNumberColumnFloatingFilter",
      date: "agDateColumnFloatingFilter",
      agDateColumnFilter: "agDateColumnFloatingFilter",
      text: "agTextColumnFloatingFilter",
      agTextColumnFilter: "agTextColumnFloatingFilter"
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var tq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), hf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, rH = (
  /** @class */
  function(n) {
    tq(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getHeaderCompDetails = function(t, i) {
      return this.getCompDetails(t, GK, "agColumnHeader", i);
    }, e.prototype.getHeaderGroupCompDetails = function(t) {
      var i = t.columnGroup.getColGroupDef();
      return this.getCompDetails(i, UK, "agColumnGroupHeader", t);
    }, e.prototype.getFullWidthCellRendererDetails = function(t) {
      return this.getCompDetails(this.gridOptions, ZK, null, t, !0);
    }, e.prototype.getFullWidthLoadingCellRendererDetails = function(t) {
      return this.getCompDetails(this.gridOptions, QK, "agLoadingCellRenderer", t, !0);
    }, e.prototype.getFullWidthGroupCellRendererDetails = function(t) {
      return this.getCompDetails(this.gridOptions, JK, "agGroupRowRenderer", t, !0);
    }, e.prototype.getFullWidthDetailCellRendererDetails = function(t) {
      return this.getCompDetails(this.gridOptions, eq, "agDetailCellRenderer", t, !0);
    }, e.prototype.getInnerRendererDetails = function(t, i) {
      return this.getCompDetails(t, dM, null, i);
    }, e.prototype.getFullWidthGroupRowInnerCellRenderer = function(t, i) {
      return this.getCompDetails(t, dM, null, i);
    }, e.prototype.getCellRendererDetails = function(t, i) {
      return this.getCompDetails(t, hM, null, i);
    }, e.prototype.getCellEditorDetails = function(t, i) {
      return this.getCompDetails(t, zK, "agCellEditor", i, !0);
    }, e.prototype.getFilterDetails = function(t, i, r) {
      return this.getCompDetails(t, k1, r, i, !0);
    }, e.prototype.getDateCompDetails = function(t) {
      return this.getCompDetails(this.gridOptions, HK, "agDateInput", t, !0);
    }, e.prototype.getLoadingOverlayCompDetails = function(t) {
      return this.getCompDetails(this.gridOptions, jK, "agLoadingOverlay", t, !0);
    }, e.prototype.getNoRowsOverlayCompDetails = function(t) {
      return this.getCompDetails(this.gridOptions, $K, "agNoRowsOverlay", t, !0);
    }, e.prototype.getTooltipCompDetails = function(t) {
      return this.getCompDetails(t.colDef, KK, "agTooltipComponent", t, !0);
    }, e.prototype.getSetFilterCellRendererDetails = function(t, i) {
      return this.getCompDetails(t, hM, null, i);
    }, e.prototype.getFloatingFilterCompDetails = function(t, i, r) {
      return this.getCompDetails(t, qK, r, i);
    }, e.prototype.getToolPanelCompDetails = function(t, i) {
      return this.getCompDetails(t, YK, null, i, !0);
    }, e.prototype.getStatusPanelCompDetails = function(t, i) {
      return this.getCompDetails(t, XK, null, i, !0);
    }, e.prototype.getCompDetails = function(t, i, r, o, s) {
      var a = this;
      s === void 0 && (s = !1);
      var l = i.propertyName, u = i.cellRenderer, c = this.getCompKeys(t, i, o), h = c.compName, d = c.jsComp, f = c.fwComp, p = c.paramsFromSelector, g = c.popupFromSelector, _ = c.popupPositionFromSelector, m = function(b) {
        var L = a.userComponentRegistry.retrieve(b);
        L && (d = L.componentFromFramework ? void 0 : L.component, f = L.componentFromFramework ? L.component : void 0);
      };
      if (h != null && m(h), d == null && f == null && r != null && m(r), d && u && !this.agComponentUtils.doesImplementIComponent(d) && (d = this.agComponentUtils.adaptFunction(l, d)), !d && !f) {
        s && console.error("Could not find component " + h + ", did you forget to configure this component?");
        return;
      }
      var v = this.mergeParamsWithApplicationProvidedParams(t, i, o, p), C = d == null, y = d || f;
      return {
        componentFromFramework: C,
        componentClass: y,
        params: v,
        type: i,
        popupFromSelector: g,
        popupPositionFromSelector: _,
        newAgStackInstance: function() {
          return a.newAgStackInstance(y, C, v, i);
        }
      };
    }, e.prototype.getCompKeys = function(t, i, r) {
      var o = this, s = i.propertyName, a, l, u, c, h, d;
      if (t) {
        var f = t, p = f[s + "Selector"], g = p ? p(r) : null, _ = function(v, C) {
          var y = function() {
            var L = "AG Grid: As of v27, the property " + s + "Framework is deprecated. The property " + s + " can now be used for JavaScript AND Framework Components.";
            mi(function() {
              return console.warn(L);
            }, "UserComponentFactory." + s + "FrameworkDeprecated");
          };
          if (typeof v == "string")
            a = v;
          else if (typeof C == "string")
            y(), a = C;
          else if (v != null && v !== !0) {
            var b = o.getFrameworkOverrides().isFrameworkComponent(v);
            b ? u = v : l = v;
          } else
            C != null && (y(), u = C);
        };
        if (g) {
          if (g.frameworkComponent != null) {
            var m = "AG Grid: As of v27, the return for " + s + "Selector has attributes [component, params] only. The attribute frameworkComponent is deprecated. You should now return back Framework Components using the 'component' attribute and the grid works out if it's a framework component or not.";
            mi(function() {
              return console.warn(m);
            }, "UserComponentFactory." + s + "FrameworkSelectorDeprecated"), _(g.frameworkComponent, void 0);
          } else
            _(g.component, void 0);
          c = g.params, h = g.popup, d = g.popupPosition;
        } else
          _(f[s], f[s + "Framework"]);
      }
      return { compName: a, jsComp: l, fwComp: u, paramsFromSelector: c, popupFromSelector: h, popupPositionFromSelector: d };
    }, e.prototype.newAgStackInstance = function(t, i, r, o) {
      var s = o.propertyName, a = !i, l;
      if (a)
        l = new t();
      else {
        var u = this.componentMetadataProvider.retrieve(s);
        l = this.frameworkComponentWrapper.wrap(t, u.mandatoryMethodList, u.optionalMethodList, o);
      }
      var c = this.initComponent(l, r);
      return c == null ? ko.resolve(l) : c.then(function() {
        return l;
      });
    }, e.prototype.mergeParamsWithApplicationProvidedParams = function(t, i, r, o) {
      o === void 0 && (o = null);
      var s = {};
      aa(s, r);
      var a = t, l = a && a[i.propertyName + "Params"];
      if (typeof l == "function") {
        var u = l(r);
        aa(s, u);
      } else
        typeof l == "object" && aa(s, l);
      return aa(s, o), s;
    }, e.prototype.initComponent = function(t, i) {
      if (this.context.createBean(t), t.init != null)
        return t.init(i);
    }, e.prototype.getDefaultFloatingFilterType = function(t) {
      if (t == null)
        return null;
      var i = null, r = this.getCompKeys(t, k1), o = r.compName, s = r.jsComp, a = r.fwComp;
      if (o)
        i = nH.getFloatingFilterType(o);
      else {
        var l = s == null && a == null && t.filter === !0;
        if (l) {
          var u = pt.isRegistered(ct.SetFilterModule);
          i = u ? "agSetColumnFloatingFilter" : "agTextColumnFloatingFilter";
        }
      }
      return i;
    }, hf([
      R("gridOptions")
    ], e.prototype, "gridOptions", void 0), hf([
      R("agComponentUtils")
    ], e.prototype, "agComponentUtils", void 0), hf([
      R("componentMetadataProvider")
    ], e.prototype, "componentMetadataProvider", void 0), hf([
      R("userComponentRegistry")
    ], e.prototype, "userComponentRegistry", void 0), hf([
      fi("frameworkComponentWrapper")
    ], e.prototype, "frameworkComponentWrapper", void 0), e = hf([
      Ke("userComponentFactory")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var oH = (
  /** @class */
  function() {
    function n() {
    }
    return n.parse = function(e) {
      if (!e)
        return null;
      if (e === !0)
        return {
          toolPanels: [
            n.DEFAULT_COLUMN_COMP,
            n.DEFAULT_FILTER_COMP
          ],
          defaultToolPanel: "columns"
        };
      if (typeof e == "string")
        return n.parse([e]);
      if (Array.isArray(e)) {
        var t = [];
        return e.forEach(function(r) {
          var o = n.DEFAULT_BY_KEY[r];
          if (!o) {
            console.warn("AG Grid: the key " + r + " is not a valid key for specifying a tool panel, valid keys are: " + Object.keys(n.DEFAULT_BY_KEY).join(","));
            return;
          }
          t.push(o);
        }), t.length === 0 ? null : {
          toolPanels: t,
          defaultToolPanel: t[0].id
        };
      }
      var i = {
        toolPanels: n.parseComponents(e.toolPanels),
        defaultToolPanel: e.defaultToolPanel,
        hiddenByDefault: e.hiddenByDefault,
        position: e.position
      };
      return i;
    }, n.parseComponents = function(e) {
      var t = [];
      return e && e.forEach(function(i) {
        var r = null;
        if (typeof i == "string") {
          var o = n.DEFAULT_BY_KEY[i];
          if (!o) {
            console.warn("AG Grid: the key " + i + " is not a valid key for specifying a tool panel, valid keys are: " + Object.keys(n.DEFAULT_BY_KEY).join(","));
            return;
          }
          r = o;
        } else
          r = i;
        t.push(r);
      }), t;
    }, n.DEFAULT_COLUMN_COMP = {
      id: "columns",
      labelDefault: "Columns",
      labelKey: "columns",
      iconKey: "columns",
      toolPanel: "agColumnsToolPanel"
    }, n.DEFAULT_FILTER_COMP = {
      id: "filters",
      labelDefault: "Filters",
      labelKey: "filters",
      iconKey: "filter",
      toolPanel: "agFiltersToolPanel"
    }, n.DEFAULT_BY_KEY = {
      columns: n.DEFAULT_COLUMN_COMP,
      filters: n.DEFAULT_FILTER_COMP
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gc = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, fM = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, iq = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, aL = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(iq(arguments[e]));
  return n;
}, nq = 25, rq = 300, oq = 5, sq = 5, aq = 10;
function le(n) {
  return n === !0 || n === "true";
}
function lL(n) {
  if (typeof n == "number")
    return n;
  if (typeof n == "string")
    return parseInt(n, 10);
}
function lq(n, e) {
  return n >= 0 ? n : e;
}
function pM(n, e) {
  var t = parseInt(n, 10);
  return Mw(t) && t > 0 ? t : e;
}
var Ve = (
  /** @class */
  function() {
    function n() {
      this.propertyEventService = new Zu(), this.domDataKey = "__AG_" + Math.random().toString(), this.destroyed = !1;
    }
    e = n, n.prototype.agWire = function(t, i) {
      this.gridOptions.api = t, this.gridOptions.columnApi = i, this.checkForDeprecated(), this.checkForViolations();
    }, n.prototype.destroy = function() {
      this.gridOptions.api = null, this.gridOptions.columnApi = null, this.destroyed = !0;
    }, n.prototype.init = function() {
      var t = this;
      this.gridOptions.suppressPropertyNamesCheck !== !0 && (this.checkGridOptionsProperties(), this.checkColumnDefProperties()), this.gridOptions.sideBar != null && (this.gridOptions.sideBar = oH.parse(this.gridOptions.sideBar));
      var i = this.useAsyncEvents();
      if (this.eventService.addGlobalListener(this.globalEventHandler.bind(this), i), this.isGroupSelectsChildren() && this.isSuppressParentsInRowNodes() && console.warn("AG Grid: 'groupSelectsChildren' does not work with 'suppressParentsInRowNodes', this selection method needs the part in rowNode to work"), this.isGroupSelectsChildren() && (this.isRowSelectionMulti() || console.warn("AG Grid: rowSelection must be 'multiple' for groupSelectsChildren to make sense"), this.isRowModelServerSide() && console.warn("AG Grid: group selects children is NOT support for Server Side Row Model. This is because the rows are lazy loaded, so selecting a group is not possible asthe grid has no way of knowing what the children are.")), this.isGroupRemoveSingleChildren() && this.isGroupHideOpenParents() && console.warn("AG Grid: groupRemoveSingleChildren and groupHideOpenParents do not work with each other, you need to pick one. And don't ask us how to us these together on our support forum either you will get the same answer!"), this.isRowModelServerSide()) {
        var r = function(s) {
          return "AG Grid: '" + s + "' is not supported on the Server-Side Row Model";
        };
        de(this.gridOptions.groupDefaultExpanded) && console.warn(r("groupDefaultExpanded")), de(this.gridOptions.groupDefaultExpanded) && console.warn(r("groupIncludeFooter")), de(this.gridOptions.groupDefaultExpanded) && console.warn(r("groupIncludeTotalFooter"));
      }
      this.isEnableRangeSelection() && pt.assertRegistered(ct.RangeSelectionModule, "enableRangeSelection"), !this.isEnableRangeSelection() && (this.isEnableRangeHandle() || this.isEnableFillHandle()) && console.warn("AG Grid: 'enableRangeHandle' and 'enableFillHandle' will not work unless 'enableRangeSelection' is set to true");
      var o = function(s) {
        t.gridOptions.icons && t.gridOptions.icons[s] && console.warn("gridOptions.icons." + s + " is no longer supported. For information on how to style checkboxes and radio buttons, see https://www.ag-grid.com/javascript-grid-icons/");
      };
      o("radioButtonOff"), o("radioButtonOn"), o("checkboxChecked"), o("checkboxUnchecked"), o("checkboxIndeterminate"), this.getScrollbarWidth();
    }, n.prototype.checkColumnDefProperties = function() {
      var t = this;
      this.gridOptions.columnDefs != null && this.gridOptions.columnDefs.forEach(function(i) {
        var r = Object.getOwnPropertyNames(i), o = aL(E1.ALL_PROPERTIES, E1.FRAMEWORK_PROPERTIES);
        t.checkProperties(r, o, o, "colDef", "https://www.ag-grid.com/javascript-grid-column-properties/");
      });
    }, n.prototype.checkGridOptionsProperties = function() {
      var t = Object.getOwnPropertyNames(this.gridOptions), i = aL(Ol.ALL_PROPERTIES, Ol.FRAMEWORK_PROPERTIES, Gd(I).map(function(o) {
        return zc.getCallbackForEvent(o);
      })), r = aL(i, ["api", "columnApi"]);
      this.checkProperties(t, r, i, "gridOptions", "https://www.ag-grid.com/javascript-grid-properties/");
    }, n.prototype.checkProperties = function(t, i, r, o, s) {
      var a = AB(t, i, r);
      pi(a, function(l, u) {
        console.warn("ag-grid: invalid " + o + " property '" + l + "' did you mean any of these: " + u.slice(0, 8).join(", "));
      }), Object.keys(a).length > 0 && console.warn("ag-grid: to see all the valid " + o + " properties please check: " + s);
    }, n.prototype.getDomDataKey = function() {
      return this.domDataKey;
    }, n.prototype.getDomData = function(t, i) {
      var r = t[this.getDomDataKey()];
      return r ? r[i] : void 0;
    }, n.prototype.setDomData = function(t, i, r) {
      var o = this.getDomDataKey(), s = t[o];
      Je(s) && (s = {}, t[o] = s), s[i] = r;
    }, n.prototype.isRowSelection = function() {
      return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple";
    }, n.prototype.isSuppressRowDeselection = function() {
      return le(this.gridOptions.suppressRowDeselection);
    }, n.prototype.isRowSelectionMulti = function() {
      return this.gridOptions.rowSelection === "multiple";
    }, n.prototype.isRowMultiSelectWithClick = function() {
      return le(this.gridOptions.rowMultiSelectWithClick);
    }, n.prototype.getContext = function() {
      return this.gridOptions.context;
    }, n.prototype.isPivotMode = function() {
      return le(this.gridOptions.pivotMode);
    }, n.prototype.isSuppressExpandablePivotGroups = function() {
      return le(this.gridOptions.suppressExpandablePivotGroups);
    }, n.prototype.getPivotColumnGroupTotals = function() {
      return this.gridOptions.pivotColumnGroupTotals;
    }, n.prototype.getPivotRowTotals = function() {
      return this.gridOptions.pivotRowTotals;
    }, n.prototype.isRowModelInfinite = function() {
      return this.gridOptions.rowModelType === q.ROW_MODEL_TYPE_INFINITE;
    }, n.prototype.isRowModelViewport = function() {
      return this.gridOptions.rowModelType === q.ROW_MODEL_TYPE_VIEWPORT;
    }, n.prototype.isRowModelServerSide = function() {
      return this.gridOptions.rowModelType === q.ROW_MODEL_TYPE_SERVER_SIDE;
    }, n.prototype.isRowModelDefault = function() {
      return Je(this.gridOptions.rowModelType) || this.gridOptions.rowModelType === q.ROW_MODEL_TYPE_CLIENT_SIDE;
    }, n.prototype.isFullRowEdit = function() {
      return this.gridOptions.editType === "fullRow";
    }, n.prototype.isSuppressFocusAfterRefresh = function() {
      return le(this.gridOptions.suppressFocusAfterRefresh);
    }, n.prototype.isSuppressBrowserResizeObserver = function() {
      return le(this.gridOptions.suppressBrowserResizeObserver);
    }, n.prototype.isSuppressMaintainUnsortedOrder = function() {
      return le(this.gridOptions.suppressMaintainUnsortedOrder);
    }, n.prototype.isSuppressClearOnFillReduction = function() {
      return le(this.gridOptions.suppressClearOnFillReduction);
    }, n.prototype.isShowToolPanel = function() {
      return le(this.gridOptions.sideBar && Array.isArray(this.getSideBar().toolPanels));
    }, n.prototype.getSideBar = function() {
      return this.gridOptions.sideBar;
    }, n.prototype.isSuppressTouch = function() {
      return le(this.gridOptions.suppressTouch);
    }, n.prototype.isMaintainColumnOrder = function() {
      return le(this.gridOptions.maintainColumnOrder);
    }, n.prototype.isSuppressRowTransform = function() {
      return le(this.gridOptions.suppressRowTransform);
    }, n.prototype.isSuppressColumnStateEvents = function() {
      return le(this.gridOptions.suppressColumnStateEvents);
    }, n.prototype.isAllowDragFromColumnsToolPanel = function() {
      return le(this.gridOptions.allowDragFromColumnsToolPanel);
    }, n.prototype.useAsyncEvents = function() {
      return !le(this.gridOptions.suppressAsyncEvents);
    }, n.prototype.isEnableCellChangeFlash = function() {
      return le(this.gridOptions.enableCellChangeFlash);
    }, n.prototype.getCellFlashDelay = function() {
      return this.gridOptions.cellFlashDelay || 500;
    }, n.prototype.getCellFadeDelay = function() {
      return this.gridOptions.cellFadeDelay || 1e3;
    }, n.prototype.isGroupSelectsChildren = function() {
      var t = le(this.gridOptions.groupSelectsChildren);
      return t && this.isTreeData() ? (console.warn("AG Grid: groupSelectsChildren does not work with tree data"), !1) : t;
    }, n.prototype.isSuppressRowHoverHighlight = function() {
      return le(this.gridOptions.suppressRowHoverHighlight);
    }, n.prototype.isColumnHoverHighlight = function() {
      return le(this.gridOptions.columnHoverHighlight);
    }, n.prototype.isGroupSelectsFiltered = function() {
      return le(this.gridOptions.groupSelectsFiltered);
    }, n.prototype.isGroupHideOpenParents = function() {
      return le(this.gridOptions.groupHideOpenParents);
    }, n.prototype.isGroupMaintainOrder = function() {
      return le(this.gridOptions.groupMaintainOrder);
    }, n.prototype.getAutoGroupColumnDef = function() {
      return this.gridOptions.autoGroupColumnDef;
    }, n.prototype.isGroupMultiAutoColumn = function() {
      return this.gridOptions.groupDisplayType ? this.matchesGroupDisplayType("multipleColumns", this.gridOptions.groupDisplayType) : le(this.gridOptions.groupHideOpenParents);
    }, n.prototype.isGroupUseEntireRow = function(t) {
      return t ? !1 : this.gridOptions.groupDisplayType ? this.matchesGroupDisplayType("groupRows", this.gridOptions.groupDisplayType) : !1;
    }, n.prototype.isGroupSuppressAutoColumn = function() {
      var t = this.gridOptions.groupDisplayType ? this.matchesGroupDisplayType("custom", this.gridOptions.groupDisplayType) : !1;
      return t ? !0 : this.gridOptions.treeDataDisplayType ? this.matchesTreeDataDisplayType("custom", this.gridOptions.treeDataDisplayType) : !1;
    }, n.prototype.isGroupRemoveSingleChildren = function() {
      return le(this.gridOptions.groupRemoveSingleChildren);
    }, n.prototype.isGroupRemoveLowestSingleChildren = function() {
      return le(this.gridOptions.groupRemoveLowestSingleChildren);
    }, n.prototype.isGroupIncludeFooter = function() {
      return le(this.gridOptions.groupIncludeFooter);
    }, n.prototype.isGroupIncludeTotalFooter = function() {
      return le(this.gridOptions.groupIncludeTotalFooter);
    }, n.prototype.isGroupSuppressBlankHeader = function() {
      return le(this.gridOptions.groupSuppressBlankHeader);
    }, n.prototype.isSuppressRowClickSelection = function() {
      return le(this.gridOptions.suppressRowClickSelection);
    }, n.prototype.isSuppressCellFocus = function() {
      return le(this.gridOptions.suppressCellFocus);
    }, n.prototype.isSuppressMultiSort = function() {
      return le(this.gridOptions.suppressMultiSort);
    }, n.prototype.isMultiSortKeyCtrl = function() {
      return this.gridOptions.multiSortKey === "ctrl";
    }, n.prototype.isPivotSuppressAutoColumn = function() {
      return le(this.gridOptions.pivotSuppressAutoColumn);
    }, n.prototype.isSuppressDragLeaveHidesColumns = function() {
      return le(this.gridOptions.suppressDragLeaveHidesColumns);
    }, n.prototype.isSuppressScrollOnNewData = function() {
      return le(this.gridOptions.suppressScrollOnNewData);
    }, n.prototype.isSuppressScrollWhenPopupsAreOpen = function() {
      return le(this.gridOptions.suppressScrollWhenPopupsAreOpen);
    }, n.prototype.isRowDragEntireRow = function() {
      return le(this.gridOptions.rowDragEntireRow);
    }, n.prototype.isSuppressRowDrag = function() {
      return le(this.gridOptions.suppressRowDrag);
    }, n.prototype.isRowDragManaged = function() {
      return le(this.gridOptions.rowDragManaged);
    }, n.prototype.isSuppressMoveWhenRowDragging = function() {
      return le(this.gridOptions.suppressMoveWhenRowDragging);
    }, n.prototype.isRowDragMultiRow = function() {
      return le(this.gridOptions.rowDragMultiRow);
    }, n.prototype.getDomLayout = function() {
      var t = this.gridOptions.domLayout || q.DOM_LAYOUT_NORMAL, i = [
        q.DOM_LAYOUT_PRINT,
        q.DOM_LAYOUT_AUTO_HEIGHT,
        q.DOM_LAYOUT_NORMAL
      ];
      return i.indexOf(t) === -1 ? (mi(function() {
        return console.warn("AG Grid: " + t + " is not valid for DOM Layout, valid values are " + q.DOM_LAYOUT_NORMAL + ", " + q.DOM_LAYOUT_AUTO_HEIGHT + " and " + q.DOM_LAYOUT_PRINT);
      }, "warn about dom layout values"), q.DOM_LAYOUT_NORMAL) : t;
    }, n.prototype.isSuppressHorizontalScroll = function() {
      return le(this.gridOptions.suppressHorizontalScroll);
    }, n.prototype.isSuppressMaxRenderedRowRestriction = function() {
      return le(this.gridOptions.suppressMaxRenderedRowRestriction);
    }, n.prototype.isExcludeChildrenWhenTreeDataFiltering = function() {
      return le(this.gridOptions.excludeChildrenWhenTreeDataFiltering);
    }, n.prototype.isAlwaysShowHorizontalScroll = function() {
      return le(this.gridOptions.alwaysShowHorizontalScroll);
    }, n.prototype.isAlwaysShowVerticalScroll = function() {
      return le(this.gridOptions.alwaysShowVerticalScroll);
    }, n.prototype.isDebounceVerticalScrollbar = function() {
      return le(this.gridOptions.debounceVerticalScrollbar);
    }, n.prototype.isSuppressLoadingOverlay = function() {
      return le(this.gridOptions.suppressLoadingOverlay);
    }, n.prototype.isSuppressNoRowsOverlay = function() {
      return le(this.gridOptions.suppressNoRowsOverlay);
    }, n.prototype.isSuppressFieldDotNotation = function() {
      return le(this.gridOptions.suppressFieldDotNotation);
    }, n.prototype.getPinnedTopRowData = function() {
      return this.gridOptions.pinnedTopRowData;
    }, n.prototype.getPinnedBottomRowData = function() {
      return this.gridOptions.pinnedBottomRowData;
    }, n.prototype.isFunctionsPassive = function() {
      return le(this.gridOptions.functionsPassive);
    }, n.prototype.isSuppressChangeDetection = function() {
      return le(this.gridOptions.suppressChangeDetection);
    }, n.prototype.isSuppressAnimationFrame = function() {
      return le(this.gridOptions.suppressAnimationFrame);
    }, n.prototype.getQuickFilterText = function() {
      return this.gridOptions.quickFilterText;
    }, n.prototype.isCacheQuickFilter = function() {
      return le(this.gridOptions.cacheQuickFilter);
    }, n.prototype.isUnSortIcon = function() {
      return le(this.gridOptions.unSortIcon);
    }, n.prototype.isSuppressMenuHide = function() {
      return le(this.gridOptions.suppressMenuHide);
    }, n.prototype.isEnterMovesDownAfterEdit = function() {
      return le(this.gridOptions.enterMovesDownAfterEdit);
    }, n.prototype.isEnterMovesDown = function() {
      return le(this.gridOptions.enterMovesDown);
    }, n.prototype.isUndoRedoCellEditing = function() {
      return le(this.gridOptions.undoRedoCellEditing);
    }, n.prototype.getUndoRedoCellEditingLimit = function() {
      return lL(this.gridOptions.undoRedoCellEditingLimit);
    }, n.prototype.getRowStyle = function() {
      return this.gridOptions.rowStyle;
    }, n.prototype.getRowClass = function() {
      return this.gridOptions.rowClass;
    }, n.prototype.getRowStyleFunc = function() {
      return this.gridOptions.getRowStyle;
    }, n.prototype.getRowClassFunc = function() {
      return this.gridOptions.getRowClass;
    }, n.prototype.rowClassRules = function() {
      return this.gridOptions.rowClassRules;
    }, n.prototype.getServerSideStoreType = function() {
      return this.gridOptions.serverSideStoreType;
    }, n.prototype.getServerSideStoreParamsFunc = function() {
      return this.gridOptions.getServerSideStoreParams;
    }, n.prototype.getCreateChartContainerFunc = function() {
      return this.gridOptions.createChartContainer;
    }, n.prototype.getPopupParent = function() {
      return this.gridOptions.popupParent;
    }, n.prototype.getBlockLoadDebounceMillis = function() {
      return this.gridOptions.blockLoadDebounceMillis;
    }, n.prototype.getPostProcessPopupFunc = function() {
      return this.gridOptions.postProcessPopup;
    }, n.prototype.getPaginationNumberFormatterFunc = function() {
      return this.gridOptions.paginationNumberFormatter;
    }, n.prototype.getChildCountFunc = function() {
      return this.gridOptions.getChildCount;
    }, n.prototype.getIsApplyServerSideTransactionFunc = function() {
      return this.gridOptions.isApplyServerSideTransaction;
    }, n.prototype.getDefaultGroupOrderComparator = function() {
      return this.gridOptions.defaultGroupOrderComparator;
    }, n.prototype.getIsFullWidthCellFunc = function() {
      return this.gridOptions.isFullWidthCell;
    }, n.prototype.getFullWidthCellRendererParams = function() {
      return this.gridOptions.fullWidthCellRendererParams;
    }, n.prototype.isEmbedFullWidthRows = function() {
      return le(this.gridOptions.embedFullWidthRows) || le(this.gridOptions.deprecatedEmbedFullWidthRows);
    }, n.prototype.isDetailRowAutoHeight = function() {
      return le(this.gridOptions.detailRowAutoHeight);
    }, n.prototype.getSuppressKeyboardEventFunc = function() {
      return this.gridOptions.suppressKeyboardEvent;
    }, n.prototype.getBusinessKeyForNodeFunc = function() {
      return this.gridOptions.getBusinessKeyForNode;
    }, n.prototype.getApi = function() {
      return this.gridOptions.api;
    }, n.prototype.getColumnApi = function() {
      return this.gridOptions.columnApi;
    }, n.prototype.isReadOnlyEdit = function() {
      return le(this.gridOptions.readOnlyEdit);
    }, n.prototype.isImmutableData = function() {
      return this.gridOptions.getRowId != null || le(this.gridOptions.immutableData);
    }, n.prototype.isEnsureDomOrder = function() {
      return le(this.gridOptions.ensureDomOrder);
    }, n.prototype.isEnableCharts = function() {
      return le(this.gridOptions.enableCharts) ? pt.assertRegistered(ct.GridChartsModule, "enableCharts") : !1;
    }, n.prototype.getColResizeDefault = function() {
      return this.gridOptions.colResizeDefault;
    }, n.prototype.isSingleClickEdit = function() {
      return le(this.gridOptions.singleClickEdit);
    }, n.prototype.isSuppressClickEdit = function() {
      return le(this.gridOptions.suppressClickEdit);
    }, n.prototype.isStopEditingWhenCellsLoseFocus = function() {
      return le(this.gridOptions.stopEditingWhenCellsLoseFocus);
    }, n.prototype.getGroupDefaultExpanded = function() {
      return this.gridOptions.groupDefaultExpanded;
    }, n.prototype.getMaxConcurrentDatasourceRequests = function() {
      var t = lL(this.gridOptions.maxConcurrentDatasourceRequests);
      if (t == null)
        return 2;
      if (!(t <= 0))
        return t;
    }, n.prototype.getMaxBlocksInCache = function() {
      return this.gridOptions.maxBlocksInCache;
    }, n.prototype.getCacheOverflowSize = function() {
      return this.gridOptions.cacheOverflowSize;
    }, n.prototype.getPaginationPageSize = function() {
      return lL(this.gridOptions.paginationPageSize);
    }, n.prototype.isPaginateChildRows = function() {
      var t = this.isGroupRemoveSingleChildren() || this.isGroupRemoveLowestSingleChildren();
      return t ? !0 : le(this.gridOptions.paginateChildRows);
    }, n.prototype.getCacheBlockSize = function() {
      return pM(this.gridOptions.cacheBlockSize);
    }, n.prototype.getInfiniteInitialRowCount = function() {
      return this.gridOptions.infiniteInitialRowCount;
    }, n.prototype.isPurgeClosedRowNodes = function() {
      return le(this.gridOptions.purgeClosedRowNodes);
    }, n.prototype.isSuppressPaginationPanel = function() {
      return le(this.gridOptions.suppressPaginationPanel);
    }, n.prototype.getRowData = function() {
      return this.gridOptions.rowData;
    }, n.prototype.isEnableRtl = function() {
      return le(this.gridOptions.enableRtl);
    }, n.prototype.getRowGroupPanelShow = function() {
      return this.gridOptions.rowGroupPanelShow;
    }, n.prototype.getPivotPanelShow = function() {
      return this.gridOptions.pivotPanelShow;
    }, n.prototype.isAngularCompileRows = function() {
      return le(this.gridOptions.angularCompileRows);
    }, n.prototype.isAngularCompileFilters = function() {
      return le(this.gridOptions.angularCompileFilters);
    }, n.prototype.isDebug = function() {
      return le(this.gridOptions.debug);
    }, n.prototype.getColumnDefs = function() {
      return this.gridOptions.columnDefs;
    }, n.prototype.getColumnTypes = function() {
      return this.gridOptions.columnTypes;
    }, n.prototype.getDatasource = function() {
      return this.gridOptions.datasource;
    }, n.prototype.getViewportDatasource = function() {
      return this.gridOptions.viewportDatasource;
    }, n.prototype.getServerSideDatasource = function() {
      return this.gridOptions.serverSideDatasource;
    }, n.prototype.isAccentedSort = function() {
      return le(this.gridOptions.accentedSort);
    }, n.prototype.isEnableBrowserTooltips = function() {
      return le(this.gridOptions.enableBrowserTooltips);
    }, n.prototype.isEnableCellExpressions = function() {
      return le(this.gridOptions.enableCellExpressions);
    }, n.prototype.isEnableGroupEdit = function() {
      return le(this.gridOptions.enableGroupEdit);
    }, n.prototype.isSuppressMiddleClickScrolls = function() {
      return le(this.gridOptions.suppressMiddleClickScrolls);
    }, n.prototype.isPreventDefaultOnContextMenu = function() {
      return le(this.gridOptions.preventDefaultOnContextMenu);
    }, n.prototype.isSuppressPreventDefaultOnMouseWheel = function() {
      return le(this.gridOptions.suppressPreventDefaultOnMouseWheel);
    }, n.prototype.isSuppressColumnVirtualisation = function() {
      return le(this.gridOptions.suppressColumnVirtualisation);
    }, n.prototype.isSuppressRowVirtualisation = function() {
      return le(this.gridOptions.suppressRowVirtualisation);
    }, n.prototype.isSuppressContextMenu = function() {
      return le(this.gridOptions.suppressContextMenu);
    }, n.prototype.isAllowContextMenuWithControlKey = function() {
      return le(this.gridOptions.allowContextMenuWithControlKey);
    }, n.prototype.isSuppressCopyRowsToClipboard = function() {
      return le(this.gridOptions.suppressCopyRowsToClipboard);
    }, n.prototype.isCopyHeadersToClipboard = function() {
      return le(this.gridOptions.copyHeadersToClipboard);
    }, n.prototype.isCopyGroupHeadersToClipboard = function() {
      return le(this.gridOptions.copyGroupHeadersToClipboard);
    }, n.prototype.isSuppressClipboardPaste = function() {
      return le(this.gridOptions.suppressClipboardPaste);
    }, n.prototype.isSuppressLastEmptyLineOnPaste = function() {
      return le(this.gridOptions.suppressLastEmptyLineOnPaste);
    }, n.prototype.isPagination = function() {
      return le(this.gridOptions.pagination);
    }, n.prototype.isSuppressEnterpriseResetOnNewColumns = function() {
      return le(this.gridOptions.suppressEnterpriseResetOnNewColumns);
    }, n.prototype.getProcessDataFromClipboardFunc = function() {
      return this.gridOptions.processDataFromClipboard;
    }, n.prototype.getAsyncTransactionWaitMillis = function() {
      return de(this.gridOptions.asyncTransactionWaitMillis) ? this.gridOptions.asyncTransactionWaitMillis : q.BATCH_WAIT_MILLIS;
    }, n.prototype.isSuppressMovableColumns = function() {
      return le(this.gridOptions.suppressMovableColumns);
    }, n.prototype.isAnimateRows = function() {
      return this.isEnsureDomOrder() ? !1 : le(this.gridOptions.animateRows);
    }, n.prototype.isSuppressColumnMoveAnimation = function() {
      return le(this.gridOptions.suppressColumnMoveAnimation);
    }, n.prototype.isSuppressAggFuncInHeader = function() {
      return le(this.gridOptions.suppressAggFuncInHeader);
    }, n.prototype.isSuppressAggAtRootLevel = function() {
      return le(this.gridOptions.suppressAggAtRootLevel);
    }, n.prototype.isSuppressAggFilteredOnly = function() {
      return le(this.gridOptions.suppressAggFilteredOnly);
    }, n.prototype.isShowOpenedGroup = function() {
      return le(this.gridOptions.showOpenedGroup);
    }, n.prototype.isReactUi = function() {
      return le(this.gridOptions.reactUi);
    }, n.prototype.isSuppressReactUi = function() {
      return le(this.gridOptions.suppressReactUi);
    }, n.prototype.isEnableRangeSelection = function() {
      return pt.isRegistered(ct.RangeSelectionModule) && le(this.gridOptions.enableRangeSelection);
    }, n.prototype.isEnableRangeHandle = function() {
      return le(this.gridOptions.enableRangeHandle);
    }, n.prototype.isEnableFillHandle = function() {
      return le(this.gridOptions.enableFillHandle);
    }, n.prototype.getFillHandleDirection = function() {
      var t = this.gridOptions.fillHandleDirection;
      return t ? t !== "x" && t !== "y" && t !== "xy" ? (mi(function() {
        return console.warn("AG Grid: valid values for fillHandleDirection are 'x', 'y' and 'xy'. Default to 'xy'.");
      }, "warn invalid fill direction"), "xy") : t : "xy";
    }, n.prototype.getFillOperation = function() {
      return this.gridOptions.fillOperation;
    }, n.prototype.isSuppressMultiRangeSelection = function() {
      return le(this.gridOptions.suppressMultiRangeSelection);
    }, n.prototype.isPaginationAutoPageSize = function() {
      return le(this.gridOptions.paginationAutoPageSize);
    }, n.prototype.isRememberGroupStateWhenNewData = function() {
      return le(this.gridOptions.rememberGroupStateWhenNewData);
    }, n.prototype.getIcons = function() {
      return this.gridOptions.icons;
    }, n.prototype.getAggFuncs = function() {
      return this.gridOptions.aggFuncs;
    }, n.prototype.getSortingOrder = function() {
      return this.gridOptions.sortingOrder;
    }, n.prototype.getAlignedGrids = function() {
      return this.gridOptions.alignedGrids;
    }, n.prototype.isMasterDetail = function() {
      var t = le(this.gridOptions.masterDetail);
      return t ? pt.assertRegistered(ct.MasterDetailModule, "masterDetail") : !1;
    }, n.prototype.isKeepDetailRows = function() {
      return le(this.gridOptions.keepDetailRows);
    }, n.prototype.getKeepDetailRowsCount = function() {
      var t = this.gridOptions.keepDetailRowsCount;
      return de(t) && t > 0 ? this.gridOptions.keepDetailRowsCount : aq;
    }, n.prototype.getIsRowMasterFunc = function() {
      return this.gridOptions.isRowMaster;
    }, n.prototype.getIsRowSelectableFunc = function() {
      return this.gridOptions.isRowSelectable;
    }, n.prototype.getGroupRowRendererParams = function() {
      return this.gridOptions.groupRowRendererParams;
    }, n.prototype.getOverlayLoadingTemplate = function() {
      return this.gridOptions.overlayLoadingTemplate;
    }, n.prototype.getOverlayNoRowsTemplate = function() {
      return this.gridOptions.overlayNoRowsTemplate;
    }, n.prototype.isSuppressAutoSize = function() {
      return le(this.gridOptions.suppressAutoSize);
    }, n.prototype.isEnableCellTextSelection = function() {
      return le(this.gridOptions.enableCellTextSelection);
    }, n.prototype.isSuppressParentsInRowNodes = function() {
      return le(this.gridOptions.suppressParentsInRowNodes);
    }, n.prototype.isSuppressClipboardApi = function() {
      return le(this.gridOptions.suppressClipboardApi);
    }, n.prototype.isFunctionsReadOnly = function() {
      return le(this.gridOptions.functionsReadOnly);
    }, n.prototype.isEnableCellTextSelect = function() {
      return le(this.gridOptions.enableCellTextSelection);
    }, n.prototype.getDefaultColDef = function() {
      return this.gridOptions.defaultColDef;
    }, n.prototype.getDefaultColGroupDef = function() {
      return this.gridOptions.defaultColGroupDef;
    }, n.prototype.getDefaultExportParams = function(t) {
      if (this.gridOptions.defaultExportParams)
        return console.warn("AG Grid: Since v25.2 `defaultExportParams`  has been replaced by `default" + b1(t) + "ExportParams`'"), t === "csv" ? this.gridOptions.defaultExportParams : this.gridOptions.defaultExportParams;
      if (t === "csv" && this.gridOptions.defaultCsvExportParams)
        return this.gridOptions.defaultCsvExportParams;
      if (t === "excel" && this.gridOptions.defaultExcelExportParams)
        return this.gridOptions.defaultExcelExportParams;
    }, n.prototype.isSuppressCsvExport = function() {
      return le(this.gridOptions.suppressCsvExport);
    }, n.prototype.isAllowShowChangeAfterFilter = function() {
      return le(this.gridOptions.allowShowChangeAfterFilter);
    }, n.prototype.isSuppressExcelExport = function() {
      return le(this.gridOptions.suppressExcelExport);
    }, n.prototype.isSuppressMakeColumnVisibleAfterUnGroup = function() {
      return le(this.gridOptions.suppressMakeColumnVisibleAfterUnGroup);
    }, n.prototype.getDataPathFunc = function() {
      return this.gridOptions.getDataPath;
    }, n.prototype.getIsServerSideGroupFunc = function() {
      return this.gridOptions.isServerSideGroup;
    }, n.prototype.getIsServerSideGroupOpenByDefaultFunc = function() {
      return this.gridOptions.isServerSideGroupOpenByDefault;
    }, n.prototype.getIsGroupOpenByDefaultFunc = function() {
      return this.gridOptions.isGroupOpenByDefault;
    }, n.prototype.getServerSideGroupKeyFunc = function() {
      return this.gridOptions.getServerSideGroupKey;
    }, n.prototype.getGroupRowAggNodesFunc = function() {
      return this.gridOptions.groupRowAggNodes;
    }, n.prototype.getContextMenuItemsFunc = function() {
      return this.gridOptions.getContextMenuItems;
    }, n.prototype.getMainMenuItemsFunc = function() {
      return this.gridOptions.getMainMenuItems;
    }, n.prototype.getRowIdFunc = function() {
      var t = this.gridOptions, i = t.getRowId, r = t.getRowNodeId;
      if (i)
        return i;
      if (r)
        return function(o) {
          return r(o.data);
        };
    }, n.prototype.getNavigateToNextHeaderFunc = function() {
      return this.gridOptions.navigateToNextHeader;
    }, n.prototype.getTabToNextHeaderFunc = function() {
      return this.gridOptions.tabToNextHeader;
    }, n.prototype.getNavigateToNextCellFunc = function() {
      return this.gridOptions.navigateToNextCell;
    }, n.prototype.getTabToNextCellFunc = function() {
      return this.gridOptions.tabToNextCell;
    }, n.prototype.getGridTabIndex = function() {
      return (this.gridOptions.tabIndex || 0).toString();
    }, n.prototype.isTreeData = function() {
      var t = le(this.gridOptions.treeData);
      return t ? pt.assertRegistered(ct.RowGroupingModule, "Tree Data") : !1;
    }, n.prototype.isValueCache = function() {
      return le(this.gridOptions.valueCache);
    }, n.prototype.isValueCacheNeverExpires = function() {
      return le(this.gridOptions.valueCacheNeverExpires);
    }, n.prototype.isDeltaSort = function() {
      return le(this.gridOptions.deltaSort);
    }, n.prototype.isAggregateOnlyChangedColumns = function() {
      return le(this.gridOptions.aggregateOnlyChangedColumns);
    }, n.prototype.getProcessSecondaryColDefFunc = function() {
      return this.gridOptions.processSecondaryColDef;
    }, n.prototype.getProcessSecondaryColGroupDefFunc = function() {
      return this.gridOptions.processSecondaryColGroupDef;
    }, n.prototype.getSendToClipboardFunc = function() {
      return this.gridOptions.sendToClipboard;
    }, n.prototype.getProcessRowPostCreateFunc = function() {
      return this.gridOptions.processRowPostCreate;
    }, n.prototype.getProcessCellForClipboardFunc = function() {
      return this.gridOptions.processCellForClipboard;
    }, n.prototype.getProcessHeaderForClipboardFunc = function() {
      return this.gridOptions.processHeaderForClipboard;
    }, n.prototype.getProcessGroupHeaderForClipboardFunc = function() {
      return this.gridOptions.processGroupHeaderForClipboard;
    }, n.prototype.getProcessCellFromClipboardFunc = function() {
      return this.gridOptions.processCellFromClipboard;
    }, n.prototype.getViewportRowModelPageSize = function() {
      return pM(this.gridOptions.viewportRowModelPageSize, oq);
    }, n.prototype.getViewportRowModelBufferSize = function() {
      return lq(this.gridOptions.viewportRowModelBufferSize, sq);
    }, n.prototype.isServerSideSortingAlwaysResets = function() {
      return le(this.gridOptions.serverSideSortingAlwaysResets);
    }, n.prototype.isServerSideFilteringAlwaysResets = function() {
      return le(this.gridOptions.serverSideFilteringAlwaysResets);
    }, n.prototype.getPostSortFunc = function() {
      return this.gridOptions.postSort;
    }, n.prototype.getChartToolbarItemsFunc = function() {
      return this.gridOptions.getChartToolbarItems;
    }, n.prototype.getChartThemeOverrides = function() {
      return this.gridOptions.chartThemeOverrides;
    }, n.prototype.getCustomChartThemes = function() {
      return this.gridOptions.customChartThemes;
    }, n.prototype.getChartThemes = function() {
      return this.gridOptions.chartThemes || ["ag-default", "ag-material", "ag-pastel", "ag-vivid", "ag-solar"];
    }, n.prototype.getClipboardDelimiter = function() {
      return de(this.gridOptions.clipboardDelimiter) ? this.gridOptions.clipboardDelimiter : "	";
    }, n.prototype.setProperty = function(t, i, r) {
      r === void 0 && (r = !1);
      var o = this.gridOptions, s = o[t];
      if (r || s !== i) {
        o[t] = i;
        var a = {
          type: t,
          currentValue: i,
          previousValue: s
        };
        this.propertyEventService.dispatchEvent(a);
      }
    }, n.prototype.addEventListener = function(t, i) {
      this.propertyEventService.addEventListener(t, i);
    }, n.prototype.removeEventListener = function(t, i) {
      this.propertyEventService.removeEventListener(t, i);
    }, n.prototype.isSkipHeaderOnAutoSize = function() {
      return !!this.gridOptions.skipHeaderOnAutoSize;
    }, n.prototype.getAutoSizePadding = function() {
      var t = this.gridOptions.autoSizePadding;
      return t != null && t >= 0 ? t : 20;
    }, n.prototype.getHeaderHeight = function() {
      return typeof this.gridOptions.headerHeight == "number" ? this.gridOptions.headerHeight : this.getFromTheme(25, "headerHeight");
    }, n.prototype.getFloatingFiltersHeight = function() {
      return typeof this.gridOptions.floatingFiltersHeight == "number" ? this.gridOptions.floatingFiltersHeight : this.getFromTheme(25, "headerHeight");
    }, n.prototype.getGroupHeaderHeight = function() {
      return typeof this.gridOptions.groupHeaderHeight == "number" ? this.gridOptions.groupHeaderHeight : this.getHeaderHeight();
    }, n.prototype.getPivotHeaderHeight = function() {
      return typeof this.gridOptions.pivotHeaderHeight == "number" ? this.gridOptions.pivotHeaderHeight : this.getHeaderHeight();
    }, n.prototype.getPivotGroupHeaderHeight = function() {
      return typeof this.gridOptions.pivotGroupHeaderHeight == "number" ? this.gridOptions.pivotGroupHeaderHeight : this.getGroupHeaderHeight();
    }, n.prototype.isExternalFilterPresent = function() {
      return typeof this.gridOptions.isExternalFilterPresent == "function" ? this.gridOptions.isExternalFilterPresent() : !1;
    }, n.prototype.doesExternalFilterPass = function(t) {
      return typeof this.gridOptions.doesExternalFilterPass == "function" ? this.gridOptions.doesExternalFilterPass(t) : !1;
    }, n.prototype.getTooltipDelay = function(t) {
      var i = this.gridOptions, r = i.tooltipShowDelay, o = i.tooltipHideDelay, s = t === "show" ? r : o, a = b1(t);
      return de(s) ? (s < 0 && mi(function() {
        return console.warn("ag-grid: tooltip" + a + "Delay should not be lower than 0");
      }, "tooltip" + a + "DelayWarn"), Math.max(200, s)) : null;
    }, n.prototype.isTooltipMouseTrack = function() {
      return le(this.gridOptions.tooltipMouseTrack);
    }, n.prototype.isSuppressModelUpdateAfterUpdateTransaction = function() {
      return le(this.gridOptions.suppressModelUpdateAfterUpdateTransaction);
    }, n.prototype.getDocument = function() {
      var t = null;
      return this.gridOptions.getDocument && de(this.gridOptions.getDocument) ? t = this.gridOptions.getDocument() : this.eGridDiv && (t = this.eGridDiv.ownerDocument), t && de(t) ? t : document;
    }, n.prototype.getMinColWidth = function() {
      var t = this.gridOptions.minColWidth;
      if (de(t) && t > e.MIN_COL_WIDTH)
        return this.gridOptions.minColWidth;
      var i = this.getFromTheme(null, "headerCellMinWidth");
      return de(i) ? Math.max(i, e.MIN_COL_WIDTH) : e.MIN_COL_WIDTH;
    }, n.prototype.getMaxColWidth = function() {
      return this.gridOptions.maxColWidth && this.gridOptions.maxColWidth > e.MIN_COL_WIDTH ? this.gridOptions.maxColWidth : null;
    }, n.prototype.getColWidth = function() {
      return typeof this.gridOptions.colWidth != "number" || this.gridOptions.colWidth < e.MIN_COL_WIDTH ? 200 : this.gridOptions.colWidth;
    }, n.prototype.getRowBuffer = function() {
      var t = this.gridOptions.rowBuffer;
      return typeof t == "number" ? t < 0 && (mi(function() {
        return console.warn("AG Grid: rowBuffer should not be negative");
      }, "warn rowBuffer negative"), this.gridOptions.rowBuffer = t = 0) : t = q.ROW_BUFFER_SIZE, t;
    }, n.prototype.getRowBufferInPixels = function() {
      var t = this.getRowBuffer(), i = this.getRowHeightAsNumber();
      return t * i;
    }, n.prototype.getScrollbarWidth = function() {
      if (this.scrollbarWidth == null) {
        var t = typeof this.gridOptions.scrollbarWidth == "number" && this.gridOptions.scrollbarWidth >= 0, i = t ? this.gridOptions.scrollbarWidth : lB();
        i != null && (this.scrollbarWidth = i, this.eventService.dispatchEvent({
          type: I.EVENT_SCROLLBAR_WIDTH_CHANGED
        }));
      }
      return this.scrollbarWidth;
    }, n.prototype.checkForDeprecated = function() {
      var t = this.gridOptions;
      t.deprecatedEmbedFullWidthRows && console.warn("AG Grid: since v21.2, deprecatedEmbedFullWidthRows has been replaced with embedFullWidthRows."), t.rowDeselection && console.warn("AG Grid: since v24.x, rowDeselection is deprecated and the behaviour is true by default. Please use `suppressRowDeselection` to prevent rows from being deselected."), t.enableMultiRowDragging && (t.rowDragMultiRow = !0, delete t.enableMultiRowDragging, console.warn("AG Grid: since v26.1, `enableMultiRowDragging` is deprecated. Please use `rowDragMultiRow`."));
      var i = function(s, a, l) {
        t[s] != null && (console.warn("ag-grid: since version " + l + ", '" + s + "' is deprecated / renamed, please use the new property name '" + a + "' instead."), t[a] == null && (t[a] = t[s]));
      };
      if (i("batchUpdateWaitMillis", "asyncTransactionWaitMillis", "23.1.x"), i("deltaRowDataMode", "immutableData", "23.1.x"), (t.immutableColumns || t.deltaColumnMode) && console.warn("AG Grid: since v24.0, immutableColumns and deltaColumnMode properties are gone. The grid now works like this as default. To keep column order maintained, set grid property applyColumnDefOrder=true"), i("suppressSetColumnStateEvents", "suppressColumnStateEvents", "24.0.x"), t.groupRowInnerRenderer || t.groupRowInnerRendererParams || t.groupRowInnerRendererFramework) {
        console.warn("AG Grid: since v24.0, grid properties groupRowInnerRenderer, groupRowInnerRendererFramework and groupRowInnerRendererParams are no longer used."), console.warn("  Instead use the grid properties groupRowRendererParams.innerRenderer, groupRowRendererParams.innerRendererFramework and groupRowRendererParams.innerRendererParams."), console.warn("  For example instead of this:"), console.warn('    groupRowInnerRenderer: "myRenderer"'), console.warn("    groupRowInnerRendererParams: {x: a}"), console.warn("  Replace with this:"), console.warn("    groupRowRendererParams: {"), console.warn('      innerRenderer: "myRenderer",'), console.warn("      innerRendererParams: {x: a}"), console.warn("    }"), console.warn("  We have copied the properties over for you. However to stop this error message, please change your application code."), t.groupRowRendererParams || (t.groupRowRendererParams = {});
        var r = t.groupRowRendererParams;
        t.groupRowInnerRenderer && (r.innerRenderer = t.groupRowInnerRenderer), t.groupRowInnerRendererParams && (r.innerRendererParams = t.groupRowInnerRendererParams), t.groupRowInnerRendererFramework && (r.innerRendererFramework = t.groupRowInnerRendererFramework);
      }
      if (t.rememberGroupStateWhenNewData && console.warn("AG Grid: since v24.0, grid property rememberGroupStateWhenNewData is deprecated. This feature was provided before Transaction Updates worked (which keep group state). Now that transaction updates are possible and they keep group state, this feature is no longer needed."), t.detailCellRendererParams && t.detailCellRendererParams.autoHeight && (console.warn("AG Grid: since v24.1, grid property detailCellRendererParams.autoHeight is replaced with grid property detailRowAutoHeight. This allows this feature to work when you provide a custom DetailCellRenderer"), t.detailRowAutoHeight = !0), t.suppressKeyboardEvent && console.warn(`AG Grid: since v24.1 suppressKeyboardEvent in the gridOptions has been deprecated and will be removed in
                 future versions of AG Grid. If you need this to be set for every column use the defaultColDef property.`), t.suppressEnterpriseResetOnNewColumns && console.warn("AG Grid: since v25, grid property suppressEnterpriseResetOnNewColumns is deprecated. This was a temporary property to allow changing columns in Server Side Row Model without triggering a reload. Now that it is possible to dynamically change columns in the grid, this is no longer needed."), t.suppressColumnStateEvents && console.warn('AG Grid: since v25, grid property suppressColumnStateEvents no longer works due to a refactor that we did. It should be possible to achieve similar using event.source, which would be "api" if the event was due to setting column state via the API'), t.defaultExportParams && console.warn("AG Grid: since v25.2, the grid property `defaultExportParams` has been replaced by `defaultCsvExportParams` and `defaultExcelExportParams`."), t.stopEditingWhenGridLosesFocus && (console.warn("AG Grid: since v25.2.2, the grid property `stopEditingWhenGridLosesFocus` has been replaced by `stopEditingWhenCellsLoseFocus`."), t.stopEditingWhenCellsLoseFocus = !0), t.applyColumnDefOrder && console.warn("AG Grid: since v26.0, the grid property `applyColumnDefOrder` is no longer needed, as this is the default behaviour. To turn this behaviour off, set maintainColumnOrder=true"), t.groupMultiAutoColumn && (console.warn("AG Grid: since v26.0, the grid property `groupMultiAutoColumn` has been replaced by `groupDisplayType = 'multipleColumns'`"), t.groupDisplayType = "multipleColumns"), t.groupUseEntireRow && (console.warn("AG Grid: since v26.0, the grid property `groupUseEntireRow` has been replaced by `groupDisplayType = 'groupRows'`"), t.groupDisplayType = "groupRows"), t.groupSuppressAutoColumn) {
        var o = t.treeData ? "treeDataDisplayType" : "groupDisplayType";
        console.warn("AG Grid: since v26.0, the grid property `groupSuppressAutoColumn` has been replaced by `" + o + " = 'custom'`"), t.groupDisplayType = "custom";
      }
      t.defaultGroupSortComparator && (console.warn("AG Grid: since v26.0, the grid property `defaultGroupSortComparator` has been replaced by `defaultGroupOrderComparator`"), t.defaultGroupOrderComparator = t.defaultGroupSortComparator), t.colWidth && console.warn("AG Grid: since v26.1, the grid property `colWidth` is deprecated and should be set via `defaultColDef.width`."), t.minColWidth && console.warn("AG Grid: since v26.1, the grid property `minColWidth` is deprecated and should be set via `defaultColDef.minWidth`."), t.maxColWidth && console.warn("AG Grid: since v26.1, the grid property `maxColWidth` is deprecated and should be set via `defaultColDef.maxWidth`."), t.reactUi && console.warn("AG Grid: since v27.0, React UI is on by default, so no need for reactUi=true. To turn it off, set suppressReactUi=true."), t.suppressReactUi && console.warn("AG Grid: The legacy React rendering engine is deprecated and will be removed in the next major version of the grid."), t.suppressCellSelection && (console.warn("AG Grid: since v27.0, `suppressCellSelection` has been replaced by `suppressCellFocus`."), t.suppressCellFocus = t.suppressCellSelection), t.getRowNodeId && console.warn("AG Grid: since v27.1, `getRowNodeId` is deprecate and has been replaced by `getRowId`. The difference is if getRowId() is implemented, immutable data is on by default."), t.immutableData && console.warn("AG Grid: since v27.1, `immutableData` is deprecated. To turn on, implement `getRowId` has been replaced by `getRowId`. The difference is if getRowId() is implemented, immutable data is on by default."), t.clipboardDeliminator && (console.warn("AG Grid: since v27.1, `clipboardDeliminator` has been replaced by `clipboardDelimiter`."), t.clipboardDelimiter = t.clipboardDeliminator);
    }, n.prototype.checkForViolations = function() {
      this.isTreeData() && this.treeDataViolations();
    }, n.prototype.treeDataViolations = function() {
      this.isRowModelDefault() && Je(this.getDataPathFunc()) && console.warn("AG Grid: property usingTreeData=true with rowModel=clientSide, but you did not provide getDataPath function, please provide getDataPath function if using tree data."), this.isRowModelServerSide() && (Je(this.getIsServerSideGroupFunc()) && console.warn("AG Grid: property usingTreeData=true with rowModel=serverSide, but you did not provide isServerSideGroup function, please provide isServerSideGroup function if using tree data."), Je(this.getServerSideGroupKeyFunc()) && console.warn("AG Grid: property usingTreeData=true with rowModel=serverSide, but you did not provide getServerSideGroupKey function, please provide getServerSideGroupKey function if using tree data."));
    }, n.prototype.getLocaleTextFunc = function() {
      if (this.gridOptions.localeTextFunc)
        return this.gridOptions.localeTextFunc;
      var t = this.gridOptions.localeText;
      return function(i, r) {
        var o = t && t[i];
        return o ?? r;
      };
    }, n.prototype.globalEventHandler = function(t, i) {
      if (!this.destroyed) {
        var r = zc.getCallbackForEvent(t);
        typeof this.gridOptions[r] == "function" && this.gridOptions[r](i);
      }
    }, n.prototype.setRowHeightVariable = function(t) {
      var i = this.eGridDiv.style.getPropertyValue("--ag-row-height").trim(), r = t + "px";
      i != r && this.eGridDiv.style.setProperty("--ag-row-height", r);
    }, n.prototype.getRowHeightAsNumber = function() {
      if (!this.gridOptions.rowHeight || Je(this.gridOptions.rowHeight))
        return this.getDefaultRowHeight();
      var t = this.gridOptions.rowHeight;
      return t && this.isNumeric(t) ? (this.setRowHeightVariable(t), t) : (console.warn("AG Grid row height must be a number if not using standard row model"), this.getDefaultRowHeight());
    }, n.prototype.isGetRowHeightFunction = function() {
      return typeof this.gridOptions.getRowHeight == "function";
    }, n.prototype.getRowHeightForNode = function(t, i, r) {
      if (i === void 0 && (i = !1), r == null && (r = this.getDefaultRowHeight()), this.isGetRowHeightFunction()) {
        if (i)
          return { height: r, estimated: !0 };
        var o = {
          node: t,
          data: t.data,
          api: this.gridOptions.api,
          context: this.gridOptions.context
        }, s = this.gridOptions.getRowHeight(o);
        if (this.isNumeric(s))
          return s === 0 && mi(function() {
            return console.warn("AG Grid: The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead.");
          }, "invalidRowHeight"), { height: Math.max(1, s), estimated: !1 };
      }
      if (t.detail && this.isMasterDetail())
        return this.isDetailRowAutoHeight() ? { height: 1, estimated: !1 } : this.isNumeric(this.gridOptions.detailRowHeight) ? { height: this.gridOptions.detailRowHeight, estimated: !1 } : { height: rq, estimated: !1 };
      var a = this.gridOptions.rowHeight && this.isNumeric(this.gridOptions.rowHeight) ? this.gridOptions.rowHeight : r;
      return { height: a, estimated: !1 };
    }, n.prototype.isDynamicRowHeight = function() {
      return typeof this.gridOptions.getRowHeight == "function";
    }, n.prototype.getListItemHeight = function() {
      return this.getFromTheme(20, "listItemHeight");
    }, n.prototype.chartMenuPanelWidth = function() {
      return this.environment.chartMenuPanelWidth();
    }, n.prototype.isNumeric = function(t) {
      return !isNaN(t) && typeof t == "number" && isFinite(t);
    }, n.prototype.getFromTheme = function(t, i) {
      var r = this.environment.getTheme().theme;
      return r && r.indexOf("ag-theme") === 0 ? this.environment.getSassVariable(r, i) : t;
    }, n.prototype.getDefaultRowHeight = function() {
      return this.getFromTheme(nq, "rowHeight");
    }, n.prototype.matchesGroupDisplayType = function(t, i) {
      var r = ["groupRows", "multipleColumns", "custom", "singleColumn"];
      return r.indexOf(i) < 0 ? (console.warn("AG Grid: '" + i + "' is not a valid groupDisplayType value - possible values are: '" + r.join("', '") + "'"), !1) : i === t;
    }, n.prototype.matchesTreeDataDisplayType = function(t, i) {
      var r = ["auto", "custom"];
      return r.indexOf(i) < 0 ? (console.warn("AG Grid: '" + i + "' is not a valid treeDataDisplayType value - possible values are: '" + r.join("', '") + "'"), !1) : i === t;
    };
    var e;
    return n.MIN_COL_WIDTH = 10, n.PROP_HEADER_HEIGHT = "headerHeight", n.PROP_GROUP_REMOVE_SINGLE_CHILDREN = "groupRemoveSingleChildren", n.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN = "groupRemoveLowestSingleChildren", n.PROP_PIVOT_HEADER_HEIGHT = "pivotHeaderHeight", n.PROP_SUPPRESS_CLIPBOARD_PASTE = "suppressClipboardPaste", n.PROP_GROUP_HEADER_HEIGHT = "groupHeaderHeight", n.PROP_PIVOT_GROUP_HEADER_HEIGHT = "pivotGroupHeaderHeight", n.PROP_NAVIGATE_TO_NEXT_CELL = "navigateToNextCell", n.PROP_TAB_TO_NEXT_CELL = "tabToNextCell", n.PROP_NAVIGATE_TO_NEXT_HEADER = "navigateToNextHeader", n.PROP_TAB_TO_NEXT_HEADER = "tabToNextHeader", n.PROP_IS_EXTERNAL_FILTER_PRESENT = "isExternalFilterPresent", n.PROP_DOES_EXTERNAL_FILTER_PASS = "doesExternalFilterPass", n.PROP_FLOATING_FILTERS_HEIGHT = "floatingFiltersHeight", n.PROP_SUPPRESS_ROW_CLICK_SELECTION = "suppressRowClickSelection", n.PROP_SUPPRESS_ROW_DRAG = "suppressRowDrag", n.PROP_SUPPRESS_MOVE_WHEN_ROW_DRAG = "suppressMoveWhenRowDragging", n.PROP_GET_ROW_CLASS = "getRowClass", n.PROP_GET_ROW_STYLE = "getRowStyle", n.PROP_GET_ROW_HEIGHT = "getRowHeight", n.PROP_POPUP_PARENT = "popupParent", n.PROP_DOM_LAYOUT = "domLayout", n.PROP_FILL_HANDLE_DIRECTION = "fillHandleDirection", n.PROP_GROUP_ROW_AGG_NODES = "groupRowAggNodes", n.PROP_GET_BUSINESS_KEY_FOR_NODE = "getBusinessKeyForNode", n.PROP_GET_CHILD_COUNT = "getChildCount", n.PROP_PROCESS_ROW_POST_CREATE = "processRowPostCreate", n.PROP_GET_ROW_NODE_ID = "getRowNodeId", n.PROP_IS_FULL_WIDTH_CELL = "isFullWidthCell", n.PROP_IS_ROW_SELECTABLE = "isRowSelectable", n.PROP_IS_ROW_MASTER = "isRowMaster", n.PROP_POST_SORT = "postSort", n.PROP_GET_DOCUMENT = "getDocument", n.PROP_POST_PROCESS_POPUP = "postProcessPopup", n.PROP_DEFAULT_GROUP_ORDER_COMPARATOR = "defaultGroupOrderComparator", n.PROP_PAGINATION_NUMBER_FORMATTER = "paginationNumberFormatter", n.PROP_GET_CONTEXT_MENU_ITEMS = "getContextMenuItems", n.PROP_GET_MAIN_MENU_ITEMS = "getMainMenuItems", n.PROP_PROCESS_CELL_FOR_CLIPBOARD = "processCellForClipboard", n.PROP_PROCESS_CELL_FROM_CLIPBOARD = "processCellFromClipboard", n.PROP_SEND_TO_CLIPBOARD = "sendToClipboard", n.PROP_PROCESS_TO_SECONDARY_COLDEF = "processSecondaryColDef", n.PROP_PROCESS_SECONDARY_COL_GROUP_DEF = "processSecondaryColGroupDef", n.PROP_GET_CHART_TOOLBAR_ITEMS = "getChartToolbarItems", n.PROP_GET_SERVER_SIDE_STORE_PARAMS = "getServerSideStoreParams", n.PROP_IS_SERVER_SIDE_GROUPS_OPEN_BY_DEFAULT = "isServerSideGroupOpenByDefault", n.PROP_IS_APPLY_SERVER_SIDE_TRANSACTION = "isApplyServerSideTransaction", n.PROP_IS_SERVER_SIDE_GROUP = "isServerSideGroup", n.PROP_GET_SERVER_SIDE_GROUP_KEY = "getServerSideGroupKey", gc([
      R("gridOptions")
    ], n.prototype, "gridOptions", void 0), gc([
      R("eventService")
    ], n.prototype, "eventService", void 0), gc([
      R("environment")
    ], n.prototype, "environment", void 0), gc([
      R("eGridDiv")
    ], n.prototype, "eGridDiv", void 0), gc([
      fM(0, wo("gridApi")),
      fM(1, wo("columnApi"))
    ], n.prototype, "agWire", null), gc([
      Lo
    ], n.prototype, "destroy", null), gc([
      Ee
    ], n.prototype, "init", null), n = e = gc([
      Ke("gridOptionsWrapper")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var vx = (
  /** @class */
  function() {
    function n(e, t) {
      this.active = !0, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = {
        rowNode: t,
        children: null
      }, this.mapToItems[t.id] = this.pathRoot;
    }
    return n.prototype.setInactive = function() {
      this.active = !1;
    }, n.prototype.isActive = function() {
      return this.active;
    }, n.prototype.depthFirstSearchChangedPath = function(e, t) {
      if (e.children)
        for (var i = 0; i < e.children.length; i++)
          this.depthFirstSearchChangedPath(e.children[i], t);
      t(e.rowNode);
    }, n.prototype.depthFirstSearchEverything = function(e, t, i) {
      if (e.childrenAfterGroup)
        for (var r = 0; r < e.childrenAfterGroup.length; r++) {
          var o = e.childrenAfterGroup[r];
          o.childrenAfterGroup ? this.depthFirstSearchEverything(e.childrenAfterGroup[r], t, i) : i && t(o);
        }
      t(e);
    }, n.prototype.forEachChangedNodeDepthFirst = function(e, t) {
      t === void 0 && (t = !1), this.active ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t);
    }, n.prototype.executeFromRootNode = function(e) {
      e(this.pathRoot.rowNode);
    }, n.prototype.createPathItems = function(e) {
      for (var t = e, i = 0; !this.mapToItems[t.id]; ) {
        var r = {
          rowNode: t,
          children: null
        };
        this.mapToItems[t.id] = r, i++, t = t.parent;
      }
      return i;
    }, n.prototype.populateColumnsMap = function(e, t) {
      var i = this;
      if (!(!this.keepingColumns || !t))
        for (var r = e; r; )
          this.nodeIdsToColumns[r.id] || (this.nodeIdsToColumns[r.id] = {}), t.forEach(function(o) {
            return i.nodeIdsToColumns[r.id][o.getId()] = !0;
          }), r = r.parent;
    }, n.prototype.linkPathItems = function(e, t) {
      for (var i = e, r = 0; r < t; r++) {
        var o = this.mapToItems[i.id], s = this.mapToItems[i.parent.id];
        s.children || (s.children = []), s.children.push(o), i = i.parent;
      }
    }, n.prototype.addParentNode = function(e, t) {
      if (!(!e || e.isRowPinned())) {
        var i = this.createPathItems(e);
        this.linkPathItems(e, i), this.populateColumnsMap(e, t);
      }
    }, n.prototype.canSkip = function(e) {
      return this.active && !this.mapToItems[e.id];
    }, n.prototype.getValueColumnsForNode = function(e, t) {
      if (!this.keepingColumns)
        return t;
      var i = this.nodeIdsToColumns[e.id], r = t.filter(function(o) {
        return i[o.getId()];
      });
      return r;
    }, n.prototype.getNotValueColumnsForNode = function(e, t) {
      if (!this.keepingColumns)
        return null;
      var i = this.nodeIdsToColumns[e.id], r = t.filter(function(o) {
        return !i[o.getId()];
      });
      return r;
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var uq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), df = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, cq = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, sH = (
  /** @class */
  function(n) {
    uq(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setBeans = function(t) {
      this.logger = t.create("selectionService"), this.reset(), this.gridOptionsWrapper.isRowModelDefault() && this.addManagedListener(this.eventService, I.EVENT_ROW_DATA_CHANGED, this.reset.bind(this));
    }, e.prototype.init = function() {
      this.groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren(), this.addManagedListener(this.eventService, I.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));
    }, e.prototype.setLastSelectedNode = function(t) {
      this.lastSelectedNode = t;
    }, e.prototype.getLastSelectedNode = function() {
      return this.lastSelectedNode;
    }, e.prototype.getSelectedNodes = function() {
      var t = [];
      return pi(this.selectedNodes, function(i, r) {
        r && t.push(r);
      }), t;
    }, e.prototype.getSelectedRows = function() {
      var t = [];
      return pi(this.selectedNodes, function(i, r) {
        r && r.data && t.push(r.data);
      }), t;
    }, e.prototype.removeGroupsFromSelection = function() {
      var t = this;
      pi(this.selectedNodes, function(i, r) {
        r && r.group && (t.selectedNodes[r.id] = void 0);
      });
    }, e.prototype.updateGroupsFromChildrenSelections = function(t) {
      if (this.gridOptionsWrapper.isGroupSelectsChildren() && this.rowModel.getType() === q.ROW_MODEL_TYPE_CLIENT_SIDE) {
        var i = this.rowModel, r = i.getRootNode();
        t || (t = new vx(!0, r), t.setInactive()), t.forEachChangedNodeDepthFirst(function(o) {
          o !== r && o.calculateSelectedFromChildren();
        });
      }
    }, e.prototype.getNodeForIdIfSelected = function(t) {
      return this.selectedNodes[t];
    }, e.prototype.clearOtherNodes = function(t) {
      var i = this, r = {}, o = 0;
      return pi(this.selectedNodes, function(s, a) {
        if (a && a.id !== t.id) {
          var l = i.selectedNodes[a.id];
          o += l.setSelectedParams({
            newValue: !1,
            clearSelection: !1,
            suppressFinishActions: !0
          }), i.groupSelectsChildren && a.parent && (r[a.parent.id] = a.parent);
        }
      }), pi(r, function(s, a) {
        a.calculateSelectedFromChildren();
      }), o;
    }, e.prototype.onRowSelected = function(t) {
      var i = t.node;
      this.groupSelectsChildren && i.group || (i.isSelected() ? this.selectedNodes[i.id] = i : this.selectedNodes[i.id] = void 0);
    }, e.prototype.syncInRowNode = function(t, i) {
      this.syncInOldRowNode(t, i), this.syncInNewRowNode(t);
    }, e.prototype.syncInOldRowNode = function(t, i) {
      var r = de(i) && t.id !== i.id;
      if (r && i) {
        var o = i.id, s = this.selectedNodes[o] == t;
        s && (this.selectedNodes[i.id] = i);
      }
    }, e.prototype.syncInNewRowNode = function(t) {
      de(this.selectedNodes[t.id]) ? (t.setSelectedInitialValue(!0), this.selectedNodes[t.id] = t) : t.setSelectedInitialValue(!1);
    }, e.prototype.reset = function() {
      this.logger.log("reset"), this.selectedNodes = {}, this.lastSelectedNode = null;
    }, e.prototype.getBestCostNodeSelection = function() {
      if (this.rowModel.getType() !== q.ROW_MODEL_TYPE_CLIENT_SIDE) {
        console.warn("AG Grid: `getBestCostNodeSelection` is only available when using normal row model");
        return;
      }
      var t = this.rowModel, i = t.getTopLevelNodes();
      if (i === null) {
        console.warn("AG Grid: `selectAll` not available doing `rowModel=virtual`");
        return;
      }
      var r = [];
      function o(s) {
        for (var a = 0, l = s.length; a < l; a++) {
          var u = s[a];
          if (u.isSelected())
            r.push(u);
          else {
            var c = u;
            c.group && c.children && o(c.children);
          }
        }
      }
      return o(i), r;
    }, e.prototype.setRowModel = function(t) {
      this.rowModel = t;
    }, e.prototype.isEmpty = function() {
      var t = 0;
      return pi(this.selectedNodes, function(i, r) {
        r && t++;
      }), t === 0;
    }, e.prototype.deselectAllRowNodes = function(t) {
      t === void 0 && (t = !1);
      var i = function(a) {
        return a.selectThisNode(!1);
      }, r = this.rowModel.getType() === q.ROW_MODEL_TYPE_CLIENT_SIDE;
      if (t) {
        if (!r) {
          console.error("AG Grid: selecting just filtered only works with In Memory Row Model");
          return;
        }
        var o = this.rowModel;
        o.forEachNodeAfterFilter(i);
      } else
        pi(this.selectedNodes, function(a, l) {
          l && i(l);
        }), this.reset();
      r && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections();
      var s = {
        type: I.EVENT_SELECTION_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(s);
    }, e.prototype.selectAllRowNodes = function(t) {
      if (t === void 0 && (t = !1), this.rowModel.getType() !== q.ROW_MODEL_TYPE_CLIENT_SIDE)
        throw new Error("selectAll only available with normal row model, ie not " + this.rowModel.getType());
      var i = this.rowModel, r = function(s) {
        return s.selectThisNode(!0);
      };
      t ? i.forEachNodeAfterFilter(r) : i.forEachNode(r), this.rowModel.getType() === q.ROW_MODEL_TYPE_CLIENT_SIDE && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections();
      var o = {
        type: I.EVENT_SELECTION_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(o);
    }, e.prototype.selectNode = function(t, i) {
      t && t.setSelectedParams({ newValue: !0, clearSelection: !i });
    }, e.prototype.deselectIndex = function(t) {
      var i = this.rowModel.getRow(t);
      this.deselectNode(i);
    }, e.prototype.deselectNode = function(t) {
      t && t.setSelectedParams({ newValue: !1, clearSelection: !1 });
    }, e.prototype.selectIndex = function(t, i) {
      var r = this.rowModel.getRow(t);
      this.selectNode(r, i);
    }, df([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), df([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), df([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), df([
      cq(0, wo("loggerFactory"))
    ], e.prototype, "setBeans", null), df([
      Ee
    ], e.prototype, "init", null), e = df([
      Ke("selectionService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var uL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, aH = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.sizeColumnsToFit = function(e) {
      typeof e > "u" && console.error("AG Grid: missing parameter to columnApi.sizeColumnsToFit(gridWidth)"), this.columnModel.sizeColumnsToFit(e, "api");
    }, n.prototype.setColumnGroupOpened = function(e, t) {
      this.columnModel.setColumnGroupOpened(e, t, "api");
    }, n.prototype.getColumnGroup = function(e, t) {
      return this.columnModel.getColumnGroup(e, t);
    }, n.prototype.getProvidedColumnGroup = function(e) {
      return this.columnModel.getProvidedColumnGroup(e);
    }, n.prototype.getDisplayNameForColumn = function(e, t) {
      return this.columnModel.getDisplayNameForColumn(e, t) || "";
    }, n.prototype.getDisplayNameForColumnGroup = function(e, t) {
      return this.columnModel.getDisplayNameForColumnGroup(e, t) || "";
    }, n.prototype.getColumn = function(e) {
      return this.columnModel.getPrimaryColumn(e);
    }, n.prototype.applyColumnState = function(e) {
      return this.columnModel.applyColumnState(e, "api");
    }, n.prototype.getColumnState = function() {
      return this.columnModel.getColumnState();
    }, n.prototype.resetColumnState = function() {
      this.columnModel.resetColumnState("api");
    }, n.prototype.getColumnGroupState = function() {
      return this.columnModel.getColumnGroupState();
    }, n.prototype.setColumnGroupState = function(e) {
      this.columnModel.setColumnGroupState(e, "api");
    }, n.prototype.resetColumnGroupState = function() {
      this.columnModel.resetColumnGroupState("api");
    }, n.prototype.isPinning = function() {
      return this.columnModel.isPinningLeft() || this.columnModel.isPinningRight();
    }, n.prototype.isPinningLeft = function() {
      return this.columnModel.isPinningLeft();
    }, n.prototype.isPinningRight = function() {
      return this.columnModel.isPinningRight();
    }, n.prototype.getDisplayedColAfter = function(e) {
      return this.columnModel.getDisplayedColAfter(e);
    }, n.prototype.getDisplayedColBefore = function(e) {
      return this.columnModel.getDisplayedColBefore(e);
    }, n.prototype.setColumnVisible = function(e, t) {
      this.columnModel.setColumnVisible(e, t, "api");
    }, n.prototype.setColumnsVisible = function(e, t) {
      this.columnModel.setColumnsVisible(e, t, "api");
    }, n.prototype.setColumnPinned = function(e, t) {
      this.columnModel.setColumnPinned(e, t, "api");
    }, n.prototype.setColumnsPinned = function(e, t) {
      this.columnModel.setColumnsPinned(e, t, "api");
    }, n.prototype.getAllColumns = function() {
      return this.columnModel.getAllPrimaryColumns();
    }, n.prototype.getAllGridColumns = function() {
      return this.columnModel.getAllGridColumns();
    }, n.prototype.getDisplayedLeftColumns = function() {
      return this.columnModel.getDisplayedLeftColumns();
    }, n.prototype.getDisplayedCenterColumns = function() {
      return this.columnModel.getDisplayedCenterColumns();
    }, n.prototype.getDisplayedRightColumns = function() {
      return this.columnModel.getDisplayedRightColumns();
    }, n.prototype.getAllDisplayedColumns = function() {
      return this.columnModel.getAllDisplayedColumns();
    }, n.prototype.getAllDisplayedVirtualColumns = function() {
      return this.columnModel.getViewportColumns();
    }, n.prototype.moveColumn = function(e, t) {
      typeof e == "number" ? (console.warn("AG Grid: you are using moveColumn(fromIndex, toIndex) - moveColumn takes a column key and a destination index, not two indexes, to move with indexes use moveColumnByIndex(from,to) instead"), this.columnModel.moveColumnByIndex(e, t, "api")) : this.columnModel.moveColumn(e, t, "api");
    }, n.prototype.moveColumnByIndex = function(e, t) {
      this.columnModel.moveColumnByIndex(e, t, "api");
    }, n.prototype.moveColumns = function(e, t) {
      this.columnModel.moveColumns(e, t, "api");
    }, n.prototype.moveRowGroupColumn = function(e, t) {
      this.columnModel.moveRowGroupColumn(e, t);
    }, n.prototype.setColumnAggFunc = function(e, t) {
      this.columnModel.setColumnAggFunc(e, t);
    }, n.prototype.setColumnWidth = function(e, t, i, r) {
      i === void 0 && (i = !0), this.columnModel.setColumnWidths([{ key: e, newWidth: t }], !1, i, r);
    }, n.prototype.setColumnWidths = function(e, t, i) {
      t === void 0 && (t = !0), this.columnModel.setColumnWidths(e, !1, t, i);
    }, n.prototype.setPivotMode = function(e) {
      this.columnModel.setPivotMode(e);
    }, n.prototype.isPivotMode = function() {
      return this.columnModel.isPivotMode();
    }, n.prototype.getSecondaryPivotColumn = function(e, t) {
      return this.columnModel.getSecondaryPivotColumn(e, t);
    }, n.prototype.setValueColumns = function(e) {
      this.columnModel.setValueColumns(e, "api");
    }, n.prototype.getValueColumns = function() {
      return this.columnModel.getValueColumns();
    }, n.prototype.removeValueColumn = function(e) {
      this.columnModel.removeValueColumn(e, "api");
    }, n.prototype.removeValueColumns = function(e) {
      this.columnModel.removeValueColumns(e, "api");
    }, n.prototype.addValueColumn = function(e) {
      this.columnModel.addValueColumn(e, "api");
    }, n.prototype.addValueColumns = function(e) {
      this.columnModel.addValueColumns(e, "api");
    }, n.prototype.setRowGroupColumns = function(e) {
      this.columnModel.setRowGroupColumns(e, "api");
    }, n.prototype.removeRowGroupColumn = function(e) {
      this.columnModel.removeRowGroupColumn(e, "api");
    }, n.prototype.removeRowGroupColumns = function(e) {
      this.columnModel.removeRowGroupColumns(e, "api");
    }, n.prototype.addRowGroupColumn = function(e) {
      this.columnModel.addRowGroupColumn(e, "api");
    }, n.prototype.addRowGroupColumns = function(e) {
      this.columnModel.addRowGroupColumns(e, "api");
    }, n.prototype.getRowGroupColumns = function() {
      return this.columnModel.getRowGroupColumns();
    }, n.prototype.setPivotColumns = function(e) {
      this.columnModel.setPivotColumns(e, "api");
    }, n.prototype.removePivotColumn = function(e) {
      this.columnModel.removePivotColumn(e, "api");
    }, n.prototype.removePivotColumns = function(e) {
      this.columnModel.removePivotColumns(e, "api");
    }, n.prototype.addPivotColumn = function(e) {
      this.columnModel.addPivotColumn(e, "api");
    }, n.prototype.addPivotColumns = function(e) {
      this.columnModel.addPivotColumns(e, "api");
    }, n.prototype.getPivotColumns = function() {
      return this.columnModel.getPivotColumns();
    }, n.prototype.getLeftDisplayedColumnGroups = function() {
      return this.columnModel.getDisplayedTreeLeft();
    }, n.prototype.getCenterDisplayedColumnGroups = function() {
      return this.columnModel.getDisplayedTreeCentre();
    }, n.prototype.getRightDisplayedColumnGroups = function() {
      return this.columnModel.getDisplayedTreeRight();
    }, n.prototype.getAllDisplayedColumnGroups = function() {
      return this.columnModel.getAllDisplayedTrees();
    }, n.prototype.autoSizeColumn = function(e, t) {
      return this.columnModel.autoSizeColumn(e, t, "api");
    }, n.prototype.autoSizeColumns = function(e, t) {
      this.columnModel.autoSizeColumns({ columns: e, skipHeader: t });
    }, n.prototype.autoSizeAllColumns = function(e) {
      this.columnModel.autoSizeAllColumns(e, "api");
    }, n.prototype.setSecondaryColumns = function(e) {
      this.columnModel.setSecondaryColumns(e, "api");
    }, n.prototype.getSecondaryColumns = function() {
      return this.columnModel.getSecondaryColumns();
    }, n.prototype.getPrimaryColumns = function() {
      return this.columnModel.getAllPrimaryColumns();
    }, n.prototype.cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid = function() {
      setTimeout(Sd.removeAllReferences.bind(window, this, "Column API"), 100);
    }, n.prototype.columnGroupOpened = function(e, t) {
      console.error("AG Grid: columnGroupOpened no longer exists, use setColumnGroupOpened"), this.setColumnGroupOpened(e, t);
    }, n.prototype.hideColumns = function(e, t) {
      console.error("AG Grid: hideColumns is deprecated, use setColumnsVisible"), this.columnModel.setColumnsVisible(e, !t, "api");
    }, n.prototype.hideColumn = function(e, t) {
      console.error("AG Grid: hideColumn is deprecated, use setColumnVisible"), this.columnModel.setColumnVisible(e, !t, "api");
    }, n.prototype.setState = function(e) {
      return console.error("AG Grid: setState is deprecated, use setColumnState"), this.setColumnState(e);
    }, n.prototype.getState = function() {
      return console.error("AG Grid: getState is deprecated, use getColumnState"), this.getColumnState();
    }, n.prototype.resetState = function() {
      console.error("AG Grid: resetState is deprecated, use resetColumnState"), this.resetColumnState();
    }, n.prototype.getAggregationColumns = function() {
      return console.error("AG Grid: getAggregationColumns is deprecated, use getValueColumns"), this.columnModel.getValueColumns();
    }, n.prototype.removeAggregationColumn = function(e) {
      console.error("AG Grid: removeAggregationColumn is deprecated, use removeValueColumn"), this.columnModel.removeValueColumn(e, "api");
    }, n.prototype.removeAggregationColumns = function(e) {
      console.error("AG Grid: removeAggregationColumns is deprecated, use removeValueColumns"), this.columnModel.removeValueColumns(e, "api");
    }, n.prototype.addAggregationColumn = function(e) {
      console.error("AG Grid: addAggregationColumn is deprecated, use addValueColumn"), this.columnModel.addValueColumn(e, "api");
    }, n.prototype.addAggregationColumns = function(e) {
      console.error("AG Grid: addAggregationColumns is deprecated, use addValueColumns"), this.columnModel.addValueColumns(e, "api");
    }, n.prototype.setColumnAggFunction = function(e, t) {
      console.error("AG Grid: setColumnAggFunction is deprecated, use setColumnAggFunc"), this.columnModel.setColumnAggFunc(e, t, "api");
    }, n.prototype.getDisplayNameForCol = function(e) {
      return console.error("AG Grid: getDisplayNameForCol is deprecated, use getDisplayNameForColumn"), this.getDisplayNameForColumn(e, null);
    }, n.prototype.setColumnState = function(e) {
      return console.error("AG Grid: setColumnState is deprecated, use applyColumnState"), this.columnModel.applyColumnState({ state: e, applyOrder: !0 }, "api");
    }, n.prototype.getOriginalColumnGroup = function(e) {
      return console.error("AG Grid: getOriginalColumnGroup is deprecated, use getProvidedColumnGroup"), this.columnModel.getProvidedColumnGroup(e);
    }, uL([
      R("columnModel")
    ], n.prototype, "columnModel", void 0), uL([
      Lo
    ], n.prototype, "cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid", null), n = uL([
      Ke("columnApi")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var kv;
(function(n) {
  n[n.FILL = 0] = "FILL", n[n.RANGE = 1] = "RANGE";
})(kv || (kv = {}));
var Qh;
(function(n) {
  n[n.VALUE = 0] = "VALUE", n[n.DIMENSION = 1] = "DIMENSION";
})(Qh || (Qh = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var rm = "ag-cell-range-selected", hq = "ag-cell-range-chart", dq = "ag-cell-range-single-cell", fq = "ag-cell-range-chart-category", pq = "ag-cell-range-handle", gq = "ag-cell-range-top", mq = "ag-cell-range-right", vq = "ag-cell-range-bottom", _q = "ag-cell-range-left", Cq = (
  /** @class */
  function() {
    function n(e, t) {
      this.beans = e, this.cellCtrl = t;
    }
    return n.prototype.setComp = function(e, t) {
      this.cellComp = e, this.eGui = t, this.onRangeSelectionChanged();
    }, n.prototype.onRangeSelectionChanged = function() {
      this.cellComp && (this.rangeCount = this.beans.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()), this.hasChartRange = this.getHasChartRange(), this.cellComp.addOrRemoveCssClass(rm, this.rangeCount !== 0), this.cellComp.addOrRemoveCssClass(rm + "-1", this.rangeCount === 1), this.cellComp.addOrRemoveCssClass(rm + "-2", this.rangeCount === 2), this.cellComp.addOrRemoveCssClass(rm + "-3", this.rangeCount === 3), this.cellComp.addOrRemoveCssClass(rm + "-4", this.rangeCount >= 4), this.cellComp.addOrRemoveCssClass(hq, this.hasChartRange), Fp(this.eGui, this.rangeCount > 0 ? !0 : void 0), this.cellComp.addOrRemoveCssClass(dq, this.isSingleCell()), this.updateRangeBorders(), this.refreshHandle());
    }, n.prototype.updateRangeBorders = function() {
      var e = this.getRangeBorders(), t = this.isSingleCell(), i = !t && e.top, r = !t && e.right, o = !t && e.bottom, s = !t && e.left;
      this.cellComp.addOrRemoveCssClass(gq, i), this.cellComp.addOrRemoveCssClass(mq, r), this.cellComp.addOrRemoveCssClass(vq, o), this.cellComp.addOrRemoveCssClass(_q, s);
    }, n.prototype.isSingleCell = function() {
      var e = this.beans.rangeService;
      return this.rangeCount === 1 && e && !e.isMoreThanOneCell();
    }, n.prototype.getHasChartRange = function() {
      var e = this.beans.rangeService;
      if (!this.rangeCount || !e)
        return !1;
      var t = e.getCellRanges();
      return t.length > 0 && t.every(function(i) {
        return Cs([Qh.DIMENSION, Qh.VALUE], i.type);
      });
    }, n.prototype.updateRangeBordersIfRangeCount = function() {
      this.rangeCount > 0 && (this.updateRangeBorders(), this.refreshHandle());
    }, n.prototype.getRangeBorders = function() {
      var e = this, t = this.beans.gridOptionsWrapper.isEnableRtl(), i = !1, r = !1, o = !1, s = !1, a = this.cellCtrl.getCellPosition().column, l = this.beans, u = l.rangeService, c = l.columnModel, h, d;
      t ? (h = c.getDisplayedColAfter(a), d = c.getDisplayedColBefore(a)) : (h = c.getDisplayedColBefore(a), d = c.getDisplayedColAfter(a));
      var f = u.getCellRanges().filter(function(v) {
        return u.isCellInSpecificRange(e.cellCtrl.getCellPosition(), v);
      });
      h || (s = !0), d || (r = !0);
      for (var p = 0; p < f.length && !(i && r && o && s); p++) {
        var g = f[p], _ = u.getRangeStartRow(g), m = u.getRangeEndRow(g);
        !i && this.beans.rowPositionUtils.sameRow(_, this.cellCtrl.getCellPosition()) && (i = !0), !o && this.beans.rowPositionUtils.sameRow(m, this.cellCtrl.getCellPosition()) && (o = !0), !s && h && g.columns.indexOf(h) < 0 && (s = !0), !r && d && g.columns.indexOf(d) < 0 && (r = !0);
      }
      return { top: i, right: r, bottom: o, left: s };
    }, n.prototype.refreshHandle = function() {
      if (this.beans.rangeService) {
        var e = this.shouldHaveSelectionHandle();
        this.selectionHandle && !e && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), e && this.addSelectionHandle(), this.cellComp.addOrRemoveCssClass(pq, !!this.selectionHandle);
      }
    }, n.prototype.shouldHaveSelectionHandle = function() {
      var e = this.beans, t = e.gridOptionsWrapper, i = e.rangeService, r = i.getCellRanges(), o = r.length;
      if (this.rangeCount < 1 || o < 1)
        return !1;
      var s = Di(r), a = this.cellCtrl.getCellPosition(), l = t.isEnableFillHandle() && !this.cellCtrl.isSuppressFillHandle(), u = t.isEnableRangeHandle(), c = o === 1 && !this.cellCtrl.isEditing() && (l || u);
      if (this.hasChartRange) {
        var h = r[0].type === Qh.DIMENSION, d = h && i.isCellInSpecificRange(a, r[0]);
        this.cellComp.addOrRemoveCssClass(fq, d), c = s.type === Qh.VALUE;
      }
      return c && s.endRow != null && i.isContiguousRange(s) && i.isBottomRightCell(s, a);
    }, n.prototype.addSelectionHandle = function() {
      var e = this.beans, t = e.gridOptionsWrapper, i = e.rangeService, r = Di(i.getCellRanges()).type, o = t.isEnableFillHandle() && Je(r), s = o ? kv.FILL : kv.RANGE;
      this.selectionHandle && this.selectionHandle.getType() !== s && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), this.selectionHandle || (this.selectionHandle = this.beans.selectionHandleFactory.createSelectionHandle(s)), this.selectionHandle.refresh(this.cellCtrl);
    }, n.prototype.destroy = function() {
      this.beans.context.destroyBean(this.selectionHandle);
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var yq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wq = (
  /** @class */
  function(n) {
    yq(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.cellCtrl = t, r.beans = i, r.column = t.getColumn(), r.rowNode = t.getRowNode(), r.setupColSpan(), r.setupRowSpan(), r;
    }
    return e.prototype.setupRowSpan = function() {
      this.rowSpan = this.column.getRowSpan(this.rowNode);
    }, e.prototype.setComp = function(t) {
      this.eGui = t, this.onLeftChanged(), this.onWidthChanged(), this.applyRowSpan();
    }, e.prototype.onDisplayColumnsChanged = function() {
      var t = this.getColSpanningList();
      ud(this.colsSpanning, t) || (this.colsSpanning = t, this.onWidthChanged(), this.onLeftChanged());
    }, e.prototype.setupColSpan = function() {
      this.column.getColDef().colSpan != null && (this.colsSpanning = this.getColSpanningList(), this.addManagedListener(this.beans.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this)), this.addManagedListener(this.beans.eventService, I.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this)));
    }, e.prototype.onWidthChanged = function() {
      if (this.eGui) {
        var t = this.getCellWidth();
        this.eGui.style.width = t + "px";
      }
    }, e.prototype.getCellWidth = function() {
      return this.colsSpanning ? this.colsSpanning.reduce(function(t, i) {
        return t + i.getActualWidth();
      }, 0) : this.column.getActualWidth();
    }, e.prototype.getColSpanningList = function() {
      var t = this.column.getColSpan(this.rowNode), i = [];
      if (t === 1)
        i.push(this.column);
      else
        for (var r = this.column, o = this.column.getPinned(), s = 0; r && s < t && (i.push(r), r = this.beans.columnModel.getDisplayedColAfter(r), !(!r || Je(r) || o !== r.getPinned())); s++)
          ;
      return i;
    }, e.prototype.onLeftChanged = function() {
      if (this.eGui) {
        var t = this.modifyLeftForPrintLayout(this.getCellLeft());
        this.eGui.style.left = t + "px";
      }
    }, e.prototype.getCellLeft = function() {
      var t;
      return this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning ? t = Di(this.colsSpanning) : t = this.column, t.getLeft();
    }, e.prototype.modifyLeftForPrintLayout = function(t) {
      if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === q.PINNED_LEFT)
        return t;
      var i = this.beans.columnModel.getDisplayedColumnsLeftWidth();
      if (this.column.getPinned() === q.PINNED_RIGHT) {
        var r = this.beans.columnModel.getBodyContainerWidth();
        return i + r + (t || 0);
      }
      return i + (t || 0);
    }, e.prototype.applyRowSpan = function() {
      if (this.rowSpan !== 1) {
        var t = this.beans.gridOptionsWrapper.getRowHeightAsNumber(), i = t * this.rowSpan;
        this.eGui.style.height = i + "px", this.eGui.style.zIndex = "1";
      }
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var bq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Sq = (
  /** @class */
  function(n) {
    bq(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.staticClasses = [], r.cellCtrl = t, r.beans = i, r.column = t.getColumn(), r.rowNode = t.getRowNode(), r;
    }
    return e.prototype.setComp = function(t, i) {
      this.cellComp = t, this.scope = i, this.applyUserStyles(), this.applyCellClassRules(), this.applyClassesFromColDef();
    }, e.prototype.applyCellClassRules = function() {
      var t = this, i = this.column.getColDef(), r = {
        value: this.cellCtrl.getValue(),
        data: this.rowNode.data,
        node: this.rowNode,
        colDef: i,
        rowIndex: this.rowNode.rowIndex,
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        $scope: this.scope,
        context: this.beans.gridOptionsWrapper.getContext()
      };
      this.beans.stylingService.processClassRules(i.cellClassRules, r, function(o) {
        return t.cellComp.addOrRemoveCssClass(o, !0);
      }, function(o) {
        return t.cellComp.addOrRemoveCssClass(o, !1);
      });
    }, e.prototype.applyUserStyles = function() {
      var t = this.column.getColDef();
      if (t.cellStyle) {
        var i;
        if (typeof t.cellStyle == "function") {
          var r = {
            column: this.column,
            value: this.cellCtrl.getValue(),
            colDef: t,
            data: this.rowNode.data,
            node: this.rowNode,
            rowIndex: this.rowNode.rowIndex,
            $scope: this.scope,
            api: this.beans.gridOptionsWrapper.getApi(),
            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
            context: this.beans.gridOptionsWrapper.getContext()
          }, o = t.cellStyle;
          i = o(r);
        } else
          i = t.cellStyle;
        this.cellComp.setUserStyles(i);
      }
    }, e.prototype.applyClassesFromColDef = function() {
      var t = this, i = this.column.getColDef(), r = {
        value: this.cellCtrl.getValue(),
        data: this.rowNode.data,
        node: this.rowNode,
        colDef: i,
        rowIndex: this.rowNode.rowIndex,
        $scope: this.scope,
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        context: this.beans.gridOptionsWrapper.getContext()
      };
      this.staticClasses.length && this.staticClasses.forEach(function(o) {
        return t.cellComp.addOrRemoveCssClass(o, !1);
      }), this.staticClasses = this.beans.stylingService.getStaticCellClasses(i, r), this.staticClasses.length && this.staticClasses.forEach(function(o) {
        return t.cellComp.addOrRemoveCssClass(o, !0);
      });
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Eq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _x = (
  /** @class */
  function(n) {
    Eq(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.ctrl = t, r.beans = i, r;
    }
    return e.prototype.setComp = function(t) {
      this.comp = t, this.setupTooltip();
    }, e.prototype.setupTooltip = function() {
      this.browserTooltips = this.beans.gridOptionsWrapper.isEnableBrowserTooltips(), this.updateTooltipText(), this.browserTooltips ? this.comp.setTitle(this.tooltip != null ? this.tooltip : void 0) : this.createTooltipFeatureIfNeeded();
    }, e.prototype.updateTooltipText = function() {
      this.tooltip = this.ctrl.getTooltipValue();
    }, e.prototype.createTooltipFeatureIfNeeded = function() {
      var t = this;
      if (this.genericTooltipFeature == null) {
        var i = {
          getTooltipParams: function() {
            return t.getTooltipParams();
          },
          getGui: function() {
            return t.ctrl.getGui();
          }
        };
        this.genericTooltipFeature = this.createManagedBean(new LS(i), this.beans.context);
      }
    }, e.prototype.refreshToolTip = function() {
      this.updateTooltipText(), this.browserTooltips && this.comp.setTitle(this.tooltip != null ? this.tooltip : void 0);
    }, e.prototype.getTooltipParams = function() {
      var t = this.ctrl, i = t.getColumn ? t.getColumn() : void 0, r = t.getColDef ? t.getColDef() : void 0, o = t.getRowNode ? t.getRowNode() : void 0;
      return {
        location: t.getLocation(),
        colDef: r,
        column: i,
        rowIndex: t.getRowIndex ? t.getRowIndex() : void 0,
        node: o,
        data: o ? o.data : void 0,
        value: this.getTooltipText(),
        valueFormatted: t.getValueFormatted ? t.getValueFormatted() : void 0
      };
    }, e.prototype.getTooltipText = function() {
      return this.tooltip;
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var vt = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Cx = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.postConstruct = function() {
      this.doingMasterDetail = this.gridOptionsWrapper.isMasterDetail(), this.gridOptionsWrapper.isRowModelDefault() && (this.clientSideRowModel = this.rowModel), this.gridOptionsWrapper.isRowModelServerSide() && (this.serverSideRowModel = this.rowModel);
    }, vt([
      R("resizeObserverService")
    ], n.prototype, "resizeObserverService", void 0), vt([
      R("paginationProxy")
    ], n.prototype, "paginationProxy", void 0), vt([
      R("context")
    ], n.prototype, "context", void 0), vt([
      R("columnApi")
    ], n.prototype, "columnApi", void 0), vt([
      R("gridApi")
    ], n.prototype, "gridApi", void 0), vt([
      R("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), vt([
      R("expressionService")
    ], n.prototype, "expressionService", void 0), vt([
      R("rowRenderer")
    ], n.prototype, "rowRenderer", void 0), vt([
      R("$compile")
    ], n.prototype, "$compile", void 0), vt([
      R("templateService")
    ], n.prototype, "templateService", void 0), vt([
      R("valueService")
    ], n.prototype, "valueService", void 0), vt([
      R("eventService")
    ], n.prototype, "eventService", void 0), vt([
      R("columnModel")
    ], n.prototype, "columnModel", void 0), vt([
      R("headerNavigationService")
    ], n.prototype, "headerNavigationService", void 0), vt([
      R("navigationService")
    ], n.prototype, "navigationService", void 0), vt([
      R("columnAnimationService")
    ], n.prototype, "columnAnimationService", void 0), vt([
      fi("rangeService")
    ], n.prototype, "rangeService", void 0), vt([
      R("focusService")
    ], n.prototype, "focusService", void 0), vt([
      fi("contextMenuFactory")
    ], n.prototype, "contextMenuFactory", void 0), vt([
      R("popupService")
    ], n.prototype, "popupService", void 0), vt([
      R("valueFormatterService")
    ], n.prototype, "valueFormatterService", void 0), vt([
      R("stylingService")
    ], n.prototype, "stylingService", void 0), vt([
      R("columnHoverService")
    ], n.prototype, "columnHoverService", void 0), vt([
      R("userComponentFactory")
    ], n.prototype, "userComponentFactory", void 0), vt([
      R("userComponentRegistry")
    ], n.prototype, "userComponentRegistry", void 0), vt([
      R("animationFrameService")
    ], n.prototype, "animationFrameService", void 0), vt([
      R("dragAndDropService")
    ], n.prototype, "dragAndDropService", void 0), vt([
      R("sortController")
    ], n.prototype, "sortController", void 0), vt([
      R("filterManager")
    ], n.prototype, "filterManager", void 0), vt([
      R("rowContainerHeightService")
    ], n.prototype, "rowContainerHeightService", void 0), vt([
      R("frameworkOverrides")
    ], n.prototype, "frameworkOverrides", void 0), vt([
      R("cellPositionUtils")
    ], n.prototype, "cellPositionUtils", void 0), vt([
      R("rowPositionUtils")
    ], n.prototype, "rowPositionUtils", void 0), vt([
      R("selectionService")
    ], n.prototype, "selectionService", void 0), vt([
      fi("selectionHandleFactory")
    ], n.prototype, "selectionHandleFactory", void 0), vt([
      R("rowCssClassCalculator")
    ], n.prototype, "rowCssClassCalculator", void 0), vt([
      R("rowModel")
    ], n.prototype, "rowModel", void 0), vt([
      R("ctrlsService")
    ], n.prototype, "ctrlsService", void 0), vt([
      R("ctrlsFactory")
    ], n.prototype, "ctrlsFactory", void 0), vt([
      R("agStackComponentsRegistry")
    ], n.prototype, "agStackComponentsRegistry", void 0), vt([
      R("valueCache")
    ], n.prototype, "valueCache", void 0), vt([
      R("rowNodeEventThrottle")
    ], n.prototype, "rowNodeEventThrottle", void 0), vt([
      Ee
    ], n.prototype, "postConstruct", null), n = vt([
      Ke("beans")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Lq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Dq = (
  /** @class */
  function(n) {
    Lq(e, n);
    function e(t, i, r) {
      var o = n.call(this) || this;
      return o.cellCtrl = t, o.beans = i, o.column = r, o;
    }
    return e.prototype.onMouseEvent = function(t, i) {
      if (!Ml(i))
        switch (t) {
          case "click":
            this.onCellClicked(i);
            break;
          case "mousedown":
          case "touchstart":
            this.onMouseDown(i);
            break;
          case "dblclick":
            this.onCellDoubleClicked(i);
            break;
          case "mouseout":
            this.onMouseOut(i);
            break;
          case "mouseover":
            this.onMouseOver(i);
            break;
        }
    }, e.prototype.onCellClicked = function(t) {
      if (this.isDoubleClickOnIPad()) {
        this.onCellDoubleClicked(t), t.preventDefault();
        return;
      }
      var i = this.beans, r = i.eventService, o = i.gridOptionsWrapper, s = this.cellCtrl.createEvent(t, I.EVENT_CELL_CLICKED);
      r.dispatchEvent(s);
      var a = this.column.getColDef();
      a.onCellClicked && window.setTimeout(function() {
        return a.onCellClicked(s);
      }, 0);
      var l = (o.isSingleClickEdit() || a.singleClickEdit) && !o.isSuppressClickEdit();
      l && this.cellCtrl.startRowOrCellEdit();
    }, e.prototype.isDoubleClickOnIPad = function() {
      if (!ug() || KO("dblclick"))
        return !1;
      var t = (/* @__PURE__ */ new Date()).getTime(), i = t - this.lastIPadMouseClickEvent < 200;
      return this.lastIPadMouseClickEvent = t, i;
    }, e.prototype.onCellDoubleClicked = function(t) {
      var i = this.column.getColDef(), r = this.cellCtrl.createEvent(t, I.EVENT_CELL_DOUBLE_CLICKED);
      this.beans.eventService.dispatchEvent(r), typeof i.onCellDoubleClicked == "function" && window.setTimeout(function() {
        return i.onCellDoubleClicked(r);
      }, 0);
      var o = !this.beans.gridOptionsWrapper.isSingleClickEdit() && !this.beans.gridOptionsWrapper.isSuppressClickEdit();
      o && this.cellCtrl.startRowOrCellEdit(null, null, t);
    }, e.prototype.onMouseDown = function(t) {
      var i = t.ctrlKey, r = t.metaKey, o = t.shiftKey, s = t.target, a = this.beans, l = a.eventService, u = a.rangeService;
      if (!this.isRightClickInExistingRange(t)) {
        var c = u && u.getCellRanges().length != 0;
        if (!o || !c) {
          var h = _S() && !this.cellCtrl.isEditing() && !fB(s);
          this.cellCtrl.focusCell(h);
        }
        if (o && c && t.preventDefault(), !this.containsWidget(s)) {
          if (u) {
            var d = this.cellCtrl.getCellPosition();
            if (o)
              u.extendLatestRangeToCell(d);
            else {
              var f = i || r;
              u.setRangeToCell(d, f);
            }
          }
          l.dispatchEvent(this.cellCtrl.createEvent(t, I.EVENT_CELL_MOUSE_DOWN));
        }
      }
    }, e.prototype.isRightClickInExistingRange = function(t) {
      var i = this.beans.rangeService;
      if (i) {
        var r = i.isCellInAnyRange(this.cellCtrl.getCellPosition());
        if (r && t.button === 2)
          return !0;
      }
      return !1;
    }, e.prototype.containsWidget = function(t) {
      return yS(t, "ag-selection-checkbox", 3);
    }, e.prototype.onMouseOut = function(t) {
      if (!this.mouseStayingInsideCell(t)) {
        var i = this.cellCtrl.createEvent(t, I.EVENT_CELL_MOUSE_OUT);
        this.beans.eventService.dispatchEvent(i), this.beans.columnHoverService.clearMouseOver();
      }
    }, e.prototype.onMouseOver = function(t) {
      if (!this.mouseStayingInsideCell(t)) {
        var i = this.cellCtrl.createEvent(t, I.EVENT_CELL_MOUSE_OVER);
        this.beans.eventService.dispatchEvent(i), this.beans.columnHoverService.setMouseOver([this.column]);
      }
    }, e.prototype.mouseStayingInsideCell = function(t) {
      if (!t.target || !t.relatedTarget)
        return !1;
      var i = this.cellCtrl.getGui(), r = i.contains(t.target), o = i.contains(t.relatedTarget);
      return r && o;
    }, e.prototype.destroy = function() {
    }, e;
  }(Cx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Rq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Tq = (
  /** @class */
  function(n) {
    Rq(e, n);
    function e(t, i, r, o, s, a) {
      var l = n.call(this) || this;
      return l.cellCtrl = t, l.beans = i, l.rowNode = o, l.rowCtrl = a, l;
    }
    return e.prototype.setComp = function(t) {
      this.eGui = t;
    }, e.prototype.onKeyDown = function(t) {
      var i = t.key;
      switch (i) {
        case pe.ENTER:
          this.onEnterKeyDown(t);
          break;
        case pe.F2:
          this.onF2KeyDown(t);
          break;
        case pe.ESCAPE:
          this.onEscapeKeyDown(t);
          break;
        case pe.TAB:
          this.onTabKeyDown(t);
          break;
        case pe.BACKSPACE:
        case pe.DELETE:
          this.onBackspaceOrDeleteKeyPressed(i, t);
          break;
        case pe.DOWN:
        case pe.UP:
        case pe.RIGHT:
        case pe.LEFT:
          this.onNavigationKeyPressed(t, i);
          break;
      }
    }, e.prototype.onNavigationKeyPressed = function(t, i) {
      this.cellCtrl.isEditing() || (t.shiftKey && this.cellCtrl.isRangeSelectionEnabled() ? this.onShiftRangeSelect(i) : this.beans.navigationService.navigateToNextCell(t, i, this.cellCtrl.getCellPosition(), !0), t.preventDefault());
    }, e.prototype.onShiftRangeSelect = function(t) {
      if (this.beans.rangeService) {
        var i = this.beans.rangeService.extendLatestRangeInDirection(t);
        i && this.beans.navigationService.ensureCellVisible(i);
      }
    }, e.prototype.onTabKeyDown = function(t) {
      this.beans.navigationService.onTabKeyDown(this.cellCtrl, t);
    }, e.prototype.onBackspaceOrDeleteKeyPressed = function(t, i) {
      this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(t, void 0, i);
    }, e.prototype.onEnterKeyDown = function(t) {
      this.cellCtrl.isEditing() || this.rowCtrl.isEditing() ? this.cellCtrl.stopEditingAndFocus() : this.beans.gridOptionsWrapper.isEnterMovesDown() ? this.beans.navigationService.navigateToNextCell(null, pe.DOWN, this.cellCtrl.getCellPosition(), !1) : (this.cellCtrl.startRowOrCellEdit(pe.ENTER, void 0, t), this.cellCtrl.isEditing() && t.preventDefault());
    }, e.prototype.onF2KeyDown = function(t) {
      this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(pe.F2, void 0, t);
    }, e.prototype.onEscapeKeyDown = function(t) {
      this.cellCtrl.isEditing() && (this.cellCtrl.stopRowOrCellEdit(!0), this.cellCtrl.focusCell(!0));
    }, e.prototype.onKeyPress = function(t) {
      var i = t.target, r = i !== this.eGui;
      if (!(r || this.cellCtrl.isEditing())) {
        var o = String.fromCharCode(t.charCode);
        o === " " ? this.onSpaceKeyPressed(t) : VB(t) && (this.cellCtrl.startRowOrCellEdit(null, o, t), t.preventDefault());
      }
    }, e.prototype.onSpaceKeyPressed = function(t) {
      var i = this.beans.gridOptionsWrapper;
      if (!this.cellCtrl.isEditing() && i.isRowSelection()) {
        var r = this.rowNode.isSelected(), o = !r;
        if (o || !i.isSuppressRowDeselection()) {
          var s = this.beans.gridOptionsWrapper.isGroupSelectsFiltered(), a = this.rowNode.setSelectedParams({
            newValue: o,
            rangeSelect: t.shiftKey,
            groupSelectsFiltered: s
          });
          r === void 0 && a === 0 && this.rowNode.setSelectedParams({
            newValue: !1,
            rangeSelect: t.shiftKey,
            groupSelectsFiltered: s
          });
        }
      }
      t.preventDefault();
    }, e.prototype.destroy = function() {
    }, e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Oq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), xq = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Nq = (
  /** @class */
  function(n) {
    Oq(e, n);
    function e(t, i, r, o) {
      var s = n.call(this, '<div class="ag-drag-handle ag-row-drag" draggable="true"></div>') || this;
      return s.rowNode = t, s.column = i, s.beans = r, s.eCell = o, s;
    }
    return e.prototype.postConstruct = function() {
      var t = this.getGui();
      t.appendChild(Kn("rowDrag", this.beans.gridOptionsWrapper, null)), this.addGuiEventListener("mousedown", function(i) {
        i.stopPropagation();
      }), this.addDragSource(), this.checkVisibility();
    }, e.prototype.addDragSource = function() {
      this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
    }, e.prototype.onDragStart = function(t) {
      var i = this, r = this.column.getColDef().dndSourceOnRowDrag;
      t.dataTransfer.setDragImage(this.eCell, 0, 0);
      var o = function() {
        try {
          var s = JSON.stringify(i.rowNode.data);
          t.dataTransfer.setData("application/json", s), t.dataTransfer.setData("text/plain", s);
        } catch {
        }
      };
      r ? r({ rowNode: this.rowNode, dragEvent: t }) : o();
    }, e.prototype.checkVisibility = function() {
      var t = this.column.isDndSource(this.rowNode);
      this.setDisplayed(t);
    }, xq([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Iq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Hw = globalThis && globalThis.__assign || function() {
  return Hw = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, Hw.apply(this, arguments);
}, Pq = "ag-cell", Aq = "ag-cell-auto-height", Mq = "ag-cell-normal-height", Fq = "ag-cell-focus", kq = "ag-cell-first-right-pinned", Wq = "ag-cell-last-left-pinned", gM = "ag-cell-not-inline-editing", Vq = "ag-cell-inline-editing", Bq = "ag-cell-popup-editing", Hq = "ag-column-hover", Gq = "ag-cell-wrap-text", Uq = 0, jc = (
  /** @class */
  function(n) {
    Iq(e, n);
    function e(t, i, r, o) {
      var s = n.call(this) || this;
      return s.suppressRefreshCell = !1, s.column = t, s.rowNode = i, s.beans = r, s.rowCtrl = o, s.instanceId = t.getId() + "-" + Uq++, s.createCellPosition(), s.addFeatures(), s;
    }
    return e.prototype.addFeatures = function() {
      var t = this;
      this.cellPositionFeature = new wq(this, this.beans), this.addDestroyFunc(function() {
        return t.cellPositionFeature.destroy();
      }), this.cellCustomStyleFeature = new Sq(this, this.beans), this.addDestroyFunc(function() {
        return t.cellCustomStyleFeature.destroy();
      }), this.cellMouseListenerFeature = new Dq(this, this.beans, this.column), this.addDestroyFunc(function() {
        return t.cellMouseListenerFeature.destroy();
      }), this.cellKeyboardListenerFeature = new Tq(this, this.beans, this.column, this.rowNode, this.scope, this.rowCtrl), this.addDestroyFunc(function() {
        return t.cellKeyboardListenerFeature.destroy();
      });
      var i = this.beans.rangeService && this.beans.gridOptionsWrapper.isEnableRangeSelection();
      i && (this.cellRangeFeature = new Cq(this.beans, this), this.addDestroyFunc(function() {
        return t.cellRangeFeature.destroy();
      })), this.addTooltipFeature();
    }, e.prototype.addTooltipFeature = function() {
      var t = this, i = function() {
        var o = t.column.getColDef(), s = t.rowNode.data;
        if (o.tooltipField && de(s))
          return xw(s, o.tooltipField, t.column.isTooltipFieldContainsDots());
        var a = o.tooltipValueGetter;
        return a ? a({
          location: "cell",
          api: t.beans.gridOptionsWrapper.getApi(),
          columnApi: t.beans.gridOptionsWrapper.getColumnApi(),
          context: t.beans.gridOptionsWrapper.getContext(),
          colDef: t.column.getColDef(),
          column: t.column,
          rowIndex: t.cellPosition.rowIndex,
          node: t.rowNode,
          data: t.rowNode.data,
          value: t.value,
          valueFormatted: t.valueFormatted
        }) : null;
      }, r = {
        getColumn: function() {
          return t.column;
        },
        getColDef: function() {
          return t.column.getColDef();
        },
        getRowIndex: function() {
          return t.cellPosition.rowIndex;
        },
        getRowNode: function() {
          return t.rowNode;
        },
        getGui: function() {
          return t.getGui();
        },
        getLocation: function() {
          return "cell";
        },
        getTooltipValue: i,
        // this makes no sense, why is the cell formatted value passed to the tooltip???
        getValueFormatted: function() {
          return t.valueFormatted;
        }
      };
      this.tooltipFeature = new _x(r, this.beans), this.addDestroyFunc(function() {
        return t.tooltipFeature.destroy();
      });
    }, e.prototype.setComp = function(t, i, r, o, s, a) {
      this.cellComp = t, this.gow = this.beans.gridOptionsWrapper, this.scope = i, this.eGui = r, this.eCellWrapper = o, this.printLayout = s, this.updateAndFormatValue(!0), this.addDomData(), this.onCellFocused(), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), this.setupAriaExpanded(), this.setupAutoHeight(), this.setAriaColIndex(), this.gow.isSuppressCellFocus() || this.cellComp.setTabIndex(-1);
      var l = Gl(this.column.getId());
      this.cellComp.setColId(l), this.cellComp.setRole("gridcell"), this.cellPositionFeature.setComp(r), this.cellCustomStyleFeature.setComp(t, i), this.tooltipFeature.setComp(t), this.cellKeyboardListenerFeature.setComp(this.eGui), this.cellRangeFeature && this.cellRangeFeature.setComp(t, r), a && this.isCellEditable() ? this.startEditing() : this.showValue();
    }, e.prototype.setupAutoHeight = function() {
      var t = this;
      if (this.column.isAutoHeight()) {
        var i = this.eCellWrapper, r = i.parentElement, o = this.beans.gridOptionsWrapper.getRowHeightAsNumber(), s = function(u) {
          if (!t.editing) {
            var c = t.beans.gridOptionsWrapper.getDocument();
            if ((!c || !c.contains(i)) && u < 5) {
              t.beans.frameworkOverrides.setTimeout(function() {
                return s(u + 1);
              }, 0);
              return;
            }
            var h = cg(r), d = h.paddingTop, f = h.paddingBottom, p = i.offsetHeight, g = p + d + f, _ = Math.max(g, o);
            t.rowNode.setRowAutoHeight(_, t.column);
          }
        }, a = function() {
          return s(0);
        };
        a();
        var l = this.beans.resizeObserverService.observeResize(i, a);
        this.addDestroyFunc(function() {
          l(), t.rowNode.setRowAutoHeight(void 0, t.column);
        });
      }
    }, e.prototype.getInstanceId = function() {
      return this.instanceId;
    }, e.prototype.showValue = function(t) {
      t === void 0 && (t = !1);
      var i = this.valueFormatted != null ? this.valueFormatted : this.value, r = this.createCellRendererParams(), o = this.beans.userComponentFactory.getCellRendererDetails(this.column.getColDef(), r);
      this.cellComp.setRenderDetails(o, i, t), this.refreshHandle();
    }, e.prototype.setupControlComps = function() {
      var t = this.column.getColDef();
      this.includeSelection = this.isIncludeControl(t.checkboxSelection), this.includeRowDrag = this.isIncludeControl(t.rowDrag), this.includeDndSource = this.isIncludeControl(t.dndSource), this.cellComp.setIncludeSelection(this.includeSelection), this.cellComp.setIncludeDndSource(this.includeDndSource), this.cellComp.setIncludeRowDrag(this.includeRowDrag);
    }, e.prototype.isForceWrapper = function() {
      var t = this.beans.gridOptionsWrapper.isEnableCellTextSelection() || this.column.isAutoHeight();
      return t;
    }, e.prototype.isIncludeControl = function(t) {
      var i = this.rowNode.rowPinned != null, r = typeof t == "function", o = i ? !1 : r || t === !0;
      return o;
    }, e.prototype.setupAriaExpanded = function() {
      var t = this, i = this.column.getColDef();
      if (this.rowNode.isExpandable()) {
        var r = i.showRowGroup, o = this.rowNode.rowGroupColumn, s = r === !0, a = o && o.getColId() === r, l = s || a;
        if (l) {
          var u = function() {
            _s(t.eGui, !!t.rowNode.expanded);
          };
          this.addManagedListener(this.rowNode, kt.EVENT_EXPANDED_CHANGED, u), u();
        }
      }
    }, e.prototype.refreshShouldDestroy = function() {
      var t = this.column.getColDef(), i = this.includeSelection != this.isIncludeControl(t.checkboxSelection), r = this.includeRowDrag != this.isIncludeControl(t.rowDrag), o = this.includeDndSource != this.isIncludeControl(t.dndSource);
      return i || r || o;
    }, e.prototype.startEditing = function(t, i, r, o) {
      t === void 0 && (t = null), i === void 0 && (i = null), r === void 0 && (r = !1), o === void 0 && (o = null);
      var s, a;
      if (!(!this.isCellEditable() || this.editing)) {
        var l = this.createCellEditorParams(t, i, r), u = this.column.getColDef(), c = this.beans.userComponentFactory.getCellEditorDetails(u, l), h = ((s = c) === null || s === void 0 ? void 0 : s.popupFromSelector) != null ? c.popupFromSelector : !!u.cellEditorPopup, d = ((a = c) === null || a === void 0 ? void 0 : a.popupPositionFromSelector) != null ? c.popupPositionFromSelector : u.cellEditorPopupPosition;
        this.setEditing(!0, h), this.cellComp.setEditDetails(c, h, d);
        var f = this.createEvent(o, I.EVENT_CELL_EDITING_STARTED);
        this.beans.eventService.dispatchEvent(f);
      }
    }, e.prototype.setEditing = function(t, i) {
      i === void 0 && (i = !1), this.editing !== t && (this.editing = t, this.editingInPopup = i, this.setInlineEditingClass());
    }, e.prototype.stopRowOrCellEdit = function(t) {
      t === void 0 && (t = !1), this.beans.gridOptionsWrapper.isFullRowEdit() ? this.rowCtrl.stopRowEditing(t) : this.stopEditing(t);
    }, e.prototype.onPopupEditorClosed = function() {
      this.isEditing() && this.stopEditingAndFocus();
    }, e.prototype.takeValueFromCellEditor = function(t) {
      var i = { newValueExists: !1 };
      if (t)
        return i;
      var r = this.cellComp.getCellEditor();
      if (!r)
        return i;
      var o = r.isCancelAfterEnd && r.isCancelAfterEnd();
      if (o)
        return i;
      var s = r.getValue();
      return {
        newValue: s,
        newValueExists: !0
      };
    }, e.prototype.saveNewValue = function(t, i) {
      if (i !== t) {
        if (this.beans.gridOptionsWrapper.isReadOnlyEdit()) {
          this.dispatchEventForSaveValueReadOnly(t, i);
          return;
        }
        this.suppressRefreshCell = !0, this.rowNode.setDataValue(this.column, i), this.suppressRefreshCell = !1;
      }
    }, e.prototype.dispatchEventForSaveValueReadOnly = function(t, i) {
      var r = this.rowNode, o = {
        type: I.EVENT_CELL_EDIT_REQUEST,
        event: null,
        rowIndex: r.rowIndex,
        rowPinned: r.rowPinned,
        column: this.column,
        api: this.beans.gridApi,
        columnApi: this.beans.columnApi,
        colDef: this.column.getColDef(),
        context: this.beans.gridOptionsWrapper.getContext(),
        data: r.data,
        node: r,
        oldValue: t,
        newValue: i,
        value: i,
        source: void 0
      };
      this.beans.eventService.dispatchEvent(o);
    }, e.prototype.stopEditing = function(t) {
      if (t === void 0 && (t = !1), !!this.editing) {
        var i = this.takeValueFromCellEditor(t), r = i.newValue, o = i.newValueExists, s = this.getValueFromValueService();
        o && this.saveNewValue(s, r), this.setEditing(!1), this.cellComp.setEditDetails(), this.updateAndFormatValue(), this.refreshCell({ forceRefresh: !0, suppressFlash: !0 }), this.dispatchEditingStoppedEvent(s, r);
      }
    }, e.prototype.dispatchEditingStoppedEvent = function(t, i) {
      var r = Hw(Hw({}, this.createEvent(null, I.EVENT_CELL_EDITING_STOPPED)), {
        oldValue: t,
        newValue: i
      });
      this.beans.eventService.dispatchEvent(r);
    }, e.prototype.setInlineEditingClass = function() {
      if (this.isAlive()) {
        var t = this.editing && !this.editingInPopup, i = this.editing && this.editingInPopup;
        this.cellComp.addOrRemoveCssClass(Vq, t), this.cellComp.addOrRemoveCssClass(gM, !t), this.cellComp.addOrRemoveCssClass(Bq, i), this.rowCtrl.setInlineEditingCss(this.editing);
      }
    }, e.prototype.hackSayEditingInPopup = function() {
      this.editingInPopup || (this.editingInPopup = !0, this.setInlineEditingClass());
    }, e.prototype.createCellEditorParams = function(t, i, r) {
      var o = {
        value: this.getValueFromValueService(),
        key: t,
        eventKey: t,
        charPress: i,
        column: this.column,
        colDef: this.column.getColDef(),
        rowIndex: this.getCellPosition().rowIndex,
        node: this.rowNode,
        data: this.rowNode.data,
        api: this.beans.gridOptionsWrapper.getApi(),
        cellStartedEdit: r,
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        context: this.beans.gridOptionsWrapper.getContext(),
        onKeyDown: this.onKeyDown.bind(this),
        stopEditing: this.stopEditingAndFocus.bind(this),
        eGridCell: this.getGui(),
        parseValue: this.parseValue.bind(this),
        formatValue: this.formatValue.bind(this)
      };
      return this.scope && (o.$scope = this.scope), o;
    }, e.prototype.createCellRendererParams = function() {
      var t = this, i = function(o, s) {
        console.warn("AG Grid: since AG Grid v26, params.addRowCompListener() is deprecated. If you need this functionality, please contact AG Grid support and advise why so that we can revert with an appropriate workaround, as we dont have any valid use cases for it. This method was originally provided as a work around to know when cells were destroyed in AG Grid before custom Cell Renderers could be provided."), t.rowCtrl.addEventListener(o, s);
      }, r = {
        value: this.value,
        valueFormatted: this.valueFormatted,
        getValue: this.getValueFromValueService.bind(this),
        setValue: function(o) {
          return t.beans.valueService.setValue(t.rowNode, t.column, o);
        },
        formatValue: this.formatValue.bind(this),
        data: this.rowNode.data,
        node: this.rowNode,
        colDef: this.column.getColDef(),
        column: this.column,
        rowIndex: this.getCellPosition().rowIndex,
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        context: this.beans.gridOptionsWrapper.getContext(),
        refreshCell: this.refreshCell.bind(this),
        eGridCell: this.getGui(),
        eParentOfValue: this.cellComp.getParentOfValue(),
        registerRowDragger: function(o, s, a, l) {
          return t.registerRowDragger(o, s, l);
        },
        // this function is not documented anywhere, so we could drop it
        // it was in the olden days to allow user to register for when rendered
        // row was removed (the row comp was removed), however now that the user
        // can provide components for cells, the destroy method gets call when this
        // happens so no longer need to fire event.
        addRowCompListener: i
      };
      return this.scope && (r.$scope = this.scope), r;
    }, e.prototype.parseValue = function(t) {
      var i = this.column.getColDef(), r = {
        node: this.rowNode,
        data: this.rowNode.data,
        oldValue: this.getValue(),
        newValue: t,
        colDef: i,
        column: this.column,
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        context: this.beans.gridOptionsWrapper.getContext()
      }, o = i.valueParser;
      return de(o) ? this.beans.expressionService.evaluate(o, r) : t;
    }, e.prototype.setFocusOutOnEditor = function() {
      if (this.editing) {
        var t = this.cellComp.getCellEditor();
        t && t.focusOut && t.focusOut();
      }
    }, e.prototype.setFocusInOnEditor = function() {
      if (this.editing) {
        var t = this.cellComp.getCellEditor();
        t && t.focusIn ? t.focusIn() : this.focusCell(!0);
      }
    }, e.prototype.onCellChanged = function(t) {
      if (this.cellComp) {
        var i = t.column === this.column;
        i && this.refreshCell({});
      }
    }, e.prototype.refreshCell = function(t) {
      if (!(this.suppressRefreshCell || this.editing)) {
        var i = this.column.getColDef(), r = t != null && !!t.newData, o = t != null && !!t.suppressFlash || !!i.suppressCellFlash, s = i.field == null && i.valueGetter == null && i.showRowGroup == null, a = t && t.forceRefresh || s || r, l = this.updateAndFormatValue(), u = a || l;
        if (u) {
          this.showValue(r);
          var c = this.beans.filterManager.isSuppressFlashingCellsBecauseFiltering(), h = !o && !c && (this.beans.gridOptionsWrapper.isEnableCellChangeFlash() || i.enableCellChangeFlash);
          h && this.flashCell(), this.cellCustomStyleFeature.applyUserStyles(), this.cellCustomStyleFeature.applyClassesFromColDef();
        }
        this.refreshToolTip(), this.cellCustomStyleFeature.applyCellClassRules();
      }
    }, e.prototype.stopEditingAndFocus = function(t) {
      t === void 0 && (t = !1), this.stopRowOrCellEdit(), this.focusCell(!0), t || this.navigateAfterEdit();
    }, e.prototype.navigateAfterEdit = function() {
      var t = this.beans.gridOptionsWrapper.isFullRowEdit();
      if (!t) {
        var i = this.beans.gridOptionsWrapper.isEnterMovesDownAfterEdit();
        i && this.beans.navigationService.navigateToNextCell(null, pe.DOWN, this.getCellPosition(), !1);
      }
    }, e.prototype.flashCell = function(t) {
      var i = t && t.flashDelay, r = t && t.fadeDelay;
      this.animateCell("data-changed", i, r);
    }, e.prototype.animateCell = function(t, i, r) {
      var o = this, s = "ag-cell-" + t, a = "ag-cell-" + t + "-animation", l = this.beans.gridOptionsWrapper;
      i || (i = l.getCellFlashDelay()), de(r) || (r = l.getCellFadeDelay()), this.cellComp.addOrRemoveCssClass(s, !0), this.cellComp.addOrRemoveCssClass(a, !1), window.setTimeout(function() {
        o.cellComp.addOrRemoveCssClass(s, !1), o.cellComp.addOrRemoveCssClass(a, !0), o.eGui.style.transition = "background-color " + r + "ms", window.setTimeout(function() {
          o.cellComp.addOrRemoveCssClass(a, !1), o.eGui.style.transition = "";
        }, r);
      }, i);
    }, e.prototype.onFlashCells = function(t) {
      if (this.cellComp) {
        var i = this.beans.cellPositionUtils.createId(this.getCellPosition()), r = t.cells[i];
        r && this.animateCell("highlight");
      }
    }, e.prototype.isCellEditable = function() {
      return this.column.isCellEditable(this.rowNode);
    }, e.prototype.isSuppressFillHandle = function() {
      return this.column.isSuppressFillHandle();
    }, e.prototype.formatValue = function(t) {
      var i = this.callValueFormatter(t);
      return i ?? t;
    }, e.prototype.callValueFormatter = function(t) {
      return this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, t);
    }, e.prototype.updateAndFormatValue = function(t) {
      t === void 0 && (t = !1);
      var i = this.value, r = this.valueFormatted;
      this.value = this.getValueFromValueService(), this.valueFormatted = this.callValueFormatter(this.value);
      var o = t ? !0 : !this.valuesAreEqual(i, this.value) || this.valueFormatted != r;
      return o;
    }, e.prototype.valuesAreEqual = function(t, i) {
      var r = this.column.getColDef();
      return r.equals ? r.equals(t, i) : t === i;
    }, e.prototype.getComp = function() {
      return this.cellComp;
    }, e.prototype.getValueFromValueService = function() {
      var t = this.rowNode.leafGroup && this.beans.columnModel.isPivotMode(), i = this.rowNode.group && this.rowNode.expanded && !this.rowNode.footer && !t, r = this.beans.gridOptionsWrapper.isGroupIncludeFooter(), o = this.beans.gridOptionsWrapper.isGroupSuppressBlankHeader(), s = i && r && !o, a = this.beans.valueService.getValue(this.column, this.rowNode, !1, s);
      return a;
    }, e.prototype.getValue = function() {
      return this.value;
    }, e.prototype.getValueFormatted = function() {
      return this.valueFormatted;
    }, e.prototype.addDomData = function() {
      var t = this, i = this.getGui();
      this.beans.gridOptionsWrapper.setDomData(i, e.DOM_DATA_KEY_CELL_CTRL, this), this.addDestroyFunc(function() {
        return t.beans.gridOptionsWrapper.setDomData(i, e.DOM_DATA_KEY_CELL_CTRL, null);
      });
    }, e.prototype.createEvent = function(t, i) {
      var r = {
        type: i,
        node: this.rowNode,
        data: this.rowNode.data,
        value: this.value,
        column: this.column,
        colDef: this.column.getColDef(),
        context: this.beans.gridOptionsWrapper.getContext(),
        api: this.beans.gridApi,
        columnApi: this.beans.columnApi,
        rowPinned: this.rowNode.rowPinned,
        event: t,
        rowIndex: this.rowNode.rowIndex
      };
      return this.scope && (r.$scope = this.scope), r;
    }, e.prototype.onKeyPress = function(t) {
      this.cellKeyboardListenerFeature.onKeyPress(t);
    }, e.prototype.onKeyDown = function(t) {
      this.cellKeyboardListenerFeature.onKeyDown(t);
    }, e.prototype.onMouseEvent = function(t, i) {
      this.cellMouseListenerFeature.onMouseEvent(t, i);
    }, e.prototype.getGui = function() {
      return this.eGui;
    }, e.prototype.refreshToolTip = function() {
      this.tooltipFeature.refreshToolTip();
    }, e.prototype.getColSpanningList = function() {
      return this.cellPositionFeature.getColSpanningList();
    }, e.prototype.onLeftChanged = function() {
      this.cellComp && this.cellPositionFeature.onLeftChanged();
    }, e.prototype.onDisplayedColumnsChanged = function() {
      this.eGui && this.setAriaColIndex();
    }, e.prototype.setAriaColIndex = function() {
      var t = this.beans.columnModel.getAriaColumnIndex(this.column);
      ax(this.getGui(), t);
    }, e.prototype.isSuppressNavigable = function() {
      return this.column.isSuppressNavigable(this.rowNode);
    }, e.prototype.onWidthChanged = function() {
      return this.cellPositionFeature.onWidthChanged();
    }, e.prototype.getColumn = function() {
      return this.column;
    }, e.prototype.getRowNode = function() {
      return this.rowNode;
    }, e.prototype.getBeans = function() {
      return this.beans;
    }, e.prototype.isPrintLayout = function() {
      return this.printLayout;
    }, e.prototype.appendChild = function(t) {
      this.eGui.appendChild(t);
    }, e.prototype.refreshHandle = function() {
      this.editing || this.cellRangeFeature && this.cellRangeFeature.refreshHandle();
    }, e.prototype.getCellPosition = function() {
      return this.cellPosition;
    }, e.prototype.isEditing = function() {
      return this.editing;
    }, e.prototype.startRowOrCellEdit = function(t, i, r) {
      r === void 0 && (r = null), this.beans.gridOptionsWrapper.isFullRowEdit() ? this.rowCtrl.startRowEditing(t, i, this) : this.startEditing(t, i, !0, r);
    }, e.prototype.getRowCtrl = function() {
      return this.rowCtrl;
    }, e.prototype.getRowPosition = function() {
      return {
        rowIndex: this.cellPosition.rowIndex,
        rowPinned: this.cellPosition.rowPinned
      };
    }, e.prototype.updateRangeBordersIfRangeCount = function() {
      this.cellComp && this.cellRangeFeature && this.cellRangeFeature.updateRangeBordersIfRangeCount();
    }, e.prototype.onRangeSelectionChanged = function() {
      this.cellComp && this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
    }, e.prototype.isRangeSelectionEnabled = function() {
      return this.cellRangeFeature != null;
    }, e.prototype.focusCell = function(t) {
      t === void 0 && (t = !1), this.beans.focusService.setFocusedCell(this.getCellPosition().rowIndex, this.column, this.rowNode.rowPinned, t);
    }, e.prototype.onRowIndexChanged = function() {
      this.createCellPosition(), this.onCellFocused(), this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
    }, e.prototype.onFirstRightPinnedChanged = function() {
      if (this.cellComp) {
        var t = this.column.isFirstRightPinned();
        this.cellComp.addOrRemoveCssClass(kq, t);
      }
    }, e.prototype.onLastLeftPinnedChanged = function() {
      if (this.cellComp) {
        var t = this.column.isLastLeftPinned();
        this.cellComp.addOrRemoveCssClass(Wq, t);
      }
    }, e.prototype.onCellFocused = function(t) {
      if (!(!this.cellComp || this.gow.isSuppressCellFocus())) {
        var i = this.beans.focusService.isCellFocused(this.cellPosition);
        if (this.cellComp.addOrRemoveCssClass(Fq, i), i && t && t.forceBrowserFocus) {
          var r = this.cellComp.getFocusableElement();
          r.focus();
        }
        var o = this.beans.gridOptionsWrapper.isFullRowEdit();
        !i && !o && this.editing && this.stopRowOrCellEdit();
      }
    }, e.prototype.createCellPosition = function() {
      this.cellPosition = {
        rowIndex: this.rowNode.rowIndex,
        rowPinned: this.rowNode.rowPinned,
        column: this.column
      };
    }, e.prototype.applyStaticCssClasses = function() {
      this.cellComp.addOrRemoveCssClass(Pq, !0), this.cellComp.addOrRemoveCssClass(gM, !0);
      var t = this.column.isAutoHeight() == !0;
      this.cellComp.addOrRemoveCssClass(Aq, t), this.cellComp.addOrRemoveCssClass(Mq, !t);
    }, e.prototype.onColumnHover = function() {
      if (this.cellComp && this.beans.gridOptionsWrapper.isColumnHoverHighlight()) {
        var t = this.beans.columnHoverService.isHovered(this.column);
        this.cellComp.addOrRemoveCssClass(Hq, t);
      }
    }, e.prototype.onNewColumnsLoaded = function() {
      this.cellComp && (this.setWrapText(), this.editing || this.refreshCell({ forceRefresh: !0, suppressFlash: !0 }));
    }, e.prototype.setWrapText = function() {
      var t = this.column.getColDef().wrapText == !0;
      this.cellComp.addOrRemoveCssClass(Gq, t);
    }, e.prototype.dispatchCellContextMenuEvent = function(t) {
      var i = this.column.getColDef(), r = this.createEvent(t, I.EVENT_CELL_CONTEXT_MENU);
      this.beans.eventService.dispatchEvent(r), i.onCellContextMenu && window.setTimeout(function() {
        return i.onCellContextMenu(r);
      }, 0);
    }, e.prototype.getCellRenderer = function() {
      return this.cellComp ? this.cellComp.getCellRenderer() : null;
    }, e.prototype.getCellEditor = function() {
      return this.cellComp ? this.cellComp.getCellEditor() : null;
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.createSelectionCheckbox = function() {
      var t = new mx();
      return this.beans.context.createBean(t), t.init({ rowNode: this.rowNode, column: this.column }), t;
    }, e.prototype.createDndSource = function() {
      var t = new Nq(this.rowNode, this.column, this.beans, this.eGui);
      return this.beans.context.createBean(t), t;
    }, e.prototype.registerRowDragger = function(t, i, r) {
      var o = this;
      if (this.customRowDragComp) {
        this.customRowDragComp.setDragElement(t, i);
        return;
      }
      var s = this.createRowDragComp(t, i, r);
      s && (this.customRowDragComp = s, this.addDestroyFunc(function() {
        return o.beans.context.destroyBean(s);
      }));
    }, e.prototype.createRowDragComp = function(t, i, r) {
      var o = this, s = this.beans.gridOptionsWrapper.isPagination(), a = this.beans.gridOptionsWrapper.isRowDragManaged(), l = this.beans.gridOptionsWrapper.isRowModelDefault();
      if (a) {
        if (!l) {
          mi(function() {
            return console.warn("AG Grid: managed row dragging is only allowed in the Client Side Row Model");
          }, "CellComp.addRowDragging");
          return;
        }
        if (s) {
          mi(function() {
            return console.warn("AG Grid: managed row dragging is not possible when doing pagination");
          }, "CellComp.addRowDragging");
          return;
        }
      }
      var u = new Vw(function() {
        return o.value;
      }, this.rowNode, this.column, t, i, r);
      return this.beans.context.createBean(u), u;
    }, e.DOM_DATA_KEY_CELL_CTRL = "cellCtrl", e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var W1 = globalThis && globalThis.__assign || function() {
  return W1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, W1.apply(this, arguments);
}, zq = (
  /** @class */
  function() {
    function n() {
    }
    return n.createChildScopeOrNull = function(e, t, i) {
      var r = i.isAngularCompileRows();
      if (!r)
        return null;
      var o = t.$new();
      o.data = W1({}, e.data), o.rowNode = e, o.context = i.getContext();
      var s = function() {
        o.$destroy(), o.data = null, o.rowNode = null, o.context = null;
      };
      return {
        scope: o,
        scopeDestroyFunc: s
      };
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var jq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ts = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, $q = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, Kq = (
  /** @class */
  function(n) {
    jq(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.element = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.addMouseListeners(), this.mockContextMenuForIPad(), this.addKeyboardEvents();
    }, e.prototype.addKeyboardEvents = function() {
      var t = this, i = ["keydown", "keypress"];
      i.forEach(function(r) {
        var o = t.processKeyboardEvent.bind(t, r);
        t.addManagedListener(t.element, r, o);
      });
    }, e.prototype.addMouseListeners = function() {
      var t = this, i = KO("touchstart") ? "touchstart" : "mousedown", r = ["dblclick", "contextmenu", "mouseover", "mouseout", "click", i];
      r.forEach(function(o) {
        var s = t.processMouseEvent.bind(t, o);
        t.addManagedListener(t.element, o, s);
      });
    }, e.prototype.processMouseEvent = function(t, i) {
      if (!(!this.mouseEventService.isEventFromThisGrid(i) || Ml(i))) {
        var r = this.getRowForEvent(i), o = this.mouseEventService.getRenderedCellForEvent(i);
        t === "contextmenu" ? this.handleContextMenuMouseEvent(i, null, r, o) : (o && o.onMouseEvent(t, i), r && r.onMouseEvent(t, i));
      }
    }, e.prototype.mockContextMenuForIPad = function() {
      var t = this;
      if (ug()) {
        var i = new la(this.element), r = function(o) {
          var s = t.getRowForEvent(o.touchEvent), a = t.mouseEventService.getRenderedCellForEvent(o.touchEvent);
          t.handleContextMenuMouseEvent(null, o.touchEvent, s, a);
        };
        this.addManagedListener(i, la.EVENT_LONG_TAP, r), this.addDestroyFunc(function() {
          return i.destroy();
        });
      }
    }, e.prototype.getRowForEvent = function(t) {
      for (var i = t.target; i; ) {
        var r = this.gridOptionsWrapper.getDomData(i, $c.DOM_DATA_KEY_ROW_CTRL);
        if (r)
          return r;
        i = i.parentElement;
      }
      return null;
    }, e.prototype.handleContextMenuMouseEvent = function(t, i, r, o) {
      var s = r ? r.getRowNode() : null, a = o ? o.getColumn() : null, l = null;
      if (a) {
        var u = t || i;
        o.dispatchCellContextMenuEvent(u), l = this.valueService.getValue(a, s);
      }
      var c = this.ctrlsService.getGridBodyCtrl(), h = o ? o.getGui() : c.getGridBodyElement();
      this.contextMenuFactory && this.contextMenuFactory.onContextMenu(t, i, s, a, l, h);
    }, e.prototype.processKeyboardEvent = function(t, i) {
      var r = Nw(this.gridOptionsWrapper, i, jc.DOM_DATA_KEY_CELL_CTRL), o = Nw(this.gridOptionsWrapper, i, $c.DOM_DATA_KEY_ROW_CTRL);
      i.defaultPrevented || (r ? this.processCellKeyboardEvent(r, t, i) : o && o.isFullWidth() && this.processFullWidthRowKeyboardEvent(o, t, i));
    }, e.prototype.processCellKeyboardEvent = function(t, i, r) {
      var o = t.getRowNode(), s = t.getColumn(), a = t.isEditing(), l = !Fw(this.gridOptionsWrapper, r, o, s, a);
      if (l)
        switch (i) {
          case "keydown":
            var u = !a && this.navigationService.handlePageScrollingKey(r);
            u || t.onKeyDown(r), this.doGridOperations(r, t.isEditing());
            break;
          case "keypress":
            t.onKeyPress(r);
            break;
        }
      if (i === "keydown") {
        var c = t.createEvent(r, I.EVENT_CELL_KEY_DOWN);
        this.eventService.dispatchEvent(c);
      }
      if (i === "keypress") {
        var h = t.createEvent(r, I.EVENT_CELL_KEY_PRESS);
        this.eventService.dispatchEvent(h);
      }
    }, e.prototype.processFullWidthRowKeyboardEvent = function(t, i, r) {
      var o = t.getRowNode(), s = this.focusService.getFocusedCell(), a = s && s.column, l = !Fw(this.gridOptionsWrapper, r, o, a, !1);
      if (l) {
        var u = r.key;
        if (i === "keydown")
          switch (u) {
            case pe.UP:
            case pe.DOWN:
              t.onKeyboardNavigate(r);
              break;
            case pe.TAB:
              t.onTabKeyDown(r);
          }
      }
      if (i === "keydown") {
        var c = t.createRowEvent(I.EVENT_CELL_KEY_DOWN, r);
        this.eventService.dispatchEvent(c);
      }
      if (i === "keypress") {
        var h = t.createRowEvent(I.EVENT_CELL_KEY_PRESS, r);
        this.eventService.dispatchEvent(h);
      }
    }, e.prototype.doGridOperations = function(t, i) {
      if (!(!t.ctrlKey && !t.metaKey) && !i && this.mouseEventService.isEventFromThisGrid(t))
        switch (t.key.toUpperCase()) {
          case pe.A:
            return this.onCtrlAndA(t);
          case pe.C:
            return this.onCtrlAndC(t);
          case pe.V:
            return this.onCtrlAndV();
          case pe.D:
            return this.onCtrlAndD(t);
          case pe.Z:
            return t.shiftKey ? this.undoRedoService.redo() : this.undoRedoService.undo();
          case pe.Y:
            return this.undoRedoService.redo();
        }
    }, e.prototype.onCtrlAndA = function(t) {
      var i = this, r = i.pinnedRowModel, o = i.paginationProxy, s = i.rangeService, a = q.PINNED_BOTTOM, l = q.PINNED_TOP;
      if (s && o.isRowsToRender()) {
        var u = $q([
          r.isEmpty(l),
          r.isEmpty(a)
        ], 2), c = u[0], h = u[1], d = c ? null : l, f = void 0, p = void 0;
        h ? (f = null, p = this.paginationProxy.getRowCount() - 1) : (f = a, p = r.getPinnedBottomRowData().length - 1);
        var g = this.columnModel.getAllDisplayedColumns();
        if (ds(g))
          return;
        s.setCellRange({
          rowStartIndex: 0,
          rowStartPinned: d,
          rowEndIndex: p,
          rowEndPinned: f,
          columnStart: g[0],
          columnEnd: Di(g)
        });
      }
      t.preventDefault();
    }, e.prototype.onCtrlAndC = function(t) {
      !this.clipboardService || this.gridOptionsWrapper.isEnableCellTextSelection() || (this.clipboardService.copyToClipboard(), t.preventDefault());
    }, e.prototype.onCtrlAndV = function() {
      pt.isRegistered(ct.ClipboardModule) && !this.gridOptionsWrapper.isSuppressClipboardPaste() && this.clipboardService.pasteFromClipboard();
    }, e.prototype.onCtrlAndD = function(t) {
      pt.isRegistered(ct.ClipboardModule) && !this.gridOptionsWrapper.isSuppressClipboardPaste() && this.clipboardService.copyRangeDown(), t.preventDefault();
    }, ts([
      R("mouseEventService")
    ], e.prototype, "mouseEventService", void 0), ts([
      R("valueService")
    ], e.prototype, "valueService", void 0), ts([
      fi("contextMenuFactory")
    ], e.prototype, "contextMenuFactory", void 0), ts([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), ts([
      R("navigationService")
    ], e.prototype, "navigationService", void 0), ts([
      R("focusService")
    ], e.prototype, "focusService", void 0), ts([
      R("undoRedoService")
    ], e.prototype, "undoRedoService", void 0), ts([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), ts([
      R("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), ts([
      R("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), ts([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), ts([
      fi("clipboardService")
    ], e.prototype, "clipboardService", void 0), ts([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var qq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ff = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Yq = (
  /** @class */
  function(n) {
    qq(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.centerContainerCon = t, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function() {
        t.gridBodyCon = t.ctrlsService.getGridBodyCtrl(), t.listenForResize();
      }), this.addManagedListener(this.eventService, I.EVENT_SCROLLBAR_WIDTH_CHANGED, this.onScrollbarWidthChanged.bind(this));
    }, e.prototype.listenForResize = function() {
      var t = this.onCenterViewportResized.bind(this);
      this.centerContainerCon.registerViewportResizeListener(t), this.gridBodyCon.registerBodyViewportResizeListener(t);
    }, e.prototype.onScrollbarWidthChanged = function() {
      this.checkViewportAndScrolls();
    }, e.prototype.onCenterViewportResized = function() {
      if (this.centerContainerCon.isViewportVisible()) {
        this.checkViewportAndScrolls();
        var t = this.centerContainerCon.getCenterWidth();
        t !== this.centerWidth && (this.centerWidth = t, this.columnModel.refreshFlexedColumns({ viewportWidth: this.centerWidth, updateBodyWidths: !0, fireResizedEvent: !0 }));
      } else
        this.bodyHeight = 0;
    }, e.prototype.checkViewportAndScrolls = function() {
      this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCon.getScrollFeature().checkScrollLeft();
    }, e.prototype.getBodyHeight = function() {
      return this.bodyHeight;
    }, e.prototype.checkBodyHeight = function() {
      var t = this.gridBodyCon.getBodyViewportElement(), i = E_(t);
      if (this.bodyHeight !== i) {
        this.bodyHeight = i;
        var r = {
          type: I.EVENT_BODY_HEIGHT_CHANGED,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(r);
      }
    }, e.prototype.updateScrollVisibleService = function() {
      this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
    }, e.prototype.updateScrollVisibleServiceImpl = function() {
      var t = {
        horizontalScrollShowing: this.isHorizontalScrollShowing(),
        verticalScrollShowing: this.gridBodyCon.isVerticalScrollShowing()
      };
      this.scrollVisibleService.setScrollsVisible(t), this.gridBodyCon.setVerticalScrollPaddingVisible(t.verticalScrollShowing);
    }, e.prototype.isHorizontalScrollShowing = function() {
      var t = this.gridOptionsWrapper.isAlwaysShowHorizontalScroll();
      return t || this.centerContainerCon.isViewportHScrollShowing();
    }, e.prototype.onHorizontalViewportChanged = function() {
      var t = this.centerContainerCon.getCenterWidth(), i = this.centerContainerCon.getViewportScrollLeft();
      this.columnModel.setViewportPosition(t, i);
    }, ff([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), ff([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), ff([
      R("scrollVisibleService")
    ], e.prototype, "scrollVisibleService", void 0), ff([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), ff([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), ff([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Xq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), mM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Zq = (
  /** @class */
  function(n) {
    Xq(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.element = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.eventService, I.EVENT_LEFT_PINNED_WIDTH_CHANGED, this.onPinnedLeftWidthChanged.bind(this));
    }, e.prototype.onPinnedLeftWidthChanged = function() {
      var t = this.pinnedWidthService.getPinnedLeftWidth(), i = t > 0;
      Wi(this.element, i), i && Ul(this.element, t);
    }, mM([
      R("pinnedWidthService")
    ], e.prototype, "pinnedWidthService", void 0), mM([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Qq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), vM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Jq = (
  /** @class */
  function(n) {
    Qq(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.element = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.eventService, I.EVENT_RIGHT_PINNED_WIDTH_CHANGED, this.onPinnedRightWidthChanged.bind(this));
    }, e.prototype.onPinnedRightWidthChanged = function() {
      var t = this.pinnedWidthService.getPinnedRightWidth(), i = t > 0;
      Wi(this.element, i), i && Ul(this.element, t);
    }, vM([
      R("pinnedWidthService")
    ], e.prototype, "pinnedWidthService", void 0), vM([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var eY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _M = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, tY = (
  /** @class */
  function(n) {
    eY(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.eContainer = t, r.eWrapper = i, r;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.eventService, I.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onHeightChanged.bind(this));
    }, e.prototype.onHeightChanged = function() {
      var t = this.maxDivHeightScaler.getUiContainerHeight(), i = t != null ? t + "px" : "";
      this.eContainer.style.height = i, this.eWrapper && (this.eWrapper.style.height = i);
    }, _M([
      R("rowContainerHeightService")
    ], e.prototype, "maxDivHeightScaler", void 0), _M([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var iY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), cL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, nY = (
  /** @class */
  function(n) {
    iY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.eContainer = t, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      if (!(!this.gridOptionsWrapper.isEnableRangeSelection() || // no range selection if no property
      Je(this.rangeService))) {
        var i = {
          dragStartPixels: 0,
          eElement: this.eContainer,
          onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
          onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
          onDragging: this.rangeService.onDragging.bind(this.rangeService)
        };
        this.dragService.addDragSource(i), this.addDestroyFunc(function() {
          return t.dragService.removeDragSource(i);
        });
      }
    }, cL([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), cL([
      R("dragService")
    ], e.prototype, "dragService", void 0), cL([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var rY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), CM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, yx = (
  /** @class */
  function(n) {
    rY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.callback = t, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this.setWidth.bind(this);
      this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_DOM_LAYOUT, t), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, t), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, t), this.setWidth();
    }, e.prototype.setWidth = function() {
      var t = this.columnModel, i = this.gridOptionsWrapper.getDomLayout() === q.DOM_LAYOUT_PRINT, r = t.getBodyContainerWidth(), o = t.getDisplayedColumnsLeftWidth(), s = t.getDisplayedColumnsRightWidth(), a = i ? r + o + s : r;
      this.callback(a);
    }, CM([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), CM([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var oY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), xh = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, sY = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, aY = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(sY(arguments[e]));
  return n;
}, _e;
(function(n) {
  n.LEFT = "left", n.RIGHT = "right", n.CENTER = "center", n.FULL_WIDTH = "fullWidth", n.TOP_LEFT = "topLeft", n.TOP_RIGHT = "topRight", n.TOP_CENTER = "topCenter", n.TOP_FULL_WIDTH = "topFullWidth", n.BOTTOM_LEFT = "bottomLeft", n.BOTTOM_RIGHT = "bottomRight", n.BOTTOM_CENTER = "bottomCenter", n.BOTTOM_FULL_WIDTH = "bottomFullWidth";
})(_e || (_e = {}));
var Fo;
(function(n) {
  n.LEFT = "left", n.RIGHT = "right", n.CENTER = "center", n.FULL_WIDTH = "fullWidth";
})(Fo || (Fo = {}));
function lH(n) {
  switch (n) {
    case _e.CENTER:
    case _e.TOP_CENTER:
    case _e.BOTTOM_CENTER:
      return Fo.CENTER;
    case _e.LEFT:
    case _e.TOP_LEFT:
    case _e.BOTTOM_LEFT:
      return Fo.LEFT;
    case _e.RIGHT:
    case _e.TOP_RIGHT:
    case _e.BOTTOM_RIGHT:
      return Fo.RIGHT;
    case _e.FULL_WIDTH:
    case _e.TOP_FULL_WIDTH:
    case _e.BOTTOM_FULL_WIDTH:
      return Fo.FULL_WIDTH;
    default:
      throw Error("Invalid Row Container Type");
  }
}
var lY = Wc([
  [_e.CENTER, "ag-center-cols-container"],
  [_e.LEFT, "ag-pinned-left-cols-container"],
  [_e.RIGHT, "ag-pinned-right-cols-container"],
  [_e.FULL_WIDTH, "ag-full-width-container"],
  [_e.TOP_CENTER, "ag-floating-top-container"],
  [_e.TOP_LEFT, "ag-pinned-left-floating-top"],
  [_e.TOP_RIGHT, "ag-pinned-right-floating-top"],
  [_e.TOP_FULL_WIDTH, "ag-floating-top-full-width-container"],
  [_e.BOTTOM_CENTER, "ag-floating-bottom-container"],
  [_e.BOTTOM_LEFT, "ag-pinned-left-floating-bottom"],
  [_e.BOTTOM_RIGHT, "ag-pinned-right-floating-bottom"],
  [_e.BOTTOM_FULL_WIDTH, "ag-floating-bottom-full-width-container"]
]), uY = Wc([
  [_e.CENTER, "ag-center-cols-viewport"],
  [_e.TOP_CENTER, "ag-floating-top-viewport"],
  [_e.BOTTOM_CENTER, "ag-floating-bottom-viewport"]
]), cY = Wc([
  [_e.CENTER, "ag-center-cols-clipper"]
]), Gw = (
  /** @class */
  function(n) {
    oY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.name = t, i;
    }
    return e.getRowContainerCssClasses = function(t) {
      var i = lY.get(t), r = uY.get(t), o = cY.get(t);
      return { container: i, viewport: r, wrapper: o };
    }, e.getPinned = function(t) {
      switch (t) {
        case _e.BOTTOM_LEFT:
        case _e.TOP_LEFT:
        case _e.LEFT:
          return q.PINNED_LEFT;
        case _e.BOTTOM_RIGHT:
        case _e.TOP_RIGHT:
        case _e.RIGHT:
          return q.PINNED_RIGHT;
        default:
          return null;
      }
    }, e.prototype.postConstruct = function() {
      var t = this;
      this.enableRtl = this.gridOptionsWrapper.isEnableRtl(), this.embedFullWidthRows = this.gridOptionsWrapper.isEmbedFullWidthRows(), this.addManagedListener(this.eventService, I.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_ROWS_CHANGED, this.onDisplayedRowsChanged.bind(this)), this.forContainers([_e.CENTER], function() {
        return t.viewportSizeFeature = t.createManagedBean(new Yq(t));
      }), this.registerWithCtrlsService();
    }, e.prototype.registerWithCtrlsService = function() {
      switch (this.name) {
        case _e.CENTER:
          this.ctrlsService.registerCenterRowContainerCtrl(this);
          break;
        case _e.LEFT:
          this.ctrlsService.registerLeftRowContainerCtrl(this);
          break;
        case _e.RIGHT:
          this.ctrlsService.registerRightRowContainerCtrl(this);
          break;
        case _e.TOP_CENTER:
          this.ctrlsService.registerTopCenterRowContainerCtrl(this);
          break;
        case _e.TOP_LEFT:
          this.ctrlsService.registerTopLeftRowContainerCon(this);
          break;
        case _e.TOP_RIGHT:
          this.ctrlsService.registerTopRightRowContainerCtrl(this);
          break;
        case _e.BOTTOM_CENTER:
          this.ctrlsService.registerBottomCenterRowContainerCtrl(this);
          break;
        case _e.BOTTOM_LEFT:
          this.ctrlsService.registerBottomLeftRowContainerCtrl(this);
          break;
        case _e.BOTTOM_RIGHT:
          this.ctrlsService.registerBottomRightRowContainerCtrl(this);
          break;
      }
    }, e.prototype.forContainers = function(t, i) {
      t.indexOf(this.name) >= 0 && i();
    }, e.prototype.getContainerElement = function() {
      return this.eContainer;
    }, e.prototype.getViewportSizeFeature = function() {
      return this.viewportSizeFeature;
    }, e.prototype.setComp = function(t, i, r, o) {
      var s = this;
      this.comp = t, this.eContainer = i, this.eViewport = r, this.eWrapper = o, this.createManagedBean(new Kq(this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder(), this.stopHScrollOnPinnedRows();
      var a = [_e.TOP_CENTER, _e.TOP_LEFT, _e.TOP_RIGHT], l = [_e.BOTTOM_CENTER, _e.BOTTOM_LEFT, _e.BOTTOM_RIGHT], u = [_e.CENTER, _e.LEFT, _e.RIGHT], c = aY(a, l, u), h = [_e.CENTER, _e.LEFT, _e.RIGHT, _e.FULL_WIDTH], d = [_e.CENTER, _e.TOP_CENTER, _e.BOTTOM_CENTER], f = [_e.LEFT, _e.BOTTOM_LEFT, _e.TOP_LEFT], p = [_e.RIGHT, _e.BOTTOM_RIGHT, _e.TOP_RIGHT];
      this.forContainers(f, function() {
        return s.createManagedBean(new Zq(s.eContainer));
      }), this.forContainers(p, function() {
        return s.createManagedBean(new Jq(s.eContainer));
      }), this.forContainers(h, function() {
        return s.createManagedBean(new tY(s.eContainer, s.eWrapper));
      }), this.forContainers(c, function() {
        return s.createManagedBean(new nY(s.eContainer));
      }), this.forContainers(d, function() {
        return s.createManagedBean(new yx(function(g) {
          return s.comp.setContainerWidth(g + "px");
        }));
      });
    }, e.prototype.listenOnDomOrder = function() {
      var t = this, i = function() {
        return t.comp.setDomOrder(t.gridOptionsWrapper.isEnsureDomOrder());
      };
      this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_DOM_LAYOUT, i), i();
    }, e.prototype.stopHScrollOnPinnedRows = function() {
      var t = this;
      this.forContainers([_e.TOP_CENTER, _e.BOTTOM_CENTER], function() {
        var i = function() {
          return t.eViewport.scrollLeft = 0;
        };
        t.addManagedListener(t.eViewport, "scroll", i);
      });
    }, e.prototype.onDisplayedColumnsChanged = function() {
      var t = this;
      this.forContainers([_e.CENTER], function() {
        return t.onHorizontalViewportChanged();
      });
    }, e.prototype.onDisplayedColumnsWidthChanged = function() {
      var t = this;
      this.forContainers([_e.CENTER], function() {
        return t.onHorizontalViewportChanged();
      });
    }, e.prototype.onScrollVisibilityChanged = function() {
      if (this.name === _e.CENTER) {
        var t = this.scrollVisibleService.isHorizontalScrollShowing(), i = t && this.gridOptionsWrapper.getScrollbarWidth() || 0, r = i == 0 ? "100%" : "calc(100% + " + i + "px)";
        this.comp.setViewportHeight(r);
      }
    }, e.prototype.addPreventScrollWhileDragging = function() {
      var t = this, i = function(r) {
        t.dragService.isDragging() && r.cancelable && r.preventDefault();
      };
      this.eContainer.addEventListener("touchmove", i, { passive: !1 }), this.addDestroyFunc(function() {
        return t.eContainer.removeEventListener("touchmove", i);
      });
    }, e.prototype.onHorizontalViewportChanged = function() {
      var t = this.getCenterWidth(), i = this.getCenterViewportScrollLeft();
      this.columnModel.setViewportPosition(t, i);
    }, e.prototype.getCenterWidth = function() {
      return wS(this.eViewport);
    }, e.prototype.getCenterViewportScrollLeft = function() {
      return Mv(this.eViewport, this.enableRtl);
    }, e.prototype.registerViewportResizeListener = function(t) {
      var i = this.resizeObserverService.observeResize(this.eViewport, t);
      this.addDestroyFunc(function() {
        return i();
      });
    }, e.prototype.isViewportVisible = function() {
      return hg(this.eViewport);
    }, e.prototype.isViewportHScrollShowing = function() {
      return O1(this.eViewport);
    }, e.prototype.getViewportScrollLeft = function() {
      return Mv(this.eViewport, this.enableRtl);
    }, e.prototype.isHorizontalScrollShowing = function() {
      var t = this.gridOptionsWrapper.isAlwaysShowHorizontalScroll();
      return t || O1(this.eViewport);
    }, e.prototype.getViewportElement = function() {
      return this.eViewport;
    }, e.prototype.setContainerTranslateX = function(t) {
      this.eContainer.style.transform = "translateX(" + t + "px)";
    }, e.prototype.getHScrollPosition = function() {
      var t = {
        left: this.eViewport.scrollLeft,
        right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
      };
      return t;
    }, e.prototype.setCenterViewportScrollLeft = function(t) {
      Aw(this.eViewport, t, this.enableRtl);
    }, e.prototype.onDisplayedRowsChanged = function() {
      var t = this, i = this.name === _e.TOP_FULL_WIDTH || this.name === _e.BOTTOM_FULL_WIDTH || this.name === _e.FULL_WIDTH, r = function(a) {
        var l = a.isFullWidth(), u = t.gridOptionsWrapper.getDomLayout() === q.DOM_LAYOUT_PRINT, c = t.embedFullWidthRows || u, h = i ? !c && l : c || !l;
        return h;
      }, o = this.getRowCtrls(), s = o.filter(r);
      this.comp.setRowCtrls(s);
    }, e.prototype.getRowCtrls = function() {
      switch (this.name) {
        case _e.TOP_CENTER:
        case _e.TOP_LEFT:
        case _e.TOP_RIGHT:
        case _e.TOP_FULL_WIDTH:
          return this.rowRenderer.getTopRowCtrls();
        case _e.BOTTOM_CENTER:
        case _e.BOTTOM_LEFT:
        case _e.BOTTOM_RIGHT:
        case _e.BOTTOM_FULL_WIDTH:
          return this.rowRenderer.getBottomRowCtrls();
        default:
          return this.rowRenderer.getRowCtrls();
      }
    }, xh([
      R("scrollVisibleService")
    ], e.prototype, "scrollVisibleService", void 0), xh([
      R("dragService")
    ], e.prototype, "dragService", void 0), xh([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), xh([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), xh([
      R("resizeObserverService")
    ], e.prototype, "resizeObserverService", void 0), xh([
      R("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), xh([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var hY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), dY = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, fY = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(dY(arguments[e]));
  return n;
}, Mo;
(function(n) {
  n.Normal = "Normal", n.FullWidth = "FullWidth", n.FullWidthLoading = "FullWidthLoading", n.FullWidthGroup = "FullWidthGroup", n.FullWidthDetail = "FullWidthDetail";
})(Mo || (Mo = {}));
var pY = 0, $c = (
  /** @class */
  function(n) {
    hY(e, n);
    function e(t, i, r, o, s, a) {
      var l = n.call(this) || this;
      return l.allRowGuis = [], l.active = !0, l.centerCellCtrls = { list: [], map: {} }, l.leftCellCtrls = { list: [], map: {} }, l.rightCellCtrls = { list: [], map: {} }, l.lastMouseDownOnDragger = !1, l.updateColumnListsPending = !1, l.parentScope = t, l.beans = r, l.rowNode = i, l.paginationPage = l.beans.paginationProxy.getCurrentPage(), l.useAnimationFrameForCreate = s, l.printLayout = a, l.instanceId = i.id + "-" + pY++, l.setAnimateFlags(o), l.rowFocused = l.beans.focusService.isRowFocused(l.rowNode.rowIndex, l.rowNode.rowPinned), l.setupAngular1Scope(), l.rowLevel = l.beans.rowCssClassCalculator.calculateRowLevel(l.rowNode), l.setRowType(), l.addListeners(), l.setInitialRowTop(), l;
    }
    return e.prototype.getBeans = function() {
      return this.beans;
    }, e.prototype.getInstanceId = function() {
      return this.instanceId;
    }, e.prototype.setComp = function(t, i, r) {
      var o = { rowComp: t, element: i, containerType: r };
      this.allRowGuis.push(o), r === Fo.LEFT ? this.leftGui = o : r === Fo.RIGHT ? this.rightGui = o : r === Fo.FULL_WIDTH ? this.fullWidthGui = o : this.centerGui = o;
      var s = this.leftGui != null && this.rightGui != null && this.centerGui != null, a = this.fullWidthGui != null;
      (s || a) && this.initialiseRowComps();
    }, e.prototype.isCacheable = function() {
      return this.rowType === Mo.FullWidthDetail && this.beans.gridOptionsWrapper.isKeepDetailRows();
    }, e.prototype.setCached = function(t) {
      var i = t ? "none" : "";
      this.allRowGuis.forEach(function(r) {
        return r.element.style.display = i;
      });
    }, e.prototype.initialiseRowComps = function() {
      var t = this, i = this.beans.gridOptionsWrapper;
      this.onRowHeightChanged(), this.updateRowIndexes(), this.setFocusedClasses(), this.setStylesFromGridOptions(), i.isRowSelection() && this.rowNode.selectable && this.onRowSelected(), this.updateColumnLists(!this.useAnimationFrameForCreate), this.slideRowIn && _1(this.onTopChanged.bind(this)), this.fadeRowIn && _1(function() {
        t.allRowGuis.forEach(function(a) {
          return a.rowComp.addOrRemoveCssClass("ag-opacity-zero", !1);
        });
      });
      var r = this.getRowBusinessKey(), o = Gl(this.rowNode.id), s = Gl(r);
      this.allRowGuis.forEach(function(a) {
        var l = a.rowComp;
        l.setRole("row");
        var u = t.getInitialRowClasses(a.containerType);
        u.forEach(function(c) {
          return l.addOrRemoveCssClass(c, !0);
        }), t.rowNode.group && _s(a.element, t.rowNode.expanded == !0), o != null && l.setRowId(o), s != null && l.setRowBusinessKey(s), t.isFullWidth() && !t.beans.gridOptionsWrapper.isSuppressCellFocus() && l.setTabIndex(-1), i.setDomData(a.element, e.DOM_DATA_KEY_ROW_CTRL, t), t.addDestroyFunc(function() {
          return i.setDomData(a.element, e.DOM_DATA_KEY_ROW_CTRL, null);
        }), t.useAnimationFrameForCreate ? t.beans.animationFrameService.createTask(t.addHoverFunctionality.bind(t, a.element), t.rowNode.rowIndex, "createTasksP2") : t.addHoverFunctionality(a.element), t.isFullWidth() && t.setupFullWidth(a), i.isRowDragEntireRow() && t.addRowDraggerToRow(a), t.useAnimationFrameForCreate && t.beans.animationFrameService.addDestroyTask(function() {
          t.isAlive() && a.rowComp.addOrRemoveCssClass("ag-after-created", !0);
        });
      }), this.executeProcessRowPostCreateFunc();
    }, e.prototype.addRowDraggerToRow = function(t) {
      var i = this.beans.gridOptionsWrapper;
      if (i.isEnableRangeSelection()) {
        mi(function() {
          console.warn("AG Grid: Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `enableRangeSelection: true`");
        }, "rowDragAndRangeSelectionEnabled");
        return;
      }
      var r = new Vw(function() {
        return "1 row";
      }, this.rowNode, void 0, t.element, void 0, !0);
      this.createManagedBean(r, this.beans.context);
    }, e.prototype.setupFullWidth = function(t) {
      var i = this.getPinnedForContainer(t.containerType), r = this.createFullWidthParams(t.element, i), o = pt.isRegistered(ct.MasterDetailModule);
      if (this.rowType == Mo.FullWidthDetail && !o) {
        pt.isPackageBased() ? console.warn("AG Grid: cell renderer 'agDetailCellRenderer' (for master detail) not found. Can only be used with ag-grid-enterprise package.") : console.warn("AG Grid: cell renderer 'agDetailCellRenderer' (for master detail) not found. Can only be used with AG Grid Enterprise Module " + ct.MasterDetailModule);
        return;
      }
      var s;
      switch (this.rowType) {
        case Mo.FullWidthDetail:
          s = this.beans.userComponentFactory.getFullWidthDetailCellRendererDetails(r);
          break;
        case Mo.FullWidthGroup:
          s = this.beans.userComponentFactory.getFullWidthGroupCellRendererDetails(r);
          break;
        case Mo.FullWidthLoading:
          s = this.beans.userComponentFactory.getFullWidthLoadingCellRendererDetails(r);
          break;
        default:
          s = this.beans.userComponentFactory.getFullWidthCellRendererDetails(r);
          break;
      }
      t.rowComp.showFullWidth(s);
    }, e.prototype.getScope = function() {
      return this.scope;
    }, e.prototype.isPrintLayout = function() {
      return this.printLayout;
    }, e.prototype.setupAngular1Scope = function() {
      var t = zq.createChildScopeOrNull(this.rowNode, this.parentScope, this.beans.gridOptionsWrapper);
      t && (this.scope = t.scope, this.addDestroyFunc(t.scopeDestroyFunc));
    }, e.prototype.getCellElement = function(t) {
      var i = this.getCellCtrl(t);
      return i ? i.getGui() : null;
    }, e.prototype.executeProcessRowPostCreateFunc = function() {
      var t = this.beans.gridOptionsWrapper.getProcessRowPostCreateFunc();
      if (t) {
        var i = {
          eRow: this.centerGui ? this.centerGui.element : void 0,
          ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
          ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
          node: this.rowNode,
          api: this.beans.gridOptionsWrapper.getApi(),
          rowIndex: this.rowNode.rowIndex,
          addRenderedRowListener: this.addEventListener.bind(this),
          columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
          context: this.beans.gridOptionsWrapper.getContext()
        };
        t(i);
      }
    }, e.prototype.setRowType = function() {
      var t = this.rowNode.stub, i = this.rowNode.isFullWidthCell(), r = this.beans.doingMasterDetail && this.rowNode.detail, o = this.beans.columnModel.isPivotMode(), s = !!this.rowNode.group && !this.rowNode.footer, a = s && this.beans.gridOptionsWrapper.isGroupUseEntireRow(o);
      t ? this.rowType = Mo.FullWidthLoading : r ? this.rowType = Mo.FullWidthDetail : i ? this.rowType = Mo.FullWidth : a ? this.rowType = Mo.FullWidthGroup : this.rowType = Mo.Normal;
    }, e.prototype.updateColumnLists = function(t) {
      var i = this;
      if (t === void 0 && (t = !1), !this.isFullWidth()) {
        var r = t || this.beans.gridOptionsWrapper.isSuppressAnimationFrame() || this.printLayout;
        if (r) {
          this.updateColumnListsImpl();
          return;
        }
        this.updateColumnListsPending || (this.beans.animationFrameService.createTask(function() {
          i.active && i.updateColumnListsImpl();
        }, this.rowNode.rowIndex, "createTasksP1"), this.updateColumnListsPending = !0);
      }
    }, e.prototype.createCellCtrls = function(t, i, r) {
      var o = this;
      r === void 0 && (r = null);
      var s = {
        list: [],
        map: {}
      }, a = function(l, u) {
        s.list.push(u), s.map[l] = u;
      };
      return i.forEach(function(l) {
        var u = l.getInstanceId(), c = t.map[u];
        c || (c = new jc(l, o.rowNode, o.beans, o)), a(u, c);
      }), t.list.forEach(function(l) {
        var u = s.map[l.getColumn().getInstanceId()] != null;
        if (!u) {
          var c = !o.isCellEligibleToBeRemoved(l, r);
          if (c) {
            a(l.getColumn().getInstanceId(), l);
            return;
          }
          l.destroy();
        }
      }), s;
    }, e.prototype.updateColumnListsImpl = function() {
      var t = this;
      this.updateColumnListsPending = !1;
      var i = this.beans.columnModel;
      if (this.printLayout)
        this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, i.getAllDisplayedColumns()), this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} };
      else {
        var r = i.getViewportCenterColumnsForRow(this.rowNode);
        this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, r);
        var o = i.getDisplayedLeftColumnsForRow(this.rowNode);
        this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, o, q.PINNED_LEFT);
        var s = i.getDisplayedRightColumnsForRow(this.rowNode);
        this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, s, q.PINNED_RIGHT);
      }
      this.allRowGuis.forEach(function(a) {
        var l = a.containerType === Fo.LEFT ? t.leftCellCtrls : a.containerType === Fo.RIGHT ? t.rightCellCtrls : t.centerCellCtrls;
        a.rowComp.setCellCtrls(l.list);
      });
    }, e.prototype.isCellEligibleToBeRemoved = function(t, i) {
      var r = !0, o = !1, s = t.getColumn();
      if (s.getPinned() != i)
        return r;
      var a = t.isEditing(), l = this.beans.focusService.isCellFocused(t.getCellPosition()), u = a || l;
      if (u) {
        var c = t.getColumn(), h = this.beans.columnModel.getAllDisplayedColumns(), d = h.indexOf(c) >= 0;
        return d ? o : r;
      }
      return r;
    }, e.prototype.setAnimateFlags = function(t) {
      if (t) {
        var i = de(this.rowNode.oldRowTop);
        this.slideRowIn = i, this.fadeRowIn = !i;
      } else
        this.slideRowIn = !1, this.fadeRowIn = !1;
    }, e.prototype.isEditing = function() {
      return this.editingRow;
    }, e.prototype.stopRowEditing = function(t) {
      this.stopEditing(t);
    }, e.prototype.isFullWidth = function() {
      return this.rowType !== Mo.Normal;
    }, e.prototype.getRowType = function() {
      return this.rowType;
    }, e.prototype.refreshFullWidth = function() {
      var t = this, i = function(u, c) {
        if (!u)
          return !0;
        var h = u.rowComp.getFullWidthCellRenderer();
        if (!h || !h.refresh)
          return !1;
        var d = t.createFullWidthParams(u.element, c), f = h.refresh(d);
        return f;
      }, r = i(this.fullWidthGui, null), o = i(this.centerGui, null), s = i(this.leftGui, q.PINNED_LEFT), a = i(this.rightGui, q.PINNED_RIGHT), l = r && o && s && a;
      return l;
    }, e.prototype.addListeners = function() {
      this.addManagedListener(this.rowNode, kt.EVENT_HEIGHT_CHANGED, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_ROW_SELECTED, this.onRowSelected.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_ROW_INDEX_CHANGED, this.onRowIndexChanged.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_TOP_CHANGED, this.onTopChanged.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_EXPANDED_CHANGED, this.updateExpandedCss.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_HAS_CHILDREN_CHANGED, this.updateExpandedCss.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_DATA_CHANGED, this.onRowNodeDataChanged.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_CELL_CHANGED, this.onRowNodeCellChanged.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_HIGHLIGHT_CHANGED, this.onRowNodeHighlightChanged.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_DRAGGING_CHANGED, this.onRowNodeDraggingChanged.bind(this)), this.addManagedListener(this.rowNode, kt.EVENT_UI_LEVEL_CHANGED, this.onUiLevelChanged.bind(this));
      var t = this.beans.eventService;
      this.addManagedListener(t, I.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED, this.onPaginationPixelOffsetChanged.bind(this)), this.addManagedListener(t, I.EVENT_HEIGHT_SCALE_CHANGED, this.onTopChanged.bind(this)), this.addManagedListener(t, I.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(t, I.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this)), this.addManagedListener(t, I.EVENT_CELL_FOCUSED, this.onCellFocusChanged.bind(this)), this.addManagedListener(t, I.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this)), this.addManagedListener(t, I.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this)), this.addManagedListener(t, I.EVENT_COLUMN_MOVED, this.onColumnMoved.bind(this)), this.addListenersForCellComps();
    }, e.prototype.onColumnMoved = function() {
      this.updateColumnLists();
    }, e.prototype.addListenersForCellComps = function() {
      var t = this;
      this.addManagedListener(this.rowNode, kt.EVENT_ROW_INDEX_CHANGED, function() {
        t.getAllCellCtrls().forEach(function(i) {
          return i.onRowIndexChanged();
        });
      }), this.addManagedListener(this.rowNode, kt.EVENT_CELL_CHANGED, function(i) {
        t.getAllCellCtrls().forEach(function(r) {
          return r.onCellChanged(i);
        });
      });
    }, e.prototype.onRowNodeDataChanged = function(t) {
      this.getAllCellCtrls().forEach(function(i) {
        return i.refreshCell({
          suppressFlash: !t.update,
          newData: !t.update
        });
      }), this.onRowSelected(), this.postProcessCss();
    }, e.prototype.onRowNodeCellChanged = function() {
      this.postProcessCss();
    }, e.prototype.postProcessCss = function() {
      this.setStylesFromGridOptions(), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), this.postProcessRowDragging();
    }, e.prototype.onRowNodeHighlightChanged = function() {
      var t = this.rowNode.highlighted;
      this.allRowGuis.forEach(function(i) {
        var r = t === Ed.Above, o = t === Ed.Below;
        i.rowComp.addOrRemoveCssClass("ag-row-highlight-above", r), i.rowComp.addOrRemoveCssClass("ag-row-highlight-below", o);
      });
    }, e.prototype.onRowNodeDraggingChanged = function() {
      this.postProcessRowDragging();
    }, e.prototype.postProcessRowDragging = function() {
      var t = this.rowNode.dragging;
      this.allRowGuis.forEach(function(i) {
        return i.rowComp.addOrRemoveCssClass("ag-row-dragging", t);
      });
    }, e.prototype.updateExpandedCss = function() {
      var t = this.rowNode.isExpandable(), i = this.rowNode.expanded == !0;
      this.allRowGuis.forEach(function(r) {
        r.rowComp.addOrRemoveCssClass("ag-row-group", t), r.rowComp.addOrRemoveCssClass("ag-row-group-expanded", t && i), r.rowComp.addOrRemoveCssClass("ag-row-group-contracted", t && !i), _s(r.element, t && i);
      });
    }, e.prototype.onDisplayedColumnsChanged = function() {
      this.updateColumnLists(!0), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights();
    }, e.prototype.onVirtualColumnsChanged = function() {
      this.updateColumnLists();
    }, e.prototype.getRowPosition = function() {
      return {
        rowPinned: this.rowNode.rowPinned,
        rowIndex: this.rowNode.rowIndex
      };
    }, e.prototype.onKeyboardNavigate = function(t) {
      var i = this.allRowGuis.find(function(u) {
        return u.element.contains(t.target);
      }), r = i ? i.element : null, o = r === t.target;
      if (o) {
        var s = this.rowNode, a = this.beans.focusService.getFocusedCell(), l = {
          rowIndex: s.rowIndex,
          rowPinned: s.rowPinned,
          column: a && a.column
        };
        this.beans.navigationService.navigateToNextCell(t, t.key, l, !0), t.preventDefault();
      }
    }, e.prototype.onTabKeyDown = function(t) {
      if (!(t.defaultPrevented || Ml(t))) {
        var i = this.allRowGuis.find(function(a) {
          return a.element.contains(t.target);
        }), r = i ? i.element : null, o = r === t.target, s = null;
        o || (s = this.beans.focusService.findNextFocusableElement(r, !1, t.shiftKey)), (this.isFullWidth() && o || !s) && this.beans.navigationService.onTabKeyDown(this, t);
      }
    }, e.prototype.onFullWidthRowFocused = function(t) {
      var i, r = this.rowNode, o = this.isFullWidth() && t.rowIndex === r.rowIndex && t.rowPinned == r.rowPinned, s = this.fullWidthGui ? this.fullWidthGui.element : (i = this.centerGui) === null || i === void 0 ? void 0 : i.element;
      s && (s.classList.toggle("ag-full-width-focus", o), o && s.focus({ preventScroll: !0 }));
    }, e.prototype.refreshCell = function(t) {
      this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, t), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, t), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, t), this.updateColumnLists();
    }, e.prototype.removeCellCtrl = function(t, i) {
      var r = {
        list: [],
        map: {}
      };
      return t.list.forEach(function(o) {
        o !== i && (r.list.push(o), r.map[o.getInstanceId()] = o);
      }), r;
    }, e.prototype.onMouseEvent = function(t, i) {
      switch (t) {
        case "dblclick":
          this.onRowDblClick(i);
          break;
        case "click":
          this.onRowClick(i);
          break;
        case "touchstart":
        case "mousedown":
          this.onRowMouseDown(i);
          break;
      }
    }, e.prototype.createRowEvent = function(t, i) {
      return {
        type: t,
        node: this.rowNode,
        data: this.rowNode.data,
        rowIndex: this.rowNode.rowIndex,
        rowPinned: this.rowNode.rowPinned,
        context: this.beans.gridOptionsWrapper.getContext(),
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        event: i
      };
    }, e.prototype.createRowEventWithSource = function(t, i) {
      var r = this.createRowEvent(t, i);
      return r.source = this, r;
    }, e.prototype.onRowDblClick = function(t) {
      if (!Ml(t)) {
        var i = this.createRowEventWithSource(I.EVENT_ROW_DOUBLE_CLICKED, t);
        this.beans.eventService.dispatchEvent(i);
      }
    }, e.prototype.onRowMouseDown = function(t) {
      if (this.lastMouseDownOnDragger = yS(t.target, "ag-row-drag", 3), !!this.isFullWidth()) {
        var i = this.rowNode, r = this.beans.columnModel;
        this.beans.focusService.setFocusedCell(i.rowIndex, r.getAllDisplayedColumns()[0], i.rowPinned, !0);
      }
    }, e.prototype.onRowClick = function(t) {
      var i = Ml(t) || this.lastMouseDownOnDragger;
      if (!i) {
        var r = this.createRowEventWithSource(I.EVENT_ROW_CLICKED, t);
        this.beans.eventService.dispatchEvent(r);
        var o = t.ctrlKey || t.metaKey, s = t.shiftKey, a = this.beans.gridOptionsWrapper.isGroupSelectsChildren();
        if (
          // we do not allow selecting groups by clicking (as the click here expands the group), or if it's a detail row,
          // so return if it's a group row
          !(a && this.rowNode.group || // this is needed so we don't unselect other rows when we click this row, eg if this row is not selectable,
          // and we click it, the selection should not change (ie any currently selected row should stay selected)
          !this.rowNode.selectable || // we also don't allow selection of pinned rows
          this.rowNode.rowPinned || // if no selection method enabled, do nothing
          !this.beans.gridOptionsWrapper.isRowSelection() || // if click selection suppressed, do nothing
          this.beans.gridOptionsWrapper.isSuppressRowClickSelection())
        ) {
          var l = this.beans.gridOptionsWrapper.isRowMultiSelectWithClick(), u = !this.beans.gridOptionsWrapper.isSuppressRowDeselection();
          if (this.rowNode.isSelected())
            l ? this.rowNode.setSelectedParams({ newValue: !1 }) : o ? u && this.rowNode.setSelectedParams({ newValue: !1 }) : this.rowNode.setSelectedParams({ newValue: !s, clearSelection: !s, rangeSelect: s });
          else {
            var c = l ? !1 : !o;
            this.rowNode.setSelectedParams({ newValue: !0, clearSelection: c, rangeSelect: s });
          }
        }
      }
    }, e.prototype.setupDetailRowAutoHeight = function(t) {
      var i = this;
      if (this.rowType === Mo.FullWidthDetail && this.beans.gridOptionsWrapper.isDetailRowAutoHeight()) {
        var r = function() {
          var s = t.clientHeight;
          if (s != null && s > 0) {
            var a = function() {
              i.rowNode.setRowHeight(s), i.beans.clientSideRowModel ? i.beans.clientSideRowModel.onRowHeightChanged() : i.beans.serverSideRowModel && i.beans.serverSideRowModel.onRowHeightChanged();
            };
            i.beans.frameworkOverrides.setTimeout(a, 0);
          }
        }, o = this.beans.resizeObserverService.observeResize(t, r);
        this.addDestroyFunc(o), r();
      }
    }, e.prototype.createFullWidthParams = function(t, i) {
      var r = this, o = {
        fullWidth: !0,
        data: this.rowNode.data,
        node: this.rowNode,
        value: this.rowNode.key,
        valueFormatted: this.rowNode.key,
        $scope: this.scope ? this.scope : this.parentScope,
        $compile: this.beans.$compile,
        rowIndex: this.rowNode.rowIndex,
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        context: this.beans.gridOptionsWrapper.getContext(),
        // these need to be taken out, as part of 'afterAttached' now
        eGridCell: t,
        eParentOfValue: t,
        pinned: i,
        addRenderedRowListener: this.addEventListener.bind(this),
        registerRowDragger: function(s, a, l, u) {
          return r.addFullWidthRowDragging(s, a, l, u);
        }
      };
      return o;
    }, e.prototype.addFullWidthRowDragging = function(t, i, r, o) {
      if (r === void 0 && (r = ""), !!this.isFullWidth()) {
        var s = new Vw(function() {
          return r;
        }, this.rowNode, void 0, t, i, o);
        this.createManagedBean(s, this.beans.context);
      }
    }, e.prototype.onUiLevelChanged = function() {
      var t = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
      if (this.rowLevel != t) {
        var i = "ag-row-level-" + t, r = "ag-row-level-" + this.rowLevel;
        this.allRowGuis.forEach(function(o) {
          o.rowComp.addOrRemoveCssClass(i, !0), o.rowComp.addOrRemoveCssClass(r, !1);
        });
      }
      this.rowLevel = t;
    }, e.prototype.isFirstRowOnPage = function() {
      return this.rowNode.rowIndex === this.beans.paginationProxy.getPageFirstRow();
    }, e.prototype.isLastRowOnPage = function() {
      return this.rowNode.rowIndex === this.beans.paginationProxy.getPageLastRow();
    }, e.prototype.onModelUpdated = function() {
      this.refreshFirstAndLastRowStyles();
    }, e.prototype.refreshFirstAndLastRowStyles = function() {
      var t = this.isFirstRowOnPage(), i = this.isLastRowOnPage();
      this.firstRowOnPage !== t && (this.firstRowOnPage = t, this.allRowGuis.forEach(function(r) {
        return r.rowComp.addOrRemoveCssClass("ag-row-first", t);
      })), this.lastRowOnPage !== i && (this.lastRowOnPage = i, this.allRowGuis.forEach(function(r) {
        return r.rowComp.addOrRemoveCssClass("ag-row-last", i);
      }));
    }, e.prototype.stopEditing = function(t) {
      if (t === void 0 && (t = !1), this.getAllCellCtrls().forEach(function(r) {
        return r.stopEditing(t);
      }), !!this.editingRow) {
        if (!t) {
          var i = this.createRowEvent(I.EVENT_ROW_VALUE_CHANGED);
          this.beans.eventService.dispatchEvent(i);
        }
        this.setEditingRow(!1);
      }
    }, e.prototype.setInlineEditingCss = function(t) {
      this.allRowGuis.forEach(function(i) {
        i.rowComp.addOrRemoveCssClass("ag-row-inline-editing", t), i.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !t);
      });
    }, e.prototype.setEditingRow = function(t) {
      this.editingRow = t, this.allRowGuis.forEach(function(r) {
        return r.rowComp.addOrRemoveCssClass("ag-row-editing", t);
      });
      var i = t ? this.createRowEvent(I.EVENT_ROW_EDITING_STARTED) : this.createRowEvent(I.EVENT_ROW_EDITING_STOPPED);
      this.beans.eventService.dispatchEvent(i);
    }, e.prototype.startRowEditing = function(t, i, r, o) {
      t === void 0 && (t = null), i === void 0 && (i = null), r === void 0 && (r = null), o === void 0 && (o = null), !this.editingRow && (this.getAllCellCtrls().forEach(function(s) {
        var a = s === r;
        a ? s.startEditing(t, i, a, o) : s.startEditing(null, null, a, o);
      }), this.setEditingRow(!0));
    }, e.prototype.getAllCellCtrls = function() {
      var t = fY(this.centerCellCtrls.list, this.leftCellCtrls.list, this.rightCellCtrls.list);
      return t;
    }, e.prototype.postProcessClassesFromGridOptions = function() {
      var t = this, i = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode, this.scope);
      !i || !i.length || i.forEach(function(r) {
        t.allRowGuis.forEach(function(o) {
          return o.rowComp.addOrRemoveCssClass(r, !0);
        });
      });
    }, e.prototype.postProcessRowClassRules = function() {
      var t = this;
      this.beans.rowCssClassCalculator.processRowClassRules(this.rowNode, this.scope, function(i) {
        t.allRowGuis.forEach(function(r) {
          return r.rowComp.addOrRemoveCssClass(i, !0);
        });
      }, function(i) {
        t.allRowGuis.forEach(function(r) {
          return r.rowComp.addOrRemoveCssClass(i, !1);
        });
      });
    }, e.prototype.setStylesFromGridOptions = function() {
      var t = this.processStylesFromGridOptions();
      this.allRowGuis.forEach(function(i) {
        return i.rowComp.setUserStyles(t);
      });
    }, e.prototype.getRowBusinessKey = function() {
      var t = this.beans.gridOptionsWrapper.getBusinessKeyForNodeFunc();
      if (typeof t == "function")
        return t(this.rowNode);
    }, e.prototype.getPinnedForContainer = function(t) {
      var i = t === Fo.LEFT ? q.PINNED_LEFT : t === Fo.RIGHT ? q.PINNED_RIGHT : null;
      return i;
    }, e.prototype.getInitialRowClasses = function(t) {
      var i = this.getPinnedForContainer(t), r = {
        rowNode: this.rowNode,
        rowFocused: this.rowFocused,
        fadeRowIn: this.fadeRowIn,
        rowIsEven: this.rowNode.rowIndex % 2 === 0,
        rowLevel: this.rowLevel,
        fullWidthRow: this.isFullWidth(),
        firstRowOnPage: this.isFirstRowOnPage(),
        lastRowOnPage: this.isLastRowOnPage(),
        printLayout: this.printLayout,
        expandable: this.rowNode.isExpandable(),
        scope: this.scope,
        pinned: i
      };
      return this.beans.rowCssClassCalculator.getInitialRowClasses(r);
    }, e.prototype.processStylesFromGridOptions = function() {
      var t = this.beans.gridOptionsWrapper.getRowStyle();
      if (t && typeof t == "function") {
        console.warn("AG Grid: rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
        return;
      }
      var i = this.beans.gridOptionsWrapper.getRowStyleFunc(), r;
      if (i) {
        var o = {
          data: this.rowNode.data,
          node: this.rowNode,
          rowIndex: this.rowNode.rowIndex,
          $scope: this.scope,
          api: this.beans.gridOptionsWrapper.getApi(),
          columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
          context: this.beans.gridOptionsWrapper.getContext()
        };
        r = i(o);
      }
      return Object.assign({}, t, r);
    }, e.prototype.onRowSelected = function() {
      var t = this, i = this.rowNode.isSelected();
      this.allRowGuis.forEach(function(r) {
        r.rowComp.addOrRemoveCssClass("ag-row-selected", i), Fp(r.element, i ? !0 : void 0);
        var o = t.createAriaLabel();
        Ud(r.element, o ?? "");
      });
    }, e.prototype.createAriaLabel = function() {
      var t = this.rowNode.isSelected();
      if (!(t && this.beans.gridOptionsWrapper.isSuppressRowDeselection())) {
        var i = this.beans.gridOptionsWrapper.getLocaleTextFunc(), r = i(t ? "ariaRowDeselect" : "ariaRowSelect", "Press SPACE to " + (t ? "deselect" : "select") + " this row.");
        return r;
      }
    }, e.prototype.isUseAnimationFrameForCreate = function() {
      return this.useAnimationFrameForCreate;
    }, e.prototype.addHoverFunctionality = function(t) {
      var i = this;
      this.active && (this.addManagedListener(t, "mouseenter", function() {
        return i.rowNode.onMouseEnter();
      }), this.addManagedListener(t, "mouseleave", function() {
        return i.rowNode.onMouseLeave();
      }), this.addManagedListener(this.rowNode, kt.EVENT_MOUSE_ENTER, function() {
        i.beans.gridOptionsWrapper.isSuppressRowHoverHighlight() || t.classList.add("ag-row-hover");
      }), this.addManagedListener(this.rowNode, kt.EVENT_MOUSE_LEAVE, function() {
        t.classList.remove("ag-row-hover");
      }));
    }, e.prototype.roundRowTopToBounds = function(t) {
      var i = this.beans.ctrlsService.getGridBodyCtrl(), r = i.getScrollFeature().getVScrollPosition(), o = this.applyPaginationOffset(r.top, !0) - 100, s = this.applyPaginationOffset(r.bottom, !0) + 100;
      return Math.min(Math.max(o, t), s);
    }, e.prototype.getFrameworkOverrides = function() {
      return this.beans.frameworkOverrides;
    }, e.prototype.onRowHeightChanged = function() {
      if (this.rowNode.rowHeight != null) {
        var t = this.beans.gridOptionsWrapper.isGetRowHeightFunction(), i = this.rowNode.rowHeight, r = this.beans.gridOptionsWrapper.getDefaultRowHeight();
        this.allRowGuis.forEach(function(o) {
          o.element.style.height = i + "px", t && o.element.style.setProperty("--ag-row-height", Math.min(r, i) - 2 + "px");
        });
      }
    }, e.prototype.addEventListener = function(t, i) {
      (t === "renderedRowRemoved" || t === "rowRemoved") && (t = I.EVENT_VIRTUAL_ROW_REMOVED, console.warn("AG Grid: Since version 11, event renderedRowRemoved is now called " + I.EVENT_VIRTUAL_ROW_REMOVED)), n.prototype.addEventListener.call(this, t, i);
    }, e.prototype.removeEventListener = function(t, i) {
      (t === "renderedRowRemoved" || t === "rowRemoved") && (t = I.EVENT_VIRTUAL_ROW_REMOVED, console.warn("AG Grid: Since version 11, event renderedRowRemoved and rowRemoved is now called " + I.EVENT_VIRTUAL_ROW_REMOVED)), n.prototype.removeEventListener.call(this, t, i);
    }, e.prototype.destroyFirstPass = function() {
      this.active = !1, this.setupRemoveAnimation();
      var t = this.createRowEvent(I.EVENT_VIRTUAL_ROW_REMOVED);
      this.dispatchEvent(t), this.beans.eventService.dispatchEvent(t), n.prototype.destroy.call(this);
    }, e.prototype.setupRemoveAnimation = function() {
      var t = this.rowNode.rowTop != null;
      if (t) {
        var i = this.roundRowTopToBounds(this.rowNode.rowTop);
        this.setRowTop(i);
      } else
        this.allRowGuis.forEach(function(r) {
          return r.rowComp.addOrRemoveCssClass("ag-opacity-zero", !0);
        });
    }, e.prototype.destroySecondPass = function() {
      this.allRowGuis.length = 0;
      var t = function(i) {
        return i.list.forEach(function(r) {
          return r.destroy();
        }), { list: [], map: {} };
      };
      this.centerCellCtrls = t(this.centerCellCtrls), this.leftCellCtrls = t(this.leftCellCtrls), this.rightCellCtrls = t(this.rightCellCtrls);
    }, e.prototype.setFocusedClasses = function() {
      var t = this;
      this.allRowGuis.forEach(function(i) {
        i.rowComp.addOrRemoveCssClass("ag-row-focus", t.rowFocused), i.rowComp.addOrRemoveCssClass("ag-row-no-focus", !t.rowFocused);
      });
    }, e.prototype.onCellFocusChanged = function() {
      var t = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
      t !== this.rowFocused && (this.rowFocused = t, this.setFocusedClasses()), !t && this.editingRow && this.stopEditing(!1);
    }, e.prototype.onPaginationChanged = function() {
      var t = this.beans.paginationProxy.getCurrentPage();
      this.paginationPage !== t && (this.paginationPage = t, this.onTopChanged()), this.refreshFirstAndLastRowStyles();
    }, e.prototype.onTopChanged = function() {
      this.setRowTop(this.rowNode.rowTop);
    }, e.prototype.onPaginationPixelOffsetChanged = function() {
      this.onTopChanged();
    }, e.prototype.applyPaginationOffset = function(t, i) {
      if (i === void 0 && (i = !1), this.rowNode.isRowPinned())
        return t;
      var r = this.beans.paginationProxy.getPixelOffset(), o = i ? 1 : -1;
      return t + r * o;
    }, e.prototype.setRowTop = function(t) {
      if (!this.printLayout && de(t)) {
        var i = this.applyPaginationOffset(t), r = this.rowNode.isRowPinned() ? i : this.beans.rowContainerHeightService.getRealPixelPosition(i), o = r + "px";
        this.setRowTopStyle(o);
      }
    }, e.prototype.getInitialRowTop = function() {
      return this.initialTop;
    }, e.prototype.getInitialTransform = function() {
      return this.initialTransform;
    }, e.prototype.setInitialRowTop = function() {
      if (this.printLayout)
        return "";
      var t = this.slideRowIn ? this.roundRowTopToBounds(this.rowNode.oldRowTop) : this.rowNode.rowTop, i = this.applyPaginationOffset(t), r = this.rowNode.isRowPinned() ? i : this.beans.rowContainerHeightService.getRealPixelPosition(i), o = r + "px", s = this.beans.gridOptionsWrapper.isSuppressRowTransform();
      s ? this.initialTop = o : this.initialTransform = "translateY(" + o + ")";
    }, e.prototype.setRowTopStyle = function(t) {
      var i = this.beans.gridOptionsWrapper.isSuppressRowTransform();
      this.allRowGuis.forEach(function(r) {
        return i ? r.rowComp.setTop(t) : r.rowComp.setTransform("translateY(" + t + ")");
      });
    }, e.prototype.getRowNode = function() {
      return this.rowNode;
    }, e.prototype.getCellCtrl = function(t) {
      var i = null;
      return this.getAllCellCtrls().forEach(function(r) {
        r.getColumn() == t && (i = r);
      }), i != null || this.getAllCellCtrls().forEach(function(r) {
        r.getColSpanningList().indexOf(t) >= 0 && (i = r);
      }), i;
    }, e.prototype.onRowIndexChanged = function() {
      this.rowNode.rowIndex != null && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss());
    }, e.prototype.updateRowIndexes = function() {
      var t = this.rowNode.getRowIndexString(), i = this.beans.headerNavigationService.getHeaderRowCount(), r = this.rowNode.rowIndex % 2 === 0, o = i + this.rowNode.rowIndex + 1;
      this.allRowGuis.forEach(function(s) {
        s.rowComp.setRowIndex(t), s.rowComp.addOrRemoveCssClass("ag-row-even", r), s.rowComp.addOrRemoveCssClass("ag-row-odd", !r), sx(s.element, o);
      });
    }, e.prototype.getPinnedLeftRowElement = function() {
      return this.leftGui ? this.leftGui.element : void 0;
    }, e.prototype.getPinnedRightRowElement = function() {
      return this.rightGui ? this.rightGui.element : void 0;
    }, e.prototype.getBodyRowElement = function() {
      return this.centerGui ? this.centerGui.element : void 0;
    }, e.prototype.getFullWidthRowElement = function() {
      return this.fullWidthGui ? this.fullWidthGui.element : void 0;
    }, e.DOM_DATA_KEY_ROW_CTRL = "renderedRow", e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), is = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, mY = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, yM = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(mY(arguments[e]));
  return n;
}, uH = (
  /** @class */
  function(n) {
    gY(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.destroyFuncsForColumnListeners = [], t.rowCtrlsByRowIndex = {}, t.zombieRowCtrls = {}, t.allRowCtrls = [], t.topRowCtrls = [], t.bottomRowCtrls = [], t.refreshInProgress = !1, t;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function() {
        t.gridBodyCtrl = t.ctrlsService.getGridBodyCtrl(), t.initialise();
      });
    }, e.prototype.initialise = function() {
      this.addManagedListener(this.eventService, I.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this)), this.addManagedListener(this.eventService, I.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_BODY_SCROLL, this.redrawAfterScroll.bind(this)), this.addManagedListener(this.eventService, I.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this)), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this)), this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = this.gridOptionsWrapper.getDomLayout() === q.DOM_LAYOUT_PRINT, this.embedFullWidthRows = this.printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows(), this.redrawAfterModelUpdate();
    }, e.prototype.initialiseCache = function() {
      if (this.gridOptionsWrapper.isKeepDetailRows()) {
        var t = this.gridOptionsWrapper.getKeepDetailRowsCount(), i = t ?? 3;
        this.cachedRowCtrls = new vY(i);
      }
    }, e.prototype.getRowCtrls = function() {
      return this.allRowCtrls;
    }, e.prototype.updateAllRowCtrls = function() {
      var t = Ya(this.rowCtrlsByRowIndex);
      this.gridOptionsWrapper.isEnsureDomOrder() && t.sort(function(o, s) {
        return o.getRowNode().rowIndex - s.getRowNode.rowIndex;
      });
      var i = Ya(this.zombieRowCtrls), r = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
      this.allRowCtrls = yM(t, i, r);
    }, e.prototype.registerCellEventListeners = function() {
      var t = this;
      this.addManagedListener(this.eventService, I.EVENT_CELL_FOCUSED, function(r) {
        t.getAllCellCtrls().forEach(function(o) {
          return o.onCellFocused(r);
        }), t.getFullWidthRowCtrls().forEach(function(o) {
          o.onFullWidthRowFocused(r);
        });
      }), this.addManagedListener(this.eventService, I.EVENT_FLASH_CELLS, function(r) {
        t.getAllCellCtrls().forEach(function(o) {
          return o.onFlashCells(r);
        });
      }), this.addManagedListener(this.eventService, I.EVENT_COLUMN_HOVER_CHANGED, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.onColumnHover();
        });
      }), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.onDisplayedColumnsChanged();
        });
      }), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, function() {
        t.printLayout && t.getAllCellCtrls().forEach(function(r) {
          return r.onLeftChanged();
        });
      });
      var i = this.gridOptionsWrapper.isEnableRangeSelection();
      i && (this.addManagedListener(this.eventService, I.EVENT_RANGE_SELECTION_CHANGED, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.onRangeSelectionChanged();
        });
      }), this.addManagedListener(this.eventService, I.EVENT_COLUMN_MOVED, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.updateRangeBordersIfRangeCount();
        });
      }), this.addManagedListener(this.eventService, I.EVENT_COLUMN_PINNED, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.updateRangeBordersIfRangeCount();
        });
      }), this.addManagedListener(this.eventService, I.EVENT_COLUMN_VISIBLE, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.updateRangeBordersIfRangeCount();
        });
      })), this.refreshListenersToColumnsForCellComps(), this.addManagedListener(this.eventService, I.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this)), this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
    }, e.prototype.removeGridColumnListeners = function() {
      this.destroyFuncsForColumnListeners.forEach(function(t) {
        return t();
      }), this.destroyFuncsForColumnListeners.length = 0;
    }, e.prototype.refreshListenersToColumnsForCellComps = function() {
      var t = this;
      this.removeGridColumnListeners();
      var i = this.columnModel.getAllGridColumns();
      i && i.forEach(function(r) {
        var o = function(c) {
          t.getAllCellCtrls().forEach(function(h) {
            h.getColumn() === r && c(h);
          });
        }, s = function() {
          o(function(c) {
            return c.onLeftChanged();
          });
        }, a = function() {
          o(function(c) {
            return c.onWidthChanged();
          });
        }, l = function() {
          o(function(c) {
            return c.onFirstRightPinnedChanged();
          });
        }, u = function() {
          o(function(c) {
            return c.onLastLeftPinnedChanged();
          });
        };
        r.addEventListener(Gt.EVENT_LEFT_CHANGED, s), r.addEventListener(Gt.EVENT_WIDTH_CHANGED, a), r.addEventListener(Gt.EVENT_FIRST_RIGHT_PINNED_CHANGED, l), r.addEventListener(Gt.EVENT_LAST_LEFT_PINNED_CHANGED, u), t.destroyFuncsForColumnListeners.push(function() {
          r.removeEventListener(Gt.EVENT_LEFT_CHANGED, s), r.removeEventListener(Gt.EVENT_WIDTH_CHANGED, a), r.removeEventListener(Gt.EVENT_FIRST_RIGHT_PINNED_CHANGED, l), r.removeEventListener(Gt.EVENT_LAST_LEFT_PINNED_CHANGED, u);
        });
      });
    }, e.prototype.onDomLayoutChanged = function() {
      var t = this.gridOptionsWrapper.getDomLayout() === q.DOM_LAYOUT_PRINT, i = t || this.gridOptionsWrapper.isEmbedFullWidthRows(), r = i !== this.embedFullWidthRows || this.printLayout !== t;
      this.printLayout = t, this.embedFullWidthRows = i, r && this.redrawAfterModelUpdate();
    }, e.prototype.datasourceChanged = function() {
      this.firstRenderedRow = 0, this.lastRenderedRow = -1;
      var t = Object.keys(this.rowCtrlsByRowIndex);
      this.removeRowCtrls(t);
    }, e.prototype.onPageLoaded = function(t) {
      var i = {
        recycleRows: t.keepRenderedRows,
        animate: t.animate,
        newData: t.newData,
        newPage: t.newPage,
        // because this is a model updated event (not pinned rows), we
        // can skip updating the pinned rows. this is needed so that if user
        // is doing transaction updates, the pinned rows are not getting constantly
        // trashed - or editing cells in pinned rows are not refreshed and put into read mode
        onlyBody: !0
      };
      this.redrawAfterModelUpdate(i);
    }, e.prototype.getAllCellsForColumn = function(t) {
      var i = [];
      return this.getAllRowCtrls().forEach(function(r) {
        var o = r.getCellElement(t);
        o && i.push(o);
      }), i;
    }, e.prototype.refreshFloatingRowComps = function() {
      this.refreshFloatingRows(this.topRowCtrls, this.pinnedRowModel.getPinnedTopRowData()), this.refreshFloatingRows(this.bottomRowCtrls, this.pinnedRowModel.getPinnedBottomRowData());
    }, e.prototype.getTopRowCtrls = function() {
      return this.topRowCtrls;
    }, e.prototype.getBottomRowCtrls = function() {
      return this.bottomRowCtrls;
    }, e.prototype.refreshFloatingRows = function(t, i) {
      var r = this;
      t.forEach(function(o) {
        o.destroyFirstPass(), o.destroySecondPass();
      }), t.length = 0, i && i.forEach(function(o) {
        var s = new $c(r.$scope, o, r.beans, !1, !1, r.printLayout);
        t.push(s);
      });
    }, e.prototype.onPinnedRowDataChanged = function() {
      var t = {
        recycleRows: !0
      };
      this.redrawAfterModelUpdate(t);
    }, e.prototype.getRenderedIndexesForRowNodes = function(t) {
      var i = [];
      return Je(t) || pi(this.rowCtrlsByRowIndex, function(r, o) {
        var s = o.getRowNode();
        t.indexOf(s) >= 0 && i.push(r);
      }), i;
    }, e.prototype.redrawRows = function(t) {
      var i = t != null && t.length > 0;
      if (i) {
        var r = this.getRenderedIndexesForRowNodes(t);
        this.removeRowCtrls(r);
      }
      this.redrawAfterModelUpdate({
        recycleRows: i
      });
    }, e.prototype.getCellToRestoreFocusToAfterRefresh = function(t) {
      var i = t.suppressKeepFocus ? null : this.focusService.getFocusCellToUseAfterRefresh();
      if (i == null)
        return null;
      var r = this.gridOptionsWrapper.getDocument(), o = r.activeElement, s = this.gridOptionsWrapper.getDomData(o, jc.DOM_DATA_KEY_CELL_CTRL), a = this.gridOptionsWrapper.getDomData(o, $c.DOM_DATA_KEY_ROW_CTRL), l = s || a;
      return l ? i : null;
    }, e.prototype.redrawAfterModelUpdate = function(t) {
      t === void 0 && (t = {}), this.getLockOnRefresh();
      var i = this.getCellToRestoreFocusToAfterRefresh(t);
      this.updateContainerHeights(), this.scrollToTopIfNewData(t);
      var r = !this.printLayout && !!t.recycleRows, o = t.animate && this.gridOptionsWrapper.isAnimateRows(), s = r ? this.recycleRows() : null;
      r || this.removeAllRowComps();
      var a = function() {
        if (i == null || s == null)
          return !1;
        var u = !1;
        return pi(s, function(c, h) {
          var d = h.getRowNode(), f = d.rowIndex == i.rowIndex, p = d.rowPinned == i.rowPinned;
          f && p && (u = !0);
        }), u;
      }, l = a();
      this.redraw(s, o), t.onlyBody || this.refreshFloatingRowComps(), this.dispatchDisplayedRowsChanged(), l || this.restoreFocusedCell(i), this.releaseLockOnRefresh();
    }, e.prototype.scrollToTopIfNewData = function(t) {
      var i = t.newData || t.newPage, r = this.gridOptionsWrapper.isSuppressScrollOnNewData();
      i && !r && this.gridBodyCtrl.getScrollFeature().scrollToTop();
    }, e.prototype.updateContainerHeights = function() {
      if (this.printLayout) {
        this.rowContainerHeightService.setModelHeight(null);
        return;
      }
      var t = this.paginationProxy.getCurrentPageHeight();
      t === 0 && (t = 1), this.rowContainerHeightService.setModelHeight(t);
    }, e.prototype.getLockOnRefresh = function() {
      if (this.refreshInProgress)
        throw new Error("AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace.");
      this.refreshInProgress = !0;
    }, e.prototype.releaseLockOnRefresh = function() {
      this.refreshInProgress = !1;
    }, e.prototype.restoreFocusedCell = function(t) {
      t && this.focusService.setFocusedCell(t.rowIndex, t.column, t.rowPinned, !0);
    }, e.prototype.stopEditing = function(t) {
      t === void 0 && (t = !1), this.getAllRowCtrls().forEach(function(i) {
        i.stopEditing(t);
      });
    }, e.prototype.onNewColumnsLoaded = function() {
      this.getAllCellCtrls().forEach(function(t) {
        return t.onNewColumnsLoaded();
      });
    }, e.prototype.getAllCellCtrls = function() {
      var t = [];
      return this.getAllRowCtrls().forEach(function(i) {
        return t = t.concat(i.getAllCellCtrls());
      }), t;
    }, e.prototype.getAllRowCtrls = function() {
      var t = this, i = yM(this.topRowCtrls, this.bottomRowCtrls);
      return Object.keys(this.rowCtrlsByRowIndex).forEach(function(r) {
        return i.push(t.rowCtrlsByRowIndex[r]);
      }), i;
    }, e.prototype.addRenderedRowListener = function(t, i, r) {
      var o = this.rowCtrlsByRowIndex[i];
      o && o.addEventListener(t, r);
    }, e.prototype.flashCells = function(t) {
      t === void 0 && (t = {});
      var i = t.flashDelay, r = t.fadeDelay;
      this.getCellCtrls(t.rowNodes, t.columns).forEach(function(o) {
        return o.flashCell({ flashDelay: i, fadeDelay: r });
      });
    }, e.prototype.refreshCells = function(t) {
      t === void 0 && (t = {});
      var i = {
        forceRefresh: t.force,
        newData: !1,
        suppressFlash: t.suppressFlash
      };
      this.getCellCtrls(t.rowNodes, t.columns).forEach(function(r) {
        if (r.refreshShouldDestroy()) {
          var o = r.getRowCtrl();
          o && o.refreshCell(r);
        } else
          r.refreshCell(i);
      }), this.getFullWidthRowCtrls(t.rowNodes).forEach(function(r) {
        r.refreshFullWidth();
      });
    }, e.prototype.getCellRendererInstances = function(t) {
      var i = this.getCellCtrls(t.rowNodes, t.columns).map(function(r) {
        return r.getCellRenderer();
      }).filter(function(r) {
        return r != null;
      });
      return i;
    }, e.prototype.getCellEditorInstances = function(t) {
      var i = [];
      return this.getCellCtrls(t.rowNodes, t.columns).forEach(function(r) {
        var o = r.getCellEditor();
        o && i.push(o);
      }), i;
    }, e.prototype.getEditingCells = function() {
      var t = [];
      return this.getAllCellCtrls().forEach(function(i) {
        if (i.isEditing()) {
          var r = i.getCellPosition();
          t.push(r);
        }
      }), t;
    }, e.prototype.mapRowNodes = function(t) {
      if (t) {
        var i = {
          top: {},
          bottom: {},
          normal: {}
        };
        return t.forEach(function(r) {
          var o = r.id;
          r.rowPinned === q.PINNED_TOP ? i.top[o] = r : r.rowPinned === q.PINNED_BOTTOM ? i.bottom[o] = r : i.normal[o] = r;
        }), i;
      }
    }, e.prototype.isRowInMap = function(t, i) {
      var r = t.id, o = t.rowPinned;
      return o === q.PINNED_BOTTOM ? i.bottom[r] != null : o === q.PINNED_TOP ? i.top[r] != null : i.normal[r] != null;
    }, e.prototype.getCellCtrls = function(t, i) {
      var r = this, o = this.mapRowNodes(t), s = [], a;
      de(i) && (a = {}, i.forEach(function(u) {
        var c = r.columnModel.getGridColumn(u);
        de(c) && (a[c.getId()] = !0);
      }));
      var l = function(u) {
        var c = u.getRowNode();
        o != null && !r.isRowInMap(c, o) || u.getAllCellCtrls().forEach(function(h) {
          var d = h.getColumn().getId(), f = a && !a[d];
          f || s.push(h);
        });
      };
      return pi(this.rowCtrlsByRowIndex, function(u, c) {
        l(c);
      }), this.topRowCtrls && this.topRowCtrls.forEach(l), this.bottomRowCtrls && this.bottomRowCtrls.forEach(l), s;
    }, e.prototype.destroy = function() {
      this.removeAllRowComps(), n.prototype.destroy.call(this);
    }, e.prototype.removeAllRowComps = function() {
      var t = Object.keys(this.rowCtrlsByRowIndex);
      this.removeRowCtrls(t);
    }, e.prototype.recycleRows = function() {
      var t = [];
      pi(this.rowCtrlsByRowIndex, function(r, o) {
        var s = o.getRowNode().id == null;
        s && t.push(r);
      }), this.removeRowCtrls(t);
      var i = {};
      return pi(this.rowCtrlsByRowIndex, function(r, o) {
        var s = o.getRowNode();
        i[s.id] = o;
      }), this.rowCtrlsByRowIndex = {}, i;
    }, e.prototype.removeRowCtrls = function(t) {
      var i = this;
      t.forEach(function(r) {
        var o = i.rowCtrlsByRowIndex[r];
        o && (o.destroyFirstPass(), o.destroySecondPass()), delete i.rowCtrlsByRowIndex[r];
      });
    }, e.prototype.redrawAfterScroll = function() {
      this.getLockOnRefresh(), this.redraw(null, !1, !0), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged();
    }, e.prototype.removeRowCompsNotToDraw = function(t) {
      var i = {};
      t.forEach(function(s) {
        return i[s] = !0;
      });
      var r = Object.keys(this.rowCtrlsByRowIndex), o = r.filter(function(s) {
        return !i[s];
      });
      this.removeRowCtrls(o);
    }, e.prototype.calculateIndexesToDraw = function(t) {
      var i = this, r = PB(this.firstRenderedRow, this.lastRenderedRow), o = function(s, a) {
        var l = a.getRowNode().rowIndex;
        l != null && (l < i.firstRenderedRow || l > i.lastRenderedRow) && i.doNotUnVirtualiseRow(a) && r.push(l);
      };
      return pi(this.rowCtrlsByRowIndex, o), pi(t, o), r.sort(function(s, a) {
        return s - a;
      }), r;
    }, e.prototype.redraw = function(t, i, r) {
      var o = this;
      i === void 0 && (i = !1), r === void 0 && (r = !1), this.rowContainerHeightService.updateOffset(), this.workOutFirstAndLastRowsToRender();
      var s = this.calculateIndexesToDraw(t);
      if (this.removeRowCompsNotToDraw(s), this.printLayout && (i = !1), s.forEach(function(l) {
        var u = o.createOrUpdateRowCtrl(l, t, i, r);
        de(u);
      }), t) {
        var a = r && !this.gridOptionsWrapper.isSuppressAnimationFrame() && !this.printLayout;
        a ? this.beans.animationFrameService.addDestroyTask(function() {
          o.destroyRowCtrls(t, i), o.updateAllRowCtrls(), o.dispatchDisplayedRowsChanged();
        }) : this.destroyRowCtrls(t, i);
      }
      this.updateAllRowCtrls(), this.checkAngularCompile(), this.gridBodyCtrl.updateRowCount();
    }, e.prototype.dispatchDisplayedRowsChanged = function() {
      var t = { type: I.EVENT_DISPLAYED_ROWS_CHANGED };
      this.eventService.dispatchEvent(t);
    }, e.prototype.onDisplayedColumnsChanged = function() {
      var t = this.columnModel.isPinningLeft(), i = this.columnModel.isPinningRight(), r = this.pinningLeft !== t || i !== this.pinningRight;
      r && (this.pinningLeft = t, this.pinningRight = i, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows());
    }, e.prototype.redrawFullWidthEmbeddedRows = function() {
      var t = [];
      this.getFullWidthRowCtrls().forEach(function(i) {
        var r = i.getRowNode().rowIndex;
        t.push(r.toString());
      }), this.refreshFloatingRowComps(), this.removeRowCtrls(t), this.redrawAfterScroll();
    }, e.prototype.getFullWidthRowCtrls = function(t) {
      var i = this, r = this.mapRowNodes(t);
      return Ya(this.rowCtrlsByRowIndex).filter(function(o) {
        if (!o.isFullWidth())
          return !1;
        var s = o.getRowNode();
        return !(r != null && !i.isRowInMap(s, r));
      });
    }, e.prototype.refreshFullWidthRows = function(t) {
      var i = [], r = !!t, o = r ? {} : void 0;
      r && o && t.forEach(function(s) {
        return o[s.id] = !0;
      }), this.getFullWidthRowCtrls().forEach(function(s) {
        var a = s.getRowNode();
        if (r && o) {
          var l = a.level > 0 && a.parent ? a.parent.id : void 0, u = !o[a.id] && !o[l];
          if (u)
            return;
        }
        var c = s.refreshFullWidth();
        if (!c) {
          var h = s.getRowNode().rowIndex;
          i.push(h.toString());
        }
      }), this.removeRowCtrls(i), this.redrawAfterScroll();
    }, e.prototype.createOrUpdateRowCtrl = function(t, i, r, o) {
      var s, a = this.rowCtrlsByRowIndex[t];
      a || (s = this.paginationProxy.getRow(t), de(s) && de(i) && i[s.id] && s.alreadyRendered && (a = i[s.id], i[s.id] = null));
      var l = !a;
      if (l)
        if (s || (s = this.paginationProxy.getRow(t)), de(s))
          a = this.createRowCon(s, r, o);
        else
          return;
      return s && (s.alreadyRendered = !0), this.rowCtrlsByRowIndex[t] = a, a;
    }, e.prototype.destroyRowCtrls = function(t, i) {
      var r = this, o = [];
      pi(t, function(s, a) {
        if (a) {
          if (r.cachedRowCtrls && a.isCacheable()) {
            r.cachedRowCtrls.addRow(a);
            return;
          }
          a.destroyFirstPass(), i ? (r.zombieRowCtrls[a.getInstanceId()] = a, o.push(function() {
            a.destroySecondPass(), delete r.zombieRowCtrls[a.getInstanceId()];
          })) : a.destroySecondPass();
        }
      }), i && (o.push(function() {
        r.updateAllRowCtrls(), r.dispatchDisplayedRowsChanged();
      }), HV(o));
    }, e.prototype.checkAngularCompile = function() {
      var t = this;
      this.gridOptionsWrapper.isAngularCompileRows() && window.setTimeout(function() {
        t.$scope.$apply();
      }, 0);
    }, e.prototype.workOutFirstAndLastRowsToRender = function() {
      var t = this, i, r;
      if (!this.paginationProxy.isRowsToRender())
        i = 0, r = -1;
      else if (this.printLayout)
        i = this.paginationProxy.getPageFirstRow(), r = this.paginationProxy.getPageLastRow();
      else {
        var o = this.gridOptionsWrapper.getRowBufferInPixels(), s = this.ctrlsService.getGridBodyCtrl(), a = this.gridOptionsWrapper.isSuppressRowVirtualisation(), l = !1, u = void 0, c = void 0;
        do {
          var h = this.paginationProxy.getPixelOffset(), d = this.paginationProxy.getCurrentPagePixelRange(), f = d.pageFirstPixel, p = d.pageLastPixel, g = this.rowContainerHeightService.getDivStretchOffset();
          if (a)
            u = f + g, c = p + g;
          else {
            var _ = s.getScrollFeature().getVScrollPosition(), m = _.top, v = _.bottom;
            u = Math.max(m + h - o, f) + g, c = Math.min(v + h + o, p) + g;
          }
          l = this.ensureAllRowsInRangeHaveHeightsCalculated(u, c);
        } while (l);
        var C = this.paginationProxy.getRowIndexAtPixel(u), y = this.paginationProxy.getRowIndexAtPixel(c), b = this.paginationProxy.getPageFirstRow(), L = this.paginationProxy.getPageLastRow();
        C < b && (C = b), y > L && (y = L), i = C, r = y;
      }
      var S = this.gridOptionsWrapper.getDomLayout() === q.DOM_LAYOUT_NORMAL, E = this.gridOptionsWrapper.isSuppressMaxRenderedRowRestriction(), D = Math.max(this.gridOptionsWrapper.getRowBuffer(), 500);
      S && !E && r - i > D && (r = i + D);
      var O = i !== this.firstRenderedRow, T = r !== this.lastRenderedRow;
      if (O || T) {
        this.firstRenderedRow = i, this.lastRenderedRow = r;
        var A = {
          type: I.EVENT_VIEWPORT_CHANGED,
          firstRow: i,
          lastRow: r,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(A);
      }
      if (this.paginationProxy.isRowsToRender()) {
        var P = {
          type: I.EVENT_FIRST_DATA_RENDERED,
          firstRow: i,
          lastRow: r,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        window.setTimeout(function() {
          return t.eventService.dispatchEventOnce(P);
        }, 50);
      }
    }, e.prototype.ensureAllRowsInRangeHaveHeightsCalculated = function(t, i) {
      var r = this.paginationProxy.ensureRowHeightsValid(t, i, -1, -1);
      return r && this.updateContainerHeights(), r;
    }, e.prototype.getFirstVirtualRenderedRow = function() {
      return this.firstRenderedRow;
    }, e.prototype.getLastVirtualRenderedRow = function() {
      return this.lastRenderedRow;
    }, e.prototype.doNotUnVirtualiseRow = function(t) {
      var i = !1, r = !0, o = t.getRowNode(), s = this.focusService.isRowNodeFocused(o), a = t.isEditing(), l = o.detail, u = s || a || l;
      if (!u)
        return i;
      var c = this.paginationProxy.isRowPresent(o);
      return c ? r : i;
    }, e.prototype.createRowCon = function(t, i, r) {
      var o = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(t) : null;
      if (o)
        return o;
      var s = this.gridOptionsWrapper.isSuppressAnimationFrame(), a = r && !s && !this.printLayout, l = new $c(this.$scope, t, this.beans, i, a, this.printLayout);
      return l;
    }, e.prototype.getRenderedNodes = function() {
      var t = this.rowCtrlsByRowIndex;
      return Object.keys(t).map(function(i) {
        return t[i].getRowNode();
      });
    }, e.prototype.getRowByPosition = function(t) {
      var i;
      switch (t.rowPinned) {
        case q.PINNED_TOP:
          i = this.topRowCtrls[t.rowIndex];
          break;
        case q.PINNED_BOTTOM:
          i = this.bottomRowCtrls[t.rowIndex];
          break;
        default:
          i = this.rowCtrlsByRowIndex[t.rowIndex];
          break;
      }
      return i;
    }, e.prototype.getRowNode = function(t) {
      switch (t.rowPinned) {
        case q.PINNED_TOP:
          return this.pinnedRowModel.getPinnedTopRowData()[t.rowIndex];
        case q.PINNED_BOTTOM:
          return this.pinnedRowModel.getPinnedBottomRowData()[t.rowIndex];
        default:
          return this.rowModel.getRow(t.rowIndex);
      }
    }, e.prototype.isRangeInRenderedViewport = function(t, i) {
      var r = t == null || i == null;
      if (r)
        return !1;
      var o = t > this.lastRenderedRow, s = i < this.firstRenderedRow, a = !s && !o;
      return a;
    }, is([
      R("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), is([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), is([
      R("$scope")
    ], e.prototype, "$scope", void 0), is([
      R("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), is([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), is([
      R("focusService")
    ], e.prototype, "focusService", void 0), is([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), is([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), is([
      R("beans")
    ], e.prototype, "beans", void 0), is([
      R("rowContainerHeightService")
    ], e.prototype, "rowContainerHeightService", void 0), is([
      fi("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), is([
      Ee
    ], e.prototype, "postConstruct", null), e = is([
      Ke("rowRenderer")
    ], e), e;
  }(we)
), vY = (
  /** @class */
  function() {
    function n(e) {
      this.entriesMap = {}, this.entriesList = [], this.maxCount = e;
    }
    return n.prototype.addRow = function(e) {
      if (this.entriesMap[e.getRowNode().id] = e, this.entriesList.push(e), e.setCached(!0), this.entriesList.length > this.maxCount) {
        var t = this.entriesList[0];
        t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t);
      }
    }, n.prototype.getRow = function(e) {
      if (e == null || e.id == null)
        return null;
      var t = this.entriesMap[e.id];
      if (!t)
        return null;
      this.removeFromCache(t), t.setCached(!1);
      var i = t.getRowNode() != e;
      return i ? null : t;
    }, n.prototype.removeFromCache = function(e) {
      var t = e.getRowNode().id;
      delete this.entriesMap[t], qr(this.entriesList, e);
    }, n.prototype.getEntries = function() {
      return this.entriesList;
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var _Y = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wx = (
  /** @class */
  function(n) {
    _Y(e, n);
    function e(t, i) {
      var r = n.call(this, t) || this;
      return r.ctrl = i, r;
    }
    return e.prototype.getCtrl = function() {
      return this.ctrl;
    }, e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var CY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), hL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, yY = (
  /** @class */
  function(n) {
    CY(e, n);
    function e(t) {
      var i = n.call(this, e.TEMPLATE, t) || this;
      return i.headerCompVersion = 0, i.column = t.getColumnGroupChild(), i.pinned = t.getPinned(), i;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.getGui(), r = function(a, l, u) {
        var c = u || i;
        l != null && l != "" ? c.setAttribute(a, l) : c.removeAttribute(a);
      }, o = {
        setWidth: function(a) {
          return i.style.width = a;
        },
        addOrRemoveCssClass: function(a, l) {
          return t.addOrRemoveCssClass(a, l);
        },
        setAriaSort: function(a) {
          return a ? xB(i, a) : NB(i);
        },
        setColId: function(a) {
          return r("col-id", a);
        },
        setTitle: function(a) {
          return r("title", a);
        },
        setAriaDescribedBy: function(a) {
          return SS(i, a);
        },
        setUserCompDetails: function(a) {
          return t.setUserCompDetails(a);
        },
        getUserCompInstance: function() {
          return t.headerComp;
        }
      };
      this.ctrl.setComp(o, this.getGui(), this.eResize);
      var s = this.ctrl.getSelectAllGui();
      this.eResize.insertAdjacentElement("afterend", s);
    }, e.prototype.destroyHeaderComp = function() {
      this.headerComp && (this.getGui().removeChild(this.headerCompGui), this.headerComp = this.destroyBean(this.headerComp), this.headerCompGui = void 0);
    }, e.prototype.setUserCompDetails = function(t) {
      var i = this;
      this.headerCompVersion++;
      var r = this.headerCompVersion;
      t.newAgStackInstance().then(function(o) {
        return i.afterCompCreated(r, o);
      });
    }, e.prototype.afterCompCreated = function(t, i) {
      if (t != this.headerCompVersion || !this.isAlive()) {
        this.destroyBean(i);
        return;
      }
      this.destroyHeaderComp(), this.headerComp = i, this.headerCompGui = i.getGui(), this.getGui().appendChild(this.headerCompGui), this.ctrl.setDragSource(this.headerCompGui);
    }, e.TEMPLATE = `<div class="ag-header-cell" role="columnheader" tabindex="-1">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
        </div>`, hL([
      fe("eResize")
    ], e.prototype, "eResize", void 0), hL([
      Ee
    ], e.prototype, "postConstruct", null), hL([
      Lo
    ], e.prototype, "destroyHeaderComp", null), e;
  }(wx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var wY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), dL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, bY = (
  /** @class */
  function(n) {
    wY(e, n);
    function e(t) {
      return n.call(this, e.TEMPLATE, t) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.getGui(), r = function(s, a) {
        return a != null ? i.setAttribute(s, a) : i.removeAttribute(s);
      }, o = {
        addOrRemoveCssClass: function(s, a) {
          return t.addOrRemoveCssClass(s, a);
        },
        addOrRemoveResizableCssClass: function(s, a) {
          return t.eResize.classList.toggle(s, a);
        },
        setWidth: function(s) {
          return i.style.width = s;
        },
        setColId: function(s) {
          return i.setAttribute("col-id", s);
        },
        setAriaExpanded: function(s) {
          return r("aria-expanded", s);
        },
        setTitle: function(s) {
          return r("title", s);
        },
        setUserCompDetails: function(s) {
          return t.setUserCompDetails(s);
        }
      };
      this.ctrl.setComp(o, i, this.eResize);
    }, e.prototype.setUserCompDetails = function(t) {
      var i = this;
      t.newAgStackInstance().then(function(r) {
        return i.afterHeaderCompCreated(r);
      });
    }, e.prototype.afterHeaderCompCreated = function(t) {
      var i = this, r = function() {
        return i.destroyBean(t);
      };
      if (!this.isAlive()) {
        r();
        return;
      }
      this.getGui().appendChild(t.getGui()), this.addDestroyFunc(r), this.ctrl.setDragSource(t.getGui());
    }, e.TEMPLATE = `<div class="ag-header-group-cell" role="columnheader" tabindex="-1">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
        </div>`, dL([
      R("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), dL([
      fe("eResize")
    ], e.prototype, "eResize", void 0), dL([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(wx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var SY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), MC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, cH = (
  /** @class */
  function(n) {
    SY(e, n);
    function e(t) {
      return n.call(this, e.TEMPLATE, t) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.getGui(), r = {
        addOrRemoveCssClass: function(o, s) {
          return t.addOrRemoveCssClass(o, s);
        },
        addOrRemoveBodyCssClass: function(o, s) {
          return t.eFloatingFilterBody.classList.toggle(o, s);
        },
        addOrRemoveButtonWrapperCssClass: function(o, s) {
          return t.eButtonWrapper.classList.toggle(o, s);
        },
        setCompDetails: function(o) {
          return t.setCompDetails(o);
        },
        getFloatingFilterComp: function() {
          return t.compPromise;
        },
        setWidth: function(o) {
          return i.style.width = o;
        },
        setMenuIcon: function(o) {
          return t.eButtonShowMainFilter.appendChild(o);
        }
      };
      this.ctrl.setComp(r, i, this.eButtonShowMainFilter, this.eFloatingFilterBody);
    }, e.prototype.setCompDetails = function(t) {
      var i = this;
      this.compPromise = t.newAgStackInstance(), this.compPromise.then(function(r) {
        return i.afterCompCreated(r);
      });
    }, e.prototype.afterCompCreated = function(t) {
      var i = this;
      t && (this.addDestroyFunc(function() {
        return i.context.destroyBean(t);
      }), this.isAlive() && (this.eFloatingFilterBody.appendChild(t.getGui()), t.afterGuiAttached && t.afterGuiAttached()));
    }, e.TEMPLATE = `<div class="ag-header-cell ag-floating-filter" role="gridcell" tabindex="-1">
            <div ref="eFloatingFilterBody" role="presentation"></div>
            <div class="ag-floating-filter-button ag-hidden" ref="eButtonWrapper" role="presentation">
                <button type="button" aria-label="Open Filter Menu" class="ag-floating-filter-button-button" ref="eButtonShowMainFilter" tabindex="-1"></button>
            </div>
        </div>`, MC([
      fe("eFloatingFilterBody")
    ], e.prototype, "eFloatingFilterBody", void 0), MC([
      fe("eButtonWrapper")
    ], e.prototype, "eButtonWrapper", void 0), MC([
      fe("eButtonShowMainFilter")
    ], e.prototype, "eButtonShowMainFilter", void 0), MC([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(wx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var EY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Xr;
(function(n) {
  n.COLUMN_GROUP = "group", n.COLUMN = "column", n.FLOATING_FILTER = "filter";
})(Xr || (Xr = {}));
var hH = (
  /** @class */
  function(n) {
    EY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      i.headerComps = {};
      var r = t.getType() == Xr.COLUMN_GROUP ? "ag-header-row-column-group" : t.getType() == Xr.FLOATING_FILTER ? "ag-header-row-column-filter" : "ag-header-row-column";
      return i.setTemplate(
        /* html */
        '<div class="ag-header-row ' + r + '" role="row"></div>'
      ), i.ctrl = t, i;
    }
    return e.prototype.init = function() {
      var t = this, i = {
        setTransform: function(r) {
          return t.getGui().style.transform = r;
        },
        setHeight: function(r) {
          return t.getGui().style.height = r;
        },
        setTop: function(r) {
          return t.getGui().style.top = r;
        },
        setHeaderCtrls: function(r) {
          return t.setHeaderCtrls(r);
        },
        setWidth: function(r) {
          return t.getGui().style.width = r;
        },
        setAriaRowIndex: function(r) {
          return sx(t.getGui(), r);
        }
      };
      this.ctrl.setComp(i);
    }, e.prototype.destroyHeaderCtrls = function() {
      this.setHeaderCtrls([]);
    }, e.prototype.setHeaderCtrls = function(t) {
      var i = this;
      if (this.isAlive()) {
        var r = this.headerComps;
        this.headerComps = {}, t.forEach(function(l) {
          var u = l.getInstanceId(), c = r[u];
          delete r[u], c == null && (c = i.createHeaderComp(l), i.getGui().appendChild(c.getGui())), i.headerComps[u] = c;
        }), pi(r, function(l, u) {
          i.getGui().removeChild(u.getGui()), i.destroyBean(u);
        });
        var o = this.gridOptionsWrapper.isEnsureDomOrder();
        if (o) {
          var s = Ya(this.headerComps);
          s.sort(function(l, u) {
            var c = l.getCtrl().getColumnGroupChild().getLeft(), h = u.getCtrl().getColumnGroupChild().getLeft();
            return c - h;
          });
          var a = s.map(function(l) {
            return l.getGui();
          });
          JO(this.getGui(), a);
        }
      }
    }, e.prototype.createHeaderComp = function(t) {
      var i;
      switch (this.ctrl.getType()) {
        case Xr.COLUMN_GROUP:
          i = new bY(t);
          break;
        case Xr.FLOATING_FILTER:
          i = new cH(t);
          break;
        default:
          i = new yY(t);
          break;
      }
      return this.createBean(i), i.setParentComponent(this), i;
    }, wM([
      Ee
    ], e.prototype, "init", null), wM([
      Lo
    ], e.prototype, "destroyHeaderCtrls", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var LY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), pf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Wa;
(function(n) {
  n[n.UP = 0] = "UP", n[n.DOWN = 1] = "DOWN", n[n.LEFT = 2] = "LEFT", n[n.RIGHT = 3] = "RIGHT";
})(Wa || (Wa = {}));
var dH = (
  /** @class */
  function(n) {
    LY(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        t.gridBodyCon = i.gridBodyCtrl;
      });
    }, e.prototype.getHeaderRowCount = function() {
      var t = this.ctrlsService.getHeaderRowContainerCtrl();
      return t ? t.getRowCount() : 0;
    }, e.prototype.getHeaderRowType = function(t) {
      var i = this.ctrlsService.getHeaderRowContainerCtrl();
      if (i)
        return i.getRowType(t);
    }, e.prototype.navigateVertically = function(t, i, r) {
      if (i || (i = this.focusService.getFocusedHeader()), !i)
        return !1;
      var o = i.headerRowIndex, s = i.column, a = this.getHeaderRowCount(), l = t === Wa.UP, u = l ? o - 1 : o + 1, c = null, h = !1;
      u < 0 && (u = 0, c = s, h = !0), u >= a && (u = -1);
      var d = this.getHeaderRowType(o);
      if (!h) {
        if (d === Xr.COLUMN_GROUP) {
          var f = s;
          c = l ? s.getParent() : f.getDisplayedChildren()[0];
        } else if (d === Xr.FLOATING_FILTER)
          c = s;
        else {
          var f = s;
          c = l ? f.getParent() : f;
        }
        if (!c)
          return !1;
      }
      return this.focusService.focusHeaderPosition({
        headerPosition: { headerRowIndex: u, column: c },
        allowUserOverride: !0,
        event: r
      });
    }, e.prototype.navigateHorizontally = function(t, i, r) {
      i === void 0 && (i = !1);
      var o = this.focusService.getFocusedHeader(), s = t === Wa.LEFT, a = this.gridOptionsWrapper.isEnableRtl(), l, u;
      return s !== a ? (u = "Before", l = this.headerPositionUtils.findHeader(o, u)) : (u = "After", l = this.headerPositionUtils.findHeader(o, u)), l ? this.focusService.focusHeaderPosition({
        headerPosition: l,
        direction: u,
        fromTab: i,
        allowUserOverride: !0,
        event: r
      }) : i ? this.focusNextHeaderRow(o, u, r) : !0;
    }, e.prototype.focusNextHeaderRow = function(t, i, r) {
      var o = t.headerRowIndex, s = null, a;
      return i === "Before" ? o > 0 && (a = o - 1, s = this.headerPositionUtils.findColAtEdgeForHeaderRow(a, "end")) : (a = o + 1, s = this.headerPositionUtils.findColAtEdgeForHeaderRow(a, "start")), this.focusService.focusHeaderPosition({
        headerPosition: s,
        direction: i,
        fromTab: !0,
        allowUserOverride: !0,
        event: r
      });
    }, e.prototype.scrollToColumn = function(t, i) {
      if (i === void 0 && (i = "After"), !t.getPinned()) {
        var r;
        if (t instanceof Yr) {
          var o = t.getDisplayedLeafColumns();
          r = i === "Before" ? Di(o) : o[0];
        } else
          r = t;
        this.gridBodyCon.getScrollFeature().ensureColumnVisible(r), this.gridBodyCon.getScrollFeature().horizontallyScrollHeaderCenterAndFloatingCenter(), this.animationFrameService.flushAllFrames();
      }
    }, pf([
      R("focusService")
    ], e.prototype, "focusService", void 0), pf([
      R("headerPositionUtils")
    ], e.prototype, "headerPositionUtils", void 0), pf([
      R("animationFrameService")
    ], e.prototype, "animationFrameService", void 0), pf([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), pf([
      Ee
    ], e.prototype, "postConstruct", null), e = pf([
      Ke("headerNavigationService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var DY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), FC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, fH = (
  /** @class */
  function(n) {
    DY(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setComp = function(t, i, r) {
      this.comp = t, this.eGui = i, this.createManagedBean(new Qu(r, {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })), this.addManagedListener(this.eventService, I.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this)), this.onPivotModeChanged(), this.setupHeaderHeight(), this.ctrlsService.registerGridHeaderCtrl(this);
    }, e.prototype.setupHeaderHeight = function() {
      var t = this.setHeaderHeight.bind(this);
      t(), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_HEADER_HEIGHT, t), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_PIVOT_HEADER_HEIGHT, t), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_GROUP_HEADER_HEIGHT, t), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_PIVOT_GROUP_HEADER_HEIGHT, t), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_FLOATING_FILTERS_HEIGHT, t), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, t);
    }, e.prototype.setHeaderHeight = function() {
      var t = this, i = t.columnModel, r = t.gridOptionsWrapper, o = 0, s = i.getHeaderRowCount(), a, l, u;
      if (i.isPivotMode())
        l = r.getPivotGroupHeaderHeight(), u = r.getPivotHeaderHeight();
      else {
        var c = i.hasFloatingFilters();
        c && (s++, o = 1), l = r.getGroupHeaderHeight(), u = r.getHeaderHeight();
      }
      var h = 1 + o, d = s - h;
      a = o * r.getFloatingFiltersHeight(), a += d * l, a += u;
      var f = a + 1 + "px";
      this.comp.setHeightAndMinHeight(f);
    }, e.prototype.onPivotModeChanged = function() {
      var t = this.columnModel.isPivotMode();
      this.comp.addOrRemoveCssClass("ag-pivot-on", t), this.comp.addOrRemoveCssClass("ag-pivot-off", !t);
    }, e.prototype.onTabKeyDown = function(t) {
      var i = this.gridOptionsWrapper.isEnableRtl(), r = t.shiftKey !== i ? Wa.LEFT : Wa.RIGHT;
      (this.headerNavigationService.navigateHorizontally(r, !0, t) || this.focusService.focusNextGridCoreContainer(t.shiftKey)) && t.preventDefault();
    }, e.prototype.handleKeyDown = function(t) {
      var i = null;
      switch (t.key) {
        case pe.LEFT:
          i = Wa.LEFT;
        case pe.RIGHT:
          de(i) || (i = Wa.RIGHT), this.headerNavigationService.navigateHorizontally(i, !1, t);
          break;
        case pe.UP:
          i = Wa.UP;
        case pe.DOWN:
          de(i) || (i = Wa.DOWN), this.headerNavigationService.navigateVertically(i, null, t) && t.preventDefault();
          break;
        default:
          return;
      }
    }, e.prototype.onFocusOut = function(t) {
      var i = this.gridOptionsWrapper.getDocument(), r = t.relatedTarget;
      !r && this.eGui.contains(i.activeElement) || this.eGui.contains(r) || this.focusService.clearFocusedHeader();
    }, FC([
      R("headerNavigationService")
    ], e.prototype, "headerNavigationService", void 0), FC([
      R("focusService")
    ], e.prototype, "focusService", void 0), FC([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), FC([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var om = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, pH = (
  /** @class */
  function() {
    function n(e, t) {
      this.needToMoveLeft = !1, this.needToMoveRight = !1, this.pinned = e, this.eContainer = t, this.centerContainer = !de(e);
    }
    return n.prototype.init = function() {
      var e = this;
      this.ctrlsService.whenReady(function() {
        e.gridBodyCon = e.ctrlsService.getGridBodyCtrl();
      });
    }, n.prototype.getIconName = function() {
      return this.pinned ? _o.ICON_PINNED : _o.ICON_MOVE;
    }, n.prototype.onDragEnter = function(e) {
      var t = e.dragItem.columns, i = e.dragSource.type === ws.ToolPanel;
      if (i)
        this.setColumnsVisible(t, !0, "uiColumnDragged");
      else {
        var r = e.dragItem.visibleState, o = (t || []).filter(function(s) {
          return r[s.getId()];
        });
        this.setColumnsVisible(o, !0, "uiColumnDragged");
      }
      this.setColumnsPinned(t, this.pinned, "uiColumnDragged"), this.onDragging(e, !0);
    }, n.prototype.onDragLeave = function(e) {
      var t = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !e.fromNudge;
      if (t) {
        var i = e.dragSource.getDragItem(), r = i.columns;
        this.setColumnsVisible(r, !1, "uiColumnDragged");
      }
      this.ensureIntervalCleared();
    }, n.prototype.setColumnsVisible = function(e, t, i) {
      if (i === void 0 && (i = "api"), e) {
        var r = e.filter(function(o) {
          return !o.getColDef().lockVisible;
        });
        this.columnModel.setColumnsVisible(r, t, i);
      }
    }, n.prototype.setColumnsPinned = function(e, t, i) {
      if (i === void 0 && (i = "api"), e) {
        var r = e.filter(function(o) {
          return !o.getColDef().lockPinned;
        });
        this.columnModel.setColumnsPinned(r, t, i);
      }
    }, n.prototype.onDragStop = function() {
      this.ensureIntervalCleared();
    }, n.prototype.normaliseX = function(e) {
      if (this.gridOptionsWrapper.isEnableRtl()) {
        var t = this.eContainer.clientWidth;
        e = t - e;
      }
      return this.centerContainer && (e += this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft()), e;
    }, n.prototype.checkCenterForScrolling = function(e) {
      if (this.centerContainer) {
        var t = this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft(), i = t + this.ctrlsService.getCenterRowContainerCtrl().getCenterWidth();
        this.gridOptionsWrapper.isEnableRtl() ? (this.needToMoveRight = e < t + 50, this.needToMoveLeft = e > i - 50) : (this.needToMoveLeft = e < t + 50, this.needToMoveRight = e > i - 50), this.needToMoveLeft || this.needToMoveRight ? this.ensureIntervalStarted() : this.ensureIntervalCleared();
      }
    }, n.prototype.onDragging = function(e, t) {
      var i = this;
      if (t === void 0 && (t = !1), this.lastDraggingEvent = e, !Je(e.hDirection)) {
        var r = this.normaliseX(e.x);
        t || this.checkCenterForScrolling(r);
        var o = this.normaliseDirection(e.hDirection), s = e.dragSource.type, a = e.dragSource.getDragItem().columns;
        a = a.filter(function(l) {
          return l.getColDef().lockPinned ? l.getPinned() == i.pinned : !0;
        }), this.attemptMoveColumns(s, a, o, r, t);
      }
    }, n.prototype.normaliseDirection = function(e) {
      if (this.gridOptionsWrapper.isEnableRtl())
        switch (e) {
          case ka.Left:
            return ka.Right;
          case ka.Right:
            return ka.Left;
          default:
            console.error("AG Grid: Unknown direction " + e);
        }
      else
        return e;
    }, n.prototype.calculateOldIndex = function(e) {
      var t = this.columnModel.getAllGridColumns(), i = qV(e.map(function(l) {
        return t.indexOf(l);
      })), r = i[0], o = Di(i), s = o - r, a = s !== i.length - 1;
      return a ? null : r;
    }, n.prototype.attemptMoveColumns = function(e, t, i, r, o) {
      var s = i === ka.Left, a = i === ka.Right, l = t.slice();
      this.columnModel.sortColumnsLikeGridColumns(l);
      var u = this.calculateValidMoves(l, a, r), c = this.calculateOldIndex(l);
      if (u.length !== 0) {
        var h = u[0], d = c !== null && !o;
        if (e == ws.HeaderCell && (d = c !== null), !(d && (s && h >= c || a && h <= c)))
          for (var f = 0; f < u.length; f++) {
            var p = u[f];
            if (this.columnModel.doesMovePassRules(l, p)) {
              this.columnModel.moveColumns(l, p, "uiColumnDragged");
              return;
            }
          }
      }
    }, n.prototype.calculateValidMoves = function(e, t, i) {
      var r = this.gridOptionsWrapper.isSuppressMovableColumns() || e.some(function(S) {
        return S.getColDef().suppressMovable;
      });
      if (r)
        return [];
      var o = this.columnModel.getDisplayedColumns(this.pinned), s = this.columnModel.getAllGridColumns(), a = o.filter(function(S) {
        return Cs(e, S);
      }), l = o.filter(function(S) {
        return !Cs(e, S);
      }), u = s.filter(function(S) {
        return !Cs(e, S);
      }), c = 0, h = i;
      if (t) {
        var d = 0;
        a.forEach(function(S) {
          return d += S.getActualWidth();
        }), h -= d;
      }
      if (h > 0) {
        for (var f = 0; f < l.length; f++) {
          var p = l[f];
          if (h -= p.getActualWidth(), h < 0)
            break;
          c++;
        }
        t && c++;
      }
      var g;
      if (c > 0) {
        var _ = l[c - 1];
        g = u.indexOf(_) + 1;
      } else
        g = u.indexOf(l[0]), g === -1 && (g = 0);
      var m = [g], v = function(S, E) {
        return S - E;
      };
      if (t) {
        for (var C = g + 1, y = s.length - 1; C <= y; )
          m.push(C), C++;
        m.sort(v);
      } else {
        for (var C = g, y = s.length - 1, b = s[C]; C <= y && this.isColumnHidden(o, b); )
          C++, m.push(C), b = s[C];
        C = g - 1;
        for (var L = 0; C >= L; )
          m.push(C), C--;
        m.sort(v).reverse();
      }
      return m;
    }, n.prototype.isColumnHidden = function(e, t) {
      return e.indexOf(t) < 0;
    }, n.prototype.ensureIntervalStarted = function() {
      this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100), this.needToMoveLeft ? this.dragAndDropService.setGhostIcon(_o.ICON_LEFT, !0) : this.dragAndDropService.setGhostIcon(_o.ICON_RIGHT, !0));
    }, n.prototype.ensureIntervalCleared = function() {
      this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.dragAndDropService.setGhostIcon(_o.ICON_MOVE));
    }, n.prototype.moveInterval = function() {
      var e;
      this.intervalCount++, e = 10 + this.intervalCount * 5, e > 100 && (e = 100);
      var t = null, i = this.gridBodyCon.getScrollFeature();
      if (this.needToMoveLeft ? t = i.scrollHorizontally(-e) : this.needToMoveRight && (t = i.scrollHorizontally(e)), t !== 0)
        this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
      else {
        this.failedMoveAttempts++;
        var r = this.lastDraggingEvent.dragItem.columns, o = r.filter(function(a) {
          return !a.getColDef().lockPinned;
        });
        if (o.length > 0 && (this.dragAndDropService.setGhostIcon(_o.ICON_PINNED), this.failedMoveAttempts > 7)) {
          var s = this.needToMoveLeft ? q.PINNED_LEFT : q.PINNED_RIGHT;
          this.setColumnsPinned(o, s, "uiColumnDragged"), this.dragAndDropService.nudge();
        }
      }
    }, om([
      R("columnModel")
    ], n.prototype, "columnModel", void 0), om([
      R("dragAndDropService")
    ], n.prototype, "dragAndDropService", void 0), om([
      R("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), om([
      R("ctrlsService")
    ], n.prototype, "ctrlsService", void 0), om([
      Ee
    ], n.prototype, "init", null), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var bM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, gH = (
  /** @class */
  function() {
    function n(e) {
      this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [], this.pinned = e;
    }
    return n.prototype.onDragEnter = function(e) {
      var t = this;
      if (this.clearColumnsList(), !this.gridOptionsWrapper.isFunctionsReadOnly()) {
        var i = e.dragItem.columns;
        i && i.forEach(function(r) {
          r.isPrimary() && (r.isAnyFunctionActive() || (r.isAllowValue() ? t.columnsToAggregate.push(r) : r.isAllowRowGroup() ? t.columnsToGroup.push(r) : r.isAllowPivot() && t.columnsToPivot.push(r)));
        });
      }
    }, n.prototype.getIconName = function() {
      var e = this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length;
      return e > 0 ? this.pinned ? _o.ICON_PINNED : _o.ICON_MOVE : null;
    }, n.prototype.onDragLeave = function(e) {
      this.clearColumnsList();
    }, n.prototype.clearColumnsList = function() {
      this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0;
    }, n.prototype.onDragging = function(e) {
    }, n.prototype.onDragStop = function(e) {
      this.columnsToAggregate.length > 0 && this.columnModel.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop"), this.columnsToGroup.length > 0 && this.columnModel.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop"), this.columnsToPivot.length > 0 && this.columnModel.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop");
    }, bM([
      R("columnModel")
    ], n.prototype, "columnModel", void 0), bM([
      R("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var RY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), sm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, mH = (
  /** @class */
  function(n) {
    RY(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.pinned = t, r.eContainer = i, r;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        switch (t.pinned) {
          case q.PINNED_LEFT:
            t.eSecondaryContainers = [
              [i.gridBodyCtrl.getBodyViewportElement(), i.leftRowContainerCtrl.getContainerElement()],
              [i.bottomLeftRowContainerCtrl.getContainerElement()],
              [i.topLeftRowContainerCtrl.getContainerElement()]
            ];
            break;
          case q.PINNED_RIGHT:
            t.eSecondaryContainers = [
              [i.gridBodyCtrl.getBodyViewportElement(), i.rightRowContainerCtrl.getContainerElement()],
              [i.bottomRightRowContainerCtrl.getContainerElement()],
              [i.topRightRowContainerCtrl.getContainerElement()]
            ];
            break;
          default:
            t.eSecondaryContainers = [
              [i.gridBodyCtrl.getBodyViewportElement(), i.centerRowContainerCtrl.getViewportElement()],
              [i.bottomCenterRowContainerCtrl.getViewportElement()],
              [i.topCenterRowContainerCtrl.getViewportElement()]
            ];
            break;
        }
      });
    }, e.prototype.isInterestedIn = function(t) {
      return t === ws.HeaderCell || t === ws.ToolPanel && this.gridOptionsWrapper.isAllowDragFromColumnsToolPanel();
    }, e.prototype.getSecondaryContainers = function() {
      return this.eSecondaryContainers;
    }, e.prototype.getContainer = function() {
      return this.eContainer;
    }, e.prototype.init = function() {
      this.moveColumnFeature = this.createManagedBean(new pH(this.pinned, this.eContainer)), this.bodyDropPivotTarget = this.createManagedBean(new gH(this.pinned)), this.dragAndDropService.addDropTarget(this);
    }, e.prototype.getIconName = function() {
      return this.currentDropListener.getIconName();
    }, e.prototype.isDropColumnInPivotMode = function(t) {
      return this.columnModel.isPivotMode() && t.dragSource.type === ws.ToolPanel;
    }, e.prototype.onDragEnter = function(t) {
      this.currentDropListener = this.isDropColumnInPivotMode(t) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(t);
    }, e.prototype.onDragLeave = function(t) {
      this.currentDropListener.onDragLeave(t);
    }, e.prototype.onDragging = function(t) {
      this.currentDropListener.onDragging(t);
    }, e.prototype.onDragStop = function(t) {
      this.currentDropListener.onDragStop(t);
    }, sm([
      R("dragAndDropService")
    ], e.prototype, "dragAndDropService", void 0), sm([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), sm([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), sm([
      Ee
    ], e.prototype, "postConstruct", null), sm([
      Ee
    ], e.prototype, "init", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var TY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), OY = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, xY = 0, R_ = (
  /** @class */
  function(n) {
    TY(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.lastFocusEvent = null, r.columnGroupChild = t, r.parentRowCtrl = i, r.instanceId = t.getUniqueId() + "-" + xY++, r;
    }
    return e.prototype.shouldStopEventPropagation = function(t) {
      var i = this.focusService.getFocusedHeader(), r = i.headerRowIndex, o = i.column;
      return BB(this.gridOptionsWrapper, t, r, o);
    }, e.prototype.setGui = function(t) {
      this.eGui = t, this.addDomData();
    }, e.prototype.addDomData = function() {
      var t = this, i = e.DOM_DATA_KEY_HEADER_CTRL;
      this.gridOptionsWrapper.setDomData(this.eGui, i, this), this.addDestroyFunc(function() {
        return t.gridOptionsWrapper.setDomData(t.eGui, i, null);
      });
    }, e.prototype.getGui = function() {
      return this.eGui;
    }, e.prototype.focus = function(t) {
      return this.eGui ? (this.lastFocusEvent = t || null, this.eGui.focus(), !0) : !1;
    }, e.prototype.getRowIndex = function() {
      return this.parentRowCtrl.getRowIndex();
    }, e.prototype.getParentRowCtrl = function() {
      return this.parentRowCtrl;
    }, e.prototype.getPinned = function() {
      return this.parentRowCtrl.getPinned();
    }, e.prototype.getInstanceId = function() {
      return this.instanceId;
    }, e.prototype.getColumnGroupChild = function() {
      return this.columnGroupChild;
    }, e.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl", OY([
      R("focusService")
    ], e.prototype, "focusService", void 0), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var sp;
(function(n) {
  n[n.SINGLE_SHEET = 0] = "SINGLE_SHEET", n[n.MULTI_SHEET = 1] = "MULTI_SHEET";
})(sp || (sp = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var ea;
(function(n) {
  n.EVERYTHING = "group", n.FILTER = "filter", n.SORT = "sort", n.MAP = "map", n.AGGREGATE = "aggregate", n.PIVOT = "pivot", n.NOTHING = "nothing";
})(ea || (ea = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Ht = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
};
function Vh(n) {
  var e = n, t = e != null && e.getFrameworkComponentInstance != null;
  return t ? e.getFrameworkComponentInstance() : n;
}
var vH = (
  /** @class */
  function() {
    function n() {
      this.detailGridInfoMap = {}, this.destroyCalled = !1;
    }
    return n.prototype.registerOverlayWrapperComp = function(e) {
      this.overlayWrapperComp = e;
    }, n.prototype.registerSideBarComp = function(e) {
      this.sideBarComp = e;
    }, n.prototype.init = function() {
      var e = this;
      switch (this.rowModel.getType()) {
        case q.ROW_MODEL_TYPE_CLIENT_SIDE:
          this.clientSideRowModel = this.rowModel;
          break;
        case q.ROW_MODEL_TYPE_INFINITE:
          this.infiniteRowModel = this.rowModel;
          break;
        case q.ROW_MODEL_TYPE_SERVER_SIDE:
          this.serverSideRowModel = this.rowModel;
          break;
      }
      this.ctrlsService.whenReady(function() {
        e.gridBodyCon = e.ctrlsService.getGridBodyCtrl();
      });
    }, n.prototype.__getAlignedGridService = function() {
      return this.alignedGridsService;
    }, n.prototype.__getContext = function() {
      return this.context;
    }, n.prototype.addDetailGridInfo = function(e, t) {
      this.detailGridInfoMap[e] = t;
    }, n.prototype.removeDetailGridInfo = function(e) {
      this.detailGridInfoMap[e] = void 0;
    }, n.prototype.getDetailGridInfo = function(e) {
      return this.detailGridInfoMap[e];
    }, n.prototype.forEachDetailGridInfo = function(e) {
      var t = 0;
      pi(this.detailGridInfoMap, function(i, r) {
        de(r) && (e(r, t), t++);
      });
    }, n.prototype.getDataAsCsv = function(e) {
      if (pt.assertRegistered(ct.CsvExportModule, "api.getDataAsCsv"))
        return this.csvCreator.getDataAsCsv(e);
    }, n.prototype.exportDataAsCsv = function(e) {
      pt.assertRegistered(ct.CsvExportModule, "api.exportDataAsCSv") && this.csvCreator.exportDataAsCsv(e);
    }, n.prototype.getExcelExportMode = function(e) {
      var t = this.gridOptionsWrapper.getDefaultExportParams("excel"), i = Object.assign({ exportMode: "xlsx" }, t, e);
      return i.exportMode;
    }, n.prototype.getDataAsExcel = function(e) {
      if (pt.assertRegistered(ct.ExcelExportModule, "api.getDataAsExcel")) {
        var t = this.getExcelExportMode(e);
        if (this.excelCreator.getFactoryMode(t) === sp.MULTI_SHEET) {
          console.warn("AG Grid: The Excel Exporter is currently on Multi Sheet mode. End that operation by calling `api.getMultipleSheetAsExcel()` or `api.exportMultipleSheetsAsExcel()`");
          return;
        }
        return this.excelCreator.getDataAsExcel(e);
      }
    }, n.prototype.exportDataAsExcel = function(e) {
      if (pt.assertRegistered(ct.ExcelExportModule, "api.exportDataAsExcel")) {
        var t = this.getExcelExportMode(e);
        if (this.excelCreator.getFactoryMode(t) === sp.MULTI_SHEET) {
          console.warn("AG Grid: The Excel Exporter is currently on Multi Sheet mode. End that operation by calling `api.getMultipleSheetAsExcel()` or `api.exportMultipleSheetsAsExcel()`");
          return;
        }
        this.excelCreator.exportDataAsExcel(e);
      }
    }, n.prototype.getSheetDataForExcel = function(e) {
      if (pt.assertRegistered(ct.ExcelExportModule, "api.getSheetDataForExcel")) {
        var t = this.getExcelExportMode(e);
        return this.excelCreator.setFactoryMode(sp.MULTI_SHEET, t), this.excelCreator.getSheetDataForExcel(e);
      }
    }, n.prototype.getMultipleSheetsAsExcel = function(e) {
      if (pt.assertRegistered(ct.ExcelExportModule, "api.getMultipleSheetsAsExcel"))
        return this.excelCreator.getMultipleSheetsAsExcel(e);
    }, n.prototype.exportMultipleSheetsAsExcel = function(e) {
      if (pt.assertRegistered(ct.ExcelExportModule, "api.exportMultipleSheetsAsExcel"))
        return this.excelCreator.exportMultipleSheetsAsExcel(e);
    }, n.prototype.setEnterpriseDatasource = function(e) {
      console.warn("AG Grid: since version 18.x, api.setEnterpriseDatasource() should be replaced with api.setServerSideDatasource()"), this.setServerSideDatasource(e);
    }, n.prototype.setGridAriaProperty = function(e, t) {
      if (e) {
        var i = this.ctrlsService.getGridBodyCtrl().getGui(), r = "aria-" + e;
        t === null ? i.removeAttribute(r) : i.setAttribute(r, t);
      }
    }, n.prototype.setServerSideDatasource = function(e) {
      this.serverSideRowModel ? this.serverSideRowModel.setDatasource(e) : console.warn("AG Grid: you can only use an enterprise datasource when gridOptions.rowModelType is '" + q.ROW_MODEL_TYPE_SERVER_SIDE + "'");
    }, n.prototype.setDatasource = function(e) {
      this.gridOptionsWrapper.isRowModelInfinite() ? this.rowModel.setDatasource(e) : console.warn("AG Grid: you can only use a datasource when gridOptions.rowModelType is '" + q.ROW_MODEL_TYPE_INFINITE + "'");
    }, n.prototype.setViewportDatasource = function(e) {
      this.gridOptionsWrapper.isRowModelViewport() ? this.rowModel.setViewportDatasource(e) : console.warn("AG Grid: you can only use a viewport datasource when gridOptions.rowModelType is '" + q.ROW_MODEL_TYPE_VIEWPORT + "'");
    }, n.prototype.setRowData = function(e) {
      var t = this.immutableService == null;
      if (t) {
        console.warn("AG Grid: you can only set rowData when using the Client Side Row Model");
        return;
      }
      this.immutableService.isActive() ? this.immutableService.setRowData(e) : (this.selectionService.reset(), this.clientSideRowModel.setRowData(e));
    }, n.prototype.setFloatingTopRowData = function(e) {
      console.warn("AG Grid: since v12, api.setFloatingTopRowData() is now api.setPinnedTopRowData()"), this.setPinnedTopRowData(e);
    }, n.prototype.setFloatingBottomRowData = function(e) {
      console.warn("AG Grid: since v12, api.setFloatingBottomRowData() is now api.setPinnedBottomRowData()"), this.setPinnedBottomRowData(e);
    }, n.prototype.getFloatingTopRowCount = function() {
      return console.warn("AG Grid: since v12, api.getFloatingTopRowCount() is now api.getPinnedTopRowCount()"), this.getPinnedTopRowCount();
    }, n.prototype.getFloatingBottomRowCount = function() {
      return console.warn("AG Grid: since v12, api.getFloatingBottomRowCount() is now api.getPinnedBottomRowCount()"), this.getPinnedBottomRowCount();
    }, n.prototype.getFloatingTopRow = function(e) {
      return console.warn("AG Grid: since v12, api.getFloatingTopRow() is now api.getPinnedTopRow()"), this.getPinnedTopRow(e);
    }, n.prototype.getFloatingBottomRow = function(e) {
      return console.warn("AG Grid: since v12, api.getFloatingBottomRow() is now api.getPinnedBottomRow()"), this.getPinnedBottomRow(e);
    }, n.prototype.setPinnedTopRowData = function(e) {
      this.pinnedRowModel.setPinnedTopRowData(e);
    }, n.prototype.setPinnedBottomRowData = function(e) {
      this.pinnedRowModel.setPinnedBottomRowData(e);
    }, n.prototype.getPinnedTopRowCount = function() {
      return this.pinnedRowModel.getPinnedTopRowCount();
    }, n.prototype.getPinnedBottomRowCount = function() {
      return this.pinnedRowModel.getPinnedBottomRowCount();
    }, n.prototype.getPinnedTopRow = function(e) {
      return this.pinnedRowModel.getPinnedTopRow(e);
    }, n.prototype.getPinnedBottomRow = function(e) {
      return this.pinnedRowModel.getPinnedBottomRow(e);
    }, n.prototype.setColumnDefs = function(e, t) {
      t === void 0 && (t = "api"), this.columnModel.setColumnDefs(e, t);
    }, n.prototype.setAutoGroupColumnDef = function(e, t) {
      this.gridOptionsWrapper.setProperty("autoGroupColumnDef", e, !0);
    }, n.prototype.setDefaultColDef = function(e, t) {
      this.gridOptionsWrapper.setProperty("defaultColDef", e, !0);
    }, n.prototype.expireValueCache = function() {
      this.valueCache.expire();
    }, n.prototype.getVerticalPixelRange = function() {
      return this.gridBodyCon.getScrollFeature().getVScrollPosition();
    }, n.prototype.getHorizontalPixelRange = function() {
      return this.gridBodyCon.getScrollFeature().getHScrollPosition();
    }, n.prototype.setAlwaysShowHorizontalScroll = function(e) {
      this.gridOptionsWrapper.setProperty("alwaysShowHorizontalScroll", e);
    }, n.prototype.setAlwaysShowVerticalScroll = function(e) {
      this.gridOptionsWrapper.setProperty("alwaysShowVerticalScroll", e);
    }, n.prototype.refreshToolPanel = function() {
      this.sideBarComp && this.sideBarComp.refresh();
    }, n.prototype.refreshCells = function(e) {
      if (e === void 0 && (e = {}), Array.isArray(e)) {
        console.warn("since AG Grid v11.1, refreshCells() now takes parameters, please see the documentation.");
        return;
      }
      this.rowRenderer.refreshCells(e);
    }, n.prototype.flashCells = function(e) {
      e === void 0 && (e = {}), this.rowRenderer.flashCells(e);
    }, n.prototype.redrawRows = function(e) {
      e === void 0 && (e = {});
      var t = e ? e.rowNodes : void 0;
      this.rowRenderer.redrawRows(t);
    }, n.prototype.setFunctionsReadOnly = function(e) {
      this.gridOptionsWrapper.setProperty("functionsReadOnly", e);
    }, n.prototype.refreshHeader = function() {
      this.ctrlsService.getHeaderRowContainerCtrls().forEach(function(e) {
        return e.refresh();
      });
    }, n.prototype.isAnyFilterPresent = function() {
      return this.filterManager.isAnyFilterPresent();
    }, n.prototype.isColumnFilterPresent = function() {
      return this.filterManager.isAdvancedFilterPresent();
    }, n.prototype.isQuickFilterPresent = function() {
      return this.filterManager.isQuickFilterPresent();
    }, n.prototype.getModel = function() {
      return this.rowModel;
    }, n.prototype.setRowNodeExpanded = function(e, t) {
      e && e.setExpanded(t);
    }, n.prototype.onGroupExpandedOrCollapsed = function(e) {
      Je(this.clientSideRowModel) && console.warn("AG Grid: cannot call onGroupExpandedOrCollapsed unless using normal row model"), de(e) && console.warn("AG Grid: api.onGroupExpandedOrCollapsed - refreshFromIndex parameter is no longer used, the grid will refresh all rows"), this.clientSideRowModel.refreshModel({ step: ea.MAP });
    }, n.prototype.refreshInMemoryRowModel = function(e) {
      console.warn("ag-grid: since version 18.x, api.refreshInMemoryRowModel() should be replaced with api.refreshClientSideRowModel()"), this.refreshClientSideRowModel(e);
    }, n.prototype.refreshClientSideRowModel = function(e) {
      Je(this.clientSideRowModel) && console.warn("cannot call refreshClientSideRowModel unless using normal row model");
      var t = ea.EVERYTHING, i = {
        group: ea.EVERYTHING,
        filter: ea.FILTER,
        map: ea.MAP,
        aggregate: ea.AGGREGATE,
        sort: ea.SORT,
        pivot: ea.PIVOT
      };
      if (de(e) && (t = i[e]), Je(t)) {
        console.error("AG Grid: invalid step " + e + ", available steps are " + Object.keys(i).join(", "));
        return;
      }
      var r = !this.gridOptionsWrapper.isSuppressAnimationFrame(), o = {
        step: t,
        keepRenderedRows: !0,
        keepEditingRows: !0,
        animate: r
      };
      this.clientSideRowModel.refreshModel(o);
    }, n.prototype.isAnimationFrameQueueEmpty = function() {
      return this.animationFrameService.isQueueEmpty();
    }, n.prototype.flushAllAnimationFrames = function() {
      this.animationFrameService.flushAllFrames();
    }, n.prototype.getRowNode = function(e) {
      return this.rowModel.getRowNode(e);
    }, n.prototype.getSizesForCurrentTheme = function() {
      return {
        rowHeight: this.gridOptionsWrapper.getRowHeightAsNumber(),
        headerHeight: this.gridOptionsWrapper.getHeaderHeight()
      };
    }, n.prototype.expandAll = function() {
      this.clientSideRowModel ? this.clientSideRowModel.expandOrCollapseAll(!0) : this.serverSideRowModel ? this.serverSideRowModel.expandAll(!0) : console.warn("AG Grid: expandAll only works with Client Side Row Model and Server Side Row Model");
    }, n.prototype.collapseAll = function() {
      this.clientSideRowModel ? this.clientSideRowModel.expandOrCollapseAll(!1) : this.serverSideRowModel ? this.serverSideRowModel.expandAll(!1) : console.warn("AG Grid: collapseAll only works with Client Side Row Model and Server Side Row Model");
    }, n.prototype.getToolPanelInstance = function(e) {
      if (!this.sideBarComp) {
        console.warn("AG Grid: toolPanel is only available in AG Grid Enterprise");
        return;
      }
      var t = this.sideBarComp.getToolPanelInstance(e);
      return Vh(t);
    }, n.prototype.addVirtualRowListener = function(e, t, i) {
      typeof e != "string" && console.warn("AG Grid: addVirtualRowListener is deprecated, please use addRenderedRowListener."), this.addRenderedRowListener(e, t, i);
    }, n.prototype.addRenderedRowListener = function(e, t, i) {
      e === "virtualRowSelected" && console.warn(`AG Grid: event virtualRowSelected is deprecated, to register for individual row
                selection events, add a listener directly to the row node.`), this.rowRenderer.addRenderedRowListener(e, t, i);
    }, n.prototype.setQuickFilter = function(e) {
      this.filterManager.setQuickFilter(e);
    }, n.prototype.selectIndex = function(e, t, i) {
      console.warn("AG Grid: do not use api for selection, call node.setSelected(value) instead"), i && console.warn("AG Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it"), this.selectionService.selectIndex(e, t);
    }, n.prototype.deselectIndex = function(e, t) {
      t === void 0 && (t = !1), console.warn("AG Grid: do not use api for selection, call node.setSelected(value) instead"), t && console.warn("AG Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it"), this.selectionService.deselectIndex(e);
    }, n.prototype.selectNode = function(e, t, i) {
      t === void 0 && (t = !1), i === void 0 && (i = !1), console.warn("AG Grid: API for selection is deprecated, call node.setSelected(value) instead"), i && console.warn("AG Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it"), e.setSelectedParams({ newValue: !0, clearSelection: !t });
    }, n.prototype.deselectNode = function(e, t) {
      t === void 0 && (t = !1), console.warn("AG Grid: API for selection is deprecated, call node.setSelected(value) instead"), t && console.warn("AG Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it"), e.setSelectedParams({ newValue: !1 });
    }, n.prototype.selectAll = function() {
      this.selectionService.selectAllRowNodes();
    }, n.prototype.deselectAll = function() {
      this.selectionService.deselectAllRowNodes();
    }, n.prototype.selectAllFiltered = function() {
      this.selectionService.selectAllRowNodes(!0);
    }, n.prototype.deselectAllFiltered = function() {
      this.selectionService.deselectAllRowNodes(!0);
    }, n.prototype.recomputeAggregates = function() {
      Je(this.clientSideRowModel) && console.warn("cannot call recomputeAggregates unless using normal row model"), console.warn("recomputeAggregates is deprecated, please call api.refreshClientSideRowModel('aggregate') instead"), this.clientSideRowModel.refreshModel({ step: ea.AGGREGATE });
    }, n.prototype.sizeColumnsToFit = function() {
      this.gridBodyCon.sizeColumnsToFit();
    }, n.prototype.showLoadingOverlay = function() {
      this.overlayWrapperComp.showLoadingOverlay();
    }, n.prototype.showNoRowsOverlay = function() {
      this.overlayWrapperComp.showNoRowsOverlay();
    }, n.prototype.hideOverlay = function() {
      this.overlayWrapperComp.hideOverlay();
    }, n.prototype.isNodeSelected = function(e) {
      return console.warn("AG Grid: no need to call api.isNodeSelected(), just call node.isSelected() instead"), e.isSelected();
    }, n.prototype.getSelectedNodesById = function() {
      return console.error("AG Grid: since version 3.4, getSelectedNodesById no longer exists, use getSelectedNodes() instead"), null;
    }, n.prototype.getSelectedNodes = function() {
      return this.selectionService.getSelectedNodes();
    }, n.prototype.getSelectedRows = function() {
      return this.selectionService.getSelectedRows();
    }, n.prototype.getBestCostNodeSelection = function() {
      return this.selectionService.getBestCostNodeSelection();
    }, n.prototype.getRenderedNodes = function() {
      return this.rowRenderer.getRenderedNodes();
    }, n.prototype.ensureColIndexVisible = function(e) {
      console.warn("AG Grid: ensureColIndexVisible(index) no longer supported, use ensureColumnVisible(colKey) instead.");
    }, n.prototype.ensureColumnVisible = function(e, t) {
      t === void 0 && (t = "auto"), this.gridBodyCon.getScrollFeature().ensureColumnVisible(e, t);
    }, n.prototype.ensureIndexVisible = function(e, t) {
      this.gridBodyCon.getScrollFeature().ensureIndexVisible(e, t);
    }, n.prototype.ensureNodeVisible = function(e, t) {
      t === void 0 && (t = null), this.gridBodyCon.getScrollFeature().ensureNodeVisible(e, t);
    }, n.prototype.forEachLeafNode = function(e) {
      Je(this.clientSideRowModel) && console.warn("cannot call forEachNode unless using normal row model"), this.clientSideRowModel.forEachLeafNode(e);
    }, n.prototype.forEachNode = function(e) {
      this.rowModel.forEachNode(e);
    }, n.prototype.forEachNodeAfterFilter = function(e) {
      Je(this.clientSideRowModel) && console.warn("cannot call forEachNodeAfterFilter unless using normal row model"), this.clientSideRowModel.forEachNodeAfterFilter(e);
    }, n.prototype.forEachNodeAfterFilterAndSort = function(e) {
      Je(this.clientSideRowModel) && console.warn("cannot call forEachNodeAfterFilterAndSort unless using normal row model"), this.clientSideRowModel.forEachNodeAfterFilterAndSort(e);
    }, n.prototype.getFilterInstance = function(e, t) {
      var i = this.getFilterInstanceImpl(e, function(o) {
        if (t) {
          var s = Vh(o);
          t(s);
        }
      }), r = Vh(i);
      return r;
    }, n.prototype.getFilterInstanceImpl = function(e, t) {
      var i = this.columnModel.getPrimaryColumn(e);
      if (i) {
        var r = this.filterManager.getFilterComponent(i, "NO_UI"), o = r && r.resolveNow(null, function(s) {
          return s;
        });
        return o ? setTimeout(t, 0, o) : r && r.then(function(s) {
          t(s);
        }), o;
      }
    }, n.prototype.destroyFilter = function(e) {
      var t = this.columnModel.getPrimaryColumn(e);
      if (t)
        return this.filterManager.destroyFilter(t, "filterDestroyed");
    }, n.prototype.getStatusPanel = function(e) {
      if (this.statusBarService) {
        var t = this.statusBarService.getStatusPanel(e);
        return Vh(t);
      }
    }, n.prototype.getColumnDef = function(e) {
      var t = this.columnModel.getPrimaryColumn(e);
      return t ? t.getColDef() : null;
    }, n.prototype.getColumnDefs = function() {
      return this.columnModel.getColumnDefs();
    }, n.prototype.onFilterChanged = function() {
      this.filterManager.onFilterChanged();
    }, n.prototype.onSortChanged = function() {
      this.sortController.onSortChanged();
    }, n.prototype.setFilterModel = function(e) {
      this.filterManager.setFilterModel(e);
    }, n.prototype.getFilterModel = function() {
      return this.filterManager.getFilterModel();
    }, n.prototype.getFocusedCell = function() {
      return this.focusService.getFocusedCell();
    }, n.prototype.clearFocusedCell = function() {
      return this.focusService.clearFocusedCell();
    }, n.prototype.setFocusedCell = function(e, t, i) {
      this.focusService.setFocusedCell(e, t, i, !0);
    }, n.prototype.setSuppressRowDrag = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_SUPPRESS_ROW_DRAG, e);
    }, n.prototype.setSuppressMoveWhenRowDragging = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_SUPPRESS_MOVE_WHEN_ROW_DRAG, e);
    }, n.prototype.setSuppressRowClickSelection = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_SUPPRESS_ROW_CLICK_SELECTION, e);
    }, n.prototype.addRowDropZone = function(e) {
      this.gridBodyCon.getRowDragFeature().addRowDropZone(e);
    }, n.prototype.removeRowDropZone = function(e) {
      var t = this.dragAndDropService.findExternalZone(e);
      t && this.dragAndDropService.removeDropTarget(t);
    }, n.prototype.getRowDropZoneParams = function(e) {
      return this.gridBodyCon.getRowDragFeature().getRowDropZone(e);
    }, n.prototype.setHeaderHeight = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_HEADER_HEIGHT, e);
    }, n.prototype.setDomLayout = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_DOM_LAYOUT, e);
    }, n.prototype.setEnableCellTextSelection = function(e) {
      this.gridBodyCon.setCellTextSelection(e);
    }, n.prototype.setFillHandleDirection = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_FILL_HANDLE_DIRECTION, e);
    }, n.prototype.setGroupHeaderHeight = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GROUP_HEADER_HEIGHT, e);
    }, n.prototype.setFloatingFiltersHeight = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_FLOATING_FILTERS_HEIGHT, e);
    }, n.prototype.setPivotHeaderHeight = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_PIVOT_HEADER_HEIGHT, e);
    }, n.prototype.setPivotGroupHeaderHeight = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_PIVOT_GROUP_HEADER_HEIGHT, e);
    }, n.prototype.setIsExternalFilterPresent = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_IS_EXTERNAL_FILTER_PRESENT, e);
    }, n.prototype.setDoesExternalFilterPass = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_DOES_EXTERNAL_FILTER_PASS, e);
    }, n.prototype.setNavigateToNextCell = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_NAVIGATE_TO_NEXT_CELL, e);
    }, n.prototype.setTabToNextCell = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_TAB_TO_NEXT_CELL, e);
    }, n.prototype.setTabToNextHeader = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_TAB_TO_NEXT_HEADER, e);
    }, n.prototype.setNavigateToNextHeader = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_NAVIGATE_TO_NEXT_HEADER, e);
    }, n.prototype.setGroupRowAggNodes = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GROUP_ROW_AGG_NODES, e);
    }, n.prototype.setGetBusinessKeyForNode = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_BUSINESS_KEY_FOR_NODE, e);
    }, n.prototype.setGetChildCount = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_CHILD_COUNT, e);
    }, n.prototype.setProcessRowPostCreate = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_PROCESS_ROW_POST_CREATE, e);
    }, n.prototype.setGetRowNodeId = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_ROW_NODE_ID, e);
    }, n.prototype.setGetRowClass = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_ROW_CLASS, e);
    }, n.prototype.setIsFullWidthCell = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_IS_FULL_WIDTH_CELL, e);
    }, n.prototype.setIsRowSelectable = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_IS_ROW_SELECTABLE, e);
    }, n.prototype.setIsRowMaster = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_IS_ROW_MASTER, e);
    }, n.prototype.setPostSort = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_POST_SORT, e);
    }, n.prototype.setGetDocument = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_DOCUMENT, e);
    }, n.prototype.setGetContextMenuItems = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_CONTEXT_MENU_ITEMS, e);
    }, n.prototype.setGetMainMenuItems = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_MAIN_MENU_ITEMS, e);
    }, n.prototype.setProcessCellForClipboard = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_PROCESS_CELL_FOR_CLIPBOARD, e);
    }, n.prototype.setSendToClipboard = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_SEND_TO_CLIPBOARD, e);
    }, n.prototype.setProcessCellFromClipboard = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_PROCESS_CELL_FROM_CLIPBOARD, e);
    }, n.prototype.setProcessSecondaryColDef = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_PROCESS_TO_SECONDARY_COLDEF, e);
    }, n.prototype.setProcessSecondaryColGroupDef = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_PROCESS_SECONDARY_COL_GROUP_DEF, e);
    }, n.prototype.setPostProcessPopup = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_POST_PROCESS_POPUP, e);
    }, n.prototype.setDefaultGroupOrderComparator = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_DEFAULT_GROUP_ORDER_COMPARATOR, e);
    }, n.prototype.setGetChartToolbarItems = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_CHART_TOOLBAR_ITEMS, e);
    }, n.prototype.setPaginationNumberFormatter = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_PAGINATION_NUMBER_FORMATTER, e);
    }, n.prototype.setGetServerSideStoreParams = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_SERVER_SIDE_STORE_PARAMS, e);
    }, n.prototype.setIsServerSideGroupOpenByDefault = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_IS_SERVER_SIDE_GROUPS_OPEN_BY_DEFAULT, e);
    }, n.prototype.setIsApplyServerSideTransaction = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_IS_APPLY_SERVER_SIDE_TRANSACTION, e);
    }, n.prototype.setIsServerSideGroup = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_IS_SERVER_SIDE_GROUP, e);
    }, n.prototype.setGetServerSideGroupKey = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_SERVER_SIDE_GROUP_KEY, e);
    }, n.prototype.setGetRowStyle = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_ROW_STYLE, e);
    }, n.prototype.setGetRowHeight = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GET_ROW_HEIGHT, e);
    }, n.prototype.isSideBarVisible = function() {
      return this.sideBarComp ? this.sideBarComp.isDisplayed() : !1;
    }, n.prototype.setSideBarVisible = function(e) {
      if (!this.sideBarComp) {
        e && console.warn("AG Grid: sideBar is not loaded");
        return;
      }
      this.sideBarComp.setDisplayed(e);
    }, n.prototype.setSideBarPosition = function(e) {
      if (!this.sideBarComp) {
        console.warn("AG Grid: sideBar is not loaded");
        return;
      }
      this.sideBarComp.setSideBarPosition(e);
    }, n.prototype.openToolPanel = function(e) {
      if (!this.sideBarComp) {
        console.warn("AG Grid: toolPanel is only available in AG Grid Enterprise");
        return;
      }
      this.sideBarComp.openToolPanel(e);
    }, n.prototype.closeToolPanel = function() {
      if (!this.sideBarComp) {
        console.warn("AG Grid: toolPanel is only available in AG Grid Enterprise");
        return;
      }
      this.sideBarComp.close();
    }, n.prototype.getOpenedToolPanel = function() {
      return this.sideBarComp ? this.sideBarComp.openedItem() : null;
    }, n.prototype.getSideBar = function() {
      return this.gridOptionsWrapper.getSideBar();
    }, n.prototype.setSideBar = function(e) {
      this.gridOptionsWrapper.setProperty("sideBar", oH.parse(e));
    }, n.prototype.setSuppressClipboardPaste = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_SUPPRESS_CLIPBOARD_PASTE, e);
    }, n.prototype.isToolPanelShowing = function() {
      return this.sideBarComp.isToolPanelShowing();
    }, n.prototype.doLayout = function() {
      var e = "AG Grid - since version 25.1, doLayout was taken out, as it's not needed. The grid responds to grid size changes automatically";
      mi(function() {
        return console.warn(e);
      }, "doLayoutDeprecated");
    }, n.prototype.resetRowHeights = function() {
      if (de(this.clientSideRowModel)) {
        if (this.columnModel.isAutoRowHeightActive()) {
          console.warn("AG Grid: calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
          return;
        }
        this.clientSideRowModel.resetRowHeights();
      }
    }, n.prototype.setGroupRemoveSingleChildren = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GROUP_REMOVE_SINGLE_CHILDREN, e);
    }, n.prototype.setGroupRemoveLowestSingleChildren = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN, e);
    }, n.prototype.onRowHeightChanged = function() {
      this.clientSideRowModel ? this.clientSideRowModel.onRowHeightChanged() : this.serverSideRowModel && this.serverSideRowModel.onRowHeightChanged();
    }, n.prototype.getValue = function(e, t) {
      var i = this.columnModel.getPrimaryColumn(e);
      return Je(i) && (i = this.columnModel.getGridColumn(e)), Je(i) ? null : this.valueService.getValue(i, t);
    }, n.prototype.addEventListener = function(e, t) {
      var i = this.gridOptionsWrapper.useAsyncEvents();
      this.eventService.addEventListener(e, t, i);
    }, n.prototype.addGlobalListener = function(e) {
      var t = this.gridOptionsWrapper.useAsyncEvents();
      this.eventService.addGlobalListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      var i = this.gridOptionsWrapper.useAsyncEvents();
      this.eventService.removeEventListener(e, t, i);
    }, n.prototype.removeGlobalListener = function(e) {
      var t = this.gridOptionsWrapper.useAsyncEvents();
      this.eventService.removeGlobalListener(e, t);
    }, n.prototype.dispatchEvent = function(e) {
      this.eventService.dispatchEvent(e);
    }, n.prototype.destroy = function() {
      if (!this.destroyCalled) {
        this.destroyCalled = !0;
        var e = this.ctrlsService.getGridCtrl();
        e && e.destroyGridUi(), this.context.destroy();
      }
    }, n.prototype.cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid = function() {
      setTimeout(BV.bind(window, this, "Grid API"), 100);
    }, n.prototype.warnIfDestroyed = function(e) {
      return this.destroyCalled && console.warn("AG Grid: Grid API method " + e + " was called on a grid that was destroyed."), this.destroyCalled;
    }, n.prototype.resetQuickFilter = function() {
      this.warnIfDestroyed("resetQuickFilter") || this.rowModel.forEachNode(function(e) {
        return e.quickFilterAggregateText = null;
      });
    }, n.prototype.getRangeSelections = function() {
      return console.warn(`AG Grid: in v20.1.x, api.getRangeSelections() is gone, please use getCellRanges() instead.
        We had to change how cell selections works a small bit to allow charting to integrate. The return type of
        getCellRanges() is a bit different, please check the AG Grid documentation.`), null;
    }, n.prototype.getCellRanges = function() {
      return this.rangeService ? this.rangeService.getCellRanges() : (console.warn("AG Grid: cell range selection is only available in AG Grid Enterprise"), null);
    }, n.prototype.camelCaseToHumanReadable = function(e) {
      return YO(e);
    }, n.prototype.addRangeSelection = function(e) {
      console.warn("AG Grid: As of version 21.x, range selection changed slightly to allow charting integration. Please call api.addCellRange() instead of api.addRangeSelection()");
    }, n.prototype.addCellRange = function(e) {
      this.rangeService || console.warn("AG Grid: cell range selection is only available in AG Grid Enterprise"), this.rangeService.addCellRange(e);
    }, n.prototype.clearRangeSelection = function() {
      this.rangeService || console.warn("AG Grid: cell range selection is only available in AG Grid Enterprise"), this.rangeService.removeAllCellRanges();
    }, n.prototype.undoCellEditing = function() {
      this.undoRedoService.undo();
    }, n.prototype.redoCellEditing = function() {
      this.undoRedoService.redo();
    }, n.prototype.getCurrentUndoSize = function() {
      return this.undoRedoService.getCurrentUndoStackSize();
    }, n.prototype.getCurrentRedoSize = function() {
      return this.undoRedoService.getCurrentRedoStackSize();
    }, n.prototype.getChartModels = function() {
      if (pt.assertRegistered(ct.RangeSelectionModule, "api.getChartModels") && pt.assertRegistered(ct.GridChartsModule, "api.getChartModels"))
        return this.chartService.getChartModels();
    }, n.prototype.getChartRef = function(e) {
      if (pt.assertRegistered(ct.RangeSelectionModule, "api.getChartRef") && pt.assertRegistered(ct.GridChartsModule, "api.getChartRef"))
        return this.chartService.getChartRef(e);
    }, n.prototype.getChartImageDataURL = function(e) {
      if (pt.assertRegistered(ct.RangeSelectionModule, "api.getChartImageDataURL") && pt.assertRegistered(ct.GridChartsModule, "api.getChartImageDataURL"))
        return this.chartService.getChartImageDataURL(e);
    }, n.prototype.createRangeChart = function(e) {
      if (pt.assertRegistered(ct.RangeSelectionModule, "api.createRangeChart") && pt.assertRegistered(ct.GridChartsModule, "api.createRangeChart"))
        return this.chartService.createRangeChart(e);
    }, n.prototype.createCrossFilterChart = function(e) {
      if (pt.assertRegistered(ct.RangeSelectionModule, "api.createCrossFilterChart") && pt.assertRegistered(ct.GridChartsModule, "api.createCrossFilterChart"))
        return this.chartService.createCrossFilterChart(e);
    }, n.prototype.restoreChart = function(e, t) {
      if (pt.assertRegistered(ct.RangeSelectionModule, "api.restoreChart") && pt.assertRegistered(ct.GridChartsModule, "api.restoreChart"))
        return this.chartService.restoreChart(e, t);
    }, n.prototype.createPivotChart = function(e) {
      if (pt.assertRegistered(ct.RangeSelectionModule, "api.createPivotChart") && pt.assertRegistered(ct.GridChartsModule, "api.createPivotChart"))
        return this.chartService.createPivotChart(e);
    }, n.prototype.copySelectedRowsToClipboard = function(e) {
      this.clipboardService || console.warn("AG Grid: clipboard is only available in AG Grid Enterprise"), this.clipboardService.copySelectedRowsToClipboard(e);
    }, n.prototype.copySelectedRangeToClipboard = function(e) {
      this.clipboardService || console.warn("AG Grid: clipboard is only available in AG Grid Enterprise"), this.clipboardService.copySelectedRangeToClipboard(e);
    }, n.prototype.copySelectedRangeDown = function() {
      this.clipboardService || console.warn("AG Grid: clipboard is only available in AG Grid Enterprise"), this.clipboardService.copyRangeDown();
    }, n.prototype.showColumnMenuAfterButtonClick = function(e, t) {
      var i = this.columnModel.getGridColumn(e);
      this.menuFactory.showMenuAfterButtonClick(i, t, "columnMenu");
    }, n.prototype.showColumnMenuAfterMouseClick = function(e, t) {
      var i = this.columnModel.getGridColumn(e);
      if (i || (i = this.columnModel.getPrimaryColumn(e)), !i) {
        console.error("AG Grid: column '" + e + "' not found");
        return;
      }
      this.menuFactory.showMenuAfterMouseEvent(i, t);
    }, n.prototype.hidePopupMenu = function() {
      this.contextMenuFactory && this.contextMenuFactory.hideActiveMenu(), this.menuFactory.hideActiveMenu();
    }, n.prototype.setPopupParent = function(e) {
      this.gridOptionsWrapper.setProperty(Ve.PROP_POPUP_PARENT, e);
    }, n.prototype.tabToNextCell = function(e) {
      return this.navigationService.tabToNextCell(!1, e);
    }, n.prototype.tabToPreviousCell = function(e) {
      return this.navigationService.tabToNextCell(!0, e);
    }, n.prototype.getCellRendererInstances = function(e) {
      e === void 0 && (e = {});
      var t = this.rowRenderer.getCellRendererInstances(e), i = t.map(Vh);
      return i;
    }, n.prototype.getCellEditorInstances = function(e) {
      e === void 0 && (e = {});
      var t = this.rowRenderer.getCellEditorInstances(e), i = t.map(Vh);
      return i;
    }, n.prototype.getEditingCells = function() {
      return this.rowRenderer.getEditingCells();
    }, n.prototype.stopEditing = function(e) {
      e === void 0 && (e = !1), this.rowRenderer.stopEditing(e);
    }, n.prototype.startEditingCell = function(e) {
      var t = this.columnModel.getGridColumn(e.colKey);
      if (!t) {
        console.warn("AG Grid: no column found for " + e.colKey);
        return;
      }
      var i = {
        rowIndex: e.rowIndex,
        rowPinned: e.rowPinned || null,
        column: t
      }, r = e.rowPinned == null;
      r && this.gridBodyCon.getScrollFeature().ensureIndexVisible(e.rowIndex);
      var o = this.navigationService.getCellByPosition(i);
      o && o.startRowOrCellEdit(e.key, e.charPress);
    }, n.prototype.addAggFunc = function(e, t) {
      this.aggFuncService && this.aggFuncService.addAggFunc(e, t);
    }, n.prototype.addAggFuncs = function(e) {
      this.aggFuncService && this.aggFuncService.addAggFuncs(e);
    }, n.prototype.clearAggFuncs = function() {
      this.aggFuncService && this.aggFuncService.clear();
    }, n.prototype.applyServerSideTransaction = function(e) {
      if (!this.serverSideTransactionManager) {
        console.warn("AG Grid: Cannot apply Server Side Transaction if not using the Server Side Row Model.");
        return;
      }
      return this.serverSideTransactionManager.applyTransaction(e);
    }, n.prototype.applyServerSideTransactionAsync = function(e, t) {
      if (!this.serverSideTransactionManager) {
        console.warn("AG Grid: Cannot apply Server Side Transaction if not using the Server Side Row Model.");
        return;
      }
      return this.serverSideTransactionManager.applyTransactionAsync(e, t);
    }, n.prototype.retryServerSideLoads = function() {
      if (!this.serverSideRowModel) {
        console.warn("AG Grid: API retryServerSideLoads() can only be used when using Server-Side Row Model.");
        return;
      }
      this.serverSideRowModel.retryLoads();
    }, n.prototype.flushServerSideAsyncTransactions = function() {
      if (!this.serverSideTransactionManager) {
        console.warn("AG Grid: Cannot flush Server Side Transaction if not using the Server Side Row Model.");
        return;
      }
      return this.serverSideTransactionManager.flushAsyncTransactions();
    }, n.prototype.applyTransaction = function(e) {
      if (!this.clientSideRowModel) {
        console.error("AG Grid: updateRowData() only works with ClientSideRowModel. Working with InfiniteRowModel was deprecated in v23.1 and removed in v24.1");
        return;
      }
      var t = this.clientSideRowModel.updateRowData(e);
      return this.rowRenderer.refreshFullWidthRows(t.update), this.gridOptionsWrapper.isSuppressChangeDetection() || this.rowRenderer.refreshCells(), t;
    }, n.prototype.updateRowData = function(e) {
      var t = "AG Grid: as of v23.1, grid API updateRowData(transaction) is now called applyTransaction(transaction). updateRowData is deprecated and will be removed in a future major release.";
      return mi(function() {
        return console.warn(t);
      }, "updateRowData deprecated"), this.applyTransaction(e);
    }, n.prototype.applyTransactionAsync = function(e, t) {
      if (!this.clientSideRowModel) {
        console.error("AG Grid: api.applyTransactionAsync() only works with ClientSideRowModel.");
        return;
      }
      this.clientSideRowModel.batchUpdateRowData(e, t);
    }, n.prototype.flushAsyncTransactions = function() {
      if (!this.clientSideRowModel) {
        console.error("AG Grid: api.applyTransactionAsync() only works with ClientSideRowModel.");
        return;
      }
      this.clientSideRowModel.flushAsyncTransactions();
    }, n.prototype.batchUpdateRowData = function(e, t) {
      var i = "AG Grid: as of v23.1, grid API batchUpdateRowData(transaction, callback) is now called applyTransactionAsync(transaction, callback). batchUpdateRowData is deprecated and will be removed in a future major release.";
      mi(function() {
        return console.warn(i);
      }, "batchUpdateRowData deprecated"), this.applyTransactionAsync(e, t);
    }, n.prototype.insertItemsAtIndex = function(e, t, i) {
      console.warn("AG Grid: insertItemsAtIndex() is deprecated, use updateRowData(transaction) instead."), this.updateRowData({ add: t, addIndex: e, update: null, remove: null });
    }, n.prototype.removeItems = function(e, t) {
      console.warn("AG Grid: removeItems() is deprecated, use updateRowData(transaction) instead.");
      var i = e.map(function(r) {
        return r.data;
      });
      this.updateRowData({ add: null, addIndex: null, update: null, remove: i });
    }, n.prototype.addItems = function(e, t) {
      console.warn("AG Grid: addItems() is deprecated, use updateRowData(transaction) instead."), this.updateRowData({ add: e, addIndex: null, update: null, remove: null });
    }, n.prototype.refreshVirtualPageCache = function() {
      console.warn("AG Grid: refreshVirtualPageCache() is now called refreshInfiniteCache(), please call refreshInfiniteCache() instead"), this.refreshInfiniteCache();
    }, n.prototype.refreshInfinitePageCache = function() {
      console.warn("AG Grid: refreshInfinitePageCache() is now called refreshInfiniteCache(), please call refreshInfiniteCache() instead"), this.refreshInfiniteCache();
    }, n.prototype.refreshInfiniteCache = function() {
      this.infiniteRowModel ? this.infiniteRowModel.refreshCache() : console.warn("AG Grid: api.refreshInfiniteCache is only available when rowModelType='infinite'.");
    }, n.prototype.purgeVirtualPageCache = function() {
      console.warn("AG Grid: purgeVirtualPageCache() is now called purgeInfiniteCache(), please call purgeInfiniteCache() instead"), this.purgeInfinitePageCache();
    }, n.prototype.purgeInfinitePageCache = function() {
      console.warn("AG Grid: purgeInfinitePageCache() is now called purgeInfiniteCache(), please call purgeInfiniteCache() instead"), this.purgeInfiniteCache();
    }, n.prototype.purgeInfiniteCache = function() {
      this.infiniteRowModel ? this.infiniteRowModel.purgeCache() : console.warn("AG Grid: api.purgeInfiniteCache is only available when rowModelType='infinite'.");
    }, n.prototype.purgeEnterpriseCache = function(e) {
      console.warn("ag-grid: since version 18.x, api.purgeEnterpriseCache() should be replaced with api.purgeServerSideCache()"), this.purgeServerSideCache(e);
    }, n.prototype.purgeServerSideCache = function(e) {
      e === void 0 && (e = []), this.serverSideRowModel ? (console.warn("AG Grid: since v25.0, api.purgeServerSideCache is deprecated. Please use api.refreshServerSideStore({purge: true}) instead."), this.refreshServerSideStore({
        route: e,
        purge: !0
      })) : console.warn("AG Grid: api.purgeServerSideCache is only available when rowModelType='serverSide'.");
    }, n.prototype.refreshServerSideStore = function(e) {
      this.serverSideRowModel ? this.serverSideRowModel.refreshStore(e) : console.warn("AG Grid: api.refreshServerSideStore is only available when rowModelType='serverSide'.");
    }, n.prototype.getServerSideStoreState = function() {
      return this.serverSideRowModel ? this.serverSideRowModel.getStoreState() : (console.warn("AG Grid: api.getServerSideStoreState is only available when rowModelType='serverSide'."), []);
    }, n.prototype.getVirtualRowCount = function() {
      return console.warn("AG Grid: getVirtualRowCount() is now called getInfiniteRowCount(), please call getInfiniteRowCount() instead"), this.getInfiniteRowCount();
    }, n.prototype.getInfiniteRowCount = function() {
      if (this.infiniteRowModel)
        return this.infiniteRowModel.getRowCount();
      console.warn("AG Grid: api.getVirtualRowCount is only available when rowModelType='virtual'.");
    }, n.prototype.isMaxRowFound = function() {
      return console.warn("AG Grid: api.isLastRowIndexKnown is deprecated, please use api.isLastRowIndexKnown()"), this.isLastRowIndexKnown();
    }, n.prototype.isLastRowIndexKnown = function() {
      if (this.infiniteRowModel)
        return this.infiniteRowModel.isLastRowIndexKnown();
      console.warn("AG Grid: api.isMaxRowFound is only available when rowModelType='virtual'.");
    }, n.prototype.setVirtualRowCount = function(e, t) {
      console.warn("AG Grid: setVirtualRowCount() is now called setInfiniteRowCount(), please call setInfiniteRowCount() instead"), this.setRowCount(e, t);
    }, n.prototype.setInfiniteRowCount = function(e, t) {
      console.warn("AG Grid: setInfiniteRowCount() is now called setRowCount(), please call setRowCount() instead"), this.setRowCount(e, t);
    }, n.prototype.setRowCount = function(e, t) {
      this.infiniteRowModel ? this.infiniteRowModel.setRowCount(e, t) : console.warn("AG Grid: api.setRowCount is only available for Infinite Row Model.");
    }, n.prototype.getVirtualPageState = function() {
      return console.warn("AG Grid: getVirtualPageState() is now called getCacheBlockState(), please call getCacheBlockState() instead"), this.getCacheBlockState();
    }, n.prototype.getInfinitePageState = function() {
      return console.warn("AG Grid: getInfinitePageState() is now called getCacheBlockState(), please call getCacheBlockState() instead"), this.getCacheBlockState();
    }, n.prototype.getCacheBlockState = function() {
      return this.rowNodeBlockLoader.getBlockState();
    }, n.prototype.checkGridSize = function() {
      console.warn("in AG Grid v25.2.0, checkGridSize() was removed, as it was legacy and didn't do anything uesful.");
    }, n.prototype.getFirstRenderedRow = function() {
      return console.warn("in AG Grid v12, getFirstRenderedRow() was renamed to getFirstDisplayedRow()"), this.getFirstDisplayedRow();
    }, n.prototype.getFirstDisplayedRow = function() {
      return this.rowRenderer.getFirstVirtualRenderedRow();
    }, n.prototype.getLastRenderedRow = function() {
      return console.warn("in AG Grid v12, getLastRenderedRow() was renamed to getLastDisplayedRow()"), this.getLastDisplayedRow();
    }, n.prototype.getLastDisplayedRow = function() {
      return this.rowRenderer.getLastVirtualRenderedRow();
    }, n.prototype.getDisplayedRowAtIndex = function(e) {
      return this.rowModel.getRow(e);
    }, n.prototype.getDisplayedRowCount = function() {
      return this.rowModel.getRowCount();
    }, n.prototype.paginationIsLastPageFound = function() {
      return this.paginationProxy.isLastPageFound();
    }, n.prototype.paginationGetPageSize = function() {
      return this.paginationProxy.getPageSize();
    }, n.prototype.paginationSetPageSize = function(e) {
      this.gridOptionsWrapper.setProperty("paginationPageSize", e);
    }, n.prototype.paginationGetCurrentPage = function() {
      return this.paginationProxy.getCurrentPage();
    }, n.prototype.paginationGetTotalPages = function() {
      return this.paginationProxy.getTotalPages();
    }, n.prototype.paginationGetRowCount = function() {
      return this.paginationProxy.getMasterRowCount();
    }, n.prototype.paginationGoToNextPage = function() {
      this.paginationProxy.goToNextPage();
    }, n.prototype.paginationGoToPreviousPage = function() {
      this.paginationProxy.goToPreviousPage();
    }, n.prototype.paginationGoToFirstPage = function() {
      this.paginationProxy.goToFirstPage();
    }, n.prototype.paginationGoToLastPage = function() {
      this.paginationProxy.goToLastPage();
    }, n.prototype.paginationGoToPage = function(e) {
      this.paginationProxy.goToPage(e);
    }, Ht([
      fi("immutableService")
    ], n.prototype, "immutableService", void 0), Ht([
      fi("csvCreator")
    ], n.prototype, "csvCreator", void 0), Ht([
      fi("excelCreator")
    ], n.prototype, "excelCreator", void 0), Ht([
      R("rowRenderer")
    ], n.prototype, "rowRenderer", void 0), Ht([
      R("navigationService")
    ], n.prototype, "navigationService", void 0), Ht([
      R("filterManager")
    ], n.prototype, "filterManager", void 0), Ht([
      R("columnModel")
    ], n.prototype, "columnModel", void 0), Ht([
      R("selectionService")
    ], n.prototype, "selectionService", void 0), Ht([
      R("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), Ht([
      R("valueService")
    ], n.prototype, "valueService", void 0), Ht([
      R("alignedGridsService")
    ], n.prototype, "alignedGridsService", void 0), Ht([
      R("eventService")
    ], n.prototype, "eventService", void 0), Ht([
      R("pinnedRowModel")
    ], n.prototype, "pinnedRowModel", void 0), Ht([
      R("context")
    ], n.prototype, "context", void 0), Ht([
      R("rowModel")
    ], n.prototype, "rowModel", void 0), Ht([
      R("sortController")
    ], n.prototype, "sortController", void 0), Ht([
      R("paginationProxy")
    ], n.prototype, "paginationProxy", void 0), Ht([
      R("focusService")
    ], n.prototype, "focusService", void 0), Ht([
      R("dragAndDropService")
    ], n.prototype, "dragAndDropService", void 0), Ht([
      fi("rangeService")
    ], n.prototype, "rangeService", void 0), Ht([
      fi("clipboardService")
    ], n.prototype, "clipboardService", void 0), Ht([
      fi("aggFuncService")
    ], n.prototype, "aggFuncService", void 0), Ht([
      R("menuFactory")
    ], n.prototype, "menuFactory", void 0), Ht([
      fi("contextMenuFactory")
    ], n.prototype, "contextMenuFactory", void 0), Ht([
      R("valueCache")
    ], n.prototype, "valueCache", void 0), Ht([
      R("animationFrameService")
    ], n.prototype, "animationFrameService", void 0), Ht([
      fi("statusBarService")
    ], n.prototype, "statusBarService", void 0), Ht([
      fi("chartService")
    ], n.prototype, "chartService", void 0), Ht([
      fi("undoRedoService")
    ], n.prototype, "undoRedoService", void 0), Ht([
      fi("rowNodeBlockLoader")
    ], n.prototype, "rowNodeBlockLoader", void 0), Ht([
      fi("ssrmTransactionManager")
    ], n.prototype, "serverSideTransactionManager", void 0), Ht([
      R("ctrlsService")
    ], n.prototype, "ctrlsService", void 0), Ht([
      fi("frameworkComponentWrapper")
    ], n.prototype, "frameworkComponentWrapper", void 0), Ht([
      Ee
    ], n.prototype, "init", null), Ht([
      Lo
    ], n.prototype, "cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid", null), n = Ht([
      Ke("gridApi")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var NY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), IY = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, TS = (
  /** @class */
  function(n) {
    NY(e, n);
    function e(t, i, r, o) {
      var s = n.call(this) || this;
      return s.columnOrGroup = t, s.eCell = i, s.ariaEl = s.eCell.querySelector("[role=columnheader]") || s.eCell, s.colsSpanning = o, s.beans = r, s;
    }
    return e.prototype.setColsSpanning = function(t) {
      this.colsSpanning = t, this.onLeftChanged();
    }, e.prototype.getColumnOrGroup = function() {
      return this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning ? Di(this.colsSpanning) : this.columnOrGroup;
    }, e.prototype.postConstruct = function() {
      this.addManagedListener(this.columnOrGroup, Gt.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this)), this.setLeftFirstTime(), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onLeftChanged.bind(this)), this.addManagedListener(this.beans.gridOptionsWrapper, Ve.PROP_DOM_LAYOUT, this.onLeftChanged.bind(this));
    }, e.prototype.setLeftFirstTime = function() {
      var t = this.beans.gridOptionsWrapper.isSuppressColumnMoveAnimation(), i = de(this.columnOrGroup.getOldLeft()), r = this.beans.columnAnimationService.isActive() && i && !t;
      r ? this.animateInLeft() : this.onLeftChanged();
    }, e.prototype.animateInLeft = function() {
      var t = this, i = this.getColumnOrGroup(), r = i.getLeft(), o = i.getOldLeft(), s = this.modifyLeftForPrintLayout(i, o), a = this.modifyLeftForPrintLayout(i, r);
      this.setLeft(s), this.actualLeft = a, this.beans.columnAnimationService.executeNextVMTurn(function() {
        t.actualLeft === a && t.setLeft(a);
      });
    }, e.prototype.onLeftChanged = function() {
      var t = this.getColumnOrGroup(), i = t.getLeft();
      this.actualLeft = this.modifyLeftForPrintLayout(t, i), this.setLeft(this.actualLeft);
    }, e.prototype.modifyLeftForPrintLayout = function(t, i) {
      var r = this.beans.gridOptionsWrapper.getDomLayout() === q.DOM_LAYOUT_PRINT;
      if (!r || t.getPinned() === q.PINNED_LEFT)
        return i;
      var o = this.beans.columnModel.getDisplayedColumnsLeftWidth();
      if (t.getPinned() === q.PINNED_RIGHT) {
        var s = this.beans.columnModel.getBodyContainerWidth();
        return o + s + i;
      }
      return o + i;
    }, e.prototype.setLeft = function(t) {
      de(t) && (this.eCell.style.left = t + "px");
      var i;
      if (this.columnOrGroup instanceof Gt)
        i = this.columnOrGroup;
      else {
        var r = this.columnOrGroup, o = r.getLeafColumns();
        if (!o.length)
          return;
        o.length > 1 && OB(this.ariaEl, o.length), i = o[0];
      }
      var s = this.beans.columnModel.getAriaColumnIndex(i);
      ax(this.ariaEl, s);
    }, IY([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var PY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), SM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, bx = (
  /** @class */
  function(n) {
    PY(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.columns = t, r.element = i, r;
    }
    return e.prototype.postConstruct = function() {
      this.gridOptionsWrapper.isColumnHoverHighlight() && this.addMouseHoverListeners();
    }, e.prototype.addMouseHoverListeners = function() {
      this.addManagedListener(this.element, "mouseout", this.onMouseOut.bind(this)), this.addManagedListener(this.element, "mouseover", this.onMouseOver.bind(this));
    }, e.prototype.onMouseOut = function() {
      this.columnHoverService.clearMouseOver();
    }, e.prototype.onMouseOver = function() {
      this.columnHoverService.setMouseOver(this.columns);
    }, SM([
      R("columnHoverService")
    ], e.prototype, "columnHoverService", void 0), SM([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var AY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), gf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, _H = (
  /** @class */
  function(n) {
    AY(e, n);
    function e(t, i) {
      var r = n.call(this, t, i) || this;
      return r.column = t, r;
    }
    return e.prototype.setComp = function(t, i, r, o) {
      n.prototype.setGui.call(this, i), this.comp = t, this.eButtonShowMainFilter = r, this.eFloatingFilterBody = o;
      var s = this.column.getColDef(), a = !!s.filter || !!s.filterFramework, l = !!s.floatingFilter;
      this.active = a && l, this.setupWidth(), this.setupLeft(), this.setupHover(), this.setupFocus(), this.setupUserComp(), this.setupSyncWithFilter(), this.setupUi(), this.addManagedListener(this.eButtonShowMainFilter, "click", this.showParentFilter.bind(this));
    }, e.prototype.setupUi = function() {
      if (this.comp.addOrRemoveButtonWrapperCssClass("ag-hidden", !this.active || this.suppressFilterButton), !!this.active) {
        this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton);
        var t = Kn("filter", this.gridOptionsWrapper, this.column);
        t && this.eButtonShowMainFilter.appendChild(t);
      }
    }, e.prototype.setupFocus = function() {
      this.createManagedBean(new Qu(this.eGui, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      }));
    }, e.prototype.onTabKeyDown = function(t) {
      var i = this.gridOptionsWrapper.getDocument(), r = i.activeElement, o = r === this.eGui;
      if (!o) {
        var s = this.focusService.findNextFocusableElement(this.eGui, null, t.shiftKey);
        if (s) {
          this.beans.headerNavigationService.scrollToColumn(this.column), t.preventDefault(), s.focus();
          return;
        }
        var a = this.findNextColumnWithFloatingFilter(t.shiftKey);
        a && this.focusService.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: this.getParentRowCtrl().getRowIndex(),
            column: a
          },
          event: t
        }) && t.preventDefault();
      }
    }, e.prototype.findNextColumnWithFloatingFilter = function(t) {
      var i = this.beans.columnModel, r = this.column;
      do
        if (r = t ? i.getDisplayedColBefore(r) : i.getDisplayedColAfter(r), !r)
          break;
      while (!r.getColDef().filter || !r.getColDef().floatingFilter);
      return r;
    }, e.prototype.handleKeyDown = function(t) {
      var i = this.gridOptionsWrapper.getDocument(), r = i.activeElement, o = r === this.eGui;
      switch (t.key) {
        case pe.UP:
        case pe.DOWN:
          o || t.preventDefault();
        case pe.LEFT:
        case pe.RIGHT:
          if (o)
            return;
          t.stopPropagation();
        case pe.ENTER:
          o && this.focusService.focusInto(this.eGui) && t.preventDefault();
          break;
        case pe.ESCAPE:
          o || this.eGui.focus();
      }
    }, e.prototype.onFocusIn = function(t) {
      var i = this.eGui.contains(t.relatedTarget);
      if (!i) {
        var r = !!t.relatedTarget && !t.relatedTarget.classList.contains("ag-floating-filter"), o = !!t.relatedTarget && yS(t.relatedTarget, "ag-floating-filter");
        if (r && o && t.target === this.eGui) {
          var s = this.lastFocusEvent, a = !!(s && s.key === pe.TAB);
          if (s && a) {
            var l = s.shiftKey;
            this.focusService.focusInto(this.eGui, l);
          }
        }
        var u = this.getRowIndex();
        this.beans.focusService.setFocusedHeader(u, this.column);
      }
    }, e.prototype.setupHover = function() {
      var t = this;
      this.createManagedBean(new bx([this.column], this.eGui));
      var i = function() {
        if (t.gridOptionsWrapper.isColumnHoverHighlight()) {
          var r = t.columnHoverService.isHovered(t.column);
          t.comp.addOrRemoveCssClass("ag-column-hover", r);
        }
      };
      this.addManagedListener(this.eventService, I.EVENT_COLUMN_HOVER_CHANGED, i), i();
    }, e.prototype.setupLeft = function() {
      var t = new TS(this.column, this.eGui, this.beans);
      this.createManagedBean(t);
    }, e.prototype.setupUserComp = function() {
      var t = this;
      if (this.active) {
        var i = this.column.getColDef(), r = this.filterManager.createFilterParams(this.column, i), o = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(i, k1, r), s = this.userComponentFactory.getDefaultFloatingFilterType(i);
        s == null && (s = "agReadOnlyFloatingFilter");
        var a = {
          api: this.gridApi,
          column: this.column,
          filterParams: o,
          currentParentModel: function() {
            return t.currentParentModel();
          },
          parentFilterInstance: function(u) {
            return t.parentFilterInstance(u);
          },
          showParentFilter: function() {
            return t.showParentFilter();
          },
          suppressFilterButton: !1
          // This one might be overridden from the colDef
        };
        this.suppressFilterButton = i.floatingFilterComponentParams ? !!i.floatingFilterComponentParams.suppressFilterButton : !1;
        var l = this.userComponentFactory.getFloatingFilterCompDetails(i, a, s);
        l && this.comp.setCompDetails(l);
      }
    }, e.prototype.currentParentModel = function() {
      var t = this.getFilterComponent(!1);
      return t ? t.resolveNow(null, function(i) {
        return i && i.getModel();
      }) : null;
    }, e.prototype.getFilterComponent = function(t) {
      return t === void 0 && (t = !0), this.filterManager.getFilterComponent(this.column, "NO_UI", t);
    }, e.prototype.parentFilterInstance = function(t) {
      var i = this.getFilterComponent();
      i != null && i.then(function(r) {
        t(Vh(r));
      });
    }, e.prototype.showParentFilter = function() {
      var t = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
      this.menuFactory.showMenuAfterButtonClick(this.column, t, "floatingFilter", "filterMenuTab", ["filterMenuTab"]);
    }, e.prototype.setupSyncWithFilter = function() {
      var t = this;
      if (this.active) {
        var i = function(r) {
          var o = t.comp.getFloatingFilterComp();
          if (o) {
            var s = t.currentParentModel();
            o.then(function(a) {
              a && a.onParentModelChanged(s, r);
            });
          }
        };
        this.addManagedListener(this.column, Gt.EVENT_FILTER_CHANGED, i), this.filterManager.isFilterActive(this.column) && i(null);
      }
    }, e.prototype.setupWidth = function() {
      var t = this, i = function() {
        var r = t.column.getActualWidth() + "px";
        t.comp.setWidth(r);
      };
      this.addManagedListener(this.column, Gt.EVENT_WIDTH_CHANGED, i), i();
    }, gf([
      R("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), gf([
      R("filterManager")
    ], e.prototype, "filterManager", void 0), gf([
      R("columnHoverService")
    ], e.prototype, "columnHoverService", void 0), gf([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), gf([
      R("menuFactory")
    ], e.prototype, "menuFactory", void 0), gf([
      R("beans")
    ], e.prototype, "beans", void 0), e;
  }(R_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Sx = (
  /** @class */
  function() {
    function n() {
    }
    return n.getHeaderClassesFromColDef = function(e, t, i, r) {
      return Je(e) ? [] : this.getColumnClassesFromCollDef(e.headerClass, e, t, i, r);
    }, n.getToolPanelClassesFromColDef = function(e, t, i, r) {
      return Je(e) ? [] : this.getColumnClassesFromCollDef(e.toolPanelClass, e, t, i, r);
    }, n.getClassParams = function(e, t, i, r) {
      return {
        // bad naming, as colDef here can be a group or a column,
        // however most people won't appreciate the difference,
        // so keeping it as colDef to avoid confusion.
        colDef: e,
        column: i,
        columnGroup: r,
        context: t.getContext(),
        api: t.getApi()
      };
    }, n.getColumnClassesFromCollDef = function(e, t, i, r, o) {
      if (Je(e))
        return [];
      var s;
      if (typeof e == "function") {
        var a = this.getClassParams(t, i, r, o);
        s = e(a);
      } else
        s = e;
      return typeof s == "string" ? [s] : Array.isArray(s) ? s : [];
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var MY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), fL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, FY = (
  /** @class */
  function(n) {
    MY(e, n);
    function e(t, i, r, o, s) {
      var a = n.call(this) || this;
      return a.pinned = t, a.column = i, a.eResize = r, a.comp = o, a.ctrl = s, a;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.column.getColDef(), r = [], o, s, a = function() {
        if (Wi(t.eResize, o), !!o) {
          var c = t.horizontalResizeService.addResizeBar({
            eResizeBar: t.eResize,
            onResizeStart: t.onResizeStart.bind(t),
            onResizing: t.onResizing.bind(t, !1),
            onResizeEnd: t.onResizing.bind(t, !0)
          });
          if (r.push(c), s) {
            var h = t.gridOptionsWrapper.isSkipHeaderOnAutoSize(), d = function() {
              t.columnModel.autoSizeColumn(t.column, h, "uiColumnResized");
            };
            t.eResize.addEventListener("dblclick", d);
            var f = new la(t.eResize);
            f.addEventListener(la.EVENT_DOUBLE_TAP, d), t.addDestroyFunc(function() {
              t.eResize.removeEventListener("dblclick", d), f.removeEventListener(la.EVENT_DOUBLE_TAP, d), f.destroy();
            });
          }
        }
      }, l = function() {
        r.forEach(function(c) {
          return c();
        }), r.length = 0;
      }, u = function() {
        var c = t.column.isResizable(), h = !t.gridOptionsWrapper.isSuppressAutoSize() && !i.suppressAutoSize, d = c !== o || h !== s;
        d && (o = c, s = h, l(), a());
      };
      u(), this.addDestroyFunc(l), this.ctrl.addRefreshFunction(u);
    }, e.prototype.onResizing = function(t, i) {
      var r = this.normaliseResizeAmount(i), o = [{ key: this.column, newWidth: this.resizeStartWidth + r }];
      this.columnModel.setColumnWidths(o, this.resizeWithShiftKey, t, "uiColumnDragged"), t && this.comp.addOrRemoveCssClass("ag-column-resizing", !1);
    }, e.prototype.onResizeStart = function(t) {
      this.resizeStartWidth = this.column.getActualWidth(), this.resizeWithShiftKey = t, this.comp.addOrRemoveCssClass("ag-column-resizing", !0);
    }, e.prototype.normaliseResizeAmount = function(t) {
      var i = t, r = this.pinned !== q.PINNED_LEFT, o = this.pinned === q.PINNED_RIGHT;
      return this.gridOptionsWrapper.isEnableRtl() ? r && (i *= -1) : o && (i *= -1), i;
    }, fL([
      R("horizontalResizeService")
    ], e.prototype, "horizontalResizeService", void 0), fL([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), fL([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var kY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), kp = (
  /** @class */
  function(n) {
    kY(e, n);
    function e(t, i, r) {
      i === void 0 && (i = "ag-checkbox"), r === void 0 && (r = "checkbox");
      var o = n.call(this, t, i, r) || this;
      return o.labelAlignment = "right", o.selected = !1, o.readOnly = !1, o.passive = !1, o;
    }
    return e.prototype.addInputListeners = function() {
      this.addManagedListener(this.eInput, "click", this.onCheckboxClick.bind(this)), this.addManagedListener(this.eLabel, "click", this.toggle.bind(this));
    }, e.prototype.getNextValue = function() {
      return this.selected === void 0 ? !0 : !this.selected;
    }, e.prototype.setPassive = function(t) {
      this.passive = t;
    }, e.prototype.isReadOnly = function() {
      return this.readOnly;
    }, e.prototype.setReadOnly = function(t) {
      this.eWrapper.classList.toggle("ag-disabled", t), this.eInput.disabled = t, this.readOnly = t;
    }, e.prototype.setDisabled = function(t) {
      return this.eWrapper.classList.toggle("ag-disabled", t), n.prototype.setDisabled.call(this, t);
    }, e.prototype.toggle = function() {
      if (!this.eInput.disabled) {
        var t = this.isSelected(), i = this.getNextValue();
        this.passive ? this.dispatchChange(i, t) : this.setValue(i);
      }
    }, e.prototype.getValue = function() {
      return this.isSelected();
    }, e.prototype.setValue = function(t, i) {
      return this.refreshSelectedClass(t), this.setSelected(t, i), this;
    }, e.prototype.setName = function(t) {
      var i = this.getInputElement();
      return i.name = t, this;
    }, e.prototype.isSelected = function() {
      return this.selected;
    }, e.prototype.setSelected = function(t, i) {
      this.isSelected() !== t && (this.previousValue = this.isSelected(), t = this.selected = typeof t == "boolean" ? t : void 0, this.eInput.checked = t, this.eInput.indeterminate = t === void 0, i || this.dispatchChange(this.selected, this.previousValue));
    }, e.prototype.dispatchChange = function(t, i, r) {
      this.dispatchEvent({ type: e.EVENT_CHANGED, selected: t, previousValue: i, event: r });
      var o = this.getInputElement(), s = {
        type: I.EVENT_CHECKBOX_CHANGED,
        id: o.id,
        name: o.name,
        selected: t,
        previousValue: i
      };
      this.eventService.dispatchEvent(s);
    }, e.prototype.onCheckboxClick = function(t) {
      if (!(this.passive || this.eInput.disabled)) {
        var i = this.isSelected(), r = this.selected = t.target.checked;
        this.refreshSelectedClass(r), this.dispatchChange(r, i, t);
      }
    }, e.prototype.refreshSelectedClass = function(t) {
      this.eWrapper.classList.toggle("ag-checked", t === !0), this.eWrapper.classList.toggle("ag-indeterminate", t == null);
    }, e;
  }(Pu)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var WY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), kC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, VY = (
  /** @class */
  function(n) {
    WY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      i.cbSelectAllVisible = !1, i.processingEventFromCheckbox = !1, i.column = t;
      var r = t.getColDef();
      return i.filteredOnly = r ? !!r.headerCheckboxSelectionFilteredOnly : !1, i;
    }
    return e.prototype.onSpaceKeyPressed = function(t) {
      var i = this.cbSelectAll, r = this.gridOptionsWrapper.getDocument();
      i.isDisplayed() && !i.getGui().contains(r.activeElement) && (t.preventDefault(), i.setValue(!i.getValue()));
    }, e.prototype.getCheckboxGui = function() {
      return this.cbSelectAll.getGui();
    }, e.prototype.setComp = function(t) {
      this.comp = t, this.cbSelectAll = this.createManagedBean(new kp()), this.cbSelectAll.addCssClass("ag-header-select-all"), So(this.cbSelectAll.getGui(), "presentation"), this.showOrHideSelectAll(), this.addManagedListener(this.eventService, I.EVENT_NEW_COLUMNS_LOADED, this.showOrHideSelectAll.bind(this)), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, this.showOrHideSelectAll.bind(this)), this.addManagedListener(this.eventService, I.EVENT_SELECTION_CHANGED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_MODEL_UPDATED, this.onModelChanged.bind(this)), this.addManagedListener(this.cbSelectAll, kp.EVENT_CHANGED, this.onCbSelectAll.bind(this)), this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel();
    }, e.prototype.showOrHideSelectAll = function() {
      this.cbSelectAllVisible = this.isCheckboxSelection(), this.cbSelectAll.setDisplayed(this.cbSelectAllVisible), this.cbSelectAllVisible && (this.checkRightRowModelType(), this.updateStateOfCheckbox()), this.refreshHeaderAriaDescribedBy(this.cbSelectAllVisible);
    }, e.prototype.refreshHeaderAriaDescribedBy = function(t) {
      var i = t ? this.cbSelectAll.getInputElement().id : void 0;
      this.comp.setAriaDescribedBy(i);
    }, e.prototype.onModelChanged = function() {
      this.cbSelectAllVisible && this.updateStateOfCheckbox();
    }, e.prototype.onSelectionChanged = function() {
      this.cbSelectAllVisible && this.updateStateOfCheckbox();
    }, e.prototype.getNextCheckboxState = function(t) {
      return t.selected === 0 && t.notSelected === 0 ? !1 : t.selected > 0 && t.notSelected > 0 ? null : t.selected > 0;
    }, e.prototype.updateStateOfCheckbox = function() {
      if (!this.processingEventFromCheckbox) {
        this.processingEventFromCheckbox = !0;
        var t = this.getSelectionCount(), i = this.getNextCheckboxState(t);
        this.cbSelectAll.setValue(i), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = !1;
      }
    }, e.prototype.refreshSelectAllLabel = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = this.cbSelectAll.getValue(), r = i ? t("ariaChecked", "checked") : t("ariaUnchecked", "unchecked"), o = t("ariaRowSelectAll", "Press Space to toggle all rows selection");
      this.cbSelectAll.setInputAriaLabel(o + " (" + r + ")");
    }, e.prototype.getSelectionCount = function() {
      var t = this, i = 0, r = 0, o = function(s) {
        t.gridOptionsWrapper.isGroupSelectsChildren() && s.group || (s.isSelected() ? i++ : s.selectable && r++);
      };
      return this.filteredOnly ? this.gridApi.forEachNodeAfterFilter(o) : this.gridApi.forEachNode(o), {
        notSelected: r,
        selected: i
      };
    }, e.prototype.checkRightRowModelType = function() {
      var t = this.rowModel.getType(), i = t === q.ROW_MODEL_TYPE_CLIENT_SIDE;
      i || console.warn("AG Grid: selectAllCheckbox is only available if using normal row model, you are using " + t);
    }, e.prototype.onCbSelectAll = function() {
      if (!this.processingEventFromCheckbox && this.cbSelectAllVisible) {
        var t = this.cbSelectAll.getValue();
        t ? this.selectionService.selectAllRowNodes(this.filteredOnly) : this.selectionService.deselectAllRowNodes(this.filteredOnly);
      }
    }, e.prototype.isCheckboxSelection = function() {
      var t = this.column.getColDef().headerCheckboxSelection;
      if (typeof t == "function") {
        var i = t;
        t = i({
          column: this.column,
          colDef: this.column.getColDef(),
          columnApi: this.columnApi,
          api: this.gridApi
        });
      }
      return t ? this.gridOptionsWrapper.isRowModelServerSide() ? (console.warn("AG Grid: headerCheckboxSelection is not supported for Server Side Row Model"), !1) : this.gridOptionsWrapper.isRowModelInfinite() ? (console.warn("AG Grid: headerCheckboxSelection is not supported for Infinite Row Model"), !1) : this.gridOptionsWrapper.isRowModelViewport() ? (console.warn("AG Grid: headerCheckboxSelection is not supported for Viewport Row Model"), !1) : !0 : !1;
    }, kC([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), kC([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), kC([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), kC([
      R("selectionService")
    ], e.prototype, "selectionService", void 0), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var BY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), yl = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, CH = (
  /** @class */
  function(n) {
    BY(e, n);
    function e(t, i) {
      var r = n.call(this, t, i) || this;
      return r.refreshFunctions = [], r.userHeaderClasses = /* @__PURE__ */ new Set(), r.column = t, r;
    }
    return e.prototype.setComp = function(t, i, r) {
      var o = this;
      n.prototype.setGui.call(this, i), this.comp = t, this.colDefVersion = this.columnModel.getColDefVersion(), this.updateState(), this.setupWidth(), this.setupMovingCss(), this.setupMenuClass(), this.setupSortableClass(), this.addColumnHoverListener(), this.setupFilterCss(), this.setupColId(), this.setupClassesFromColDef(), this.setupTooltip(), this.addActiveHeaderMouseListeners(), this.setupSelectAll(), this.setupUserComp(), this.createManagedBean(new FY(this.getPinned(), this.column, r, t, this)), this.createManagedBean(new bx([this.column], i)), this.createManagedBean(new TS(this.column, i, this.beans)), this.createManagedBean(new Qu(i, {
        shouldStopEventPropagation: function(s) {
          return o.shouldStopEventPropagation(s);
        },
        onTabKeyDown: function() {
          return null;
        },
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })), this.addManagedListener(this.eventService, I.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this)), this.addManagedListener(this.eventService, I.EVENT_COLUMN_VALUE_CHANGED, this.onColumnValueChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_COLUMN_PIVOT_CHANGED, this.onColumnPivotChanged.bind(this));
    }, e.prototype.setupUserComp = function() {
      var t = this.lookupUserCompDetails();
      this.setCompDetails(t);
    }, e.prototype.setCompDetails = function(t) {
      this.userCompDetails = t, this.comp.setUserCompDetails(t);
    }, e.prototype.lookupUserCompDetails = function() {
      var t = this.createParams(), i = this.column.getColDef();
      return this.userComponentFactory.getHeaderCompDetails(i, t);
    }, e.prototype.createParams = function() {
      var t = this, i = this.column.getColDef(), r = {
        column: this.column,
        displayName: this.displayName,
        enableSorting: i.sortable,
        enableMenu: this.menuEnabled,
        showColumnMenu: function(o) {
          t.gridApi.showColumnMenuAfterButtonClick(t.column, o);
        },
        progressSort: function(o) {
          t.sortController.progressSort(t.column, !!o, "uiColumnSorted");
        },
        setSort: function(o, s) {
          t.sortController.setSortForColumn(t.column, o, !!s, "uiColumnSorted");
        },
        api: this.gridApi,
        columnApi: this.columnApi,
        context: this.gridOptionsWrapper.getContext(),
        eGridHeader: this.getGui()
      };
      return r;
    }, e.prototype.setupSelectAll = function() {
      this.selectAllFeature = this.createManagedBean(new VY(this.column)), this.selectAllFeature.setComp(this.comp);
    }, e.prototype.getSelectAllGui = function() {
      return this.selectAllFeature.getCheckboxGui();
    }, e.prototype.handleKeyDown = function(t) {
      t.key === pe.SPACE && this.selectAllFeature.onSpaceKeyPressed(t), t.key === pe.ENTER && this.onEnterKeyPressed(t);
    }, e.prototype.onEnterKeyPressed = function(t) {
      var i = this.comp.getUserCompInstance();
      if (i) {
        if (t.ctrlKey || t.metaKey)
          this.menuEnabled && i.showMenu && (t.preventDefault(), i.showMenu());
        else if (this.sortable) {
          var r = t.shiftKey;
          this.sortController.progressSort(this.column, r, "uiColumnSorted");
        }
      }
    }, e.prototype.isMenuEnabled = function() {
      return this.menuEnabled;
    }, e.prototype.onFocusIn = function(t) {
      if (!this.getGui().contains(t.relatedTarget)) {
        var i = this.getRowIndex();
        this.focusService.setFocusedHeader(i, this.column);
      }
      this.setActiveHeader(!0);
    }, e.prototype.onFocusOut = function(t) {
      this.getGui().contains(t.relatedTarget) || this.setActiveHeader(!1);
    }, e.prototype.setupTooltip = function() {
      var t = this, i = {
        getColumn: function() {
          return t.column;
        },
        getColDef: function() {
          return t.column.getColDef();
        },
        getGui: function() {
          return t.eGui;
        },
        getLocation: function() {
          return "header";
        },
        getTooltipValue: function() {
          var o = t.column.getColDef().headerTooltip;
          return o;
        }
      }, r = this.createManagedBean(new _x(i, this.beans));
      r.setComp(this.comp), this.refreshFunctions.push(function() {
        return r.refreshToolTip();
      });
    }, e.prototype.setupClassesFromColDef = function() {
      var t = this, i = function() {
        var r = t.column.getColDef(), o = t.gridOptionsWrapper, s = Sx.getHeaderClassesFromColDef(r, o, t.column, null), a = t.userHeaderClasses;
        t.userHeaderClasses = new Set(s), s.forEach(function(l) {
          a.has(l) ? a.delete(l) : t.comp.addOrRemoveCssClass(l, !0);
        }), a.forEach(function(l) {
          return t.comp.addOrRemoveCssClass(l, !1);
        });
      };
      this.refreshFunctions.push(i), i();
    }, e.prototype.setDragSource = function(t) {
      var i = this;
      this.dragSourceElement = t, this.removeDragSource(), t && this.draggable && (this.moveDragSource = {
        type: ws.HeaderCell,
        eElement: t,
        defaultIconName: _o.ICON_HIDE,
        getDragItem: function() {
          return i.createDragItem();
        },
        dragItemName: this.displayName,
        onDragStarted: function() {
          return i.column.setMoving(!0, "uiColumnMoved");
        },
        onDragStopped: function() {
          return i.column.setMoving(!1, "uiColumnMoved");
        }
      }, this.dragAndDropService.addDragSource(this.moveDragSource, !0));
    }, e.prototype.createDragItem = function() {
      var t = {};
      return t[this.column.getId()] = this.column.isVisible(), {
        columns: [this.column],
        visibleState: t
      };
    }, e.prototype.removeDragSource = function() {
      this.moveDragSource && (this.dragAndDropService.removeDragSource(this.moveDragSource), this.moveDragSource = void 0);
    }, e.prototype.onNewColumnsLoaded = function() {
      var t = this.columnModel.getColDefVersion();
      t != this.colDefVersion && (this.colDefVersion = t, this.refresh());
    }, e.prototype.updateState = function() {
      var t = this.column.getColDef();
      this.menuEnabled = this.menuFactory.isMenuEnabled(this.column) && !t.suppressMenu, this.sortable = t.sortable, this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable();
    }, e.prototype.addRefreshFunction = function(t) {
      this.refreshFunctions.push(t);
    }, e.prototype.refresh = function() {
      this.updateState(), this.refreshHeaderComp(), this.refreshFunctions.forEach(function(t) {
        return t();
      });
    }, e.prototype.refreshHeaderComp = function() {
      var t = this.lookupUserCompDetails(), i = this.comp.getUserCompInstance(), r = i != null && this.userCompDetails.componentClass == t.componentClass, o = r ? this.attemptHeaderCompRefresh(t.params) : !1;
      o ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(t);
    }, e.prototype.attemptHeaderCompRefresh = function(t) {
      var i = this.comp.getUserCompInstance();
      if (!i || !i.refresh)
        return !1;
      var r = i.refresh(t);
      return r;
    }, e.prototype.calculateDisplayName = function() {
      return this.columnModel.getDisplayNameForColumn(this.column, "header", !0);
    }, e.prototype.checkDisplayName = function() {
      this.displayName !== this.calculateDisplayName() && this.refresh();
    }, e.prototype.workOutDraggable = function() {
      var t = this.column.getColDef(), i = this.gridOptionsWrapper.isSuppressMovableColumns(), r = !i && !t.suppressMovable && !t.lockPosition;
      return !!r || !!t.enableRowGroup || !!t.enablePivot;
    }, e.prototype.onColumnRowGroupChanged = function() {
      this.checkDisplayName();
    }, e.prototype.onColumnPivotChanged = function() {
      this.checkDisplayName();
    }, e.prototype.onColumnValueChanged = function() {
      this.checkDisplayName();
    }, e.prototype.setupWidth = function() {
      var t = this, i = function() {
        t.comp.setWidth(t.column.getActualWidth() + "px");
      };
      this.addManagedListener(this.column, Gt.EVENT_WIDTH_CHANGED, i), i();
    }, e.prototype.setupMovingCss = function() {
      var t = this, i = function() {
        t.comp.addOrRemoveCssClass("ag-header-cell-moving", t.column.isMoving());
      };
      this.addManagedListener(this.column, Gt.EVENT_MOVING_CHANGED, i), i();
    }, e.prototype.setupMenuClass = function() {
      var t = this, i = function() {
        t.comp.addOrRemoveCssClass("ag-column-menu-visible", t.column.isMenuVisible());
      };
      this.addManagedListener(this.column, Gt.EVENT_MENU_VISIBLE_CHANGED, i), i();
    }, e.prototype.setupSortableClass = function() {
      var t = this, i = function() {
        t.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!t.sortable);
      }, r = function() {
        t.sortable ? t.comp.setAriaSort(bB(t.column)) : t.comp.setAriaSort(void 0);
      };
      i(), r(), this.addRefreshFunction(i), this.addRefreshFunction(r), this.addManagedListener(this.column, Gt.EVENT_SORT_CHANGED, r);
    }, e.prototype.addColumnHoverListener = function() {
      var t = this, i = function() {
        if (t.gridOptionsWrapper.isColumnHoverHighlight()) {
          var r = t.columnHoverService.isHovered(t.column);
          t.comp.addOrRemoveCssClass("ag-column-hover", r);
        }
      };
      this.addManagedListener(this.eventService, I.EVENT_COLUMN_HOVER_CHANGED, i), i();
    }, e.prototype.setupFilterCss = function() {
      var t = this, i = function() {
        t.comp.addOrRemoveCssClass("ag-header-cell-filtered", t.column.isFilterActive());
      };
      this.addManagedListener(this.column, Gt.EVENT_FILTER_ACTIVE_CHANGED, i), i();
    }, e.prototype.setupColId = function() {
      this.comp.setColId(this.column.getColId());
    }, e.prototype.addActiveHeaderMouseListeners = function() {
      var t = this, i = function(r) {
        return t.setActiveHeader(r.type === "mouseenter");
      };
      this.addManagedListener(this.getGui(), "mouseenter", i), this.addManagedListener(this.getGui(), "mouseleave", i);
    }, e.prototype.setActiveHeader = function(t) {
      this.comp.addOrRemoveCssClass("ag-header-active", t);
    }, yl([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), yl([
      R("columnHoverService")
    ], e.prototype, "columnHoverService", void 0), yl([
      R("beans")
    ], e.prototype, "beans", void 0), yl([
      R("sortController")
    ], e.prototype, "sortController", void 0), yl([
      R("menuFactory")
    ], e.prototype, "menuFactory", void 0), yl([
      R("dragAndDropService")
    ], e.prototype, "dragAndDropService", void 0), yl([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), yl([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), yl([
      R("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), yl([
      Lo
    ], e.prototype, "removeDragSource", null), e;
  }(R_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var HY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), WC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, GY = (
  /** @class */
  function(n) {
    HY(e, n);
    function e(t, i, r, o) {
      var s = n.call(this) || this;
      return s.eResize = i, s.comp = t, s.pinned = r, s.columnGroup = o, s;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      if (!this.columnGroup.isResizable()) {
        this.comp.addOrRemoveResizableCssClass("ag-hidden", !0);
        return;
      }
      var i = this.horizontalResizeService.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, !1),
        onResizeEnd: this.onResizing.bind(this, !0)
      });
      if (this.addDestroyFunc(i), !this.gridOptionsWrapper.isSuppressAutoSize()) {
        var r = this.gridOptionsWrapper.isSkipHeaderOnAutoSize();
        this.eResize.addEventListener("dblclick", function() {
          var o = [], s = t.columnGroup.getDisplayedLeafColumns();
          s.forEach(function(a) {
            a.getColDef().suppressAutoSize || o.push(a.getColId());
          }), o.length > 0 && t.columnModel.autoSizeColumns({
            columns: o,
            skipHeader: r,
            stopAtGroup: t.columnGroup,
            source: "uiColumnResized"
          }), t.resizeLeafColumnsToFit();
        });
      }
    }, e.prototype.onResizeStart = function(t) {
      var i = this;
      this.calculateInitialValues();
      var r = null;
      if (t && (r = this.columnModel.getDisplayedGroupAfter(this.columnGroup)), r) {
        var o = r.getDisplayedLeafColumns();
        this.resizeTakeFromCols = o.filter(function(s) {
          return s.isResizable();
        }), this.resizeTakeFromStartWidth = 0, this.resizeTakeFromCols.forEach(function(s) {
          return i.resizeTakeFromStartWidth += s.getActualWidth();
        }), this.resizeTakeFromRatios = [], this.resizeTakeFromCols.forEach(function(s) {
          return i.resizeTakeFromRatios.push(s.getActualWidth() / i.resizeTakeFromStartWidth);
        });
      } else
        this.resizeTakeFromCols = null, this.resizeTakeFromStartWidth = null, this.resizeTakeFromRatios = null;
      this.comp.addOrRemoveCssClass("ag-column-resizing", !0);
    }, e.prototype.onResizing = function(t, i) {
      var r = this.normaliseDragChange(i), o = this.resizeStartWidth + r;
      this.resizeColumns(o, t);
    }, e.prototype.resizeLeafColumnsToFit = function() {
      var t = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup);
      this.calculateInitialValues(), t > this.resizeStartWidth && this.resizeColumns(t, !0);
    }, e.prototype.resizeColumns = function(t, i) {
      i === void 0 && (i = !0);
      var r = [];
      if (r.push({
        columns: this.resizeCols,
        ratios: this.resizeRatios,
        width: t
      }), this.resizeTakeFromCols) {
        var o = t - this.resizeStartWidth;
        r.push({
          columns: this.resizeTakeFromCols,
          ratios: this.resizeTakeFromRatios,
          width: this.resizeTakeFromStartWidth - o
        });
      }
      this.columnModel.resizeColumnSets({
        resizeSets: r,
        finished: i,
        source: "uiColumnDragged"
      }), i && this.comp.addOrRemoveCssClass("ag-column-resizing", !1);
    }, e.prototype.calculateInitialValues = function() {
      var t = this, i = this.columnGroup.getDisplayedLeafColumns();
      this.resizeCols = i.filter(function(r) {
        return r.isResizable();
      }), this.resizeStartWidth = 0, this.resizeCols.forEach(function(r) {
        return t.resizeStartWidth += r.getActualWidth();
      }), this.resizeRatios = [], this.resizeCols.forEach(function(r) {
        return t.resizeRatios.push(r.getActualWidth() / t.resizeStartWidth);
      });
    }, e.prototype.normaliseDragChange = function(t) {
      var i = t;
      return this.gridOptionsWrapper.isEnableRtl() ? this.pinned !== q.PINNED_LEFT && (i *= -1) : this.pinned === q.PINNED_RIGHT && (i *= -1), i;
    }, WC([
      R("horizontalResizeService")
    ], e.prototype, "horizontalResizeService", void 0), WC([
      R("autoWidthCalculator")
    ], e.prototype, "autoWidthCalculator", void 0), WC([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), WC([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var UY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), zY = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, jY = (
  /** @class */
  function(n) {
    UY(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.removeChildListenersFuncs = [], r.columnGroup = i, r.comp = t, r;
    }
    return e.prototype.postConstruct = function() {
      this.addListenersToChildrenColumns(), this.addManagedListener(this.columnGroup, Yr.EVENT_DISPLAYED_CHILDREN_CHANGED, this.onDisplayedChildrenChanged.bind(this)), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
    }, e.prototype.addListenersToChildrenColumns = function() {
      var t = this;
      this.removeListenersOnChildrenColumns();
      var i = this.onWidthChanged.bind(this);
      this.columnGroup.getLeafColumns().forEach(function(r) {
        r.addEventListener(Gt.EVENT_WIDTH_CHANGED, i), r.addEventListener(Gt.EVENT_VISIBLE_CHANGED, i), t.removeChildListenersFuncs.push(function() {
          r.removeEventListener(Gt.EVENT_WIDTH_CHANGED, i), r.removeEventListener(Gt.EVENT_VISIBLE_CHANGED, i);
        });
      });
    }, e.prototype.removeListenersOnChildrenColumns = function() {
      this.removeChildListenersFuncs.forEach(function(t) {
        return t();
      }), this.removeChildListenersFuncs = [];
    }, e.prototype.onDisplayedChildrenChanged = function() {
      this.addListenersToChildrenColumns(), this.onWidthChanged();
    }, e.prototype.onWidthChanged = function() {
      this.comp.setWidth(this.columnGroup.getActualWidth() + "px");
    }, zY([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var $Y = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), mf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, yH = (
  /** @class */
  function(n) {
    $Y(e, n);
    function e(t, i) {
      var r = n.call(this, t, i) || this;
      return r.columnGroup = t, r;
    }
    return e.prototype.setComp = function(t, i, r) {
      n.prototype.setGui.call(this, i), this.comp = t, this.displayName = this.columnModel.getDisplayNameForColumnGroup(this.columnGroup, "header"), this.addClasses(), this.addAttributes(), this.setupMovingCss(), this.setupExpandable(), this.setupTooltip(), this.setupUserComp();
      var o = this.getParentRowCtrl().getPinned(), s = this.columnGroup.getProvidedColumnGroup().getLeafColumns();
      this.createManagedBean(new bx(s, i)), this.createManagedBean(new TS(this.columnGroup, i, this.beans)), this.createManagedBean(new jY(t, this.columnGroup)), this.groupResizeFeature = this.createManagedBean(new GY(t, r, o, this.columnGroup)), this.createManagedBean(new Qu(i, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: function() {
        },
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      }));
    }, e.prototype.resizeLeafColumnsToFit = function() {
      this.groupResizeFeature.onResizeStart(!1), this.groupResizeFeature.resizeLeafColumnsToFit();
    }, e.prototype.setupUserComp = function() {
      var t = this, i = this.displayName, r = {
        displayName: this.displayName,
        columnGroup: this.columnGroup,
        setExpanded: function(u) {
          t.columnModel.setColumnGroupOpened(t.columnGroup.getProvidedColumnGroup(), u, "gridInitializing");
        },
        api: this.gridApi,
        columnApi: this.columnApi,
        context: this.gridOptionsWrapper.getContext()
      };
      if (!i) {
        for (var o = this.columnGroup, s = o.getLeafColumns(); o.getParent() && o.getParent().getLeafColumns().length === s.length; )
          o = o.getParent();
        var a = o.getColGroupDef();
        a && (i = a.headerName), i || (i = s ? this.columnModel.getDisplayNameForColumn(s[0], "header", !0) : "");
      }
      var l = this.userComponentFactory.getHeaderGroupCompDetails(r);
      this.comp.setUserCompDetails(l);
    }, e.prototype.setupTooltip = function() {
      var t = this, i = this.columnGroup.getColGroupDef(), r = {
        getColumn: function() {
          return t.columnGroup;
        },
        getGui: function() {
          return t.eGui;
        },
        getLocation: function() {
          return "headerGroup";
        },
        getTooltipValue: function() {
          return i && i.headerTooltip;
        }
      };
      i && (r.getColDef = function() {
        return i;
      });
      var o = this.createManagedBean(new _x(r, this.beans));
      o.setComp(this.comp);
    }, e.prototype.setupExpandable = function() {
      var t = this.columnGroup.getProvidedColumnGroup();
      this.refreshExpanded(), this.addManagedListener(t, fn.EVENT_EXPANDABLE_CHANGED, this.refreshExpanded.bind(this)), this.addManagedListener(t, fn.EVENT_EXPANDED_CHANGED, this.refreshExpanded.bind(this));
    }, e.prototype.refreshExpanded = function() {
      var t = this.columnGroup;
      this.expandable = t.isExpandable();
      var i = t.isExpanded();
      this.expandable ? this.comp.setAriaExpanded(i ? "true" : "false") : this.comp.setAriaExpanded(void 0);
    }, e.prototype.addAttributes = function() {
      this.comp.setColId(this.columnGroup.getUniqueId());
    }, e.prototype.addClasses = function() {
      var t = this, i = this.columnGroup.getColGroupDef(), r = Sx.getHeaderClassesFromColDef(i, this.gridOptionsWrapper, null, this.columnGroup);
      r.push(this.columnGroup.isPadding() ? "ag-header-group-cell-no-group" : "ag-header-group-cell-with-group"), r.forEach(function(o) {
        return t.comp.addOrRemoveCssClass(o, !0);
      });
    }, e.prototype.setupMovingCss = function() {
      var t = this, i = this.columnGroup.getProvidedColumnGroup(), r = i.getLeafColumns(), o = function() {
        return t.comp.addOrRemoveCssClass("ag-header-cell-moving", t.columnGroup.isMoving());
      };
      r.forEach(function(s) {
        t.addManagedListener(s, Gt.EVENT_MOVING_CHANGED, o);
      }), o();
    }, e.prototype.onFocusIn = function(t) {
      if (!this.eGui.contains(t.relatedTarget)) {
        var i = this.getRowIndex();
        this.beans.focusService.setFocusedHeader(i, this.columnGroup);
      }
    }, e.prototype.handleKeyDown = function(t) {
      var i = this.gridOptionsWrapper.getDocument(), r = i.activeElement, o = r === this.eGui;
      if (!(!this.expandable || !o) && t.key === pe.ENTER) {
        var s = this.columnGroup, a = !s.isExpanded();
        this.columnModel.setColumnGroupOpened(s.getProvidedColumnGroup(), a, "uiColumnExpanded");
      }
    }, e.prototype.setDragSource = function(t) {
      var i = this;
      if (!this.isSuppressMoving()) {
        var r = this.columnGroup.getProvidedColumnGroup().getLeafColumns(), o = {
          type: ws.HeaderCell,
          eElement: t,
          defaultIconName: _o.ICON_HIDE,
          dragItemName: this.displayName,
          // we add in the original group leaf columns, so we move both visible and non-visible items
          getDragItem: this.getDragItemForGroup.bind(this),
          onDragStarted: function() {
            return r.forEach(function(s) {
              return s.setMoving(!0, "uiColumnDragged");
            });
          },
          onDragStopped: function() {
            return r.forEach(function(s) {
              return s.setMoving(!1, "uiColumnDragged");
            });
          }
        };
        this.dragAndDropService.addDragSource(o, !0), this.addDestroyFunc(function() {
          return i.dragAndDropService.removeDragSource(o);
        });
      }
    }, e.prototype.getDragItemForGroup = function() {
      var t = this.columnGroup.getProvidedColumnGroup().getLeafColumns(), i = {};
      t.forEach(function(o) {
        return i[o.getId()] = o.isVisible();
      });
      var r = [];
      return this.columnModel.getAllDisplayedColumns().forEach(function(o) {
        t.indexOf(o) >= 0 && (r.push(o), qr(t, o));
      }), t.forEach(function(o) {
        return r.push(o);
      }), {
        columns: r,
        visibleState: i
      };
    }, e.prototype.isSuppressMoving = function() {
      var t = !1;
      this.columnGroup.getLeafColumns().forEach(function(r) {
        (r.getColDef().suppressMovable || r.getColDef().lockPosition) && (t = !0);
      });
      var i = t || this.gridOptionsWrapper.isSuppressMovableColumns();
      return i;
    }, mf([
      R("beans")
    ], e.prototype, "beans", void 0), mf([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), mf([
      R("dragAndDropService")
    ], e.prototype, "dragAndDropService", void 0), mf([
      R("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), mf([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), mf([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), e;
  }(R_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var KY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), pL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, qY = 0, jy = (
  /** @class */
  function(n) {
    KY(e, n);
    function e(t, i, r) {
      var o = n.call(this) || this;
      return o.instanceId = qY++, o.headerCellCtrls = {}, o.rowIndex = t, o.pinned = i, o.type = r, o;
    }
    return e.prototype.getInstanceId = function() {
      return this.instanceId;
    }, e.prototype.setComp = function(t) {
      this.comp = t, this.onRowHeightChanged(), this.onVirtualColumnsChanged(), this.setWidth(), this.addEventListeners(), CS() && this.comp.setTransform("translateZ(0)"), t.setAriaRowIndex(this.rowIndex + 1);
    }, e.prototype.addEventListeners = function() {
      this.addManagedListener(this.eventService, I.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this)), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_DOM_LAYOUT, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this)), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_HEADER_HEIGHT, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_PIVOT_HEADER_HEIGHT, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_GROUP_HEADER_HEIGHT, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_PIVOT_GROUP_HEADER_HEIGHT, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_FLOATING_FILTERS_HEIGHT, this.onRowHeightChanged.bind(this));
    }, e.prototype.getHeaderCellCtrl = function(t) {
      return Gd(this.headerCellCtrls).find(function(i) {
        return i.getColumnGroupChild() === t;
      });
    }, e.prototype.onDisplayedColumnsChanged = function() {
      this.onVirtualColumnsChanged(), this.setWidth();
    }, e.prototype.getType = function() {
      return this.type;
    }, e.prototype.onColumnResized = function() {
      this.setWidth();
    }, e.prototype.setWidth = function() {
      var t = this.getWidthForRow();
      this.comp.setWidth(t + "px");
    }, e.prototype.getWidthForRow = function() {
      var t = this.gridOptionsWrapper.getDomLayout() === q.DOM_LAYOUT_PRINT;
      if (t) {
        var i = this.pinned != null;
        return i ? 0 : this.columnModel.getContainerWidth(q.PINNED_RIGHT) + this.columnModel.getContainerWidth(q.PINNED_LEFT) + this.columnModel.getContainerWidth(null);
      }
      return this.columnModel.getContainerWidth(this.pinned);
    }, e.prototype.onRowHeightChanged = function() {
      var t = this.columnModel.getHeaderRowCount(), i = [], r = 0, o, s;
      this.columnModel.isPivotMode() ? (o = this.gridOptionsWrapper.getPivotGroupHeaderHeight(), s = this.gridOptionsWrapper.getPivotHeaderHeight()) : (this.columnModel.hasFloatingFilters() && (t++, r = 1), o = this.gridOptionsWrapper.getGroupHeaderHeight(), s = this.gridOptionsWrapper.getHeaderHeight());
      for (var a = 1 + r, l = t - a, u = 0; u < l; u++)
        i.push(o);
      i.push(s);
      for (var u = 0; u < r; u++)
        i.push(this.gridOptionsWrapper.getFloatingFiltersHeight());
      for (var c = 0, u = 0; u < this.rowIndex; u++)
        c += i[u];
      this.comp.setTop(c + "px"), this.comp.setHeight(i[this.rowIndex] + "px");
    }, e.prototype.getPinned = function() {
      return this.pinned;
    }, e.prototype.getRowIndex = function() {
      return this.rowIndex;
    }, e.prototype.onVirtualColumnsChanged = function() {
      var t = this, i = this.headerCellCtrls;
      this.headerCellCtrls = {};
      var r = this.getColumnsInViewport();
      r.forEach(function(a) {
        if (!a.isEmptyGroup()) {
          var l = a.getUniqueId(), u = i[l];
          delete i[l];
          var c = u && u.getColumnGroupChild() != a;
          if (c && (t.destroyBean(u), u = void 0), u == null)
            switch (t.type) {
              case Xr.FLOATING_FILTER:
                u = t.createBean(new _H(a, t));
                break;
              case Xr.COLUMN_GROUP:
                u = t.createBean(new yH(a, t));
                break;
              default:
                u = t.createBean(new CH(a, t));
                break;
            }
          t.headerCellCtrls[l] = u;
        }
      });
      var o = function(a) {
        var l = t.focusService.isHeaderWrapperFocused(a);
        if (!l)
          return !1;
        var u = t.columnModel.isDisplayed(a.getColumnGroupChild());
        return u;
      };
      pi(i, function(a, l) {
        var u = o(l);
        u ? t.headerCellCtrls[a] = l : t.destroyBean(l);
      });
      var s = Ya(this.headerCellCtrls);
      this.comp.setHeaderCtrls(s);
    }, e.prototype.destroyCtrls = function() {
      var t = this;
      pi(this.headerCellCtrls, function(i, r) {
        t.destroyBean(r);
      }), this.headerCellCtrls = {};
    }, e.prototype.getColumnsInViewport = function() {
      var t = this.gridOptionsWrapper.getDomLayout() === q.DOM_LAYOUT_PRINT;
      return t ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
    }, e.prototype.getColumnsInViewportPrintLayout = function() {
      var t = this;
      if (this.pinned != null)
        return [];
      var i = [], r = this.getActualDepth();
      return [q.PINNED_LEFT, null, q.PINNED_RIGHT].forEach(function(o) {
        var s = t.columnModel.getVirtualHeaderGroupRow(o, r);
        i = i.concat(s);
      }), i;
    }, e.prototype.getActualDepth = function() {
      return this.type == Xr.FLOATING_FILTER ? this.rowIndex - 1 : this.rowIndex;
    }, e.prototype.getColumnsInViewportNormalLayout = function() {
      return this.columnModel.getVirtualHeaderGroupRow(this.pinned, this.getActualDepth());
    }, e.prototype.focusHeader = function(t, i) {
      var r = Ya(this.headerCellCtrls), o = r.find(function(s) {
        return s.getColumnGroupChild() == t;
      });
      return o ? (o.focus(i), !0) : !1;
    }, pL([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), pL([
      R("focusService")
    ], e.prototype, "focusService", void 0), pL([
      Lo
    ], e.prototype, "destroyCtrls", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var YY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), am = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, XY = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, ZY = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(XY(arguments[e]));
  return n;
}, wH = (
  /** @class */
  function(n) {
    YY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.groupsRowCtrls = [], i.pinned = t, i;
    }
    return e.prototype.setComp = function(t, i) {
      this.comp = t, this.setupCenterWidth(), this.setupPinnedWidth(), this.setupDragAndDrop(i), this.addManagedListener(this.eventService, I.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this)), this.ctrlsService.registerHeaderContainer(this, this.pinned), this.columnModel.isReady() && this.refresh();
    }, e.prototype.setupDragAndDrop = function(t) {
      var i = new mH(this.pinned, t);
      this.createManagedBean(i);
    }, e.prototype.refresh = function(t) {
      var i = this;
      t === void 0 && (t = !1);
      var r = new ES(), o = this.focusService.getFocusHeaderToUseAfterRefresh(), s = function() {
        var c = i.columnModel.getHeaderRowCount() - 1;
        i.groupsRowCtrls = i.destroyBeans(i.groupsRowCtrls);
        for (var h = 0; h < c; h++) {
          var d = i.createBean(new jy(r.next(), i.pinned, Xr.COLUMN_GROUP));
          i.groupsRowCtrls.push(d);
        }
      }, a = function() {
        var c = r.next(), h = i.columnsRowCtrl == null || !t || i.columnsRowCtrl.getRowIndex() !== c;
        h && (i.destroyBean(i.columnsRowCtrl), i.columnsRowCtrl = i.createBean(new jy(c, i.pinned, Xr.COLUMN)));
      }, l = function() {
        var c = !i.columnModel.isPivotMode() && i.columnModel.hasFloatingFilters(), h = function() {
          i.filtersRowCtrl = i.destroyBean(i.filtersRowCtrl);
        };
        if (!c) {
          h();
          return;
        }
        var d = r.next();
        if (i.filtersRowCtrl) {
          var f = i.filtersRowCtrl.getRowIndex() !== d;
          (!t || f) && h();
        }
        i.filtersRowCtrl || (i.filtersRowCtrl = i.createBean(new jy(d, i.pinned, Xr.FLOATING_FILTER)));
      };
      s(), a(), l();
      var u = this.getAllCtrls();
      this.comp.setCtrls(u), this.restoreFocusOnHeader(o);
    }, e.prototype.restoreFocusOnHeader = function(t) {
      t == null || t.column.getPinned() != this.pinned || this.focusService.focusHeaderPosition({ headerPosition: t });
    }, e.prototype.getAllCtrls = function() {
      var t = ZY(this.groupsRowCtrls, [this.columnsRowCtrl]);
      return this.filtersRowCtrl && t.push(this.filtersRowCtrl), t;
    }, e.prototype.onGridColumnsChanged = function() {
      this.refresh(!0);
    }, e.prototype.setupCenterWidth = function() {
      var t = this;
      this.pinned == null && this.createManagedBean(new yx(function(i) {
        return t.comp.setCenterWidth(i + "px");
      }));
    }, e.prototype.setHorizontalScroll = function(t) {
      this.comp.setContainerTransform("translateX(" + t + "px)");
    }, e.prototype.setupPinnedWidth = function() {
      var t = this;
      if (this.pinned != null) {
        var i = this.pinned === q.PINNED_LEFT, r = this.pinned === q.PINNED_RIGHT, o = function() {
          var s = i ? t.pinnedWidthService.getPinnedLeftWidth() : t.pinnedWidthService.getPinnedRightWidth();
          if (s != null) {
            var a = s == 0, l = t.gridOptionsWrapper.isEnableRtl(), u = t.gridOptionsWrapper.getScrollbarWidth(), c = t.scrollVisibleService.isVerticalScrollShowing() && (l && i || !l && r), h = c ? s + u : s;
            t.comp.setPinnedContainerWidth(h + "px"), t.comp.addOrRemoveCssClass("ag-hidden", a);
          }
        };
        this.addManagedListener(this.eventService, I.EVENT_LEFT_PINNED_WIDTH_CHANGED, o), this.addManagedListener(this.eventService, I.EVENT_RIGHT_PINNED_WIDTH_CHANGED, o), this.addManagedListener(this.eventService, I.EVENT_SCROLL_VISIBILITY_CHANGED, o), this.addManagedListener(this.eventService, I.EVENT_SCROLLBAR_WIDTH_CHANGED, o);
      }
    }, e.prototype.getHeaderCtrlForColumn = function(t) {
      if (t instanceof Gt)
        return this.columnsRowCtrl ? this.columnsRowCtrl.getHeaderCellCtrl(t) : void 0;
      if (this.groupsRowCtrls.length !== 0)
        for (var i = 0; i < this.groupsRowCtrls.length; i++) {
          var r = this.groupsRowCtrls[i].getHeaderCellCtrl(t);
          if (r)
            return r;
        }
    }, e.prototype.getHtmlElementForColumnHeader = function(t) {
      var i = this.getHeaderCtrlForColumn(t);
      return i ? i.getGui() : null;
    }, e.prototype.getRowType = function(t) {
      var i = this.getAllCtrls(), r = i[t];
      return r ? r.getType() : void 0;
    }, e.prototype.focusHeader = function(t, i, r) {
      var o = this.getAllCtrls(), s = o[t];
      return s ? s.focusHeader(i, r) : !1;
    }, e.prototype.getRowCount = function() {
      return this.getAllCtrls().length;
    }, am([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), am([
      R("scrollVisibleService")
    ], e.prototype, "scrollVisibleService", void 0), am([
      R("pinnedWidthService")
    ], e.prototype, "pinnedWidthService", void 0), am([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), am([
      R("focusService")
    ], e.prototype, "focusService", void 0), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var QY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), gL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, $y = (
  /** @class */
  function(n) {
    QY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.headerRowComps = {}, i.rowCompsList = [], i.pinned = t, i;
    }
    return e.prototype.init = function() {
      var t = this;
      this.selectAndSetTemplate();
      var i = {
        addOrRemoveCssClass: function(o, s) {
          return t.addOrRemoveCssClass(o, s);
        },
        setCtrls: function(o) {
          return t.setCtrls(o);
        },
        // only gets called for center section
        setCenterWidth: function(o) {
          return t.eCenterContainer.style.width = o;
        },
        setContainerTransform: function(o) {
          return t.eCenterContainer.style.transform = o;
        },
        // only gets called for pinned sections
        setPinnedContainerWidth: function(o) {
          var s = t.getGui();
          s.style.width = o, s.style.maxWidth = o, s.style.minWidth = o;
        }
      }, r = this.createManagedBean(new wH(this.pinned));
      r.setComp(i, this.getGui());
    }, e.prototype.selectAndSetTemplate = function() {
      var t = this.pinned == q.PINNED_LEFT, i = this.pinned == q.PINNED_RIGHT, r = t ? e.PINNED_LEFT_TEMPLATE : i ? e.PINNED_RIGHT_TEMPLATE : e.CENTER_TEMPLATE;
      this.setTemplate(r), this.eRowContainer = this.eCenterContainer ? this.eCenterContainer : this.getGui();
    }, e.prototype.destroyRowComps = function() {
      this.setCtrls([]);
    }, e.prototype.destroyRowComp = function(t) {
      this.destroyBean(t), this.eRowContainer.removeChild(t.getGui());
    }, e.prototype.setCtrls = function(t) {
      var i = this, r = this.headerRowComps;
      this.headerRowComps = {}, this.rowCompsList = [];
      var o, s = function(a) {
        var l = a.getGui(), u = l.parentElement != i.eRowContainer;
        u && i.eRowContainer.appendChild(l), o && QO(i.eRowContainer, l, o), o = l;
      };
      t.forEach(function(a) {
        var l = a.getInstanceId(), u = r[l];
        delete r[l];
        var c = u || i.createBean(new hH(a));
        i.headerRowComps[l] = c, i.rowCompsList.push(c), s(c);
      }), Ya(r).forEach(function(a) {
        return i.destroyRowComp(a);
      });
    }, e.PINNED_LEFT_TEMPLATE = '<div class="ag-pinned-left-header" role="presentation"/>', e.PINNED_RIGHT_TEMPLATE = '<div class="ag-pinned-right-header" role="presentation"/>', e.CENTER_TEMPLATE = `<div class="ag-header-viewport" role="presentation">
            <div class="ag-header-container" ref="eCenterContainer" role="rowgroup"></div>
        </div>`, gL([
      fe("eCenterContainer")
    ], e.prototype, "eCenterContainer", void 0), gL([
      Ee
    ], e.prototype, "init", null), gL([
      Lo
    ], e.prototype, "destroyRowComps", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var JY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), eX = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, bH = (
  /** @class */
  function(n) {
    JY(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = {
        addOrRemoveCssClass: function(s, a) {
          return t.addOrRemoveCssClass(s, a);
        },
        setHeightAndMinHeight: function(s) {
          t.getGui().style.height = s, t.getGui().style.minHeight = s;
        }
      }, r = this.createManagedBean(new fH());
      r.setComp(i, this.getGui(), this.getFocusableElement());
      var o = function(s) {
        t.createManagedBean(s), t.appendChild(s);
      };
      o(new $y(q.PINNED_LEFT)), o(new $y(null)), o(new $y(q.PINNED_RIGHT));
    }, e.TEMPLATE = '<div class="ag-header" role="presentation"/>', eX([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var tX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Uw = globalThis && globalThis.__assign || function() {
  return Uw = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, Uw.apply(this, arguments);
}, Da = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, SH = (
  /** @class */
  function(n) {
    tX(e, n);
    function e() {
      var i = n !== null && n.apply(this, arguments) || this;
      return i.allAdvancedFilters = /* @__PURE__ */ new Map(), i.activeAdvancedFilters = [], i.quickFilter = null, i.quickFilterParts = null, i.processingFilterChange = !1, i;
    }
    t = e, e.prototype.init = function() {
      var i = this;
      this.addManagedListener(this.eventService, I.EVENT_ROW_DATA_CHANGED, function(r) {
        return i.onNewRowsLoaded(r);
      }), this.addManagedListener(this.eventService, I.EVENT_GRID_COLUMNS_CHANGED, function() {
        return i.onColumnsChanged();
      }), this.quickFilter = this.parseQuickFilter(this.gridOptionsWrapper.getQuickFilterText()), this.setQuickFilterParts(), this.allowShowChangeAfterFilter = this.gridOptionsWrapper.isAllowShowChangeAfterFilter();
    }, e.prototype.setQuickFilterParts = function() {
      this.quickFilterParts = this.quickFilter ? this.quickFilter.split(" ") : null;
    }, e.prototype.setFilterModel = function(i) {
      var r = this, o = [], s = this.getFilterModel();
      if (i) {
        var a = cx(Object.keys(i));
        this.allAdvancedFilters.forEach(function(l, u) {
          var c = i[u];
          o.push(r.setModelOnFilterWrapper(l.filterPromise, c)), a.delete(u);
        }), a.forEach(function(l) {
          var u = r.columnModel.getPrimaryColumn(l);
          if (!u) {
            console.warn("AG Grid: setFilterModel() - no column found for colId: " + l);
            return;
          }
          if (!u.isFilterAllowed()) {
            console.warn("AG Grid: setFilterModel() - unable to fully apply model, filtering disabled for colId: " + l);
            return;
          }
          var c = r.getOrCreateFilterWrapper(u, "NO_UI");
          if (!c) {
            console.warn("AG-Grid: setFilterModel() - unable to fully apply model, unable to create filter for colId: " + l);
            return;
          }
          o.push(r.setModelOnFilterWrapper(c.filterPromise, i[l]));
        });
      } else
        this.allAdvancedFilters.forEach(function(l) {
          o.push(r.setModelOnFilterWrapper(l.filterPromise, null));
        });
      ko.all(o).then(function() {
        var l = r.getFilterModel(), u = [];
        r.allAdvancedFilters.forEach(function(c, h) {
          var d = s ? s[h] : null, f = l ? l[h] : null;
          Sd.jsonEquals(d, f) || u.push(c.column);
        }), u.length > 0 && r.onFilterChanged({ columns: u });
      });
    }, e.prototype.setModelOnFilterWrapper = function(i, r) {
      return new ko(function(o) {
        i.then(function(s) {
          typeof s.setModel != "function" && (console.warn("AG Grid: filter missing setModel method, which is needed for setFilterModel"), o()), (s.setModel(r) || ko.resolve()).then(function() {
            return o();
          });
        });
      });
    }, e.prototype.getFilterModel = function() {
      var i = {};
      return this.allAdvancedFilters.forEach(function(r, o) {
        var s = r.filterPromise, a = s.resolveNow(null, function(u) {
          return u;
        });
        if (a == null)
          return null;
        if (typeof a.getModel != "function") {
          console.warn("AG Grid: filter API missing getModel method, which is needed for getFilterModel");
          return;
        }
        var l = a.getModel();
        de(l) && (i[o] = l);
      }), i;
    }, e.prototype.isAdvancedFilterPresent = function() {
      return this.activeAdvancedFilters.length > 0;
    }, e.prototype.updateActiveFilters = function() {
      var i = this;
      this.activeAdvancedFilters.length = 0;
      var r = function(o) {
        return o ? o.isFilterActive ? o.isFilterActive() : (console.warn("AG Grid: Filter is missing isFilterActive() method"), !1) : !1;
      };
      this.allAdvancedFilters.forEach(function(o) {
        if (o.filterPromise.resolveNow(!1, r)) {
          var s = o.filterPromise.resolveNow(null, function(a) {
            return a;
          });
          i.activeAdvancedFilters.push(s);
        }
      });
    }, e.prototype.updateFilterFlagInColumns = function(i, r) {
      this.allAdvancedFilters.forEach(function(o) {
        var s = o.filterPromise.resolveNow(!1, function(a) {
          return a.isFilterActive();
        });
        o.column.setFilterActive(s, i, r);
      });
    }, e.prototype.isAnyFilterPresent = function() {
      return this.isQuickFilterPresent() || this.isAdvancedFilterPresent() || this.gridOptionsWrapper.isExternalFilterPresent();
    }, e.prototype.doAdvancedFiltersPass = function(i, r) {
      for (var o = i.data, s = 0; s < this.activeAdvancedFilters.length; s++) {
        var a = this.activeAdvancedFilters[s];
        if (!(a == null || a === r)) {
          if (typeof a.doesFilterPass != "function")
            throw new Error("Filter is missing method doesFilterPass");
          if (!a.doesFilterPass({ node: i, data: o }))
            return !1;
        }
      }
      return !0;
    }, e.prototype.parseQuickFilter = function(i) {
      return de(i) ? this.gridOptionsWrapper.isRowModelDefault() ? i.toUpperCase() : (console.warn("AG Grid - Quick filtering only works with the Client-Side Row Model"), null) : null;
    }, e.prototype.setQuickFilter = function(i) {
      if (i != null && typeof i != "string") {
        console.warn("AG Grid - setQuickFilter() only supports string inputs, received: " + typeof i);
        return;
      }
      var r = this.parseQuickFilter(i);
      this.quickFilter !== r && (this.quickFilter = r, this.setQuickFilterParts(), this.onFilterChanged());
    }, e.prototype.onFilterChanged = function(i) {
      i === void 0 && (i = {});
      var r = i.filterInstance, o = i.additionalEventAttributes, s = i.columns;
      this.updateActiveFilters(), this.updateFilterFlagInColumns("filterChanged", o), this.allAdvancedFilters.forEach(function(l) {
        l.filterPromise && l.filterPromise.then(function(u) {
          u && u !== r && u.onAnyFilterChanged && u.onAnyFilterChanged();
        });
      });
      var a = {
        type: I.EVENT_FILTER_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi,
        columns: s || []
      };
      o && aa(a, o), this.processingFilterChange = !0, this.eventService.dispatchEvent(a), this.processingFilterChange = !1;
    }, e.prototype.isSuppressFlashingCellsBecauseFiltering = function() {
      return !this.allowShowChangeAfterFilter && this.processingFilterChange;
    }, e.prototype.isQuickFilterPresent = function() {
      return this.quickFilter !== null;
    }, e.prototype.doesRowPassOtherFilters = function(i, r) {
      return this.doesRowPassFilter({ rowNode: r, filterInstanceToSkip: i });
    }, e.prototype.doesRowPassQuickFilterNoCache = function(i, r) {
      var o = this, s = this.columnModel.getAllColumnsForQuickFilter();
      return s.some(function(a) {
        var l = o.getQuickFilterTextForColumn(a, i);
        return de(l) && l.indexOf(r) >= 0;
      });
    }, e.prototype.doesRowPassQuickFilterCache = function(i, r) {
      return i.quickFilterAggregateText || this.aggregateRowForQuickFilter(i), i.quickFilterAggregateText.indexOf(r) >= 0;
    }, e.prototype.doesRowPassQuickFilter = function(i) {
      var r = this, o = this.gridOptionsWrapper.isCacheQuickFilter();
      return this.quickFilterParts.every(function(s) {
        return o ? r.doesRowPassQuickFilterCache(i, s) : r.doesRowPassQuickFilterNoCache(i, s);
      });
    }, e.prototype.doesRowPassFilter = function(i) {
      return !(this.isQuickFilterPresent() && !this.doesRowPassQuickFilter(i.rowNode) || this.gridOptionsWrapper.isExternalFilterPresent() && !this.gridOptionsWrapper.doesExternalFilterPass(i.rowNode) || this.isAdvancedFilterPresent() && !this.doAdvancedFiltersPass(i.rowNode, i.filterInstanceToSkip));
    }, e.prototype.getQuickFilterTextForColumn = function(i, r) {
      var o = this.valueService.getValue(i, r, !0), s = i.getColDef();
      if (s.getQuickFilterText) {
        var a = {
          value: o,
          node: r,
          data: r.data,
          column: i,
          colDef: s,
          context: this.gridOptionsWrapper.getContext()
        };
        o = s.getQuickFilterText(a);
      }
      return de(o) ? o.toString().toUpperCase() : null;
    }, e.prototype.aggregateRowForQuickFilter = function(i) {
      var r = this, o = [], s = this.columnModel.getAllColumnsForQuickFilter();
      s.forEach(function(a) {
        var l = r.getQuickFilterTextForColumn(a, i);
        de(l) && o.push(l);
      }), i.quickFilterAggregateText = o.join(t.QUICK_FILTER_SEPARATOR);
    }, e.prototype.onNewRowsLoaded = function(i) {
      this.allAdvancedFilters.forEach(function(r) {
        r.filterPromise.then(function(o) {
          o.onNewRowsLoaded && o.onNewRowsLoaded();
        });
      }), this.updateFilterFlagInColumns(i), this.updateActiveFilters();
    }, e.prototype.createValueGetter = function(i) {
      var r = this;
      return function(o) {
        var s = o.node;
        return r.valueService.getValue(i, s, !0);
      };
    }, e.prototype.getFilterComponent = function(i, r, o) {
      o === void 0 && (o = !0);
      var s;
      if (o)
        return ((s = this.getOrCreateFilterWrapper(i, r)) === null || s === void 0 ? void 0 : s.filterPromise) || null;
      var a = this.cachedFilter(i);
      return a ? a.filterPromise : null;
    }, e.prototype.isFilterActive = function(i) {
      var r = this.cachedFilter(i);
      return !!r && r.filterPromise.resolveNow(!1, function(o) {
        return o.isFilterActive();
      });
    }, e.prototype.getOrCreateFilterWrapper = function(i, r) {
      if (!i.isFilterAllowed())
        return null;
      var o = this.cachedFilter(i);
      return o ? r !== "NO_UI" && this.putIntoGui(o, r) : (o = this.createFilterWrapper(i, r), this.allAdvancedFilters.set(i.getColId(), o)), o;
    }, e.prototype.cachedFilter = function(i) {
      return this.allAdvancedFilters.get(i.getColId());
    }, e.prototype.createFilterInstance = function(i, r) {
      var o = this, s = pt.isRegistered(ct.SetFilterModule) ? "agSetColumnFilter" : "agTextColumnFilter", a = i.getColDef(), l, u = Uw(Uw({}, this.createFilterParams(i, a, r)), { filterModifiedCallback: function() {
        var d = {
          type: I.EVENT_FILTER_MODIFIED,
          api: o.gridApi,
          columnApi: o.columnApi,
          column: i,
          filterInstance: l
        };
        o.eventService.dispatchEvent(d);
      }, filterChangedCallback: function(d) {
        return o.onFilterChanged({ filterInstance: l, additionalEventAttributes: d, columns: [i] });
      }, doesRowPassOtherFilter: function(d) {
        return o.doesRowPassOtherFilters(l, d);
      } }), c = this.userComponentFactory.getFilterDetails(a, u, s);
      if (!c)
        return null;
      var h = c.newAgStackInstance();
      return h && h.then(function(d) {
        return l = d;
      }), h;
    }, e.prototype.createFilterParams = function(i, r, o) {
      o === void 0 && (o = null);
      var s = {
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        column: i,
        colDef: zO(r),
        rowModel: this.rowModel,
        filterChangedCallback: function() {
        },
        filterModifiedCallback: function() {
        },
        valueGetter: this.createValueGetter(i),
        context: this.gridOptionsWrapper.getContext(),
        doesRowPassOtherFilter: function() {
          return !0;
        }
      };
      return o && (s.$scope = o), s;
    }, e.prototype.createFilterWrapper = function(i, r) {
      var o = {
        column: i,
        filterPromise: null,
        scope: null,
        compiledElement: null,
        guiPromise: ko.resolve(null)
      };
      return o.scope = this.gridOptionsWrapper.isAngularCompileFilters() ? this.$scope.$new() : null, o.filterPromise = this.createFilterInstance(i, o.scope), o.filterPromise && this.putIntoGui(o, r), o;
    }, e.prototype.putIntoGui = function(i, r) {
      var o = this, s = document.createElement("div");
      s.className = "ag-filter", i.guiPromise = new ko(function(a) {
        i.filterPromise.then(function(l) {
          var u = l.getGui();
          if (de(u) || console.warn("AG Grid: getGui method from filter returned " + u + ", it should be a DOM element or an HTML template string."), typeof u == "string" && (u = Dr(u)), s.appendChild(u), i.scope) {
            var c = o.$compile(s)(i.scope);
            i.compiledElement = c, window.setTimeout(function() {
              return i.scope.$apply();
            }, 0);
          }
          a(s), o.eventService.dispatchEvent({
            type: I.EVENT_FILTER_OPENED,
            column: i.column,
            source: r,
            eGui: s,
            api: o.gridApi,
            columnApi: o.columnApi
          });
        });
      });
    }, e.prototype.onColumnsChanged = function() {
      var i = this, r = [];
      this.allAdvancedFilters.forEach(function(o, s) {
        var a = i.columnModel.getPrimaryColumn(s);
        a || (r.push(o.column), i.disposeFilterWrapper(o, "filterDestroyed"));
      }), r.length > 0 && this.onFilterChanged({ columns: r });
    }, e.prototype.destroyFilter = function(i, r) {
      r === void 0 && (r = "api");
      var o = this.allAdvancedFilters.get(i.getColId());
      o && (this.disposeFilterWrapper(o, r), this.onFilterChanged({ columns: [i] }));
    }, e.prototype.disposeFilterWrapper = function(i, r) {
      var o = this;
      i.filterPromise.then(function(s) {
        (s.setModel(null) || ko.resolve()).then(function() {
          o.getContext().destroyBean(s), i.column.setFilterActive(!1, r), i.scope && (i.compiledElement && i.compiledElement.remove(), i.scope.$destroy()), o.allAdvancedFilters.delete(i.column.getColId());
        });
      });
    }, e.prototype.destroy = function() {
      var i = this;
      n.prototype.destroy.call(this), this.allAdvancedFilters.forEach(function(r) {
        return i.disposeFilterWrapper(r, "filterDestroyed");
      });
    };
    var t;
    return e.QUICK_FILTER_SEPARATOR = `
`, Da([
      R("$compile")
    ], e.prototype, "$compile", void 0), Da([
      R("$scope")
    ], e.prototype, "$scope", void 0), Da([
      R("valueService")
    ], e.prototype, "valueService", void 0), Da([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), Da([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), Da([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), Da([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), Da([
      R("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), Da([
      Ee
    ], e.prototype, "init", null), Da([
      Lo
    ], e.prototype, "destroy", null), e = t = Da([
      Ke("filterManager")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var iX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), lm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, EH = (
  /** @class */
  function(n) {
    iX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.initialised = !1, t;
    }
    return e.prototype.init = function() {
      this.cellExpressions = this.gridOptionsWrapper.isEnableCellExpressions(), this.initialised = !0;
    }, e.prototype.getValue = function(t, i, r, o) {
      if (r === void 0 && (r = !1), o === void 0 && (o = !1), this.initialised || this.init(), !!i) {
        var s = t.getColDef(), a = s.field, l = t.getId(), u = i.data, c, h = i.groupData && i.groupData[l] !== void 0, d = !o && i.aggData && i.aggData[l] !== void 0;
        if (r && s.filterValueGetter ? c = this.executeFilterValueGetter(s.filterValueGetter, u, t, i) : this.gridOptionsWrapper.isTreeData() && d ? c = i.aggData[l] : this.gridOptionsWrapper.isTreeData() && s.valueGetter ? c = this.executeValueGetter(s.valueGetter, u, t, i) : this.gridOptionsWrapper.isTreeData() && a && u ? c = xw(u, a, t.isFieldContainsDots()) : h ? c = i.groupData[l] : d ? c = i.aggData[l] : s.valueGetter ? c = this.executeValueGetter(s.valueGetter, u, t, i) : a && u && (c = xw(u, a, t.isFieldContainsDots())), this.cellExpressions && typeof c == "string" && c.indexOf("=") === 0) {
          var f = c.substring(1);
          c = this.executeValueGetter(f, u, t, i);
        }
        if (c == null) {
          var p = this.getOpenedGroup(i, t);
          if (p != null)
            return p;
        }
        return c;
      }
    }, e.prototype.getOpenedGroup = function(t, i) {
      if (this.gridOptionsWrapper.isShowOpenedGroup()) {
        var r = i.getColDef();
        if (r.showRowGroup)
          for (var o = i.getColDef().showRowGroup, s = t.parent; s != null; ) {
            if (s.rowGroupColumn && (o === !0 || o === s.rowGroupColumn.getId()))
              return s.key;
            s = s.parent;
          }
      }
    }, e.prototype.setValue = function(t, i, r, o) {
      var s = this.columnModel.getPrimaryColumn(i);
      if (!(!t || !s)) {
        Je(t.data) && (t.data = {});
        var a = s.getColDef(), l = a.field, u = a.newValueHandler, c = a.valueSetter;
        if (Je(l) && Je(u) && Je(c)) {
          console.warn("AG Grid: you need either field or valueSetter set on colDef for editing to work");
          return;
        }
        var h = {
          node: t,
          data: t.data,
          oldValue: this.getValue(s, t),
          newValue: r,
          colDef: s.getColDef(),
          column: s,
          api: this.gridOptionsWrapper.getApi(),
          columnApi: this.gridOptionsWrapper.getColumnApi(),
          context: this.gridOptionsWrapper.getContext()
        };
        h.newValue = r;
        var d;
        if (u && de(u) ? d = u(h) : de(c) ? d = this.expressionService.evaluate(c, h) : d = this.setValueUsingField(t.data, l, r, s.isFieldContainsDots()), d === void 0 && (d = !0), !!d) {
          t.resetQuickFilterAggregateText(), this.valueCache.onDataChanged(), h.newValue = this.getValue(s, t);
          var f = s.getColDef().onCellValueChanged;
          typeof f == "function" && setTimeout(function() {
            return f(h);
          }, 0);
          var p = {
            type: I.EVENT_CELL_VALUE_CHANGED,
            event: null,
            rowIndex: t.rowIndex,
            rowPinned: t.rowPinned,
            column: h.column,
            api: h.api,
            columnApi: h.columnApi,
            colDef: h.colDef,
            context: h.context,
            data: t.data,
            node: t,
            oldValue: h.oldValue,
            newValue: h.newValue,
            value: h.newValue,
            source: o
          };
          this.eventService.dispatchEvent(p);
        }
      }
    }, e.prototype.setValueUsingField = function(t, i, r, o) {
      if (!i)
        return !1;
      var s = !1;
      if (!o)
        t[i] = r;
      else
        for (var a = i.split("."), l = t; a.length > 0 && l; ) {
          var u = a.shift();
          a.length === 0 ? l[u] = r : l = l[u];
        }
      return !s;
    }, e.prototype.executeFilterValueGetter = function(t, i, r, o) {
      var s = {
        data: i,
        node: o,
        column: r,
        colDef: r.getColDef(),
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        context: this.gridOptionsWrapper.getContext(),
        getValue: this.getValueCallback.bind(this, o)
      };
      return this.expressionService.evaluate(t, s);
    }, e.prototype.executeValueGetter = function(t, i, r, o) {
      var s = r.getId(), a = this.valueCache.getValue(o, s);
      if (a !== void 0)
        return a;
      var l = {
        data: i,
        node: o,
        column: r,
        colDef: r.getColDef(),
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        context: this.gridOptionsWrapper.getContext(),
        getValue: this.getValueCallback.bind(this, o)
      }, u = this.expressionService.evaluate(t, l);
      return this.valueCache.setValue(o, s, u), u;
    }, e.prototype.getValueCallback = function(t, i) {
      var r = this.columnModel.getPrimaryColumn(i);
      return r ? this.getValue(r, t) : null;
    }, e.prototype.getKeyForNode = function(t, i) {
      var r = this.getValue(t, i), o = t.getColDef().keyCreator, s = r;
      if (o) {
        var a = {
          value: r,
          colDef: t.getColDef(),
          column: t,
          node: i,
          data: i.data,
          api: this.gridOptionsWrapper.getApi(),
          columnApi: this.gridOptionsWrapper.getColumnApi(),
          context: this.gridOptionsWrapper.getContext()
        };
        s = o(a);
      }
      return typeof s == "string" || s == null || (s = String(s), s === "[object Object]" && mi(function() {
        console.warn("AG Grid: a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key");
      }, "getKeyForNode - warn about [object,object]")), s;
    }, lm([
      R("expressionService")
    ], e.prototype, "expressionService", void 0), lm([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), lm([
      R("valueCache")
    ], e.prototype, "valueCache", void 0), lm([
      Ee
    ], e.prototype, "init", null), e = lm([
      Ke("valueService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var nX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), EM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Fn;
(function(n) {
  n.AUTO_HEIGHT = "ag-layout-auto-height", n.NORMAL = "ag-layout-normal", n.PRINT = "ag-layout-print";
})(Fn || (Fn = {}));
var Ex = (
  /** @class */
  function(n) {
    nX(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.view = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_DOM_LAYOUT, this.updateLayoutClasses.bind(this)), this.updateLayoutClasses();
    }, e.prototype.updateLayoutClasses = function() {
      var t = this.gridOptionsWrapper.getDomLayout(), i = {
        autoHeight: t === q.DOM_LAYOUT_AUTO_HEIGHT,
        normal: t === q.DOM_LAYOUT_NORMAL,
        print: t === q.DOM_LAYOUT_PRINT
      }, r = i.autoHeight ? Fn.AUTO_HEIGHT : i.print ? Fn.PRINT : Fn.NORMAL;
      this.view.updateLayoutClasses(r, i);
    }, EM([
      R("gridOptionsWrapper")
    ], e.prototype, "gridOptionsWrapper", void 0), EM([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var rX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wl = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, oX = (
  /** @class */
  function(n) {
    rX(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.scrollLeft = -1, i.nextScrollTop = -1, i.scrollTop = -1, i.eBodyViewport = t, i.resetLastHorizontalScrollElementDebounced = th(i.resetLastHorizontalScrollElement.bind(i), 500), i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.enableRtl = this.gridOptionsWrapper.isEnableRtl(), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this)), this.ctrlsService.whenReady(function(i) {
        t.centerRowContainerCon = i.centerRowContainerCtrl, t.onDisplayedColumnsWidthChanged(), t.addScrollListener();
      });
    }, e.prototype.addScrollListener = function() {
      var t = this.ctrlsService.getFakeHScrollCtrl();
      this.addManagedListener(this.centerRowContainerCon.getViewportElement(), "scroll", this.onCenterViewportScroll.bind(this)), this.addManagedListener(t.getViewport(), "scroll", this.onFakeHorizontalScroll.bind(this));
      var i = this.gridOptionsWrapper.isDebounceVerticalScrollbar() ? th(this.onVerticalScroll.bind(this), 100) : this.onVerticalScroll.bind(this);
      this.addManagedListener(this.eBodyViewport, "scroll", i);
    }, e.prototype.onDisplayedColumnsWidthChanged = function() {
      this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter();
    }, e.prototype.horizontallyScrollHeaderCenterAndFloatingCenter = function(t) {
      var i = this.centerRowContainerCon == null;
      if (!i) {
        t === void 0 && (t = this.centerRowContainerCon.getCenterViewportScrollLeft());
        var r = this.enableRtl ? t : -t, o = this.ctrlsService.getTopCenterRowContainerCtrl(), s = this.ctrlsService.getBottomCenterRowContainerCtrl(), a = this.ctrlsService.getFakeHScrollCtrl(), l = this.ctrlsService.getHeaderRowContainerCtrl();
        l.setHorizontalScroll(r), s.setContainerTranslateX(r), o.setContainerTranslateX(r);
        var u = this.lastHorizontalScrollElement === this.centerRowContainerCon.getViewportElement() ? a.getViewport() : this.centerRowContainerCon.getViewportElement();
        Aw(u, Math.abs(t), this.enableRtl);
      }
    }, e.prototype.isControllingScroll = function(t) {
      return this.lastHorizontalScrollElement ? t === this.lastHorizontalScrollElement : (this.lastHorizontalScrollElement = t, !0);
    }, e.prototype.onFakeHorizontalScroll = function() {
      var t = this.ctrlsService.getFakeHScrollCtrl().getViewport();
      this.isControllingScroll(t) && this.onBodyHorizontalScroll(t);
    }, e.prototype.onCenterViewportScroll = function() {
      var t = this.centerRowContainerCon.getViewportElement();
      this.isControllingScroll(t) && this.onBodyHorizontalScroll(t);
    }, e.prototype.onBodyHorizontalScroll = function(t) {
      var i = this.centerRowContainerCon.getViewportElement(), r = i.scrollLeft;
      this.shouldBlockScrollUpdate("horizontal", r, !0) || (this.doHorizontalScroll(Math.round(Mv(t, this.enableRtl))), this.resetLastHorizontalScrollElementDebounced());
    }, e.prototype.onVerticalScroll = function() {
      var t = this.eBodyViewport.scrollTop;
      this.shouldBlockScrollUpdate("vertical", t, !0) || (this.animationFrameService.setScrollTop(t), this.nextScrollTop = t, this.gridOptionsWrapper.isSuppressAnimationFrame() ? (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()) : this.animationFrameService.schedule());
    }, e.prototype.resetLastHorizontalScrollElement = function() {
      this.lastHorizontalScrollElement = null;
    }, e.prototype.doHorizontalScroll = function(t) {
      var i = this.ctrlsService.getFakeHScrollCtrl().getViewport(), r = Mv(i, this.enableRtl);
      this.scrollLeft === t && t === r || (this.scrollLeft = t, this.fireScrollEvent("horizontal"), this.horizontallyScrollHeaderCenterAndFloatingCenter(t), this.onHorizontalViewportChanged());
    }, e.prototype.fireScrollEvent = function(t) {
      var i = this, r = {
        type: I.EVENT_BODY_SCROLL,
        api: this.gridApi,
        columnApi: this.columnApi,
        direction: t,
        left: this.scrollLeft,
        top: this.scrollTop
      };
      this.eventService.dispatchEvent(r), window.clearTimeout(this.scrollTimer), this.scrollTimer = void 0, this.scrollTimer = window.setTimeout(function() {
        var o = Object.assign({}, r, {
          type: I.EVENT_BODY_SCROLL_END
        });
        i.eventService.dispatchEvent(o);
      }, 100);
    }, e.prototype.shouldBlockScrollUpdate = function(t, i, r) {
      if (r === void 0 && (r = !1), r && !ug())
        return !1;
      if (t === "vertical") {
        var o = E_(this.eBodyViewport), s = this.eBodyViewport.scrollHeight;
        if (i < 0 || i + o > s)
          return !0;
      }
      if (t === "horizontal") {
        var a = this.centerRowContainerCon.getCenterWidth(), l = this.centerRowContainerCon.getViewportElement().scrollWidth;
        if (this.enableRtl && Av()) {
          if (i > 0)
            return !0;
        } else if (i < 0)
          return !0;
        if (Math.abs(i) + a > l)
          return !0;
      }
      return !1;
    }, e.prototype.redrawRowsAfterScroll = function() {
      this.fireScrollEvent("vertical");
    }, e.prototype.onHorizontalViewportChanged = function() {
      this.centerRowContainerCon.onHorizontalViewportChanged();
    }, e.prototype.checkScrollLeft = function() {
      this.scrollLeft !== this.centerRowContainerCon.getCenterViewportScrollLeft() && this.onBodyHorizontalScroll(this.centerRowContainerCon.getViewportElement());
    }, e.prototype.executeAnimationFrameScroll = function() {
      var t = this.scrollTop != this.nextScrollTop;
      return t && (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()), t;
    }, e.prototype.setHorizontalScrollPosition = function(t) {
      var i = 0, r = this.centerRowContainerCon.getViewportElement().scrollWidth - this.centerRowContainerCon.getCenterWidth();
      this.shouldBlockScrollUpdate("horizontal", t) && (this.enableRtl && Av() ? t = t > 0 ? 0 : r : t = Math.min(Math.max(t, i), r)), Aw(this.centerRowContainerCon.getViewportElement(), Math.abs(t), this.enableRtl), this.doHorizontalScroll(t);
    }, e.prototype.setVerticalScrollPosition = function(t) {
      this.eBodyViewport.scrollTop = t;
    }, e.prototype.getVScrollPosition = function() {
      var t = {
        top: this.eBodyViewport.scrollTop,
        bottom: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetHeight
      };
      return t;
    }, e.prototype.getHScrollPosition = function() {
      return this.centerRowContainerCon.getHScrollPosition();
    }, e.prototype.isHorizontalScrollShowing = function() {
      return this.centerRowContainerCon.isHorizontalScrollShowing();
    }, e.prototype.scrollHorizontally = function(t) {
      var i = this.centerRowContainerCon.getViewportElement().scrollLeft;
      return this.setHorizontalScrollPosition(i + t), this.centerRowContainerCon.getViewportElement().scrollLeft - i;
    }, e.prototype.scrollToTop = function() {
      this.eBodyViewport.scrollTop = 0;
    }, e.prototype.ensureNodeVisible = function(t, i) {
      i === void 0 && (i = null);
      for (var r = this.rowModel.getRowCount(), o = typeof t == "function", s = -1, a = 0; a < r; a++) {
        var l = this.rowModel.getRow(a);
        if (o) {
          if (t(l)) {
            s = a;
            break;
          }
        } else if (t === l || t === l.data) {
          s = a;
          break;
        }
      }
      s >= 0 && this.ensureIndexVisible(s, i);
    }, e.prototype.ensureIndexVisible = function(t, i) {
      if (this.gridOptionsWrapper.getDomLayout() !== q.DOM_LAYOUT_PRINT) {
        var r = this.paginationProxy.getRowCount();
        if (typeof t != "number" || t < 0 || t >= r) {
          console.warn("invalid row index for ensureIndexVisible: " + t);
          return;
        }
        var o = this.gridOptionsWrapper.isPagination(), s = o && !this.gridOptionsWrapper.isSuppressPaginationPanel();
        s || this.paginationProxy.goToPageWithIndex(t);
        var a = this.paginationProxy.getRow(t), l;
        do {
          var u = a.rowTop, c = a.rowHeight, h = this.paginationProxy.getPixelOffset(), d = a.rowTop - h, f = d + a.rowHeight, p = this.getVScrollPosition(), g = this.heightScaler.getDivStretchOffset(), _ = p.top + g, m = p.bottom + g, v = m - _, C = this.heightScaler.getScrollPositionForPixel(d), y = this.heightScaler.getScrollPositionForPixel(f - v), b = Math.min((C + y) / 2, d), L = _ > d, S = m < f, E = null;
          i === "top" ? E = C : i === "bottom" ? E = y : i === "middle" ? E = b : L ? E = C : S && (E = y), E !== null && (this.eBodyViewport.scrollTop = E, this.rowRenderer.redrawAfterScroll()), l = u !== a.rowTop || c !== a.rowHeight;
        } while (l);
        this.animationFrameService.flushAllFrames();
      }
    }, e.prototype.ensureColumnVisible = function(t, i) {
      i === void 0 && (i = "auto");
      var r = this.columnModel.getGridColumn(t);
      if (r && !r.isPinned() && this.columnModel.isColumnDisplayed(r)) {
        var o = this.getPositionedHorizontalScroll(r, i);
        o !== null && this.centerRowContainerCon.setCenterViewportScrollLeft(o), this.centerRowContainerCon.onHorizontalViewportChanged(), this.animationFrameService.flushAllFrames();
      }
    }, e.prototype.getPositionedHorizontalScroll = function(t, i) {
      var r = this.isColumnOutsideViewport(t), o = r.columnBeforeStart, s = r.columnAfterEnd, a = this.centerRowContainerCon.getCenterWidth() < t.getActualWidth(), l = this.centerRowContainerCon.getCenterWidth(), u = this.enableRtl, c = (u ? o : s) || a, h = u ? s : o;
      i !== "auto" && (c = i === "start", h = i === "end");
      var d = i === "middle";
      if (c || h || d) {
        var f = this.getColumnBounds(t), p = f.colLeft, g = f.colMiddle, _ = f.colRight;
        return d ? g - l / 2 : c ? u ? _ : p : u ? p - l : _ - l;
      }
      return null;
    }, e.prototype.isColumnOutsideViewport = function(t) {
      var i = this.getViewportBounds(), r = i.start, o = i.end, s = this.getColumnBounds(t), a = s.colLeft, l = s.colRight, u = this.enableRtl, c = u ? r > l : o < l, h = u ? o < a : r > a;
      return { columnBeforeStart: c, columnAfterEnd: h };
    }, e.prototype.getColumnBounds = function(t) {
      var i = this.enableRtl, r = this.columnModel.getBodyContainerWidth(), o = t.getActualWidth(), s = t.getLeft(), a = i ? -1 : 1, l = i ? r - s : s, u = l + o * a, c = l + o / 2 * a;
      return { colLeft: l, colMiddle: c, colRight: u };
    }, e.prototype.getViewportBounds = function() {
      var t = this.centerRowContainerCon.getCenterWidth(), i = this.centerRowContainerCon.getCenterViewportScrollLeft(), r = i, o = t + i;
      return { start: r, end: o, width: t };
    }, wl([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), wl([
      R("animationFrameService")
    ], e.prototype, "animationFrameService", void 0), wl([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), wl([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), wl([
      R("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), wl([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), wl([
      R("rowContainerHeightService")
    ], e.prototype, "heightScaler", void 0), wl([
      R("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), wl([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), wl([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var LH = (
  /** @class */
  function() {
    function n(e) {
      this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = e.scrollAxis.indexOf("x") !== -1, this.scrollVertically = e.scrollAxis.indexOf("y") !== -1, this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || function() {
        return !1;
      }, this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || function() {
        return !1;
      };
    }
    return n.prototype.check = function(e, t) {
      t === void 0 && (t = !1);
      var i = t || this.shouldSkipVerticalScroll();
      if (!(i && this.shouldSkipHorizontalScroll())) {
        var r = this.scrollContainer.getBoundingClientRect(), o = this.scrollByTick;
        this.tickLeft = e.clientX < r.left + o, this.tickRight = e.clientX > r.right - o, this.tickUp = e.clientY < r.top + o && !i, this.tickDown = e.clientY > r.bottom - o && !i, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared();
      }
    }, n.prototype.ensureTickingStarted = function() {
      this.tickingInterval === null && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0);
    }, n.prototype.doTick = function() {
      this.tickCount++;
      var e;
      if (e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40, this.scrollVertically) {
        var t = this.getVerticalPosition();
        this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e);
      }
      if (this.scrollHorizontally) {
        var i = this.getHorizontalPosition();
        this.tickLeft && this.setHorizontalPosition(i - e), this.tickRight && this.setHorizontalPosition(i + e);
      }
      this.onScrollCallback && this.onScrollCallback();
    }, n.prototype.ensureCleared = function() {
      this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null);
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var sX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), V1 = globalThis && globalThis.__assign || function() {
  return V1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, V1.apply(this, arguments);
}, No = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, aX = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, lX = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(aX(arguments[e]));
  return n;
}, uX = (
  /** @class */
  function(n) {
    sX(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.isMultiRowDrag = !1, i.isGridSorted = !1, i.isGridFiltered = !1, i.isRowGroupActive = !1, i.eContainer = t, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.gridOptionsWrapper.isRowModelDefault() && (this.clientSideRowModel = this.rowModel);
      var i = function() {
        t.onSortChanged(), t.onFilterChanged(), t.onRowGroupChanged();
      };
      this.addManagedListener(this.eventService, I.EVENT_SORT_CHANGED, this.onSortChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_MODEL_UPDATED, function() {
        i();
      }), i(), this.ctrlsService.whenReady(function() {
        var r = t.ctrlsService.getGridBodyCtrl();
        t.autoScrollService = new LH({
          scrollContainer: r.getBodyViewportElement(),
          scrollAxis: "y",
          getVerticalPosition: function() {
            return r.getScrollFeature().getVScrollPosition().top;
          },
          setVerticalPosition: function(o) {
            return r.getScrollFeature().setVerticalScrollPosition(o);
          },
          onScrollCallback: function() {
            t.onDragging(t.lastDraggingEvent);
          }
        });
      });
    }, e.prototype.onSortChanged = function() {
      this.isGridSorted = this.sortController.isSortActive();
    }, e.prototype.onFilterChanged = function() {
      this.isGridFiltered = this.filterManager.isAnyFilterPresent();
    }, e.prototype.onRowGroupChanged = function() {
      var t = this.columnModel.getRowGroupColumns();
      this.isRowGroupActive = !ds(t);
    }, e.prototype.getContainer = function() {
      return this.eContainer;
    }, e.prototype.isInterestedIn = function(t) {
      return t === ws.RowDrag;
    }, e.prototype.getIconName = function() {
      var t = this.gridOptionsWrapper.isRowDragManaged();
      return t && this.shouldPreventRowMove() ? _o.ICON_NOT_ALLOWED : _o.ICON_MOVE;
    }, e.prototype.shouldPreventRowMove = function() {
      return this.isGridSorted || this.isGridFiltered || this.isRowGroupActive;
    }, e.prototype.getRowNodes = function(t) {
      var i = this;
      if (!this.isFromThisGrid(t))
        return t.dragItem.rowNodes || [];
      var r = this.gridOptionsWrapper.isRowDragMultiRow(), o = lX(this.selectionService.getSelectedNodes()).sort(function(a, l) {
        return i.getRowIndexNumber(a) - i.getRowIndexNumber(l);
      }), s = t.dragItem.rowNode;
      return r && o.indexOf(s) !== -1 ? (this.isMultiRowDrag = !0, o) : (this.isMultiRowDrag = !1, [s]);
    }, e.prototype.onDragEnter = function(t) {
      t.dragItem.rowNodes = this.getRowNodes(t), this.dispatchGridEvent(I.EVENT_ROW_DRAG_ENTER, t), this.getRowNodes(t).forEach(function(i) {
        i.setDragging(!0);
      }), this.onEnterOrDragging(t);
    }, e.prototype.onDragging = function(t) {
      this.onEnterOrDragging(t);
    }, e.prototype.isFromThisGrid = function(t) {
      var i = t.dragSource.dragSourceDomDataKey;
      return i === this.gridOptionsWrapper.getDomDataKey();
    }, e.prototype.isDropZoneWithinThisGrid = function(t) {
      var i = this.ctrlsService.getGridBodyCtrl(), r = i.getGui(), o = t.dropZoneTarget;
      return !r.contains(o);
    }, e.prototype.onEnterOrDragging = function(t) {
      this.dispatchGridEvent(I.EVENT_ROW_DRAG_MOVE, t), this.lastDraggingEvent = t;
      var i = this.mouseEventService.getNormalisedPosition(t).y, r = this.gridOptionsWrapper.isRowDragManaged();
      r && this.doManagedDrag(t, i), this.autoScrollService.check(t.event);
    }, e.prototype.doManagedDrag = function(t, i) {
      var r = this.isFromThisGrid(t), o = this.gridOptionsWrapper.isRowDragManaged(), s = t.dragItem.rowNodes;
      o && this.shouldPreventRowMove() || (this.gridOptionsWrapper.isSuppressMoveWhenRowDragging() || !r ? this.isDropZoneWithinThisGrid(t) || this.clientSideRowModel.highlightRowAtPixel(s[0], i) : this.moveRows(s, i));
    }, e.prototype.getRowIndexNumber = function(t) {
      return parseInt(Di(t.getRowIndexString().split("-")), 10);
    }, e.prototype.moveRowAndClearHighlight = function(t) {
      var i = this, r = this.clientSideRowModel.getLastHighlightedRowNode(), o = r && r.highlighted === Ed.Below, s = this.mouseEventService.getNormalisedPosition(t).y, a = t.dragItem.rowNodes, l = o ? 1 : 0;
      if (this.isFromThisGrid(t))
        a.forEach(function(h) {
          h.rowTop < s && (l -= 1);
        }), this.moveRows(a, s, l);
      else {
        var u = this.gridOptionsWrapper.getRowIdFunc(), c = this.clientSideRowModel.getRowIndexAtPixel(s) + 1;
        this.clientSideRowModel.getHighlightPosition(s) === Ed.Above && c--, this.clientSideRowModel.updateRowData({
          add: a.map(function(h) {
            return h.data;
          }).filter(function(h) {
            return !i.clientSideRowModel.getRowNode(u ? u({ data: h, level: 0, api: i.gridApi, columnApi: i.columnApi }) : h.id);
          }),
          addIndex: c
        });
      }
      this.clearRowHighlight();
    }, e.prototype.clearRowHighlight = function() {
      this.clientSideRowModel.highlightRowAtPixel(null);
    }, e.prototype.moveRows = function(t, i, r) {
      r === void 0 && (r = 0);
      var o = this.clientSideRowModel.ensureRowsAtPixel(t, i, r);
      o && (this.focusService.clearFocusedCell(), this.rangeService && this.rangeService.removeAllCellRanges());
    }, e.prototype.addRowDropZone = function(t) {
      var i = this;
      if (!t.getContainer()) {
        mi(function() {
          return console.warn("AG Grid: addRowDropZone - A container target needs to be provided");
        }, "add-drop-zone-empty-target");
        return;
      }
      if (this.dragAndDropService.findExternalZone(t)) {
        console.warn("AG Grid: addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.");
        return;
      }
      var r = {
        getContainer: t.getContainer
      };
      t.fromGrid ? (t.fromGrid = void 0, r = t) : (t.onDragEnter && (r.onDragEnter = function(o) {
        t.onDragEnter(i.draggingToRowDragEvent(I.EVENT_ROW_DRAG_ENTER, o));
      }), t.onDragLeave && (r.onDragLeave = function(o) {
        t.onDragLeave(i.draggingToRowDragEvent(I.EVENT_ROW_DRAG_LEAVE, o));
      }), t.onDragging && (r.onDragging = function(o) {
        t.onDragging(i.draggingToRowDragEvent(I.EVENT_ROW_DRAG_MOVE, o));
      }), t.onDragStop && (r.onDragStop = function(o) {
        t.onDragStop(i.draggingToRowDragEvent(I.EVENT_ROW_DRAG_END, o));
      })), this.dragAndDropService.addDropTarget(V1({ isInterestedIn: function(o) {
        return o === ws.RowDrag;
      }, getIconName: function() {
        return _o.ICON_MOVE;
      }, external: !0 }, r));
    }, e.prototype.getRowDropZone = function(t) {
      var i = this, r = this.getContainer.bind(this), o = this.onDragEnter.bind(this), s = this.onDragLeave.bind(this), a = this.onDragging.bind(this), l = this.onDragStop.bind(this);
      return t ? {
        getContainer: r,
        onDragEnter: t.onDragEnter ? function(u) {
          o(u), t.onDragEnter(i.draggingToRowDragEvent(I.EVENT_ROW_DRAG_ENTER, u));
        } : o,
        onDragLeave: t.onDragLeave ? function(u) {
          s(u), t.onDragLeave(i.draggingToRowDragEvent(I.EVENT_ROW_DRAG_LEAVE, u));
        } : s,
        onDragging: t.onDragging ? function(u) {
          a(u), t.onDragging(i.draggingToRowDragEvent(I.EVENT_ROW_DRAG_MOVE, u));
        } : a,
        onDragStop: t.onDragStop ? function(u) {
          l(u), t.onDragStop(i.draggingToRowDragEvent(I.EVENT_ROW_DRAG_END, u));
        } : l,
        fromGrid: !0
        /* @private */
      } : {
        getContainer: r,
        onDragEnter: o,
        onDragLeave: s,
        onDragging: a,
        onDragStop: l,
        /* @private */
        fromGrid: !0
      };
    }, e.prototype.draggingToRowDragEvent = function(t, i) {
      var r = this.mouseEventService.getNormalisedPosition(i).y, o = r > this.paginationProxy.getCurrentPageHeight(), s = -1, a;
      o || (s = this.rowModel.getRowIndexAtPixel(r), a = this.rowModel.getRow(s));
      var l;
      switch (i.vDirection) {
        case Ld.Down:
          l = "down";
          break;
        case Ld.Up:
          l = "up";
          break;
        default:
          l = null;
          break;
      }
      var u = {
        type: t,
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        event: i.event,
        node: i.dragItem.rowNode,
        nodes: i.dragItem.rowNodes,
        overIndex: s,
        overNode: a,
        y: r,
        vDirection: l
      };
      return u;
    }, e.prototype.dispatchGridEvent = function(t, i) {
      var r = this.draggingToRowDragEvent(t, i);
      this.eventService.dispatchEvent(r);
    }, e.prototype.onDragLeave = function(t) {
      this.dispatchGridEvent(I.EVENT_ROW_DRAG_LEAVE, t), this.stopDragging(t), this.gridOptionsWrapper.isRowDragManaged() && this.clearRowHighlight(), this.isFromThisGrid(t) && (this.isMultiRowDrag = !1);
    }, e.prototype.onDragStop = function(t) {
      this.dispatchGridEvent(I.EVENT_ROW_DRAG_END, t), this.stopDragging(t), this.gridOptionsWrapper.isRowDragManaged() && (this.gridOptionsWrapper.isSuppressMoveWhenRowDragging() || !this.isFromThisGrid(t)) && !this.isDropZoneWithinThisGrid(t) && this.moveRowAndClearHighlight(t);
    }, e.prototype.stopDragging = function(t) {
      this.autoScrollService.ensureCleared(), this.getRowNodes(t).forEach(function(i) {
        i.setDragging(!1);
      });
    }, No([
      R("dragAndDropService")
    ], e.prototype, "dragAndDropService", void 0), No([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), No([
      R("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), No([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), No([
      R("focusService")
    ], e.prototype, "focusService", void 0), No([
      R("sortController")
    ], e.prototype, "sortController", void 0), No([
      R("filterManager")
    ], e.prototype, "filterManager", void 0), No([
      R("selectionService")
    ], e.prototype, "selectionService", void 0), No([
      R("mouseEventService")
    ], e.prototype, "mouseEventService", void 0), No([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), No([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), No([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), No([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), No([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var cX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ns = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Dd;
(function(n) {
  n.ANIMATION_ON = "ag-row-animation", n.ANIMATION_OFF = "ag-row-no-animation";
})(Dd || (Dd = {}));
var DH = "ag-selectable", RH = "ag-force-vertical-scroll", TH = "ag-column-moving", OH = (
  /** @class */
  function(n) {
    cX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.angularApplyTriggered = !1, t;
    }
    return e.prototype.getScrollFeature = function() {
      return this.bodyScrollFeature;
    }, e.prototype.getBodyViewportElement = function() {
      return this.eBodyViewport;
    }, e.prototype.setComp = function(t, i, r, o, s) {
      this.comp = t, this.eGridBody = i, this.eBodyViewport = r, this.eTop = o, this.eBottom = s, this.setCellTextSelection(this.gridOptionsWrapper.isEnableCellTextSelect()), this.createManagedBean(new Ex(this.comp)), this.bodyScrollFeature = this.createManagedBean(new oX(this.eBodyViewport)), this.addRowDragListener(), this.setupRowAnimationCssClass(), this.ctrlsService.registerGridBodyCtrl(this), this.addEventListeners(), this.addFocusListeners([o, r, s]), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), this.$scope && this.addAngularApplyCheck();
    }, e.prototype.getComp = function() {
      return this.comp;
    }, e.prototype.addEventListeners = function() {
      this.addManagedListener(this.eventService, I.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_PINNED_ROW_DATA_CHANGED, this.setFloatingHeights.bind(this));
    }, e.prototype.addFocusListeners = function(t) {
      var i = this;
      t.forEach(function(r) {
        i.addManagedListener(r, "focusin", function() {
          r.classList.add("ag-has-focus");
        }), i.addManagedListener(r, "focusout", function(o) {
          r.contains(o.relatedTarget) || r.classList.remove("ag-has-focus");
        });
      });
    }, e.prototype.setColumnMovingCss = function(t) {
      this.comp.setColumnMovingCss(t ? TH : null, t);
    }, e.prototype.setCellTextSelection = function(t) {
      t === void 0 && (t = !1);
      var i = t ? DH : null;
      this.comp.setCellSelectableCss(i, t);
    }, e.prototype.onScrollVisibilityChanged = function() {
      var t = this.scrollVisibleService.isVerticalScrollShowing();
      this.setVerticalScrollPaddingVisible(t);
    }, e.prototype.onGridColumnsChanged = function() {
      var t = this.columnModel.getAllGridColumns();
      this.comp.setColumnCount(t ? t.length : 0);
    }, e.prototype.disableBrowserDragging = function() {
      this.addManagedListener(this.eGridBody, "dragstart", function(t) {
        if (t.target instanceof HTMLImageElement)
          return t.preventDefault(), !1;
      });
    }, e.prototype.addStopEditingWhenGridLosesFocus = function() {
      var t = this;
      if (this.gridOptionsWrapper.isStopEditingWhenCellsLoseFocus()) {
        var i = function(o) {
          var s = o.relatedTarget;
          if (Pw(s) === null) {
            t.rowRenderer.stopEditing();
            return;
          }
          var a = (
            // see if click came from inside the viewports
            r.some(function(u) {
              return u.contains(s);
            }) && t.mouseEventService.isElementInThisGrid(s)
          );
          if (!a) {
            var l = t.popupService;
            a = l.getActivePopups().some(function(u) {
              return u.contains(s);
            }) || l.isElementWithinCustomPopup(s);
          }
          a || t.rowRenderer.stopEditing();
        }, r = [this.eBodyViewport, this.eBottom, this.eTop];
        r.forEach(function(o) {
          return t.addManagedListener(o, "focusout", i);
        });
      }
    }, e.prototype.updateRowCount = function() {
      var t = this.headerNavigationService.getHeaderRowCount(), i = this.paginationProxy.getType(), r = -1;
      i === q.ROW_MODEL_TYPE_CLIENT_SIDE && (r = 0, this.paginationProxy.forEachNode(function(s) {
        s.group || r++;
      }));
      var o = r === -1 ? -1 : t + r;
      this.comp.setRowCount(o);
    }, e.prototype.registerBodyViewportResizeListener = function(t) {
      this.comp.registerBodyViewportResizeListener(t);
    }, e.prototype.setVerticalScrollPaddingVisible = function(t) {
      var i = t ? "scroll" : "hidden";
      this.comp.setPinnedTopBottomOverflowY(i);
    }, e.prototype.isVerticalScrollShowing = function() {
      var t = this.gridOptionsWrapper.isAlwaysShowVerticalScroll(), i = t ? RH : null;
      return this.comp.setAlwaysVerticalScrollClass(i, t), t || mB(this.eBodyViewport);
    }, e.prototype.setupRowAnimationCssClass = function() {
      var t = this, i = function() {
        var r = t.gridOptionsWrapper.isAnimateRows() && !t.rowContainerHeightService.isStretching(), o = r ? Dd.ANIMATION_ON : Dd.ANIMATION_OFF;
        t.comp.setRowAnimationCssOnBodyViewport(o, r);
      };
      i(), this.addManagedListener(this.eventService, I.EVENT_HEIGHT_SCALE_CHANGED, i);
    }, e.prototype.getGridBodyElement = function() {
      return this.eGridBody;
    }, e.prototype.addBodyViewportListener = function() {
      var t = this, i = function(r) {
        t.gridOptionsWrapper.isPreventDefaultOnContextMenu() && r.preventDefault();
        var o = r.target;
        (o === t.eBodyViewport || o === t.ctrlsService.getCenterRowContainerCtrl().getViewportElement()) && t.contextMenuFactory && t.contextMenuFactory.onContextMenu(r, null, null, null, null, t.eGridBody);
      };
      this.addManagedListener(this.eBodyViewport, "contextmenu", i), this.addManagedListener(this.eBodyViewport, "wheel", this.onWheel.bind(this));
    }, e.prototype.onWheel = function(t) {
      this.gridOptionsWrapper.isSuppressScrollWhenPopupsAreOpen() && this.popupService.hasAnchoredPopup() && t.preventDefault();
    }, e.prototype.getGui = function() {
      return this.eGridBody;
    }, e.prototype.scrollVertically = function(t) {
      var i = this.eBodyViewport.scrollTop;
      return this.bodyScrollFeature.setVerticalScrollPosition(i + t), this.eBodyViewport.scrollTop - i;
    }, e.prototype.addRowDragListener = function() {
      this.rowDragFeature = this.createManagedBean(new uX(this.eBodyViewport)), this.dragAndDropService.addDropTarget(this.rowDragFeature);
    }, e.prototype.getRowDragFeature = function() {
      return this.rowDragFeature;
    }, e.prototype.setFloatingHeights = function() {
      var t = this.pinnedRowModel, i = t.getPinnedTopTotalHeight();
      i && (i += 1);
      var r = t.getPinnedBottomTotalHeight();
      r && (r += 1), this.comp.setTopHeight(i), this.comp.setBottomHeight(r), this.comp.setTopDisplay(i ? "inherit" : "none"), this.comp.setBottomDisplay(r ? "inherit" : "none");
    }, e.prototype.sizeColumnsToFit = function(t) {
      var i = this, r = this.isVerticalScrollShowing(), o = r ? this.gridOptionsWrapper.getScrollbarWidth() : 0, s = wS(this.eBodyViewport), a = s - o;
      if (a > 0) {
        this.columnModel.sizeColumnsToFit(a, "sizeColumnsToFit");
        return;
      }
      t === void 0 ? window.setTimeout(function() {
        i.sizeColumnsToFit(100);
      }, 0) : t === 100 ? window.setTimeout(function() {
        i.sizeColumnsToFit(500);
      }, 100) : t === 500 ? window.setTimeout(function() {
        i.sizeColumnsToFit(-1);
      }, 500) : console.warn("AG Grid: tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?");
    }, e.prototype.addScrollEventListener = function(t) {
      this.eBodyViewport.addEventListener("scroll", t);
    }, e.prototype.removeScrollEventListener = function(t) {
      this.eBodyViewport.removeEventListener("scroll", t);
    }, e.prototype.requestAngularApply = function() {
      var t = this;
      this.angularApplyTriggered || (this.angularApplyTriggered = !0, window.setTimeout(function() {
        t.angularApplyTriggered = !1, t.$scope.$apply();
      }, 0));
    }, e.prototype.addAngularApplyCheck = function() {
      var t = this;
      this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, function() {
        return t.requestAngularApply();
      }), this.addManagedListener(this.eventService, I.EVENT_VIRTUAL_COLUMNS_CHANGED, function() {
        return t.requestAngularApply();
      });
    }, ns([
      R("rowContainerHeightService")
    ], e.prototype, "rowContainerHeightService", void 0), ns([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), ns([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), ns([
      R("scrollVisibleService")
    ], e.prototype, "scrollVisibleService", void 0), ns([
      fi("contextMenuFactory")
    ], e.prototype, "contextMenuFactory", void 0), ns([
      R("headerNavigationService")
    ], e.prototype, "headerNavigationService", void 0), ns([
      R("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), ns([
      R("dragAndDropService")
    ], e.prototype, "dragAndDropService", void 0), ns([
      R("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), ns([
      R("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), ns([
      R("popupService")
    ], e.prototype, "popupService", void 0), ns([
      R("mouseEventService")
    ], e.prototype, "mouseEventService", void 0), ns([
      R("$scope")
    ], e.prototype, "$scope", void 0), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var hX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Nh = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, dX = (
  /* html */
  `<div class="ag-root ag-unselectable" role="grid">
        <ag-header-root ref="gridHeader"></ag-header-root>
        <div class="ag-floating-top" ref="eTop" role="presentation">
            <ag-row-container ref="topLeftContainer" name="` + _e.TOP_LEFT + `"></ag-row-container>
            <ag-row-container ref="topCenterContainer" name="` + _e.TOP_CENTER + `"></ag-row-container>
            <ag-row-container ref="topRightContainer" name="` + _e.TOP_RIGHT + `"></ag-row-container>
            <ag-row-container ref="topFullWidthContainer" name="` + _e.TOP_FULL_WIDTH + `"></ag-row-container>
        </div>
        <div class="ag-body-viewport" ref="eBodyViewport" role="presentation">
            <ag-row-container ref="leftContainer" name="` + _e.LEFT + `"></ag-row-container>
            <ag-row-container ref="centerContainer" name="` + _e.CENTER + `"></ag-row-container>
            <ag-row-container ref="rightContainer" name="` + _e.RIGHT + `"></ag-row-container>
            <ag-row-container ref="fullWidthContainer" name="` + _e.FULL_WIDTH + `"></ag-row-container>
        </div>
        <div class="ag-floating-bottom" ref="eBottom" role="presentation">
            <ag-row-container ref="bottomLeftContainer" name="` + _e.BOTTOM_LEFT + `"></ag-row-container>
            <ag-row-container ref="bottomCenterContainer" name="` + _e.BOTTOM_CENTER + `"></ag-row-container>
            <ag-row-container ref="bottomRightContainer" name="` + _e.BOTTOM_RIGHT + `"></ag-row-container>
            <ag-row-container ref="bottomFullWidthContainer" name="` + _e.BOTTOM_FULL_WIDTH + `"></ag-row-container>
        </div>
        <ag-fake-horizontal-scroll></ag-fake-horizontal-scroll>
        <ag-overlay-wrapper></ag-overlay-wrapper>
    </div>`
), xH = (
  /** @class */
  function(n) {
    hX(e, n);
    function e() {
      return n.call(this, dX) || this;
    }
    return e.prototype.init = function() {
      var t = this, i = function(o, s) {
        var a = o + "px";
        s.style.minHeight = a, s.style.height = a;
      }, r = {
        setRowAnimationCssOnBodyViewport: function(o, s) {
          return t.setRowAnimationCssOnBodyViewport(o, s);
        },
        setColumnCount: function(o) {
          return TB(t.getGui(), o);
        },
        setRowCount: function(o) {
          return RB(t.getGui(), o);
        },
        setTopHeight: function(o) {
          return i(o, t.eTop);
        },
        setBottomHeight: function(o) {
          return i(o, t.eBottom);
        },
        setTopDisplay: function(o) {
          return t.eTop.style.display = o;
        },
        setBottomDisplay: function(o) {
          return t.eBottom.style.display = o;
        },
        setColumnMovingCss: function(o, s) {
          return t.addOrRemoveCssClass(TH, s);
        },
        updateLayoutClasses: function(o, s) {
          var a = t.eBodyViewport.classList;
          a.toggle(Fn.AUTO_HEIGHT, s.autoHeight), a.toggle(Fn.NORMAL, s.normal), a.toggle(Fn.PRINT, s.print), t.addOrRemoveCssClass(Fn.AUTO_HEIGHT, s.autoHeight), t.addOrRemoveCssClass(Fn.NORMAL, s.normal), t.addOrRemoveCssClass(Fn.PRINT, s.print);
        },
        setAlwaysVerticalScrollClass: function(o, s) {
          return t.eBodyViewport.classList.toggle(RH, s);
        },
        registerBodyViewportResizeListener: function(o) {
          var s = t.resizeObserverService.observeResize(t.eBodyViewport, o);
          t.addDestroyFunc(function() {
            return s();
          });
        },
        setPinnedTopBottomOverflowY: function(o) {
          return t.eTop.style.overflowY = t.eBottom.style.overflowY = o;
        },
        setCellSelectableCss: function(o, s) {
          [t.eTop, t.eBodyViewport, t.eBottom].forEach(function(a) {
            return a.classList.toggle(DH, s);
          });
        }
      };
      this.ctrl = this.createManagedBean(new OH()), this.ctrl.setComp(r, this.getGui(), this.eBodyViewport, this.eTop, this.eBottom), (this.rangeService || this.gridOptionsWrapper.isRowSelectionMulti()) && DB(this.getGui(), !0);
    }, e.prototype.setRowAnimationCssOnBodyViewport = function(t, i) {
      var r = this.eBodyViewport.classList;
      r.toggle(Dd.ANIMATION_ON, i), r.toggle(Dd.ANIMATION_OFF, !i);
    }, e.prototype.getFloatingTopBottom = function() {
      return [this.eTop, this.eBottom];
    }, Nh([
      R("resizeObserverService")
    ], e.prototype, "resizeObserverService", void 0), Nh([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), Nh([
      fe("eBodyViewport")
    ], e.prototype, "eBodyViewport", void 0), Nh([
      fe("eTop")
    ], e.prototype, "eTop", void 0), Nh([
      fe("eBottom")
    ], e.prototype, "eBottom", void 0), Nh([
      fe("gridHeader")
    ], e.prototype, "headerRootComp", void 0), Nh([
      Ee
    ], e.prototype, "init", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var fX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), LM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, pX = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, NH = (
  /** @class */
  function(n) {
    fX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.expressionToFunctionCache = {}, t;
    }
    return e.prototype.setBeans = function(t) {
      this.logger = t.create("ExpressionService");
    }, e.prototype.evaluate = function(t, i) {
      if (typeof t == "function") {
        var r = t;
        return r(i);
      } else if (typeof t == "string") {
        var o = t;
        return this.evaluateExpression(o, i);
      } else
        console.error("AG Grid: value should be either a string or a function", t);
    }, e.prototype.evaluateExpression = function(t, i) {
      try {
        var r = this.createExpressionFunction(t), o = r(i.value, i.context, i.oldValue, i.newValue, i.value, i.node, i.data, i.colDef, i.rowIndex, i.api, i.columnApi, i.getValue, i.column, i.columnGroup);
        return o;
      } catch (s) {
        return console.log("Processing of the expression failed"), console.log("Expression = " + t), console.log("Params =", i), console.log("Exception = " + s), null;
      }
    }, e.prototype.createExpressionFunction = function(t) {
      if (this.expressionToFunctionCache[t])
        return this.expressionToFunctionCache[t];
      var i = this.createFunctionBody(t), r = new Function("x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, columnApi, getValue, column, columnGroup", i);
      return this.expressionToFunctionCache[t] = r, r;
    }, e.prototype.createFunctionBody = function(t) {
      return t.indexOf("return") >= 0 ? t : "return " + t + ";";
    }, LM([
      pX(0, wo("loggerFactory"))
    ], e.prototype, "setBeans", null), e = LM([
      Ke("expressionService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), DM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, IH = (
  /** @class */
  function(n) {
    gX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.templateCache = {}, t.waitingCallbacks = {}, t;
    }
    return e.prototype.getTemplate = function(t, i) {
      var r = this.templateCache[t];
      if (r)
        return r;
      var o = this.waitingCallbacks[t], s = this;
      if (!o) {
        o = [], this.waitingCallbacks[t] = o;
        var a = new XMLHttpRequest();
        a.onload = function() {
          s.handleHttpResult(this, t);
        }, a.open("GET", t), a.send();
      }
      return i && o.push(i), null;
    }, e.prototype.handleHttpResult = function(t, i) {
      if (t.status !== 200 || t.response === null) {
        console.warn("AG Grid: Unable to get template error " + t.status + " - " + i);
        return;
      }
      this.templateCache[i] = t.response || t.responseText;
      for (var r = this.waitingCallbacks[i], o = 0; o < r.length; o++) {
        var s = r[o];
        s();
      }
      if (this.$scope) {
        var a = this;
        window.setTimeout(function() {
          a.$scope.$apply();
        }, 0);
      }
    }, DM([
      R("$scope")
    ], e.prototype, "$scope", void 0), e = DM([
      Ke("templateService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var mX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Ks = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, vX = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, _X = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(vX(arguments[e]));
  return n;
}, ap = (
  /** @class */
  function(n) {
    mX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    t = e, e.addKeyboardModeEvents = function(i, r) {
      var o = t.instancesMonitored.get(i);
      o && o.length > 0 ? o.indexOf(r) === -1 && o.push(r) : (t.instancesMonitored.set(i, [r]), i.addEventListener("keydown", t.toggleKeyboardMode), i.addEventListener("mousedown", t.toggleKeyboardMode));
    }, e.removeKeyboardModeEvents = function(i, r) {
      var o = t.instancesMonitored.get(i), s = [];
      o && o.length && (s = _X(o).filter(function(a) {
        return a !== r;
      }), t.instancesMonitored.set(i, s)), s.length === 0 && (i.removeEventListener("keydown", t.toggleKeyboardMode), i.removeEventListener("mousedown", t.toggleKeyboardMode));
    }, e.toggleKeyboardMode = function(i) {
      var r = t.keyboardModeActive, o = i.type === "keydown";
      if (!(o && (i.ctrlKey || i.metaKey || i.altKey)) && !(r && o || !r && !o)) {
        t.keyboardModeActive = o;
        var s = i.target.ownerDocument;
        if (s) {
          var a = t.instancesMonitored.get(s);
          a && a.forEach(function(l) {
            l.dispatchEvent({ type: o ? I.EVENT_KEYBOARD_FOCUS : I.EVENT_MOUSE_FOCUS });
          });
        }
      }
    }, e.prototype.init = function() {
      var i = this, r = this.clearFocusedCell.bind(this);
      this.addManagedListener(this.eventService, I.EVENT_COLUMN_PIVOT_MODE_CHANGED, r), this.addManagedListener(this.eventService, I.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverythingChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_COLUMN_GROUP_OPENED, r), this.addManagedListener(this.eventService, I.EVENT_COLUMN_ROW_GROUP_CHANGED, r), this.ctrlsService.whenReady(function(o) {
        i.gridCtrl = o.gridCtrl;
        var s = i.gridOptionsWrapper.getDocument();
        t.addKeyboardModeEvents(s, i.gridCtrl), i.addDestroyFunc(function() {
          return i.unregisterGridCompController(i.gridCtrl);
        });
      });
    }, e.prototype.unregisterGridCompController = function(i) {
      var r = this.gridOptionsWrapper.getDocument();
      t.removeKeyboardModeEvents(r, i);
    }, e.prototype.onColumnEverythingChanged = function() {
      if (this.focusedCellPosition) {
        var i = this.focusedCellPosition.column, r = this.columnModel.getGridColumn(i.getId());
        i !== r && this.clearFocusedCell();
      }
    }, e.prototype.isKeyboardMode = function() {
      return t.keyboardModeActive;
    }, e.prototype.getFocusCellToUseAfterRefresh = function() {
      var i = this.gridOptionsWrapper.getDocument();
      return this.gridOptionsWrapper.isSuppressFocusAfterRefresh() || !this.focusedCellPosition || this.isDomDataMissingInHierarchy(i.activeElement, $c.DOM_DATA_KEY_ROW_CTRL) ? null : this.focusedCellPosition;
    }, e.prototype.getFocusHeaderToUseAfterRefresh = function() {
      var i = this.gridOptionsWrapper.getDocument();
      return this.gridOptionsWrapper.isSuppressFocusAfterRefresh() || !this.focusedHeaderPosition || this.isDomDataMissingInHierarchy(i.activeElement, R_.DOM_DATA_KEY_HEADER_CTRL) ? null : this.focusedHeaderPosition;
    }, e.prototype.isDomDataMissingInHierarchy = function(i, r) {
      for (var o = i; o; ) {
        var s = this.gridOptionsWrapper.getDomData(o, r);
        if (s)
          return !1;
        o = o.parentNode;
      }
      return !0;
    }, e.prototype.clearFocusedCell = function() {
      this.focusedCellPosition = null, this.onCellFocused(!1);
    }, e.prototype.getFocusedCell = function() {
      return this.focusedCellPosition;
    }, e.prototype.setFocusedCell = function(i, r, o, s) {
      s === void 0 && (s = !1);
      var a = this.columnModel.getGridColumn(r);
      if (!a) {
        this.focusedCellPosition = null;
        return;
      }
      this.focusedCellPosition = a ? { rowIndex: i, rowPinned: op(o), column: a } : null, this.onCellFocused(s);
    }, e.prototype.isCellFocused = function(i) {
      return this.focusedCellPosition == null ? !1 : this.focusedCellPosition.column === i.column && this.isRowFocused(i.rowIndex, i.rowPinned);
    }, e.prototype.isRowNodeFocused = function(i) {
      return this.isRowFocused(i.rowIndex, i.rowPinned);
    }, e.prototype.isHeaderWrapperFocused = function(i) {
      if (this.focusedHeaderPosition == null)
        return !1;
      var r = i.getColumnGroupChild(), o = i.getRowIndex(), s = i.getPinned(), a = this.focusedHeaderPosition, l = a.column, u = a.headerRowIndex;
      return r === l && o === u && s == l.getPinned();
    }, e.prototype.clearFocusedHeader = function() {
      this.focusedHeaderPosition = null;
    }, e.prototype.getFocusedHeader = function() {
      return this.focusedHeaderPosition;
    }, e.prototype.setFocusedHeader = function(i, r) {
      this.focusedHeaderPosition = { headerRowIndex: i, column: r };
    }, e.prototype.focusHeaderPosition = function(i) {
      var r = i.direction, o = i.fromTab, s = i.allowUserOverride, a = i.event, l = i.headerPosition;
      if (s) {
        var u = this.gridOptionsWrapper, c = this.getFocusedHeader(), h = this.headerNavigationService.getHeaderRowCount();
        if (o) {
          var d = u.getTabToNextHeaderFunc();
          if (d) {
            var f = {
              backwards: r === "Before",
              previousHeaderPosition: c,
              nextHeaderPosition: l,
              headerRowCount: h,
              api: u.getApi(),
              columnApi: u.getColumnApi()
            };
            l = d(f);
          }
        } else {
          var d = u.getNavigateToNextHeaderFunc();
          if (d && a) {
            var p = {
              key: a.key,
              previousHeaderPosition: c,
              nextHeaderPosition: l,
              headerRowCount: h,
              event: a,
              api: u.getApi(),
              columnApi: u.getColumnApi()
            };
            l = d(p);
          }
        }
      }
      if (!l)
        return !1;
      if (l.headerRowIndex === -1)
        return this.focusGridView(l.column);
      this.headerNavigationService.scrollToColumn(l.column, r);
      var g = this.ctrlsService.getHeaderRowContainerCtrl(l.column.getPinned()), _ = g.focusHeader(l.headerRowIndex, l.column, a);
      return _;
    }, e.prototype.focusFirstHeader = function() {
      var i = this.columnModel.getAllDisplayedColumns()[0];
      return i ? (i.getParent() && (i = this.columnModel.getColumnGroupAtLevel(i, 0)), this.focusHeaderPosition({
        headerPosition: { headerRowIndex: 0, column: i }
      })) : !1;
    }, e.prototype.focusLastHeader = function(i) {
      var r = this.headerNavigationService.getHeaderRowCount() - 1, o = Di(this.columnModel.getAllDisplayedColumns());
      return this.focusHeaderPosition({
        headerPosition: { headerRowIndex: r, column: o },
        event: i
      });
    }, e.prototype.isAnyCellFocused = function() {
      return !!this.focusedCellPosition;
    }, e.prototype.isRowFocused = function(i, r) {
      return this.focusedCellPosition == null ? !1 : this.focusedCellPosition.rowIndex === i && this.focusedCellPosition.rowPinned === op(r);
    }, e.prototype.findFocusableElements = function(i, r, o) {
      o === void 0 && (o = !1);
      var s = q.FOCUSABLE_SELECTOR, a = q.FOCUSABLE_EXCLUDE;
      r && (a += ", " + r), o && (a += ', [tabindex="-1"]');
      var l = Array.prototype.slice.apply(i.querySelectorAll(s)), u = Array.prototype.slice.apply(i.querySelectorAll(a));
      if (!u.length)
        return l;
      var c = function(h, d) {
        return h.filter(function(f) {
          return d.indexOf(f) === -1;
        });
      };
      return c(l, u);
    }, e.prototype.focusInto = function(i, r, o) {
      r === void 0 && (r = !1), o === void 0 && (o = !1);
      var s = this.findFocusableElements(i, null, o), a = r ? Di(s) : s[0];
      return a ? (a.focus(), !0) : !1;
    }, e.prototype.findNextFocusableElement = function(i, r, o) {
      i === void 0 && (i = this.eGridDiv);
      var s = this.findFocusableElements(i, r ? ':not([tabindex="-1"])' : null), a = this.gridOptionsWrapper.getDocument(), l = a.activeElement, u;
      r ? u = s.findIndex(function(h) {
        return h.contains(l);
      }) : u = s.indexOf(l);
      var c = u + (o ? -1 : 1);
      return c < 0 || c >= s.length ? null : s[c];
    }, e.prototype.isFocusUnderManagedComponent = function(i) {
      var r = this.gridOptionsWrapper.getDocument(), o = i.querySelectorAll("." + Qu.FOCUS_MANAGED_CLASS);
      if (!o.length)
        return !1;
      for (var s = 0; s < o.length; s++)
        if (o[s].contains(r.activeElement))
          return !0;
      return !1;
    }, e.prototype.findTabbableParent = function(i, r) {
      r === void 0 && (r = 5);
      for (var o = 0; i && Pw(i) === null && ++o <= r; )
        i = i.parentElement;
      return Pw(i) === null ? null : i;
    }, e.prototype.onCellFocused = function(i) {
      var r = {
        type: I.EVENT_CELL_FOCUSED,
        forceBrowserFocus: i,
        rowIndex: null,
        column: null,
        floating: null,
        api: this.gridApi,
        columnApi: this.columnApi,
        rowPinned: null,
        isFullWidthCell: !1
      };
      if (this.focusedCellPosition) {
        var o = r.rowIndex = this.focusedCellPosition.rowIndex, s = r.rowPinned = this.focusedCellPosition.rowPinned;
        r.column = this.focusedCellPosition.column;
        var a = this.rowRenderer.getRowByPosition({ rowIndex: o, rowPinned: s });
        a && (r.isFullWidthCell = a.isFullWidth());
      }
      this.eventService.dispatchEvent(r);
    }, e.prototype.focusGridView = function(i, r) {
      if (this.gridOptionsWrapper.isSuppressCellFocus())
        return r ? this.focusLastHeader() : this.focusNextGridCoreContainer(!1);
      var o = r ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
      if (!o)
        return !1;
      var s = o.rowIndex, a = o.rowPinned, l = this.getFocusedHeader();
      if (!i && l && (i = l.column), s == null || !i)
        return !1;
      if (this.navigationService.ensureCellVisible({ rowIndex: s, column: i, rowPinned: a }), this.setFocusedCell(s, i, op(a), !0), this.rangeService) {
        var u = { rowIndex: s, rowPinned: a, column: i };
        this.rangeService.setRangeToCell(u);
      }
      return !0;
    }, e.prototype.focusNextGridCoreContainer = function(i) {
      return this.gridCtrl.focusNextInnerContainer(i) ? !0 : (i || this.gridCtrl.forceFocusOutOfContainer(), !1);
    };
    var t;
    return e.AG_KEYBOARD_FOCUS = "ag-keyboard-focus", e.keyboardModeActive = !1, e.instancesMonitored = /* @__PURE__ */ new Map(), Ks([
      R("eGridDiv")
    ], e.prototype, "eGridDiv", void 0), Ks([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), Ks([
      R("headerNavigationService")
    ], e.prototype, "headerNavigationService", void 0), Ks([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), Ks([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), Ks([
      R("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), Ks([
      R("rowPositionUtils")
    ], e.prototype, "rowPositionUtils", void 0), Ks([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), Ks([
      R("navigationService")
    ], e.prototype, "navigationService", void 0), Ks([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Ks([
      Ee
    ], e.prototype, "init", null), e = t = Ks([
      Ke("focusService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var CX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), um = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, xc;
(function(n) {
  n[n.vertical = 0] = "vertical", n[n.horizontal = 1] = "horizontal";
})(xc || (xc = {}));
var yX = 0, PH = (
  /** @class */
  function(n) {
    CX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.popupList = [], t;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        t.gridCtrl = i.gridCtrl, t.addManagedListener(t.gridCtrl, I.EVENT_KEYBOARD_FOCUS, function() {
          t.popupList.forEach(function(r) {
            return r.element.classList.add(ap.AG_KEYBOARD_FOCUS);
          });
        }), t.addManagedListener(t.gridCtrl, I.EVENT_MOUSE_FOCUS, function() {
          t.popupList.forEach(function(r) {
            return r.element.classList.remove(ap.AG_KEYBOARD_FOCUS);
          });
        });
      });
    }, e.prototype.getPopupParent = function() {
      var t = this.gridOptionsWrapper.getPopupParent();
      return t || this.gridCtrl.getGui();
    }, e.prototype.positionPopupForMenu = function(t) {
      var i = t.eventSource.getBoundingClientRect(), r = this.getParentRect(), o = this.keepXYWithinBounds(t.ePopup, i.top - r.top, xc.vertical), s = t.ePopup.clientWidth > 0 ? t.ePopup.clientWidth : 200;
      t.ePopup.style.minWidth = s + "px";
      var a = r.right - r.left, l = a - s, u;
      this.gridOptionsWrapper.isEnableRtl() ? (u = h(), u < 0 && (u = c()), u > l && (u = 0)) : (u = c(), u > l && (u = h()), u < 0 && (u = 0)), t.ePopup.style.left = u + "px", t.ePopup.style.top = o + "px";
      function c() {
        return i.right - r.left - 2;
      }
      function h() {
        return i.left - r.left - s;
      }
    }, e.prototype.positionPopupUnderMouseEvent = function(t) {
      var i = t.ePopup, r = t.nudgeX, o = t.nudgeY, s = this.calculatePointerAlign(t.mouseEvent), a = s.x, l = s.y;
      this.positionPopup({
        ePopup: i,
        x: a,
        y: l,
        nudgeX: r,
        nudgeY: o,
        keepWithinBounds: !0
      }), this.callPostProcessPopup(t.type, t.ePopup, null, t.mouseEvent, t.column, t.rowNode);
    }, e.prototype.calculatePointerAlign = function(t) {
      var i = this.getParentRect();
      return {
        x: t.clientX - i.left,
        y: t.clientY - i.top
      };
    }, e.prototype.positionPopupUnderComponent = function(t) {
      var i = t.eventSource.getBoundingClientRect(), r = t.alignSide || "left", o = this.getParentRect(), s = i.left - o.left;
      r === "right" && (s -= t.ePopup.offsetWidth - i.width), this.positionPopup({
        ePopup: t.ePopup,
        nudgeX: t.nudgeX,
        nudgeY: t.nudgeY,
        x: s,
        y: i.top - o.top + i.height,
        keepWithinBounds: t.keepWithinBounds
      }), this.callPostProcessPopup(t.type, t.ePopup, t.eventSource, null, t.column, t.rowNode);
    }, e.prototype.positionPopupOverComponent = function(t) {
      var i = t.eventSource.getBoundingClientRect(), r = this.getParentRect();
      this.positionPopup({
        ePopup: t.ePopup,
        nudgeX: t.nudgeX,
        nudgeY: t.nudgeY,
        x: i.left - r.left,
        y: i.top - r.top,
        keepWithinBounds: t.keepWithinBounds
      }), this.callPostProcessPopup(t.type, t.ePopup, t.eventSource, null, t.column, t.rowNode);
    }, e.prototype.callPostProcessPopup = function(t, i, r, o, s, a) {
      var l = this.gridOptionsWrapper.getPostProcessPopupFunc();
      if (l) {
        var u = {
          column: s,
          rowNode: a,
          ePopup: i,
          type: t,
          eventSource: r,
          mouseEvent: o
        };
        l(u);
      }
    }, e.prototype.positionPopup = function(t) {
      var i = t.ePopup, r = t.keepWithinBounds, o = t.nudgeX, s = t.nudgeY, a = t.x, l = t.y;
      o && (a += o), s && (l += s), r && (a = this.keepXYWithinBounds(i, a, xc.horizontal), l = this.keepXYWithinBounds(i, l, xc.vertical)), i.style.left = a + "px", i.style.top = l + "px";
    }, e.prototype.getActivePopups = function() {
      return this.popupList.map(function(t) {
        return t.element;
      });
    }, e.prototype.getPopupList = function() {
      return this.popupList;
    }, e.prototype.getParentRect = function() {
      var t = this.gridOptionsWrapper.getDocument(), i = this.getPopupParent();
      i === t.body && (i = t.documentElement);
      var r = getComputedStyle(i), o = i.getBoundingClientRect();
      return {
        top: o.top + parseFloat(r.borderTopWidth) || 0,
        left: o.left + parseFloat(r.borderLeftWidth) || 0,
        right: o.right + parseFloat(r.borderRightWidth) || 0,
        bottom: o.bottom + parseFloat(r.borderBottomWidth) || 0
      };
    }, e.prototype.keepXYWithinBounds = function(t, i, r) {
      var o = r === xc.vertical, s = o ? "clientHeight" : "clientWidth", a = o ? "top" : "left", l = o ? "offsetHeight" : "offsetWidth", u = o ? "scrollTop" : "scrollLeft", c = this.gridOptionsWrapper.getDocument(), h = c.documentElement, d = this.getPopupParent(), f = d.getBoundingClientRect(), p = c.documentElement.getBoundingClientRect(), g = d === c.body, _ = t[l], m = o ? ZO : bS, v = g ? m(h) + h[u] : d[s];
      g && (v -= Math.abs(p[a] - f[a]));
      var C = v - _;
      return Math.min(Math.max(i, 0), Math.abs(C));
    }, e.prototype.keepPopupPositionedRelativeTo = function(t) {
      var i = this, r = this.getPopupParent(), o = r.getBoundingClientRect(), s = t.element.getBoundingClientRect(), a = o.top - s.top, l = o.left - s.left, u = a, c = l, h = t.ePopup.style.top, d = parseInt(h.substring(0, h.length - 1), 10), f = t.ePopup.style.left, p = parseInt(f.substring(0, f.length - 1), 10);
      return new ko(function(g) {
        i.getFrameworkOverrides().setInterval(function() {
          var _ = r.getBoundingClientRect(), m = t.element.getBoundingClientRect(), v = m.top == 0 && m.left == 0 && m.height == 0 && m.width == 0;
          if (v) {
            t.hidePopup();
            return;
          }
          var C = _.top - m.top;
          if (C != u) {
            var y = i.keepXYWithinBounds(t.ePopup, d + a - C, xc.vertical);
            t.ePopup.style.top = y + "px";
          }
          u = C;
          var b = _.left - m.left;
          if (b != c) {
            var L = i.keepXYWithinBounds(t.ePopup, p + l - b, xc.horizontal);
            t.ePopup.style.left = L + "px";
          }
          c = b;
        }, 200).then(function(_) {
          var m = function() {
            _ != null && window.clearInterval(_);
          };
          g(m);
        });
      });
    }, e.prototype.addPopup = function(t) {
      var i = this, r = t.modal, o = t.eChild, s = t.closeOnEsc, a = t.closedCallback, l = t.click, u = t.alwaysOnTop, c = t.afterGuiAttached, h = t.positionCallback, d = t.anchorToElement, f = t.ariaLabel, p = this.gridOptionsWrapper.getDocument(), g = new ko(function(O) {
        return O(function() {
        });
      });
      if (!p)
        return console.warn("ag-grid: could not find the document, document is empty"), { hideFunc: function() {
        }, stopAnchoringPromise: g };
      var _ = this.popupList.findIndex(function(O) {
        return O.element === o;
      });
      if (_ !== -1) {
        var m = this.popupList[_];
        return { hideFunc: m.hideFunc, stopAnchoringPromise: m.stopAnchoringPromise };
      }
      var v = this.getPopupParent();
      o.style.top == null && (o.style.top = "0px"), o.style.left == null && (o.style.left = "0px");
      var C = document.createElement("div"), y = this.environment.getTheme().theme;
      y && C.classList.add(y), C.classList.add("ag-popup"), o.classList.add(this.gridOptionsWrapper.isEnableRtl() ? "ag-rtl" : "ag-ltr", "ag-popup-child"), o.hasAttribute("role") || So(o, "dialog"), Ud(o, f), this.focusService.isKeyboardMode() && o.classList.add(ap.AG_KEYBOARD_FOCUS), C.appendChild(o), v.appendChild(C), u ? this.setAlwaysOnTop(C, !0) : this.bringPopupToFront(C);
      var b = !1, L = function(O) {
        if (C.contains(p.activeElement)) {
          var T = O.key;
          T === pe.ESCAPE && D({ keyboardEvent: O });
        }
      }, S = function(O) {
        return D({ mouseEvent: O });
      }, E = function(O) {
        return D({ touchEvent: O });
      }, D = function(O) {
        O === void 0 && (O = {});
        var T = O.mouseEvent, A = O.touchEvent, P = O.keyboardEvent;
        // we don't hide popup if the event was on the child, or any
        // children of this child
        i.isEventFromCurrentPopup({ mouseEvent: T, touchEvent: A }, o) || // if the event to close is actually the open event, then ignore it
        i.isEventSameChainAsOriginalEvent({ originalMouseEvent: l, mouseEvent: T, touchEvent: A }) || // this method should only be called once. the client can have different
        // paths, each one wanting to close, so this method may be called multiple times.
        b || (b = !0, v.removeChild(C), p.removeEventListener("keydown", L), p.removeEventListener("mousedown", S), p.removeEventListener("touchstart", E), p.removeEventListener("contextmenu", S), i.eventService.removeEventListener(I.EVENT_DRAG_STARTED, S), a && a(T || A || P), i.popupList = i.popupList.filter(function(G) {
          return G.element !== o;
        }), g && g.then(function(G) {
          return G && G();
        }));
      };
      return c && c({ hidePopup: D }), window.setTimeout(function() {
        s && p.addEventListener("keydown", L), r && (p.addEventListener("mousedown", S), i.eventService.addEventListener(I.EVENT_DRAG_STARTED, S), p.addEventListener("touchstart", E), p.addEventListener("contextmenu", S));
      }, 0), h && h(), d && (g = this.keepPopupPositionedRelativeTo({
        element: d,
        ePopup: o,
        hidePopup: D
      })), this.popupList.push({
        element: o,
        wrapper: C,
        hideFunc: D,
        stopAnchoringPromise: g,
        instanceId: yX++,
        isAnchored: !!d
      }), {
        hideFunc: D,
        stopAnchoringPromise: g
      };
    }, e.prototype.hasAnchoredPopup = function() {
      return this.popupList.some(function(t) {
        return t.isAnchored;
      });
    }, e.prototype.isEventFromCurrentPopup = function(t, i) {
      var r = t.mouseEvent, o = t.touchEvent, s = r || o;
      if (!s)
        return !1;
      var a = this.popupList.findIndex(function(c) {
        return c.element === i;
      });
      if (a === -1)
        return !1;
      for (var l = a; l < this.popupList.length; l++) {
        var u = this.popupList[l];
        if (Iw(u.element, s))
          return !0;
      }
      return this.isElementWithinCustomPopup(s.target);
    }, e.prototype.isElementWithinCustomPopup = function(t) {
      for (var i = this.gridOptionsWrapper.getDocument(); t && t !== i.body; ) {
        if (t.classList.contains("ag-custom-component-popup") || t.parentElement === null)
          return !0;
        t = t.parentElement;
      }
      return !1;
    }, e.prototype.isEventSameChainAsOriginalEvent = function(t) {
      var i = t.originalMouseEvent, r = t.mouseEvent, o = t.touchEvent, s = null;
      if (r ? s = r : o && (s = o.touches[0]), s && i) {
        var a = r ? r.screenX : 0, l = r ? r.screenY : 0, u = Math.abs(i.screenX - a) < 5, c = Math.abs(i.screenY - l) < 5;
        if (u && c)
          return !0;
      }
      return !1;
    }, e.prototype.getWrapper = function(t) {
      for (; !t.classList.contains("ag-popup") && t.parentElement; )
        t = t.parentElement;
      return t.classList.contains("ag-popup") ? t : null;
    }, e.prototype.setAlwaysOnTop = function(t, i) {
      var r = this.getWrapper(t);
      r && (r.classList.toggle("ag-always-on-top", !!i), i && this.bringPopupToFront(r));
    }, e.prototype.bringPopupToFront = function(t) {
      var i = this.getPopupParent(), r = Array.prototype.slice.call(i.querySelectorAll(".ag-popup")), o = r.length, s = Array.prototype.slice.call(i.querySelectorAll(".ag-popup.ag-always-on-top")), a = s.length, l = this.getWrapper(t);
      if (!(!l || o <= 1 || !i.contains(t))) {
        var u = r.indexOf(l), c = l.querySelectorAll("div"), h = [];
        if (c.forEach(function(g) {
          g.scrollTop !== 0 && h.push([g, g.scrollTop]);
        }), a) {
          var d = l.classList.contains("ag-always-on-top");
          d ? u !== o - 1 && Di(s).insertAdjacentElement("afterend", l) : u !== o - a - 1 && s[0].insertAdjacentElement("beforebegin", l);
        } else
          u !== o - 1 && Di(r).insertAdjacentElement("afterend", l);
        for (; h.length; ) {
          var f = h.pop();
          f[0].scrollTop = f[1];
        }
        var p = {
          type: "popupToFront",
          api: this.gridOptionsWrapper.getApi(),
          columnApi: this.gridOptionsWrapper.getColumnApi(),
          eWrapper: l
        };
        this.eventService.dispatchEvent(p);
      }
    }, um([
      R("environment")
    ], e.prototype, "environment", void 0), um([
      R("focusService")
    ], e.prototype, "focusService", void 0), um([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), um([
      Ee
    ], e.prototype, "postConstruct", null), e = um([
      Ke("popupService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var wX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), RM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, bX = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, AH = (
  /** @class */
  function(n) {
    wX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setBeans = function(t) {
      this.logging = t.isDebug();
    }, e.prototype.create = function(t) {
      return new zw(t, this.isLogging.bind(this));
    }, e.prototype.isLogging = function() {
      return this.logging;
    }, RM([
      bX(0, wo("gridOptionsWrapper"))
    ], e.prototype, "setBeans", null), e = RM([
      Ke("loggerFactory")
    ], e), e;
  }(we)
), zw = (
  /** @class */
  function() {
    function n(e, t) {
      this.name = e, this.isLoggingFunc = t;
    }
    return n.prototype.isLogging = function() {
      return this.isLoggingFunc();
    }, n.prototype.log = function(e) {
      this.isLoggingFunc() && console.log("AG Grid." + this.name + ": " + e);
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var SX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), cm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, MH = (
  /** @class */
  function(n) {
    SX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        t.centerRowContainerCon = i.centerRowContainerCtrl;
      });
    }, e.prototype.getPreferredWidthForColumn = function(t, i) {
      var r = this.getHeaderCellForColumn(t);
      if (!r)
        return -1;
      var o = this.rowRenderer.getAllCellsForColumn(t);
      return i || o.push(r), this.addElementsToContainerAndGetWidth(o);
    }, e.prototype.getPreferredWidthForColumnGroup = function(t) {
      var i = this.getHeaderCellForColumn(t);
      return i ? this.addElementsToContainerAndGetWidth([i]) : -1;
    }, e.prototype.addElementsToContainerAndGetWidth = function(t) {
      var i = this, r = document.createElement("span");
      r.style.position = "fixed";
      var o = this.centerRowContainerCon.getContainerElement();
      o.appendChild(r), t.forEach(function(l) {
        return i.cloneItemIntoDummy(l, r);
      });
      var s = r.offsetWidth;
      o.removeChild(r);
      var a = this.gridOptionsWrapper.getAutoSizePadding();
      return s + a;
    }, e.prototype.getHeaderCellForColumn = function(t) {
      var i = null;
      return this.ctrlsService.getHeaderRowContainerCtrls().forEach(function(r) {
        var o = r.getHtmlElementForColumnHeader(t);
        o != null && (i = o);
      }), i;
    }, e.prototype.cloneItemIntoDummy = function(t, i) {
      var r = t.cloneNode(!0);
      r.style.width = "", r.style.position = "static", r.style.left = "";
      var o = document.createElement("div"), s = o.classList, a = ["ag-header-cell", "ag-header-group-cell"].some(function(d) {
        return r.classList.contains(d);
      });
      a ? (s.add("ag-header", "ag-header-row"), o.style.position = "static") : s.add("ag-row");
      for (var l = t.parentElement; l; ) {
        var u = ["ag-header-row", "ag-row"].some(function(d) {
          return l.classList.contains(d);
        });
        if (u) {
          for (var c = 0; c < l.classList.length; c++) {
            var h = l.classList[c];
            h != "ag-row-position-absolute" && s.add(h);
          }
          break;
        }
        l = l.parentElement;
      }
      o.appendChild(r), i.appendChild(o);
    }, cm([
      R("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), cm([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), cm([
      R("rowCssClassCalculator")
    ], e.prototype, "rowCssClassCalculator", void 0), cm([
      Ee
    ], e.prototype, "postConstruct", null), e = cm([
      Ke("autoWidthCalculator")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var EX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), mL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, FH = (
  /** @class */
  function(n) {
    EX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.addResizeBar = function(t) {
      var i = this, r = {
        dragStartPixels: t.dragStartPixels || 0,
        eElement: t.eResizeBar,
        onDragStart: this.onDragStart.bind(this, t),
        onDragStop: this.onDragStop.bind(this, t),
        onDragging: this.onDragging.bind(this, t)
      };
      this.dragService.addDragSource(r, !0);
      var o = function() {
        return i.dragService.removeDragSource(r);
      };
      return o;
    }, e.prototype.onDragStart = function(t, i) {
      this.dragStartX = i.clientX, this.setResizeIcons();
      var r = i instanceof MouseEvent && i.shiftKey === !0;
      t.onResizeStart(r);
    }, e.prototype.setResizeIcons = function() {
      var t = this.ctrlsService.getGridCtrl();
      t.setResizeCursor(!0), t.disableUserSelect(!0);
    }, e.prototype.onDragStop = function(t, i) {
      t.onResizeEnd(this.resizeAmount), this.resetIcons();
    }, e.prototype.resetIcons = function() {
      var t = this.ctrlsService.getGridCtrl();
      t.setResizeCursor(!1), t.disableUserSelect(!1);
    }, e.prototype.onDragging = function(t, i) {
      this.resizeAmount = i.clientX - this.dragStartX, t.onResizing(this.resizeAmount);
    }, mL([
      R("dragService")
    ], e.prototype, "dragService", void 0), mL([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), e = mL([
      Ke("horizontalResizeService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var LX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), mc = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, kH = (
  /** @class */
  function(n) {
    LX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      this.ctrlsService.registerGridCtrl(this);
    }, e.prototype.setComp = function(t, i, r) {
      var o = this;
      this.view = t, this.eGridHostDiv = i, this.eGui = r, this.mouseEventService.stampTopLevelGridCompWithGridInstance(i), this.createManagedBean(new Ex(this.view)), this.addRtlSupport(), this.addManagedListener(this, I.EVENT_KEYBOARD_FOCUS, function() {
        o.view.addOrRemoveKeyboardFocusClass(!0);
      }), this.addManagedListener(this, I.EVENT_MOUSE_FOCUS, function() {
        o.view.addOrRemoveKeyboardFocusClass(!1);
      });
      var s = this.resizeObserverService.observeResize(this.eGridHostDiv, this.onGridSizeChanged.bind(this));
      this.addDestroyFunc(function() {
        return s();
      });
    }, e.prototype.showDropZones = function() {
      return pt.isRegistered(ct.RowGroupingModule);
    }, e.prototype.showSideBar = function() {
      return pt.isRegistered(ct.SideBarModule);
    }, e.prototype.showStatusBar = function() {
      return pt.isRegistered(ct.StatusBarModule);
    }, e.prototype.showWatermark = function() {
      return pt.isRegistered(ct.EnterpriseCoreModule);
    }, e.prototype.onGridSizeChanged = function() {
      var t = {
        type: I.EVENT_GRID_SIZE_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi,
        clientWidth: this.eGridHostDiv.clientWidth,
        clientHeight: this.eGridHostDiv.clientHeight
      };
      this.eventService.dispatchEvent(t);
    }, e.prototype.addRtlSupport = function() {
      var t = this.gridOptionsWrapper.isEnableRtl() ? "ag-rtl" : "ag-ltr";
      this.view.setRtlClass(t);
    }, e.prototype.destroyGridUi = function() {
      this.view.destroyGridUi();
    }, e.prototype.getGui = function() {
      return this.eGui;
    }, e.prototype.setResizeCursor = function(t) {
      this.view.setCursor(t ? "ew-resize" : null);
    }, e.prototype.disableUserSelect = function(t) {
      this.view.setUserSelect(t ? "none" : null);
    }, e.prototype.focusNextInnerContainer = function(t) {
      var i = this.gridOptionsWrapper.getDocument(), r = this.view.getFocusableContainers(), o = r.findIndex(function(a) {
        return a.contains(i.activeElement);
      }), s = o + (t ? -1 : 1);
      return s <= 0 || s >= r.length ? !1 : this.focusService.focusInto(r[s]);
    }, e.prototype.focusInnerElement = function(t) {
      var i = this.view.getFocusableContainers();
      if (t) {
        if (i.length > 1)
          return this.focusService.focusInto(Di(i), !0);
        var r = Di(this.columnModel.getAllDisplayedColumns());
        if (this.focusService.focusGridView(r, !0))
          return !0;
      }
      return this.focusService.focusFirstHeader();
    }, e.prototype.forceFocusOutOfContainer = function(t) {
      t === void 0 && (t = !1), this.view.forceFocusOutOfContainer(t);
    }, mc([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), mc([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), mc([
      R("focusService")
    ], e.prototype, "focusService", void 0), mc([
      R("resizeObserverService")
    ], e.prototype, "resizeObserverService", void 0), mc([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), mc([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), mc([
      R("mouseEventService")
    ], e.prototype, "mouseEventService", void 0), mc([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var DX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), TM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, WH = (
  /** @class */
  function(n) {
    DX(e, n);
    function e(t) {
      var i = n.call(this) || this;
      i.skipTabGuardFocus = !1;
      var r = t.comp, o = t.eTopGuard, s = t.eBottomGuard, a = t.focusInnerElement, l = t.onFocusIn, u = t.onFocusOut, c = t.shouldStopEventPropagation, h = t.onTabKeyDown, d = t.handleKeyDown, f = t.eFocusableElement;
      return i.comp = r, i.eTopGuard = o, i.eBottomGuard = s, i.providedFocusInnerElement = a, i.eFocusableElement = f, i.providedFocusIn = l, i.providedFocusOut = u, i.providedShouldStopEventPropagation = c, i.providedOnTabKeyDown = h, i.providedHandleKeyDown = d, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.createManagedBean(new Qu(this.eFocusableElement, {
        shouldStopEventPropagation: function() {
          return t.shouldStopEventPropagation();
        },
        onTabKeyDown: function(i) {
          return t.onTabKeyDown(i);
        },
        handleKeyDown: function(i) {
          return t.handleKeyDown(i);
        },
        onFocusIn: function(i) {
          return t.onFocusIn(i);
        },
        onFocusOut: function(i) {
          return t.onFocusOut(i);
        }
      })), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach(function(i) {
        return t.addManagedListener(i, "focus", t.onFocus.bind(t));
      });
    }, e.prototype.handleKeyDown = function(t) {
      this.providedHandleKeyDown && this.providedHandleKeyDown(t);
    }, e.prototype.tabGuardsAreActive = function() {
      return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
    }, e.prototype.shouldStopEventPropagation = function() {
      return this.providedShouldStopEventPropagation ? this.providedShouldStopEventPropagation() : !1;
    }, e.prototype.activateTabGuards = function() {
      this.comp.setTabIndex(this.getGridTabIndex());
    }, e.prototype.deactivateTabGuards = function() {
      this.comp.setTabIndex();
    }, e.prototype.onFocus = function(t) {
      if (this.skipTabGuardFocus) {
        this.skipTabGuardFocus = !1;
        return;
      }
      var i = t.target === this.eBottomGuard;
      this.providedFocusInnerElement ? this.providedFocusInnerElement(i) : this.focusInnerElement(i);
    }, e.prototype.onFocusIn = function(t) {
      this.providedFocusIn && this.providedFocusIn(t) || this.deactivateTabGuards();
    }, e.prototype.onFocusOut = function(t) {
      this.providedFocusOut && this.providedFocusOut(t) || this.eFocusableElement.contains(t.relatedTarget) || this.activateTabGuards();
    }, e.prototype.onTabKeyDown = function(t) {
      var i = this;
      if (this.providedOnTabKeyDown) {
        this.providedOnTabKeyDown(t);
        return;
      }
      if (!t.defaultPrevented) {
        var r = this.tabGuardsAreActive();
        r && this.deactivateTabGuards();
        var o = this.getNextFocusableElement(t.shiftKey);
        r && setTimeout(function() {
          return i.activateTabGuards();
        }, 0), o && (o.focus(), t.preventDefault());
      }
    }, e.prototype.getGridTabIndex = function() {
      return this.gridOptionsWrapper.getGridTabIndex();
    }, e.prototype.focusInnerElement = function(t) {
      t === void 0 && (t = !1);
      var i = this.focusService.findFocusableElements(this.eFocusableElement);
      this.tabGuardsAreActive() && (i.splice(0, 1), i.splice(i.length - 1, 1)), i.length && i[t ? i.length - 1 : 0].focus();
    }, e.prototype.getNextFocusableElement = function(t) {
      return this.focusService.findNextFocusableElement(this.eFocusableElement, !1, t);
    }, e.prototype.forceFocusOutOfContainer = function(t) {
      t === void 0 && (t = !1);
      var i = t ? this.eTopGuard : this.eBottomGuard;
      this.activateTabGuards(), this.skipTabGuardFocus = !0, i.focus();
    }, TM([
      R("focusService")
    ], e.prototype, "focusService", void 0), TM([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var RX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), TX = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, OX = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(TX(arguments[e]));
  return n;
}, T_ = (
  /** @class */
  function(n) {
    RX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.initialiseTabGuard = function(t) {
      this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.getFocusableElement();
      var i = [this.eTopGuard, this.eBottomGuard], r = {
        setTabIndex: function(o) {
          i.forEach(function(s) {
            return o != null ? s.setAttribute("tabIndex", o) : s.removeAttribute("tabIndex");
          });
        }
      };
      this.addTabGuards(this.eTopGuard, this.eBottomGuard), this.tabGuardCtrl = this.createManagedBean(new WH({
        comp: r,
        eTopGuard: this.eTopGuard,
        eBottomGuard: this.eBottomGuard,
        eFocusableElement: this.eFocusableElement,
        onFocusIn: t.onFocusIn,
        onFocusOut: t.onFocusOut,
        focusInnerElement: t.focusInnerElement,
        handleKeyDown: t.handleKeyDown,
        onTabKeyDown: t.onTabKeyDown,
        shouldStopEventPropagation: t.shouldStopEventPropagation
      }));
    }, e.prototype.createTabGuard = function(t) {
      var i = document.createElement("div");
      return i.classList.add("ag-tab-guard", "ag-tab-guard-" + t), So(i, "presentation"), i;
    }, e.prototype.addTabGuards = function(t, i) {
      this.eFocusableElement.insertAdjacentElement("afterbegin", t), this.eFocusableElement.insertAdjacentElement("beforeend", i);
    }, e.prototype.removeAllChildrenExceptTabGuards = function() {
      var t = [this.eTopGuard, this.eBottomGuard];
      ys(this.getFocusableElement()), this.addTabGuards.apply(this, OX(t));
    }, e.prototype.forceFocusOutOfContainer = function(t) {
      t === void 0 && (t = !1), this.tabGuardCtrl.forceFocusOutOfContainer(t);
    }, e.prototype.appendChild = function(t, i) {
      D_(t) || (t = t.getGui());
      var r = this.eBottomGuard;
      r ? r.insertAdjacentElement("beforebegin", t) : n.prototype.appendChild.call(this, t, i);
    }, e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var xX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), hm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, VH = (
  /** @class */
  function(n) {
    xX(e, n);
    function e(t) {
      var i = n.call(this, void 0) || this;
      return i.eGridDiv = t, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.logger = this.loggerFactory.create("GridComp");
      var i = {
        destroyGridUi: function() {
          return t.destroyBean(t);
        },
        setRtlClass: function(o) {
          return t.addCssClass(o);
        },
        addOrRemoveKeyboardFocusClass: function(o) {
          return t.addOrRemoveCssClass(ap.AG_KEYBOARD_FOCUS, o);
        },
        forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
        updateLayoutClasses: this.updateLayoutClasses.bind(this),
        getFocusableContainers: this.getFocusableContainers.bind(this),
        setUserSelect: function(o) {
          t.getGui().style.userSelect = o ?? "", t.getGui().style.webkitUserSelect = o ?? "";
        },
        setCursor: function(o) {
          t.getGui().style.cursor = o ?? "";
        }
      };
      this.ctrl = this.createManagedBean(new kH());
      var r = this.createTemplate();
      this.setTemplate(r), this.ctrl.setComp(i, this.eGridDiv, this.getGui()), this.insertGridIntoDom(), this.initialiseTabGuard({
        // we want to override the default behaviour to do nothing for onTabKeyDown
        onTabKeyDown: function() {
        },
        focusInnerElement: function(o) {
          return t.ctrl.focusInnerElement(o);
        }
      });
    }, e.prototype.insertGridIntoDom = function() {
      var t = this, i = this.getGui();
      this.eGridDiv.appendChild(i), this.addDestroyFunc(function() {
        t.eGridDiv.removeChild(i), t.logger.log("Grid removed from DOM");
      });
    }, e.prototype.updateLayoutClasses = function(t, i) {
      var r = this.eRootWrapperBody.classList;
      r.toggle(Fn.AUTO_HEIGHT, i.autoHeight), r.toggle(Fn.NORMAL, i.normal), r.toggle(Fn.PRINT, i.print), this.addOrRemoveCssClass(Fn.AUTO_HEIGHT, i.autoHeight), this.addOrRemoveCssClass(Fn.NORMAL, i.normal), this.addOrRemoveCssClass(Fn.PRINT, i.print);
    }, e.prototype.createTemplate = function() {
      var t = this.ctrl.showDropZones() ? "<ag-grid-header-drop-zones></ag-grid-header-drop-zones>" : "", i = this.ctrl.showSideBar() ? '<ag-side-bar ref="sideBar"></ag-side-bar>' : "", r = this.ctrl.showStatusBar() ? '<ag-status-bar ref="statusBar"></ag-status-bar>' : "", o = this.ctrl.showWatermark() ? "<ag-watermark></ag-watermark>" : "", s = (
        /* html */
        `<div class="ag-root-wrapper">
                ` + t + `
                <div class="ag-root-wrapper-body" ref="rootWrapperBody">
                    <ag-grid-body ref="gridBody"></ag-grid-body>
                    ` + i + `
                </div>
                ` + r + `
                <ag-pagination></ag-pagination>
                ` + o + `
            </div>`
      );
      return s;
    }, e.prototype.getFocusableElement = function() {
      return this.eRootWrapperBody;
    }, e.prototype.getFocusableContainers = function() {
      var t = [
        this.gridBodyComp.getGui()
      ];
      return this.sideBarComp && t.push(this.sideBarComp.getGui()), t.filter(function(i) {
        return hg(i);
      });
    }, hm([
      R("loggerFactory")
    ], e.prototype, "loggerFactory", void 0), hm([
      fe("gridBody")
    ], e.prototype, "gridBodyComp", void 0), hm([
      fe("sideBar")
    ], e.prototype, "sideBarComp", void 0), hm([
      fe("rootWrapperBody")
    ], e.prototype, "eRootWrapperBody", void 0), hm([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(T_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var NX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), vf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, BH = (
  /** @class */
  function(n) {
    NX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.dragEndFunctions = [], t.dragSources = [], t;
    }
    return e.prototype.init = function() {
      this.logger = this.loggerFactory.create("DragService");
    }, e.prototype.removeAllListeners = function() {
      this.dragSources.forEach(this.removeListener.bind(this)), this.dragSources.length = 0;
    }, e.prototype.removeListener = function(t) {
      var i = t.dragSource.eElement, r = t.mouseDownListener;
      if (i.removeEventListener("mousedown", r), t.touchEnabled) {
        var o = t.touchStartListener;
        i.removeEventListener("touchstart", o, { passive: !0 });
      }
    }, e.prototype.removeDragSource = function(t) {
      var i = this.dragSources.find(function(r) {
        return r.dragSource === t;
      });
      i && (this.removeListener(i), qr(this.dragSources, i));
    }, e.prototype.isDragging = function() {
      return this.dragging;
    }, e.prototype.addDragSource = function(t, i) {
      var r = this;
      i === void 0 && (i = !1);
      var o = this.onMouseDown.bind(this, t);
      t.eElement.addEventListener("mousedown", o);
      var s = null, a = this.gridOptionsWrapper.isSuppressTouch();
      i && !a && (s = function(l) {
        l.cancelable && l.preventDefault(), r.onTouchStart(t, l);
      }, t.eElement.addEventListener("touchstart", s, { passive: !0 })), this.dragSources.push({
        dragSource: t,
        mouseDownListener: o,
        touchStartListener: s,
        touchEnabled: i
      });
    }, e.prototype.onTouchStart = function(t, i) {
      var r = this;
      this.currentDragParams = t, this.dragging = !1;
      var o = i.touches[0];
      this.touchLastTime = o, this.touchStart = o;
      var s = function(h) {
        return r.onTouchMove(h, t.eElement);
      }, a = function(h) {
        return r.onTouchUp(h, t.eElement);
      }, l = function(h) {
        h.cancelable && h.preventDefault();
      }, u = t.eElement, c = [
        // Prevents the page document from moving while we are dragging items around.
        // preventDefault needs to be called in the touchmove listener and never inside the
        // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
        { target: document, type: "touchmove", listener: l, options: { passive: !1 } },
        { target: u, type: "touchmove", listener: s, options: { passive: !0 } },
        { target: u, type: "touchend", listener: a, options: { passive: !0 } },
        { target: u, type: "touchcancel", listener: a, options: { passive: !0 } }
      ];
      this.addTemporaryEvents(c), t.dragStartPixels === 0 && this.onCommonMove(o, this.touchStart, t.eElement);
    }, e.prototype.onMouseDown = function(t, i) {
      var r = this, o = i;
      if (!(t.skipMouseEvent && t.skipMouseEvent(i)) && !o._alreadyProcessedByDragService && (o._alreadyProcessedByDragService = !0, i.button === 0)) {
        this.currentDragParams = t, this.dragging = !1, this.mouseStartEvent = i;
        var s = this.gridOptionsWrapper.getDocument(), a = function(d) {
          return r.onMouseMove(d, t.eElement);
        }, l = function(d) {
          return r.onMouseUp(d, t.eElement);
        }, u = function(d) {
          return d.preventDefault();
        }, c = s, h = [
          { target: c, type: "mousemove", listener: a },
          { target: c, type: "mouseup", listener: l },
          { target: c, type: "contextmenu", listener: u }
        ];
        this.addTemporaryEvents(h), t.dragStartPixels === 0 && this.onMouseMove(i, t.eElement);
      }
    }, e.prototype.addTemporaryEvents = function(t) {
      t.forEach(function(i) {
        var r = i.target, o = i.type, s = i.listener, a = i.options;
        r.addEventListener(o, s, a);
      }), this.dragEndFunctions.push(function() {
        t.forEach(function(i) {
          var r = i.target, o = i.type, s = i.listener, a = i.options;
          r.removeEventListener(o, s, a);
        });
      });
    }, e.prototype.isEventNearStartEvent = function(t, i) {
      var r = this.currentDragParams.dragStartPixels, o = de(r) ? r : 4;
      return ux(t, i, o);
    }, e.prototype.getFirstActiveTouch = function(t) {
      for (var i = 0; i < t.length; i++)
        if (t[i].identifier === this.touchStart.identifier)
          return t[i];
      return null;
    }, e.prototype.onCommonMove = function(t, i, r) {
      if (!this.dragging) {
        if (!this.dragging && this.isEventNearStartEvent(t, i))
          return;
        this.dragging = !0;
        var o = {
          type: I.EVENT_DRAG_STARTED,
          api: this.gridApi,
          columnApi: this.columnApi,
          target: r
        };
        this.eventService.dispatchEvent(o), this.currentDragParams.onDragStart(i), this.currentDragParams.onDragging(i);
      }
      this.currentDragParams.onDragging(t);
    }, e.prototype.onTouchMove = function(t, i) {
      var r = this.getFirstActiveTouch(t.touches);
      r && this.onCommonMove(r, this.touchStart, i);
    }, e.prototype.onMouseMove = function(t, i) {
      t.type === "mousemove" && t.cancelable && t.preventDefault(), this.onCommonMove(t, this.mouseStartEvent, i);
    }, e.prototype.onTouchUp = function(t, i) {
      var r = this.getFirstActiveTouch(t.changedTouches);
      r || (r = this.touchLastTime), this.onUpCommon(r, i);
    }, e.prototype.onMouseUp = function(t, i) {
      this.onUpCommon(t, i);
    }, e.prototype.onUpCommon = function(t, i) {
      if (this.dragging) {
        this.dragging = !1, this.currentDragParams.onDragStop(t);
        var r = {
          type: I.EVENT_DRAG_STOPPED,
          api: this.gridApi,
          columnApi: this.columnApi,
          target: i
        };
        this.eventService.dispatchEvent(r);
      }
      this.mouseStartEvent = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null, this.dragEndFunctions.forEach(function(o) {
        return o();
      }), this.dragEndFunctions.length = 0;
    }, vf([
      R("loggerFactory")
    ], e.prototype, "loggerFactory", void 0), vf([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), vf([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), vf([
      Ee
    ], e.prototype, "init", null), vf([
      Lo
    ], e.prototype, "removeAllListeners", null), e = vf([
      Ke("dragService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var IX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), VC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, HH = (
  /** @class */
  function(n) {
    IX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    t = e, e.prototype.progressSort = function(i, r, o) {
      o === void 0 && (o = "api");
      var s = this.getNextSortDirection(i);
      this.setSortForColumn(i, s, r, o);
    }, e.prototype.setSortForColumn = function(i, r, o, s) {
      s === void 0 && (s = "api"), r !== q.SORT_ASC && r !== q.SORT_DESC && (r = null), i.setSort(r, s);
      var a = o && !this.gridOptionsWrapper.isSuppressMultiSort();
      a || this.clearSortBarThisColumn(i, s), this.updateSortIndex(i), this.dispatchSortChangedEvents();
    }, e.prototype.updateSortIndex = function(i) {
      var r = this.getColumnsWithSortingOrdered(), o = 0;
      r.forEach(function(a) {
        a !== i && (a.setSortIndex(o), o++);
      }), i.getSort() && i.setSortIndex(o);
      var s = this.columnModel.getPrimaryAndSecondaryAndAutoColumns();
      s.filter(function(a) {
        return a.getSort() == null;
      }).forEach(function(a) {
        return a.setSortIndex();
      });
    }, e.prototype.onSortChanged = function() {
      this.dispatchSortChangedEvents();
    }, e.prototype.isSortActive = function() {
      var i = this.columnModel.getPrimaryAndSecondaryAndAutoColumns(), r = i.filter(function(o) {
        return !!o.getSort();
      });
      return r && r.length > 0;
    }, e.prototype.dispatchSortChangedEvents = function() {
      var i = {
        type: I.EVENT_SORT_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.clearSortBarThisColumn = function(i, r) {
      this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach(function(o) {
        o !== i && o.setSort(void 0, r);
      });
    }, e.prototype.getNextSortDirection = function(i) {
      var r;
      if (i.getColDef().sortingOrder ? r = i.getColDef().sortingOrder : this.gridOptionsWrapper.getSortingOrder() ? r = this.gridOptionsWrapper.getSortingOrder() : r = t.DEFAULT_SORTING_ORDER, !Array.isArray(r) || r.length <= 0)
        return console.warn("AG Grid: sortingOrder must be an array with at least one element, currently it's " + r), null;
      var o = r.indexOf(i.getSort()), s = o < 0, a = o == r.length - 1, l;
      return s || a ? l = r[0] : l = r[o + 1], t.DEFAULT_SORTING_ORDER.indexOf(l) < 0 ? (console.warn("AG Grid: invalid sort type " + l), null) : l;
    }, e.prototype.getColumnsWithSortingOrdered = function() {
      var i = this.columnModel.getPrimaryAndSecondaryAndAutoColumns(), r = i.filter(function(s) {
        return !!s.getSort();
      }), o = {};
      return i.forEach(function(s, a) {
        return o[s.getId()] = a;
      }), r.sort(function(s, a) {
        var l = s.getSortIndex(), u = a.getSortIndex();
        if (l != null && u != null)
          return l - u;
        if (l == null && u == null) {
          var c = o[s.getId()], h = o[a.getId()];
          return c > h ? 1 : -1;
        } else
          return u == null ? -1 : 1;
      }), r;
    }, e.prototype.getSortModel = function() {
      return this.getColumnsWithSortingOrdered().map(function(i) {
        return {
          sort: i.getSort(),
          colId: i.getId()
        };
      });
    }, e.prototype.getSortOptions = function() {
      return this.getColumnsWithSortingOrdered().map(function(i) {
        return {
          sort: i.getSort(),
          column: i
        };
      });
    };
    var t;
    return e.DEFAULT_SORTING_ORDER = [q.SORT_ASC, q.SORT_DESC, null], VC([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), VC([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), VC([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), e = t = VC([
      Ke("sortController")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var PX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), OM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, GH = (
  /** @class */
  function(n) {
    PX(e, n);
    function e() {
      var i = n !== null && n.apply(this, arguments) || this;
      return i.gridInstanceId = t.gridInstanceSequence.next(), i;
    }
    t = e, e.prototype.stampTopLevelGridCompWithGridInstance = function(i) {
      i[t.GRID_DOM_KEY] = this.gridInstanceId;
    }, e.prototype.getRenderedCellForEvent = function(i) {
      return Nw(this.gridOptionsWrapper, i, jc.DOM_DATA_KEY_CELL_CTRL);
    }, e.prototype.isEventFromThisGrid = function(i) {
      var r = this.isElementInThisGrid(i.target);
      return r;
    }, e.prototype.isElementInThisGrid = function(i) {
      for (var r = i; r; ) {
        var o = r[t.GRID_DOM_KEY];
        if (de(o)) {
          var s = o === this.gridInstanceId;
          return s;
        }
        r = r.parentElement;
      }
      return !1;
    }, e.prototype.getCellPositionForEvent = function(i) {
      var r = this.getRenderedCellForEvent(i);
      return r ? r.getCellPosition() : null;
    }, e.prototype.getNormalisedPosition = function(i) {
      var r = this.gridOptionsWrapper.getDomLayout() === q.DOM_LAYOUT_NORMAL, o = i, s, a;
      if (o.clientX != null || o.clientY != null ? (s = o.clientX, a = o.clientY) : (s = o.x, a = o.y), r) {
        var l = this.ctrlsService.getGridBodyCtrl(), u = l.getScrollFeature().getVScrollPosition(), c = l.getScrollFeature().getHScrollPosition();
        s += c.left, a += u.top;
      }
      return { x: s, y: a };
    };
    var t;
    return e.gridInstanceSequence = new ES(), e.GRID_DOM_KEY = "__ag_grid_instance", OM([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), e = t = OM([
      Ke("mouseEventService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var AX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), dm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, UH = (
  /** @class */
  function(n) {
    AX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getNextCellToFocus = function(t, i) {
      for (var r = i, o = !1; !o; ) {
        switch (t) {
          case pe.UP:
            r = this.getCellAbove(r);
            break;
          case pe.DOWN:
            r = this.getCellBelow(r);
            break;
          case pe.RIGHT:
            this.gridOptionsWrapper.isEnableRtl() ? r = this.getCellToLeft(r) : r = this.getCellToRight(r);
            break;
          case pe.LEFT:
            this.gridOptionsWrapper.isEnableRtl() ? r = this.getCellToRight(r) : r = this.getCellToLeft(r);
            break;
          default:
            r = null, console.warn("AG Grid: unknown key for navigation " + t);
            break;
        }
        r ? o = this.isCellGoodToFocusOn(r) : o = !0;
      }
      return r;
    }, e.prototype.isCellGoodToFocusOn = function(t) {
      var i = t.column, r;
      switch (t.rowPinned) {
        case q.PINNED_TOP:
          r = this.pinnedRowModel.getPinnedTopRow(t.rowIndex);
          break;
        case q.PINNED_BOTTOM:
          r = this.pinnedRowModel.getPinnedBottomRow(t.rowIndex);
          break;
        default:
          r = this.rowModel.getRow(t.rowIndex);
          break;
      }
      if (!r)
        return !1;
      var o = i.isSuppressNavigable(r);
      return !o;
    }, e.prototype.getCellToLeft = function(t) {
      if (!t)
        return null;
      var i = this.columnModel.getDisplayedColBefore(t.column);
      return i ? {
        rowIndex: t.rowIndex,
        column: i,
        rowPinned: t.rowPinned
      } : null;
    }, e.prototype.getCellToRight = function(t) {
      if (!t)
        return null;
      var i = this.columnModel.getDisplayedColAfter(t.column);
      return i ? {
        rowIndex: t.rowIndex,
        column: i,
        rowPinned: t.rowPinned
      } : null;
    }, e.prototype.getRowBelow = function(t) {
      var i = t.rowIndex, r = t.rowPinned;
      if (this.isLastRowInContainer(t))
        switch (r) {
          case q.PINNED_BOTTOM:
            return null;
          case q.PINNED_TOP:
            return this.rowModel.isRowsToRender() ? { rowIndex: this.paginationProxy.getPageFirstRow(), rowPinned: null } : this.pinnedRowModel.isRowsToRender(q.PINNED_BOTTOM) ? { rowIndex: 0, rowPinned: q.PINNED_BOTTOM } : null;
          default:
            return this.pinnedRowModel.isRowsToRender(q.PINNED_BOTTOM) ? { rowIndex: 0, rowPinned: q.PINNED_BOTTOM } : null;
        }
      return { rowIndex: i + 1, rowPinned: r };
    }, e.prototype.getCellBelow = function(t) {
      if (!t)
        return null;
      var i = this.getRowBelow(t);
      return i ? {
        rowIndex: i.rowIndex,
        column: t.column,
        rowPinned: i.rowPinned
      } : null;
    }, e.prototype.isLastRowInContainer = function(t) {
      var i = t.rowPinned, r = t.rowIndex;
      if (i === q.PINNED_TOP) {
        var o = this.pinnedRowModel.getPinnedTopRowData().length - 1;
        return o <= r;
      }
      if (i === q.PINNED_BOTTOM) {
        var s = this.pinnedRowModel.getPinnedBottomRowData().length - 1;
        return s <= r;
      }
      var a = this.paginationProxy.getPageLastRow();
      return a <= r;
    }, e.prototype.getRowAbove = function(t) {
      var i = t.rowIndex, r = t.rowPinned, o = r ? i === 0 : i === this.paginationProxy.getPageFirstRow();
      return o ? r === q.PINNED_TOP ? null : r ? this.rowModel.isRowsToRender() ? this.getLastBodyCell() : this.pinnedRowModel.isRowsToRender(q.PINNED_TOP) ? this.getLastFloatingTopRow() : null : this.pinnedRowModel.isRowsToRender(q.PINNED_TOP) ? this.getLastFloatingTopRow() : null : { rowIndex: i - 1, rowPinned: r };
    }, e.prototype.getCellAbove = function(t) {
      if (!t)
        return null;
      var i = this.getRowAbove({ rowIndex: t.rowIndex, rowPinned: t.rowPinned });
      return i ? {
        rowIndex: i.rowIndex,
        column: t.column,
        rowPinned: i.rowPinned
      } : null;
    }, e.prototype.getLastBodyCell = function() {
      var t = this.paginationProxy.getPageLastRow();
      return { rowIndex: t, rowPinned: null };
    }, e.prototype.getLastFloatingTopRow = function() {
      var t = this.pinnedRowModel.getPinnedTopRowData().length - 1;
      return { rowIndex: t, rowPinned: q.PINNED_TOP };
    }, e.prototype.getNextTabbedCell = function(t, i) {
      return i ? this.getNextTabbedCellBackwards(t) : this.getNextTabbedCellForwards(t);
    }, e.prototype.getNextTabbedCellForwards = function(t) {
      var i = this.columnModel.getAllDisplayedColumns(), r = t.rowIndex, o = t.rowPinned, s = this.columnModel.getDisplayedColAfter(t.column);
      if (!s) {
        s = i[0];
        var a = this.getRowBelow(t);
        if (Je(a) || !a.rowPinned && !this.paginationProxy.isRowInPage(a))
          return null;
        r = a ? a.rowIndex : null, o = a ? a.rowPinned : null;
      }
      return { rowIndex: r, column: s, rowPinned: o };
    }, e.prototype.getNextTabbedCellBackwards = function(t) {
      var i = this.columnModel.getAllDisplayedColumns(), r = t.rowIndex, o = t.rowPinned, s = this.columnModel.getDisplayedColBefore(t.column);
      if (!s) {
        s = Di(i);
        var a = this.getRowAbove({ rowIndex: t.rowIndex, rowPinned: t.rowPinned });
        if (Je(a) || !a.rowPinned && !this.paginationProxy.isRowInPage(a))
          return null;
        r = a ? a.rowIndex : null, o = a ? a.rowPinned : null;
      }
      return { rowIndex: r, column: s, rowPinned: o };
    }, dm([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), dm([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), dm([
      R("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), dm([
      R("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), e = dm([
      Ke("cellNavigationService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var MX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), xM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, zH = (
  /** @class */
  function(n) {
    MX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.formatValue = function(t, i, r, o, s, a) {
      a === void 0 && (a = !0);
      var l = null, u, c = t.getColDef();
      if (s ? u = s : a && (u = i && i.rowPinned && c.pinnedRowValueFormatter ? c.pinnedRowValueFormatter : c.valueFormatter), u) {
        var h = {
          value: o,
          node: i,
          data: i ? i.data : null,
          colDef: c,
          column: t,
          api: this.gridOptionsWrapper.getApi(),
          columnApi: this.gridOptionsWrapper.getColumnApi(),
          context: this.gridOptionsWrapper.getContext()
        };
        h.$scope = r, l = this.expressionService.evaluate(u, h);
      } else if (c.refData)
        return c.refData[o] || "";
      return l == null && Array.isArray(o) && (l = o.join(", ")), l;
    }, xM([
      R("expressionService")
    ], e.prototype, "expressionService", void 0), e = xM([
      Ke("valueFormatterService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var FX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), jH = (
  /** @class */
  function(n) {
    FX(e, n);
    function e(t) {
      return n.call(this, t, "ag-radio-button", "radio") || this;
    }
    return e.prototype.isSelected = function() {
      return this.eInput.checked;
    }, e.prototype.toggle = function() {
      this.eInput.disabled || this.isSelected() || this.setValue(!0);
    }, e.prototype.addInputListeners = function() {
      n.prototype.addInputListeners.call(this), this.addManagedListener(this.eventService, I.EVENT_CHECKBOX_CHANGED, this.onChange.bind(this));
    }, e.prototype.onChange = function(t) {
      t.selected && t.name && this.eInput.name && this.eInput.name === t.name && t.id && this.eInput.id !== t.id && this.setValue(!1, !0);
    }, e;
  }(kp)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var kX = ["mouseover", "mouseout", "mouseenter", "mouseleave"], WX = ["touchstart", "touchend", "touchmove", "touchcancel"], $H = (
  /** @class */
  function() {
    function n() {
      this.isOutsideAngular = function(e) {
        return Cs(kX, e);
      };
    }
    return n.prototype.setTimeout = function(e, t) {
      window.setTimeout(e, t);
    }, n.prototype.setInterval = function(e, t) {
      return new ko(function(i) {
        i(window.setInterval(e, t));
      });
    }, n.prototype.addEventListener = function(e, t, i, r) {
      var o = Cs(WX, t);
      e.addEventListener(t, i, { capture: !!r, passive: o });
    }, n.prototype.dispatchEvent = function(e, t, i) {
      t();
    }, n.prototype.frameworkComponent = function(e) {
      return null;
    }, n.prototype.isFrameworkComponent = function(e) {
      return !1;
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var VX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), fm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, KH = (
  /** @class */
  function(n) {
    VX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));
    }, e.prototype.onDisplayedColumnsChanged = function() {
      this.update();
    }, e.prototype.onDisplayedColumnsWidthChanged = function() {
      this.update();
    }, e.prototype.update = function() {
      this.updateImpl(), setTimeout(this.updateImpl.bind(this), 500);
    }, e.prototype.updateImpl = function() {
      var t = this.ctrlsService.getCenterRowContainerCtrl();
      if (t) {
        var i = {
          horizontalScrollShowing: t.isHorizontalScrollShowing(),
          verticalScrollShowing: this.isVerticalScrollShowing()
        };
        this.setScrollsVisible(i);
      }
    }, e.prototype.setScrollsVisible = function(t) {
      var i = this.horizontalScrollShowing !== t.horizontalScrollShowing || this.verticalScrollShowing !== t.verticalScrollShowing;
      if (i) {
        this.horizontalScrollShowing = t.horizontalScrollShowing, this.verticalScrollShowing = t.verticalScrollShowing;
        var r = {
          type: I.EVENT_SCROLL_VISIBILITY_CHANGED,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(r);
      }
    }, e.prototype.isHorizontalScrollShowing = function() {
      return this.horizontalScrollShowing;
    }, e.prototype.isVerticalScrollShowing = function() {
      return this.verticalScrollShowing;
    }, fm([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), fm([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), fm([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), fm([
      Ee
    ], e.prototype, "postConstruct", null), e = fm([
      Ke("scrollVisibleService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var BX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), NM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, qH = (
  /** @class */
  function(n) {
    BX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.processAllCellClasses = function(t, i, r, o) {
      this.processClassRules(t.cellClassRules, i, r, o), this.processStaticCellClasses(t, i, r);
    }, e.prototype.processClassRules = function(t, i, r, o) {
      if (t != null) {
        for (var s = Object.keys(t), a = {}, l = {}, u = function(d) {
          var f = s[d], p = t[f], g;
          typeof p == "string" ? g = c.expressionService.evaluate(p, i) : typeof p == "function" && (g = p(i)), f.split(" ").forEach(function(_) {
            _ == null || _.trim() == "" || (g ? a[_] = !0 : l[_] = !0);
          });
        }, c = this, h = 0; h < s.length; h++)
          u(h);
        o && Object.keys(l).forEach(o), Object.keys(a).forEach(r);
      }
    }, e.prototype.getStaticCellClasses = function(t, i) {
      var r = t.cellClass;
      if (!r)
        return [];
      var o;
      if (typeof r == "function") {
        var s = r;
        o = s(i);
      } else
        o = r;
      return typeof o == "string" && (o = [o]), o || [];
    }, e.prototype.processStaticCellClasses = function(t, i, r) {
      var o = this.getStaticCellClasses(t, i);
      o.forEach(function(s) {
        r(s);
      });
    }, NM([
      R("expressionService")
    ], e.prototype, "expressionService", void 0), e = NM([
      Ke("stylingService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var HX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), vL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, GX = (
  /** @class */
  function(n) {
    HX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setMouseOver = function(t) {
      this.selectedColumns = t;
      var i = {
        type: I.EVENT_COLUMN_HOVER_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.clearMouseOver = function() {
      this.selectedColumns = null;
      var t = {
        type: I.EVENT_COLUMN_HOVER_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(t);
    }, e.prototype.isHovered = function(t) {
      return !!this.selectedColumns && this.selectedColumns.indexOf(t) >= 0;
    }, vL([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), vL([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), e = vL([
      Ke("columnHoverService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var UX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _L = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, zX = (
  /** @class */
  function(n) {
    UX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.executeNextFuncs = [], t.executeLaterFuncs = [], t.active = !1, t.animationThreadCount = 0, t;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        return t.gridBodyCtrl = i.gridBodyCtrl;
      });
    }, e.prototype.isActive = function() {
      return this.active;
    }, e.prototype.start = function() {
      this.active || this.gridOptionsWrapper.isSuppressColumnMoveAnimation() || this.gridOptionsWrapper.isEnableRtl() || (this.ensureAnimationCssClassPresent(), this.active = !0);
    }, e.prototype.finish = function() {
      this.active && (this.flush(), this.active = !1);
    }, e.prototype.executeNextVMTurn = function(t) {
      this.active ? this.executeNextFuncs.push(t) : t();
    }, e.prototype.executeLaterVMTurn = function(t) {
      this.active ? this.executeLaterFuncs.push(t) : t();
    }, e.prototype.ensureAnimationCssClassPresent = function() {
      var t = this;
      this.animationThreadCount++;
      var i = this.animationThreadCount;
      this.gridBodyCtrl.setColumnMovingCss(!0), this.executeLaterFuncs.push(function() {
        t.animationThreadCount === i && t.gridBodyCtrl.setColumnMovingCss(!1);
      });
    }, e.prototype.flush = function() {
      var t = this.executeNextFuncs;
      this.executeNextFuncs = [];
      var i = this.executeLaterFuncs;
      this.executeLaterFuncs = [], !(t.length === 0 && i.length === 0) && (window.setTimeout(function() {
        return t.forEach(function(r) {
          return r();
        });
      }, 0), window.setTimeout(function() {
        return i.forEach(function(r) {
          return r();
        });
      }, 300));
    }, _L([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), _L([
      Ee
    ], e.prototype, "postConstruct", null), e = _L([
      Ke("columnAnimationService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var jX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), CL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, $X = (
  /** @class */
  function(n) {
    jX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    t = e, e.prototype.createAutoGroupColumns = function(i) {
      var r = this, o = [], s = this.gridOptionsWrapper.isTreeData(), a = this.gridOptionsWrapper.isGroupMultiAutoColumn();
      return s && a && (console.warn("AG Grid: you cannot mix groupMultiAutoColumn with treeData, only one column can be used to display groups when doing tree data"), a = !1), a ? i.forEach(function(l, u) {
        o.push(r.createOneAutoGroupColumn(l, u));
      }) : o.push(this.createOneAutoGroupColumn()), o;
    }, e.prototype.createOneAutoGroupColumn = function(i, r) {
      var o = this.generateDefaultColDef(i), s;
      i ? s = q.GROUP_AUTO_COLUMN_ID + "-" + i.getId() : s = t.GROUP_AUTO_COLUMN_BUNDLE_ID;
      var a = this.gridOptionsWrapper.getAutoGroupColumnDef();
      if (aa(o, a), o = this.columnFactory.mergeColDefs(o), o.colId = s, !this.gridOptionsWrapper.isTreeData()) {
        var l = Je(o.field) && Je(o.valueGetter) && Je(o.filterValueGetter);
        l && (o.filter = !1);
      }
      r && r > 0 && (o.headerCheckboxSelection = !1);
      var u = new Gt(o, null, s, !0);
      return this.context.createBean(u), u;
    }, e.prototype.generateDefaultColDef = function(i) {
      var r = this.gridOptionsWrapper.getAutoGroupColumnDef(), o = this.gridOptionsWrapper.getLocaleTextFunc(), s = {
        headerName: o("group", "Group")
      }, a = r && (r.cellRenderer || r.cellRendererFramework || r.cellRendererSelector);
      if (a || (s.cellRenderer = "agGroupCellRenderer"), i) {
        var l = i.getColDef();
        Object.assign(s, {
          // cellRendererParams.groupKey: colDefToCopy.field;
          headerName: this.columnModel.getDisplayNameForColumn(i, "header"),
          headerValueGetter: l.headerValueGetter
        }), (l.cellRenderer || l.cellRendererFramework) && Object.assign(s, {
          cellRendererParams: {
            innerRenderer: l.cellRenderer,
            innerRendererFramework: l.cellRendererFramework,
            innerRendererParams: l.cellRendererParams
          }
        }), s.showRowGroup = i.getColId();
      } else
        s.showRowGroup = !0;
      return s;
    };
    var t;
    return e.GROUP_AUTO_COLUMN_BUNDLE_ID = q.GROUP_AUTO_COLUMN_ID, CL([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), CL([
      R("columnFactory")
    ], e.prototype, "columnFactory", void 0), e = t = CL([
      Ke("autoGroupColService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var KX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), pm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, YH = (
  /** @class */
  function(n) {
    KX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.currentPage = 0, t.topDisplayedRowIndex = 0, t.bottomDisplayedRowIndex = 0, t.pixelOffset = 0, t.masterRowCount = 0, t;
    }
    return e.prototype.postConstruct = function() {
      this.active = this.gridOptionsWrapper.isPagination(), this.paginateChildRows = this.gridOptionsWrapper.isPaginateChildRows(), this.addManagedListener(this.eventService, I.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this)), this.addManagedListener(this.gridOptionsWrapper, "paginationPageSize", this.onPaginationPageSizeChanged.bind(this)), this.onModelUpdated();
    }, e.prototype.ensureRowHeightsValid = function(t, i, r, o) {
      var s = this.rowModel.ensureRowHeightsValid(t, i, this.getPageFirstRow(), this.getPageLastRow());
      return s && this.calculatePages(), s;
    }, e.prototype.onModelUpdated = function(t) {
      this.calculatePages();
      var i = {
        type: I.EVENT_PAGINATION_CHANGED,
        animate: t ? t.animate : !1,
        newData: t ? t.newData : !1,
        newPage: t ? t.newPage : !1,
        keepRenderedRows: t ? t.keepRenderedRows : !1,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.onPaginationPageSizeChanged = function() {
      this.calculatePages();
      var t = {
        type: I.EVENT_PAGINATION_CHANGED,
        animate: !1,
        newData: !1,
        newPage: !1,
        // important to keep rendered rows, otherwise every time grid is resized,
        // we would destroy all the rows.
        keepRenderedRows: !0,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(t);
    }, e.prototype.goToPage = function(t) {
      if (!(!this.active || this.currentPage === t)) {
        this.currentPage = t;
        var i = {
          type: I.EVENT_MODEL_UPDATED,
          animate: !1,
          keepRenderedRows: !1,
          newData: !1,
          newPage: !0,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.onModelUpdated(i);
      }
    }, e.prototype.getPixelOffset = function() {
      return this.pixelOffset;
    }, e.prototype.getRow = function(t) {
      return this.rowModel.getRow(t);
    }, e.prototype.getRowNode = function(t) {
      return this.rowModel.getRowNode(t);
    }, e.prototype.getRowIndexAtPixel = function(t) {
      return this.rowModel.getRowIndexAtPixel(t);
    }, e.prototype.getCurrentPageHeight = function() {
      return Je(this.topRowBounds) || Je(this.bottomRowBounds) ? 0 : Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0);
    }, e.prototype.getCurrentPagePixelRange = function() {
      var t = this.topRowBounds ? this.topRowBounds.rowTop : 0, i = this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0;
      return { pageFirstPixel: t, pageLastPixel: i };
    }, e.prototype.isRowPresent = function(t) {
      if (!this.rowModel.isRowPresent(t))
        return !1;
      var i = t.rowIndex >= this.topDisplayedRowIndex && t.rowIndex <= this.bottomDisplayedRowIndex;
      return i;
    }, e.prototype.isEmpty = function() {
      return this.rowModel.isEmpty();
    }, e.prototype.isRowsToRender = function() {
      return this.rowModel.isRowsToRender();
    }, e.prototype.getNodesInRangeForSelection = function(t, i) {
      return this.rowModel.getNodesInRangeForSelection(t, i);
    }, e.prototype.forEachNode = function(t) {
      return this.rowModel.forEachNode(t);
    }, e.prototype.getType = function() {
      return this.rowModel.getType();
    }, e.prototype.getRowBounds = function(t) {
      var i = this.rowModel.getRowBounds(t);
      return i.rowIndex = t, i;
    }, e.prototype.getPageFirstRow = function() {
      return this.topRowBounds ? this.topRowBounds.rowIndex : -1;
    }, e.prototype.getPageLastRow = function() {
      return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1;
    }, e.prototype.getRowCount = function() {
      return this.rowModel.getRowCount();
    }, e.prototype.getPageForIndex = function(t) {
      return Math.floor(t / this.pageSize);
    }, e.prototype.goToPageWithIndex = function(t) {
      if (this.active) {
        var i = this.getPageForIndex(t);
        this.goToPage(i);
      }
    }, e.prototype.isRowInPage = function(t) {
      if (!this.active)
        return !0;
      var i = this.getPageForIndex(t.rowIndex);
      return i === this.currentPage;
    }, e.prototype.isLastPageFound = function() {
      return this.rowModel.isLastRowIndexKnown();
    }, e.prototype.getCurrentPage = function() {
      return this.currentPage;
    }, e.prototype.goToNextPage = function() {
      this.goToPage(this.currentPage + 1);
    }, e.prototype.goToPreviousPage = function() {
      this.goToPage(this.currentPage - 1);
    }, e.prototype.goToFirstPage = function() {
      this.goToPage(0);
    }, e.prototype.goToLastPage = function() {
      var t = this.rowModel.getRowCount(), i = Math.floor(t / this.pageSize);
      this.goToPage(i);
    }, e.prototype.getPageSize = function() {
      return this.pageSize;
    }, e.prototype.getTotalPages = function() {
      return this.totalPages;
    }, e.prototype.setPageSize = function() {
      this.pageSize = this.gridOptionsWrapper.getPaginationPageSize(), (this.pageSize == null || this.pageSize < 1) && (this.pageSize = 100);
    }, e.prototype.calculatePages = function() {
      this.active ? (this.setPageSize(), this.paginateChildRows ? this.calculatePagesAllRows() : this.calculatePagesMasterRowsOnly()) : this.calculatedPagesNotActive(), this.topRowBounds = this.rowModel.getRowBounds(this.topDisplayedRowIndex), this.topRowBounds && (this.topRowBounds.rowIndex = this.topDisplayedRowIndex), this.bottomRowBounds = this.rowModel.getRowBounds(this.bottomDisplayedRowIndex), this.bottomRowBounds && (this.bottomRowBounds.rowIndex = this.bottomDisplayedRowIndex), this.setPixelOffset(de(this.topRowBounds) ? this.topRowBounds.rowTop : 0);
    }, e.prototype.setPixelOffset = function(t) {
      this.pixelOffset !== t && (this.pixelOffset = t, this.eventService.dispatchEvent({ type: I.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED }));
    }, e.prototype.setZeroRows = function() {
      this.masterRowCount = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = -1, this.currentPage = 0, this.totalPages = 0;
    }, e.prototype.calculatePagesMasterRowsOnly = function() {
      if (this.masterRowCount = this.rowModel.getTopLevelRowCount(), this.masterRowCount <= 0) {
        this.setZeroRows();
        return;
      }
      var t = this.masterRowCount - 1;
      this.totalPages = Math.floor(t / this.pageSize) + 1, this.currentPage >= this.totalPages && (this.currentPage = this.totalPages - 1), (!Mw(this.currentPage) || this.currentPage < 0) && (this.currentPage = 0);
      var i = this.pageSize * this.currentPage, r = this.pageSize * (this.currentPage + 1) - 1;
      if (r > t && (r = t), this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(i), r === t)
        this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
      else {
        var o = this.rowModel.getTopLevelRowDisplayedIndex(r + 1);
        this.bottomDisplayedRowIndex = o - 1;
      }
    }, e.prototype.getMasterRowCount = function() {
      return this.masterRowCount;
    }, e.prototype.calculatePagesAllRows = function() {
      if (this.masterRowCount = this.rowModel.getRowCount(), this.masterRowCount === 0) {
        this.setZeroRows();
        return;
      }
      var t = this.masterRowCount - 1;
      this.totalPages = Math.floor(t / this.pageSize) + 1, this.currentPage >= this.totalPages && (this.currentPage = this.totalPages - 1), (!Mw(this.currentPage) || this.currentPage < 0) && (this.currentPage = 0), this.topDisplayedRowIndex = this.pageSize * this.currentPage, this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1, this.bottomDisplayedRowIndex > t && (this.bottomDisplayedRowIndex = t);
    }, e.prototype.calculatedPagesNotActive = function() {
      this.pageSize = this.rowModel.getRowCount(), this.totalPages = 1, this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
    }, pm([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), pm([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), pm([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), pm([
      Ee
    ], e.prototype, "postConstruct", null), e = pm([
      Ke("paginationProxy")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var qX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), yL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, YX = (
  /** @class */
  function(n) {
    qX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        t.centerRowContainerCon = i.centerRowContainerCtrl, t.addManagedListener(t.eventService, I.EVENT_BODY_HEIGHT_CHANGED, t.onBodyHeightChanged.bind(t)), t.addManagedListener(t.eventService, I.EVENT_SCROLL_VISIBILITY_CHANGED, t.onScrollVisibilityChanged.bind(t)), t.checkPageSize();
      });
    }, e.prototype.notActive = function() {
      return !this.gridOptionsWrapper.isPaginationAutoPageSize();
    }, e.prototype.onScrollVisibilityChanged = function() {
      this.checkPageSize();
    }, e.prototype.onBodyHeightChanged = function() {
      this.checkPageSize();
    }, e.prototype.checkPageSize = function() {
      if (!this.notActive()) {
        var t = this.gridOptionsWrapper.getRowHeightAsNumber(), i = this.centerRowContainerCon.getViewportSizeFeature().getBodyHeight();
        if (i > 0) {
          var r = Math.floor(i / t);
          this.gridOptionsWrapper.setProperty("paginationPageSize", r);
        }
      }
    }, yL([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), yL([
      Ee
    ], e.prototype, "postConstruct", null), e = yL([
      Ke("paginationAutoPageSizeService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var XX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), IM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, XH = (
  /** @class */
  function(n) {
    XX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.cacheVersion = 0, t;
    }
    return e.prototype.init = function() {
      this.active = this.gridOptionsWrapper.isValueCache(), this.neverExpires = this.gridOptionsWrapper.isValueCacheNeverExpires();
    }, e.prototype.onDataChanged = function() {
      this.neverExpires || this.expire();
    }, e.prototype.expire = function() {
      this.cacheVersion++;
    }, e.prototype.setValue = function(t, i, r) {
      this.active && (t.__cacheVersion !== this.cacheVersion && (t.__cacheVersion = this.cacheVersion, t.__cacheData = {}), t.__cacheData[i] = r);
    }, e.prototype.getValue = function(t, i) {
      if (!(!this.active || t.__cacheVersion !== this.cacheVersion))
        return t.__cacheData[i];
    }, IM([
      Ee
    ], e.prototype, "init", null), e = IM([
      Ke("valueCache")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var ZX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), BC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, QX = (
  /** @class */
  function(n) {
    ZX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      this.rowModel.getType() === q.ROW_MODEL_TYPE_CLIENT_SIDE && (this.clientSideRowModel = this.rowModel), this.addManagedListener(this.eventService, I.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged.bind(this));
    }, e.prototype.onCellValueChanged = function(t) {
      t.source !== q.SOURCE_PASTE && this.doChangeDetection(t.node, t.column);
    }, e.prototype.doChangeDetection = function(t, i) {
      if (!this.gridOptionsWrapper.isSuppressChangeDetection()) {
        if (this.clientSideRowModel && !t.isRowPinned()) {
          var r = this.gridOptionsWrapper.isAggregateOnlyChangedColumns(), o = new vx(r, this.clientSideRowModel.getRootNode());
          o.addParentNode(t.parent, [i]), this.clientSideRowModel.doAggregate(o);
        }
        this.rowRenderer.refreshCells();
      }
    }, BC([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), BC([
      R("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), BC([
      Ee
    ], e.prototype, "init", null), e = BC([
      Ke("changeDetectionService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var JX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), gm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, eZ = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, ZH = (
  /** @class */
  function(n) {
    JX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.consuming = !1, t;
    }
    return e.prototype.setBeans = function(t) {
      this.logger = t.create("AlignedGridsService");
    }, e.prototype.init = function() {
      this.addManagedListener(this.eventService, I.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, I.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, I.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, I.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, I.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, I.EVENT_BODY_SCROLL, this.fireScrollEvent.bind(this));
    }, e.prototype.fireEvent = function(t) {
      if (!this.consuming) {
        var i = this.gridOptionsWrapper.getAlignedGrids();
        i && i.forEach(function(r) {
          if (r.api) {
            var o = r.api.__getAlignedGridService();
            t(o);
          }
        });
      }
    }, e.prototype.onEvent = function(t) {
      this.consuming = !0, t(), this.consuming = !1;
    }, e.prototype.fireColumnEvent = function(t) {
      this.fireEvent(function(i) {
        i.onColumnEvent(t);
      });
    }, e.prototype.fireScrollEvent = function(t) {
      t.direction === "horizontal" && this.fireEvent(function(i) {
        i.onScrollEvent(t);
      });
    }, e.prototype.onScrollEvent = function(t) {
      var i = this;
      this.onEvent(function() {
        var r = i.ctrlsService.getGridBodyCtrl();
        r.getScrollFeature().setHorizontalScrollPosition(t.left);
      });
    }, e.prototype.getMasterColumns = function(t) {
      var i = [];
      return t.columns ? t.columns.forEach(function(r) {
        i.push(r);
      }) : t.column && i.push(t.column), i;
    }, e.prototype.getColumnIds = function(t) {
      var i = [];
      return t.columns ? t.columns.forEach(function(r) {
        i.push(r.getColId());
      }) : t.column && i.push(t.column.getColId()), i;
    }, e.prototype.onColumnEvent = function(t) {
      var i = this;
      this.onEvent(function() {
        switch (t.type) {
          case I.EVENT_COLUMN_MOVED:
          case I.EVENT_COLUMN_VISIBLE:
          case I.EVENT_COLUMN_PINNED:
          case I.EVENT_COLUMN_RESIZED:
            var r = t;
            i.processColumnEvent(r);
            break;
          case I.EVENT_COLUMN_GROUP_OPENED:
            var o = t;
            i.processGroupOpenedEvent(o);
            break;
          case I.EVENT_COLUMN_PIVOT_CHANGED:
            console.warn("AG Grid: pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.");
            break;
        }
      });
    }, e.prototype.processGroupOpenedEvent = function(t) {
      var i = t.columnGroup, r = null;
      if (i) {
        var o = i.getGroupId();
        r = this.columnModel.getProvidedColumnGroup(o);
      }
      i && !r || (this.logger.log("onColumnEvent-> processing " + t + " expanded = " + i.isExpanded()), this.columnModel.setColumnGroupOpened(r, i.isExpanded(), "alignedGridChanged"));
    }, e.prototype.processColumnEvent = function(t) {
      var i = this, r = t.column, o = null;
      if (r && (o = this.columnModel.getPrimaryColumn(r.getColId())), !(r && !o)) {
        var s = this.getMasterColumns(t);
        switch (t.type) {
          case I.EVENT_COLUMN_MOVED:
            {
              var a = t, l = t.columnApi.getColumnState(), u = l.map(function(_) {
                return { colId: _.colId };
              });
              this.columnModel.applyColumnState({ state: u, applyOrder: !0 }, "alignedGridChanged"), this.logger.log("onColumnEvent-> processing " + t.type + " toIndex = " + a.toIndex);
            }
            break;
          case I.EVENT_COLUMN_VISIBLE:
            {
              var c = t, l = t.columnApi.getColumnState(), u = l.map(function(v) {
                return { colId: v.colId, hide: v.hide };
              });
              this.columnModel.applyColumnState({ state: u }, "alignedGridChanged"), this.logger.log("onColumnEvent-> processing " + t.type + " visible = " + c.visible);
            }
            break;
          case I.EVENT_COLUMN_PINNED:
            {
              var h = t, l = t.columnApi.getColumnState(), u = l.map(function(v) {
                return { colId: v.colId, pinned: v.pinned };
              });
              this.columnModel.applyColumnState({ state: u }, "alignedGridChanged"), this.logger.log("onColumnEvent-> processing " + t.type + " pinned = " + h.pinned);
            }
            break;
          case I.EVENT_COLUMN_RESIZED:
            var d = t;
            s.forEach(function(_) {
              i.logger.log("onColumnEvent-> processing " + t.type + " actualWidth = " + _.getActualWidth());
              var m = [{ key: _.getColId(), newWidth: _.getActualWidth() }];
              i.columnModel.setColumnWidths(m, !1, d.finished, "alignedGridChanged");
            });
            break;
        }
        var f = this.ctrlsService.getGridBodyCtrl(), p = f.isVerticalScrollShowing(), g = this.gridOptionsWrapper.getAlignedGrids();
        g && g.forEach(function(_) {
          _.api && _.api.setAlwaysShowVerticalScroll(p);
        });
      }
    }, gm([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), gm([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), gm([
      eZ(0, wo("loggerFactory"))
    ], e.prototype, "setBeans", null), gm([
      Ee
    ], e.prototype, "init", null), e = gm([
      Ke("alignedGridsService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var tZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), PM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, iZ = (
  /** @class */
  function(n) {
    tZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.adaptFunction = function(t, i) {
      var r = this.componentMetadataProvider.retrieve(t);
      return r && r.functionAdapter ? r.functionAdapter(i) : null;
    }, e.prototype.adaptCellRendererFunction = function(t) {
      var i = (
        /** @class */
        function() {
          function r() {
          }
          return r.prototype.refresh = function(o) {
            return !1;
          }, r.prototype.getGui = function() {
            return this.eGui;
          }, r.prototype.init = function(o) {
            var s = t(o), a = typeof s;
            if (a === "string" || a === "number" || a === "boolean") {
              this.eGui = Dr("<span>" + s + "</span>");
              return;
            }
            if (s == null) {
              this.eGui = Dr("<span></span>");
              return;
            }
            this.eGui = s;
          }, r;
        }()
      );
      return i;
    }, e.prototype.doesImplementIComponent = function(t) {
      return t ? t.prototype && "getGui" in t.prototype : !1;
    }, PM([
      R("componentMetadataProvider")
    ], e.prototype, "componentMetadataProvider", void 0), e = PM([
      Ke("agComponentUtils")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var nZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, rZ = (
  /** @class */
  function(n) {
    nZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      this.componentMetaData = {
        dateComponent: {
          mandatoryMethodList: ["getDate", "setDate"],
          optionalMethodList: ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel"]
        },
        detailCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        headerComponent: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh"]
        },
        headerGroupComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        loadingCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        loadingOverlayComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        noRowsOverlayComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        floatingFilterComponent: {
          mandatoryMethodList: ["onParentModelChanged"],
          optionalMethodList: ["afterGuiAttached"]
        },
        floatingFilterWrapperComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        cellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh", "afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        cellEditor: {
          mandatoryMethodList: ["getValue"],
          optionalMethodList: ["isPopup", "isCancelBeforeStart", "isCancelAfterEnd", "getPopupPosition", "focusIn", "focusOut", "afterGuiAttached"]
        },
        innerRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        fullWidthCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh", "afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        pinnedRowCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh", "afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        groupRowRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        filter: {
          mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
          optionalMethodList: ["afterGuiAttached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged"]
        },
        filterComponent: {
          mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
          optionalMethodList: ["afterGuiAttached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged"]
        },
        statusPanel: {
          mandatoryMethodList: [],
          optionalMethodList: ["afterGuiAttached"]
        },
        toolPanel: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh", "afterGuiAttached"]
        },
        tooltipComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        }
      };
    }, e.prototype.retrieve = function(t) {
      return this.componentMetaData[t];
    }, wL([
      R("agComponentUtils")
    ], e.prototype, "agComponentUtils", void 0), wL([
      Ee
    ], e.prototype, "postConstruct", null), e = wL([
      Ke("componentMetadataProvider")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var oZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), AM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, bL = 8, sZ = 4, SL = 4, EL = 6, aZ = {
  // this item is required for custom themes
  "ag-theme-custom": {
    headerHeight: 25,
    headerCellMinWidth: 24,
    listItemHeight: sZ * 5,
    rowHeight: 25,
    chartMenuPanelWidth: 220
  },
  "ag-theme-material": {
    headerHeight: bL * 7,
    headerCellMinWidth: 48,
    listItemHeight: bL * 4,
    rowHeight: bL * 6,
    chartMenuPanelWidth: 240
  },
  "ag-theme-balham": {
    headerHeight: SL * 8,
    headerCellMinWidth: 24,
    listItemHeight: SL * 6,
    rowHeight: SL * 7,
    chartMenuPanelWidth: 220
  },
  "ag-theme-alpine": {
    headerHeight: EL * 8,
    headerCellMinWidth: 36,
    listItemHeight: EL * 4,
    rowHeight: EL * 7,
    chartMenuPanelWidth: 240
  }
}, MM = {
  headerHeight: ["ag-header-row"],
  headerCellMinWidth: ["ag-header-cell"],
  listItemHeight: ["ag-virtual-list-item"],
  rowHeight: ["ag-row"],
  chartMenuPanelWidth: ["ag-chart-docked-container"]
}, mm = {}, QH = (
  /** @class */
  function(n) {
    oZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getSassVariable = function(t, i) {
      var r = "ag-theme-" + (t.match("material") ? "material" : t.match("balham") ? "balham" : t.match("alpine") ? "alpine" : "custom"), o = aZ[r][i], s = 0;
      mm[t] || (mm[t] = {});
      var a = mm[t][i];
      if (a != null)
        return a;
      if (MM[i]) {
        var l = MM[i], u = document.createElement("div");
        u.classList.add(t), u.style.position = "absolute";
        var c = l.reduce(function(d, f) {
          var p = document.createElement("div");
          return p.style.position = "static", p.classList.add(f), d.appendChild(p), p;
        }, u);
        if (document.body) {
          document.body.appendChild(u);
          var h = i.toLowerCase().indexOf("height") !== -1 ? "height" : "width";
          s = parseInt(window.getComputedStyle(c)[h], 10), document.body.removeChild(u);
        }
      }
      return mm[t][i] = s || o, mm[t][i];
    }, e.prototype.isThemeDark = function() {
      var t = this.getTheme().theme;
      return !!t && t.indexOf("dark") >= 0;
    }, e.prototype.chartMenuPanelWidth = function() {
      var t = this.getTheme().themeFamily;
      return this.getSassVariable(t, "chartMenuPanelWidth");
    }, e.prototype.getTheme = function() {
      for (var t = /\bag-(material|(?:theme-([\w\-]*)))\b/, i = this.eGridDiv, r = null; i && (r = t.exec(i.className), !r); )
        i = i.parentElement || void 0;
      if (!r)
        return {};
      var o = r[0], s = r[2] === void 0;
      if (s) {
        var a = o.replace("ag-", "ag-theme-");
        mi(function() {
          return console.warn("AG Grid: As of v19 old theme are no longer provided. Please replace " + o + " with " + a + ".");
        }, "using-old-theme");
      }
      return { theme: o, el: i, themeFamily: o.replace(/-dark$/, "") };
    }, AM([
      R("eGridDiv")
    ], e.prototype, "eGridDiv", void 0), e = AM([
      Ke("environment")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var lZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), LL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, JH = (
  /** @class */
  function(n) {
    lZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.createTasksP1 = { list: [], sorted: !1 }, t.createTasksP2 = { list: [], sorted: !1 }, t.destroyTasks = [], t.ticking = !1, t.scrollGoingDown = !0, t.lastScrollTop = 0, t.taskCount = 0, t.cancelledTasks = /* @__PURE__ */ new Set(), t;
    }
    return e.prototype.setScrollTop = function(t) {
      this.scrollGoingDown = t > this.lastScrollTop, this.lastScrollTop = t;
    }, e.prototype.init = function() {
      this.useAnimationFrame = !this.gridOptionsWrapper.isSuppressAnimationFrame();
    }, e.prototype.isOn = function() {
      return this.useAnimationFrame;
    }, e.prototype.verifyAnimationFrameOn = function(t) {
      this.useAnimationFrame === !1 && console.warn("AG Grid: AnimationFrameService." + t + " called but animation frames are off");
    }, e.prototype.createTask = function(t, i, r) {
      this.verifyAnimationFrameOn(r);
      var o = { task: t, index: i, createOrder: ++this.taskCount };
      this.addTaskToList(this[r], o), this.schedule();
    }, e.prototype.cancelTask = function(t) {
      this.cancelledTasks.add(t);
    }, e.prototype.addTaskToList = function(t, i) {
      t.list.push(i), t.sorted = !1;
    }, e.prototype.sortTaskList = function(t) {
      if (!t.sorted) {
        var i = this.scrollGoingDown ? 1 : -1;
        t.list.sort(function(r, o) {
          return r.index !== o.index ? i * (o.index - r.index) : o.createOrder - r.createOrder;
        }), t.sorted = !0;
      }
    }, e.prototype.addDestroyTask = function(t) {
      this.verifyAnimationFrameOn("createTasksP3"), this.destroyTasks.push(t), this.schedule();
    }, e.prototype.executeFrame = function(t) {
      this.verifyAnimationFrameOn("executeFrame");
      for (var i = this.createTasksP1, r = i.list, o = this.createTasksP2, s = o.list, a = this.destroyTasks, l = (/* @__PURE__ */ new Date()).getTime(), u = (/* @__PURE__ */ new Date()).getTime() - l, c = t <= 0, h = this.ctrlsService.getGridBodyCtrl(); c || u < t; ) {
        var d = h.getScrollFeature().executeAnimationFrameScroll();
        if (!d) {
          var f = void 0;
          if (r.length)
            this.sortTaskList(i), f = r.pop().task;
          else if (s.length)
            this.sortTaskList(o), f = s.pop().task;
          else if (a.length)
            f = a.pop();
          else {
            this.cancelledTasks.clear();
            break;
          }
          this.cancelledTasks.has(f) || f();
        }
        u = (/* @__PURE__ */ new Date()).getTime() - l;
      }
      r.length || s.length || a.length ? this.requestFrame() : this.stopTicking();
    }, e.prototype.stopTicking = function() {
      this.ticking = !1;
    }, e.prototype.flushAllFrames = function() {
      this.useAnimationFrame && this.executeFrame(-1);
    }, e.prototype.schedule = function() {
      this.useAnimationFrame && (this.ticking || (this.ticking = !0, this.requestFrame()));
    }, e.prototype.requestFrame = function() {
      var t = this.executeFrame.bind(this, 60), i = this.gridOptionsWrapper.getDocument(), r = i.defaultView || window;
      r.requestAnimationFrame ? r.requestAnimationFrame(t) : r.webkitRequestAnimationFrame ? r.webkitRequestAnimationFrame(t) : r.setTimeout(t, 0);
    }, e.prototype.isQueueEmpty = function() {
      return !this.ticking;
    }, e.prototype.debounce = function(t) {
      var i = this, r = !1;
      return function() {
        if (!i.isOn()) {
          i.getFrameworkOverrides().setTimeout(t, 0);
          return;
        }
        r || (r = !0, i.addDestroyTask(function() {
          r = !1, t();
        }));
      };
    }, LL([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), LL([
      Ee
    ], e.prototype, "init", null), e = LL([
      Ke("animationFrameService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var uZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), jw = globalThis && globalThis.__assign || function() {
  return jw = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, jw.apply(this, arguments);
}, Io = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, e4 = (
  /** @class */
  function(n) {
    uZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.timeLastPageEventProcessed = 0, t;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        t.gridBodyCon = i.gridBodyCtrl;
      });
    }, e.prototype.handlePageScrollingKey = function(t) {
      var i = t.key, r = t.altKey, o = t.ctrlKey || t.metaKey, s = this.mouseEventService.getCellPositionForEvent(t);
      if (!s)
        return !1;
      var a = !1;
      switch (i) {
        case pe.PAGE_HOME:
        case pe.PAGE_END:
          !o && !r && (this.onHomeOrEndKey(i), a = !0);
          break;
        case pe.LEFT:
        case pe.RIGHT:
          o && !r && (this.onCtrlLeftOrRight(i, s), a = !0);
          break;
        case pe.UP:
        case pe.DOWN:
          o && !r && (this.onCtrlUpOrDown(i, s), a = !0);
          break;
        case pe.PAGE_DOWN:
          !o && !r && (this.onPageDown(s), a = !0);
          break;
        case pe.PAGE_UP:
          !o && !r && (this.onPageUp(s), a = !0);
          break;
      }
      return a && t.preventDefault(), a;
    }, e.prototype.isTimeSinceLastPageEventToRecent = function() {
      var t = (/* @__PURE__ */ new Date()).getTime(), i = t - this.timeLastPageEventProcessed;
      return i < 100;
    }, e.prototype.setTimeLastPageEventProcessed = function() {
      this.timeLastPageEventProcessed = (/* @__PURE__ */ new Date()).getTime();
    }, e.prototype.navigateTo = function(t) {
      var i = t.scrollIndex, r = t.scrollType, o = t.scrollColumn, s = t.focusIndex, a = t.focusColumn;
      if (de(o) && !o.isPinned() && this.gridBodyCon.getScrollFeature().ensureColumnVisible(o), de(i) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(i, r), this.animationFrameService.flushAllFrames(), this.focusService.setFocusedCell(s, a, null, !0), this.rangeService) {
        var l = { rowIndex: s, rowPinned: null, column: a };
        this.rangeService.setRangeToCell(l);
      }
    }, e.prototype.onPageDown = function(t) {
      if (!this.isTimeSinceLastPageEventToRecent()) {
        var i = this.ctrlsService.getGridBodyCtrl(), r = i.getScrollFeature().getVScrollPosition(), o = this.getViewportHeight(), s = this.paginationProxy.getPixelOffset(), a = r.top + o, l = this.paginationProxy.getRowIndexAtPixel(a + s), u = l, c = this.paginationProxy.getRow(t.rowIndex).rowTop, h = c + o - s, d = this.paginationProxy.getRowIndexAtPixel(h + s), f = this.paginationProxy.getPageLastRow();
        d === t.rowIndex && (u = d = t.rowIndex + 1), d > f && (d = f), u > f && (u = f), this.isRowTallerThanView(d) && (u = d), this.navigateTo({
          scrollIndex: u,
          scrollType: "top",
          scrollColumn: null,
          focusIndex: d,
          focusColumn: t.column
        }), this.setTimeLastPageEventProcessed();
      }
    }, e.prototype.onPageUp = function(t) {
      if (!this.isTimeSinceLastPageEventToRecent()) {
        var i = this.ctrlsService.getGridBodyCtrl(), r = i.getScrollFeature().getVScrollPosition(), o = this.getViewportHeight(), s = this.paginationProxy.getPixelOffset(), a = r.top, l = this.paginationProxy.getRowIndexAtPixel(a + s), u = l, c = this.paginationProxy.getRow(t.rowIndex), h = c.rowTop + c.rowHeight - o - s, d = this.paginationProxy.getRowIndexAtPixel(h + s), f = this.paginationProxy.getPageFirstRow();
        d === t.rowIndex && (u = d = t.rowIndex - 1), d < f && (d = f), u < f && (u = f);
        var p = "bottom";
        this.isRowTallerThanView(d) && (u = d, p = "top"), this.navigateTo({
          scrollIndex: u,
          scrollType: p,
          scrollColumn: null,
          focusIndex: d,
          focusColumn: t.column
        }), this.setTimeLastPageEventProcessed();
      }
    }, e.prototype.getViewportHeight = function() {
      var t = this.ctrlsService.getGridBodyCtrl(), i = t.getScrollFeature().getVScrollPosition(), r = this.gridOptionsWrapper.getScrollbarWidth(), o = i.bottom - i.top;
      return this.ctrlsService.getCenterRowContainerCtrl().isHorizontalScrollShowing() && (o -= r), o;
    }, e.prototype.isRowTallerThanView = function(t) {
      var i = this.paginationProxy.getRow(t);
      if (!i)
        return !1;
      var r = i.rowHeight;
      return typeof r != "number" ? !1 : r > this.getViewportHeight();
    }, e.prototype.getIndexToFocus = function(t, i) {
      var r = t;
      if (i) {
        var o = this.paginationProxy.getRow(t);
        o && o.stub && (r -= 1);
      }
      return r;
    }, e.prototype.onCtrlUpOrDown = function(t, i) {
      var r = t === pe.UP, o = r ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();
      this.navigateTo({
        scrollIndex: o,
        scrollType: null,
        scrollColumn: i.column,
        focusIndex: this.getIndexToFocus(o, !r),
        focusColumn: i.column
      });
    }, e.prototype.onCtrlLeftOrRight = function(t, i) {
      var r = t === pe.LEFT, o = this.columnModel.getAllDisplayedColumns(), s = this.gridOptionsWrapper.isEnableRtl(), a = r !== s ? o[0] : Di(o);
      this.navigateTo({
        scrollIndex: i.rowIndex,
        scrollType: null,
        scrollColumn: a,
        focusIndex: i.rowIndex,
        focusColumn: a
      });
    }, e.prototype.onHomeOrEndKey = function(t) {
      var i = t === pe.PAGE_HOME, r = this.columnModel.getAllDisplayedColumns(), o = i ? r[0] : Di(r), s = i ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();
      this.navigateTo({
        scrollIndex: s,
        scrollType: null,
        scrollColumn: o,
        focusIndex: this.getIndexToFocus(s, !i),
        focusColumn: o
      });
    }, e.prototype.onTabKeyDown = function(t, i) {
      var r = i.shiftKey, o = this.tabToNextCellCommon(t, r, i);
      if (o) {
        i.preventDefault();
        return;
      }
      if (r) {
        var s = t.getRowPosition(), a = s.rowIndex, l = s.rowPinned, u = l ? a === 0 : a === this.paginationProxy.getPageFirstRow();
        u && (i.preventDefault(), this.focusService.focusLastHeader(i));
      } else
        t instanceof jc && t.focusCell(!0), this.focusService.focusNextGridCoreContainer(r) && i.preventDefault();
    }, e.prototype.tabToNextCell = function(t, i) {
      var r = this.focusService.getFocusedCell();
      if (!r)
        return !1;
      var o = this.getCellByPosition(r);
      return !o && (o = this.rowRenderer.getRowByPosition(r), !o || !o.isFullWidth()) ? !1 : this.tabToNextCellCommon(o, t, i);
    }, e.prototype.tabToNextCellCommon = function(t, i, r) {
      var o = t.isEditing();
      if (!o && t instanceof jc) {
        var s = t, a = s.getRowCtrl();
        a && (o = a.isEditing());
      }
      var l;
      return o ? this.gridOptionsWrapper.isFullRowEdit() ? l = this.moveToNextEditingRow(t, i, r) : l = this.moveToNextEditingCell(t, i, r) : l = this.moveToNextCellNotEditing(t, i), l || !!this.focusService.getFocusedHeader();
    }, e.prototype.moveToNextEditingCell = function(t, i, r) {
      r === void 0 && (r = null);
      var o = t.getCellPosition();
      t.stopEditing();
      var s = this.findNextCellToFocusOn(o, i, !0);
      return s == null ? !1 : (s.startEditing(null, null, !0, r), s.focusCell(!1), !0);
    }, e.prototype.moveToNextEditingRow = function(t, i, r) {
      r === void 0 && (r = null);
      var o = t.getCellPosition(), s = this.findNextCellToFocusOn(o, i, !0);
      if (s == null)
        return !1;
      var a = s.getCellPosition(), l = this.isCellEditable(o), u = this.isCellEditable(a), c = a && o.rowIndex === a.rowIndex && o.rowPinned === a.rowPinned;
      if (l && t.setFocusOutOnEditor(), !c) {
        var h = t.getRowCtrl();
        h.stopEditing();
        var d = s.getRowCtrl();
        d.startRowEditing(void 0, void 0, void 0, r);
      }
      return u ? (s.setFocusInOnEditor(), s.focusCell()) : s.focusCell(!0), !0;
    }, e.prototype.moveToNextCellNotEditing = function(t, i) {
      var r = this.columnModel.getAllDisplayedColumns(), o;
      t instanceof $c ? o = jw(jw({}, t.getRowPosition()), { column: i ? r[0] : Di(r) }) : o = t.getCellPosition();
      var s = this.findNextCellToFocusOn(o, i, !1);
      if (s instanceof jc)
        s.focusCell(!0);
      else if (s)
        return this.tryToFocusFullWidthRow(s.getRowPosition(), i);
      return de(s);
    }, e.prototype.findNextCellToFocusOn = function(t, i, r) {
      for (var o = t; ; ) {
        t !== o && (t = o), i || (o = this.getLastCellOfColSpan(o)), o = this.cellNavigationService.getNextTabbedCell(o, i);
        var s = this.gridOptionsWrapper.getTabToNextCellFunc();
        if (de(s)) {
          var a = {
            backwards: i,
            editing: r,
            previousCellPosition: t,
            nextCellPosition: o || null,
            api: this.gridOptionsWrapper.getApi(),
            columnApi: this.gridOptionsWrapper.getColumnApi()
          }, l = s(a);
          de(l) ? (l.floating && (mi(function() {
            console.warn("AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?");
          }, "no floating in userCell"), l.rowPinned = l.floating), o = {
            rowIndex: l.rowIndex,
            column: l.column,
            rowPinned: l.rowPinned
          }) : o = null;
        }
        if (!o)
          return null;
        if (o.rowIndex < 0) {
          var u = this.headerNavigationService.getHeaderRowCount();
          return this.focusService.focusHeaderPosition({
            headerPosition: {
              headerRowIndex: u + o.rowIndex,
              column: o.column
            }
          }), null;
        }
        var c = this.gridOptionsWrapper.isFullRowEdit();
        if (r && !c) {
          var h = this.isCellEditable(o);
          if (!h)
            continue;
        }
        this.ensureCellVisible(o);
        var d = this.getCellByPosition(o);
        if (!d) {
          var f = this.rowRenderer.getRowByPosition(o);
          if (!f || !f.isFullWidth())
            continue;
          return f;
        }
        if (!d.isSuppressNavigable())
          return this.rangeService && this.rangeService.setRangeToCell(o), d;
      }
    }, e.prototype.isCellEditable = function(t) {
      var i = this.lookupRowNodeForCell(t);
      return i ? t.column.isCellEditable(i) : !1;
    }, e.prototype.getCellByPosition = function(t) {
      var i = this.rowRenderer.getRowByPosition(t);
      return i ? i.getCellCtrl(t.column) : null;
    }, e.prototype.lookupRowNodeForCell = function(t) {
      return t.rowPinned === q.PINNED_TOP ? this.pinnedRowModel.getPinnedTopRow(t.rowIndex) : t.rowPinned === q.PINNED_BOTTOM ? this.pinnedRowModel.getPinnedBottomRow(t.rowIndex) : this.paginationProxy.getRow(t.rowIndex);
    }, e.prototype.navigateToNextCell = function(t, i, r, o) {
      for (var s = r, a = !1; s && (s === r || !this.isValidNavigateCell(s)); )
        this.gridOptionsWrapper.isEnableRtl() ? i === pe.LEFT && (s = this.getLastCellOfColSpan(s)) : i === pe.RIGHT && (s = this.getLastCellOfColSpan(s)), s = this.cellNavigationService.getNextCellToFocus(i, s), a = Je(s);
      if (a && t && t.key === pe.UP && (s = {
        rowIndex: -1,
        rowPinned: null,
        column: r.column
      }), o) {
        var l = this.gridOptionsWrapper.getNavigateToNextCellFunc();
        if (de(l)) {
          var u = {
            key: i,
            previousCellPosition: r,
            nextCellPosition: s || null,
            event: t,
            api: this.gridOptionsWrapper.getApi(),
            columnApi: this.gridOptionsWrapper.getColumnApi()
          }, c = l(u);
          de(c) ? (c.floating && (mi(function() {
            console.warn("AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?");
          }, "no floating in userCell"), c.rowPinned = c.floating), s = {
            rowPinned: c.rowPinned,
            rowIndex: c.rowIndex,
            column: c.column
          }) : s = null;
        }
      }
      if (s) {
        if (s.rowIndex < 0) {
          var h = this.headerNavigationService.getHeaderRowCount();
          this.focusService.focusHeaderPosition({
            headerPosition: { headerRowIndex: h + s.rowIndex, column: r.column },
            event: t || void 0
          });
          return;
        }
        var d = this.getNormalisedPosition(s);
        d ? this.focusPosition(d) : this.tryToFocusFullWidthRow(s);
      }
    }, e.prototype.getNormalisedPosition = function(t) {
      this.ensureCellVisible(t);
      var i = this.getCellByPosition(t);
      return i ? (t = i.getCellPosition(), this.ensureCellVisible(t), t) : null;
    }, e.prototype.tryToFocusFullWidthRow = function(t, i) {
      i === void 0 && (i = !1);
      var r = this.columnModel.getAllDisplayedColumns(), o = this.rowRenderer.getRowByPosition(t);
      if (!o || !o.isFullWidth())
        return !1;
      var s = {
        rowIndex: t.rowIndex,
        rowPinned: t.rowPinned,
        column: t.column || (i ? Di(r) : r[0])
      };
      return this.focusPosition(s), !0;
    }, e.prototype.focusPosition = function(t) {
      this.focusService.setFocusedCell(t.rowIndex, t.column, t.rowPinned, !0), this.rangeService && this.rangeService.setRangeToCell(t);
    }, e.prototype.isValidNavigateCell = function(t) {
      var i = this.rowPositionUtils.getRowNode(t);
      return !!i;
    }, e.prototype.getLastCellOfColSpan = function(t) {
      var i = this.getCellByPosition(t);
      if (!i)
        return t;
      var r = i.getColSpanningList();
      return r.length === 1 ? t : {
        rowIndex: t.rowIndex,
        column: Di(r),
        rowPinned: t.rowPinned
      };
    }, e.prototype.ensureCellVisible = function(t) {
      Je(t.rowPinned) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(t.rowIndex), t.column.isPinned() || this.gridBodyCon.getScrollFeature().ensureColumnVisible(t.column), this.gridBodyCon.getScrollFeature().horizontallyScrollHeaderCenterAndFloatingCenter(), this.animationFrameService.flushAllFrames();
    }, Io([
      R("mouseEventService")
    ], e.prototype, "mouseEventService", void 0), Io([
      R("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), Io([
      R("focusService")
    ], e.prototype, "focusService", void 0), Io([
      R("animationFrameService")
    ], e.prototype, "animationFrameService", void 0), Io([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), Io([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), Io([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Io([
      R("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), Io([
      R("headerNavigationService")
    ], e.prototype, "headerNavigationService", void 0), Io([
      R("rowPositionUtils")
    ], e.prototype, "rowPositionUtils", void 0), Io([
      R("cellNavigationService")
    ], e.prototype, "cellNavigationService", void 0), Io([
      R("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), Io([
      Ee
    ], e.prototype, "postConstruct", null), e = Io([
      Ke("navigationService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var cZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), HC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, hZ = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, dZ = (
  /** @class */
  function(n) {
    cZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.scrollY = 0, t.uiBodyHeight = 0, t;
    }
    return e.prototype.agWire = function(t) {
      this.logger = t.create("RowContainerHeightService");
    }, e.prototype.postConstruct = function() {
      this.addManagedListener(this.eventService, I.EVENT_BODY_HEIGHT_CHANGED, this.updateOffset.bind(this)), this.maxDivHeight = aB(), this.logger.log("maxDivHeight = " + this.maxDivHeight);
    }, e.prototype.isStretching = function() {
      return this.stretching;
    }, e.prototype.getDivStretchOffset = function() {
      return this.divStretchOffset;
    }, e.prototype.updateOffset = function() {
      if (this.stretching) {
        var t = this.ctrlsService.getGridBodyCtrl(), i = t.getScrollFeature().getVScrollPosition().top, r = this.getUiBodyHeight(), o = i !== this.scrollY || r !== this.uiBodyHeight;
        o && (this.scrollY = i, this.uiBodyHeight = r, this.calculateOffset());
      }
    }, e.prototype.calculateOffset = function() {
      this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
      var t = this.scrollY / this.maxScrollY, i = t * this.pixelsToShave;
      this.logger.log("Div Stretch Offset = " + i + " (" + this.pixelsToShave + " * " + t + ")"), this.setDivStretchOffset(i);
    }, e.prototype.setUiContainerHeight = function(t) {
      t !== this.uiContainerHeight && (this.uiContainerHeight = t, this.eventService.dispatchEvent({ type: I.EVENT_ROW_CONTAINER_HEIGHT_CHANGED }));
    }, e.prototype.clearOffset = function() {
      this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0);
    }, e.prototype.setDivStretchOffset = function(t) {
      var i = typeof t == "number" ? Math.floor(t) : null;
      this.divStretchOffset !== i && (this.divStretchOffset = i, this.eventService.dispatchEvent({ type: I.EVENT_HEIGHT_SCALE_CHANGED }));
    }, e.prototype.setModelHeight = function(t) {
      this.modelHeight = t, this.stretching = t != null && this.maxDivHeight > 0 && t > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset();
    }, e.prototype.getUiContainerHeight = function() {
      return this.uiContainerHeight;
    }, e.prototype.getRealPixelPosition = function(t) {
      return t - this.divStretchOffset;
    }, e.prototype.getUiBodyHeight = function() {
      var t = this.ctrlsService.getGridBodyCtrl(), i = t.getScrollFeature().getVScrollPosition();
      return i.bottom - i.top;
    }, e.prototype.getScrollPositionForPixel = function(t) {
      if (this.pixelsToShave <= 0)
        return t;
      var i = this.modelHeight - this.getUiBodyHeight(), r = t / i, o = this.maxScrollY * r;
      return o;
    }, HC([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), HC([
      hZ(0, wo("loggerFactory"))
    ], e.prototype, "agWire", null), HC([
      Ee
    ], e.prototype, "postConstruct", null), e = HC([
      Ke("rowContainerHeightService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var fZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), FM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, t4 = (
  /** @class */
  function(n) {
    fZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      this.groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren(), this.isRowSelectableFunc = this.gridOptionsWrapper.getIsRowSelectableFunc();
    }, e.prototype.updateSelectableAfterGrouping = function(t) {
      if (this.isRowSelectableFunc) {
        var i = function(r) {
          return r.childrenAfterGroup;
        };
        this.recurseDown(t.childrenAfterGroup, i);
      }
    }, e.prototype.updateSelectableAfterFiltering = function(t) {
      if (this.isRowSelectableFunc) {
        var i = function(r) {
          return r.childrenAfterFilter;
        };
        this.recurseDown(t.childrenAfterGroup, i);
      }
    }, e.prototype.recurseDown = function(t, i) {
      var r = this;
      t && t.forEach(function(o) {
        if (o.group) {
          o.hasChildren() && r.recurseDown(i(o), i);
          var s;
          if (r.groupSelectsChildren) {
            var a = (i(o) || []).find(function(l) {
              return l.selectable === !0;
            });
            s = de(a);
          } else
            s = r.isRowSelectableFunc ? r.isRowSelectableFunc(o) : !1;
          o.setRowSelectable(s);
        }
      });
    }, FM([
      Ee
    ], e.prototype, "init", null), e = FM([
      Ke("selectableService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var pZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), qs = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, gZ = (
  /** @class */
  function(n) {
    pZ(e, n);
    function e() {
      var t = n.call(this) || this;
      return t.previousAndFirstButtonsDisabled = !1, t.nextButtonDisabled = !1, t.lastButtonDisabled = !1, t;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.gridOptionsWrapper.isEnableRtl();
      this.setTemplate(this.getTemplate()), this.btFirst.insertAdjacentElement("afterbegin", Kn(i ? "last" : "first", this.gridOptionsWrapper)), this.btPrevious.insertAdjacentElement("afterbegin", Kn(i ? "next" : "previous", this.gridOptionsWrapper)), this.btNext.insertAdjacentElement("afterbegin", Kn(i ? "previous" : "next", this.gridOptionsWrapper)), this.btLast.insertAdjacentElement("afterbegin", Kn(i ? "first" : "last", this.gridOptionsWrapper));
      var r = this.gridOptionsWrapper.isPagination(), o = r && !this.gridOptionsWrapper.isSuppressPaginationPanel();
      if (!o) {
        this.setDisplayed(!1);
        return;
      }
      this.addManagedListener(this.eventService, I.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this)), [
        { el: this.btFirst, fn: this.onBtFirst.bind(this) },
        { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
        { el: this.btNext, fn: this.onBtNext.bind(this) },
        { el: this.btLast, fn: this.onBtLast.bind(this) }
      ].forEach(function(s) {
        var a = s.el, l = s.fn;
        t.addManagedListener(a, "click", l), t.addManagedListener(a, "keydown", function(u) {
          (u.key === pe.ENTER || u.key === pe.SPACE) && (u.preventDefault(), l());
        });
      }), this.onPaginationChanged();
    }, e.prototype.onPaginationChanged = function() {
      this.enableOrDisableButtons(), this.updateRowLabels(), this.setCurrentPageLabel(), this.setTotalLabels();
    }, e.prototype.onBtFirst = function() {
      this.previousAndFirstButtonsDisabled || this.paginationProxy.goToFirstPage();
    }, e.prototype.setCurrentPageLabel = function() {
      var t = this.paginationProxy.getTotalPages() > 0, i = this.paginationProxy.getCurrentPage(), r = t ? i + 1 : 0;
      this.lbCurrent.innerHTML = this.formatNumber(r);
    }, e.prototype.formatNumber = function(t) {
      var i = this.gridOptionsWrapper.getPaginationNumberFormatterFunc();
      if (i)
        return i({ value: t });
      var r = this.gridOptionsWrapper.getLocaleTextFunc(), o = r("thousandSeparator", ","), s = r("decimalSeparator", ".");
      return lx(t, o, s);
    }, e.prototype.getTemplate = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = t("page", "Page"), r = t("to", "to"), o = t("of", "of"), s = t("firstPage", "First Page"), a = t("previousPage", "Previous Page"), l = t("nextPage", "Next Page"), u = t("lastPage", "Last Page"), c = this.getCompId();
      return (
        /* html */
        '<div class="ag-paging-panel ag-unselectable" id="ag-' + c + `">
                <span class="ag-paging-row-summary-panel" role="status">
                    <span id="ag-` + c + `-first-row" ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-` + c + '-to">' + r + `</span>
                    <span id="ag-` + c + `-last-row" ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-` + c + '-of">' + o + `</span>
                    <span id="ag-` + c + `-row-count" ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div ref="btFirst" class="ag-paging-button" role="button" aria-label="` + s + `" tabindex="0"></div>
                    <div ref="btPrevious" class="ag-paging-button" role="button" aria-label="` + a + `" tabindex="0"></div>
                    <span class="ag-paging-description" role="status">
                        <span id="ag-` + c + '-start-page">' + i + `</span>
                        <span id="ag-` + c + `-start-page-number" ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-` + c + '-of-page">' + o + `</span>
                        <span id="ag-` + c + `-of-page-number" ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div ref="btNext" class="ag-paging-button" role="button" aria-label="` + l + `" tabindex="0"></div>
                    <div ref="btLast" class="ag-paging-button" role="button" aria-label="` + u + `" tabindex="0"></div>
                </span>
            </div>`
      );
    }, e.prototype.onBtNext = function() {
      this.nextButtonDisabled || this.paginationProxy.goToNextPage();
    }, e.prototype.onBtPrevious = function() {
      this.previousAndFirstButtonsDisabled || this.paginationProxy.goToPreviousPage();
    }, e.prototype.onBtLast = function() {
      this.lastButtonDisabled || this.paginationProxy.goToLastPage();
    }, e.prototype.enableOrDisableButtons = function() {
      var t = this.paginationProxy.getCurrentPage(), i = this.paginationProxy.isLastPageFound(), r = this.paginationProxy.getTotalPages();
      this.previousAndFirstButtonsDisabled = t === 0, this.btFirst.classList.toggle("ag-disabled", this.previousAndFirstButtonsDisabled), Gf(this.btFirst, this.previousAndFirstButtonsDisabled), this.btPrevious.classList.toggle("ag-disabled", this.previousAndFirstButtonsDisabled), Gf(this.btPrevious, this.previousAndFirstButtonsDisabled);
      var o = this.isZeroPagesToDisplay(), s = i && t === r - 1;
      this.nextButtonDisabled = s || o, this.btNext.classList.toggle("ag-disabled", this.nextButtonDisabled), Gf(this.btNext, this.nextButtonDisabled), this.lastButtonDisabled = !i || o || t === r - 1, this.btLast.classList.toggle("ag-disabled", this.lastButtonDisabled), Gf(this.btLast, this.lastButtonDisabled);
    }, e.prototype.updateRowLabels = function() {
      var t = this.paginationProxy.getCurrentPage(), i = this.paginationProxy.getPageSize(), r = this.paginationProxy.isLastPageFound(), o = this.paginationProxy.isLastPageFound() ? this.paginationProxy.getMasterRowCount() : null, s, a;
      this.isZeroPagesToDisplay() ? s = a = 0 : (s = i * t + 1, a = s + i - 1, r && a > o && (a = o)), this.lbFirstRowOnPage.innerHTML = this.formatNumber(s), this.rowNodeBlockLoader.isLoading() ? this.lbLastRowOnPage.innerHTML = "?" : this.lbLastRowOnPage.innerHTML = this.formatNumber(a);
    }, e.prototype.isZeroPagesToDisplay = function() {
      var t = this.paginationProxy.isLastPageFound(), i = this.paginationProxy.getTotalPages();
      return t && i === 0;
    }, e.prototype.setTotalLabels = function() {
      var t = this.paginationProxy.isLastPageFound(), i = this.paginationProxy.getTotalPages(), r = t ? this.paginationProxy.getMasterRowCount() : null;
      if (r === 1) {
        var o = this.paginationProxy.getRow(0), s = o && o.group && !(o.groupData || o.aggData);
        if (s) {
          this.setTotalLabelsToZero();
          return;
        }
      }
      if (t)
        this.lbTotal.innerHTML = this.formatNumber(i), this.lbRecordCount.innerHTML = this.formatNumber(r);
      else {
        var a = this.gridOptionsWrapper.getLocaleTextFunc()("more", "more");
        this.lbTotal.innerHTML = a, this.lbRecordCount.innerHTML = a;
      }
    }, e.prototype.setTotalLabelsToZero = function() {
      this.lbFirstRowOnPage.innerHTML = this.formatNumber(0), this.lbCurrent.innerHTML = this.formatNumber(0), this.lbLastRowOnPage.innerHTML = this.formatNumber(0), this.lbTotal.innerHTML = this.formatNumber(0), this.lbRecordCount.innerHTML = this.formatNumber(0);
    }, qs([
      R("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), qs([
      R("rowNodeBlockLoader")
    ], e.prototype, "rowNodeBlockLoader", void 0), qs([
      fe("btFirst")
    ], e.prototype, "btFirst", void 0), qs([
      fe("btPrevious")
    ], e.prototype, "btPrevious", void 0), qs([
      fe("btNext")
    ], e.prototype, "btNext", void 0), qs([
      fe("btLast")
    ], e.prototype, "btLast", void 0), qs([
      fe("lbRecordCount")
    ], e.prototype, "lbRecordCount", void 0), qs([
      fe("lbFirstRowOnPage")
    ], e.prototype, "lbFirstRowOnPage", void 0), qs([
      fe("lbLastRowOnPage")
    ], e.prototype, "lbLastRowOnPage", void 0), qs([
      fe("lbCurrent")
    ], e.prototype, "lbCurrent", void 0), qs([
      fe("lbTotal")
    ], e.prototype, "lbTotal", void 0), qs([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var mZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), vZ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, kM = 50, i4 = (
  /** @class */
  function(n) {
    mZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.polyfillFunctions = [], t;
    }
    return e.prototype.observeResize = function(t, i) {
      var r = this, o = this.gridOptionsWrapper.getDocument(), s = o.defaultView || window, a = th(i, kM), l = function() {
        var d = new s.ResizeObserver(a);
        return d.observe(t), function() {
          return d.disconnect();
        };
      }, u = function() {
        var d = T1(t), f = R1(t), p = !0, g = function() {
          if (p) {
            var _ = T1(t), m = R1(t), v = _ !== d || m !== f;
            v && (d = _, f = m, i()), r.doNextPolyfillTurn(g);
          }
        };
        return g(), function() {
          return p = !1;
        };
      }, c = this.gridOptionsWrapper.isSuppressBrowserResizeObserver(), h = !!s.ResizeObserver;
      return h && !c ? l() : u();
    }, e.prototype.doNextPolyfillTurn = function(t) {
      this.polyfillFunctions.push(t), this.schedulePolyfill();
    }, e.prototype.schedulePolyfill = function() {
      var t = this;
      if (!this.polyfillScheduled) {
        var i = function() {
          var r = t.polyfillFunctions;
          t.polyfillScheduled = !1, t.polyfillFunctions = [], r.forEach(function(o) {
            return o();
          });
        };
        this.polyfillScheduled = !0, this.getFrameworkOverrides().setTimeout(i, kM);
      }
    }, e = vZ([
      Ke("resizeObserverService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var _Z = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _f = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Uf;
(function(n) {
  n[n.Loading = 0] = "Loading", n[n.NoRows = 1] = "NoRows";
})(Uf || (Uf = {}));
var CZ = (
  /** @class */
  function(n) {
    _Z(e, n);
    function e() {
      var t = n.call(this, e.TEMPLATE) || this;
      return t.inProgress = !1, t.destroyRequested = !1, t;
    }
    return e.prototype.updateLayoutClasses = function(t, i) {
      var r = this.eOverlayWrapper.classList;
      r.toggle(Fn.AUTO_HEIGHT, i.autoHeight), r.toggle(Fn.NORMAL, i.normal), r.toggle(Fn.PRINT, i.print);
    }, e.prototype.postConstruct = function() {
      this.createManagedBean(new Ex(this)), this.setDisplayed(!1), this.addManagedListener(this.eventService, I.EVENT_ROW_DATA_CHANGED, this.onRowDataChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_ROW_DATA_UPDATED, this.onRowDataChanged.bind(this)), this.addManagedListener(this.eventService, I.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this)), this.gridOptionsWrapper.isRowModelDefault() && !this.gridOptionsWrapper.getRowData() && this.showLoadingOverlay(), this.gridApi.registerOverlayWrapperComp(this);
    }, e.prototype.setWrapperTypeClass = function(t) {
      var i = this.eOverlayWrapper.classList;
      i.toggle("ag-overlay-loading-wrapper", t === Uf.Loading), i.toggle("ag-overlay-no-rows-wrapper", t === Uf.NoRows);
    }, e.prototype.showLoadingOverlay = function() {
      if (!this.gridOptionsWrapper.isSuppressLoadingOverlay()) {
        var t = {
          api: this.gridOptionsWrapper.getApi()
        }, i = this.userComponentFactory.getLoadingOverlayCompDetails(t), r = i.newAgStackInstance();
        this.showOverlay(r, Uf.Loading);
      }
    }, e.prototype.showNoRowsOverlay = function() {
      if (!this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {
        var t = {
          api: this.gridOptionsWrapper.getApi()
        }, i = this.userComponentFactory.getNoRowsOverlayCompDetails(t), r = i.newAgStackInstance();
        this.showOverlay(r, Uf.NoRows);
      }
    }, e.prototype.showOverlay = function(t, i) {
      var r = this;
      this.inProgress || (this.setWrapperTypeClass(i), this.destroyActiveOverlay(), this.inProgress = !0, t && t.then(function(o) {
        r.inProgress = !1, r.eOverlayWrapper.appendChild(o.getGui()), r.activeOverlay = o, r.destroyRequested && (r.destroyRequested = !1, r.destroyActiveOverlay());
      }), this.setDisplayed(!0));
    }, e.prototype.destroyActiveOverlay = function() {
      if (this.inProgress) {
        this.destroyRequested = !0;
        return;
      }
      this.activeOverlay && (this.activeOverlay = this.getContext().destroyBean(this.activeOverlay), ys(this.eOverlayWrapper));
    }, e.prototype.hideOverlay = function() {
      this.destroyActiveOverlay(), this.setDisplayed(!1);
    }, e.prototype.destroy = function() {
      this.destroyActiveOverlay(), n.prototype.destroy.call(this);
    }, e.prototype.showOrHideOverlay = function() {
      var t = this.paginationProxy.isEmpty(), i = this.gridOptionsWrapper.isSuppressNoRowsOverlay();
      t && !i ? this.showNoRowsOverlay() : this.hideOverlay();
    }, e.prototype.onRowDataChanged = function() {
      this.showOrHideOverlay();
    }, e.prototype.onNewColumnsLoaded = function() {
      this.columnModel.isReady() && !this.paginationProxy.isEmpty() && this.hideOverlay();
    }, e.TEMPLATE = `
        <div class="ag-overlay" aria-hidden="true">
            <div class="ag-overlay-panel">
                <div class="ag-overlay-wrapper" ref="eOverlayWrapper"></div>
            </div>
        </div>`, _f([
      R("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), _f([
      R("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), _f([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), _f([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), _f([
      fe("eOverlayWrapper")
    ], e.prototype, "eOverlayWrapper", void 0), _f([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var yZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), vc = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, n4 = (
  /** @class */
  function(n) {
    yZ(e, n);
    function e(t) {
      t === void 0 && (t = {});
      var i = n.call(this, e.getTemplate(t)) || this;
      i.suppressEnabledCheckbox = !0, i.suppressOpenCloseIcons = !1;
      var r = t.title, o = t.enabled, s = t.items, a = t.suppressEnabledCheckbox, l = t.suppressOpenCloseIcons;
      return i.title = r, i.cssIdentifier = t.cssIdentifier || "default", i.enabled = o ?? !0, i.items = s || [], i.alignItems = t.alignItems || "center", a != null && (i.suppressEnabledCheckbox = a), l != null && (i.suppressOpenCloseIcons = l), i;
    }
    return e.getTemplate = function(t) {
      var i = t.cssIdentifier || "default", r = t.direction || "vertical";
      return (
        /* html */
        '<div class="ag-group ag-' + i + `-group" role="presentation">
            <div class="ag-group-title-bar ag-` + i + `-group-title-bar ag-unselectable" ref="eTitleBar" role="button">
                <span class="ag-group-title-bar-icon ag-` + i + `-group-title-bar-icon" ref="eGroupOpenedIcon" role="presentation"></span>
                <span class="ag-group-title-bar-icon ag-` + i + `-group-title-bar-icon" ref="eGroupClosedIcon" role="presentation"></span>
                <span ref="eTitle" class="ag-group-title ag-` + i + `-group-title"></span>
            </div>
            <div ref="eToolbar" class="ag-group-toolbar ag-` + i + `-group-toolbar">
                <ag-checkbox ref="cbGroupEnabled"></ag-checkbox>
            </div>
            <div ref="eContainer" class="ag-group-container ag-group-container-` + r + " ag-" + i + `-group-container"></div>
        </div>`
      );
    }, e.prototype.postConstruct = function() {
      if (this.items.length) {
        var t = this.items;
        this.items = [], this.addItems(t);
      }
      var i = this.gridOptionsWrapper.getLocaleTextFunc();
      this.cbGroupEnabled.setLabel(i("enabled", "Enabled")), this.title && this.setTitle(this.title), this.enabled && this.setEnabled(this.enabled), this.setAlignItems(this.alignItems), this.hideEnabledCheckbox(this.suppressEnabledCheckbox), this.hideOpenCloseIcons(this.suppressOpenCloseIcons), this.setupExpandContract(), this.refreshAriaStatus(), this.refreshChildDisplay();
    }, e.prototype.setupExpandContract = function() {
      var t = this;
      this.eGroupClosedIcon.appendChild(Js("columnSelectClosed", this.gridOptionsWrapper, null)), this.eGroupOpenedIcon.appendChild(Js("columnSelectOpen", this.gridOptionsWrapper, null)), this.addManagedListener(this.eTitleBar, "click", function() {
        return t.toggleGroupExpand();
      }), this.addManagedListener(this.eTitleBar, "keydown", function(i) {
        switch (i.key) {
          case pe.ENTER:
          case pe.SPACE:
            i.preventDefault(), t.toggleGroupExpand();
            break;
          case pe.RIGHT:
          case pe.LEFT:
            i.preventDefault(), t.toggleGroupExpand(i.key === pe.RIGHT);
            break;
        }
      });
    }, e.prototype.refreshAriaStatus = function() {
      this.suppressOpenCloseIcons || _s(this.eTitleBar, this.expanded);
    }, e.prototype.refreshChildDisplay = function() {
      var t = !this.suppressOpenCloseIcons;
      Wi(this.eToolbar, this.expanded && !this.suppressEnabledCheckbox), Wi(this.eGroupOpenedIcon, t && this.expanded), Wi(this.eGroupClosedIcon, t && !this.expanded);
    }, e.prototype.isExpanded = function() {
      return this.expanded;
    }, e.prototype.setAlignItems = function(t) {
      this.alignItems !== t && this.removeCssClass("ag-group-item-alignment-" + this.alignItems), this.alignItems = t;
      var i = "ag-group-item-alignment-" + this.alignItems;
      return this.addCssClass(i), this;
    }, e.prototype.toggleGroupExpand = function(t) {
      return this.suppressOpenCloseIcons ? (this.expanded = !0, this.refreshChildDisplay(), Wi(this.eContainer, !0), this) : (t = t ?? !this.expanded, this.expanded === t ? this : (this.expanded = t, this.refreshAriaStatus(), this.refreshChildDisplay(), Wi(this.eContainer, t), this.dispatchEvent({ type: this.expanded ? e.EVENT_EXPANDED : e.EVENT_COLLAPSED }), this));
    }, e.prototype.addItems = function(t) {
      var i = this;
      t.forEach(function(r) {
        return i.addItem(r);
      });
    }, e.prototype.addItem = function(t) {
      var i = this.eContainer, r = t instanceof St ? t.getGui() : t;
      r.classList.add("ag-group-item", "ag-" + this.cssIdentifier + "-group-item"), i.appendChild(r), this.items.push(r);
    }, e.prototype.hideItem = function(t, i) {
      var r = this.items[i];
      r.classList.toggle("ag-hidden", t);
    }, e.prototype.setTitle = function(t) {
      return this.eTitle.innerText = t, this;
    }, e.prototype.addCssClassToTitleBar = function(t) {
      this.eTitleBar.classList.add(t);
    }, e.prototype.setEnabled = function(t, i) {
      return this.enabled = t, this.refreshDisabledStyles(), this.toggleGroupExpand(t), i || this.cbGroupEnabled.setValue(t), this;
    }, e.prototype.isEnabled = function() {
      return this.enabled;
    }, e.prototype.onEnableChange = function(t) {
      var i = this;
      return this.cbGroupEnabled.onValueChange(function(r) {
        i.setEnabled(r, !0), t(r);
      }), this;
    }, e.prototype.hideEnabledCheckbox = function(t) {
      return this.suppressEnabledCheckbox = t, this.refreshChildDisplay(), this.refreshDisabledStyles(), this;
    }, e.prototype.hideOpenCloseIcons = function(t) {
      return this.suppressOpenCloseIcons = t, t && this.toggleGroupExpand(!0), this;
    }, e.prototype.refreshDisabledStyles = function() {
      this.addOrRemoveCssClass("ag-disabled", !this.enabled), this.suppressEnabledCheckbox && !this.enabled ? (this.eTitleBar.classList.add("ag-disabled-group-title-bar"), this.eTitleBar.removeAttribute("tabindex")) : (this.eTitleBar.classList.remove("ag-disabled-group-title-bar"), this.eTitleBar.setAttribute("tabindex", "0")), this.eContainer.classList.toggle("ag-disabled-group-container", !this.enabled);
    }, e.EVENT_EXPANDED = "expanded", e.EVENT_COLLAPSED = "collapsed", vc([
      fe("eTitleBar")
    ], e.prototype, "eTitleBar", void 0), vc([
      fe("eGroupOpenedIcon")
    ], e.prototype, "eGroupOpenedIcon", void 0), vc([
      fe("eGroupClosedIcon")
    ], e.prototype, "eGroupClosedIcon", void 0), vc([
      fe("eToolbar")
    ], e.prototype, "eToolbar", void 0), vc([
      fe("cbGroupEnabled")
    ], e.prototype, "cbGroupEnabled", void 0), vc([
      fe("eTitle")
    ], e.prototype, "eTitle", void 0), vc([
      fe("eContainer")
    ], e.prototype, "eContainer", void 0), vc([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var wZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), WM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, r4 = "ag-resizer-wrapper", bZ = (
  /* html */
  '<div class="' + r4 + `">
        <div ref="eTopLeftResizer" class="ag-resizer ag-resizer-topLeft"></div>
        <div ref="eTopResizer" class="ag-resizer ag-resizer-top"></div>
        <div ref="eTopRightResizer" class="ag-resizer ag-resizer-topRight"></div>
        <div ref="eRightResizer" class="ag-resizer ag-resizer-right"></div>
        <div ref="eBottomRightResizer" class="ag-resizer ag-resizer-bottomRight"></div>
        <div ref="eBottomResizer" class="ag-resizer ag-resizer-bottom"></div>
        <div ref="eBottomLeftResizer" class="ag-resizer ag-resizer-bottomLeft"></div>
        <div ref="eLeftResizer" class="ag-resizer ag-resizer-left"></div>
    </div>`
), o4 = (
  /** @class */
  function(n) {
    wZ(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.element = t, r.dragStartPosition = {
        x: 0,
        y: 0
      }, r.position = {
        x: 0,
        y: 0
      }, r.lastSize = {
        width: -1,
        height: -1
      }, r.positioned = !1, r.resizersAdded = !1, r.resizeListeners = [], r.boundaryEl = null, r.isResizing = !1, r.isMoving = !1, r.resizable = {}, r.movable = !1, r.currentResizer = null, r.config = Object.assign({}, { popup: !1 }, i), r;
    }
    return e.prototype.center = function() {
      var t = this.offsetParent, i = t.clientHeight, r = t.clientWidth, o = r / 2 - this.getWidth() / 2, s = i / 2 - this.getHeight() / 2;
      this.offsetElement(o, s);
    }, e.prototype.initialisePosition = function() {
      var t = this.config, i = t.centered, r = t.forcePopupParentAsOffsetParent, o = t.minWidth, s = t.width, a = t.minHeight, l = t.height, u = t.x, c = t.y;
      this.offsetParent || this.setOffsetParent();
      var h = 0, d = 0, f = !!this.element.offsetParent;
      if (f) {
        var p = this.findBoundaryElement(), g = window.getComputedStyle(p);
        if (g.minWidth != null) {
          var _ = p.offsetWidth - this.element.offsetWidth;
          d = parseInt(g.minWidth, 10) - _;
        }
        if (g.minHeight != null) {
          var m = p.offsetHeight - this.element.offsetHeight;
          h = parseInt(g.minHeight, 10) - m;
        }
      }
      if (this.minHeight = a || h, this.minWidth = o || d, s && this.setWidth(s), l && this.setHeight(l), (!s || !l) && this.refreshSize(), i)
        this.center();
      else if (u || c)
        this.offsetElement(u, c);
      else if (f && r && this.boundaryEl) {
        var v = parseFloat(this.boundaryEl.style.top), C = parseFloat(this.boundaryEl.style.left);
        this.offsetElement(isNaN(C) ? 0 : C, isNaN(v) ? 0 : v);
      }
      this.positioned = !!this.offsetParent;
    }, e.prototype.isPositioned = function() {
      return this.positioned;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.setMovable = function(t, i) {
      if (!(!this.config.popup || t === this.movable)) {
        this.movable = t;
        var r = this.moveElementDragListener || {
          eElement: i,
          onDragStart: this.onMoveStart.bind(this),
          onDragging: this.onMove.bind(this),
          onDragStop: this.onMoveEnd.bind(this)
        };
        t ? (this.dragService.addDragSource(r), this.moveElementDragListener = r) : (this.dragService.removeDragSource(r), this.moveElementDragListener = void 0);
      }
    }, e.prototype.setResizable = function(t) {
      var i = this;
      if (this.clearResizeListeners(), t ? this.addResizers() : this.removeResizers(), typeof t == "boolean") {
        if (t === !1)
          return;
        t = {
          topLeft: t,
          top: t,
          topRight: t,
          right: t,
          bottomRight: t,
          bottom: t,
          bottomLeft: t,
          left: t
        };
      }
      Object.keys(t).forEach(function(r) {
        var o = t, s = !!o[r], a = i.getResizerElement(r), l = {
          dragStartPixels: 0,
          eElement: a,
          onDragStart: function(u) {
            return i.onResizeStart(u, r);
          },
          onDragging: i.onResize.bind(i),
          onDragStop: function(u) {
            return i.onResizeEnd(u, r);
          }
        };
        (!!i.resizable[r] !== s || !i.isAlive() && !s) && (s ? (i.dragService.addDragSource(l), i.resizeListeners.push(l), a.style.pointerEvents = "all") : a.style.pointerEvents = "none");
      });
    }, e.prototype.removeSizeFromEl = function() {
      this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex");
    }, e.prototype.restoreLastSize = function() {
      this.element.style.flex = "0 0 auto";
      var t = this.lastSize, i = t.height, r = t.width;
      r !== -1 && (this.element.style.width = r + "px"), i !== -1 && (this.element.style.height = i + "px");
    }, e.prototype.getHeight = function() {
      return this.element.offsetHeight;
    }, e.prototype.setHeight = function(t) {
      var i = this.config.popup, r = this.element, o = !1;
      if (typeof t == "string" && t.indexOf("%") !== -1)
        cd(r, t), t = ZO(r), o = !0;
      else if (this.positioned) {
        var s = this.element.getBoundingClientRect(), a = this.offsetParent.getBoundingClientRect();
        t = Math.max(this.minHeight, t);
        var l = this.offsetParent.clientHeight, u = i ? this.position.y : s.top, c = i ? 0 : a.top;
        l && t + u > l + c && (t = l - u);
      }
      this.getHeight() !== t && (o ? (r.style.maxHeight = "unset", r.style.minHeight = "unset") : i ? cd(r, t) : (r.style.height = t + "px", r.style.flex = "0 0 auto", this.lastSize.height = typeof t == "number" ? t : parseFloat(t)));
    }, e.prototype.getWidth = function() {
      return this.element.offsetWidth;
    }, e.prototype.setWidth = function(t) {
      var i = this.element, r = this.config.popup, o = !1;
      if (typeof t == "string" && t.indexOf("%") !== -1)
        Ul(i, t), t = bS(i), o = !0;
      else if (this.positioned) {
        t = Math.max(this.minWidth, t);
        var s = this.offsetParent.clientWidth, a = r ? this.position.x : this.element.getBoundingClientRect().left;
        s && t + a > s && (t = s - a);
      }
      this.getWidth() !== t && (o ? (i.style.maxWidth = "unset", i.style.minWidth = "unset") : this.config.popup ? Ul(i, t) : (i.style.width = t + "px", i.style.flex = " unset", this.lastSize.width = typeof t == "number" ? t : parseFloat(t)));
    }, e.prototype.offsetElement = function(t, i) {
      t === void 0 && (t = 0), i === void 0 && (i = 0);
      var r = this.config.forcePopupParentAsOffsetParent ? this.boundaryEl : this.element;
      this.popupService.positionPopup({
        ePopup: r,
        x: t,
        y: i,
        keepWithinBounds: !0
      }), this.setPosition(parseFloat(r.style.left), parseFloat(r.style.top));
    }, e.prototype.setPosition = function(t, i) {
      this.position.x = t, this.position.y = i;
    }, e.prototype.updateDragStartPosition = function(t, i) {
      this.dragStartPosition = { x: t, y: i };
    }, e.prototype.calculateMouseMovement = function(t) {
      var i = t.e, r = t.isLeft, o = t.isTop, s = t.anywhereWithin, a = t.topBuffer, l = i.clientX - this.dragStartPosition.x, u = i.clientY - this.dragStartPosition.y, c = this.shouldSkipX(i, !!r, !!s, l) ? 0 : l, h = this.shouldSkipY(i, !!o, a, u) ? 0 : u;
      return { movementX: c, movementY: h };
    }, e.prototype.shouldSkipX = function(t, i, r, o) {
      var s = this.element.getBoundingClientRect(), a = this.offsetParent.getBoundingClientRect(), l = this.boundaryEl.getBoundingClientRect(), u = this.config.popup ? this.position.x : s.left, c = u <= 0 && a.left >= t.clientX || a.right <= t.clientX && a.right <= l.right;
      return c ? !0 : (i ? c = // skip if we are moving to the left and the cursor
      // is positioned to the right of the left side anchor
      o < 0 && t.clientX > u + a.left || // skip if we are moving to the right and the cursor
      // is positioned to the left of the dialog
      o > 0 && t.clientX < u + a.left : r ? c = o < 0 && t.clientX > l.right || o > 0 && t.clientX < u + a.left : c = // if the movement is bound to the right side of the dialog
      // we skip if we are moving to the left and the cursor
      // is to the right of the dialog
      o < 0 && t.clientX > l.right || // or skip if we are moving to the right and the cursor
      // is to the left of the right side anchor
      o > 0 && t.clientX < l.right, c);
    }, e.prototype.shouldSkipY = function(t, i, r, o) {
      r === void 0 && (r = 0);
      var s = this.element.getBoundingClientRect(), a = this.offsetParent.getBoundingClientRect(), l = this.boundaryEl.getBoundingClientRect(), u = this.config.popup ? this.position.y : s.top, c = u <= 0 && a.top >= t.clientY || a.bottom <= t.clientY && a.bottom <= l.bottom;
      return c ? !0 : (i ? c = // skip if we are moving to towards top and the cursor is
      // below the top anchor + topBuffer
      // note: topBuffer is used when moving the dialog using the title bar
      o < 0 && t.clientY > u + a.top + r || // skip if we are moving to the bottom and the cursor is
      // above the top anchor
      o > 0 && t.clientY < u + a.top : c = // skip if we are moving towards the top and the cursor
      // is below the bottom anchor
      o < 0 && t.clientY > l.bottom || // skip if we are moving towards the bottom and the cursor
      // is above the bottom anchor
      o > 0 && t.clientY < l.bottom, c);
    }, e.prototype.createResizeMap = function() {
      var t = this.element;
      this.resizerMap = {
        topLeft: { element: t.querySelector("[ref=eTopLeftResizer]") },
        top: { element: t.querySelector("[ref=eTopResizer]") },
        topRight: { element: t.querySelector("[ref=eTopRightResizer]") },
        right: { element: t.querySelector("[ref=eRightResizer]") },
        bottomRight: { element: t.querySelector("[ref=eBottomRightResizer]") },
        bottom: { element: t.querySelector("[ref=eBottomResizer]") },
        bottomLeft: { element: t.querySelector("[ref=eBottomLeftResizer]") },
        left: { element: t.querySelector("[ref=eLeftResizer]") }
      };
    }, e.prototype.addResizers = function() {
      if (!this.resizersAdded) {
        var t = this.element;
        if (t) {
          var i = new DOMParser(), r = i.parseFromString(bZ, "text/html").body;
          t.appendChild(r.firstChild), this.createResizeMap(), this.resizersAdded = !0;
        }
      }
    }, e.prototype.removeResizers = function() {
      this.resizerMap = void 0;
      var t = this.element.querySelector("." + r4);
      t && this.element.removeChild(t), this.resizersAdded = !1;
    }, e.prototype.getResizerElement = function(t) {
      return this.resizerMap[t].element;
    }, e.prototype.onResizeStart = function(t, i) {
      this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = {
        isTop: !!i.match(/top/i),
        isRight: !!i.match(/right/i),
        isBottom: !!i.match(/bottom/i),
        isLeft: !!i.match(/left/i)
      }, this.element.classList.add("ag-resizing"), this.resizerMap[i].element.classList.add("ag-active");
      var r = this.config, o = r.popup, s = r.forcePopupParentAsOffsetParent;
      !o && !s && this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = !0, this.updateDragStartPosition(t.clientX, t.clientY);
    }, e.prototype.getSiblings = function() {
      var t = this.element, i = t.parentElement;
      return i ? Array.prototype.slice.call(i.children).filter(function(r) {
        return !r.classList.contains("ag-hidden");
      }) : null;
    }, e.prototype.getMinSizeOfSiblings = function() {
      for (var t = this.getSiblings() || [], i = 0, r = 0, o = 0; o < t.length; o++) {
        var s = t[o], a = !!s.style.flex && s.style.flex !== "0 0 auto";
        if (s !== this.element) {
          var l = this.minHeight || 0, u = this.minWidth || 0;
          if (a) {
            var c = window.getComputedStyle(s);
            c.minHeight && (l = parseInt(c.minHeight, 10)), c.minWidth && (u = parseInt(c.minWidth, 10));
          } else
            l = s.offsetHeight, u = s.offsetWidth;
          i += l, r += u;
        }
      }
      return { height: i, width: r };
    }, e.prototype.applySizeToSiblings = function(t) {
      var i = null, r = this.getSiblings();
      if (r) {
        for (var o = 0; o < r.length; o++) {
          var s = r[o];
          s !== i && (t ? s.style.height = s.offsetHeight + "px" : s.style.width = s.offsetWidth + "px", s.style.flex = "0 0 auto", s === this.element && (i = r[o + 1]));
        }
        i && (i.style.removeProperty("height"), i.style.removeProperty("min-height"), i.style.removeProperty("max-height"), i.style.flex = "1 1 auto");
      }
    }, e.prototype.onResize = function(t) {
      if (!(!this.isResizing || !this.currentResizer)) {
        var i = this.config, r = i.popup, o = i.forcePopupParentAsOffsetParent, s = this.currentResizer, a = s.isTop, l = s.isRight, u = s.isBottom, c = s.isLeft, h = l || c, d = u || a, f = this.calculateMouseMovement({ e: t, isLeft: c, isTop: a }), p = f.movementX, g = f.movementY, _ = this.position.x, m = this.position.y, v = 0, C = 0;
        if (h && p) {
          var y = c ? -1 : 1, b = this.getWidth(), L = b + p * y, S = !1;
          c && (v = b - L, (_ + v <= 0 || L <= this.minWidth) && (S = !0, v = 0)), S || this.setWidth(L);
        }
        if (d && g) {
          var y = a ? -1 : 1, E = this.getHeight(), D = E + g * y, O = !1;
          a ? (C = E - D, (m + C <= 0 || D <= this.minHeight) && (O = !0, C = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && E < D && this.getMinSizeOfSiblings().height + D > this.element.parentElement.offsetHeight && (O = !0), O || this.setHeight(D);
        }
        this.updateDragStartPosition(t.clientX, t.clientY), ((r || o) && v || C) && this.offsetElement(_ + v, m + C);
      }
    }, e.prototype.onResizeEnd = function(t, i) {
      this.isResizing = !1, this.currentResizer = null, this.boundaryEl = null;
      var r = {
        type: "resize",
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi()
      };
      this.element.classList.remove("ag-resizing"), this.resizerMap[i].element.classList.remove("ag-active"), this.dispatchEvent(r);
    }, e.prototype.refreshSize = function() {
      var t = this.element;
      this.config.popup && (this.config.width || this.setWidth(t.offsetWidth), this.config.height || this.setHeight(t.offsetHeight));
    }, e.prototype.onMoveStart = function(t) {
      this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = !0, this.element.classList.add("ag-moving"), this.updateDragStartPosition(t.clientX, t.clientY);
    }, e.prototype.onMove = function(t) {
      if (this.isMoving) {
        var i = this.position, r = i.x, o = i.y, s;
        this.config.calculateTopBuffer && (s = this.config.calculateTopBuffer());
        var a = this.calculateMouseMovement({
          e: t,
          isTop: !0,
          anywhereWithin: !0,
          topBuffer: s
        }), l = a.movementX, u = a.movementY;
        this.offsetElement(r + l, o + u), this.updateDragStartPosition(t.clientX, t.clientY);
      }
    }, e.prototype.onMoveEnd = function() {
      this.isMoving = !1, this.boundaryEl = null, this.element.classList.remove("ag-moving");
    }, e.prototype.setOffsetParent = function() {
      this.config.forcePopupParentAsOffsetParent ? this.offsetParent = this.popupService.getPopupParent() : this.offsetParent = this.element.offsetParent;
    }, e.prototype.findBoundaryElement = function() {
      for (var t = this.element; t; ) {
        if (window.getComputedStyle(t).position !== "static")
          return t;
        t = t.parentElement;
      }
      return this.element;
    }, e.prototype.clearResizeListeners = function() {
      for (; this.resizeListeners.length; ) {
        var t = this.resizeListeners.pop();
        this.dragService.removeDragSource(t);
      }
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this), this.moveElementDragListener && this.dragService.removeDragSource(this.moveElementDragListener), this.clearResizeListeners(), this.removeResizers();
    }, WM([
      R("popupService")
    ], e.prototype, "popupService", void 0), WM([
      R("dragService")
    ], e.prototype, "dragService", void 0), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var SZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), vm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Lx = (
  /** @class */
  function(n) {
    SZ(e, n);
    function e(t) {
      var i = n.call(this, e.getTemplate(t)) || this;
      return i.closable = !0, i.config = t, i;
    }
    return e.getTemplate = function(t) {
      var i = t && t.cssIdentifier || "default";
      return (
        /* html */
        '<div class="ag-panel ag-' + i + `-panel" tabindex="-1">
            <div ref="eTitleBar" class="ag-panel-title-bar ag-` + i + `-panel-title-bar ag-unselectable">
                <span ref="eTitle" class="ag-panel-title-bar-title ag-` + i + `-panel-title-bar-title"></span>
                <div ref="eTitleBarButtons" class="ag-panel-title-bar-buttons ag-` + i + `-panel-title-bar-buttons"></div>
            </div>
            <div ref="eContentWrapper" class="ag-panel-content-wrapper ag-` + i + `-panel-content-wrapper"></div>
        </div>`
      );
    }, e.prototype.postConstruct = function() {
      var t = this, i = this.config, r = i.component, o = i.closable, s = i.hideTitleBar, a = i.title, l = i.minWidth, u = l === void 0 ? 250 : l, c = i.width, h = i.minHeight, d = h === void 0 ? 250 : h, f = i.height, p = i.centered, g = i.popup, _ = i.x, m = i.y;
      this.positionableFeature = new o4(this.getGui(), {
        minWidth: u,
        width: c,
        minHeight: d,
        height: f,
        centered: p,
        x: _,
        y: m,
        popup: g,
        calculateTopBuffer: function() {
          return t.positionableFeature.getHeight() - t.getBodyHeight();
        }
      }), this.createManagedBean(this.positionableFeature);
      var v = this.getGui();
      r && this.setBodyComponent(r), s ? this.eTitleBar.classList.add("ag-hidden") : (a && this.setTitle(a), this.setClosable(o ?? this.closable)), this.addManagedListener(this.eTitleBar, "mousedown", function(C) {
        var y = t.gridOptionsWrapper.getDocument();
        if (v.contains(C.relatedTarget) || v.contains(y.activeElement) || t.eTitleBarButtons.contains(C.target)) {
          C.preventDefault();
          return;
        }
        var b = t.eContentWrapper.querySelector("button, [href], input, select, textarea, [tabindex]");
        b && b.focus();
      }), !(g && this.positionableFeature.isPositioned()) && (this.renderComponent && this.renderComponent(), this.positionableFeature.initialisePosition(), this.eContentWrapper.style.height = "0");
    }, e.prototype.renderComponent = function() {
      var t = this, i = this.getGui();
      i.focus(), this.close = function() {
        i.parentElement.removeChild(i), t.destroy();
      };
    }, e.prototype.getHeight = function() {
      return this.positionableFeature.getHeight();
    }, e.prototype.setHeight = function(t) {
      this.positionableFeature.setHeight(t);
    }, e.prototype.getWidth = function() {
      return this.positionableFeature.getWidth();
    }, e.prototype.setWidth = function(t) {
      this.positionableFeature.setWidth(t);
    }, e.prototype.setClosable = function(t) {
      if (t !== this.closable && (this.closable = t), t) {
        var i = this.closeButtonComp = new St(e.CLOSE_BTN_TEMPLATE);
        this.getContext().createBean(i);
        var r = i.getGui(), o = Kn("close", this.gridOptionsWrapper);
        o.classList.add("ag-panel-title-bar-button-icon"), r.appendChild(o), this.addTitleBarButton(i), i.addManagedListener(r, "click", this.onBtClose.bind(this));
      } else if (this.closeButtonComp) {
        var r = this.closeButtonComp.getGui();
        r.parentElement.removeChild(r), this.closeButtonComp = this.destroyBean(this.closeButtonComp);
      }
    }, e.prototype.setBodyComponent = function(t) {
      t.setParentComponent(this), this.eContentWrapper.appendChild(t.getGui());
    }, e.prototype.addTitleBarButton = function(t, i) {
      var r = this.eTitleBarButtons, o = r.children, s = o.length;
      i == null && (i = s), i = Math.max(0, Math.min(i, s)), t.addCssClass("ag-panel-title-bar-button");
      var a = t.getGui();
      i === 0 ? r.insertAdjacentElement("afterbegin", a) : i === s ? r.insertAdjacentElement("beforeend", a) : o[i - 1].insertAdjacentElement("afterend", a), t.setParentComponent(this);
    }, e.prototype.getBodyHeight = function() {
      return E_(this.eContentWrapper);
    }, e.prototype.getBodyWidth = function() {
      return wS(this.eContentWrapper);
    }, e.prototype.setTitle = function(t) {
      this.eTitle.innerText = t;
    }, e.prototype.onBtClose = function() {
      this.close();
    }, e.prototype.destroy = function() {
      this.closeButtonComp && (this.closeButtonComp = this.destroyBean(this.closeButtonComp));
      var t = this.getGui();
      t && t.offsetParent && this.close(), n.prototype.destroy.call(this);
    }, e.CLOSE_BTN_TEMPLATE = '<div class="ag-button"></div>', vm([
      fe("eContentWrapper")
    ], e.prototype, "eContentWrapper", void 0), vm([
      fe("eTitleBar")
    ], e.prototype, "eTitleBar", void 0), vm([
      fe("eTitleBarButtons")
    ], e.prototype, "eTitleBarButtons", void 0), vm([
      fe("eTitle")
    ], e.prototype, "eTitle", void 0), vm([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var EZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), $w = globalThis && globalThis.__assign || function() {
  return $w = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, $w.apply(this, arguments);
}, LZ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Dx = (
  /** @class */
  function(n) {
    EZ(e, n);
    function e(t) {
      var i = n.call(this, $w($w({}, t), { popup: !0 })) || this;
      return i.isMaximizable = !1, i.isMaximized = !1, i.maximizeListeners = [], i.resizeListenerDestroy = null, i.lastPosition = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.getGui(), r = this.config, o = r.movable, s = r.resizable, a = r.maximizable;
      this.addCssClass("ag-dialog"), n.prototype.postConstruct.call(this), this.addManagedListener(i, "focusin", function(l) {
        i.contains(l.relatedTarget) || t.popupService.bringPopupToFront(i);
      }), o && this.setMovable(o), a && this.setMaximizable(a), s && this.setResizable(s);
    }, e.prototype.renderComponent = function() {
      var t = this.getGui(), i = this.config, r = i.alwaysOnTop, o = i.modal, s = i.title, a = this.gridOptionsWrapper.getLocaleTextFunc(), l = this.popupService.addPopup({
        modal: o,
        eChild: t,
        closeOnEsc: !0,
        closedCallback: this.destroy.bind(this),
        alwaysOnTop: r,
        ariaLabel: s || a("ariaLabelDialog", "Dialog")
      });
      l && (this.close = l.hideFunc);
    }, e.prototype.toggleMaximize = function() {
      var t = this.positionableFeature.getPosition();
      if (this.isMaximized) {
        var i = this.lastPosition, r = i.x, o = i.y, s = i.width, a = i.height;
        this.setWidth(s), this.setHeight(a), this.positionableFeature.offsetElement(r, o);
      } else
        this.lastPosition.width = this.getWidth(), this.lastPosition.height = this.getHeight(), this.lastPosition.x = t.x, this.lastPosition.y = t.y, this.positionableFeature.offsetElement(0, 0), this.setHeight("100%"), this.setWidth("100%");
      this.isMaximized = !this.isMaximized, this.refreshMaximizeIcon();
    }, e.prototype.refreshMaximizeIcon = function() {
      Wi(this.maximizeIcon, !this.isMaximized), Wi(this.minimizeIcon, this.isMaximized);
    }, e.prototype.clearMaximizebleListeners = function() {
      this.maximizeListeners.length && (this.maximizeListeners.forEach(function(t) {
        return t();
      }), this.maximizeListeners.length = 0), this.resizeListenerDestroy && (this.resizeListenerDestroy(), this.resizeListenerDestroy = null);
    }, e.prototype.destroy = function() {
      this.maximizeButtonComp = this.destroyBean(this.maximizeButtonComp), this.clearMaximizebleListeners(), n.prototype.destroy.call(this);
    }, e.prototype.setResizable = function(t) {
      this.positionableFeature.setResizable(t);
    }, e.prototype.setMovable = function(t) {
      this.positionableFeature.setMovable(t, this.eTitleBar);
    }, e.prototype.setMaximizable = function(t) {
      var i = this;
      if (!t) {
        this.clearMaximizebleListeners(), this.maximizeButtonComp && (this.destroyBean(this.maximizeButtonComp), this.maximizeButtonComp = this.maximizeIcon = this.minimizeIcon = void 0);
        return;
      }
      var r = this.eTitleBar;
      if (!(!r || t === this.isMaximizable)) {
        var o = this.maximizeButtonComp = this.createBean(new St(
          /* html */
          '<div class="ag-dialog-button"></span>'
        )), s = o.getGui();
        s.appendChild(this.maximizeIcon = Kn("maximize", this.gridOptionsWrapper)), this.maximizeIcon.classList.add("ag-panel-title-bar-button-icon"), s.appendChild(this.minimizeIcon = Kn("minimize", this.gridOptionsWrapper)), this.minimizeIcon.classList.add("ag-panel-title-bar-button-icon", "ag-hidden"), o.addManagedListener(s, "click", this.toggleMaximize.bind(this)), this.addTitleBarButton(o, 0), this.maximizeListeners.push(this.addManagedListener(r, "dblclick", this.toggleMaximize.bind(this))), this.resizeListenerDestroy = this.addManagedListener(this, "resize", function() {
          i.isMaximized = !1, i.refreshMaximizeIcon();
        });
      }
    }, LZ([
      R("popupService")
    ], e.prototype, "popupService", void 0), e;
  }(Lx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var DZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Rx = (
  /** @class */
  function(n) {
    DZ(e, n);
    function e(t, i, r) {
      return i === void 0 && (i = "ag-text-field"), r === void 0 && (r = "text"), n.call(this, t, i, r) || this;
    }
    return e.prototype.postConstruct = function() {
      n.prototype.postConstruct.call(this), this.config.allowedCharPattern && this.preventDisallowedCharacters();
    }, e.prototype.setValue = function(t, i) {
      var r = n.prototype.setValue.call(this, t, i);
      return this.eInput.value !== t && (this.eInput.value = de(t) ? t : ""), r;
    }, e.prototype.preventDisallowedCharacters = function() {
      var t = new RegExp("[" + this.config.allowedCharPattern + "]"), i = function(r) {
        r.key && !t.test(r.key) && r.preventDefault();
      };
      this.addManagedListener(this.eInput, "keypress", i), this.addManagedListener(this.eInput, "paste", function(r) {
        var o, s = (o = r.clipboardData) === null || o === void 0 ? void 0 : o.getData("text");
        s && s.split("").some(function(a) {
          return !t.test(a);
        }) && r.preventDefault();
      });
    }, e;
  }(Pu)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var RZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), s4 = (
  /** @class */
  function(n) {
    RZ(e, n);
    function e(t) {
      return n.call(this, t, "ag-text-area", null, "textarea") || this;
    }
    return e.prototype.setValue = function(t, i) {
      var r = n.prototype.setValue.call(this, t, i);
      return this.eInput.value = t, r;
    }, e.prototype.setCols = function(t) {
      return this.eInput.cols = t, this;
    }, e.prototype.setRows = function(t) {
      return this.eInput.rows = t, this;
    }, e;
  }(Pu)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var TZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), GC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, a4 = (
  /** @class */
  function(n) {
    TZ(e, n);
    function e(t) {
      var i = n.call(this, t, e.TEMPLATE) || this;
      return i.labelAlignment = "top", i;
    }
    return e.prototype.init = function() {
      this.eSlider.addCssClass("ag-slider-field");
    }, e.prototype.onValueChange = function(t) {
      var i = this, r = Fl.EVENT_CHANGED;
      return this.addManagedListener(this.eText, r, function() {
        var o = parseFloat(i.eText.getValue());
        i.eSlider.setValue(o.toString(), !0), t(o || 0);
      }), this.addManagedListener(this.eSlider, r, function() {
        var o = i.eSlider.getValue();
        i.eText.setValue(o, !0), t(parseFloat(o));
      }), this;
    }, e.prototype.setSliderWidth = function(t) {
      return this.eSlider.setWidth(t), this;
    }, e.prototype.setTextFieldWidth = function(t) {
      return this.eText.setWidth(t), this;
    }, e.prototype.setMinValue = function(t) {
      return this.eSlider.setMinValue(t), this.eText.setMin(t), this;
    }, e.prototype.setMaxValue = function(t) {
      return this.eSlider.setMaxValue(t), this.eText.setMax(t), this;
    }, e.prototype.getValue = function() {
      return this.eText.getValue();
    }, e.prototype.setValue = function(t) {
      return this.getValue() === t ? this : (this.eText.setValue(t, !0), this.eSlider.setValue(t, !0), this.dispatchEvent({ type: Fl.EVENT_CHANGED }), this);
    }, e.prototype.setStep = function(t) {
      return this.eSlider.setStep(t), this.eText.setStep(t), this;
    }, e.TEMPLATE = `<div class="ag-slider">
            <label ref="eLabel"></label>
            <div class="ag-wrapper ag-slider-wrapper">
                <ag-input-range ref="eSlider"></ag-input-range>
                <ag-input-number-field ref="eText"></ag-input-number-field>
            </div>
        </div>`, GC([
      fe("eLabel")
    ], e.prototype, "eLabel", void 0), GC([
      fe("eSlider")
    ], e.prototype, "eSlider", void 0), GC([
      fe("eText")
    ], e.prototype, "eText", void 0), GC([
      Ee
    ], e.prototype, "init", null), e;
  }(hx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var OZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), fu = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, xZ = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, NZ = (
  /** @class */
  function(n) {
    OZ(e, n);
    function e(t) {
      var i = n.call(this, e.TEMPLATE) || this;
      return i.H = 1, i.S = 1, i.B = 1, i.A = 1, i.isSpectrumDragging = !1, i.isSpectrumHueDragging = !1, i.isSpectrumAlphaDragging = !1, i.colorChanged = !1, i.picker = t.picker, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this.getGui();
      this.initRecentColors(), this.addManagedListener(this.spectrumVal, "mousedown", this.onSpectrumDraggerDown.bind(this)), this.addManagedListener(t, "mousemove", this.onSpectrumDraggerMove.bind(this)), this.addManagedListener(this.spectrumHue, "mousedown", this.onSpectrumHueDown.bind(this)), this.addManagedListener(t, "mousemove", this.onSpectrumHueMove.bind(this)), this.addManagedListener(this.spectrumAlpha, "mousedown", this.onSpectrumAlphaDown.bind(this)), this.addManagedListener(t, "mousemove", this.onSpectrumAlphaMove.bind(this)), this.addManagedListener(document, "mouseup", this.onMouseUp.bind(this)), this.addManagedListener(this.recentColors, "click", this.onRecentColorClick.bind(this));
    }, e.prototype.refreshSpectrumRect = function() {
      return this.spectrumValRect = this.spectrumVal.getBoundingClientRect();
    }, e.prototype.refreshHueRect = function() {
      return this.spectrumHueRect = this.spectrumHue.getBoundingClientRect();
    }, e.prototype.refreshAlphaRect = function() {
      return this.spectrumAlphaRect = this.spectrumAlpha.getBoundingClientRect();
    }, e.prototype.onSpectrumDraggerDown = function(t) {
      this.refreshSpectrumRect(), this.isSpectrumDragging = !0, this.moveDragger(t);
    }, e.prototype.onSpectrumDraggerMove = function(t) {
      this.isSpectrumDragging && this.moveDragger(t);
    }, e.prototype.onSpectrumHueDown = function(t) {
      this.refreshHueRect(), this.isSpectrumHueDragging = !0, this.moveHueSlider(t);
    }, e.prototype.onSpectrumHueMove = function(t) {
      this.isSpectrumHueDragging && this.moveHueSlider(t);
    }, e.prototype.onSpectrumAlphaDown = function(t) {
      this.refreshAlphaRect(), this.isSpectrumAlphaDragging = !0, this.moveAlphaSlider(t);
    }, e.prototype.onSpectrumAlphaMove = function(t) {
      this.isSpectrumAlphaDragging && this.moveAlphaSlider(t);
    }, e.prototype.onMouseUp = function() {
      this.isSpectrumDragging = !1, this.isSpectrumHueDragging = !1, this.isSpectrumAlphaDragging = !1;
    }, e.prototype.moveDragger = function(t) {
      var i = this.spectrumValRect;
      if (i) {
        var r = t.clientX - i.left, o = t.clientY - i.top;
        r = Math.max(r, 0), r = Math.min(r, i.width), o = Math.max(o, 0), o = Math.min(o, i.height), this.setSpectrumValue(r / i.width, 1 - o / i.height);
      }
    }, e.prototype.moveHueSlider = function(t) {
      var i = this.spectrumHueRect;
      if (i) {
        var r = this.spectrumHueSlider, o = r.getBoundingClientRect(), s = t.clientX - i.left;
        s = Math.max(s, 0), s = Math.min(s, i.width), this.H = 1 - s / i.width, r.style.left = s + o.width / 2 + "px", this.update();
      }
    }, e.prototype.moveAlphaSlider = function(t) {
      var i = this.spectrumAlphaRect;
      if (i) {
        var r = this.spectrumAlphaSlider, o = r.getBoundingClientRect(), s = t.clientX - i.left;
        s = Math.max(s, 0), s = Math.min(s, i.width), this.A = s / i.width, r.style.left = s + o.width / 2 + "px", this.update();
      }
    }, e.prototype.update = function() {
      var t = If.fromHSB(this.H * 360, this.S, this.B, this.A), i = If.fromHSB(this.H * 360, 1, 1), r = t.toRgbaString(), o = this.picker, s = If.fromString(o.getValue());
      s.toRgbaString() !== r && (this.colorChanged = !0), o.setValue(r), this.spectrumColor.style.backgroundColor = i.toRgbaString(), this.spectrumDragger.style.backgroundColor = r;
    }, e.prototype.setSpectrumValue = function(t, i) {
      var r = this.spectrumValRect || this.refreshSpectrumRect();
      if (r) {
        var o = this.spectrumDragger, s = o.getBoundingClientRect();
        t = Math.max(0, t), t = Math.min(1, t), i = Math.max(0, i), i = Math.min(1, i), this.S = t, this.B = i, o.style.left = t * r.width - s.width / 2 + "px", o.style.top = (1 - i) * r.height - s.height / 2 + "px", this.update();
      }
    }, e.prototype.initRecentColors = function() {
      var t = e.recentColors, i = t.map(function(r, o) {
        return '<div class="ag-recent-color" id=' + o + ' style="background-color: ' + r + '; width: 15px; height: 15px;" recent-color="' + r + '"></div>';
      });
      this.recentColors.innerHTML = i.join("");
    }, e.prototype.setValue = function(t) {
      var i = If.fromString(t), r = xZ(i.toHSB(), 3), o = r[0], s = r[1], a = r[2];
      this.H = (isNaN(o) ? 0 : o) / 360, this.A = i.a;
      var l = this.spectrumHueRect || this.refreshHueRect(), u = this.spectrumAlphaRect || this.refreshAlphaRect();
      this.spectrumHueSlider.style.left = (this.H - 1) * -l.width + "px", this.spectrumAlphaSlider.style.left = this.A * u.width + "px", this.setSpectrumValue(s, a);
    }, e.prototype.onRecentColorClick = function(t) {
      var i = t.target;
      if (de(i.id)) {
        var r = parseInt(i.id, 10);
        this.setValue(e.recentColors[r]), this.destroy();
      }
    }, e.prototype.addRecentColor = function() {
      var t = If.fromHSB(this.H * 360, this.S, this.B, this.A), i = t.toRgbaString(), r = e.recentColors;
      !this.colorChanged || r[0] === i || (r = r.filter(function(o) {
        return o != i;
      }), r = [i].concat(r), r.length > e.maxRecentColors && (r = r.slice(0, e.maxRecentColors)), e.recentColors = r);
    }, e.prototype.destroy = function() {
      this.addRecentColor(), n.prototype.destroy.call(this);
    }, e.maxRecentColors = 8, e.recentColors = [], e.TEMPLATE = `<div class="ag-color-panel">
            <div ref="spectrumColor" class="ag-spectrum-color">
                <div class="ag-spectrum-sat ag-spectrum-fill">
                    <div ref="spectrumVal" class="ag-spectrum-val ag-spectrum-fill">
                        <div ref="spectrumDragger" class="ag-spectrum-dragger"></div>
                    </div>
                </div>
            </div>
            <div class="ag-spectrum-tools">
                <div ref="spectrumHue" class="ag-spectrum-hue ag-spectrum-tool">
                    <div class="ag-spectrum-hue-background"></div>
                    <div ref="spectrumHueSlider" class="ag-spectrum-slider"></div>
                </div>
                <div ref="spectrumAlpha" class="ag-spectrum-alpha ag-spectrum-tool">
                    <div class="ag-spectrum-alpha-background"></div>
                    <div ref="spectrumAlphaSlider" class="ag-spectrum-slider"></div>
                </div>
                <div ref="recentColors" class="ag-recent-colors"></div>
            </div>
        </div>`, fu([
      fe("spectrumColor")
    ], e.prototype, "spectrumColor", void 0), fu([
      fe("spectrumVal")
    ], e.prototype, "spectrumVal", void 0), fu([
      fe("spectrumDragger")
    ], e.prototype, "spectrumDragger", void 0), fu([
      fe("spectrumHue")
    ], e.prototype, "spectrumHue", void 0), fu([
      fe("spectrumHueSlider")
    ], e.prototype, "spectrumHueSlider", void 0), fu([
      fe("spectrumAlpha")
    ], e.prototype, "spectrumAlpha", void 0), fu([
      fe("spectrumAlphaSlider")
    ], e.prototype, "spectrumAlphaSlider", void 0), fu([
      fe("recentColors")
    ], e.prototype, "recentColors", void 0), fu([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var IZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), l4 = (
  /** @class */
  function(n) {
    IZ(e, n);
    function e(t) {
      var i = n.call(this, t, "ag-color-picker", "colorPicker") || this;
      return t && t.color && (i.value = t.color), i;
    }
    return e.prototype.postConstruct = function() {
      n.prototype.postConstruct.call(this), this.value && this.setValue(this.value);
    }, e.prototype.showPicker = function() {
      var t = this, i = this.getGui().getBoundingClientRect(), r = this.createBean(new Dx({
        closable: !1,
        modal: !0,
        hideTitleBar: !0,
        minWidth: 190,
        width: 190,
        height: 250,
        x: i.right - 190,
        y: i.top - 250
      }));
      this.isPickerDisplayed = !0, r.addCssClass("ag-color-dialog"), _s(this.eWrapper, !0);
      var o = this.createBean(new NZ({ picker: this }));
      return o.addDestroyFunc(function() {
        r.isAlive() && t.destroyBean(r);
      }), r.setParentComponent(this), r.setBodyComponent(o), o.setValue(this.getValue()), r.addDestroyFunc(function() {
        t.isDestroyingPicker ? t.isDestroyingPicker = !1 : (t.isDestroyingPicker = !0, o.isAlive() && t.destroyBean(o)), t.isAlive() && (_s(t.eWrapper, !1), t.getFocusableElement().focus()), t.isPickerDisplayed = !1;
      }), r;
    }, e.prototype.setValue = function(t) {
      return this.value === t ? this : (this.eDisplayField.style.backgroundColor = t, n.prototype.setValue.call(this, t));
    }, e.prototype.getValue = function() {
      return this.value;
    }, e;
  }(jB)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var PZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), u4 = (
  /** @class */
  function(n) {
    PZ(e, n);
    function e(t) {
      return n.call(this, t, "ag-number-field", "number") || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      n.prototype.postConstruct.call(this), this.addManagedListener(this.eInput, "blur", function() {
        var i = parseFloat(t.eInput.value), r = isNaN(i) ? "" : t.normalizeValue(i.toString());
        t.value !== r && t.setValue(r);
      }), this.eInput.step = "any";
    }, e.prototype.normalizeValue = function(t) {
      if (t === "")
        return "";
      this.precision && (t = this.adjustPrecision(t));
      var i = parseFloat(t);
      return this.min != null && i < this.min ? t = this.min.toString() : this.max != null && i > this.max && (t = this.max.toString()), t;
    }, e.prototype.adjustPrecision = function(t) {
      if (this.precision) {
        var i = parseFloat(t).toFixed(this.precision);
        t = parseFloat(i).toString();
      }
      return t;
    }, e.prototype.setMin = function(t) {
      return this.min === t ? this : (this.min = t, ev(this.eInput, "min", t), this);
    }, e.prototype.setMax = function(t) {
      return this.max === t ? this : (this.max = t, ev(this.eInput, "max", t), this);
    }, e.prototype.setPrecision = function(t) {
      return this.precision = t, this;
    }, e.prototype.setStep = function(t) {
      return this.step === t ? this : (this.step = t, ev(this.eInput, "step", t), this);
    }, e.prototype.setValue = function(t, i) {
      t = this.adjustPrecision(t);
      var r = this.normalizeValue(t);
      return t != r ? this : n.prototype.setValue.call(this, t, i);
    }, e;
  }(Rx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var AZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), c4 = (
  /** @class */
  function(n) {
    AZ(e, n);
    function e(t) {
      return n.call(this, t, "ag-range-field", "range") || this;
    }
    return e.prototype.postConstruct = function() {
      n.prototype.postConstruct.call(this);
      var t = this.config, i = t.min, r = t.max, o = t.step;
      i != null && this.setMinValue(i), r != null && this.setMaxValue(r), this.setStep(o || 1);
    }, e.prototype.addInputListeners = function() {
      var t = this;
      this.addManagedListener(this.eInput, "input", function(i) {
        var r = i.target.value;
        t.setValue(r);
      });
    }, e.prototype.setMinValue = function(t) {
      return this.min = t, this.eInput.setAttribute("min", t.toString()), this;
    }, e.prototype.setMaxValue = function(t) {
      return this.max = t, this.eInput.setAttribute("max", t.toString()), this;
    }, e.prototype.setStep = function(t) {
      return this.eInput.setAttribute("step", t.toString()), this;
    }, e.prototype.setValue = function(t, i) {
      this.min != null && (t = Math.max(parseFloat(t), this.min).toString()), this.max != null && (t = Math.min(parseFloat(t), this.max).toString());
      var r = n.prototype.setValue.call(this, t, i);
      return this.eInput.value = t, r;
    }, e;
  }(Pu)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var MZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _m = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, h4 = (
  /** @class */
  function(n) {
    MZ(e, n);
    function e(t) {
      var i = n.call(this, t, e.TEMPLATE) || this;
      return i.radius = 0, i.offsetX = 0, i.offsetY = 0, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      n.prototype.postConstruct.call(this), this.dragListener = {
        eElement: this.eParentCircle,
        dragStartPixels: 0,
        onDragStart: function(i) {
          t.parentCircleRect = t.eParentCircle.getBoundingClientRect();
        },
        onDragging: function(i) {
          return t.calculateAngleDrag(i);
        },
        onDragStop: function() {
        }
      }, this.dragService.addDragSource(this.dragListener), this.eAngleValue.setLabel("").setLabelWidth(5).setInputWidth(45).setMin(0).setMax(360).setValue("" + this.degrees).onValueChange(function(i) {
        (i == null || i === "") && (i = "0"), i = t.eAngleValue.normalizeValue(i);
        var r = parseFloat(i);
        r > 180 && (r = r - 360), t.setValue(r);
      }), this.updateNumberInput(), de(this.getValue()) && this.eAngleValue.setValue(this.normalizeNegativeValue(this.getValue()).toString()), this.addManagedListener(this, Fl.EVENT_CHANGED, function() {
        var i = t.gridOptionsWrapper.getDocument();
        t.eAngleValue.getInputElement().contains(i.activeElement) || t.updateNumberInput();
      });
    }, e.prototype.updateNumberInput = function() {
      var t = this.normalizeNegativeValue(this.getValue());
      this.eAngleValue.setValue(t.toString());
    }, e.prototype.positionChildCircle = function(t) {
      var i = this.parentCircleRect || { width: 24, height: 24 }, r = this.eChildCircle, o = i.width / 2, s = i.height / 2;
      r.style.left = o + Math.cos(t) * 8 + "px", r.style.top = s + Math.sin(t) * 8 + "px";
    }, e.prototype.calculatePolar = function() {
      var t = this.offsetX, i = this.offsetY, r = Math.atan2(i, t);
      this.degrees = this.toDegrees(r), this.radius = Math.sqrt(t * t + i * i), this.positionChildCircle(r);
    }, e.prototype.calculateCartesian = function() {
      var t = this.toRadians(this.getValue()), i = this.getRadius();
      this.setOffsetX(Math.cos(t) * i).setOffsetY(Math.sin(t) * i);
    }, e.prototype.setOffsetX = function(t) {
      return this.offsetX !== t && (this.offsetX = t, this.calculatePolar()), this;
    }, e.prototype.setOffsetY = function(t) {
      return this.offsetY !== t && (this.offsetY = t, this.calculatePolar()), this;
    }, e.prototype.calculateAngleDrag = function(t) {
      var i = this.parentCircleRect, r = i.width / 2, o = i.height / 2, s = t.clientX - i.left, a = t.clientY - i.top, l = s - r, u = a - o, c = Math.atan2(u, l);
      this.setValue(c, !0);
    }, e.prototype.toDegrees = function(t) {
      return t / Math.PI * 180;
    }, e.prototype.toRadians = function(t) {
      return t / 180 * Math.PI;
    }, e.prototype.normalizeNegativeValue = function(t) {
      return t < 0 ? 360 + t : t;
    }, e.prototype.normalizeAngle180 = function(t) {
      return t %= Math.PI * 2, t < -Math.PI ? t += Math.PI * 2 : t >= Math.PI && (t -= Math.PI * 2), t;
    }, e.prototype.getRadius = function() {
      return this.radius;
    }, e.prototype.setRadius = function(t) {
      return this.radius === t ? this : (this.radius = t, this.calculateCartesian(), this);
    }, e.prototype.onValueChange = function(t) {
      var i = this;
      return this.addManagedListener(this, Fl.EVENT_CHANGED, function() {
        t(i.degrees);
      }), this;
    }, e.prototype.getValue = function(t) {
      return t ? this.toRadians(this.degrees) : this.degrees;
    }, e.prototype.setValue = function(t, i) {
      var r;
      return i ? r = t : r = this.normalizeAngle180(this.toRadians(t)), t = this.toDegrees(r), this.degrees !== t && (this.degrees = Math.floor(t), this.calculateCartesian(), this.positionChildCircle(r), this.dispatchEvent({ type: Fl.EVENT_CHANGED })), this;
    }, e.prototype.setWidth = function(t) {
      return Ul(this.getGui(), t), this;
    }, e.prototype.destroy = function() {
      this.dragService.removeDragSource(this.dragListener), n.prototype.destroy.call(this);
    }, e.TEMPLATE = `<div class="ag-angle-select">
            <div ref="eLabel"></div>
            <div class="ag-wrapper ag-angle-select-wrapper">
                <div ref="eAngleSelectField" class="ag-angle-select-field">
                    <div ref="eParentCircle" class="ag-angle-select-parent-circle">
                        <div ref="eChildCircle" class="ag-angle-select-child-circle"></div>
                    </div>
                </div>
                <ag-input-number-field ref="eAngleValue"></ag-input-number-field>
            </div>
        </div>`, _m([
      fe("eLabel")
    ], e.prototype, "eLabel", void 0), _m([
      fe("eParentCircle")
    ], e.prototype, "eParentCircle", void 0), _m([
      fe("eChildCircle")
    ], e.prototype, "eChildCircle", void 0), _m([
      fe("eAngleValue")
    ], e.prototype, "eAngleValue", void 0), _m([
      R("dragService")
    ], e.prototype, "dragService", void 0), e;
  }(hx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var FZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), d4 = (
  /** @class */
  function(n) {
    FZ(e, n);
    function e(t) {
      return n.call(this, t, "ag-toggle-button") || this;
    }
    return e.prototype.setValue = function(t, i) {
      return n.prototype.setValue.call(this, t, i), this.addOrRemoveCssClass("ag-selected", this.getValue()), this;
    }, e;
  }(kp)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var kZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), UC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, f4 = (
  /** @class */
  function(n) {
    kZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getFirstRow = function() {
      var t = 0, i;
      return this.pinnedRowModel.getPinnedTopRowCount() ? i = q.PINNED_TOP : this.rowModel.getRowCount() ? (i = null, t = this.paginationProxy.getPageFirstRow()) : this.pinnedRowModel.getPinnedBottomRowCount() && (i = q.PINNED_BOTTOM), i === void 0 ? null : { rowIndex: t, rowPinned: i };
    }, e.prototype.getLastRow = function() {
      var t, i = null, r = this.pinnedRowModel.getPinnedBottomRowCount(), o = this.pinnedRowModel.getPinnedTopRowCount();
      return r ? (i = q.PINNED_BOTTOM, t = r - 1) : this.rowModel.getRowCount() ? (i = null, t = this.paginationProxy.getPageLastRow()) : o && (i = q.PINNED_TOP, t = o - 1), t === void 0 ? null : { rowIndex: t, rowPinned: i };
    }, e.prototype.getRowNode = function(t) {
      switch (t.rowPinned) {
        case q.PINNED_TOP:
          return this.pinnedRowModel.getPinnedTopRowData()[t.rowIndex];
        case q.PINNED_BOTTOM:
          return this.pinnedRowModel.getPinnedBottomRowData()[t.rowIndex];
        default:
          return this.rowModel.getRow(t.rowIndex);
      }
    }, e.prototype.sameRow = function(t, i) {
      return !t && !i ? !0 : t && !i || !t && i ? !1 : t.rowIndex === i.rowIndex && t.rowPinned == i.rowPinned;
    }, e.prototype.before = function(t, i) {
      switch (t.rowPinned) {
        case q.PINNED_TOP:
          if (i.rowPinned !== q.PINNED_TOP)
            return !0;
          break;
        case q.PINNED_BOTTOM:
          if (i.rowPinned !== q.PINNED_BOTTOM)
            return !1;
          break;
        default:
          if (de(i.rowPinned))
            return i.rowPinned !== q.PINNED_TOP;
          break;
      }
      return t.rowIndex < i.rowIndex;
    }, UC([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), UC([
      R("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), UC([
      R("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), e = UC([
      Ke("rowPositionUtils")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var WZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), VZ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, p4 = (
  /** @class */
  function(n) {
    WZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.createId = function(t) {
      var i = t.rowIndex, r = t.rowPinned, o = t.column;
      return this.createIdFromValues(i, o, r);
    }, e.prototype.createIdFromValues = function(t, i, r) {
      return t + "." + (r ?? "null") + "." + i.getId();
    }, e.prototype.equals = function(t, i) {
      var r = t.column === i.column, o = t.rowPinned === i.rowPinned, s = t.rowIndex === i.rowIndex;
      return r && o && s;
    }, e = VZ([
      Ke("cellPositionUtils")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var BZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Cm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, g4 = (
  /** @class */
  function(n) {
    BZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      this.setPinnedTopRowData(this.gridOptionsWrapper.getPinnedTopRowData()), this.setPinnedBottomRowData(this.gridOptionsWrapper.getPinnedBottomRowData());
    }, e.prototype.isEmpty = function(t) {
      var i = t === q.PINNED_TOP ? this.pinnedTopRows : this.pinnedBottomRows;
      return ds(i);
    }, e.prototype.isRowsToRender = function(t) {
      return !this.isEmpty(t);
    }, e.prototype.getRowAtPixel = function(t, i) {
      var r = i === q.PINNED_TOP ? this.pinnedTopRows : this.pinnedBottomRows;
      if (ds(r))
        return 0;
      for (var o = 0; o < r.length; o++) {
        var s = r[o], a = s.rowTop + s.rowHeight - 1;
        if (a >= t)
          return o;
      }
      return r.length - 1;
    }, e.prototype.setPinnedTopRowData = function(t) {
      this.pinnedTopRows = this.createNodesFromData(t, !0);
      var i = {
        type: I.EVENT_PINNED_ROW_DATA_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.setPinnedBottomRowData = function(t) {
      this.pinnedBottomRows = this.createNodesFromData(t, !1);
      var i = {
        type: I.EVENT_PINNED_ROW_DATA_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.createNodesFromData = function(t, i) {
      var r = this, o = [];
      if (t) {
        var s = 0;
        t.forEach(function(a, l) {
          var u = new kt(r.beans);
          u.data = a;
          var c = i ? kt.ID_PREFIX_TOP_PINNED : kt.ID_PREFIX_BOTTOM_PINNED;
          u.id = c + l, u.rowPinned = i ? q.PINNED_TOP : q.PINNED_BOTTOM, u.setRowTop(s), u.setRowHeight(r.gridOptionsWrapper.getRowHeightForNode(u).height), u.setRowIndex(l), s += u.rowHeight, o.push(u);
        });
      }
      return o;
    }, e.prototype.getPinnedTopRowData = function() {
      return this.pinnedTopRows;
    }, e.prototype.getPinnedBottomRowData = function() {
      return this.pinnedBottomRows;
    }, e.prototype.getPinnedTopTotalHeight = function() {
      return this.getTotalHeight(this.pinnedTopRows);
    }, e.prototype.getPinnedTopRowCount = function() {
      return this.pinnedTopRows ? this.pinnedTopRows.length : 0;
    }, e.prototype.getPinnedBottomRowCount = function() {
      return this.pinnedBottomRows ? this.pinnedBottomRows.length : 0;
    }, e.prototype.getPinnedTopRow = function(t) {
      return this.pinnedTopRows[t];
    }, e.prototype.getPinnedBottomRow = function(t) {
      return this.pinnedBottomRows[t];
    }, e.prototype.forEachPinnedTopRow = function(t) {
      ds(this.pinnedTopRows) || this.pinnedTopRows.forEach(t);
    }, e.prototype.forEachPinnedBottomRow = function(t) {
      ds(this.pinnedBottomRows) || this.pinnedBottomRows.forEach(t);
    }, e.prototype.getPinnedBottomTotalHeight = function() {
      return this.getTotalHeight(this.pinnedBottomRows);
    }, e.prototype.getTotalHeight = function(t) {
      if (!t || t.length === 0)
        return 0;
      var i = Di(t);
      return i.rowTop + i.rowHeight;
    }, Cm([
      R("columnApi")
    ], e.prototype, "columnApi", void 0), Cm([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), Cm([
      R("beans")
    ], e.prototype, "beans", void 0), Cm([
      Ee
    ], e.prototype, "init", null), e = Cm([
      Ke("pinnedRowModel")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var HZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Ky = (
  /** @class */
  function() {
    function n(e) {
      this.cellValueChanges = e;
    }
    return n;
  }()
), DL = (
  /** @class */
  function(n) {
    HZ(e, n);
    function e(t, i, r) {
      var o = n.call(this, t) || this;
      return o.initialRange = i, o.finalRange = r, o;
    }
    return e;
  }(Ky)
), VM = (
  /** @class */
  function() {
    function n(e) {
      this.actionStack = [], this.maxStackSize = e || n.DEFAULT_STACK_SIZE, this.actionStack = new Array(this.maxStackSize);
    }
    return n.prototype.pop = function() {
      return this.actionStack.pop();
    }, n.prototype.push = function(e) {
      var t = e.cellValueChanges && e.cellValueChanges.length > 0;
      t && (this.actionStack.length === this.maxStackSize && this.actionStack.shift(), this.actionStack.push(e));
    }, n.prototype.clear = function() {
      this.actionStack = [];
    }, n.prototype.getCurrentStackSize = function() {
      return this.actionStack.length;
    }, n.DEFAULT_STACK_SIZE = 10, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var GZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _c = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, UZ = (
  /** @class */
  function(n) {
    GZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.cellValueChanges = [], t.activeCellEdit = null, t.activeRowEdit = null, t.isPasting = !1, t.isFilling = !1, t.onCellValueChanged = function(i) {
        var r = { column: i.column, rowIndex: i.rowIndex, rowPinned: i.rowPinned }, o = t.activeCellEdit !== null && t.cellPositionUtils.equals(t.activeCellEdit, r), s = t.activeRowEdit !== null && t.rowPositionUtils.sameRow(t.activeRowEdit, r), a = o || s || t.isPasting || t.isFilling;
        if (a) {
          var l = i.rowPinned, u = i.rowIndex, c = i.column, h = i.oldValue, d = i.value, f = {
            rowPinned: l,
            rowIndex: u,
            columnId: c.getColId(),
            newValue: d,
            oldValue: h
          };
          t.cellValueChanges.push(f);
        }
      }, t.clearStacks = function() {
        t.undoStack.clear(), t.redoStack.clear();
      }, t;
    }
    return e.prototype.init = function() {
      if (this.gridOptionsWrapper.isUndoRedoCellEditing()) {
        var t = this.gridOptionsWrapper.getUndoRedoCellEditingLimit();
        t <= 0 || (this.undoStack = new VM(t), this.redoStack = new VM(t), this.addRowEditingListeners(), this.addCellEditingListeners(), this.addPasteListeners(), this.addFillListeners(), this.addManagedListener(this.eventService, I.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged), this.addManagedListener(this.eventService, I.EVENT_MODEL_UPDATED, this.clearStacks), this.addManagedListener(this.eventService, I.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.clearStacks), this.addManagedListener(this.eventService, I.EVENT_NEW_COLUMNS_LOADED, this.clearStacks), this.addManagedListener(this.eventService, I.EVENT_COLUMN_GROUP_OPENED, this.clearStacks), this.addManagedListener(this.eventService, I.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearStacks), this.addManagedListener(this.eventService, I.EVENT_COLUMN_MOVED, this.clearStacks), this.addManagedListener(this.eventService, I.EVENT_COLUMN_PINNED, this.clearStacks), this.addManagedListener(this.eventService, I.EVENT_COLUMN_VISIBLE, this.clearStacks), this.addManagedListener(this.eventService, I.EVENT_ROW_DRAG_END, this.clearStacks));
      }
    }, e.prototype.getCurrentUndoStackSize = function() {
      return this.undoStack ? this.undoStack.getCurrentStackSize() : 0;
    }, e.prototype.getCurrentRedoStackSize = function() {
      return this.redoStack ? this.redoStack.getCurrentStackSize() : 0;
    }, e.prototype.undo = function() {
      if (this.undoStack) {
        var t = this.undoStack.pop();
        !t || !t.cellValueChanges || (this.processAction(t, function(i) {
          return i.oldValue;
        }), t instanceof DL ? this.processRangeAndCellFocus(t.cellValueChanges, t.initialRange) : this.processRangeAndCellFocus(t.cellValueChanges), this.redoStack.push(t));
      }
    }, e.prototype.redo = function() {
      if (this.redoStack) {
        var t = this.redoStack.pop();
        !t || !t.cellValueChanges || (this.processAction(t, function(i) {
          return i.newValue;
        }), t instanceof DL ? this.processRangeAndCellFocus(t.cellValueChanges, t.finalRange) : this.processRangeAndCellFocus(t.cellValueChanges), this.undoStack.push(t));
      }
    }, e.prototype.processAction = function(t, i) {
      var r = this;
      t.cellValueChanges.forEach(function(o) {
        var s = o.rowIndex, a = o.rowPinned, l = o.columnId, u = { rowIndex: s, rowPinned: a }, c = r.getRowNode(u);
        c.displayed && c.setDataValue(l, i(o));
      });
    }, e.prototype.processRangeAndCellFocus = function(t, i) {
      var r;
      if (i) {
        var o = i.startRow, s = i.endRow;
        r = {
          rowPinned: o.rowPinned,
          rowIndex: o.rowIndex,
          columnId: i.startColumn.getColId()
        }, this.setLastFocusedCell(r);
        var a = {
          rowStartIndex: o.rowIndex,
          rowStartPinned: o.rowPinned,
          rowEndIndex: s.rowIndex,
          rowEndPinned: s.rowPinned,
          columnStart: i.startColumn,
          columns: i.columns
        };
        this.gridApi.addCellRange(a);
        return;
      }
      var l = t[0], u = l.rowIndex, c = l.rowPinned, h = { rowIndex: u, rowPinned: c }, d = this.getRowNode(h);
      r = {
        rowPinned: l.rowPinned,
        rowIndex: d.rowIndex,
        columnId: l.columnId
      }, this.setLastFocusedCell(r);
    }, e.prototype.setLastFocusedCell = function(t) {
      var i = t.rowIndex, r = t.columnId, o = t.rowPinned;
      this.gridApi.ensureIndexVisible(i), this.gridApi.ensureColumnVisible(r), pt.isRegistered(ct.RangeSelectionModule) && this.gridApi.clearRangeSelection(), this.focusService.setFocusedCell(i, r, o, !0);
    }, e.prototype.addRowEditingListeners = function() {
      var t = this;
      this.addManagedListener(this.eventService, I.EVENT_ROW_EDITING_STARTED, function(i) {
        t.activeRowEdit = { rowIndex: i.rowIndex, rowPinned: i.rowPinned };
      }), this.addManagedListener(this.eventService, I.EVENT_ROW_EDITING_STOPPED, function() {
        var i = new Ky(t.cellValueChanges);
        t.pushActionsToUndoStack(i), t.activeRowEdit = null;
      });
    }, e.prototype.addCellEditingListeners = function() {
      var t = this;
      this.addManagedListener(this.eventService, I.EVENT_CELL_EDITING_STARTED, function(i) {
        t.activeCellEdit = { column: i.column, rowIndex: i.rowIndex, rowPinned: i.rowPinned };
      }), this.addManagedListener(this.eventService, I.EVENT_CELL_EDITING_STOPPED, function() {
        t.activeCellEdit = null;
        var i = !t.activeRowEdit && !t.isPasting && !t.isFilling;
        if (i) {
          var r = new Ky(t.cellValueChanges);
          t.pushActionsToUndoStack(r);
        }
      });
    }, e.prototype.addPasteListeners = function() {
      var t = this;
      this.addManagedListener(this.eventService, I.EVENT_PASTE_START, function() {
        t.isPasting = !0;
      }), this.addManagedListener(this.eventService, I.EVENT_PASTE_END, function() {
        var i = new Ky(t.cellValueChanges);
        t.pushActionsToUndoStack(i), t.isPasting = !1;
      });
    }, e.prototype.addFillListeners = function() {
      var t = this;
      this.addManagedListener(this.eventService, I.EVENT_FILL_START, function() {
        t.isFilling = !0;
      }), this.addManagedListener(this.eventService, I.EVENT_FILL_END, function(i) {
        var r = new DL(t.cellValueChanges, i.initialRange, i.finalRange);
        t.pushActionsToUndoStack(r), t.isFilling = !1;
      });
    }, e.prototype.pushActionsToUndoStack = function(t) {
      this.undoStack.push(t), this.cellValueChanges = [], this.redoStack.clear();
    }, e.prototype.getRowNode = function(t) {
      switch (t.rowPinned) {
        case q.PINNED_TOP:
          return this.pinnedRowModel.getPinnedTopRowData()[t.rowIndex];
        case q.PINNED_BOTTOM:
          return this.pinnedRowModel.getPinnedBottomRowData()[t.rowIndex];
        default:
          return this.rowModel.getRow(t.rowIndex);
      }
    }, _c([
      R("focusService")
    ], e.prototype, "focusService", void 0), _c([
      R("gridApi")
    ], e.prototype, "gridApi", void 0), _c([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), _c([
      R("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), _c([
      R("cellPositionUtils")
    ], e.prototype, "cellPositionUtils", void 0), _c([
      R("rowPositionUtils")
    ], e.prototype, "rowPositionUtils", void 0), _c([
      Ee
    ], e.prototype, "init", null), e = _c([
      Ke("undoRedoService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var zZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), RL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, m4 = (
  /** @class */
  function(n) {
    zZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.findHeader = function(t, i) {
      var r, o, s;
      if (t.column instanceof Yr ? (o = "getDisplayedGroup" + i, r = this.columnModel[o](t.column)) : (s = "getDisplayedCol" + i, r = this.columnModel[s](t.column)), r)
        return {
          column: r,
          headerRowIndex: t.headerRowIndex
        };
    }, e.prototype.findColAtEdgeForHeaderRow = function(t, i) {
      var r = this.columnModel.getAllDisplayedColumns(), o = r[i === "start" ? 0 : r.length - 1];
      if (o) {
        var s = this.ctrlsService.getHeaderRowContainerCtrl(o.getPinned()), a = s.getRowType(t);
        if (a == Xr.COLUMN_GROUP) {
          var l = this.columnModel.getColumnGroupAtLevel(o, t);
          return {
            headerRowIndex: t,
            column: l
          };
        }
        return {
          // if type==null, means the header level didn't exist
          headerRowIndex: a == null ? -1 : t,
          column: o
        };
      }
    }, RL([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), RL([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), e = RL([
      Ke("headerPositionUtils")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var jZ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, $Z = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.buildColumnDefs = function(e, t, i) {
      var r = this, o = [], s = {};
      return e.forEach(function(a) {
        for (var l = r.createDefFromColumn(a, t, i), u = !0, c = l, h = a.getOriginalParent(); h; ) {
          var d = null;
          if (h.isPadding()) {
            h = h.getOriginalParent();
            continue;
          }
          var f = s[h.getGroupId()];
          if (f) {
            f.children.push(c), u = !1;
            break;
          }
          d = r.createDefFromGroup(h), d && (d.children = [c], s[d.groupId] = d, c = d, h = h.getOriginalParent());
        }
        u && o.push(c);
      }), o;
    }, n.prototype.createDefFromGroup = function(e) {
      var t = Ow(e.getColGroupDef(), ["children"]);
      return t && (t.groupId = e.getGroupId()), t;
    }, n.prototype.createDefFromColumn = function(e, t, i) {
      var r = Ow(e.getColDef());
      return r.colId = e.getColId(), r.width = e.getActualWidth(), r.rowGroup = e.isRowGroupActive(), r.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null, r.pivot = e.isPivotActive(), r.pivotIndex = e.isPivotActive() ? i.indexOf(e) : null, r.aggFunc = e.isValueActive() ? e.getAggFunc() : null, r.hide = e.isVisible() ? void 0 : !0, r.pinned = e.isPinned() ? e.getPinned() : null, r.sort = e.getSort() ? e.getSort() : null, r.sortIndex = e.getSortIndex() != null ? e.getSortIndex() : null, r;
    }, n = jZ([
      Ke("columnDefFactory")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var TL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, KZ = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getInitialRowClasses = function(e) {
      var t = [];
      return de(e.extraCssClass) && t.push(e.extraCssClass), t.push("ag-row"), t.push(e.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), e.fadeRowIn && t.push("ag-opacity-zero"), t.push(e.rowIsEven ? "ag-row-even" : "ag-row-odd"), e.rowNode.isRowPinned() && t.push("ag-row-pinned"), e.rowNode.isSelected() && t.push("ag-row-selected"), e.rowNode.footer && t.push("ag-row-footer"), t.push("ag-row-level-" + e.rowLevel), e.rowNode.stub && t.push("ag-row-loading"), e.fullWidthRow && t.push("ag-full-width-row"), e.expandable && (t.push("ag-row-group"), t.push(e.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted")), e.rowNode.dragging && t.push("ag-row-dragging"), w1(t, this.processClassesFromGridOptions(e.rowNode, e.scope)), w1(t, this.preProcessRowClassRules(e.rowNode, e.scope)), t.push(e.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), e.firstRowOnPage && t.push("ag-row-first"), e.lastRowOnPage && t.push("ag-row-last"), e.fullWidthRow && (e.pinned === q.PINNED_LEFT && t.push("ag-cell-last-left-pinned"), e.pinned === q.PINNED_RIGHT && t.push("ag-cell-first-right-pinned")), t;
    }, n.prototype.processClassesFromGridOptions = function(e, t) {
      var i = [], r = function(u) {
        typeof u == "string" ? i.push(u) : Array.isArray(u) && u.forEach(function(c) {
          return i.push(c);
        });
      }, o = this.gridOptionsWrapper.getRowClass();
      if (o) {
        if (typeof o == "function")
          return console.warn("AG Grid: rowClass should not be a function, please use getRowClass instead"), [];
        r(o);
      }
      var s = this.gridOptionsWrapper.getRowClassFunc();
      if (s) {
        var a = {
          data: e.data,
          node: e,
          rowIndex: e.rowIndex,
          $scope: t,
          api: this.gridOptionsWrapper.getApi(),
          columnApi: this.gridOptionsWrapper.getColumnApi(),
          context: this.gridOptionsWrapper.getContext()
        }, l = s(a);
        r(l);
      }
      return i;
    }, n.prototype.preProcessRowClassRules = function(e, t) {
      var i = [];
      return this.processRowClassRules(e, t, function(r) {
        i.push(r);
      }, function(r) {
      }), i;
    }, n.prototype.processRowClassRules = function(e, t, i, r) {
      var o = {
        data: e.data,
        node: e,
        rowIndex: e.rowIndex,
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        $scope: t,
        context: this.gridOptionsWrapper.getContext()
      };
      this.stylingService.processClassRules(this.gridOptionsWrapper.rowClassRules(), o, i, r);
    }, n.prototype.calculateRowLevel = function(e) {
      return e.group ? e.level : e.parent ? e.parent.level + 1 : 0;
    }, TL([
      R("stylingService")
    ], n.prototype, "stylingService", void 0), TL([
      R("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), n = TL([
      Ke("rowCssClassCalculator")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var qZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), B1 = (
  /** @class */
  function(n) {
    qZ(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.state = e.STATE_WAITING_TO_LOAD, i.version = 0, i.id = t, i;
    }
    return e.prototype.getId = function() {
      return this.id;
    }, e.prototype.load = function() {
      this.state = e.STATE_LOADING, this.loadFromDatasource();
    }, e.prototype.getVersion = function() {
      return this.version;
    }, e.prototype.setStateWaitingToLoad = function() {
      this.version++, this.state = e.STATE_WAITING_TO_LOAD;
    }, e.prototype.getState = function() {
      return this.state;
    }, e.prototype.pageLoadFailed = function(t) {
      var i = this.isRequestMostRecentAndLive(t);
      i && (this.state = e.STATE_FAILED, this.processServerFail()), this.dispatchLoadCompleted(!1);
    }, e.prototype.success = function(t, i) {
      this.successCommon(t, i);
    }, e.prototype.pageLoaded = function(t, i, r) {
      this.successCommon(t, { rowData: i, rowCount: r });
    }, e.prototype.isRequestMostRecentAndLive = function(t) {
      var i = t === this.version, r = this.isAlive();
      return i && r;
    }, e.prototype.successCommon = function(t, i) {
      this.dispatchLoadCompleted();
      var r = this.isRequestMostRecentAndLive(t);
      r && (this.state = e.STATE_LOADED, this.processServerResult(i));
    }, e.prototype.dispatchLoadCompleted = function(t) {
      t === void 0 && (t = !0);
      var i = {
        type: e.EVENT_LOAD_COMPLETE,
        success: t,
        block: this
      };
      this.dispatchEvent(i);
    }, e.EVENT_LOAD_COMPLETE = "loadComplete", e.STATE_WAITING_TO_LOAD = "needsLoading", e.STATE_LOADING = "loading", e.STATE_LOADED = "loaded", e.STATE_FAILED = "failed", e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var YZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), OL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, XZ = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, v4 = (
  /** @class */
  function(n) {
    YZ(e, n);
    function e() {
      var i = n !== null && n.apply(this, arguments) || this;
      return i.activeBlockLoadsCount = 0, i.blocks = [], i.active = !0, i;
    }
    t = e, e.prototype.postConstruct = function() {
      this.maxConcurrentRequests = this.gridOptionsWrapper.getMaxConcurrentDatasourceRequests();
      var i = this.gridOptionsWrapper.getBlockLoadDebounceMillis();
      i && i > 0 && (this.checkBlockToLoadDebounce = Sd.debounce(this.performCheckBlocksToLoad.bind(this), i));
    }, e.prototype.setBeans = function(i) {
      this.logger = i.create("RowNodeBlockLoader");
    }, e.prototype.addBlock = function(i) {
      this.blocks.push(i), i.addEventListener(B1.EVENT_LOAD_COMPLETE, this.loadComplete.bind(this)), this.checkBlockToLoad();
    }, e.prototype.removeBlock = function(i) {
      Sd.removeFromArray(this.blocks, i);
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this), this.active = !1;
    }, e.prototype.loadComplete = function() {
      this.activeBlockLoadsCount--, this.checkBlockToLoad(), this.activeBlockLoadsCount == 0 && this.dispatchEvent({ type: t.BLOCK_LOADER_FINISHED_EVENT });
    }, e.prototype.checkBlockToLoad = function() {
      this.checkBlockToLoadDebounce ? this.checkBlockToLoadDebounce() : this.performCheckBlocksToLoad();
    }, e.prototype.performCheckBlocksToLoad = function() {
      if (this.active) {
        if (this.printCacheStatus(), this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
          this.logger.log("checkBlockToLoad: max loads exceeded");
          return;
        }
        var i = null;
        this.blocks.forEach(function(r) {
          r.getState() === B1.STATE_WAITING_TO_LOAD && (i = r);
        }), i && (i.load(), this.activeBlockLoadsCount++, this.printCacheStatus());
      }
    }, e.prototype.getBlockState = function() {
      var i = {};
      return this.blocks.forEach(function(r) {
        var o = r.getBlockStateJson(), s = o.id, a = o.state;
        i[s] = a;
      }), i;
    }, e.prototype.printCacheStatus = function() {
      this.logger.isLogging() && this.logger.log("printCacheStatus: activePageLoadsCount = " + this.activeBlockLoadsCount + "," + (" blocks = " + JSON.stringify(this.getBlockState())));
    }, e.prototype.isLoading = function() {
      return this.activeBlockLoadsCount > 0;
    };
    var t;
    return e.BLOCK_LOADER_FINISHED_EVENT = "blockLoaderFinished", OL([
      Ee
    ], e.prototype, "postConstruct", null), OL([
      XZ(0, wo("loggerFactory"))
    ], e.prototype, "setBeans", null), e = t = OL([
      Ke("rowNodeBlockLoader")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var zC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, _4 = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.doFullSort = function(e, t) {
      var i = function(o, s) {
        return { currentPos: s, rowNode: o };
      }, r = e.map(i);
      return r.sort(this.compareRowNodes.bind(this, t)), r.map(function(o) {
        return o.rowNode;
      });
    }, n.prototype.compareRowNodes = function(e, t, i) {
      for (var r = t.rowNode, o = i.rowNode, s = 0, a = e.length; s < a; s++) {
        var l = e[s], u = l.sort === q.SORT_DESC, c = this.getValue(r, l.column), h = this.getValue(o, l.column), d = void 0, f = this.getComparator(l, r);
        f ? d = f(c, h, r, o, u) : d = Sd.defaultComparator(c, h, this.gridOptionsWrapper.isAccentedSort());
        var p = !isNaN(d);
        if (p && d !== 0)
          return l.sort === q.SORT_ASC ? d : d * -1;
      }
      return t.currentPos - i.currentPos;
    }, n.prototype.getComparator = function(e, t) {
      var i = e.column, r = i.getColDef().comparator;
      if (r != null)
        return r;
      if (t.rowGroupColumn)
        return t.rowGroupColumn.getColDef().comparator;
      if (i.getColDef().showRowGroup) {
        var o = !t.group && i.getColDef().field;
        if (o) {
          var s = this.columnModel.getPrimaryColumn(o);
          if (s)
            return s.getColDef().comparator;
        }
      }
    }, n.prototype.getValue = function(e, t) {
      return this.valueService.getValue(t, e, !1, !1);
    }, zC([
      R("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), zC([
      R("valueService")
    ], n.prototype, "valueService", void 0), zC([
      R("columnModel")
    ], n.prototype, "columnModel", void 0), n = zC([
      Ke("rowNodeSorter")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var ZZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), QZ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, C4 = (
  /** @class */
  function(n) {
    ZZ(e, n);
    function e() {
      var i = n !== null && n.apply(this, arguments) || this;
      return i.ready = !1, i.readyCallbacks = [], i;
    }
    t = e, e.prototype.checkReady = function() {
      if (this.ready = this.gridCtrl != null && this.gridBodyCtrl != null && this.centerRowContainerCtrl != null && this.leftRowContainerCtrl != null && this.rightRowContainerCtrl != null && this.bottomCenterRowContainerCtrl != null && this.bottomLeftRowContainerCtrl != null && this.bottomRightRowContainerCtrl != null && this.topCenterRowContainerCtrl != null && this.topLeftRowContainerCtrl != null && this.topRightRowContainerCtrl != null && this.centerHeaderRowContainerCtrl != null && this.leftHeaderRowContainerCtrl != null && this.rightHeaderRowContainerCtrl != null && this.fakeHScrollCtrl != null && this.gridHeaderCtrl != null, this.ready) {
        var i = this.createReadyParams();
        this.readyCallbacks.forEach(function(r) {
          return r(i);
        }), this.readyCallbacks.length = 0;
      }
    }, e.prototype.whenReady = function(i) {
      this.ready ? i(this.createReadyParams()) : this.readyCallbacks.push(i);
    }, e.prototype.createReadyParams = function() {
      return {
        centerRowContainerCtrl: this.centerRowContainerCtrl,
        leftRowContainerCtrl: this.leftRowContainerCtrl,
        rightRowContainerCtrl: this.rightRowContainerCtrl,
        bottomCenterRowContainerCtrl: this.bottomCenterRowContainerCtrl,
        bottomLeftRowContainerCtrl: this.bottomLeftRowContainerCtrl,
        bottomRightRowContainerCtrl: this.bottomRightRowContainerCtrl,
        topCenterRowContainerCtrl: this.topCenterRowContainerCtrl,
        topLeftRowContainerCtrl: this.topLeftRowContainerCtrl,
        topRightRowContainerCtrl: this.topRightRowContainerCtrl,
        centerHeaderRowContainerCtrl: this.centerHeaderRowContainerCtrl,
        leftHeaderRowContainerCtrl: this.leftHeaderRowContainerCtrl,
        rightHeaderRowContainerCtrl: this.rightHeaderRowContainerCtrl,
        fakeHScrollCtrl: this.fakeHScrollCtrl,
        gridBodyCtrl: this.gridBodyCtrl,
        gridCtrl: this.gridCtrl,
        gridHeaderCtrl: this.gridHeaderCtrl
      };
    }, e.prototype.registerFakeHScrollCtrl = function(i) {
      this.fakeHScrollCtrl = i, this.checkReady();
    }, e.prototype.registerGridHeaderCtrl = function(i) {
      this.gridHeaderCtrl = i, this.checkReady();
    }, e.prototype.registerCenterRowContainerCtrl = function(i) {
      this.centerRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerLeftRowContainerCtrl = function(i) {
      this.leftRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerRightRowContainerCtrl = function(i) {
      this.rightRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerTopCenterRowContainerCtrl = function(i) {
      this.topCenterRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerTopLeftRowContainerCon = function(i) {
      this.topLeftRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerTopRightRowContainerCtrl = function(i) {
      this.topRightRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerBottomCenterRowContainerCtrl = function(i) {
      this.bottomCenterRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerBottomLeftRowContainerCtrl = function(i) {
      this.bottomLeftRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerBottomRightRowContainerCtrl = function(i) {
      this.bottomRightRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerHeaderContainer = function(i, r) {
      switch (r) {
        case q.PINNED_LEFT:
          this.leftHeaderRowContainerCtrl = i;
          break;
        case q.PINNED_RIGHT:
          this.rightHeaderRowContainerCtrl = i;
          break;
        default:
          this.centerHeaderRowContainerCtrl = i;
          break;
      }
      this.checkReady();
    }, e.prototype.registerGridBodyCtrl = function(i) {
      this.gridBodyCtrl = i, this.checkReady();
    }, e.prototype.registerGridCtrl = function(i) {
      this.gridCtrl = i, this.checkReady();
    }, e.prototype.getFakeHScrollCtrl = function() {
      return this.fakeHScrollCtrl;
    }, e.prototype.getGridHeaderCtrl = function() {
      return this.gridHeaderCtrl;
    }, e.prototype.getGridCtrl = function() {
      return this.gridCtrl;
    }, e.prototype.getCenterRowContainerCtrl = function() {
      return this.centerRowContainerCtrl;
    }, e.prototype.getTopCenterRowContainerCtrl = function() {
      return this.topCenterRowContainerCtrl;
    }, e.prototype.getBottomCenterRowContainerCtrl = function() {
      return this.bottomCenterRowContainerCtrl;
    }, e.prototype.getGridBodyCtrl = function() {
      return this.gridBodyCtrl;
    }, e.prototype.getHeaderRowContainerCtrls = function() {
      return [this.leftHeaderRowContainerCtrl, this.rightHeaderRowContainerCtrl, this.centerHeaderRowContainerCtrl];
    }, e.prototype.getHeaderRowContainerCtrl = function(i) {
      switch (i) {
        case q.PINNED_LEFT:
          return this.leftHeaderRowContainerCtrl;
        case q.PINNED_RIGHT:
          return this.rightHeaderRowContainerCtrl;
        default:
          return this.centerHeaderRowContainerCtrl;
      }
    };
    var t;
    return e.NAME = "ctrlsService", e = t = QZ([
      Ke(t.NAME)
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var JZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), eQ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, tQ = (
  /** @class */
  function(n) {
    JZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.registry = {}, t;
    }
    return e.prototype.register = function(t) {
      this.registry[t.controllerName] = t.controllerClass;
    }, e.prototype.getInstance = function(t) {
      var i = this.registry[t];
      if (i != null)
        return new i();
    }, e = eQ([
      Ke("ctrlsFactory")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var iQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), jC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, nQ = (
  /** @class */
  function(n) {
    iQ(e, n);
    function e() {
      return n.call(this) || this;
    }
    return e.prototype.setComp = function(t, i, r, o) {
      this.view = t, this.eViewport = r, this.eContainer = o, this.eGui = i, this.addManagedListener(this.eventService, I.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.onScrollVisibilityChanged();
      var s = this.setFakeHScrollSpacerWidths.bind(this);
      this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, s), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, s), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_DOM_LAYOUT, s), this.setFakeHScrollSpacerWidths(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()), this.ctrlsService.registerFakeHScrollCtrl(this);
    }, e.prototype.addActiveListenerToggles = function() {
      var t = this, i = ["mouseenter", "mousedown", "touchstart"], r = ["mouseleave", "mouseup", "touchend"];
      i.forEach(function(o) {
        return t.addManagedListener(t.eGui, o, function() {
          return t.view.addOrRemoveCssClass("ag-scrollbar-active", !0);
        });
      }), r.forEach(function(o) {
        return t.addManagedListener(t.eGui, o, function() {
          return t.view.addOrRemoveCssClass("ag-scrollbar-active", !1);
        });
      });
    }, e.prototype.postConstruct = function() {
      this.enableRtl = this.gridOptionsWrapper.isEnableRtl(), this.invisibleScrollbar = cB();
    }, e.prototype.onScrollVisibilityChanged = function() {
      this.setScrollVisible(), this.setFakeHScrollSpacerWidths();
    }, e.prototype.hideAndShowInvisibleScrollAsNeeded = function() {
      var t = this;
      this.addManagedListener(this.eventService, I.EVENT_BODY_SCROLL, function(i) {
        i.direction === "horizontal" && t.view.addOrRemoveCssClass("ag-scrollbar-scrolling", !0);
      }), this.addManagedListener(this.eventService, I.EVENT_BODY_SCROLL_END, function() {
        return t.view.addOrRemoveCssClass("ag-scrollbar-scrolling", !1);
      });
    }, e.prototype.setFakeHScrollSpacerWidths = function() {
      var t = this.scrollVisibleService.isVerticalScrollShowing(), i = this.columnModel.getDisplayedColumnsRightWidth(), r = !this.enableRtl && t, o = this.gridOptionsWrapper.getScrollbarWidth();
      r && (i += o), this.view.setRightSpacerFixedWidth(i), this.view.includeRightSpacerScrollerCss("ag-scroller-corner", i <= o);
      var s = this.columnModel.getDisplayedColumnsLeftWidth(), a = this.enableRtl && t;
      a && (s += o), this.view.setLeftSpacerFixedWidth(s), this.view.includeLeftSpacerScrollerCss("ag-scroller-corner", s <= o);
    }, e.prototype.setScrollVisible = function() {
      var t = this.scrollVisibleService.isHorizontalScrollShowing(), i = this.invisibleScrollbar, r = this.gridOptionsWrapper.isSuppressHorizontalScroll(), o = t && this.gridOptionsWrapper.getScrollbarWidth() || 0, s = o === 0 && i ? 15 : o, a = r ? 0 : s;
      this.view.addOrRemoveCssClass("ag-scrollbar-invisible", i), this.view.setHeight(a), this.view.setViewportHeight(a), this.view.setContainerHeight(a);
    }, e.prototype.getViewport = function() {
      return this.eViewport;
    }, e.prototype.getContainer = function() {
      return this.eContainer;
    }, jC([
      R("scrollVisibleService")
    ], e.prototype, "scrollVisibleService", void 0), jC([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), jC([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), jC([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var rQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ym = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, oQ = (
  /** @class */
  function(n) {
    rQ(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = {
        addOrRemoveCssClass: function(o, s) {
          return t.addOrRemoveCssClass(o, s);
        },
        setHeight: function(o) {
          return cd(t.getGui(), o);
        },
        setContainerHeight: function(o) {
          return cd(t.eContainer, o);
        },
        setViewportHeight: function(o) {
          return cd(t.eViewport, o);
        },
        setRightSpacerFixedWidth: function(o) {
          return Ul(t.eRightSpacer, o);
        },
        setLeftSpacerFixedWidth: function(o) {
          return Ul(t.eLeftSpacer, o);
        },
        includeLeftSpacerScrollerCss: function(o, s) {
          return t.eLeftSpacer.classList.toggle(o, s);
        },
        includeRightSpacerScrollerCss: function(o, s) {
          return t.eRightSpacer.classList.toggle(o, s);
        }
      }, r = this.createManagedBean(new nQ());
      r.setComp(i, this.getGui(), this.eViewport, this.eContainer), this.createManagedBean(new yx(function(o) {
        return t.eContainer.style.width = o + "px";
      }));
    }, e.TEMPLATE = `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" ref="eRightSpacer"></div>
        </div>`, ym([
      fe("eLeftSpacer")
    ], e.prototype, "eLeftSpacer", void 0), ym([
      fe("eRightSpacer")
    ], e.prototype, "eRightSpacer", void 0), ym([
      fe("eViewport")
    ], e.prototype, "eViewport", void 0), ym([
      fe("eContainer")
    ], e.prototype, "eContainer", void 0), ym([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var sQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), xL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, aQ = (
  /** @class */
  function(n) {
    sQ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this.checkContainerWidths.bind(this);
      this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_CHANGED, t), this.addManagedListener(this.eventService, I.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, t), this.addManagedListener(this.gridOptionsWrapper, Ve.PROP_DOM_LAYOUT, t);
    }, e.prototype.checkContainerWidths = function() {
      var t = this.gridOptionsWrapper.getDomLayout() === q.DOM_LAYOUT_PRINT, i = t ? 0 : this.columnModel.getDisplayedColumnsLeftWidth(), r = t ? 0 : this.columnModel.getDisplayedColumnsRightWidth();
      i != this.leftWidth && (this.leftWidth = i, this.eventService.dispatchEvent({ type: I.EVENT_LEFT_PINNED_WIDTH_CHANGED })), r != this.rightWidth && (this.rightWidth = r, this.eventService.dispatchEvent({ type: I.EVENT_RIGHT_PINNED_WIDTH_CHANGED }));
    }, e.prototype.getPinnedRightWidth = function() {
      return this.rightWidth;
    }, e.prototype.getPinnedLeftWidth = function() {
      return this.leftWidth;
    }, xL([
      R("columnModel")
    ], e.prototype, "columnModel", void 0), xL([
      Ee
    ], e.prototype, "postConstruct", null), e = xL([
      Ke("pinnedWidthService")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var lQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), uQ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, y4 = (
  /** @class */
  function(n) {
    lQ(e, n);
    function e(t) {
      var i = n.call(
        this,
        /* html */
        '<div class="ag-popup-editor" tabindex="-1"/>'
      ) || this;
      return i.params = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.gridOptionsWrapper.setDomData(this.getGui(), e.DOM_KEY_POPUP_EDITOR_WRAPPER, !0), this.addKeyDownListener();
    }, e.prototype.addKeyDownListener = function() {
      var t = this, i = this.getGui(), r = this.params, o = function(s) {
        Fw(t.gridOptionsWrapper, s, r.node, r.column, !0) || r.onKeyDown(s);
      };
      this.addManagedListener(i, "keydown", o);
    }, e.DOM_KEY_POPUP_EDITOR_WRAPPER = "popupEditorWrapper", uQ([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(fg)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var cQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), H1 = globalThis && globalThis.__assign || function() {
  return H1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, H1.apply(this, arguments);
}, w4 = (
  /** @class */
  function(n) {
    cQ(e, n);
    function e(t, i, r, o, s, a) {
      var l = n.call(this) || this;
      l.scope = null, l.rendererVersion = 0, l.editorVersion = 0, l.scope = t, l.beans = i, l.column = r.getColumn(), l.rowNode = r.getRowNode(), l.rowCtrl = r.getRowCtrl(), l.eRow = s, l.setTemplate(
        /* html */
        '<div comp-id="' + l.getCompId() + '"/>'
      );
      var u = l.getGui();
      l.forceWrapper = r.isForceWrapper(), l.refreshWrapper(!1);
      var c = function(d, f, p) {
        var g = p || u;
        f != null && f != "" ? g.setAttribute(d, f) : g.removeAttribute(d);
      }, h = {
        addOrRemoveCssClass: function(d, f) {
          return l.addOrRemoveCssClass(d, f);
        },
        setUserStyles: function(d) {
          return ex(u, d);
        },
        getFocusableElement: function() {
          return l.getFocusableElement();
        },
        setTabIndex: function(d) {
          return c("tabindex", d.toString());
        },
        setRole: function(d) {
          return So(u, d);
        },
        setColId: function(d) {
          return c("col-id", d);
        },
        setTitle: function(d) {
          return c("title", d);
        },
        setIncludeSelection: function(d) {
          return l.includeSelection = d;
        },
        setIncludeRowDrag: function(d) {
          return l.includeRowDrag = d;
        },
        setIncludeDndSource: function(d) {
          return l.includeDndSource = d;
        },
        setRenderDetails: function(d, f, p) {
          return l.setRenderDetails(d, f, p);
        },
        setEditDetails: function(d, f, p) {
          return l.setEditDetails(d, f, p);
        },
        getCellEditor: function() {
          return l.cellEditor || null;
        },
        getCellRenderer: function() {
          return l.cellRenderer || null;
        },
        getParentOfValue: function() {
          return l.getParentOfValue();
        }
      };
      return l.cellCtrl = r, r.setComp(h, l.scope, l.getGui(), l.eCellWrapper, o, a), l;
    }
    return e.prototype.getParentOfValue = function() {
      return this.eCellValue ? this.eCellValue : this.eCellWrapper ? this.eCellWrapper : this.getGui();
    }, e.prototype.setRenderDetails = function(t, i, r) {
      var o = this.cellEditor && !this.cellEditorPopupWrapper;
      if (!o) {
        this.firstRender = this.firstRender == null;
        var s = this.isUsingAngular1Template(), a = this.refreshWrapper(!1);
        if (t) {
          var l = r || a, u = l ? !1 : this.refreshCellRenderer(t);
          u || (this.destroyRenderer(), this.createCellRendererInstance(t));
        } else
          this.destroyRenderer(), s ? this.insertValueUsingAngular1Template() : this.insertValueWithoutCellRenderer(i);
      }
    }, e.prototype.setEditDetails = function(t, i, r) {
      t ? this.createCellEditorInstance(t, i, r) : this.destroyEditor();
    }, e.prototype.removeControls = function() {
      this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp), this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp), this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp);
    }, e.prototype.refreshWrapper = function(t) {
      var i = this.includeRowDrag || this.includeDndSource || this.includeSelection, r = i || this.forceWrapper, o = r && this.eCellWrapper == null;
      o && (this.eCellWrapper = Dr('<div class="ag-cell-wrapper" role="presentation"></div>'), this.getGui().appendChild(this.eCellWrapper));
      var s = !r && this.eCellWrapper != null;
      s && (Ha(this.eCellWrapper), this.eCellWrapper = void 0), this.addOrRemoveCssClass("ag-cell-value", !r);
      var a = !t && r, l = a && this.eCellValue == null;
      l && (this.eCellValue = Dr('<span class="ag-cell-value" role="presentation"></span>'), this.eCellWrapper.appendChild(this.eCellValue));
      var u = !a && this.eCellValue != null;
      u && (Ha(this.eCellValue), this.eCellValue = void 0);
      var c = o || s || l || u;
      return c && this.removeControls(), !t && i && this.addControls(), c;
    }, e.prototype.addControls = function() {
      var t = this.eCellValue.id = "cell-" + this.getCompId(), i = [];
      this.includeRowDrag && this.rowDraggingComp == null && (this.rowDraggingComp = this.cellCtrl.createRowDragComp(), this.rowDraggingComp && this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue)), this.includeDndSource && this.dndSourceComp == null && (this.dndSourceComp = this.cellCtrl.createDndSource(), this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue)), this.includeSelection && (this.checkboxSelectionComp == null && (this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox(), this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue)), i.push(this.checkboxSelectionComp.getCheckboxId())), i.push(t), SS(this.getGui(), i.join(" "));
    }, e.prototype.createCellEditorInstance = function(t, i, r) {
      var o = this, s = this.editorVersion, a = t.newAgStackInstance();
      if (a) {
        var l = t.params;
        a.then(function(c) {
          return o.afterCellEditorCreated(s, c, l, i, r);
        });
        var u = Je(this.cellEditor);
        u && l.cellStartedEdit && this.cellCtrl.focusCell(!0);
      }
    }, e.prototype.insertValueWithoutCellRenderer = function(t) {
      var i = this.getParentOfValue();
      ys(i);
      var r = t != null ? Gl(t) : null;
      r != null && (i.innerHTML = r);
    }, e.prototype.insertValueUsingAngular1Template = function() {
      var t = this, i = this.column.getColDef(), r = i.template, o = i.templateUrl, s;
      if (r != null ? s = r : o != null && (s = this.beans.templateService.getTemplate(o, function() {
        return t.cellCtrl.refreshCell({ forceRefresh: !0 });
      })), s != null) {
        var a = this.getParentOfValue();
        a.innerHTML = s, this.updateAngular1ScopeAndCompile();
      }
    }, e.prototype.destroyEditorAndRenderer = function() {
      this.destroyRenderer(), this.destroyEditor();
    }, e.prototype.destroyRenderer = function() {
      var t = this.beans.context;
      this.cellRenderer = t.destroyBean(this.cellRenderer), Ha(this.cellRendererGui), this.cellRendererGui = null, this.rendererVersion++;
    }, e.prototype.destroyEditor = function() {
      var t = this.beans.context;
      this.hideEditorPopup && this.hideEditorPopup(), this.hideEditorPopup = void 0, this.cellEditor = t.destroyBean(this.cellEditor), this.cellEditorPopupWrapper = t.destroyBean(this.cellEditorPopupWrapper), Ha(this.cellEditorGui), this.cellEditorGui = null, this.editorVersion++;
    }, e.prototype.refreshCellRenderer = function(t) {
      if (this.cellRenderer == null || this.cellRenderer.refresh == null || this.cellRendererClass !== t.componentClass)
        return !1;
      var i = this.cellRenderer.refresh(t.params);
      return i === !0 || i === void 0;
    }, e.prototype.createCellRendererInstance = function(t) {
      var i = this, r = this.beans.gridOptionsWrapper.isAngularCompileRows(), o = this.beans.gridOptionsWrapper.isSuppressAnimationFrame(), s = !r && !o, a = this.rendererVersion, l = t.componentClass, u = function() {
        var c = i.rendererVersion !== a || !i.isAlive();
        if (!c) {
          var h = t.newAgStackInstance(), d = i.afterCellRendererCreated.bind(i, a, l);
          h && h.then(d);
        }
      };
      s && this.firstRender ? this.beans.animationFrameService.createTask(u, this.rowNode.rowIndex, "createTasksP2") : u();
    }, e.prototype.isUsingAngular1Template = function() {
      var t = this.column.getColDef(), i = t.template != null || t.templateUrl != null;
      return i;
    }, e.prototype.getCtrl = function() {
      return this.cellCtrl;
    }, e.prototype.getRowCtrl = function() {
      return this.rowCtrl;
    }, e.prototype.getCellRenderer = function() {
      return this.cellRenderer;
    }, e.prototype.getCellEditor = function() {
      return this.cellEditor;
    }, e.prototype.afterCellRendererCreated = function(t, i, r) {
      var o = !this.isAlive() || t !== this.rendererVersion;
      if (o) {
        this.beans.context.destroyBean(r);
        return;
      }
      if (this.cellRenderer = r, this.cellRendererClass = i, this.cellRendererGui = this.cellRenderer.getGui(), this.cellRendererGui != null) {
        var s = this.getParentOfValue();
        ys(s), s.appendChild(this.cellRendererGui), this.updateAngular1ScopeAndCompile();
      }
    }, e.prototype.afterCellEditorCreated = function(t, i, r, o, s) {
      var a = t !== this.editorVersion;
      if (a) {
        this.beans.context.destroyBean(i);
        return;
      }
      var l = i.isCancelBeforeStart && i.isCancelBeforeStart();
      if (l) {
        this.beans.context.destroyBean(i), this.cellCtrl.stopEditing();
        return;
      }
      if (!i.getGui) {
        console.warn("AG Grid: cellEditor for column " + this.column.getId() + " is missing getGui() method"), this.beans.context.destroyBean(i);
        return;
      }
      this.cellEditor = i, this.cellEditorGui = i.getGui();
      var u = o || i.isPopup !== void 0 && i.isPopup();
      u ? (o || this.cellCtrl.hackSayEditingInPopup(), this.addPopupCellEditor(r, s)) : this.addInCellEditor(), i.afterGuiAttached && i.afterGuiAttached();
    }, e.prototype.addInCellEditor = function() {
      var t = this.getGui(), i = this.beans.gridOptionsWrapper.getDocument();
      if (t.contains(i.activeElement) && t.focus(), this.destroyRenderer(), this.refreshWrapper(!0), this.clearParentOfValue(), this.cellEditorGui) {
        var r = this.getParentOfValue();
        r.appendChild(this.cellEditorGui);
      }
    }, e.prototype.addPopupCellEditor = function(t, i) {
      var r = this;
      this.beans.gridOptionsWrapper.isFullRowEdit() && console.warn("AG Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.");
      var o = this.cellEditor;
      this.cellEditorPopupWrapper = this.beans.context.createBean(new y4(t));
      var s = this.cellEditorPopupWrapper.getGui();
      this.cellEditorGui && s.appendChild(this.cellEditorGui);
      var a = this.beans.popupService, l = this.beans.gridOptionsWrapper.isStopEditingWhenCellsLoseFocus(), u = i ?? (o.getPopupPosition ? o.getPopupPosition() : "over"), c = {
        column: this.column,
        rowNode: this.rowNode,
        type: "popupCellEditor",
        eventSource: this.getGui(),
        ePopup: s,
        keepWithinBounds: !0
      }, h = u === "under" ? a.positionPopupUnderComponent.bind(a, c) : a.positionPopupOverComponent.bind(a, c), d = this.beans.gridOptionsWrapper.getLocaleTextFunc(), f = a.addPopup({
        modal: l,
        eChild: s,
        closeOnEsc: !0,
        closedCallback: function() {
          r.cellCtrl.onPopupEditorClosed();
        },
        anchorToElement: this.getGui(),
        positionCallback: h,
        ariaLabel: d("ariaLabelCellEditor", "Cell Editor")
      });
      f && (this.hideEditorPopup = f.hideFunc);
    }, e.prototype.detach = function() {
      this.eRow.removeChild(this.getGui());
    }, e.prototype.destroy = function() {
      this.cellCtrl.stopEditing(), this.destroyEditorAndRenderer(), this.removeControls(), this.angularCompiledElement && (this.angularCompiledElement.remove(), this.angularCompiledElement = void 0), n.prototype.destroy.call(this);
    }, e.prototype.clearParentOfValue = function() {
      var t = this.getGui(), i = this.beans.gridOptionsWrapper.getDocument();
      t.contains(i.activeElement) && t.focus({
        preventScroll: !0
      }), ys(this.getParentOfValue());
    }, e.prototype.updateAngular1ScopeAndCompile = function() {
      if (this.beans.gridOptionsWrapper.isAngularCompileRows() && this.scope) {
        this.scope.data = H1({}, this.rowNode.data), this.angularCompiledElement && this.angularCompiledElement.remove();
        var t = this.getParentOfValue();
        this.angularCompiledElement = this.beans.$compile(t.children)(this.scope), this.beans.ctrlsService.getGridBodyCtrl().requestAngularApply();
      }
    }, e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var hQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), dQ = (
  /** @class */
  function(n) {
    hQ(e, n);
    function e(t, i, r) {
      var o = n.call(this) || this;
      o.cellComps = {}, o.beans = i, o.rowCtrl = t, o.setTemplate(
        /* html */
        '<div comp-id="' + o.getCompId() + '" style="' + o.getInitialStyle() + '"/>'
      );
      var s = o.getGui(), a = s.style, l = {
        setDomOrder: function(u) {
          return o.domOrder = u;
        },
        setCellCtrls: function(u) {
          return o.setCellCtrls(u);
        },
        showFullWidth: function(u) {
          return o.showFullWidth(u);
        },
        getFullWidthCellRenderer: function() {
          return o.getFullWidthCellRenderer();
        },
        addOrRemoveCssClass: function(u, c) {
          return o.addOrRemoveCssClass(u, c);
        },
        setUserStyles: function(u) {
          return ex(s, u);
        },
        setTop: function(u) {
          return a.top = u;
        },
        setTransform: function(u) {
          return a.transform = u;
        },
        setRowIndex: function(u) {
          return s.setAttribute("row-index", u);
        },
        setRole: function(u) {
          return So(s, u);
        },
        setRowId: function(u) {
          return s.setAttribute("row-id", u);
        },
        setRowBusinessKey: function(u) {
          return s.setAttribute("row-business-key", u);
        },
        setTabIndex: function(u) {
          return s.setAttribute("tabindex", u.toString());
        }
      };
      return t.setComp(l, o.getGui(), r), o;
    }
    return e.prototype.getInitialStyle = function() {
      var t = this.rowCtrl.getInitialTransform(), i = this.rowCtrl.getInitialRowTop();
      return t ? "transform: " + t : "top: " + i;
    }, e.prototype.showFullWidth = function(t) {
      var i = this, r = function(s) {
        if (i.isAlive()) {
          var a = s.getGui();
          i.getGui().appendChild(a), i.rowCtrl.setupDetailRowAutoHeight(a), i.setFullWidthRowComp(s);
        } else
          i.beans.context.destroyBean(s);
      }, o = t.newAgStackInstance();
      o && o.then(r);
    }, e.prototype.setCellCtrls = function(t) {
      var i = this, r = Object.assign({}, this.cellComps);
      t.forEach(function(s) {
        var a = s.getInstanceId(), l = i.cellComps[a];
        l == null ? i.newCellComp(s) : r[a] = null;
      });
      var o = Ya(r).filter(function(s) {
        return s != null;
      });
      this.destroyCells(o), this.ensureDomOrder(t);
    }, e.prototype.ensureDomOrder = function(t) {
      var i = this;
      if (this.domOrder) {
        var r = [];
        t.forEach(function(o) {
          var s = i.cellComps[o.getInstanceId()];
          s && r.push(s.getGui());
        }), JO(this.getGui(), r);
      }
    }, e.prototype.newCellComp = function(t) {
      var i = new w4(this.rowCtrl.getScope(), this.beans, t, this.rowCtrl.isPrintLayout(), this.getGui(), this.rowCtrl.isEditing());
      this.cellComps[t.getInstanceId()] = i, this.getGui().appendChild(i.getGui());
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this), this.destroyAllCells();
    }, e.prototype.destroyAllCells = function() {
      var t = Ya(this.cellComps).filter(function(i) {
        return i != null;
      });
      this.destroyCells(t);
    }, e.prototype.setFullWidthRowComp = function(t) {
      var i = this;
      this.fullWidthCellRenderer && console.error("AG Grid - should not be setting fullWidthRowComponent twice"), this.fullWidthCellRenderer = t, this.addDestroyFunc(function() {
        i.fullWidthCellRenderer = i.beans.context.destroyBean(i.fullWidthCellRenderer);
      });
    }, e.prototype.getFullWidthCellRenderer = function() {
      return this.fullWidthCellRenderer;
    }, e.prototype.destroyCells = function(t) {
      var i = this;
      t.forEach(function(r) {
        if (r) {
          var o = r.getCtrl().getInstanceId();
          i.cellComps[o] === r && (r.detach(), r.destroy(), i.cellComps[o] = null);
        }
      });
    }, e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var fQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), G1 = globalThis && globalThis.__assign || function() {
  return G1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, G1.apply(this, arguments);
}, Cf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
};
function pQ() {
  var n = St.elementGettingCreated.getAttribute("name"), e = Gw.getRowContainerCssClasses(n), t, i = n === _e.CENTER, r = n === _e.TOP_CENTER || n === _e.BOTTOM_CENTER;
  return i ? t = /* html */
  '<div class="' + e.wrapper + `" ref="eWrapper" role="presentation">
                <div class="` + e.viewport + `" ref="eViewport" role="presentation">
                    <div class="` + e.container + `" ref="eContainer" role="rowgroup"></div>
                </div>
            </div>` : r ? t = /* html */
  '<div class="' + e.viewport + `" ref="eViewport" role="presentation">
                <div class="` + e.container + `" ref="eContainer" role="presentation"></div>
            </div>` : t = /* html */
  '<div class="' + e.container + '" ref="eContainer" role="presentation"></div>', t;
}
var b4 = (
  /** @class */
  function(n) {
    fQ(e, n);
    function e() {
      var t = n.call(this, pQ()) || this;
      return t.rowComps = {}, t.name = St.elementGettingCreated.getAttribute("name"), t.type = lH(t.name), t;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = {
        setViewportHeight: function(o) {
          return t.eViewport.style.height = o;
        },
        setRowCtrls: function(o) {
          return t.setRowCtrls(o);
        },
        setDomOrder: function(o) {
          t.domOrder = o;
        },
        setContainerWidth: function(o) {
          return t.eContainer.style.width = o;
        }
      }, r = this.createManagedBean(new Gw(this.name));
      r.setComp(i, this.eContainer, this.eViewport, this.eWrapper);
    }, e.prototype.preDestroy = function() {
      this.setRowCtrls([]);
    }, e.prototype.setRowCtrls = function(t) {
      var i = this, r = G1({}, this.rowComps);
      this.rowComps = {}, this.lastPlacedElement = null;
      var o = function(s) {
        var a = s.getInstanceId(), l = r[a];
        if (l)
          i.rowComps[a] = l, delete r[a], i.ensureDomOrder(l.getGui());
        else {
          var u = i.newRowComp(s);
          i.rowComps[a] = u, i.appendRow(u.getGui());
        }
      };
      t.forEach(o), Ya(r).forEach(function(s) {
        i.eContainer.removeChild(s.getGui()), s.destroy();
      });
    }, e.prototype.appendRow = function(t) {
      this.domOrder ? gB(this.eContainer, t, this.lastPlacedElement) : this.eContainer.appendChild(t), this.lastPlacedElement = t;
    }, e.prototype.ensureDomOrder = function(t) {
      this.domOrder && (QO(this.eContainer, t, this.lastPlacedElement), this.lastPlacedElement = t);
    }, e.prototype.newRowComp = function(t) {
      Gw.getPinned(this.name);
      var i = new dQ(t, this.beans, this.type);
      return i;
    }, Cf([
      R("beans")
    ], e.prototype, "beans", void 0), Cf([
      fe("eViewport")
    ], e.prototype, "eViewport", void 0), Cf([
      fe("eContainer")
    ], e.prototype, "eContainer", void 0), Cf([
      fe("eWrapper")
    ], e.prototype, "eWrapper", void 0), Cf([
      Ee
    ], e.prototype, "postConstruct", null), Cf([
      Lo
    ], e.prototype, "preDestroy", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), $C = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, mQ = (
  /** @class */
  function(n) {
    gQ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.events = [], t;
    }
    return e.prototype.postConstruct = function() {
      this.rowModel.getType() == q.ROW_MODEL_TYPE_CLIENT_SIDE && (this.clientSideRowModel = this.rowModel);
    }, e.prototype.dispatchExpanded = function(t) {
      var i = this;
      if (this.clientSideRowModel == null) {
        this.eventService.dispatchEvent(t);
        return;
      }
      this.events.push(t);
      var r = function() {
        i.clientSideRowModel && i.clientSideRowModel.onRowGroupOpened(), i.events.forEach(function(o) {
          return i.eventService.dispatchEvent(o);
        }), i.events = [];
      };
      this.dispatchExpandedDebounced == null && (this.dispatchExpandedDebounced = this.animationFrameService.debounce(r)), this.dispatchExpandedDebounced();
    }, $C([
      R("animationFrameService")
    ], e.prototype, "animationFrameService", void 0), $C([
      R("rowModel")
    ], e.prototype, "rowModel", void 0), $C([
      Ee
    ], e.prototype, "postConstruct", null), e = $C([
      Ke("rowNodeEventThrottle")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var vQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, S4 = (
  /** @class */
  function(n) {
    vQ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.hideActiveMenu = function() {
      this.hidePopup && this.hidePopup();
    }, e.prototype.showMenuAfterMouseEvent = function(t, i) {
      var r = this;
      this.showPopup(t, function(o) {
        r.popupService.positionPopupUnderMouseEvent({
          column: t,
          type: "columnMenu",
          mouseEvent: i,
          ePopup: o
        });
      }, i.target);
    }, e.prototype.showMenuAfterButtonClick = function(t, i, r) {
      var o = this;
      this.showPopup(t, function(s) {
        o.popupService.positionPopupUnderComponent({
          type: r,
          eventSource: i,
          ePopup: s,
          keepWithinBounds: !0,
          column: t
        });
      }, i);
    }, e.prototype.showPopup = function(t, i, r) {
      var o = this, s = this.filterManager.getOrCreateFilterWrapper(t, "COLUMN_MENU");
      if (!s)
        throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
      var a = document.createElement("div");
      So(a, "presentation"), a.classList.add("ag-menu"), this.tabListener = this.addManagedListener(a, "keydown", function(f) {
        return o.trapFocusWithin(f, a);
      }), s.guiPromise.then(function(f) {
        return a.appendChild(f);
      });
      var l, u = r || this.ctrlsService.getGridBodyCtrl().getGui(), c = function(f) {
        t.setMenuVisible(!1, "contextMenu");
        var p = f instanceof KeyboardEvent;
        if (o.tabListener && (o.tabListener = o.tabListener()), p && r && hg(r)) {
          var g = o.focusService.findTabbableParent(r);
          g && g.focus();
        }
      }, h = this.gridOptionsWrapper.getLocaleTextFunc(), d = this.popupService.addPopup({
        modal: !0,
        eChild: a,
        closeOnEsc: !0,
        closedCallback: c,
        positionCallback: function() {
          return i(a);
        },
        anchorToElement: u,
        ariaLabel: h("ariaLabelColumnMenu", "Column Menu")
      });
      d && (this.hidePopup = l = d.hideFunc), s.filterPromise.then(function(f) {
        i(a), f.afterGuiAttached && f.afterGuiAttached({ container: "columnMenu", hidePopup: l });
      }), t.setMenuVisible(!0, "contextMenu");
    }, e.prototype.trapFocusWithin = function(t, i) {
      t.key !== pe.TAB || t.defaultPrevented || this.focusService.findNextFocusableElement(i, !1, t.shiftKey) || (t.preventDefault(), this.focusService.focusInto(i, t.shiftKey));
    }, e.prototype.isMenuEnabled = function(t) {
      return t.isFilterAllowed();
    }, wm([
      R("filterManager")
    ], e.prototype, "filterManager", void 0), wm([
      R("popupService")
    ], e.prototype, "popupService", void 0), wm([
      R("focusService")
    ], e.prototype, "focusService", void 0), wm([
      R("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), e = wm([
      Ke("menuFactory")
    ], e), e;
  }(we)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var _Q = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, BM = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(_Q(arguments[e]));
  return n;
}, E4 = (
  /** @class */
  function() {
    function n(e, t, i) {
      if (!t) {
        console.error("AG Grid: no gridOptions provided to the grid");
        return;
      }
      this.gridOptions = t, new L4().create(e, t, function(r) {
        var o = new VH(e);
        r.createBean(o);
      }, void 0, i);
    }
    return n.prototype.destroy = function() {
      this.gridOptions && this.gridOptions.api && this.gridOptions.api.destroy();
    }, n;
  }()
), L4 = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.create = function(e, t, i, r, o) {
      var s = this, a = !!t.debug, l = this.getRegisteredModules(o), u = this.createBeansList(t.rowModelType, l), c = this.createProvidedBeans(e, t, o);
      if (u) {
        var h = {
          providedBeanInstances: c,
          beanClasses: u,
          debug: a
        }, d = new zw("AG Grid", function() {
          return t.debug;
        }), f = new zw("Context", function() {
          return h.debug;
        }), p = new jV(h, f), g = p.getBean("beans");
        this.registerModuleUserComponents(g, l), this.registerStackComponents(g, l), this.registerControllers(g, l), i(p), g.ctrlsService.whenReady(function() {
          s.setColumnsAndData(g), s.dispatchGridReadyEvent(g, t);
          var _ = pt.isRegistered(ct.EnterpriseCoreModule);
          d.log("initialised successfully, enterprise = " + _);
        }), r && r(p);
      }
    }, n.prototype.registerControllers = function(e, t) {
      t.forEach(function(i) {
        i.controllers && i.controllers.forEach(function(r) {
          return e.ctrlsFactory.register(r);
        });
      });
    }, n.prototype.registerStackComponents = function(e, t) {
      var i = this.createAgStackComponentsList(t);
      e.agStackComponentsRegistry.setupComponents(i);
    }, n.prototype.getRegisteredModules = function(e) {
      var t = e ? e.modules : null, i = pt.getRegisteredModules(), r = [], o = {};
      function s(a, l) {
        function u(c) {
          o[c.moduleName] || (o[c.moduleName] = !0, r.push(c), pt.register(c, a));
        }
        u(l), l.dependantModules && l.dependantModules.forEach(s.bind(null, a));
      }
      return t && t.forEach(s.bind(null, !0)), i && i.forEach(s.bind(null, !pt.isPackageBased())), r;
    }, n.prototype.registerModuleUserComponents = function(e, t) {
      var i = this.extractModuleEntity(t, function(r) {
        return r.userComponents ? r.userComponents : [];
      });
      i.forEach(function(r) {
        e.userComponentRegistry.registerDefaultComponent(r.componentName, r.componentClass);
      });
    }, n.prototype.createProvidedBeans = function(e, t, i) {
      var r = i ? i.frameworkOverrides : null;
      Je(r) && (r = new $H());
      var o = {
        gridOptions: t,
        eGridDiv: e,
        $scope: i ? i.$scope : null,
        $compile: i ? i.$compile : null,
        globalEventListener: i ? i.globalEventListener : null,
        frameworkOverrides: r
      };
      return i && i.providedBeanInstances && Object.assign(o, i.providedBeanInstances), o;
    }, n.prototype.createAgStackComponentsList = function(e) {
      var t = [
        { componentName: "AgCheckbox", componentClass: kp },
        { componentName: "AgRadioButton", componentClass: jH },
        { componentName: "AgToggleButton", componentClass: d4 },
        { componentName: "AgInputTextField", componentClass: Rx },
        { componentName: "AgInputTextArea", componentClass: s4 },
        { componentName: "AgInputNumberField", componentClass: u4 },
        { componentName: "AgInputRange", componentClass: c4 },
        { componentName: "AgSelect", componentClass: dx },
        { componentName: "AgSlider", componentClass: a4 },
        { componentName: "AgAngleSelect", componentClass: h4 },
        { componentName: "AgColorPicker", componentClass: l4 },
        { componentName: "AgGridBody", componentClass: xH },
        { componentName: "AgHeaderRoot", componentClass: bH },
        { componentName: "AgPagination", componentClass: gZ },
        { componentName: "AgOverlayWrapper", componentClass: CZ },
        { componentName: "AgGroupComponent", componentClass: n4 },
        { componentName: "AgPanel", componentClass: Lx },
        { componentName: "AgDialog", componentClass: Dx },
        { componentName: "AgRowContainer", componentClass: b4 },
        { componentName: "AgFakeHorizontalScroll", componentClass: oQ }
      ], i = this.extractModuleEntity(e, function(r) {
        return r.agStackComponents ? r.agStackComponents : [];
      });
      return t = t.concat(i), t;
    }, n.prototype.createBeansList = function(e, t) {
      var i = this.getRowModelClass(e, t);
      if (i) {
        var r = [
          i,
          Cx,
          f4,
          p4,
          m4,
          YX,
          vH,
          iH,
          iZ,
          rZ,
          i4,
          rH,
          dZ,
          FH,
          g4,
          BH,
          rB,
          Zu,
          Ve,
          PH,
          sH,
          SH,
          iB,
          dH,
          YH,
          uH,
          NH,
          QV,
          IH,
          ZH,
          e4,
          XH,
          EH,
          AH,
          nB,
          MH,
          S4,
          _o,
          aH,
          ap,
          GH,
          QH,
          UH,
          zH,
          qH,
          KH,
          HH,
          GX,
          zX,
          t4,
          $X,
          QX,
          JH,
          UZ,
          oB,
          $Z,
          KZ,
          v4,
          _4,
          C4,
          aQ,
          mQ,
          tQ
        ], o = this.extractModuleEntity(t, function(a) {
          return a.beans ? a.beans : [];
        });
        r.push.apply(r, BM(o));
        var s = [];
        return r.forEach(function(a) {
          s.indexOf(a) < 0 && s.push(a);
        }), s;
      }
    }, n.prototype.extractModuleEntity = function(e, t) {
      return [].concat.apply([], BM(e.map(t)));
    }, n.prototype.setColumnsAndData = function(e) {
      var t = e.gridOptionsWrapper.getColumnDefs();
      e.columnModel.setColumnDefs(t || [], "gridInitializing"), e.rowModel.start();
    }, n.prototype.dispatchGridReadyEvent = function(e, t) {
      var i = {
        type: I.EVENT_GRID_READY,
        api: t.api,
        columnApi: t.columnApi
      };
      e.eventService.dispatchEvent(i);
    }, n.prototype.getRowModelClass = function(e, t) {
      e || (e = q.ROW_MODEL_TYPE_CLIENT_SIDE);
      var i = {};
      t.forEach(function(o) {
        pi(o.rowModels, function(s, a) {
          i[s] = a;
        });
      });
      var r = i[e];
      if (de(r))
        return r;
      e === q.ROW_MODEL_TYPE_INFINITE && console.error('AG Grid: Row Model "Infinite" not found. Please ensure the ' + ct.InfiniteRowModelModule + " is registered.';"), console.error("AG Grid: could not find matching row model for rowModelType " + e), e === q.ROW_MODEL_TYPE_VIEWPORT && console.error('AG Grid: Row Model "Viewport" not found. Please ensure the AG Grid Enterprise Module ' + ct.ViewportRowModelModule + " is registered.';"), e === q.ROW_MODEL_TYPE_SERVER_SIDE && console.error('AG Grid: Row Model "Server Side" not found. Please ensure the AG Grid Enterprise Module ' + ct.ServerSideRowModelModule + " is registered.';"), e === q.ROW_MODEL_TYPE_CLIENT_SIDE && console.error('AG Grid: Row Model "Client Side" not found. Please ensure the ' + ct.ClientSideRowModelModule + " is registered.';");
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function CQ(n) {
  var e = n.module("agGrid", []);
  e.directive("agGrid", function() {
    return {
      restrict: "A",
      controller: ["$element", "$scope", "$compile", "$attrs", yQ],
      scope: !0
    };
  });
}
function yQ(n, e, t, i) {
  var r, o = i.agGrid;
  if (r = e.$eval(o), !r) {
    console.warn("WARNING - grid options for AG Grid not found. Please ensure the attribute ag-grid points to a valid object on the scope");
    return;
  }
  var s = n[0], a = {
    $scope: e,
    $compile: t
  }, l = new E4(s, r, a), u = o + ".quickFilterText", c = e.$watch(u, function(h) {
    r.api.setQuickFilter(h);
  });
  e.$on("$destroy", function() {
    c(), l && l.destroy(), l = null;
  });
}
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var wQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), KC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, bQ = (
  /** @class */
  function(n) {
    wQ(e, n);
    function e(t) {
      var i = n.call(this, e.getTemplate(t.cssClass)) || this;
      return i.items = [], i.tabbedItemScrollMap = /* @__PURE__ */ new Map(), i.params = t, t.items && t.items.forEach(function(r) {
        return i.addItem(r);
      }), i;
    }
    return e.prototype.postConstruct = function() {
      this.createManagedBean(new Qu(this.getFocusableElement(), {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this)
      }));
    }, e.getTemplate = function(t) {
      return (
        /* html */
        '<div class="ag-tabs ' + t + `">
            <div ref="eHeader" role="tablist" class="ag-tabs-header ` + (t ? t + "-header" : "") + `"></div>
            <div ref="eBody" role="presentation" class="ag-tabs-body ` + (t ? t + "-body" : "") + `"></div>
        </div>`
      );
    }, e.prototype.handleKeyDown = function(t) {
      var i = this.gridOptionsWrapper.getDocument();
      switch (t.key) {
        case pe.RIGHT:
        case pe.LEFT:
          if (!this.eHeader.contains(i.activeElement))
            return;
          var r = this.items.indexOf(this.activeItem), o = t.key === pe.RIGHT ? Math.min(r + 1, this.items.length - 1) : Math.max(r - 1, 0);
          if (r === o)
            return;
          t.preventDefault();
          var s = this.items[o];
          this.showItemWrapper(s), s.eHeaderButton.focus();
          break;
        case pe.UP:
        case pe.DOWN:
          t.stopPropagation();
          break;
      }
    }, e.prototype.onTabKeyDown = function(t) {
      if (!t.defaultPrevented) {
        var i = this, r = i.focusService, o = i.eHeader, s = i.eBody, a = i.activeItem, l = this.gridOptionsWrapper.getDocument(), u = l.activeElement;
        if (t.preventDefault(), o.contains(u))
          r.focusInto(s, t.shiftKey);
        else if (r.isFocusUnderManagedComponent(s))
          a.eHeaderButton.focus();
        else {
          var c = r.findNextFocusableElement(s, !1, t.shiftKey);
          c ? c.focus() : a.eHeaderButton.focus();
        }
      }
    }, e.prototype.setAfterAttachedParams = function(t) {
      this.afterAttachedParams = t;
    }, e.prototype.showFirstItem = function() {
      this.items.length > 0 && this.showItemWrapper(this.items[0]);
    }, e.prototype.addItem = function(t) {
      var i = document.createElement("span");
      So(i, "tab"), i.setAttribute("tabIndex", "-1"), i.appendChild(t.title), i.classList.add("ag-tab"), this.eHeader.appendChild(i), Ud(i, t.titleLabel);
      var r = {
        tabbedItem: t,
        eHeaderButton: i
      };
      this.items.push(r), i.addEventListener("click", this.showItemWrapper.bind(this, r));
    }, e.prototype.showItem = function(t) {
      var i = this.items.find(function(r) {
        return r.tabbedItem === t;
      });
      i && this.showItemWrapper(i);
    }, e.prototype.showItemWrapper = function(t) {
      var i = this, r = t.tabbedItem, o = t.eHeaderButton;
      if (this.params.onItemClicked && this.params.onItemClicked({ item: r }), this.activeItem === t) {
        zV(this.params.onActiveItemClicked);
        return;
      }
      this.lastScrollListener && (this.lastScrollListener = this.lastScrollListener()), ys(this.eBody), r.bodyPromise.then(function(s) {
        i.eBody.appendChild(s);
        var a = !i.focusService.isKeyboardMode();
        if (i.focusService.focusInto(i.eBody, !1, a), r.afterAttachedCallback && r.afterAttachedCallback(i.afterAttachedParams), i.params.keepScrollPosition) {
          var l = r.getScrollableContainer && r.getScrollableContainer() || s;
          i.lastScrollListener = i.addManagedListener(l, "scroll", function() {
            i.tabbedItemScrollMap.set(r.name, l.scrollTop);
          });
          var u = i.tabbedItemScrollMap.get(r.name);
          u !== void 0 && setTimeout(function() {
            l.scrollTop = u;
          }, 0);
        }
      }), this.activeItem && this.activeItem.eHeaderButton.classList.remove("ag-tab-selected"), o.classList.add("ag-tab-selected"), this.activeItem = t;
    }, KC([
      R("focusService")
    ], e.prototype, "focusService", void 0), KC([
      fe("eHeader")
    ], e.prototype, "eHeader", void 0), KC([
      fe("eBody")
    ], e.prototype, "eBody", void 0), KC([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function SQ(n) {
  return new ko(function(e) {
    var t = new XMLHttpRequest();
    t.open("GET", n.url), t.send(), t.onreadystatechange = function() {
      t.readyState === 4 && t.status === 200 && e(JSON.parse(t.responseText));
    };
  });
}
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var U1;
(function(n) {
  n.Applied = "Applied", n.StoreNotFound = "StoreNotFound", n.StoreLoading = "StoreLoading", n.StoreWaitingToLoad = "StoreWaitingToLoad", n.StoreLoadingFailed = "StoreLoadingFailed", n.StoreWrongType = "StoreWrongType", n.Cancelled = "Cancelled";
})(U1 || (U1 = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var EQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Kw = globalThis && globalThis.__assign || function() {
  return Kw = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, Kw.apply(this, arguments);
}, HM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, D4 = (
  /** @class */
  function(n) {
    EQ(e, n);
    function e(t) {
      t === void 0 && (t = 1);
      var i = n.call(
        this,
        /* html */
        '<div class="ag-menu-list" role="tree"></div>'
      ) || this;
      return i.level = t, i.menuItems = [], i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.initialiseTabGuard({
        onTabKeyDown: function(i) {
          return t.onTabKeyDown(i);
        },
        handleKeyDown: function(i) {
          return t.handleKeyDown(i);
        }
      });
    }, e.prototype.onTabKeyDown = function(t) {
      var i = this.getParentComponent(), r = i && i.getGui(), o = r && r.classList.contains("ag-focus-managed");
      o || t.preventDefault(), t.shiftKey && this.closeIfIsChild(t);
    }, e.prototype.handleKeyDown = function(t) {
      switch (t.key) {
        case pe.UP:
        case pe.RIGHT:
        case pe.DOWN:
        case pe.LEFT:
          t.preventDefault(), this.handleNavKey(t.key);
          break;
        case pe.ESCAPE:
          var i = this.findTopMenu();
          i && this.focusService.focusInto(i.getGui());
          break;
      }
    }, e.prototype.clearActiveItem = function() {
      this.activeMenuItem && (this.activeMenuItem.deactivate(), this.activeMenuItem = null);
    }, e.prototype.addMenuItems = function(t) {
      var i = this;
      t != null && t.forEach(function(r) {
        r === "separator" ? i.addSeparator() : typeof r == "string" ? console.warn("AG Grid: unrecognised menu item " + r) : i.addItem(r);
      });
    }, e.prototype.addItem = function(t) {
      var i = this, r = this.createManagedBean(new Pf(Kw(Kw({}, t), { isAnotherSubMenuOpen: function() {
        return i.menuItems.some(function(o) {
          return o.isSubMenuOpen();
        });
      } })));
      r.setParentComponent(this), LB(r.getGui(), this.level), this.menuItems.push(r), this.appendChild(r.getGui()), this.addManagedListener(r, Pf.EVENT_MENU_ITEM_SELECTED, function(o) {
        i.dispatchEvent(o);
      }), this.addManagedListener(r, Pf.EVENT_MENU_ITEM_ACTIVATED, function(o) {
        i.activeMenuItem && i.activeMenuItem !== o.menuItem && i.activeMenuItem.deactivate(), i.activeMenuItem = o.menuItem;
      });
    }, e.prototype.activateFirstItem = function() {
      var t = this.menuItems.filter(function(i) {
        return !i.isDisabled();
      })[0];
      t && t.activate();
    }, e.prototype.addSeparator = function() {
      var t = (
        /* html */
        `
            <div class="ag-menu-separator" aria-hidden="true">
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
            </div>`
      );
      this.appendChild(Dr(t));
    }, e.prototype.findTopMenu = function() {
      var t = this.getParentComponent();
      if (!t && this instanceof e)
        return this;
      for (; ; ) {
        var i = t && t.getParentComponent && t.getParentComponent();
        if (!i || !(i instanceof e || i instanceof Pf))
          break;
        t = i;
      }
      return t instanceof e ? t : void 0;
    }, e.prototype.handleNavKey = function(t) {
      switch (t) {
        case pe.UP:
        case pe.DOWN:
          var i = this.findNextItem(t === pe.UP);
          i && i !== this.activeMenuItem && i.activate();
          return;
      }
      var r = this.gridOptionsWrapper.isEnableRtl() ? pe.RIGHT : pe.LEFT;
      t === r ? this.closeIfIsChild() : this.openChild();
    }, e.prototype.closeIfIsChild = function(t) {
      var i = this.getParentComponent();
      i && i instanceof Pf && (t && t.preventDefault(), i.closeSubMenu(), i.getGui().focus());
    }, e.prototype.openChild = function() {
      this.activeMenuItem && this.activeMenuItem.openSubMenu(!0);
    }, e.prototype.findNextItem = function(t) {
      var i = this.menuItems.filter(function(l) {
        return !l.isDisabled();
      });
      if (i.length) {
        if (!this.activeMenuItem)
          return t ? Di(i) : i[0];
        t && i.reverse();
        for (var r, o = !1, s = 0; s < i.length; s++) {
          var a = i[s];
          if (!o) {
            a === this.activeMenuItem && (o = !0);
            continue;
          }
          r = a;
          break;
        }
        return r || this.activeMenuItem;
      }
    }, e.prototype.destroy = function() {
      this.clearActiveItem(), n.prototype.destroy.call(this);
    }, HM([
      R("focusService")
    ], e.prototype, "focusService", void 0), HM([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(T_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var LQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), DQ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, R4 = (
  /** @class */
  function(n) {
    LQ(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.wrappedComponent = t, i.setTemplateFromElement(t.getGui()), i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.initialiseTabGuard({
        onTabKeyDown: function(i) {
          return t.onTabKeyDown(i);
        },
        handleKeyDown: function(i) {
          return t.handleKeyDown(i);
        }
      });
    }, e.prototype.handleKeyDown = function(t) {
      t.key === pe.ESCAPE && this.closePanel();
    }, e.prototype.onTabKeyDown = function(t) {
      t.defaultPrevented || (this.closePanel(), t.preventDefault());
    }, e.prototype.closePanel = function() {
      var t = this.parentComponent;
      t.closeSubMenu(), setTimeout(function() {
        return t.getGui().focus();
      }, 0);
    }, DQ([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(T_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var RQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), GM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Pf = (
  /** @class */
  function(n) {
    RQ(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.params = t, i.isActive = !1, i.subMenuIsOpen = !1, i.setTemplate(
        /* html */
        '<div class="' + i.getClassName() + '" tabindex="-1" role="treeitem"></div>'
      ), i;
    }
    return e.prototype.init = function() {
      var t = this;
      this.addIcon(), this.addName(), this.addShortcut(), this.addSubMenu(), this.addTooltip();
      var i = this.getGui();
      this.params.disabled ? (this.addCssClass(this.getClassName("disabled")), Gf(i, !0)) : (this.addGuiEventListener("click", function(r) {
        return t.onItemSelected(r);
      }), this.addGuiEventListener("keydown", function(r) {
        (r.key === pe.ENTER || r.key === pe.SPACE) && (r.preventDefault(), t.onItemSelected(r));
      }), this.addGuiEventListener("mousedown", function(r) {
        r.stopPropagation(), r.preventDefault();
      }), this.addGuiEventListener("mouseenter", function() {
        return t.onMouseEnter();
      }), this.addGuiEventListener("mouseleave", function() {
        return t.onMouseLeave();
      })), this.params.cssClasses && this.params.cssClasses.forEach(function(r) {
        return t.addCssClass(r);
      });
    }, e.prototype.isDisabled = function() {
      return !!this.params.disabled;
    }, e.prototype.openSubMenu = function(t) {
      var i = this;
      if (t === void 0 && (t = !1), this.closeSubMenu(), !!this.params.subMenu) {
        var r = Dr(
          /* html */
          '<div class="ag-menu" role="presentation"></div>'
        ), o;
        if (this.params.subMenu instanceof Array) {
          var s = SB(this.getGui()), a = isNaN(s) ? 1 : s + 1, l = this.createBean(new D4(a));
          l.setParentComponent(this), l.addMenuItems(this.params.subMenu), r.appendChild(l.getGui()), this.addManagedListener(l, e.EVENT_MENU_ITEM_SELECTED, function(v) {
            return i.dispatchEvent(v);
          }), l.addGuiEventListener("mouseenter", function() {
            return i.cancelDeactivate();
          }), o = function() {
            return i.destroyBean(l);
          }, t && setTimeout(function() {
            return l.activateFirstItem();
          }, 0);
        } else {
          var u = this.params.subMenu, c = this.createBean(new R4(u));
          c.setParentComponent(this);
          var h = c.getGui(), d = "mouseenter", f = function() {
            return i.cancelDeactivate();
          };
          h.addEventListener(d, f), o = function() {
            return h.removeEventListener(d, f);
          }, r.appendChild(h), u.afterGuiAttached && setTimeout(function() {
            return u.afterGuiAttached();
          }, 0);
        }
        var p = this.getGui(), g = this.popupService.positionPopupForMenu.bind(this.popupService, { eventSource: p, ePopup: r }), _ = this.gridOptionsWrapper.getLocaleTextFunc(), m = this.popupService.addPopup({
          modal: !0,
          eChild: r,
          positionCallback: g,
          anchorToElement: p,
          ariaLabel: _("ariaLabelSubMenu", "SubMenu")
        });
        this.subMenuIsOpen = !0, _s(p, !0), this.hideSubMenu = function() {
          m && m.hideFunc(), i.subMenuIsOpen = !1, _s(p, !1), o();
        };
      }
    }, e.prototype.closeSubMenu = function() {
      this.hideSubMenu && (this.hideSubMenu(), this.hideSubMenu = null, _s(this.getGui(), !1));
    }, e.prototype.isSubMenuOpen = function() {
      return this.subMenuIsOpen;
    }, e.prototype.activate = function(t) {
      var i = this;
      this.cancelActivate(), !this.params.disabled && (this.isActive = !0, this.addCssClass(this.getClassName("active")), this.getGui().focus(), t && this.params.subMenu && window.setTimeout(function() {
        i.isAlive() && i.isActive && i.openSubMenu();
      }, 300), this.onItemActivated());
    }, e.prototype.deactivate = function() {
      this.cancelDeactivate(), this.removeCssClass(this.getClassName("active")), this.isActive = !1, this.subMenuIsOpen && this.hideSubMenu();
    }, e.prototype.addIcon = function() {
      if (!(!this.params.checked && !this.params.icon && this.params.isCompact)) {
        var t = Dr(
          /* html */
          '<span ref="eIcon" class="' + this.getClassName("part") + " " + this.getClassName("icon") + '" role="presentation"></span>'
        );
        this.params.checked ? t.appendChild(Kn("check", this.gridOptionsWrapper)) : this.params.icon && (D_(this.params.icon) ? t.appendChild(this.params.icon) : typeof this.params.icon == "string" ? t.innerHTML = this.params.icon : console.warn("AG Grid: menu item icon must be DOM node or string")), this.getGui().appendChild(t);
      }
    }, e.prototype.addName = function() {
      if (!(!this.params.name && this.params.isCompact)) {
        var t = Dr(
          /* html */
          '<span ref="eName" class="' + this.getClassName("part") + " " + this.getClassName("text") + '">' + (this.params.name || "") + "</span>"
        );
        this.getGui().appendChild(t);
      }
    }, e.prototype.addTooltip = function() {
      this.params.tooltip && (this.tooltip = this.params.tooltip, this.gridOptionsWrapper.isEnableBrowserTooltips() ? this.getGui().setAttribute("title", this.tooltip) : this.createManagedBean(new LS(this)));
    }, e.prototype.getTooltipParams = function() {
      return {
        location: "menu",
        value: this.tooltip
      };
    }, e.prototype.addShortcut = function() {
      if (!(!this.params.shortcut && this.params.isCompact)) {
        var t = Dr(
          /* html */
          '<span ref="eShortcut" class="' + this.getClassName("part") + " " + this.getClassName("shortcut") + '">' + (this.params.shortcut || "") + "</span>"
        );
        this.getGui().appendChild(t);
      }
    }, e.prototype.addSubMenu = function() {
      if (!(!this.params.subMenu && this.params.isCompact)) {
        var t = Dr(
          /* html */
          '<span ref="ePopupPointer" class="' + this.getClassName("part") + " " + this.getClassName("popup-pointer") + '"></span>'
        ), i = this.getGui();
        if (this.params.subMenu) {
          var r = this.gridOptionsWrapper.isEnableRtl() ? "smallLeft" : "smallRight";
          _s(i, !1), t.appendChild(Kn(r, this.gridOptionsWrapper));
        }
        i.appendChild(t);
      }
    }, e.prototype.onItemSelected = function(t) {
      if (this.params.action ? this.params.action() : this.openSubMenu(t && t.type === "keydown"), !(this.params.subMenu && !this.params.action)) {
        var i = {
          type: e.EVENT_MENU_ITEM_SELECTED,
          action: this.params.action,
          checked: this.params.checked,
          cssClasses: this.params.cssClasses,
          disabled: this.params.disabled,
          icon: this.params.icon,
          name: this.params.name,
          shortcut: this.params.shortcut,
          subMenu: this.params.subMenu,
          tooltip: this.params.tooltip,
          event: t
        };
        this.dispatchEvent(i);
      }
    }, e.prototype.onItemActivated = function() {
      var t = {
        type: e.EVENT_MENU_ITEM_ACTIVATED,
        menuItem: this
      };
      this.dispatchEvent(t);
    }, e.prototype.cancelActivate = function() {
      this.activateTimeoutId && (window.clearTimeout(this.activateTimeoutId), this.activateTimeoutId = 0);
    }, e.prototype.cancelDeactivate = function() {
      this.deactivateTimeoutId && (window.clearTimeout(this.deactivateTimeoutId), this.deactivateTimeoutId = 0);
    }, e.prototype.onMouseEnter = function() {
      var t = this;
      this.cancelDeactivate(), this.params.isAnotherSubMenuOpen() ? this.activateTimeoutId = window.setTimeout(function() {
        return t.activate(!0);
      }, e.ACTIVATION_DELAY) : this.activate(!0);
    }, e.prototype.onMouseLeave = function() {
      var t = this;
      this.cancelActivate(), this.isSubMenuOpen() ? this.deactivateTimeoutId = window.setTimeout(function() {
        return t.deactivate();
      }, e.ACTIVATION_DELAY) : this.deactivate();
    }, e.prototype.getClassName = function(t) {
      var i = this.params.isCompact ? "ag-compact-menu-option" : "ag-menu-option";
      return t ? i + "-" + t : i;
    }, e.EVENT_MENU_ITEM_SELECTED = "menuItemSelected", e.EVENT_MENU_ITEM_ACTIVATED = "menuItemActivated", e.ACTIVATION_DELAY = 80, GM([
      R("popupService")
    ], e.prototype, "popupService", void 0), GM([
      Ee
    ], e.prototype, "init", null), e;
  }(St)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var TQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), qC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, OQ = (
  /** @class */
  function(n) {
    TQ(e, n);
    function e(t, i, r) {
      t === void 0 && (t = "default"), i === void 0 && (i = "listbox");
      var o = n.call(this, e.getTemplate(t)) || this;
      return o.cssIdentifier = t, o.ariaRole = i, o.listName = r, o.renderedRows = /* @__PURE__ */ new Map(), o.rowHeight = 20, o.isDestroyed = !1, o;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.addScrollListener(), this.rowHeight = this.getItemHeight(), this.addResizeObserver(), this.initialiseTabGuard({
        onFocusIn: function(i) {
          return t.onFocusIn(i);
        },
        onFocusOut: function(i) {
          return t.onFocusOut(i);
        },
        focusInnerElement: function(i) {
          return t.focusInnerElement(i);
        },
        onTabKeyDown: function(i) {
          return t.onTabKeyDown(i);
        },
        handleKeyDown: function(i) {
          return t.handleKeyDown(i);
        }
      }), this.setAriaProperties();
    }, e.prototype.setAriaProperties = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = t("ariaDefaultListName", this.listName || "List"), r = this.eContainer;
      So(r, this.ariaRole), Ud(r, i);
    }, e.prototype.addResizeObserver = function() {
      var t = this.drawVirtualRows.bind(this), i = this.resizeObserverService.observeResize(this.getGui(), t);
      this.addDestroyFunc(i);
    }, e.prototype.focusInnerElement = function(t) {
      this.focusRow(t ? this.model.getRowCount() - 1 : 0);
    }, e.prototype.onFocusIn = function(t) {
      var i = t.target;
      return i.classList.contains("ag-virtual-list-item") && (this.lastFocusedRowIndex = EB(i) - 1), !1;
    }, e.prototype.onFocusOut = function(t) {
      return this.getFocusableElement().contains(t.relatedTarget) || (this.lastFocusedRowIndex = null), !1;
    }, e.prototype.handleKeyDown = function(t) {
      switch (t.key) {
        case pe.UP:
        case pe.DOWN:
          this.navigate(t.key === pe.UP) && t.preventDefault();
          break;
      }
    }, e.prototype.onTabKeyDown = function(t) {
      this.navigate(t.shiftKey) ? t.preventDefault() : this.focusService.focusInto(this.getGui(), !t.shiftKey);
    }, e.prototype.navigate = function(t) {
      if (this.lastFocusedRowIndex == null)
        return !1;
      var i = this.lastFocusedRowIndex + (t ? -1 : 1);
      return i < 0 || i >= this.model.getRowCount() ? !1 : (this.focusRow(i), !0);
    }, e.prototype.getLastFocusedRow = function() {
      return this.lastFocusedRowIndex;
    }, e.prototype.focusRow = function(t) {
      var i = this;
      this.ensureIndexVisible(t), window.setTimeout(function() {
        var r = i.renderedRows.get(t);
        r && r.eDiv.focus();
      }, 10);
    }, e.prototype.getComponentAt = function(t) {
      var i = this.renderedRows.get(t);
      return i && i.rowComponent;
    }, e.getTemplate = function(t) {
      return (
        /* html */
        `
            <div class="ag-virtual-list-viewport ag-` + t + `-virtual-list-viewport" role="presentation">
                <div class="ag-virtual-list-container ag-` + t + `-virtual-list-container" ref="eContainer"></div>
            </div>`
      );
    }, e.prototype.getItemHeight = function() {
      return this.gridOptionsWrapper.getListItemHeight();
    }, e.prototype.ensureIndexVisible = function(t) {
      var i = this.model.getRowCount();
      if (typeof t != "number" || t < 0 || t >= i) {
        console.warn("AG Grid: invalid row index for ensureIndexVisible: " + t);
        return;
      }
      var r = t * this.rowHeight, o = r + this.rowHeight, s = this.getGui(), a = s.scrollTop, l = s.offsetHeight, u = a + l, c = a > r, h = u < o;
      if (c)
        s.scrollTop = r;
      else if (h) {
        var d = o - l;
        s.scrollTop = d;
      }
    }, e.prototype.setComponentCreator = function(t) {
      this.componentCreator = t;
    }, e.prototype.getRowHeight = function() {
      return this.rowHeight;
    }, e.prototype.getScrollTop = function() {
      return this.getGui().scrollTop;
    }, e.prototype.setRowHeight = function(t) {
      this.rowHeight = t, this.refresh();
    }, e.prototype.refresh = function() {
      var t = this;
      if (!(this.model == null || this.isDestroyed)) {
        var i = this.model.getRowCount();
        this.eContainer.style.height = i * this.rowHeight + "px", UV(function() {
          return t.eContainer.clientHeight >= i * t.rowHeight;
        }, function() {
          t.isDestroyed || (t.clearVirtualRows(), t.drawVirtualRows());
        });
      }
    }, e.prototype.clearVirtualRows = function() {
      var t = this;
      this.renderedRows.forEach(function(i, r) {
        return t.removeRow(r);
      });
    }, e.prototype.drawVirtualRows = function() {
      var t = this.getGui(), i = t.scrollTop, r = i + t.offsetHeight, o = Math.floor(i / this.rowHeight), s = Math.floor(r / this.rowHeight);
      this.ensureRowsRendered(o, s);
    }, e.prototype.ensureRowsRendered = function(t, i) {
      var r = this;
      this.renderedRows.forEach(function(s, a) {
        (a < t || a > i) && a !== r.lastFocusedRowIndex && r.removeRow(a);
      });
      for (var o = t; o <= i; o++)
        this.renderedRows.has(o) || o < this.model.getRowCount() && this.insertRow(o);
    }, e.prototype.insertRow = function(t) {
      var i = this, r = this.model.getRow(t), o = document.createElement("div");
      if (o.classList.add("ag-virtual-list-item", "ag-" + this.cssIdentifier + "-virtual-list-item"), So(o, this.ariaRole === "tree" ? "treeitem" : "option"), rx(o, this.model.getRowCount()), ox(o, t + 1), o.setAttribute("tabindex", "-1"), typeof this.model.isRowSelected == "function") {
        var s = this.model.isRowSelected(t);
        Fp(o, !!s), IB(o, s);
      }
      o.style.height = this.rowHeight + "px", o.style.top = this.rowHeight * t + "px";
      var a = this.componentCreator(r, o);
      a.addGuiEventListener("focusin", function() {
        return i.lastFocusedRowIndex = t;
      }), o.appendChild(a.getGui()), this.renderedRows.has(t - 1) ? this.renderedRows.get(t - 1).eDiv.insertAdjacentElement("afterend", o) : this.renderedRows.has(t + 1) ? this.renderedRows.get(t + 1).eDiv.insertAdjacentElement("beforebegin", o) : this.eContainer.appendChild(o), this.renderedRows.set(t, { rowComponent: a, eDiv: o });
    }, e.prototype.removeRow = function(t) {
      var i = this.renderedRows.get(t);
      this.eContainer.removeChild(i.eDiv), this.destroyBean(i.rowComponent), this.renderedRows.delete(t);
    }, e.prototype.addScrollListener = function() {
      var t = this;
      this.addGuiEventListener("scroll", function() {
        return t.drawVirtualRows();
      });
    }, e.prototype.setModel = function(t) {
      this.model = t;
    }, e.prototype.destroy = function() {
      this.isDestroyed || (this.clearVirtualRows(), this.isDestroyed = !0, n.prototype.destroy.call(this));
    }, qC([
      R("resizeObserverService")
    ], e.prototype, "resizeObserverService", void 0), qC([
      R("focusService")
    ], e.prototype, "focusService", void 0), qC([
      fe("eContainer")
    ], e.prototype, "eContainer", void 0), qC([
      Ee
    ], e.prototype, "postConstruct", null), e;
  }(T_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function xQ(n, e, t, i, r) {
  r === void 0 && (r = !1), console.warn("AG Grid: Since ag-grid 11.0.0 defaultGroupComparator is not necessary. You can remove this from your colDef");
  var o = de(t) && t.group, s = de(i) && i.group, a = o && s, l = !o && !s;
  return a ? v1(t.key, i.key, r) : l ? v1(n, e, r) : o ? 1 : -1;
}
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var NQ = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.wrap = function(e, t, i, r) {
      var o = this;
      i === void 0 && (i = []);
      var s = this.createWrapper(e, r);
      return t.forEach(function(a) {
        o.createMethod(s, a, !0);
      }), i.forEach(function(a) {
        o.createMethod(s, a, !1);
      }), s;
    }, n.prototype.unwrap = function(e) {
      return e;
    }, n.prototype.createMethod = function(e, t, i) {
      e.addMethod(t, this.createMethodProxy(e, t, i));
    }, n.prototype.createMethodProxy = function(e, t, i) {
      return function() {
        return e.hasMethod(t) ? e.callMethod(t, arguments) : (i && console.warn("AG Grid: Framework component is missing the method " + t + "()"), null);
      };
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var z1;
(function(n) {
  n.InsideBase = "insideBase", n.InsideEnd = "insideEnd", n.Center = "center", n.OutsideEnd = "outsideEnd";
})(z1 || (z1 = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var pg = typeof global > "u" ? {} : global;
pg.HTMLElement = typeof HTMLElement > "u" ? {} : HTMLElement;
pg.HTMLButtonElement = typeof HTMLButtonElement > "u" ? {} : HTMLButtonElement;
pg.HTMLSelectElement = typeof HTMLSelectElement > "u" ? {} : HTMLSelectElement;
pg.HTMLInputElement = typeof HTMLInputElement > "u" ? {} : HTMLInputElement;
pg.Node = typeof Node > "u" ? {} : Node;
pg.MouseEvent = typeof MouseEvent > "u" ? {} : MouseEvent;
const IQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbstractHeaderCellCtrl: R_,
  AgAbstractField: Fl,
  AgAngleSelect: h4,
  AgCheckbox: kp,
  AgColorPicker: l4,
  AgDialog: Dx,
  AgGroupComponent: n4,
  AgInputNumberField: u4,
  AgInputRange: c4,
  AgInputTextArea: s4,
  AgInputTextField: Rx,
  AgMenuItemComponent: Pf,
  AgMenuList: D4,
  AgMenuPanel: R4,
  AgPanel: Lx,
  AgPromise: ko,
  get AgPromiseStatus() {
    return Zh;
  },
  AgRadioButton: jH,
  AgSelect: dx,
  AgSlider: a4,
  AgStackComponentsRegistry: oB,
  AgToggleButton: d4,
  AlignedGridsService: ZH,
  AnimateShowChangeCellRenderer: QB,
  AnimateSlideCellRenderer: JB,
  AnimationFrameService: JH,
  AutoScrollService: LH,
  AutoWidthCalculator: MH,
  Autowired: R,
  get BarColumnLabelPlacement() {
    return z1;
  },
  BaseComponentWrapper: NQ,
  Bean: Ke,
  BeanStub: we,
  Beans: Cx,
  BodyDropPivotTarget: gH,
  BodyDropTarget: mH,
  CellComp: w4,
  CellCtrl: jc,
  CellNavigationService: UH,
  CellPositionUtils: p4,
  get CellRangeType() {
    return Qh;
  },
  ChangedPath: vx,
  CheckboxSelectionComponent: mx,
  get ClientSideRowModelSteps() {
    return ea;
  },
  ColDefUtil: E1,
  Color: If,
  Column: Gt,
  ColumnApi: aH,
  ColumnFactory: QV,
  ColumnGroup: Yr,
  ColumnKeyCreator: AV,
  ColumnModel: iB,
  ColumnUtils: nB,
  Component: St,
  ComponentUtil: zc,
  Constants: q,
  Context: jV,
  CssClassApplier: Sx,
  CssClassManager: HB,
  CtrlsService: C4,
  CustomTooltipFeature: LS,
  DateFilter: fx,
  DisplayedGroupCreator: rB,
  DragAndDropService: _o,
  DragService: BH,
  get DragSourceType() {
    return ws;
  },
  Environment: QH,
  EventService: Zu,
  Events: I,
  get ExcelFactoryMode() {
    return sp;
  },
  ExpressionService: NH,
  FilterManager: SH,
  FloatingFilterMapper: nH,
  FocusService: ap,
  Grid: E4,
  GridApi: vH,
  GridBodyComp: xH,
  GridBodyCtrl: OH,
  GridComp: VH,
  GridCoreCreator: L4,
  GridCtrl: kH,
  GridHeaderComp: bH,
  GridHeaderCtrl: fH,
  GridOptionsWrapper: Ve,
  GroupCellRenderer: F1,
  GroupCellRendererCtrl: tH,
  GroupInstanceIdCreator: JV,
  HeaderCellCtrl: CH,
  HeaderFilterCellComp: cH,
  HeaderFilterCellCtrl: _H,
  HeaderGroupCellCtrl: yH,
  get HeaderNavigationDirection() {
    return Wa;
  },
  HeaderNavigationService: dH,
  HeaderPositionUtils: m4,
  HeaderRowComp: hH,
  HeaderRowContainerComp: $y,
  HeaderRowContainerCtrl: wH,
  HeaderRowCtrl: jy,
  get HeaderRowType() {
    return Xr;
  },
  get HorizontalDirection() {
    return ka;
  },
  HorizontalResizeService: FH,
  KeyCode: pe,
  LargeTextCellEditor: YB,
  get LayoutCssClasses() {
    return Fn;
  },
  Logger: zw,
  LoggerFactory: AH,
  ManagedFocusFeature: Qu,
  get ModuleNames() {
    return ct;
  },
  ModuleRegistry: pt,
  MouseEventService: GH,
  MoveColumnFeature: pH,
  NavigationService: e4,
  NumberFilter: px,
  NumberSequence: ES,
  Optional: fi,
  PaginationProxy: YH,
  PinnedRowModel: g4,
  PopupComponent: fg,
  PopupEditorWrapper: y4,
  PopupSelectCellEditor: XB,
  PopupService: PH,
  PopupTextCellEditor: ZB,
  PositionableFeature: o4,
  PostConstruct: Ee,
  PreConstruct: C1,
  PreDestroy: Lo,
  PropertyKeys: Ol,
  ProvidedColumnGroup: fn,
  ProvidedFilter: Fv,
  Qualifier: wo,
  QuerySelector: N$,
  RefSelector: fe,
  ResizeObserverService: i4,
  get RowAnimationCssClasses() {
    return Dd;
  },
  RowContainerComp: b4,
  RowContainerCtrl: Gw,
  get RowContainerName() {
    return _e;
  },
  get RowContainerType() {
    return Fo;
  },
  RowCtrl: $c,
  get RowHighlightPosition() {
    return Ed;
  },
  RowNode: kt,
  RowNodeBlock: B1,
  RowNodeBlockLoader: v4,
  RowNodeSorter: _4,
  RowPositionUtils: f4,
  RowRenderer: uH,
  ScalarFilter: ur,
  ScrollVisibleService: KH,
  SelectCellEditor: gx,
  SelectableService: t4,
  get SelectionHandleType() {
    return kv;
  },
  SelectionService: sH,
  get ServerSideTransactionResultStatus() {
    return U1;
  },
  SetLeftFeature: TS,
  SimpleFilter: bn,
  SortController: HH,
  StandardMenuFactory: S4,
  StylingService: qH,
  TabGuardComp: T_,
  TabGuardCtrl: WH,
  TabbedLayout: bQ,
  TemplateService: IH,
  TextCellEditor: Ww,
  TextFilter: DS,
  TextFloatingFilter: qB,
  Timer: R$,
  TouchListener: la,
  UserComponentFactory: rH,
  UserComponentRegistry: iH,
  ValueCache: XH,
  ValueFormatterService: zH,
  ValueService: EH,
  VanillaFrameworkOverrides: $H,
  get VerticalDirection() {
    return Ld;
  },
  VirtualList: OQ,
  _: Sd,
  defaultGroupComparator: xQ,
  getRowContainerTypeForName: lH,
  initialiseAgGridWithAngular1: CQ,
  simpleHttpRequest: SQ,
  stringToArray: sB
}, Symbol.toStringTag, { value: "Module" }));
var Tx = {}, Ox = {};
const gr = /* @__PURE__ */ OO(IQ);
var xx = {}, OS = {};
Object.defineProperty(OS, "__esModule", { value: !0 });
class PQ {
}
class AQ extends PQ {
  constructor(e, t, i) {
    super(), this.portal = null, this.reactComponent = e, this.portalManager = t, this.componentType = i, this.statelessComponent = this.isStateless(this.reactComponent);
  }
  getGui() {
    return this.eParentElement;
  }
  destroy() {
    return this.componentInstance && typeof this.componentInstance.destroy == "function" && this.componentInstance.destroy(), this.portalManager.destroyPortal(this.portal);
  }
  createParentElement(e) {
    const t = this.portalManager.getComponentWrappingElement(), i = document.createElement(t || "div");
    return i.classList.add("ag-react-container"), e.reactContainer = i, i;
  }
  addParentContainerStyleAndClasses() {
    this.componentInstance && (this.componentInstance.getReactContainerStyle && this.componentInstance.getReactContainerStyle() && Object.assign(this.eParentElement.style, this.componentInstance.getReactContainerStyle()), this.componentInstance.getReactContainerClasses && this.componentInstance.getReactContainerClasses() && this.componentInstance.getReactContainerClasses().forEach((t) => this.eParentElement.classList.add(t)));
  }
  statelessComponentRendered() {
    return this.eParentElement.childElementCount > 0 || this.eParentElement.childNodes.length > 0;
  }
  getFrameworkComponentInstance() {
    return this.componentInstance;
  }
  isStatelessComponent() {
    return this.statelessComponent;
  }
  getReactComponentName() {
    return this.reactComponent.name;
  }
  getMemoType() {
    return this.hasSymbol() ? Symbol.for("react.memo") : 60115;
  }
  hasSymbol() {
    return typeof Symbol == "function" && Symbol.for;
  }
  isStateless(e) {
    return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === this.getMemoType();
  }
  hasMethod(e) {
    const t = this.getFrameworkComponentInstance();
    return !!t && t[e] !== null || this.fallbackMethodAvailable(e);
  }
  callMethod(e, t) {
    const i = this.getFrameworkComponentInstance();
    if (this.isStatelessComponent())
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
    if (!i) {
      setTimeout(() => this.callMethod(e, t));
      return;
    }
    const r = i[e];
    if (r)
      return r.apply(i, t);
    if (this.fallbackMethodAvailable(e))
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
  }
  addMethod(e, t) {
    this[e] = t;
  }
}
OS.ReactComponent = AQ;
var xS = {};
Object.defineProperty(xS, "__esModule", { value: !0 });
let MQ = 0;
function FQ() {
  return `agPortalKey_${++MQ}`;
}
xS.default = FQ;
var kQ = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(xx, "__esModule", { value: !0 });
const UM = wt, WQ = rg, VQ = gr, BQ = OS, HQ = UW, GQ = kQ(xS);
class NS extends BQ.ReactComponent {
  constructor(e, t, i, r) {
    super(e, i, r), this.staticMarkup = null, this.staticRenderTime = 0, this.parentComponent = t;
  }
  init(e) {
    return this.eParentElement = this.createParentElement(e), this.renderStaticMarkup(e), new VQ.AgPromise((t) => this.createReactComponent(e, t));
  }
  createReactComponent(e, t) {
    this.isStatelessComponent() || (e.ref = (o) => {
      this.componentInstance = o, this.addParentContainerStyleAndClasses(), this.removeStaticMarkup();
    });
    const i = UM.createElement(this.reactComponent, e), r = WQ.createPortal(
      i,
      this.eParentElement,
      GQ.default()
      // fixed deltaRowModeRefreshCompRenderer
    );
    this.portal = r, this.portalManager.mountReactPortal(r, this, (o) => {
      t(o), this.isStatelessComponent() && (this.isSlowRenderer() && this.removeStaticMarkup(), setTimeout(() => {
        this.removeStaticMarkup();
      }));
    });
  }
  fallbackMethodAvailable(e) {
    return !1;
  }
  fallbackMethod(e, t) {
  }
  isSlowRenderer() {
    return this.staticRenderTime >= NS.SLOW_RENDERING_THRESHOLD;
  }
  isNullValue() {
    return this.staticMarkup === "";
  }
  /*
   * Attempt to render the component as static markup if possible
   * What this does is eliminate any visible flicker for the user in the scenario where a component is destroyed and
   * recreated with exactly the same data (ie with force refresh)
   * Note: Some use cases will throw an error (ie when using Context) so if an error occurs just ignore it any move on
   */
  renderStaticMarkup(e) {
    if (this.parentComponent.isDisableStaticMarkup() || !this.componentType.cellRenderer)
      return;
    const t = console.error, i = UM.createElement(this.reactComponent, e);
    try {
      console.error = () => {
      };
      const r = Date.now(), o = HQ.renderToStaticMarkup(i);
      this.staticRenderTime = Date.now() - r, console.error = t, o === "" ? this.staticMarkup = o : o && (this.staticMarkup = document.createElement("span"), this.staticMarkup.innerHTML = o, this.eParentElement.appendChild(this.staticMarkup));
    } catch {
    } finally {
      console.error = t;
    }
  }
  removeStaticMarkup() {
    this.parentComponent.isDisableStaticMarkup() || !this.componentType.cellRenderer || this.staticMarkup && (this.staticMarkup.remove ? (this.staticMarkup.remove(), this.staticMarkup = null) : this.eParentElement.removeChild && (this.eParentElement.removeChild(this.staticMarkup), this.staticMarkup = null));
  }
  rendered() {
    return this.isNullValue() || !!this.staticMarkup || this.isStatelessComponent() && this.statelessComponentRendered() || !!(!this.isStatelessComponent() && this.getFrameworkComponentInstance());
  }
}
xx.LegacyReactComponent = NS;
NS.SLOW_RENDERING_THRESHOLD = 3;
var O_ = {}, UQ = Ne && Ne.__rest || function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
}, T4 = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, zQ = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(O_, "__esModule", { value: !0 });
const NL = T4(wt), gg = zQ(ju), mg = T4(gr);
class lp extends NL.Component {
  constructor(e) {
    super(e), this.props = e;
  }
  render() {
    return null;
  }
  static mapChildColumnDefs(e) {
    return NL.default.Children.map(e, (t) => t ? lp.toColDef(t.props) : null);
  }
  static toColDef(e) {
    const { children: t } = e, i = UQ(e, ["children"]);
    return lp.hasChildColumns(t) && (i.children = lp.mapChildColumnDefs(t)), i;
  }
  static hasChildColumns(e) {
    return NL.default.Children.count(e) > 0;
  }
}
O_.AgGridColumn = lp;
vg(mg.ColDefUtil.BOOLEAN_PROPERTIES, gg.default.bool);
vg(mg.ColDefUtil.STRING_PROPERTIES, gg.default.string);
vg(mg.ColDefUtil.OBJECT_PROPERTIES, gg.default.object);
vg(mg.ColDefUtil.ARRAY_PROPERTIES, gg.default.array);
vg(mg.ColDefUtil.NUMBER_PROPERTIES, gg.default.number);
vg(mg.ColDefUtil.FUNCTION_PROPERTIES, gg.default.func);
function vg(n, e) {
  n.forEach((t) => {
    lp[t] = e;
  });
}
var IS = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 });
  var e;
  (function(o) {
    o.IdentityCheck = "IdentityCheck", o.DeepValueCheck = "DeepValueCheck", o.NoCheck = "NoCheck";
  })(e = n.ChangeDetectionStrategyType || (n.ChangeDetectionStrategyType = {}));
  class t {
    constructor(s) {
      this.strategy = s;
    }
    areEqual(s, a) {
      return this.strategy(s, a);
    }
  }
  class i {
    areEqual(s, a) {
      return i.areEquivalent(i.copy(s), i.copy(a));
    }
    /*
     * deeper object comparison - taken from https://stackoverflow.com/questions/1068834/object-comparison-in-javascript
     */
    static unwrapStringOrNumber(s) {
      return s instanceof Number || s instanceof String ? s.valueOf() : s;
    }
    // sigh, here for ie compatibility
    static copy(s) {
      if (!s)
        return s;
      if (Array.isArray(s)) {
        const a = [];
        for (let l = 0; l < s.length; l++)
          a.push(this.copy(s[l]));
        return a;
      }
      return typeof s != "object" ? s : [{}, s].reduce((a, l) => (Object.keys(l).forEach(function(u) {
        a[u] = l[u];
      }), a), {});
    }
    static isNaN(s) {
      return Number.isNaN ? Number.isNaN(s) : typeof s == "number" && isNaN(s);
    }
    /*
     * slightly modified, but taken from https://stackoverflow.com/questions/1068834/object-comparison-in-javascript
     *
     * What we're trying to do here is determine if the property being checked has changed in _value_, not just in reference
     *
     * For eg, if a user updates the columnDefs via property binding, but the actual columns defs are the same before and
     * after, then we don't want the grid to re-render
     */
    static areEquivalent(s, a) {
      if (s = i.unwrapStringOrNumber(s), a = i.unwrapStringOrNumber(a), s === a)
        return !0;
      if (s === null || a === null || typeof s != typeof a)
        return !1;
      if (i.isNaN(s) && i.isNaN(a))
        return !0;
      if (s instanceof Date)
        return a instanceof Date && s.valueOf() === a.valueOf();
      if (typeof s == "function")
        return !1;
      if (typeof s != "object" || s.$$typeof && s.$$typeof.toString() === "Symbol(react.element)")
        return s == a;
      if (Object.isFrozen(s) || Object.isFrozen(a))
        return s === a;
      const l = s.areEquivPropertyTracking === void 0, u = a.areEquivPropertyTracking === void 0;
      try {
        let c;
        if (l)
          s.areEquivPropertyTracking = [];
        else if (s.areEquivPropertyTracking.some(function(d) {
          return d === a;
        }))
          return !0;
        if (u)
          a.areEquivPropertyTracking = [];
        else if (a.areEquivPropertyTracking.some((d) => d === s))
          return !0;
        s.areEquivPropertyTracking.push(a), a.areEquivPropertyTracking.push(s);
        const h = {};
        for (c in s)
          c != "areEquivPropertyTracking" && (h[c] = null);
        for (c in a)
          c != "areEquivPropertyTracking" && (h[c] = null);
        for (c in h)
          if (!this.areEquivalent(s[c], a[c]))
            return !1;
        return !0;
      } finally {
        l && delete s.areEquivPropertyTracking, u && delete a.areEquivPropertyTracking;
      }
    }
  }
  class r {
    constructor() {
      this.strategyMap = {
        [e.DeepValueCheck]: new i(),
        [e.IdentityCheck]: new t((s, a) => s === a),
        [e.NoCheck]: new t((s, a) => !1)
      };
    }
    getStrategy(s) {
      return this.strategyMap[s];
    }
  }
  n.ChangeDetectionService = r;
})(IS);
var PS = {}, jQ = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(PS, "__esModule", { value: !0 });
const zM = wt, $Q = rg, KQ = gr, qQ = OS, YQ = UW, jM = jQ(xS);
class XQ extends qQ.ReactComponent {
  constructor(e, t, i) {
    super(e, t, i), this.oldPortal = null, this.key = jM.default(), this.portalKey = jM.default();
  }
  init(e) {
    return this.eParentElement = this.createParentElement(e), this.params = e, this.createOrUpdatePortal(e), new KQ.AgPromise((t) => this.createReactComponent(t));
  }
  createOrUpdatePortal(e) {
    this.isStatelessComponent() || (e.ref = (t) => {
      this.componentInstance = t, this.addParentContainerStyleAndClasses();
    }), this.reactElement = zM.createElement(this.reactComponent, Object.assign(Object.assign({}, e), { key: this.key })), this.portal = $Q.createPortal(
      this.reactElement,
      this.eParentElement,
      this.portalKey
      // fixed deltaRowModeRefreshCompRenderer
    );
  }
  createReactComponent(e) {
    this.portalManager.mountReactPortal(this.portal, this, (t) => {
      e(t);
    });
  }
  isNullValue() {
    return this.valueRenderedIsNull(this.params);
  }
  rendered() {
    return this.isStatelessComponent() && this.statelessComponentRendered() || !!(!this.isStatelessComponent() && this.getFrameworkComponentInstance());
  }
  valueRenderedIsNull(e) {
    if (!this.componentType.cellRenderer)
      return !1;
    const t = console.error;
    try {
      return console.error = () => {
      }, YQ.renderToStaticMarkup(zM.createElement(this.reactComponent, e)) === "";
    } catch {
    } finally {
      console.error = t;
    }
    return !1;
  }
  /*
  * fallback methods - these will be invoked if a corresponding instance method is not present
  * for example if refresh is called and is not available on the component instance, then refreshComponent on this
  * class will be invoked instead
  *
  * Currently only refresh is supported
  */
  refreshComponent(e) {
    this.oldPortal = this.portal, this.createOrUpdatePortal(e), this.portalManager.updateReactPortal(this.oldPortal, this.portal);
  }
  fallbackMethod(e, t) {
    const i = this[`${e}Component`];
    if (i)
      return i.bind(this)(t);
  }
  fallbackMethodAvailable(e) {
    return !!this[`${e}Component`];
  }
}
PS.NewReactComponent = XQ;
var AS = {};
Object.defineProperty(AS, "__esModule", { value: !0 });
class MS {
  constructor(e, t, i) {
    this.destroyed = !1, this.portals = [], this.hasPendingPortalUpdate = !1, this.wrappingElement = t || "div", this.parent = e, this.maxComponentCreationTimeMs = i || MS.MAX_COMPONENT_CREATION_TIME_IN_MS;
  }
  getPortals() {
    return this.portals;
  }
  destroy() {
    this.destroyed = !0;
  }
  destroyPortal(e) {
    this.portals = this.portals.filter((t) => t !== e), this.batchUpdate();
  }
  getComponentWrappingElement() {
    return this.wrappingElement;
  }
  mountReactPortal(e, t, i) {
    this.portals = [...this.portals, e], this.waitForInstance(t, i), this.batchUpdate();
  }
  updateReactPortal(e, t) {
    this.portals[this.portals.indexOf(e)] = t, this.batchUpdate();
  }
  batchUpdate() {
    this.hasPendingPortalUpdate || (setTimeout(() => {
      this.destroyed || this.parent.forceUpdate(() => {
        this.hasPendingPortalUpdate = !1;
      });
    }), this.hasPendingPortalUpdate = !0);
  }
  waitForInstance(e, t, i = Date.now()) {
    if (this.destroyed) {
      t(null);
      return;
    }
    if (e.rendered())
      t(e);
    else {
      if (Date.now() - i >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate) {
        if (e.isNullValue()) {
          t(e);
          return;
        }
        console.error(`AG Grid: React Component '${e.getReactComponentName()}' not created within ${this.maxComponentCreationTimeMs}ms`);
        return;
      }
      window.setTimeout(() => {
        this.waitForInstance(e, t, i);
      });
    }
  }
}
AS.PortalManager = MS;
MS.MAX_COMPONENT_CREATION_TIME_IN_MS = 1e3;
var YC = {}, Nx = {}, Rr = {}, ZQ = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(Rr, "__esModule", { value: !0 });
const QQ = ZQ(wt);
Rr.BeansContext = QQ.default.createContext({});
var Ju = {};
Object.defineProperty(Ju, "__esModule", { value: !0 });
Ju.showJsComp = (n, e, t, i) => {
  if (!n || n.componentFromFramework)
    return;
  const o = n.newAgStackInstance();
  if (!o)
    return;
  let s, a, l = !1;
  return o.then((u) => {
    if (l) {
      e.destroyBean(u);
      return;
    }
    s = u, a = s.getGui(), t.appendChild(a), $M(i, s);
  }), () => {
    l = !0, s && (a && a.parentElement && a.parentElement.removeChild(a), e.destroyBean(s), i && $M(i, void 0));
  };
};
const $M = (n, e) => {
  if (n)
    if (n instanceof Function)
      n(e);
    else {
      const t = n;
      t.current = e;
    }
};
Ju.createSyncJsComp = (n) => {
  const e = n.newAgStackInstance();
  if (e)
    return e.resolveNow(null, (t) => t);
};
var no = {};
Object.defineProperty(no, "__esModule", { value: !0 });
no.classesList = (...n) => n.filter((t) => t != null && t !== "").join(" ");
class Ix {
  constructor() {
    this.classesMap = {};
  }
  setClass(e, t) {
    if (!!this.classesMap[e] == t)
      return this;
    const r = new Ix();
    return r.classesMap = Object.assign({}, this.classesMap), r.classesMap[e] = t, r;
  }
  toString() {
    return Object.keys(this.classesMap).filter((t) => this.classesMap[t]).join(" ");
  }
}
no.CssClasses = Ix;
no.isComponentStateless = (n) => {
  const e = () => typeof Symbol == "function" && Symbol.for, t = () => e() ? Symbol.for("react.memo") : 60115;
  return typeof n == "function" && !(n.prototype && n.prototype.isReactComponent) || typeof n == "object" && n.$$typeof === t();
};
var JQ = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(Nx, "__esModule", { value: !0 });
const eJ = gr, Ci = JQ(wt), tJ = Rr, iJ = Ju, XC = no, O4 = Ci.forwardRef((n, e) => {
  const t = Ci.useContext(tJ.BeansContext).context, i = Ci.useRef(null), r = Ci.useRef(null), o = Ci.useRef(null), s = Ci.useRef(null), a = Ci.useRef(null), [l, u] = Ci.useState(), [c, h] = Ci.useState(), [d, f] = Ci.useState(), [p, g] = Ci.useState(new XC.CssClasses()), [_, m] = Ci.useState(new XC.CssClasses()), [v, C] = Ci.useState(new XC.CssClasses()), [y, b] = Ci.useState(new XC.CssClasses());
  Ci.useImperativeHandle(e, () => ({
    // force new instance when grid tries to refresh
    refresh() {
      return !1;
    }
  })), Ci.useEffect(() => iJ.showJsComp(l, t, r.current), [l]), Ci.useEffect(() => {
    const P = {
      setInnerRenderer: (U, $) => {
        u(U), f($);
      },
      setChildCount: (U) => h(U),
      addOrRemoveCssClass: (U, $) => g((k) => k.setClass(U, $)),
      setContractedDisplayed: (U) => C(($) => $.setClass("ag-hidden", !U)),
      setExpandedDisplayed: (U) => m(($) => $.setClass("ag-hidden", !U)),
      setCheckboxVisible: (U) => {
        b(($) => $.setClass("ag-invisible", !U));
      }
    }, G = t.createBean(new eJ.GroupCellRendererCtrl());
    return G.init(P, i.current, o.current, s.current, a.current, O4, n), () => {
      t.destroyBean(G);
    };
  }, []);
  const L = Ci.useMemo(() => `ag-cell-wrapper ${p.toString()}`, [p]), S = Ci.useMemo(() => `ag-group-expanded ${_.toString()}`, [_]), E = Ci.useMemo(() => `ag-group-contracted ${v.toString()}`, [v]), D = Ci.useMemo(() => `ag-group-checkbox ${y.toString()}`, [y]), O = l && l.componentFromFramework, T = O ? l.componentClass : void 0, A = l == null && d != null;
  return Ci.default.createElement(
    "span",
    Object.assign({ className: L, ref: i }, n.colDef ? {} : { role: "gridcell" }),
    Ci.default.createElement("span", { className: S, ref: s }),
    Ci.default.createElement("span", { className: E, ref: a }),
    Ci.default.createElement("span", { className: D, ref: o }),
    Ci.default.createElement(
      "span",
      { className: "ag-group-value", ref: r },
      A && Ci.default.createElement(Ci.default.Fragment, null, d),
      O && Ci.default.createElement(T, Object.assign({}, l.params))
    ),
    Ci.default.createElement("span", { className: "ag-group-child-count" }, c)
  );
});
Nx.default = O4;
var ZC = {}, QC = {}, Px = {}, Ax = {}, Mx = {}, Fx = {}, kx = {}, Wx = {}, nJ = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(Wx, "__esModule", { value: !0 });
const An = nJ(wt), rJ = Rr, oJ = gr, sJ = no, aJ = Ju, lJ = (n) => {
  const { context: e } = An.useContext(rJ.BeansContext), [t, i] = An.useState(), [r, o] = An.useState(), [s, a] = An.useState(), [l, u] = An.useState(), [c, h] = An.useState(), [d, f] = An.useState(), p = An.useRef(null), g = An.useRef(null), _ = An.useRef(), { ctrl: m } = n, v = An.useMemo(() => new oJ.CssClassManager(() => p.current), []);
  An.useEffect(() => {
    const S = {
      setWidth: (D) => i(D),
      addOrRemoveCssClass: (D, O) => v.addOrRemoveCssClass(D, O),
      setAriaSort: (D) => u(D),
      setColId: (D) => a(D),
      setTitle: (D) => o(D),
      setAriaDescribedBy: (D) => h(D),
      setUserCompDetails: (D) => f(D),
      getUserCompInstance: () => _.current || void 0
    };
    m.setComp(S, p.current, g.current);
    const E = m.getSelectAllGui();
    g.current.insertAdjacentElement("afterend", E);
  }, []), An.useEffect(() => aJ.showJsComp(d, e, p.current, _), [d]), An.useEffect(() => {
    let S;
    p.current.childNodes.forEach((E) => {
      E != null && E !== g.current && (S = E);
    }), m.setDragSource(S);
  }, [d]);
  const C = An.useMemo(() => ({ width: t }), [t]), y = An.useMemo(() => {
    var S;
    return !!(((S = d) === null || S === void 0 ? void 0 : S.componentFromFramework) && sJ.isComponentStateless(d.componentClass));
  }, [d]), b = d && d.componentFromFramework, L = d && d.componentClass;
  return An.default.createElement(
    "div",
    { ref: p, className: "ag-header-cell", style: C, title: r, "col-id": s, "aria-sort": l, role: "columnheader", tabIndex: -1, "aria-describedby": c },
    An.default.createElement("div", { ref: g, className: "ag-header-cell-resize", role: "presentation" }),
    b && y && An.default.createElement(L, Object.assign({}, d.params)),
    b && !y && An.default.createElement(L, Object.assign({}, d.params, { ref: _ }))
  );
};
Wx.default = An.memo(lJ);
var Vx = {}, uJ = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(Vx, "__esModule", { value: !0 });
const Gn = uJ(wt), cJ = Rr, hJ = Ju, KM = no, dJ = (n) => {
  const { context: e } = Gn.useContext(cJ.BeansContext), [t, i] = Gn.useState(new KM.CssClasses()), [r, o] = Gn.useState(new KM.CssClasses()), [s, a] = Gn.useState(), [l, u] = Gn.useState(), [c, h] = Gn.useState(), [d, f] = Gn.useState(), [p, g] = Gn.useState(), _ = Gn.useRef(null), m = Gn.useRef(null), { ctrl: v } = n;
  Gn.useEffect(() => {
    const E = {
      setWidth: (D) => a(D),
      addOrRemoveCssClass: (D, O) => i((T) => T.setClass(D, O)),
      setColId: (D) => h(D),
      setTitle: (D) => u(D),
      setUserCompDetails: (D) => g(D),
      addOrRemoveResizableCssClass: (D, O) => o((T) => T.setClass(D, O)),
      setAriaExpanded: (D) => f(D)
    };
    v.setComp(E, _.current, m.current);
  }, []), Gn.useEffect(() => hJ.showJsComp(p, e, _.current), [p]), Gn.useEffect(() => {
    let E;
    _.current.childNodes.forEach((D) => {
      D != null && D !== m.current && (E = D);
    }), E && v.setDragSource(E);
  }, [p]);
  const C = Gn.useMemo(() => ({
    width: s
  }), [s]), y = Gn.useMemo(() => "ag-header-group-cell " + t.toString(), [t]), b = Gn.useMemo(() => "ag-header-cell-resize " + r.toString(), [r]), L = p && p.componentFromFramework, S = p && p.componentClass;
  return Gn.default.createElement(
    "div",
    { ref: _, className: y, style: C, title: l, "col-id": c, role: "columnheader", tabIndex: -1, "aria-expanded": d },
    L && Gn.default.createElement(S, Object.assign({}, p.params)),
    Gn.default.createElement("div", { ref: m, className: b })
  );
};
Vx.default = Gn.memo(dJ);
var Bx = {}, fJ = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(Bx, "__esModule", { value: !0 });
const zi = fJ(wt), pJ = Rr, gJ = gr, JC = no, mJ = Ju, vJ = (n) => {
  const { context: e } = zi.useContext(pJ.BeansContext), [t, i] = zi.useState(new JC.CssClasses()), [r, o] = zi.useState(new JC.CssClasses()), [s, a] = zi.useState(new JC.CssClasses()), [l, u] = zi.useState(), [c, h] = zi.useState(), d = zi.useRef(null), f = zi.useRef(null), p = zi.useRef(null), g = zi.useRef(null), _ = zi.useRef(), m = zi.useMemo(() => new gJ.AgPromise((O) => _.current = O), []), { ctrl: v } = n;
  zi.useEffect(() => {
    const O = {
      addOrRemoveCssClass: (T, A) => i((P) => P.setClass(T, A)),
      addOrRemoveBodyCssClass: (T, A) => o((P) => P.setClass(T, A)),
      addOrRemoveButtonWrapperCssClass: (T, A) => a((P) => P.setClass(T, A)),
      setWidth: (T) => u(T),
      setCompDetails: (T) => h(T),
      getFloatingFilterComp: () => m,
      setMenuIcon: (T) => g.current.appendChild(T)
    };
    v.setComp(O, d.current, g.current, f.current);
  }, []), zi.useEffect(() => mJ.showJsComp(c, e, f.current, _.current), [c]);
  const C = zi.useMemo(() => ({
    width: l
  }), [l]), y = zi.useMemo(() => "ag-header-cell ag-floating-filter " + t.toString(), [t]), b = zi.useMemo(() => r.toString(), [r]), L = zi.useMemo(() => "ag-floating-filter-button " + s.toString(), [r]), S = zi.useMemo(() => !!(c && c.componentFromFramework && JC.isComponentStateless(c.componentClass)), [c]), E = c && c.componentFromFramework, D = c && c.componentClass;
  return zi.default.createElement(
    "div",
    { ref: d, className: y, style: C, role: "gridcell", tabIndex: -1 },
    zi.default.createElement(
      "div",
      { ref: f, className: b, role: "presentation" },
      E && S && zi.default.createElement(D, Object.assign({}, c.params)),
      E && !S && zi.default.createElement(D, Object.assign({}, c.params, { ref: _.current }))
    ),
    zi.default.createElement(
      "div",
      { ref: p, className: L, role: "presentation" },
      zi.default.createElement("button", { ref: g, type: "button", "aria-label": "Open Filter Menu", className: "ag-floating-filter-button-button", tabIndex: -1 })
    )
  );
};
Bx.default = zi.memo(vJ);
var _J = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, Hx = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(kx, "__esModule", { value: !0 });
const Ih = gr, wr = _J(wt), CJ = Rr, yJ = Hx(Wx), wJ = Hx(Vx), bJ = Hx(Bx), SJ = (n) => {
  const { gridOptionsWrapper: e } = wr.useContext(CJ.BeansContext), [t, i] = wr.useState(), [r, o] = wr.useState(), [s, a] = wr.useState(), [l, u] = wr.useState(), [c, h] = wr.useState(), [d, f] = wr.useState([]), p = wr.useRef(null), { ctrl: g } = n, _ = g.getType() === Ih.HeaderRowType.COLUMN, m = g.getType() === Ih.HeaderRowType.COLUMN_GROUP, v = g.getType() === Ih.HeaderRowType.FLOATING_FILTER, C = wr.useCallback((S, E) => {
    if (e.isEnsureDomOrder())
      return E;
    const D = Ih._.mapById(S, (P) => P.getInstanceId()), O = Ih._.mapById(E, (P) => P.getInstanceId()), T = S.filter((P) => O.has(P.getInstanceId())), A = E.filter((P) => !D.has(P.getInstanceId()));
    return [...T, ...A];
  }, []);
  wr.useEffect(() => {
    const S = {
      setTransform: (E) => i(E),
      setHeight: (E) => o(E),
      setTop: (E) => a(E),
      setHeaderCtrls: (E) => f((D) => C(D, E)),
      setWidth: (E) => u(E),
      setAriaRowIndex: (E) => h(E)
    };
    g.setComp(S);
  }, []);
  const y = wr.useMemo(() => ({
    transform: t,
    height: r,
    top: s,
    width: l
  }), [t, r, s, l]), b = wr.useMemo(() => {
    const S = ["ag-header-row"];
    return _ && S.push("ag-header-row-column"), m && S.push("ag-header-row-column-group"), v && S.push("ag-header-row-column-filter"), S.join(" ");
  }, []), L = wr.useCallback((S) => {
    switch (g.getType()) {
      case Ih.HeaderRowType.COLUMN_GROUP:
        return wr.default.createElement(wJ.default, { ctrl: S, key: S.getInstanceId() });
      case Ih.HeaderRowType.FLOATING_FILTER:
        return wr.default.createElement(bJ.default, { ctrl: S, key: S.getInstanceId() });
      default:
        return wr.default.createElement(yJ.default, { ctrl: S, key: S.getInstanceId() });
    }
  }, []);
  return wr.default.createElement("div", { ref: p, className: b, role: "row", style: y, "aria-rowindex": c }, d.map(L));
};
kx.default = wr.memo(SJ);
var EJ = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, LJ = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(Fx, "__esModule", { value: !0 });
const or = EJ(wt), DJ = Rr, IL = gr, RJ = no, TJ = LJ(kx), OJ = (n) => {
  const [e, t] = or.useState(new RJ.CssClasses()), [i, r] = or.useState(), [o, s] = or.useState(), [a, l] = or.useState(), [u, c] = or.useState([]), { context: h } = or.useContext(DJ.BeansContext), d = or.useRef(null), f = n.pinned === IL.Constants.PINNED_LEFT, p = n.pinned === IL.Constants.PINNED_RIGHT, g = !f && !p;
  or.useEffect(() => {
    const y = {
      addOrRemoveCssClass: (L, S) => t((E) => E.setClass(L, S)),
      setCtrls: (L) => c(L),
      // centre only
      setCenterWidth: (L) => r(L),
      setContainerTransform: (L) => s(L),
      // pinned only
      setPinnedContainerWidth: (L) => l(L)
    }, b = h.createBean(new IL.HeaderRowContainerCtrl(n.pinned));
    return b.setComp(y, d.current), () => {
      h.destroyBean(b);
    };
  }, []);
  const _ = or.useMemo(() => e.toString(), [e]), m = () => u.map((y) => or.default.createElement(TJ.default, { ctrl: y, key: y.getInstanceId() })), v = or.useMemo(() => ({
    width: i,
    transform: o
  }), [i, o]), C = or.useMemo(() => ({
    width: a,
    minWidth: a,
    maxWidth: a
  }), [a]);
  return or.default.createElement(
    or.default.Fragment,
    null,
    f && or.default.createElement("div", { ref: d, className: "ag-pinned-left-header " + _, role: "presentation", style: C }, m()),
    p && or.default.createElement("div", { ref: d, className: "ag-pinned-right-header " + _, role: "presentation", style: C }, m()),
    g && or.default.createElement(
      "div",
      { ref: d, className: "ag-header-viewport " + _, role: "presentation" },
      or.default.createElement("div", { className: "ag-header-container", role: "rowgroup", style: v }, m())
    )
  );
};
Fx.default = or.memo(OJ);
var xJ = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, NJ = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(Mx, "__esModule", { value: !0 });
const Xs = xJ(wt), IJ = Rr, PL = gr, PJ = no, AL = NJ(Fx), AJ = () => {
  const [n, e] = Xs.useState(new PJ.CssClasses()), [t, i] = Xs.useState(), { context: r } = Xs.useContext(IJ.BeansContext), o = Xs.useRef(null);
  Xs.useEffect(() => {
    const l = {
      addOrRemoveCssClass: (c, h) => e((d) => d.setClass(c, h)),
      setHeightAndMinHeight: (c) => i(c)
    }, u = r.createBean(new PL.GridHeaderCtrl());
    return u.setComp(l, o.current, o.current), () => {
      r.destroyBean(u);
    };
  }, []);
  const s = Xs.useMemo(() => "ag-header " + n.toString(), [n]), a = Xs.useMemo(() => ({
    height: t,
    minHeight: t
  }), [t]);
  return Xs.default.createElement(
    "div",
    { ref: o, className: s, style: a, role: "presentation" },
    Xs.default.createElement(AL.default, { pinned: PL.Constants.PINNED_LEFT }),
    Xs.default.createElement(AL.default, { pinned: null }),
    Xs.default.createElement(AL.default, { pinned: PL.Constants.PINNED_RIGHT })
  );
};
Mx.default = Xs.memo(AJ);
var x_ = {};
Object.defineProperty(x_, "__esModule", { value: !0 });
const MJ = wt, FJ = (n, e) => {
  MJ.useEffect(() => {
    const t = e.current, i = t.parentElement;
    if (!i)
      return;
    const r = document.createComment(n);
    return i.insertBefore(r, t), () => {
      i.removeChild(r);
    };
  }, []);
};
x_.default = FJ;
var Gx = {}, Ux = {}, x4 = {}, zx = {}, kJ = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(zx, "__esModule", { value: !0 });
const WJ = gr, Af = kJ(wt), VJ = rg, BJ = Rr, HJ = (n) => {
  const [e, t] = Af.useState(), { context: i, popupService: r, gridOptionsWrapper: o } = Af.useContext(BJ.BeansContext);
  return Af.useEffect(() => {
    const { editDetails: s, cellCtrl: a, eParentCell: l } = n, { compDetails: u } = s, c = o.isStopEditingWhenCellsLoseFocus(), h = i.createBean(new WJ.PopupEditorWrapper(u.params)), d = h.getGui();
    if (n.jsChildComp) {
      const v = n.jsChildComp.getGui();
      v && d.appendChild(v);
    }
    const f = {
      column: a.getColumn(),
      rowNode: a.getRowNode(),
      type: "popupCellEditor",
      eventSource: l,
      ePopup: d,
      keepWithinBounds: !0
    }, p = s.popupPosition === "under" ? r.positionPopupUnderComponent.bind(r, f) : r.positionPopupOverComponent.bind(r, f), g = o.getLocaleTextFunc(), _ = r.addPopup({
      modal: c,
      eChild: d,
      closeOnEsc: !0,
      closedCallback: () => {
        a.onPopupEditorClosed();
      },
      anchorToElement: l,
      positionCallback: p,
      ariaLabel: g("ariaLabelCellEditor", "Cell Editor")
    }), m = _ ? _.hideFunc : void 0;
    return t(h), n.jsChildComp && n.jsChildComp.afterGuiAttached && n.jsChildComp.afterGuiAttached(), () => {
      m != null && m(), i.destroyBean(h);
    };
  }, []), Af.default.createElement(Af.default.Fragment, null, e && n.wrappedContent && VJ.createPortal(n.wrappedContent, e.getGui()));
};
zx.default = Af.memo(HJ);
var jx = {};
Object.defineProperty(jx, "__esModule", { value: !0 });
const ey = wt, GJ = Rr, UJ = (n, e, t, i, r, o) => {
  const { context: s, userComponentFactory: a } = ey.useContext(GJ.BeansContext), l = ey.useCallback(() => {
    const u = r.current;
    if (!u)
      return;
    const c = u.getGui();
    c && c.parentElement && c.parentElement.removeChild(c), s.destroyBean(u), r.current = void 0;
  }, []);
  ey.useEffect(() => {
    const u = n != null, c = n && n.compDetails && !n.compDetails.componentFromFramework, h = e && t == null;
    if (!(u && c && !h)) {
      l();
      return;
    }
    const f = n.compDetails;
    if (r.current) {
      const v = r.current, y = v.refresh != null && n.force == !1 ? v.refresh(f.params) : !1;
      if (y === !0 || y === void 0)
        return;
      l();
    }
    const p = f.newAgStackInstance();
    if (!p)
      return;
    const g = p.resolveNow(null, (v) => v);
    if (!g)
      return;
    const _ = g.getGui();
    if (!_)
      return;
    (e ? t : o.current).appendChild(_), r.current = g;
  }, [n, e, i]), ey.useEffect(() => l, []);
};
jx.default = UJ;
(function(n) {
  var e = Ne && Ne.__importStar || function(p) {
    if (p && p.__esModule)
      return p;
    var g = {};
    if (p != null)
      for (var _ in p)
        Object.hasOwnProperty.call(p, _) && (g[_] = p[_]);
    return g.default = p, g;
  }, t = Ne && Ne.__importDefault || function(p) {
    return p && p.__esModule ? p : { default: p };
  };
  Object.defineProperty(n, "__esModule", { value: !0 });
  const i = gr, r = e(wt), o = no, s = t(zx), a = t(jx), l = Rr, u = Ju;
  (function(p) {
    p[p.ShowValue = 0] = "ShowValue", p[p.EditValue = 1] = "EditValue";
  })(n.CellCompState || (n.CellCompState = {}));
  const c = (p, g, _) => {
    const m = _.getColumn();
    if (!p && g.isPopup && g.isPopup()) {
      const v = `AG Grid: Found an issue in column ${m.getColId()}. If using React, specify an editor is a popup using colDef.cellEditorPopup=true. AG Grid React cannot depend on the editor component specifying if it's in a popup (via the isPopup() method on the editor), as React needs to know this information BEFORE the component is created.`;
      i._.doOnce(() => console.warn(v), "jsEditorComp-isPopup-" + _.getColumn().getColId());
    }
    if (p && g.getPopupPosition && g.getPopupPosition() != null) {
      const v = `AG Grid: Found an issue in column ${m.getColId()}. If using React, specify an editor popup position using colDef.cellEditorPopupPosition=true. AG Grid React cannot depend on the editor component specifying it's position (via the getPopupPosition() method on the editor), as React needs to know this information BEFORE the component is created.`;
      i._.doOnce(() => console.warn(v), "jsEditorComp-getPopupPosition-" + _.getColumn().getColId());
    }
  }, h = (p, g, _, m, v, C) => {
    const y = p.compDetails, b = y.componentClass, L = y.componentFromFramework && !p.popup, S = y.componentFromFramework && p.popup, E = !y.componentFromFramework && p.popup;
    return r.default.createElement(
      r.default.Fragment,
      null,
      L && r.default.createElement(b, Object.assign({}, p.compDetails.params, { ref: g })),
      S && r.default.createElement(s.default, { editDetails: p, cellCtrl: v, eParentCell: m, wrappedContent: r.default.createElement(b, Object.assign({}, p.compDetails.params, { ref: _ })) }),
      E && C && r.default.createElement(s.default, { editDetails: p, cellCtrl: v, eParentCell: m, jsChildComp: C })
    );
  }, d = (p, g, _, m, v, C, y) => {
    const { compDetails: b, value: L } = p, S = !b, E = b && b.componentFromFramework, D = b && b.componentClass, O = L && L.toString ? L.toString() : L, T = () => r.default.createElement(
      r.default.Fragment,
      null,
      S && r.default.createElement(r.default.Fragment, null, O),
      E && !C && r.default.createElement(D, Object.assign({}, b.params, { key: g, ref: m })),
      E && C && r.default.createElement(D, Object.assign({}, b.params, { key: g }))
    );
    return r.default.createElement(r.default.Fragment, null, v ? r.default.createElement("span", { role: "presentation", id: `cell-${_}`, className: "ag-cell-value", ref: y }, T()) : T());
  }, f = (p) => {
    const { context: g } = r.useContext(l.BeansContext), { cellCtrl: _, printLayout: m, editingRow: v } = p, [C, y] = r.useState(), [b, L] = r.useState(), [S, E] = r.useState(1), [D, O] = r.useState(new o.CssClasses()), [T, A] = r.useState(), [P, G] = r.useState(), [U, $] = r.useState(), [k, se] = r.useState(), [ne, Ce] = r.useState(), [ue, B] = r.useState(), [z, Y] = r.useState(!1), [x, M] = r.useState(!1), [F, H] = r.useState(!1), [oe, ve] = r.useState(), Me = r.useMemo(() => _.isForceWrapper(), []), ze = r.useRef(null), je = r.useRef(null), Fe = r.useRef(), qe = r.useRef(), Tt = r.useRef(), [Nt, ti] = r.useState(0), ii = r.useCallback((X) => {
      Tt.current = X, ti((re) => re + 1);
    }, []), at = r.useRef(), [Hi, zt] = r.useState(0), qi = r.useCallback((X) => {
      at.current = X, zt((re) => re + 1);
    }, []), Yi = C != null && (z || F || x), wi = Me || Yi, ft = r.useCallback((X, re) => {
      qe.current = re, re && (c(X, re, _), re.isCancelBeforeStart && re.isCancelBeforeStart() && setTimeout(() => _.stopEditing(), 0));
    }, []), ai = r.useCallback((X) => ft(!0, X), []), Jn = r.useCallback((X) => ft(!1, X), []);
    a.default(C, wi, at.current, Hi, Fe, ze);
    const On = r.useRef();
    r.useEffect(() => {
      const X = On.current, re = C;
      if (On.current = C, X == null || X.compDetails == null || re == null || re.compDetails == null)
        return;
      const he = X.compDetails, be = re.compDetails;
      if (he.componentClass != be.componentClass || je.current == null || je.current.refresh == null)
        return;
      je.current.refresh(be.params) != !0 && E(($e) => $e + 1);
    }, [C]), r.useEffect(() => {
      if (!(b && !b.compDetails.componentFromFramework))
        return;
      const re = b.compDetails, he = b.popup === !0, be = u.createSyncJsComp(re);
      if (!be)
        return;
      const xe = be.getGui();
      return ft(he, be), he || (ze.current.appendChild(xe), be.afterGuiAttached && be.afterGuiAttached()), ve(be), () => {
        g.destroyBean(be), ft(he, void 0), ve(void 0), xe && xe.parentElement && xe.parentElement.removeChild(xe);
      };
    }, [b]), r.useEffect(() => {
      if (!_ || !g || ($(Tt.current ? `cell-${_.getInstanceId()}` : void 0), !Tt.current || !wi))
        return;
      const X = [], re = (he) => {
        if (he) {
          const be = he.getGui();
          Tt.current.insertAdjacentElement("afterbegin", be), X.push(() => {
            g.destroyBean(he), i._.removeFromParent(be);
          });
        }
        return he;
      };
      return z && re(_.createSelectionCheckbox()), F && re(_.createDndSource()), x && re(_.createRowDragComp()), () => {
        X.forEach((he) => {
          he();
        });
      };
    }, [wi, F, x, z, Nt]), r.useEffect(() => {
      if (!_)
        return;
      const X = {
        addOrRemoveCssClass: (he, be) => O((xe) => xe.setClass(he, be)),
        setUserStyles: (he) => A(he),
        getFocusableElement: () => ze.current,
        setTabIndex: (he) => G(he),
        setRole: (he) => se(he),
        setColId: (he) => Ce(he),
        setTitle: (he) => B(he),
        setIncludeSelection: (he) => Y(he),
        setIncludeRowDrag: (he) => M(he),
        setIncludeDndSource: (he) => H(he),
        getCellEditor: () => qe.current || null,
        getCellRenderer: () => je.current ? je.current : Fe.current,
        getParentOfValue: () => at.current ? at.current : Tt.current ? Tt.current : ze.current,
        setRenderDetails: (he, be, xe) => {
          y({
            value: be,
            compDetails: he,
            force: xe
          });
        },
        setEditDetails: (he, be, xe) => {
          he ? (L({
            compDetails: he,
            popup: be,
            popupPosition: xe
          }), be || y(void 0)) : L(void 0);
        }
      }, re = Tt.current || void 0;
      _.setComp(X, null, ze.current, re, m, v);
    }, []);
    const Vn = r.useMemo(() => !!(C && C.compDetails && C.compDetails.componentFromFramework && o.isComponentStateless(C.compDetails.componentClass)), [C]), Yt = r.useMemo(() => {
      let X = D.toString();
      return wi || (X += " ag-cell-value"), X;
    }, [D, Yi]), To = r.useMemo(() => _.getInstanceId(), []), te = () => r.default.createElement(
      r.default.Fragment,
      null,
      C != null && d(C, S, To, je, wi, Vn, qi),
      b != null && h(b, Jn, ai, ze.current, _, oe)
    );
    return r.default.createElement("div", { ref: ze, className: Yt, style: T, tabIndex: P, role: k, "col-id": ne, title: ue, "aria-describedby": U }, wi ? r.default.createElement("div", { className: "ag-cell-wrapper", role: "presentation", ref: ii }, te()) : te());
  };
  n.default = r.memo(f);
})(x4);
var zJ = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, jJ = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(Ux, "__esModule", { value: !0 });
const Si = zJ(wt), $J = gr, KJ = Ju, qJ = no, YJ = Rr, XJ = jJ(x4), ZJ = (n, e, t) => {
  if (t) {
    const l = { list: e, instanceIdMap: /* @__PURE__ */ new Map() };
    return e.forEach((u) => l.instanceIdMap.set(u.getInstanceId(), u)), l;
  }
  const i = [], r = [], o = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  return e.forEach((l) => s.set(l.getInstanceId(), l)), n.list.forEach((l) => {
    const u = l.getInstanceId();
    s.has(u) && (i.push(l), o.set(u, l));
  }), e.forEach((l) => {
    const u = l.getInstanceId();
    n.instanceIdMap.has(u) || (r.push(l), o.set(u, l));
  }), {
    list: [...i, ...r],
    instanceIdMap: o
  };
}, QJ = (n) => {
  const { context: e } = Si.useContext(YJ.BeansContext), { rowCtrl: t, containerType: i } = n, [r, o] = Si.useState(), [s, a] = Si.useState(), [l, u] = Si.useState(), [c, h] = Si.useState(), [d, f] = Si.useState(), [p, g] = Si.useState(), [_, m] = Si.useState({ list: [], instanceIdMap: /* @__PURE__ */ new Map() }), [v, C] = Si.useState(), [y, b] = Si.useState(!1), [L, S] = Si.useState(t.getInitialRowTop()), [E, D] = Si.useState(t.getInitialTransform()), O = Si.useRef(null), T = Si.useRef(), A = Si.useRef(!1), [P, G] = Si.useState(0);
  Si.useEffect(() => {
    var B;
    if (A.current || !v || P > 10)
      return;
    const z = (B = O.current) === null || B === void 0 ? void 0 : B.firstChild;
    z ? (t.setupDetailRowAutoHeight(z), A.current = !0) : G((Y) => Y + 1);
  }, [v, P]);
  const U = Si.useMemo(() => new $J.CssClassManager(() => O.current), []);
  Si.useEffect(() => {
    if (!t.isAlive())
      return;
    const B = {
      // the rowTop is managed by state, instead of direct style manipulation by rowCtrl (like all the other styles)
      // as we need to have an initial value when it's placed into he DOM for the first time, for animation to work.
      setTop: (z) => S(z),
      setTransform: (z) => D(z),
      // i found using React for managing classes at the row level was to slow, as modifying classes caused a lot of
      // React code to execute, so avoiding React for managing CSS Classes made the grid go much faster.
      addOrRemoveCssClass: (z, Y) => U.addOrRemoveCssClass(z, Y),
      setDomOrder: (z) => b(z),
      setRowIndex: (z) => o(z),
      setRowId: (z) => a(z),
      setRowBusinessKey: (z) => h(z),
      setTabIndex: (z) => f(z),
      setUserStyles: (z) => g(z),
      setRole: (z) => u(z),
      // if we don't maintain the order, then cols will be ripped out and into the dom
      // when cols reordered, which would stop the CSS transitions from working
      setCellCtrls: (z) => m((Y) => ZJ(Y, z, y)),
      showFullWidth: (z) => C(z),
      getFullWidthCellRenderer: () => T.current
    };
    t.setComp(B, O.current, i);
  }, []), Si.useEffect(() => KJ.showJsComp(v, e, O.current, T), [v]);
  const $ = Si.useMemo(() => {
    const B = { top: L, transform: E };
    return Object.assign(B, p), B;
  }, [L, E, p]), k = v && v.componentFromFramework, se = _ != null, ne = Si.useMemo(() => {
    var B;
    return !!(((B = v) === null || B === void 0 ? void 0 : B.componentFromFramework) && qJ.isComponentStateless(v.componentClass));
  }, [v]), Ce = () => _.list.map((B) => Si.default.createElement(XJ.default, { cellCtrl: B, editingRow: t.isEditing(), printLayout: t.isPrintLayout(), key: B.getInstanceId() })), ue = () => {
    const B = v.componentClass;
    return Si.default.createElement(
      Si.default.Fragment,
      null,
      ne && Si.default.createElement(B, Object.assign({}, v.params)),
      !ne && Si.default.createElement(B, Object.assign({}, v.params, { ref: T }))
    );
  };
  return Si.default.createElement(
    "div",
    { ref: O, role: l, style: $, "row-index": r, "row-id": s, "row-business-key": c, tabIndex: d },
    se && Ce(),
    k && ue()
  );
};
Ux.default = Si.memo(QJ);
var JJ = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, N4 = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(Gx, "__esModule", { value: !0 });
const yf = gr, ji = JJ(wt), ML = no, eee = N4(x_), tee = N4(Ux), iee = Rr, nee = (n) => {
  const { context: e } = ji.useContext(iee.BeansContext), [t, i] = ji.useState(""), [r, o] = ji.useState([]), [s, a] = ji.useState([]), [l, u] = ji.useState(!1), [c, h] = ji.useState(""), { name: d } = n, f = ji.useMemo(() => yf.getRowContainerTypeForName(d), [d]), p = ji.useRef(null), g = ji.useRef(null), _ = ji.useRef(null), m = ji.useMemo(() => yf.RowContainerCtrl.getRowContainerCssClasses(d), [d]), v = ji.useMemo(() => ML.classesList(m.wrapper), []), C = ji.useMemo(() => ML.classesList(m.viewport), []), y = ji.useMemo(() => ML.classesList(m.container), []), b = d === yf.RowContainerName.CENTER, L = d === yf.RowContainerName.TOP_CENTER || d === yf.RowContainerName.BOTTOM_CENTER, S = !b && !L, E = b ? p : L ? g : _;
  eee.default(" AG Row Container " + d + " ", E), ji.useEffect(() => {
    o((A) => {
      if (l)
        return s;
      const P = A.filter(($) => s.indexOf($) >= 0), G = s.filter(($) => P.indexOf($) < 0);
      return [...P, ...G];
    });
  }, [l, s]), ji.useEffect(() => {
    const A = [], P = {
      setViewportHeight: i,
      setRowCtrls: (U) => a(U),
      setDomOrder: (U) => u(U),
      setContainerWidth: (U) => h(U)
    }, G = e.createBean(new yf.RowContainerCtrl(d));
    return A.push(G), G.setComp(P, _.current, g.current, p.current), () => {
      e.destroyBeans(A);
    };
  }, []);
  const D = ji.useMemo(() => ({
    height: t
  }), [t]), O = ji.useMemo(() => ({
    width: c
  }), [c]), T = () => ji.default.createElement("div", { className: y, ref: _, role: "rowgroup", style: O }, r.map((A) => ji.default.createElement(tee.default, { rowCtrl: A, containerType: f, key: A.getInstanceId() })));
  return ji.default.createElement(
    ji.default.Fragment,
    null,
    b && ji.default.createElement(
      "div",
      { className: v, ref: p, role: "presentation" },
      ji.default.createElement("div", { className: C, ref: g, role: "presentation", style: D }, T())
    ),
    L && ji.default.createElement("div", { className: C, ref: g, role: "presentation", style: D }, T()),
    S && T()
  );
};
Gx.default = ji.memo(nee);
var ree = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, $x = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(Ax, "__esModule", { value: !0 });
const rs = gr, Ei = ree(wt), oee = Rr, see = $x(Mx), ty = $x(x_), aee = $x(Gx), iy = no, lee = () => {
  const { context: n, agStackComponentsRegistry: e, resizeObserverService: t } = Ei.useContext(oee.BeansContext), [i, r] = Ei.useState(""), [o, s] = Ei.useState(0), [a, l] = Ei.useState(0), [u, c] = Ei.useState(0), [h, d] = Ei.useState(0), [f, p] = Ei.useState(""), [g, _] = Ei.useState(""), [m, v] = Ei.useState(null), [C, y] = Ei.useState(""), [b, L] = Ei.useState(null), [S, E] = Ei.useState(""), [D, O] = Ei.useState(null), T = Ei.useRef(null), A = Ei.useRef(null), P = Ei.useRef(null), G = Ei.useRef(null);
  ty.default(" AG Grid Body ", T), ty.default(" AG Pinned Top ", A), ty.default(" AG Middle ", P), ty.default(" AG Pinned Bottom ", G), Ei.useEffect(() => {
    const z = [], Y = [];
    if (!n)
      return;
    const x = (H) => {
      const oe = e.getComponentClass(H), ve = n.createBean(new oe());
      return z.push(ve), ve;
    };
    T.current.appendChild(document.createComment(" AG Fake Horizontal Scroll ")), T.current.appendChild(x("AG-FAKE-HORIZONTAL-SCROLL").getGui()), T.current.appendChild(document.createComment(" AG Overlay Wrapper ")), T.current.appendChild(x("AG-OVERLAY-WRAPPER").getGui());
    const M = {
      setRowAnimationCssOnBodyViewport: r,
      setColumnCount: s,
      setRowCount: l,
      setTopHeight: c,
      setBottomHeight: d,
      setTopDisplay: p,
      setBottomDisplay: _,
      setColumnMovingCss: v,
      updateLayoutClasses: y,
      setAlwaysVerticalScrollClass: L,
      setPinnedTopBottomOverflowY: E,
      setCellSelectableCss: O,
      registerBodyViewportResizeListener: (H) => {
        const oe = t.observeResize(P.current, H);
        Y.push(() => oe());
      }
    }, F = n.createBean(new rs.GridBodyCtrl());
    return z.push(F), F.setComp(M, T.current, P.current, A.current, G.current), () => {
      n.destroyBeans(z), Y.forEach((H) => H());
    };
  }, []);
  const U = Ei.useMemo(() => iy.classesList("ag-root", "ag-unselectable", m, C), [m, C]), $ = Ei.useMemo(() => iy.classesList("ag-body-viewport", i, C, b, D), [i, C, b, D]), k = Ei.useMemo(() => iy.classesList("ag-floating-top", D), [D]), se = Ei.useMemo(() => iy.classesList("ag-floating-bottom", D), [D]), ne = Ei.useMemo(() => ({
    height: u,
    minHeight: u,
    display: f,
    overflowY: S
  }), [u, f, S]), Ce = Ei.useMemo(() => ({
    height: h,
    minHeight: h,
    display: g,
    overflowY: S
  }), [h, g, S]), ue = (z) => Ei.default.createElement(aee.default, { name: z, key: `${z}-container` }), B = ({ section: z, children: Y, className: x, style: M }) => Ei.default.createElement("div", { ref: z, className: x, role: "presentation", style: M }, Y.map(ue));
  return Ei.default.createElement(
    "div",
    { ref: T, className: U, role: "grid", "aria-colcount": o, "aria-rowcount": a },
    Ei.default.createElement(see.default, null),
    B({ section: A, className: k, style: ne, children: [
      rs.RowContainerName.TOP_LEFT,
      rs.RowContainerName.TOP_CENTER,
      rs.RowContainerName.TOP_RIGHT,
      rs.RowContainerName.TOP_FULL_WIDTH
    ] }),
    B({ section: P, className: $, children: [
      rs.RowContainerName.LEFT,
      rs.RowContainerName.CENTER,
      rs.RowContainerName.RIGHT,
      rs.RowContainerName.FULL_WIDTH
    ] }),
    B({ section: G, className: se, style: Ce, children: [
      rs.RowContainerName.BOTTOM_LEFT,
      rs.RowContainerName.BOTTOM_CENTER,
      rs.RowContainerName.BOTTOM_RIGHT,
      rs.RowContainerName.BOTTOM_FULL_WIDTH
    ] })
  );
};
Ax.default = Ei.memo(lee);
var Kx = {}, uee = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(Kx, "__esModule", { value: !0 });
const Qs = uee(wt), cee = gr, hee = Rr, dee = (n, e) => {
  const { children: t, eFocusableElement: i, onTabKeyDown: r, gridCtrl: o } = n, { context: s } = Qs.useContext(hee.BeansContext), a = Qs.useRef(null), l = Qs.useRef(null), u = Qs.useRef(), [c, h] = Qs.useState();
  Qs.useImperativeHandle(e, () => ({
    forceFocusOutOfContainer() {
      u.current.forceFocusOutOfContainer();
    }
  })), Qs.useEffect(() => {
    const f = a.current, p = l.current, g = {
      setTabIndex: (m) => m == null ? h(void 0) : h(parseInt(m, 10))
    }, _ = u.current = s.createBean(new cee.TabGuardCtrl({
      comp: g,
      eTopGuard: f,
      eBottomGuard: p,
      eFocusableElement: i,
      onTabKeyDown: r,
      focusInnerElement: (m) => o.focusInnerElement(m)
    }));
    return () => {
      s.destroyBean(_);
    };
  }, []);
  const d = (f) => Qs.default.createElement("div", { className: `ag-tab-guard ag-tab-guard-${f}`, role: "presentation", tabIndex: c, ref: f === "top" ? a : l });
  return Qs.default.createElement(
    Qs.default.Fragment,
    null,
    d("top"),
    t,
    d("bottom")
  );
}, fee = Qs.forwardRef(dee);
Kx.default = Qs.memo(fee);
var pee = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, qx = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(Px, "__esModule", { value: !0 });
const qM = gr, Fi = pee(wt), gee = Rr, mee = qx(Ax), vee = qx(x_), _ee = qx(Kx), YM = no, Cee = ({ context: n }) => {
  const [e, t] = Fi.useState(""), [i, r] = Fi.useState(""), [o, s] = Fi.useState(""), [a, l] = Fi.useState(null), [u, c] = Fi.useState(null), [h, d] = Fi.useState(!1), [f, p] = Fi.useState(), g = Fi.useRef(null), _ = Fi.useRef(null), m = Fi.useRef(), v = Fi.useRef(null), C = Fi.useRef(() => {
  }), y = Fi.useCallback(() => {
  }, []), b = Fi.useMemo(() => n.getBean("beans"), []);
  vee.default(" AG Grid ", _), Fi.useEffect(() => {
    const T = g.current = n.createBean(new qM.GridCtrl());
    return () => {
      n.destroyBean(T), g.current = null;
    };
  }, []), Fi.useEffect(() => {
    const T = g.current;
    C.current = T.focusInnerElement.bind(T);
    const A = {
      destroyGridUi: () => {
      },
      setRtlClass: t,
      addOrRemoveKeyboardFocusClass: (P) => r(P ? qM.FocusService.AG_KEYBOARD_FOCUS : ""),
      forceFocusOutOfContainer: () => {
        m.current.forceFocusOutOfContainer();
      },
      updateLayoutClasses: s,
      getFocusableContainers: () => {
        const P = [], G = _.current.querySelector(".ag-root"), U = _.current.querySelector(".ag-side-bar");
        return G && P.push(G), U && P.push(U), P;
      },
      setCursor: l,
      setUserSelect: c
    };
    T.setComp(A, _.current, _.current), d(!0);
  }, []), Fi.useEffect(() => {
    if (!f)
      return;
    const T = g.current, A = [], { agStackComponentsRegistry: P } = b, G = P.getComponentClass("AG-GRID-HEADER-DROP-ZONES"), U = P.getComponentClass("AG-SIDE-BAR"), $ = P.getComponentClass("AG-STATUS-BAR"), k = P.getComponentClass("AG-WATERMARK"), se = P.getComponentClass("AG-PAGINATION"), ne = [], Ce = _.current, ue = v.current;
    if (T.showDropZones() && G) {
      const B = n.createBean(new G()), z = B.getGui();
      Ce.insertAdjacentElement("afterbegin", z), ne.push(z), A.push(B);
    }
    if (T.showSideBar() && U) {
      const B = n.createBean(new U()), z = B.getGui(), Y = ue.querySelector(".ag-tab-guard-bottom");
      Y && (Y.insertAdjacentElement("beforebegin", z), ne.push(z)), A.push(B);
    }
    if (T.showStatusBar() && $) {
      const B = n.createBean(new $()), z = B.getGui();
      Ce.insertAdjacentElement("beforeend", z), ne.push(z), A.push(B);
    }
    if (se) {
      const B = n.createBean(new se()), z = B.getGui();
      Ce.insertAdjacentElement("beforeend", z), ne.push(z), A.push(B);
    }
    if (T.showWatermark() && k) {
      const B = n.createBean(new k()), z = B.getGui();
      Ce.insertAdjacentElement("beforeend", z), ne.push(z), A.push(B);
    }
    return () => {
      n.destroyBeans(A), ne.forEach((B) => {
        B.parentElement && B.parentElement.removeChild(B);
      });
    };
  }, [f]);
  const L = Fi.useMemo(() => YM.classesList("ag-root-wrapper", e, i, o), [e, i, o]), S = Fi.useMemo(() => YM.classesList("ag-root-wrapper-body", "ag-focus-managed", o), [o]), E = Fi.useMemo(() => ({
    userSelect: u ?? "",
    WebkitUserSelect: u ?? "",
    cursor: a ?? ""
  }), [u, a]), D = v.current, O = Fi.useCallback((T) => {
    m.current = T, p(!0);
  }, []);
  return Fi.default.createElement(
    "div",
    { ref: _, className: L, style: E },
    Fi.default.createElement("div", { className: S, ref: v }, h && D && Fi.default.createElement(
      gee.BeansContext.Provider,
      { value: b },
      Fi.default.createElement(
        _ee.default,
        { ref: O, eFocusableElement: D, onTabKeyDown: y, gridCtrl: g.current },
        // we wait for initialised before rending the children, so GridComp has created and registered with it's
        // GridCtrl before we create the child GridBodyComp. Otherwise the GridBodyComp would initialise first,
        // before we have set the the Layout CSS classes, causing the GridBodyComp to render rows to a grid that
        // doesn't have it's height specified, which would result if all the rows getting rendered (and if many rows,
        // hangs the UI)
        Fi.default.createElement(mee.default, null)
      )
    ))
  );
};
Px.default = Fi.memo(Cee);
var XM;
function Yx() {
  if (XM)
    return QC;
  XM = 1;
  var n = Ne && Ne.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var f = {};
    if (d != null)
      for (var p in d)
        Object.hasOwnProperty.call(d, p) && (f[p] = d[p]);
    return f.default = d, f;
  }, e = Ne && Ne.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(QC, "__esModule", { value: !0 });
  const t = gr, i = n(wt), r = O_, o = IS, s = PS, a = AS, l = e(Px), u = I4();
  class c extends i.Component {
    constructor(f) {
      super(f), this.props = f, this.destroyFuncs = [], this.changeDetectionService = new o.ChangeDetectionService(), this.eGui = i.default.createRef(), this.whenReadyFuncs = [], this.ready = !1, this.state = { context: void 0 }, this.portalManager = new a.PortalManager(this, f.componentWrappingElement, f.maxComponentCreationTimeMs);
    }
    render() {
      return i.default.createElement(
        "div",
        { style: this.createStyleForDiv(), className: this.props.className, ref: this.eGui },
        this.state.context && i.default.createElement(l.default, { context: this.state.context }),
        this.portalManager.getPortals()
      );
    }
    createStyleForDiv() {
      return Object.assign({ height: "100%" }, this.props.containerStyle || {});
    }
    componentDidMount() {
      const f = this.props.modules || [], p = {
        providedBeanInstances: {
          frameworkComponentWrapper: new h(this.portalManager)
        },
        modules: f,
        frameworkOverrides: new u.ReactFrameworkOverrides(!0)
      };
      this.gridOptions = this.props.gridOptions || {};
      const { children: g } = this.props;
      r.AgGridColumn.hasChildColumns(g) && (this.gridOptions.columnDefs = r.AgGridColumn.mapChildColumnDefs(g)), this.gridOptions = t.ComponentUtil.copyAttributesToGridOptions(this.gridOptions, this.props);
      const _ = (C) => {
        this.setState({ context: C }), C.getBean(t.CtrlsService.NAME).whenReady(() => {
          this.api = this.gridOptions.api, this.columnApi = this.gridOptions.columnApi, this.props.setGridApi(this.api, this.columnApi), this.destroyFuncs.push(() => this.api.destroy());
        });
      }, m = (C) => {
        C.getBean(t.CtrlsService.NAME).whenReady(() => {
          this.whenReadyFuncs.forEach((b) => b()), this.whenReadyFuncs.length = 0, this.ready = !0;
        });
      };
      new t.GridCoreCreator().create(this.eGui.current, this.gridOptions, _, m, p);
    }
    componentWillUnmount() {
      this.destroyFuncs.forEach((f) => f());
    }
    componentDidUpdate(f) {
      this.processPropsChanges(f, this.props);
    }
    processPropsChanges(f, p) {
      const g = {};
      this.extractGridPropertyChanges(f, p, g), this.extractDeclarativeColDefChanges(p, g), this.processChanges(g);
    }
    extractDeclarativeColDefChanges(f, p) {
      if (this.props.gridOptions && this.props.gridOptions.columnDefs || this.props.columnDefs)
        return;
      const g = !!f.debug, _ = "columnDefs", m = this.gridOptions.columnDefs;
      if (r.AgGridColumn.hasChildColumns(f.children)) {
        const v = this.changeDetectionService.getStrategy(this.getStrategyTypeForProp(_)), C = r.AgGridColumn.mapChildColumnDefs(f.children);
        v.areEqual(m, C) || (g && console.log("agGridReact: colDefs definitions changed"), p[_] = {
          previousValue: m,
          currentValue: C
        });
      } else
        m && m.length > 0 && (p[_] = {
          previousValue: m,
          currentValue: []
        });
    }
    extractGridPropertyChanges(f, p, g) {
      const _ = !!p.debug;
      Object.keys(p).forEach((m) => {
        t._.includes(t.ComponentUtil.ALL_PROPERTIES, m) && (this.changeDetectionService.getStrategy(this.getStrategyTypeForProp(m)).areEqual(f[m], p[m]) || (_ && console.log(`agGridReact: [${m}] property changed`), g[m] = {
          previousValue: f[m],
          currentValue: p[m]
        }));
      }), t.ComponentUtil.getEventCallbacks().forEach((m) => {
        f[m] !== p[m] && (_ && console.log(`agGridReact: [${m}] event callback changed`), g[m] = {
          previousValue: f[m],
          currentValue: p[m]
        });
      });
    }
    processChanges(f) {
      this.processWhenReady(() => t.ComponentUtil.processOnChange(f, this.gridOptions, this.api, this.columnApi));
    }
    processWhenReady(f) {
      this.ready ? f() : this.whenReadyFuncs.push(f);
    }
    getStrategyTypeForProp(f) {
      if (f === "rowData") {
        if (this.props.rowDataChangeDetectionStrategy)
          return this.props.rowDataChangeDetectionStrategy;
        if (this.isImmutableDataActive())
          return o.ChangeDetectionStrategyType.IdentityCheck;
      }
      return o.ChangeDetectionStrategyType.DeepValueCheck;
    }
    isImmutableDataActive() {
      return this.props.deltaRowDataMode || this.props.immutableData || this.props.gridOptions && (this.props.gridOptions.deltaRowDataMode || this.props.gridOptions.immutableData);
    }
  }
  QC.AgGridReactUi = c;
  class h extends t.BaseComponentWrapper {
    constructor(f) {
      super(), this.parent = f;
    }
    createWrapper(f, p) {
      return new s.NewReactComponent(f, this.parent, p);
    }
  }
  return QC;
}
var ZM;
function yee() {
  if (ZM)
    return ZC;
  ZM = 1;
  var n = Ne && Ne.__importStar || function(s) {
    if (s && s.__esModule)
      return s;
    var a = {};
    if (s != null)
      for (var l in s)
        Object.hasOwnProperty.call(s, l) && (a[l] = s[l]);
    return a.default = s, a;
  };
  Object.defineProperty(ZC, "__esModule", { value: !0 });
  const e = n(wt), t = no, i = Rr, r = Yx(), o = (s, a) => {
    const { ctrlsFactory: l, context: u, gridOptionsWrapper: c, resizeObserverService: h, clientSideRowModel: d, serverSideRowModel: f } = e.useContext(i.BeansContext), [p, g] = e.useState(new t.CssClasses()), [_, m] = e.useState(new t.CssClasses()), [v, C] = e.useState(), [y, b] = e.useState(), L = e.useRef(), S = e.useRef(null), E = e.useMemo(() => p.toString() + " ag-details-row", [p]), D = e.useMemo(() => _.toString() + " ag-details-grid", [_]);
    a && e.useImperativeHandle(a, () => ({
      refresh() {
        return L.current.refresh();
      }
    })), e.useEffect(() => {
      s.template && typeof s.template == "string" && console.warn("AG Grid: detailCellRendererParams.template is not supported by React - this only works with frameworks that work against String templates. To change the template, please provide your own React Detail Cell Renderer.");
    }, []), e.useEffect(() => {
      const T = {
        addOrRemoveCssClass: (P, G) => g((U) => U.setClass(P, G)),
        addOrRemoveDetailGridCssClass: (P, G) => m((U) => U.setClass(P, G)),
        setDetailGrid: (P) => C(P),
        setRowData: (P) => b(P)
      }, A = l.getInstance("detailCellRenderer");
      if (A) {
        if (u.createBean(A), A.init(T, s), L.current = A, c.isDetailRowAutoHeight()) {
          const P = () => {
            if (S.current == null)
              return;
            const G = S.current.clientHeight;
            G != null && G > 0 && setTimeout(() => {
              s.node.setRowHeight(G), d ? d.onRowHeightChanged() : f && f.onRowHeightChanged();
            }, 0);
          };
          h.observeResize(S.current, P), P();
        }
        return () => {
          u.destroyBean(A);
        };
      }
    }, []);
    const O = e.useCallback((T, A) => {
      L.current.registerDetailWithMaster(T, A);
    }, []);
    return e.default.createElement("div", { className: E, ref: S }, v && e.default.createElement(r.AgGridReactUi, Object.assign({ className: D }, v, { rowData: y, setGridApi: O })));
  };
  return ZC.default = e.forwardRef(o), ZC;
}
var QM;
function I4() {
  if (QM)
    return YC;
  QM = 1;
  var n = Ne && Ne.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  };
  Object.defineProperty(YC, "__esModule", { value: !0 });
  const e = gr, t = n(Nx), i = n(yee());
  class r extends e.VanillaFrameworkOverrides {
    constructor(s) {
      super(), this.frameworkComponents = {
        agGroupCellRenderer: t.default,
        agGroupRowRenderer: t.default,
        agDetailCellRenderer: i.default
      }, this.reactUi = s;
    }
    frameworkComponent(s) {
      if (this.reactUi)
        return this.frameworkComponents[s];
    }
    isFrameworkComponent(s) {
      if (!s)
        return !1;
      const a = s.prototype;
      return !(a && "getGui" in a);
    }
  }
  return YC.ReactFrameworkOverrides = r, YC;
}
var wee = Ne && Ne.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
}, bee = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(Ox, "__esModule", { value: !0 });
const mo = gr, lh = wee(ju), JM = bee(wt), See = xx, ny = O_, FL = IS, Eee = PS, Lee = AS, Dee = I4();
class Wp extends JM.Component {
  constructor(e) {
    super(e), this.props = e, this.changeDetectionService = new FL.ChangeDetectionService(), this.api = null, this.destroyed = !1, this.SYNCHRONOUS_CHANGE_PROPERTIES = ["context"], this.portalManager = new Lee.PortalManager(this, e.componentWrappingElement, e.maxComponentCreationTimeMs);
  }
  render() {
    return JM.default.createElement("div", {
      style: this.createStyleForDiv(),
      className: this.props.className,
      ref: (e) => {
        this.eGridDiv = e;
      }
    }, this.portalManager.getPortals());
  }
  createStyleForDiv() {
    return Object.assign({ height: "100%" }, this.props.containerStyle || {});
  }
  componentDidMount() {
    const e = this.props.modules || [], t = {
      providedBeanInstances: {
        agGridReact: this,
        frameworkComponentWrapper: new Ree(this, this.portalManager)
      },
      modules: e,
      frameworkOverrides: new Dee.ReactFrameworkOverrides(!1)
    }, i = this.props.gridOptions || {}, { children: r } = this.props;
    ny.AgGridColumn.hasChildColumns(r) && (i.columnDefs = ny.AgGridColumn.mapChildColumnDefs(r)), this.gridOptions = mo.ComponentUtil.copyAttributesToGridOptions(i, this.props), new mo.Grid(this.eGridDiv, this.gridOptions, t), this.api = this.gridOptions.api, this.columnApi = this.gridOptions.columnApi, this.props.setGridApi(this.api, this.columnApi);
  }
  getStrategyTypeForProp(e) {
    if (e === "rowData") {
      if (this.props.rowDataChangeDetectionStrategy)
        return this.props.rowDataChangeDetectionStrategy;
      if (this.isImmutableDataActive())
        return FL.ChangeDetectionStrategyType.IdentityCheck;
    }
    return FL.ChangeDetectionStrategyType.DeepValueCheck;
  }
  isImmutableDataActive() {
    return this.props.deltaRowDataMode || this.props.immutableData || this.props.gridOptions && (this.props.gridOptions.deltaRowDataMode || this.props.gridOptions.immutableData || this.props.gridOptions.getRowId);
  }
  shouldComponentUpdate(e) {
    return this.processPropsChanges(this.props, e), !1;
  }
  componentDidUpdate(e) {
    this.processPropsChanges(e, this.props);
  }
  processPropsChanges(e, t) {
    const i = {};
    this.extractGridPropertyChanges(e, t, i), this.extractDeclarativeColDefChanges(t, i), this.processSynchronousChanges(i), this.processAsynchronousChanges(i);
  }
  extractDeclarativeColDefChanges(e, t) {
    if (this.props.gridOptions && this.props.gridOptions.columnDefs || this.props.columnDefs)
      return;
    const i = !!e.debug, r = "columnDefs", o = this.gridOptions.columnDefs;
    if (ny.AgGridColumn.hasChildColumns(e.children)) {
      const s = this.changeDetectionService.getStrategy(this.getStrategyTypeForProp(r)), a = ny.AgGridColumn.mapChildColumnDefs(e.children);
      s.areEqual(o, a) || (i && console.log("agGridReact: colDefs definitions changed"), t[r] = {
        previousValue: o,
        currentValue: a
      });
    } else
      o && o.length > 0 && (t[r] = {
        previousValue: o,
        currentValue: []
      });
  }
  extractGridPropertyChanges(e, t, i) {
    const r = !!t.debug;
    Object.keys(t).forEach((o) => {
      mo._.includes(mo.ComponentUtil.ALL_PROPERTIES, o) && (this.changeDetectionService.getStrategy(this.getStrategyTypeForProp(o)).areEqual(e[o], t[o]) || (r && console.log(`agGridReact: [${o}] property changed`), i[o] = {
        previousValue: e[o],
        currentValue: t[o]
      }));
    }), mo.ComponentUtil.getEventCallbacks().forEach((o) => {
      e[o] !== t[o] && (r && console.log(`agGridReact: [${o}] event callback changed`), i[o] = {
        previousValue: e[o],
        currentValue: t[o]
      });
    });
  }
  componentWillUnmount() {
    this.api && (this.api.destroy(), this.api = null), this.destroyed = !0, this.portalManager.destroy();
  }
  isDisableStaticMarkup() {
    return this.props.disableStaticMarkup === !0;
  }
  isLegacyComponentRendering() {
    return this.props.legacyComponentRendering === !0;
  }
  processSynchronousChanges(e) {
    const t = Object.assign({}, e);
    if (Object.keys(t).length > 0) {
      const i = {};
      this.SYNCHRONOUS_CHANGE_PROPERTIES.forEach((r) => {
        t[r] && (i[r] = t[r], delete t[r]);
      }), Object.keys(i).length > 0 && this.api && mo.ComponentUtil.processOnChange(i, this.gridOptions, this.api, this.columnApi);
    }
    return t;
  }
  processAsynchronousChanges(e) {
    Object.keys(e).length > 0 && window.setTimeout(() => {
      this.api && mo.ComponentUtil.processOnChange(e, this.gridOptions, this.api, this.columnApi);
    });
  }
}
Ox.AgGridReactLegacy = Wp;
Wp.MAX_COMPONENT_CREATION_TIME_IN_MS = 1e3;
Wp.defaultProps = {
  legacyComponentRendering: !1,
  disableStaticMarkup: !1,
  maxComponentCreationTimeMs: Wp.MAX_COMPONENT_CREATION_TIME_IN_MS
};
Wp.propTypes = {
  gridOptions: lh.default.object
};
zd(mo.ComponentUtil.getEventCallbacks(), lh.default.func);
zd(mo.ComponentUtil.BOOLEAN_PROPERTIES, lh.default.bool);
zd(mo.ComponentUtil.STRING_PROPERTIES, lh.default.string);
zd(mo.ComponentUtil.OBJECT_PROPERTIES, lh.default.object);
zd(mo.ComponentUtil.ARRAY_PROPERTIES, lh.default.array);
zd(mo.ComponentUtil.NUMBER_PROPERTIES, lh.default.number);
zd(mo.ComponentUtil.FUNCTION_PROPERTIES, lh.default.func);
function zd(n, e) {
  n.forEach((t) => {
    Wp[t] = e;
  });
}
class Ree extends mo.BaseComponentWrapper {
  constructor(e, t) {
    super(), this.agGridReact = e, this.portalManager = t;
  }
  createWrapper(e, t) {
    return this.agGridReact.isLegacyComponentRendering() ? new See.LegacyReactComponent(e, this.agGridReact, this.portalManager, t) : new Eee.NewReactComponent(e, this.portalManager, t);
  }
}
var Tee = Ne && Ne.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(Tx, "__esModule", { value: !0 });
const eF = Tee(wt), Oee = Ox, xee = Yx();
let Nee = class extends eF.Component {
  constructor() {
    super(...arguments), this.setGridApi = (e, t) => {
      this.api = e, this.columnApi = t;
    };
  }
  render() {
    const e = this.props.suppressReactUi ? Oee.AgGridReactLegacy : xee.AgGridReactUi;
    return eF.default.createElement(e, Object.assign({}, this.props, { setGridApi: this.setGridApi }));
  }
};
Tx.AgGridReact = Nee;
var j_e = Tx.AgGridReact;
O_.AgGridColumn;
IS.ChangeDetectionStrategyType;
Yx().AgGridReactUi;
const tF = {
  "show-settings": "boolean",
  "show-placeholder": "boolean"
}, Iee = {
  "show-close-button": "boolean"
}, iF = {
  "max-count": "number",
  "fetch-additional-count": "number",
  "show-placeholder": "boolean",
  filter: "json"
}, Xx = {
  MultipleCursors: {
    context: "json",
    location: "json"
  },
  PagePresence: {
    context: "json",
    location: "json",
    durable: "boolean",
    "max-users": "number",
    "exclude-viewer": "boolean",
    "only-present-users": "boolean",
    orientation: "orientation"
  },
  PresenceFacepile: {
    context: "json",
    location: "json",
    "max-users": "number",
    "exclude-viewer": "boolean",
    "only-present-users": "boolean",
    "exact-match": "boolean",
    orientation: "orientation"
  },
  PresenceObserver: {
    context: "json",
    location: "json",
    "present-events": "array",
    "absent-events": "array",
    "observe-document": "boolean",
    durable: "boolean",
    "initial-state": "boolean"
  },
  Sidebar: {
    context: "json",
    location: "json",
    open: "boolean",
    "show-close-button": "boolean",
    "show-inbox": "boolean",
    "show-presence": "boolean",
    "show-launcher": "boolean",
    "show-all-activity": "boolean",
    "exclude-viewer-from-presence": "boolean",
    "show-pins-on-page": "boolean",
    "thread-name": "string"
  },
  SidebarLauncher: {
    disabled: "boolean",
    label: "string",
    "icon-url": "string",
    "inbox-badge-style": "badge-style"
  },
  Thread: {
    context: "json",
    location: "json",
    "thread-id": "string",
    "thread-name": "string",
    metadata: "json",
    collapsed: "boolean",
    autofocus: "boolean",
    "show-header": "boolean",
    "show-placeholder": "boolean",
    "composer-expanded": "boolean",
    "thread-options": "json"
  },
  ThreadList: {
    location: "json",
    filter: "json",
    "partial-match": "boolean",
    "show-screenshot-preview-in-message": "boolean",
    "highlight-open-floating-thread": "boolean",
    "highlight-thread-id": "string",
    mode: "string",
    "show-placeholder": "boolean"
  },
  Composer: {
    location: "json",
    "thread-id": "string",
    "thread-name": "string",
    autofocus: "boolean",
    "show-expanded": "boolean",
    "show-close-button": "boolean",
    size: "composer-size"
  },
  InboxLauncher: {
    label: "string",
    disabled: "boolean",
    "icon-url": "string",
    "inbox-badge-style": "badge-style",
    "show-inbox-on-click": "boolean",
    ...tF
  },
  Inbox: { ...tF, ...Iee },
  Settings: {},
  FloatingThreads: {
    location: "json",
    disabled: "boolean",
    "show-button": "boolean",
    "button-label": "string",
    "thread-name": "string",
    "show-screenshot-preview": "boolean"
  },
  SelectionComments: {
    location: "json",
    "button-label": "string",
    "icon-url": "string",
    "thread-name": "string"
  },
  NotificationList: {
    ...iF
  },
  Message: {
    "thread-id": "string",
    "message-id": "string"
  },
  Facepile: {
    users: "array",
    "enable-tooltip": "boolean"
  },
  NotificationListLauncher: {
    label: "string",
    "icon-url": "string",
    "badge-style": "badge-style",
    disabled: "boolean",
    ...iF
  },
  Pin: {
    location: "json",
    "thread-id": "string"
  },
  Avatar: {
    "user-id": "string",
    "enable-tooltip": "boolean"
  },
  AddReaction: {
    "thread-id": "string",
    "message-id": "string",
    "enable-tooltip": "boolean",
    disabled: "boolean"
  }
}, Pee = {
  json: (n) => n !== void 0 ? JSON.stringify(n) : void 0,
  boolean: (n) => n == null ? void 0 : n.toString(),
  number: (n) => n == null ? void 0 : n.toString(),
  string: (n) => n === void 0 ? void 0 : n || "",
  array: (n) => n == null ? void 0 : n.join(","),
  "badge-style": (n) => n === void 0 ? void 0 : n || "",
  orientation: (n) => n === void 0 ? void 0 : n || "",
  "composer-size": (n) => n === void 0 ? void 0 : n || ""
};
function Aee(n) {
  return n.replace(/-([a-z])/g, function(e, t) {
    return t.toUpperCase();
  });
}
const Zx = (n) => (e) => {
  const t = {};
  for (const i of Object.keys(n)) {
    const r = i, o = Aee(r);
    o in e && (t[r] = Pee[n[r]](e[o]));
  }
  return t;
};
function Mee(n, e) {
  if (n === e)
    return !0;
  if (!n || !e)
    return !1;
  const t = Object.keys(n);
  return t.length !== Object.keys(e).length || !t.every((i) => Object.prototype.hasOwnProperty.call(e, i)) ? !1 : t.every((i) => n[i] === e[i]);
}
const nF = "data-cord-annotation-location";
function P4(n) {
  return JSON.stringify(Object.fromEntries(Object.entries(n).filter(([e, t]) => t !== void 0).sort(([e], [t]) => e < t ? -1 : 1)));
}
let Fee = !1, kee = null;
try {
  Fee = !!localStorage.getItem("__cord_log_loading_times__"), kee = localStorage.getItem("__cord_override_script_url__");
} catch {
}
const Wee = Se.createContext({
  sdk: null,
  location: void 0,
  setLocation: () => {
  },
  hasProvider: !1,
  clientAuthToken: void 0,
  userID: void 0,
  organizationID: void 0
});
function FS(n) {
  const { hasProvider: e, ...t } = PU(Wee);
  return Jc(() => {
    e || console.error(`[Cord SDK] The ${n} hook is used in a component that is not a descendant of <CordProvider>.`);
  }, [e, n]), t;
}
function A4(n) {
  const { location: e, setLocation: t } = FS("useCordLocation");
  return Jc(() => {
    n && !Mee(e, n) && t(n);
  }, [n, e, t]), Jc(() => () => {
    t(void 0);
  }, [t]), n ?? e;
}
function Vee(n, e) {
  const [t, i] = nA(null), [r, o] = nA(!1);
  return Jc(() => {
    if (!t)
      return;
    const s = Object.keys(n).map((a) => {
      const l = n[a], u = (h) => {
        h instanceof CustomEvent && (l == null || l(...h.detail));
      }, c = `${e ?? t.nodeName.toLowerCase()}:${a}`;
      return t.addEventListener(c, u), [c, u];
    });
    return o(!0), () => {
      for (const [a, l] of s)
        t.removeEventListener(a, l);
      o(!1);
    };
  }, [t, n, e]), [i, r];
}
function Bee(n) {
  return Lv((e) => {
    if (!n)
      return;
    const t = (s) => {
      typeof n == "function" ? n(s) : n.current = s;
    };
    if (!e) {
      t(null);
      return;
    }
    if (e.initialised) {
      t(e);
      return;
    }
    let i = !0;
    const r = () => {
      i && t(e);
    }, o = `${e.nodeName.toLowerCase()}:initialised`;
    return e.addEventListener(o, r), () => {
      i = !1, e.removeEventListener(o, r);
    };
  }, [n]);
}
function Qx(n, e) {
  const [t, i] = Vee(n), r = Bee(e);
  return [
    Lv((o) => {
      r(o), t(o);
    }, [t, r]),
    i
  ];
}
const Hee = Zx(Xx.MultipleCursors);
function Gee(n, e) {
  const [t, i] = Qx({}, e), r = A4();
  return Se.createElement("cord-multiple-cursors", { id: n.id, class: n.className, style: n.style, ref: t, "buffer-events": !i, ...Hee({ location: r, ...n }) });
}
Se.forwardRef(Gee);
function M4(n, e) {
  return Lv((t) => {
    t && Object.assign(t, n), e(t);
  }, [e, n]);
}
const Uee = Zx(Xx.Sidebar);
function zee(n, e) {
  const { onOpen: t, onClose: i, onThreadOpen: r, onThreadClose: o } = n, [s, a] = Qx({
    open: t,
    close: i,
    threadopen: r,
    threadclose: o
  }, e), l = M4({
    newComponentSwitchConfig: n.newComponentSwitchConfig,
    screenshotConfig: n.screenshotConfig
  }, s), u = A4();
  return Se.createElement("cord-sidebar", { id: n.id, class: n.className, style: n.style, ref: l, "buffer-events": !a, ...Uee({ location: u, ...n }) });
}
Se.forwardRef(zee);
function Jx(n) {
  const e = a1(() => P4(n), [n]);
  return a1(() => JSON.parse(e), [e]);
}
const jee = () => {
};
function $_e(n, e) {
  var t;
  const { sdk: i } = FS("useCordAnnotationRenderer"), r = Jx(n);
  return Jc(() => {
    if (!(!e || !i))
      return i.annotation.setRenderHandler(r, e), () => {
        i.annotation.clearRenderHandler(r);
      };
  }, [i, r, e]), {
    redrawAnnotations: (t = i == null ? void 0 : i.annotation.redrawAnnotations) !== null && t !== void 0 ? t : jee
  };
}
function K_e(n, e) {
  const { sdk: t } = FS("useCordAnnotationCaptureHandler"), i = Jx(n);
  Jc(() => {
    if (!(!e || !t))
      return t.annotation.setCaptureHandler(i, e), () => {
        t.annotation.clearCaptureHandler(i);
      };
  }, [t, i, e]);
}
function q_e(n, e) {
  const { sdk: t } = FS("useCordAnnotationClickHandler"), i = Jx(n);
  Jc(() => {
    if (!(!e || !t))
      return t.annotation.setClickHandler(i, e), () => {
        t.annotation.clearClickHandler(i);
      };
  }, [t, i, e]);
}
function $ee(n, e) {
  const t = AU(null);
  return a1(() => ({
    get current() {
      return t.current;
    },
    set current(i) {
      t.current !== i && (e == null || e(t.current), t.current = i, n(i));
    }
  }), [n, e]);
}
function Y_e(n) {
  const e = P4(n), t = Lv((r) => {
    r == null || r.setAttribute(nF, e);
  }, [e]), i = Lv((r) => {
    r == null || r.removeAttribute(nF);
  }, []);
  return $ee(t, i);
}
const Kee = Zx(Xx.FloatingThreads);
let F4 = !1;
try {
  F4 = !!localStorage.getItem("__cord_log_loading_times__");
} catch {
}
function qee(n, e) {
  const [t, i] = Qx({
    start: n.onStart,
    finish: n.onFinish,
    cancel: n.onCancel
  }, e), r = M4({
    newComponentSwitchConfig: n.newComponentSwitchConfig,
    screenshotConfig: n.screenshotConfig
  }, t);
  return Jc(() => {
    F4 && console.log(`<cord-floating-threads> first render: ${(/* @__PURE__ */ new Date()).toISOString()}`);
  }, []), Se.createElement("cord-floating-threads", { ref: r, id: n.id, "buffer-events": !i, class: n.className, style: n.style, ...Kee(n) });
}
Se.forwardRef(qee);
var qw = {}, Yee = {
  get exports() {
    return qw;
  },
  set exports(n) {
    qw = n;
  }
}, k4 = {};
function W4(n) {
  var e, t, i = "";
  if (typeof n == "string" || typeof n == "number")
    i += n;
  else if (typeof n == "object")
    if (Array.isArray(n))
      for (e = 0; e < n.length; e++)
        n[e] && (t = W4(n[e])) && (i && (i += " "), i += t);
    else
      for (e in n)
        n[e] && (i && (i += " "), i += e);
  return i;
}
function rF() {
  for (var n, e, t = 0, i = ""; t < arguments.length; )
    (n = arguments[t++]) && (e = W4(n)) && (i && (i += " "), i += e);
  return i;
}
const Xee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: rF,
  default: rF
}, Symbol.toStringTag, { value: "Module" })), Zee = /* @__PURE__ */ OO(Xee);
var Tn = {}, ql = {};
Object.defineProperty(ql, "__esModule", {
  value: !0
});
ql.dontSetMe = ite;
ql.findInArray = Qee;
ql.int = tte;
ql.isFunction = Jee;
ql.isNum = ete;
function Qee(n, e) {
  for (var t = 0, i = n.length; t < i; t++)
    if (e.apply(e, [n[t], t, n]))
      return n[t];
}
function Jee(n) {
  return typeof n == "function" || Object.prototype.toString.call(n) === "[object Function]";
}
function ete(n) {
  return typeof n == "number" && !isNaN(n);
}
function tte(n) {
  return parseInt(n, 10);
}
function ite(n, e, t) {
  if (n[e])
    return new Error("Invalid prop ".concat(e, " passed to ").concat(t, " - do not set this, set it on the child."));
}
var jd = {};
Object.defineProperty(jd, "__esModule", {
  value: !0
});
jd.browserPrefixToKey = B4;
jd.browserPrefixToStyle = nte;
jd.default = void 0;
jd.getPrefix = V4;
var kL = ["Moz", "Webkit", "O", "ms"];
function V4() {
  var n, e, t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
  if (typeof window > "u")
    return "";
  var i = (n = window.document) === null || n === void 0 || (e = n.documentElement) === null || e === void 0 ? void 0 : e.style;
  if (!i || t in i)
    return "";
  for (var r = 0; r < kL.length; r++)
    if (B4(t, kL[r]) in i)
      return kL[r];
  return "";
}
function B4(n, e) {
  return e ? "".concat(e).concat(rte(n)) : n;
}
function nte(n, e) {
  return e ? "-".concat(e.toLowerCase(), "-").concat(n) : n;
}
function rte(n) {
  for (var e = "", t = !0, i = 0; i < n.length; i++)
    t ? (e += n[i].toUpperCase(), t = !1) : n[i] === "-" ? t = !0 : e += n[i];
  return e;
}
var ote = V4();
jd.default = ote;
function j1(n) {
  return j1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, j1(n);
}
Object.defineProperty(Tn, "__esModule", {
  value: !0
});
Tn.addClassName = j4;
Tn.addEvent = lte;
Tn.addUserSelectStyles = Cte;
Tn.createCSSTransform = gte;
Tn.createSVGTransform = mte;
Tn.getTouch = vte;
Tn.getTouchIdentifier = _te;
Tn.getTranslation = eN;
Tn.innerHeight = dte;
Tn.innerWidth = fte;
Tn.matchesSelector = z4;
Tn.matchesSelectorAndParentsTo = ate;
Tn.offsetXYFromParent = pte;
Tn.outerHeight = cte;
Tn.outerWidth = hte;
Tn.removeClassName = $4;
Tn.removeEvent = ute;
Tn.removeUserSelectStyles = yte;
var bs = ql, oF = ste(jd);
function H4(n) {
  if (typeof WeakMap != "function")
    return null;
  var e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
  return (H4 = function(r) {
    return r ? t : e;
  })(n);
}
function ste(n, e) {
  if (!e && n && n.__esModule)
    return n;
  if (n === null || j1(n) !== "object" && typeof n != "function")
    return { default: n };
  var t = H4(e);
  if (t && t.has(n))
    return t.get(n);
  var i = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in n)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(n, o)) {
      var s = r ? Object.getOwnPropertyDescriptor(n, o) : null;
      s && (s.get || s.set) ? Object.defineProperty(i, o, s) : i[o] = n[o];
    }
  return i.default = n, t && t.set(n, i), i;
}
function sF(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    })), t.push.apply(t, i);
  }
  return t;
}
function G4(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? sF(Object(t), !0).forEach(function(i) {
      U4(n, i, t[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : sF(Object(t)).forEach(function(i) {
      Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
    });
  }
  return n;
}
function U4(n, e, t) {
  return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n;
}
var ry = "";
function z4(n, e) {
  return ry || (ry = (0, bs.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(t) {
    return (0, bs.isFunction)(n[t]);
  })), (0, bs.isFunction)(n[ry]) ? n[ry](e) : !1;
}
function ate(n, e, t) {
  var i = n;
  do {
    if (z4(i, e))
      return !0;
    if (i === t)
      return !1;
    i = i.parentNode;
  } while (i);
  return !1;
}
function lte(n, e, t, i) {
  if (n) {
    var r = G4({
      capture: !0
    }, i);
    n.addEventListener ? n.addEventListener(e, t, r) : n.attachEvent ? n.attachEvent("on" + e, t) : n["on" + e] = t;
  }
}
function ute(n, e, t, i) {
  if (n) {
    var r = G4({
      capture: !0
    }, i);
    n.removeEventListener ? n.removeEventListener(e, t, r) : n.detachEvent ? n.detachEvent("on" + e, t) : n["on" + e] = null;
  }
}
function cte(n) {
  var e = n.clientHeight, t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e += (0, bs.int)(t.borderTopWidth), e += (0, bs.int)(t.borderBottomWidth), e;
}
function hte(n) {
  var e = n.clientWidth, t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e += (0, bs.int)(t.borderLeftWidth), e += (0, bs.int)(t.borderRightWidth), e;
}
function dte(n) {
  var e = n.clientHeight, t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e -= (0, bs.int)(t.paddingTop), e -= (0, bs.int)(t.paddingBottom), e;
}
function fte(n) {
  var e = n.clientWidth, t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e -= (0, bs.int)(t.paddingLeft), e -= (0, bs.int)(t.paddingRight), e;
}
function pte(n, e, t) {
  var i = e === e.ownerDocument.body, r = i ? {
    left: 0,
    top: 0
  } : e.getBoundingClientRect(), o = (n.clientX + e.scrollLeft - r.left) / t, s = (n.clientY + e.scrollTop - r.top) / t;
  return {
    x: o,
    y: s
  };
}
function gte(n, e) {
  var t = eN(n, e, "px");
  return U4({}, (0, oF.browserPrefixToKey)("transform", oF.default), t);
}
function mte(n, e) {
  var t = eN(n, e, "");
  return t;
}
function eN(n, e, t) {
  var i = n.x, r = n.y, o = "translate(".concat(i).concat(t, ",").concat(r).concat(t, ")");
  if (e) {
    var s = "".concat(typeof e.x == "string" ? e.x : e.x + t), a = "".concat(typeof e.y == "string" ? e.y : e.y + t);
    o = "translate(".concat(s, ", ").concat(a, ")") + o;
  }
  return o;
}
function vte(n, e) {
  return n.targetTouches && (0, bs.findInArray)(n.targetTouches, function(t) {
    return e === t.identifier;
  }) || n.changedTouches && (0, bs.findInArray)(n.changedTouches, function(t) {
    return e === t.identifier;
  });
}
function _te(n) {
  if (n.targetTouches && n.targetTouches[0])
    return n.targetTouches[0].identifier;
  if (n.changedTouches && n.changedTouches[0])
    return n.changedTouches[0].identifier;
}
function Cte(n) {
  if (n) {
    var e = n.getElementById("react-draggable-style-el");
    e || (e = n.createElement("style"), e.type = "text/css", e.id = "react-draggable-style-el", e.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, e.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, n.getElementsByTagName("head")[0].appendChild(e)), n.body && j4(n.body, "react-draggable-transparent-selection");
  }
}
function yte(n) {
  if (n)
    try {
      if (n.body && $4(n.body, "react-draggable-transparent-selection"), n.selection)
        n.selection.empty();
      else {
        var e = (n.defaultView || window).getSelection();
        e && e.type !== "Caret" && e.removeAllRanges();
      }
    } catch {
    }
}
function j4(n, e) {
  n.classList ? n.classList.add(e) : n.className.match(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"))) || (n.className += " ".concat(e));
}
function $4(n, e) {
  n.classList ? n.classList.remove(e) : n.className = n.className.replace(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"), "g"), "");
}
var Yl = {};
Object.defineProperty(Yl, "__esModule", {
  value: !0
});
Yl.canDragX = Ste;
Yl.canDragY = Ete;
Yl.createCoreData = Dte;
Yl.createDraggableData = Rte;
Yl.getBoundPosition = wte;
Yl.getControlPosition = Lte;
Yl.snapToGrid = bte;
var as = ql, zf = Tn;
function wte(n, e, t) {
  if (!n.props.bounds)
    return [e, t];
  var i = n.props.bounds;
  i = typeof i == "string" ? i : Tte(i);
  var r = tN(n);
  if (typeof i == "string") {
    var o = r.ownerDocument, s = o.defaultView, a;
    if (i === "parent" ? a = r.parentNode : a = o.querySelector(i), !(a instanceof s.HTMLElement))
      throw new Error('Bounds selector "' + i + '" could not find an element.');
    var l = a, u = s.getComputedStyle(r), c = s.getComputedStyle(l);
    i = {
      left: -r.offsetLeft + (0, as.int)(c.paddingLeft) + (0, as.int)(u.marginLeft),
      top: -r.offsetTop + (0, as.int)(c.paddingTop) + (0, as.int)(u.marginTop),
      right: (0, zf.innerWidth)(l) - (0, zf.outerWidth)(r) - r.offsetLeft + (0, as.int)(c.paddingRight) - (0, as.int)(u.marginRight),
      bottom: (0, zf.innerHeight)(l) - (0, zf.outerHeight)(r) - r.offsetTop + (0, as.int)(c.paddingBottom) - (0, as.int)(u.marginBottom)
    };
  }
  return (0, as.isNum)(i.right) && (e = Math.min(e, i.right)), (0, as.isNum)(i.bottom) && (t = Math.min(t, i.bottom)), (0, as.isNum)(i.left) && (e = Math.max(e, i.left)), (0, as.isNum)(i.top) && (t = Math.max(t, i.top)), [e, t];
}
function bte(n, e, t) {
  var i = Math.round(e / n[0]) * n[0], r = Math.round(t / n[1]) * n[1];
  return [i, r];
}
function Ste(n) {
  return n.props.axis === "both" || n.props.axis === "x";
}
function Ete(n) {
  return n.props.axis === "both" || n.props.axis === "y";
}
function Lte(n, e, t) {
  var i = typeof e == "number" ? (0, zf.getTouch)(n, e) : null;
  if (typeof e == "number" && !i)
    return null;
  var r = tN(t), o = t.props.offsetParent || r.offsetParent || r.ownerDocument.body;
  return (0, zf.offsetXYFromParent)(i || n, o, t.props.scale);
}
function Dte(n, e, t) {
  var i = n.state, r = !(0, as.isNum)(i.lastX), o = tN(n);
  return r ? {
    node: o,
    deltaX: 0,
    deltaY: 0,
    lastX: e,
    lastY: t,
    x: e,
    y: t
  } : {
    node: o,
    deltaX: e - i.lastX,
    deltaY: t - i.lastY,
    lastX: i.lastX,
    lastY: i.lastY,
    x: e,
    y: t
  };
}
function Rte(n, e) {
  var t = n.props.scale;
  return {
    node: e.node,
    x: n.state.x + e.deltaX / t,
    y: n.state.y + e.deltaY / t,
    deltaX: e.deltaX / t,
    deltaY: e.deltaY / t,
    lastX: n.state.x,
    lastY: n.state.y
  };
}
function Tte(n) {
  return {
    left: n.left,
    top: n.top,
    right: n.right,
    bottom: n.bottom
  };
}
function tN(n) {
  var e = n.findDOMNode();
  if (!e)
    throw new Error("<DraggableCore>: Unmounted during event!");
  return e;
}
var kS = {}, WS = {};
Object.defineProperty(WS, "__esModule", {
  value: !0
});
WS.default = Ote;
function Ote() {
}
function Yw(n) {
  return Yw = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Yw(n);
}
Object.defineProperty(kS, "__esModule", {
  value: !0
});
kS.default = void 0;
var WL = Nte(wt), os = iN(ju), xte = iN(rg), Hr = Tn, Cc = Yl, VL = ql, bm = iN(WS);
function iN(n) {
  return n && n.__esModule ? n : { default: n };
}
function K4(n) {
  if (typeof WeakMap != "function")
    return null;
  var e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
  return (K4 = function(r) {
    return r ? t : e;
  })(n);
}
function Nte(n, e) {
  if (!e && n && n.__esModule)
    return n;
  if (n === null || Yw(n) !== "object" && typeof n != "function")
    return { default: n };
  var t = K4(e);
  if (t && t.has(n))
    return t.get(n);
  var i = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in n)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(n, o)) {
      var s = r ? Object.getOwnPropertyDescriptor(n, o) : null;
      s && (s.get || s.set) ? Object.defineProperty(i, o, s) : i[o] = n[o];
    }
  return i.default = n, t && t.set(n, i), i;
}
function aF(n, e) {
  return Mte(n) || Ate(n, e) || Pte(n, e) || Ite();
}
function Ite() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Pte(n, e) {
  if (n) {
    if (typeof n == "string")
      return lF(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return lF(n, e);
  }
}
function lF(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, i = new Array(e); t < e; t++)
    i[t] = n[t];
  return i;
}
function Ate(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var i = [], r = !0, o = !1, s, a;
    try {
      for (t = t.call(n); !(r = (s = t.next()).done) && (i.push(s.value), !(e && i.length === e)); r = !0)
        ;
    } catch (l) {
      o = !0, a = l;
    } finally {
      try {
        !r && t.return != null && t.return();
      } finally {
        if (o)
          throw a;
      }
    }
    return i;
  }
}
function Mte(n) {
  if (Array.isArray(n))
    return n;
}
function Fte(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function uF(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(n, i.key, i);
  }
}
function kte(n, e, t) {
  return e && uF(n.prototype, e), t && uF(n, t), Object.defineProperty(n, "prototype", { writable: !1 }), n;
}
function Wte(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  n.prototype = Object.create(e && e.prototype, { constructor: { value: n, writable: !0, configurable: !0 } }), Object.defineProperty(n, "prototype", { writable: !1 }), e && $1(n, e);
}
function $1(n, e) {
  return $1 = Object.setPrototypeOf || function(i, r) {
    return i.__proto__ = r, i;
  }, $1(n, e);
}
function Vte(n) {
  var e = Hte();
  return function() {
    var i = Xw(n), r;
    if (e) {
      var o = Xw(this).constructor;
      r = Reflect.construct(i, arguments, o);
    } else
      r = i.apply(this, arguments);
    return Bte(this, r);
  };
}
function Bte(n, e) {
  if (e && (Yw(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Gr(n);
}
function Gr(n) {
  if (n === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function Hte() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Xw(n) {
  return Xw = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Xw(n);
}
function ta(n, e, t) {
  return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n;
}
var Ra = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  }
}, yc = Ra.mouse, VS = /* @__PURE__ */ function(n) {
  Wte(t, n);
  var e = Vte(t);
  function t() {
    var i;
    Fte(this, t);
    for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++)
      o[s] = arguments[s];
    return i = e.call.apply(e, [this].concat(o)), ta(Gr(i), "state", {
      dragging: !1,
      // Used while dragging to determine deltas.
      lastX: NaN,
      lastY: NaN,
      touchIdentifier: null
    }), ta(Gr(i), "mounted", !1), ta(Gr(i), "handleDragStart", function(a) {
      if (i.props.onMouseDown(a), !i.props.allowAnyClick && typeof a.button == "number" && a.button !== 0)
        return !1;
      var l = i.findDOMNode();
      if (!l || !l.ownerDocument || !l.ownerDocument.body)
        throw new Error("<DraggableCore> not mounted on DragStart!");
      var u = l.ownerDocument;
      if (!(i.props.disabled || !(a.target instanceof u.defaultView.Node) || i.props.handle && !(0, Hr.matchesSelectorAndParentsTo)(a.target, i.props.handle, l) || i.props.cancel && (0, Hr.matchesSelectorAndParentsTo)(a.target, i.props.cancel, l))) {
        a.type === "touchstart" && a.preventDefault();
        var c = (0, Hr.getTouchIdentifier)(a);
        i.setState({
          touchIdentifier: c
        });
        var h = (0, Cc.getControlPosition)(a, c, Gr(i));
        if (h != null) {
          var d = h.x, f = h.y, p = (0, Cc.createCoreData)(Gr(i), d, f);
          (0, bm.default)("DraggableCore: handleDragStart: %j", p), (0, bm.default)("calling", i.props.onStart);
          var g = i.props.onStart(a, p);
          g === !1 || i.mounted === !1 || (i.props.enableUserSelectHack && (0, Hr.addUserSelectStyles)(u), i.setState({
            dragging: !0,
            lastX: d,
            lastY: f
          }), (0, Hr.addEvent)(u, yc.move, i.handleDrag), (0, Hr.addEvent)(u, yc.stop, i.handleDragStop));
        }
      }
    }), ta(Gr(i), "handleDrag", function(a) {
      var l = (0, Cc.getControlPosition)(a, i.state.touchIdentifier, Gr(i));
      if (l != null) {
        var u = l.x, c = l.y;
        if (Array.isArray(i.props.grid)) {
          var h = u - i.state.lastX, d = c - i.state.lastY, f = (0, Cc.snapToGrid)(i.props.grid, h, d), p = aF(f, 2);
          if (h = p[0], d = p[1], !h && !d)
            return;
          u = i.state.lastX + h, c = i.state.lastY + d;
        }
        var g = (0, Cc.createCoreData)(Gr(i), u, c);
        (0, bm.default)("DraggableCore: handleDrag: %j", g);
        var _ = i.props.onDrag(a, g);
        if (_ === !1 || i.mounted === !1) {
          try {
            i.handleDragStop(new MouseEvent("mouseup"));
          } catch {
            var m = document.createEvent("MouseEvents");
            m.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), i.handleDragStop(m);
          }
          return;
        }
        i.setState({
          lastX: u,
          lastY: c
        });
      }
    }), ta(Gr(i), "handleDragStop", function(a) {
      if (i.state.dragging) {
        var l = (0, Cc.getControlPosition)(a, i.state.touchIdentifier, Gr(i));
        if (l != null) {
          var u = l.x, c = l.y;
          if (Array.isArray(i.props.grid)) {
            var h = u - i.state.lastX || 0, d = c - i.state.lastY || 0, f = (0, Cc.snapToGrid)(i.props.grid, h, d), p = aF(f, 2);
            h = p[0], d = p[1], u = i.state.lastX + h, c = i.state.lastY + d;
          }
          var g = (0, Cc.createCoreData)(Gr(i), u, c), _ = i.props.onStop(a, g);
          if (_ === !1 || i.mounted === !1)
            return !1;
          var m = i.findDOMNode();
          m && i.props.enableUserSelectHack && (0, Hr.removeUserSelectStyles)(m.ownerDocument), (0, bm.default)("DraggableCore: handleDragStop: %j", g), i.setState({
            dragging: !1,
            lastX: NaN,
            lastY: NaN
          }), m && ((0, bm.default)("DraggableCore: Removing handlers"), (0, Hr.removeEvent)(m.ownerDocument, yc.move, i.handleDrag), (0, Hr.removeEvent)(m.ownerDocument, yc.stop, i.handleDragStop));
        }
      }
    }), ta(Gr(i), "onMouseDown", function(a) {
      return yc = Ra.mouse, i.handleDragStart(a);
    }), ta(Gr(i), "onMouseUp", function(a) {
      return yc = Ra.mouse, i.handleDragStop(a);
    }), ta(Gr(i), "onTouchStart", function(a) {
      return yc = Ra.touch, i.handleDragStart(a);
    }), ta(Gr(i), "onTouchEnd", function(a) {
      return yc = Ra.touch, i.handleDragStop(a);
    }), i;
  }
  return kte(t, [{
    key: "componentDidMount",
    value: function() {
      this.mounted = !0;
      var r = this.findDOMNode();
      r && (0, Hr.addEvent)(r, Ra.touch.start, this.onTouchStart, {
        passive: !1
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.mounted = !1;
      var r = this.findDOMNode();
      if (r) {
        var o = r.ownerDocument;
        (0, Hr.removeEvent)(o, Ra.mouse.move, this.handleDrag), (0, Hr.removeEvent)(o, Ra.touch.move, this.handleDrag), (0, Hr.removeEvent)(o, Ra.mouse.stop, this.handleDragStop), (0, Hr.removeEvent)(o, Ra.touch.stop, this.handleDragStop), (0, Hr.removeEvent)(r, Ra.touch.start, this.onTouchStart, {
          passive: !1
        }), this.props.enableUserSelectHack && (0, Hr.removeUserSelectStyles)(o);
      }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
  }, {
    key: "findDOMNode",
    value: function() {
      var r, o, s;
      return (r = this.props) !== null && r !== void 0 && r.nodeRef ? (o = this.props) === null || o === void 0 || (s = o.nodeRef) === null || s === void 0 ? void 0 : s.current : xte.default.findDOMNode(this);
    }
  }, {
    key: "render",
    value: function() {
      return /* @__PURE__ */ WL.cloneElement(WL.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  }]), t;
}(WL.Component);
kS.default = VS;
ta(VS, "displayName", "DraggableCore");
ta(VS, "propTypes", {
  /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */
  allowAnyClick: os.default.bool,
  /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */
  disabled: os.default.bool,
  /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */
  enableUserSelectHack: os.default.bool,
  /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */
  offsetParent: function(e, t) {
    if (e[t] && e[t].nodeType !== 1)
      throw new Error("Draggable's offsetParent must be a DOM Node.");
  },
  /**
   * `grid` specifies the x and y that dragging should snap to.
   */
  grid: os.default.arrayOf(os.default.number),
  /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  handle: os.default.string,
  /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */
  cancel: os.default.string,
  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */
  nodeRef: os.default.object,
  /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onStart: os.default.func,
  /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onDrag: os.default.func,
  /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */
  onStop: os.default.func,
  /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */
  onMouseDown: os.default.func,
  /**
   * `scale`, if set, applies scaling while dragging an element
   */
  scale: os.default.number,
  /**
   * These properties should be defined on the child, not here.
   */
  className: VL.dontSetMe,
  style: VL.dontSetMe,
  transform: VL.dontSetMe
});
ta(VS, "defaultProps", {
  allowAnyClick: !1,
  // by default only accept left click
  disabled: !1,
  enableUserSelectHack: !0,
  onStart: function() {
  },
  onDrag: function() {
  },
  onStop: function() {
  },
  onMouseDown: function() {
  },
  scale: 1
});
(function(n) {
  function e(B) {
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(z) {
      return typeof z;
    } : function(z) {
      return z && typeof Symbol == "function" && z.constructor === Symbol && z !== Symbol.prototype ? "symbol" : typeof z;
    }, e(B);
  }
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), Object.defineProperty(n, "DraggableCore", {
    enumerable: !0,
    get: function() {
      return u.default;
    }
  }), n.default = void 0;
  var t = p(wt), i = d(ju), r = d(rg), o = d(Zee), s = Tn, a = Yl, l = ql, u = d(kS), c = d(WS), h = ["axis", "bounds", "children", "defaultPosition", "defaultClassName", "defaultClassNameDragging", "defaultClassNameDragged", "position", "positionOffset", "scale"];
  function d(B) {
    return B && B.__esModule ? B : { default: B };
  }
  function f(B) {
    if (typeof WeakMap != "function")
      return null;
    var z = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap();
    return (f = function(M) {
      return M ? Y : z;
    })(B);
  }
  function p(B, z) {
    if (!z && B && B.__esModule)
      return B;
    if (B === null || e(B) !== "object" && typeof B != "function")
      return { default: B };
    var Y = f(z);
    if (Y && Y.has(B))
      return Y.get(B);
    var x = {}, M = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var F in B)
      if (F !== "default" && Object.prototype.hasOwnProperty.call(B, F)) {
        var H = M ? Object.getOwnPropertyDescriptor(B, F) : null;
        H && (H.get || H.set) ? Object.defineProperty(x, F, H) : x[F] = B[F];
      }
    return x.default = B, Y && Y.set(B, x), x;
  }
  function g() {
    return g = Object.assign || function(B) {
      for (var z = 1; z < arguments.length; z++) {
        var Y = arguments[z];
        for (var x in Y)
          Object.prototype.hasOwnProperty.call(Y, x) && (B[x] = Y[x]);
      }
      return B;
    }, g.apply(this, arguments);
  }
  function _(B, z) {
    if (B == null)
      return {};
    var Y = m(B, z), x, M;
    if (Object.getOwnPropertySymbols) {
      var F = Object.getOwnPropertySymbols(B);
      for (M = 0; M < F.length; M++)
        x = F[M], !(z.indexOf(x) >= 0) && Object.prototype.propertyIsEnumerable.call(B, x) && (Y[x] = B[x]);
    }
    return Y;
  }
  function m(B, z) {
    if (B == null)
      return {};
    var Y = {}, x = Object.keys(B), M, F;
    for (F = 0; F < x.length; F++)
      M = x[F], !(z.indexOf(M) >= 0) && (Y[M] = B[M]);
    return Y;
  }
  function v(B, z) {
    var Y = Object.keys(B);
    if (Object.getOwnPropertySymbols) {
      var x = Object.getOwnPropertySymbols(B);
      z && (x = x.filter(function(M) {
        return Object.getOwnPropertyDescriptor(B, M).enumerable;
      })), Y.push.apply(Y, x);
    }
    return Y;
  }
  function C(B) {
    for (var z = 1; z < arguments.length; z++) {
      var Y = arguments[z] != null ? arguments[z] : {};
      z % 2 ? v(Object(Y), !0).forEach(function(x) {
        Ce(B, x, Y[x]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(B, Object.getOwnPropertyDescriptors(Y)) : v(Object(Y)).forEach(function(x) {
        Object.defineProperty(B, x, Object.getOwnPropertyDescriptor(Y, x));
      });
    }
    return B;
  }
  function y(B, z) {
    return D(B) || E(B, z) || L(B, z) || b();
  }
  function b() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function L(B, z) {
    if (B) {
      if (typeof B == "string")
        return S(B, z);
      var Y = Object.prototype.toString.call(B).slice(8, -1);
      if (Y === "Object" && B.constructor && (Y = B.constructor.name), Y === "Map" || Y === "Set")
        return Array.from(B);
      if (Y === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Y))
        return S(B, z);
    }
  }
  function S(B, z) {
    (z == null || z > B.length) && (z = B.length);
    for (var Y = 0, x = new Array(z); Y < z; Y++)
      x[Y] = B[Y];
    return x;
  }
  function E(B, z) {
    var Y = B == null ? null : typeof Symbol < "u" && B[Symbol.iterator] || B["@@iterator"];
    if (Y != null) {
      var x = [], M = !0, F = !1, H, oe;
      try {
        for (Y = Y.call(B); !(M = (H = Y.next()).done) && (x.push(H.value), !(z && x.length === z)); M = !0)
          ;
      } catch (ve) {
        F = !0, oe = ve;
      } finally {
        try {
          !M && Y.return != null && Y.return();
        } finally {
          if (F)
            throw oe;
        }
      }
      return x;
    }
  }
  function D(B) {
    if (Array.isArray(B))
      return B;
  }
  function O(B, z) {
    if (!(B instanceof z))
      throw new TypeError("Cannot call a class as a function");
  }
  function T(B, z) {
    for (var Y = 0; Y < z.length; Y++) {
      var x = z[Y];
      x.enumerable = x.enumerable || !1, x.configurable = !0, "value" in x && (x.writable = !0), Object.defineProperty(B, x.key, x);
    }
  }
  function A(B, z, Y) {
    return z && T(B.prototype, z), Y && T(B, Y), Object.defineProperty(B, "prototype", { writable: !1 }), B;
  }
  function P(B, z) {
    if (typeof z != "function" && z !== null)
      throw new TypeError("Super expression must either be null or a function");
    B.prototype = Object.create(z && z.prototype, { constructor: { value: B, writable: !0, configurable: !0 } }), Object.defineProperty(B, "prototype", { writable: !1 }), z && G(B, z);
  }
  function G(B, z) {
    return G = Object.setPrototypeOf || function(x, M) {
      return x.__proto__ = M, x;
    }, G(B, z);
  }
  function U(B) {
    var z = se();
    return function() {
      var x = ne(B), M;
      if (z) {
        var F = ne(this).constructor;
        M = Reflect.construct(x, arguments, F);
      } else
        M = x.apply(this, arguments);
      return $(this, M);
    };
  }
  function $(B, z) {
    if (z && (e(z) === "object" || typeof z == "function"))
      return z;
    if (z !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return k(B);
  }
  function k(B) {
    if (B === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return B;
  }
  function se() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function ne(B) {
    return ne = Object.setPrototypeOf ? Object.getPrototypeOf : function(Y) {
      return Y.__proto__ || Object.getPrototypeOf(Y);
    }, ne(B);
  }
  function Ce(B, z, Y) {
    return z in B ? Object.defineProperty(B, z, { value: Y, enumerable: !0, configurable: !0, writable: !0 }) : B[z] = Y, B;
  }
  var ue = /* @__PURE__ */ function(B) {
    P(Y, B);
    var z = U(Y);
    function Y(x) {
      var M;
      return O(this, Y), M = z.call(this, x), Ce(k(M), "onDragStart", function(F, H) {
        (0, c.default)("Draggable: onDragStart: %j", H);
        var oe = M.props.onStart(F, (0, a.createDraggableData)(k(M), H));
        if (oe === !1)
          return !1;
        M.setState({
          dragging: !0,
          dragged: !0
        });
      }), Ce(k(M), "onDrag", function(F, H) {
        if (!M.state.dragging)
          return !1;
        (0, c.default)("Draggable: onDrag: %j", H);
        var oe = (0, a.createDraggableData)(k(M), H), ve = {
          x: oe.x,
          y: oe.y
        };
        if (M.props.bounds) {
          var Me = ve.x, ze = ve.y;
          ve.x += M.state.slackX, ve.y += M.state.slackY;
          var je = (0, a.getBoundPosition)(k(M), ve.x, ve.y), Fe = y(je, 2), qe = Fe[0], Tt = Fe[1];
          ve.x = qe, ve.y = Tt, ve.slackX = M.state.slackX + (Me - ve.x), ve.slackY = M.state.slackY + (ze - ve.y), oe.x = ve.x, oe.y = ve.y, oe.deltaX = ve.x - M.state.x, oe.deltaY = ve.y - M.state.y;
        }
        var Nt = M.props.onDrag(F, oe);
        if (Nt === !1)
          return !1;
        M.setState(ve);
      }), Ce(k(M), "onDragStop", function(F, H) {
        if (!M.state.dragging)
          return !1;
        var oe = M.props.onStop(F, (0, a.createDraggableData)(k(M), H));
        if (oe === !1)
          return !1;
        (0, c.default)("Draggable: onDragStop: %j", H);
        var ve = {
          dragging: !1,
          slackX: 0,
          slackY: 0
        }, Me = !!M.props.position;
        if (Me) {
          var ze = M.props.position, je = ze.x, Fe = ze.y;
          ve.x = je, ve.y = Fe;
        }
        M.setState(ve);
      }), M.state = {
        // Whether or not we are currently dragging.
        dragging: !1,
        // Whether or not we have been dragged before.
        dragged: !1,
        // Current transform x and y.
        x: x.position ? x.position.x : x.defaultPosition.x,
        y: x.position ? x.position.y : x.defaultPosition.y,
        prevPropsPosition: C({}, x.position),
        // Used for compensating for out-of-bounds drags
        slackX: 0,
        slackY: 0,
        // Can only determine if SVG after mounting
        isElementSVG: !1
      }, x.position && !(x.onDrag || x.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element."), M;
    }
    return A(Y, [{
      key: "componentDidMount",
      value: function() {
        typeof window.SVGElement < "u" && this.findDOMNode() instanceof window.SVGElement && this.setState({
          isElementSVG: !0
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.setState({
          dragging: !1
        });
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
    }, {
      key: "findDOMNode",
      value: function() {
        var M, F, H;
        return (M = (F = this.props) === null || F === void 0 || (H = F.nodeRef) === null || H === void 0 ? void 0 : H.current) !== null && M !== void 0 ? M : r.default.findDOMNode(this);
      }
    }, {
      key: "render",
      value: function() {
        var M, F = this.props;
        F.axis, F.bounds;
        var H = F.children, oe = F.defaultPosition, ve = F.defaultClassName, Me = F.defaultClassNameDragging, ze = F.defaultClassNameDragged, je = F.position, Fe = F.positionOffset;
        F.scale;
        var qe = _(F, h), Tt = {}, Nt = null, ti = !!je, ii = !ti || this.state.dragging, at = je || oe, Hi = {
          // Set left if horizontal drag is enabled
          x: (0, a.canDragX)(this) && ii ? this.state.x : at.x,
          // Set top if vertical drag is enabled
          y: (0, a.canDragY)(this) && ii ? this.state.y : at.y
        };
        this.state.isElementSVG ? Nt = (0, s.createSVGTransform)(Hi, Fe) : Tt = (0, s.createCSSTransform)(Hi, Fe);
        var zt = (0, o.default)(H.props.className || "", ve, (M = {}, Ce(M, Me, this.state.dragging), Ce(M, ze, this.state.dragged), M));
        return /* @__PURE__ */ t.createElement(u.default, g({}, qe, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), /* @__PURE__ */ t.cloneElement(t.Children.only(H), {
          className: zt,
          style: C(C({}, H.props.style), Tt),
          transform: Nt
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: (
        // React 16.3+
        // Arity (props, state)
        function(M, F) {
          var H = M.position, oe = F.prevPropsPosition;
          return H && (!oe || H.x !== oe.x || H.y !== oe.y) ? ((0, c.default)("Draggable: getDerivedStateFromProps %j", {
            position: H,
            prevPropsPosition: oe
          }), {
            x: H.x,
            y: H.y,
            prevPropsPosition: C({}, H)
          }) : null;
        }
      )
    }]), Y;
  }(t.Component);
  n.default = ue, Ce(ue, "displayName", "Draggable"), Ce(ue, "propTypes", C(C({}, u.default.propTypes), {}, {
    /**
     * `axis` determines which axis the draggable can move.
     *
     *  Note that all callbacks will still return data as normal. This only
     *  controls flushing to the DOM.
     *
     * 'both' allows movement horizontally and vertically.
     * 'x' limits movement to horizontal axis.
     * 'y' limits movement to vertical axis.
     * 'none' limits all movement.
     *
     * Defaults to 'both'.
     */
    axis: i.default.oneOf(["both", "x", "y", "none"]),
    /**
     * `bounds` determines the range of movement available to the element.
     * Available values are:
     *
     * 'parent' restricts movement within the Draggable's parent node.
     *
     * Alternatively, pass an object with the following properties, all of which are optional:
     *
     * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
     *
     * All values are in px.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable bounds={{right: 300, bottom: 300}}>
     *              <div>Content</div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    bounds: i.default.oneOfType([i.default.shape({
      left: i.default.number,
      right: i.default.number,
      top: i.default.number,
      bottom: i.default.number
    }), i.default.string, i.default.oneOf([!1])]),
    defaultClassName: i.default.string,
    defaultClassNameDragging: i.default.string,
    defaultClassNameDragged: i.default.string,
    /**
     * `defaultPosition` specifies the x and y that the dragged item should start at
     *
     * Example:
     *
     * ```jsx
     *      let App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable defaultPosition={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    defaultPosition: i.default.shape({
      x: i.default.number,
      y: i.default.number
    }),
    positionOffset: i.default.shape({
      x: i.default.oneOfType([i.default.number, i.default.string]),
      y: i.default.oneOfType([i.default.number, i.default.string])
    }),
    /**
     * `position`, if present, defines the current position of the element.
     *
     *  This is similar to how form elements in React work - if no `position` is supplied, the component
     *  is uncontrolled.
     *
     * Example:
     *
     * ```jsx
     *      let App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable position={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    position: i.default.shape({
      x: i.default.number,
      y: i.default.number
    }),
    /**
     * These properties should be defined on the child, not here.
     */
    className: l.dontSetMe,
    style: l.dontSetMe,
    transform: l.dontSetMe
  })), Ce(ue, "defaultProps", C(C({}, u.default.defaultProps), {}, {
    axis: "both",
    bounds: !1,
    defaultClassName: "react-draggable",
    defaultClassNameDragging: "react-draggable-dragging",
    defaultClassNameDragged: "react-draggable-dragged",
    defaultPosition: {
      x: 0,
      y: 0
    },
    scale: 1
  }));
})(k4);
var q4 = k4, Y4 = q4.default, Gte = q4.DraggableCore;
Yee.exports = Y4;
qw.default = Y4;
qw.DraggableCore = Gte;
/**
 * React Router DOM v6.12.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Wv() {
  return Wv = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Wv.apply(this, arguments);
}
function Ute(n, e) {
  if (n == null)
    return {};
  var t = {}, i = Object.keys(n), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(e.indexOf(r) >= 0) && (t[r] = n[r]);
  return t;
}
function zte(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
}
function jte(n, e) {
  return n.button === 0 && // Ignore everything but left clicks
  (!e || e === "_self") && // Let browser handle "target=_blank" etc.
  !zte(n);
}
function K1(n) {
  return n === void 0 && (n = ""), new URLSearchParams(typeof n == "string" || Array.isArray(n) || n instanceof URLSearchParams ? n : Object.keys(n).reduce((e, t) => {
    let i = n[t];
    return e.concat(Array.isArray(i) ? i.map((r) => [t, r]) : [[t, i]]);
  }, []));
}
function $te(n, e) {
  let t = K1(n);
  if (e)
    for (let i of e.keys())
      t.has(i) || e.getAll(i).forEach((r) => {
        t.append(i, r);
      });
  return t;
}
const Kte = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];
function X_e(n, e) {
  return fz({
    basename: e == null ? void 0 : e.basename,
    future: Wv({}, e == null ? void 0 : e.future, {
      v7_prependBasename: !0
    }),
    history: FU({
      window: e == null ? void 0 : e.window
    }),
    hydrationData: (e == null ? void 0 : e.hydrationData) || qte(),
    routes: n,
    mapRouteProperties: kz
  }).initialize();
}
function qte() {
  var n;
  let e = (n = window) == null ? void 0 : n.__staticRouterHydrationData;
  return e && e.errors && (e = Wv({}, e, {
    errors: Yte(e.errors)
  })), e;
}
function Yte(n) {
  if (!n)
    return null;
  let e = Object.entries(n), t = {};
  for (let [i, r] of e)
    if (r && r.__type === "RouteErrorResponse")
      t[i] = new NO(r.status, r.statusText, r.data, r.internal === !0);
    else if (r && r.__type === "Error") {
      let o = new Error(r.message);
      o.stack = "", t[i] = o;
    } else
      t[i] = r;
  return t;
}
const Xte = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Zte = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Z_e = /* @__PURE__ */ Se.forwardRef(function(e, t) {
  let {
    onClick: i,
    relative: r,
    reloadDocument: o,
    replace: s,
    state: a,
    target: l,
    to: u,
    preventScrollReset: c
  } = e, h = Ute(e, Kte), {
    basename: d
  } = Se.useContext(sg), f, p = !1;
  if (typeof u == "string" && Zte.test(u) && (f = u, Xte))
    try {
      let v = new URL(window.location.href), C = u.startsWith("//") ? new URL(v.protocol + u) : new URL(u), y = og(C.pathname, d);
      C.origin === v.origin && y != null ? u = y + C.search + C.hash : p = !0;
    } catch {
    }
  let g = bz(u, {
    relative: r
  }), _ = Qte(u, {
    replace: s,
    state: a,
    target: l,
    preventScrollReset: c,
    relative: r
  });
  function m(v) {
    i && i(v), v.defaultPrevented || _(v);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ Se.createElement("a", Wv({}, h, {
      href: f || g,
      onClick: p || o ? i : m,
      ref: t,
      target: l
    }))
  );
});
var cF;
(function(n) {
  n.UseScrollRestoration = "useScrollRestoration", n.UseSubmitImpl = "useSubmitImpl", n.UseFetcher = "useFetcher";
})(cF || (cF = {}));
var hF;
(function(n) {
  n.UseFetchers = "useFetchers", n.UseScrollRestoration = "useScrollRestoration";
})(hF || (hF = {}));
function Qte(n, e) {
  let {
    target: t,
    replace: i,
    state: r,
    preventScrollReset: o,
    relative: s
  } = e === void 0 ? {} : e, a = nV(), l = __(), u = rV(n, {
    relative: s
  });
  return Se.useCallback((c) => {
    if (jte(c, t)) {
      c.preventDefault();
      let h = i !== void 0 ? i : Cd(l) === Cd(u);
      a(n, {
        replace: h,
        state: r,
        preventScrollReset: o,
        relative: s
      });
    }
  }, [l, a, u, i, r, t, n, o, s]);
}
function Q_e(n) {
  let e = Se.useRef(K1(n)), t = Se.useRef(!1), i = __(), r = Se.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    $te(i.search, t.current ? null : e.current)
  ), [i.search]), o = nV(), s = Se.useCallback((a, l) => {
    const u = K1(typeof a == "function" ? a(r) : a);
    t.current = !0, o("?" + u, l);
  }, [o, r]);
  return [r, s];
}
function Jte(n, e) {
  let t;
  return e.length === 0 ? t = n : t = n.replace(/\{(\d+)\}/g, function(i, r) {
    const o = r[0];
    return typeof e[o] < "u" ? e[o] : i;
  }), t;
}
function w(n, e, ...t) {
  return Jte(e, t);
}
var BL;
const qy = "en";
let Zw = !1, Qw = !1, Yy = !1, X4 = !1, Z4 = !1, nN = !1, oy, HL = qy, eie, Dc;
const gn = typeof self == "object" ? self : typeof global == "object" ? global : {};
let an;
typeof gn.vscode < "u" && typeof gn.vscode.process < "u" ? an = gn.vscode.process : typeof process < "u" && (an = process);
const Q4 = typeof ((BL = an == null ? void 0 : an.versions) === null || BL === void 0 ? void 0 : BL.electron) == "string" && an.type === "renderer", tie = Q4 && (an == null ? void 0 : an.sandboxed), iie = (() => {
  if (tie)
    return "bypassHeatCheck";
  const n = an == null ? void 0 : an.env.VSCODE_BROWSER_CODE_LOADING;
  if (typeof n == "string")
    return n === "none" || n === "code" || n === "bypassHeatCheck" || n === "bypassHeatCheckAndEagerCompile" ? n : "bypassHeatCheck";
})(), nie = typeof iie == "string";
if (typeof navigator == "object" && !Q4)
  Dc = navigator.userAgent, Zw = Dc.indexOf("Windows") >= 0, Qw = Dc.indexOf("Macintosh") >= 0, nN = (Dc.indexOf("Macintosh") >= 0 || Dc.indexOf("iPad") >= 0 || Dc.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0, Yy = Dc.indexOf("Linux") >= 0, Z4 = !0, oy = navigator.language, HL = oy;
else if (typeof an == "object") {
  Zw = an.platform === "win32", Qw = an.platform === "darwin", Yy = an.platform === "linux", Yy && an.env.SNAP && an.env.SNAP_REVISION, oy = qy, HL = qy;
  const n = an.env.VSCODE_NLS_CONFIG;
  if (n)
    try {
      const e = JSON.parse(n), t = e.availableLanguages["*"];
      oy = e.locale, HL = t || qy, eie = e._translationsConfigFile;
    } catch {
    }
  X4 = !0;
} else
  console.error("Unable to resolve platform.");
const Eo = Zw, Ft = Qw, Rs = Yy, iv = X4, BS = Z4, _g = nN, rie = Dc, Jw = function() {
  if (gn.setImmediate)
    return gn.setImmediate.bind(gn);
  if (typeof gn.postMessage == "function" && !gn.importScripts) {
    let t = [];
    gn.addEventListener("message", (r) => {
      if (r.data && r.data.vscodeSetImmediateId)
        for (let o = 0, s = t.length; o < s; o++) {
          const a = t[o];
          if (a.id === r.data.vscodeSetImmediateId) {
            t.splice(o, 1), a.callback();
            return;
          }
        }
    });
    let i = 0;
    return (r) => {
      const o = ++i;
      t.push({
        id: o,
        callback: r
      }), gn.postMessage({ vscodeSetImmediateId: o }, "*");
    };
  }
  if (typeof (an == null ? void 0 : an.nextTick) == "function")
    return an.nextTick.bind(an);
  const e = Promise.resolve();
  return (t) => e.then(t);
}(), Ga = Qw || nN ? 2 : Zw ? 1 : 3;
let dF = !0, fF = !1;
function J4() {
  if (!fF) {
    fF = !0;
    const n = new Uint8Array(2);
    n[0] = 1, n[1] = 2, dF = new Uint16Array(n.buffer)[0] === (2 << 8) + 1;
  }
  return dF;
}
const eG = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function oie(n = "") {
  let e = "(-?\\d*\\.\\d\\w*)|([^";
  for (const t of eG)
    n.indexOf(t) >= 0 || (e += "\\" + t);
  return e += "\\s]+)", new RegExp(e, "g");
}
const tG = oie();
function q1(n) {
  let e = tG;
  if (n && n instanceof RegExp)
    if (n.global)
      e = n;
    else {
      let t = "g";
      n.ignoreCase && (t += "i"), n.multiline && (t += "m"), n.unicode && (t += "u"), e = new RegExp(n.source, t);
    }
  return e.lastIndex = 0, e;
}
const sie = {
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
};
function eb(n, e, t, i, r = sie) {
  if (t.length > r.maxLen) {
    let u = n - r.maxLen / 2;
    return u < 0 ? u = 0 : i += u, t = t.substring(u, n + r.maxLen / 2), eb(n, e, t, i, r);
  }
  const o = Date.now(), s = n - 1 - i;
  let a = -1, l = null;
  for (let u = 1; !(Date.now() - o >= r.timeBudget); u++) {
    const c = s - r.windowSize * u;
    e.lastIndex = Math.max(0, c);
    const h = aie(e, t, s, a);
    if (!h && l || (l = h, c <= 0))
      break;
    a = c;
  }
  if (l) {
    let u = {
      word: l[0],
      startColumn: i + 1 + l.index,
      endColumn: i + 1 + l.index + l[0].length
    };
    return e.lastIndex = 0, u;
  }
  return null;
}
function aie(n, e, t, i) {
  let r;
  for (; r = n.exec(e); ) {
    const o = r.index || 0;
    if (o <= t && n.lastIndex >= t)
      return r;
    if (i > 0 && o > i)
      return null;
  }
  return null;
}
const Vm = 8;
class iG {
  /**
   * @internal
   */
  constructor(e) {
    this._values = e;
  }
  hasChanged(e) {
    return this._values[e];
  }
}
class lie {
  constructor() {
    this._values = [];
  }
  _read(e) {
    return this._values[e];
  }
  get(e) {
    return this._values[e];
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class nG {
  constructor() {
    this.stableMinimapLayoutInput = null, this.stableFitMaxMinimapScale = 0, this.stableFitRemainingWidth = 0;
  }
}
class Yn {
  constructor(e, t, i, r) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = r;
  }
  compute(e, t, i) {
    return i;
  }
}
class Cg {
  constructor(e, t = null) {
    this.schema = void 0, this.id = e, this.name = "_never_", this.defaultValue = void 0, this.deps = t;
  }
  validate(e) {
    return this.defaultValue;
  }
}
class $d {
  constructor(e, t, i, r) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = r;
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : e;
  }
  compute(e, t, i) {
    return i;
  }
}
function Ge(n, e) {
  return typeof n > "u" ? e : n === "false" ? !1 : !!n;
}
class ut extends $d {
  constructor(e, t, i, r = void 0) {
    typeof r < "u" && (r.type = "boolean", r.default = i), super(e, t, i, r);
  }
  validate(e) {
    return Ge(e, this.defaultValue);
  }
}
class oi extends $d {
  constructor(e, t, i, r, o, s = void 0) {
    typeof s < "u" && (s.type = "integer", s.default = i, s.minimum = r, s.maximum = o), super(e, t, i, s), this.minimum = r, this.maximum = o;
  }
  static clampedInt(e, t, i, r) {
    if (typeof e > "u")
      return t;
    let o = parseInt(e, 10);
    return isNaN(o) ? t : (o = Math.max(i, o), o = Math.min(r, o), o | 0);
  }
  validate(e) {
    return oi.clampedInt(e, this.defaultValue, this.minimum, this.maximum);
  }
}
class Hc extends $d {
  constructor(e, t, i, r, o) {
    typeof o < "u" && (o.type = "number", o.default = i), super(e, t, i, o), this.validationFn = r;
  }
  static clamp(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static float(e, t) {
    if (typeof e == "number")
      return e;
    if (typeof e > "u")
      return t;
    const i = parseFloat(e);
    return isNaN(i) ? t : i;
  }
  validate(e) {
    return this.validationFn(Hc.float(e, this.defaultValue));
  }
}
class vo extends $d {
  static string(e, t) {
    return typeof e != "string" ? t : e;
  }
  constructor(e, t, i, r = void 0) {
    typeof r < "u" && (r.type = "string", r.default = i), super(e, t, i, r);
  }
  validate(e) {
    return vo.string(e, this.defaultValue);
  }
}
function hs(n, e, t) {
  return typeof n != "string" || t.indexOf(n) === -1 ? e : n;
}
class sn extends $d {
  constructor(e, t, i, r, o = void 0) {
    typeof o < "u" && (o.type = "string", o.enum = r, o.default = i), super(e, t, i, o), this._allowedValues = r;
  }
  validate(e) {
    return hs(e, this.defaultValue, this._allowedValues);
  }
}
class Sm extends Yn {
  constructor(e, t, i, r, o, s, a = void 0) {
    typeof a < "u" && (a.type = "string", a.enum = o, a.default = r), super(e, t, i, a), this._allowedValues = o, this._convert = s;
  }
  validate(e) {
    return typeof e != "string" ? this.defaultValue : this._allowedValues.indexOf(e) === -1 ? this.defaultValue : this._convert(e);
  }
}
function uie(n) {
  switch (n) {
    case "none":
      return 0;
    case "keep":
      return 1;
    case "brackets":
      return 2;
    case "advanced":
      return 3;
    case "full":
      return 4;
  }
}
class cie extends Yn {
  constructor() {
    super(2, "accessibilitySupport", 0, {
      type: "string",
      enum: ["auto", "on", "off"],
      enumDescriptions: [
        w("accessibilitySupport.auto", "The editor will use platform APIs to detect when a Screen Reader is attached."),
        w("accessibilitySupport.on", "The editor will be permanently optimized for usage with a Screen Reader. Word wrapping will be disabled."),
        w("accessibilitySupport.off", "The editor will never be optimized for usage with a Screen Reader.")
      ],
      default: "auto",
      description: w("accessibilitySupport", "Controls whether the editor should run in a mode where it is optimized for screen readers. Setting to on will disable word wrapping.")
    });
  }
  validate(e) {
    switch (e) {
      case "auto":
        return 0;
      case "off":
        return 1;
      case "on":
        return 2;
    }
    return this.defaultValue;
  }
  compute(e, t, i) {
    return i === 0 ? e.accessibilitySupport : i;
  }
}
class hie extends Yn {
  constructor() {
    const e = {
      insertSpace: !0,
      ignoreEmptyLines: !0
    };
    super(17, "comments", e, {
      "editor.comments.insertSpace": {
        type: "boolean",
        default: e.insertSpace,
        description: w("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
      },
      "editor.comments.ignoreEmptyLines": {
        type: "boolean",
        default: e.ignoreEmptyLines,
        description: w("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertSpace: Ge(t.insertSpace, this.defaultValue.insertSpace),
      ignoreEmptyLines: Ge(t.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
    };
  }
}
function die(n) {
  switch (n) {
    case "blink":
      return 1;
    case "smooth":
      return 2;
    case "phase":
      return 3;
    case "expand":
      return 4;
    case "solid":
      return 5;
  }
}
var kn;
(function(n) {
  n[n.Line = 1] = "Line", n[n.Block = 2] = "Block", n[n.Underline = 3] = "Underline", n[n.LineThin = 4] = "LineThin", n[n.BlockOutline = 5] = "BlockOutline", n[n.UnderlineThin = 6] = "UnderlineThin";
})(kn || (kn = {}));
function fie(n) {
  switch (n) {
    case "line":
      return kn.Line;
    case "block":
      return kn.Block;
    case "underline":
      return kn.Underline;
    case "line-thin":
      return kn.LineThin;
    case "block-outline":
      return kn.BlockOutline;
    case "underline-thin":
      return kn.UnderlineThin;
  }
}
class pie extends Cg {
  constructor() {
    super(125, [
      63,
      31
      /* extraEditorClassName */
    ]);
  }
  compute(e, t, i) {
    const r = ["monaco-editor"];
    return t.get(
      31
      /* extraEditorClassName */
    ) && r.push(t.get(
      31
      /* extraEditorClassName */
    )), e.extraEditorClassName && r.push(e.extraEditorClassName), t.get(
      63
      /* mouseStyle */
    ) === "default" ? r.push("mouse-default") : t.get(
      63
      /* mouseStyle */
    ) === "copy" && r.push("mouse-copy"), t.get(
      98
      /* showUnused */
    ) && r.push("showUnused"), t.get(
      123
      /* showDeprecated */
    ) && r.push("showDeprecated"), r.join(" ");
  }
}
class gie extends ut {
  constructor() {
    super(30, "emptySelectionClipboard", !0, { description: w("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.") });
  }
  compute(e, t, i) {
    return i && e.emptySelectionClipboard;
  }
}
class mie extends Yn {
  constructor() {
    const e = {
      cursorMoveOnType: !0,
      seedSearchStringFromSelection: !0,
      autoFindInSelection: "never",
      globalFindClipboard: !1,
      addExtraSpaceOnTop: !0,
      loop: !0
    };
    super(33, "find", e, {
      "editor.find.cursorMoveOnType": {
        type: "boolean",
        default: e.cursorMoveOnType,
        description: w("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
      },
      "editor.find.seedSearchStringFromSelection": {
        type: "boolean",
        default: e.seedSearchStringFromSelection,
        description: w("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
      },
      "editor.find.autoFindInSelection": {
        type: "string",
        enum: ["never", "always", "multiline"],
        default: e.autoFindInSelection,
        enumDescriptions: [
          w("editor.find.autoFindInSelection.never", "Never turn on Find in selection automatically (default)."),
          w("editor.find.autoFindInSelection.always", "Always turn on Find in selection automatically."),
          w("editor.find.autoFindInSelection.multiline", "Turn on Find in selection automatically when multiple lines of content are selected.")
        ],
        description: w("find.autoFindInSelection", "Controls the condition for turning on find in selection automatically.")
      },
      "editor.find.globalFindClipboard": {
        type: "boolean",
        default: e.globalFindClipboard,
        description: w("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
        included: Ft
      },
      "editor.find.addExtraSpaceOnTop": {
        type: "boolean",
        default: e.addExtraSpaceOnTop,
        description: w("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
      },
      "editor.find.loop": {
        type: "boolean",
        default: e.loop,
        description: w("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      cursorMoveOnType: Ge(t.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
      seedSearchStringFromSelection: Ge(t.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection),
      autoFindInSelection: typeof e.autoFindInSelection == "boolean" ? e.autoFindInSelection ? "always" : "never" : hs(t.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
      globalFindClipboard: Ge(t.globalFindClipboard, this.defaultValue.globalFindClipboard),
      addExtraSpaceOnTop: Ge(t.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
      loop: Ge(t.loop, this.defaultValue.loop)
    };
  }
}
class fs extends Yn {
  constructor() {
    super(41, "fontLigatures", fs.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: w("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
        },
        {
          type: "string",
          description: w("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
        }
      ],
      description: w("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" ? fs.OFF : e === "true" ? fs.ON : e : e ? fs.ON : fs.OFF;
  }
}
fs.OFF = '"liga" off, "calt" off';
fs.ON = '"liga" on, "calt" on';
class vie extends Cg {
  constructor() {
    super(
      40
      /* fontInfo */
    );
  }
  compute(e, t, i) {
    return e.fontInfo;
  }
}
class _ie extends $d {
  constructor() {
    super(42, "fontSize", Ss.fontSize, {
      type: "number",
      minimum: 6,
      maximum: 100,
      default: Ss.fontSize,
      description: w("fontSize", "Controls the font size in pixels.")
    });
  }
  validate(e) {
    let t = Hc.float(e, this.defaultValue);
    return t === 0 ? Ss.fontSize : Hc.clamp(t, 6, 100);
  }
  compute(e, t, i) {
    return e.fontInfo.fontSize;
  }
}
class Nl extends Yn {
  constructor() {
    super(43, "fontWeight", Ss.fontWeight, {
      anyOf: [
        {
          type: "number",
          minimum: Nl.MINIMUM_VALUE,
          maximum: Nl.MAXIMUM_VALUE,
          errorMessage: w("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: Nl.SUGGESTION_VALUES
        }
      ],
      default: Ss.fontWeight,
      description: w("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
    });
  }
  validate(e) {
    return e === "normal" || e === "bold" ? e : String(oi.clampedInt(e, Ss.fontWeight, Nl.MINIMUM_VALUE, Nl.MAXIMUM_VALUE));
  }
}
Nl.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
Nl.MINIMUM_VALUE = 1;
Nl.MAXIMUM_VALUE = 1e3;
class Cie extends Yn {
  constructor() {
    const e = {
      multiple: "peek",
      multipleDefinitions: "peek",
      multipleTypeDefinitions: "peek",
      multipleDeclarations: "peek",
      multipleImplementations: "peek",
      multipleReferences: "peek",
      alternativeDefinitionCommand: "editor.action.goToReferences",
      alternativeTypeDefinitionCommand: "editor.action.goToReferences",
      alternativeDeclarationCommand: "editor.action.goToReferences",
      alternativeImplementationCommand: "",
      alternativeReferenceCommand: ""
    }, t = {
      type: "string",
      enum: ["peek", "gotoAndPeek", "goto"],
      default: e.multiple,
      enumDescriptions: [
        w("editor.gotoLocation.multiple.peek", "Show peek view of the results (default)"),
        w("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a peek view"),
        w("editor.gotoLocation.multiple.goto", "Go to the primary result and enable peek-less navigation to others")
      ]
    }, i = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
    super(47, "gotoLocation", e, {
      "editor.gotoLocation.multiple": {
        deprecationMessage: w("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
      },
      "editor.gotoLocation.multipleDefinitions": Object.assign({ description: w("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleTypeDefinitions": Object.assign({ description: w("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleDeclarations": Object.assign({ description: w("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleImplementations": Object.assign({ description: w("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleReferences": Object.assign({ description: w("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.alternativeDefinitionCommand": {
        type: "string",
        default: e.alternativeDefinitionCommand,
        enum: i,
        description: w("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeTypeDefinitionCommand": {
        type: "string",
        default: e.alternativeTypeDefinitionCommand,
        enum: i,
        description: w("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeDeclarationCommand": {
        type: "string",
        default: e.alternativeDeclarationCommand,
        enum: i,
        description: w("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
      },
      "editor.gotoLocation.alternativeImplementationCommand": {
        type: "string",
        default: e.alternativeImplementationCommand,
        enum: i,
        description: w("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
      },
      "editor.gotoLocation.alternativeReferenceCommand": {
        type: "string",
        default: e.alternativeReferenceCommand,
        enum: i,
        description: w("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
      }
    });
  }
  validate(e) {
    var t, i, r, o, s;
    if (!e || typeof e != "object")
      return this.defaultValue;
    const a = e;
    return {
      multiple: hs(a.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
      multipleDefinitions: (t = a.multipleDefinitions) !== null && t !== void 0 ? t : hs(a.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTypeDefinitions: (i = a.multipleTypeDefinitions) !== null && i !== void 0 ? i : hs(a.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleDeclarations: (r = a.multipleDeclarations) !== null && r !== void 0 ? r : hs(a.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleImplementations: (o = a.multipleImplementations) !== null && o !== void 0 ? o : hs(a.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleReferences: (s = a.multipleReferences) !== null && s !== void 0 ? s : hs(a.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
      alternativeDefinitionCommand: vo.string(a.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
      alternativeTypeDefinitionCommand: vo.string(a.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
      alternativeDeclarationCommand: vo.string(a.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
      alternativeImplementationCommand: vo.string(a.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
      alternativeReferenceCommand: vo.string(a.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand)
    };
  }
}
class yie extends Yn {
  constructor() {
    const e = {
      enabled: !0,
      delay: 300,
      sticky: !0
    };
    super(50, "hover", e, {
      "editor.hover.enabled": {
        type: "boolean",
        default: e.enabled,
        description: w("hover.enabled", "Controls whether the hover is shown.")
      },
      "editor.hover.delay": {
        type: "number",
        default: e.delay,
        description: w("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
      },
      "editor.hover.sticky": {
        type: "boolean",
        default: e.sticky,
        description: w("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: Ge(t.enabled, this.defaultValue.enabled),
      delay: oi.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
      sticky: Ge(t.sticky, this.defaultValue.sticky)
    };
  }
}
class up extends Cg {
  constructor() {
    super(128, [
      46,
      55,
      35,
      62,
      90,
      57,
      58,
      92,
      115,
      118,
      119,
      120,
      2
      /* accessibilitySupport */
    ]);
  }
  compute(e, t, i) {
    return up.computeLayout(t, {
      memory: e.memory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight,
      isDominatedByLongLines: e.isDominatedByLongLines,
      lineHeight: e.fontInfo.lineHeight,
      viewLineCount: e.viewLineCount,
      lineNumbersDigitCount: e.lineNumbersDigitCount,
      typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
      maxDigitWidth: e.fontInfo.maxDigitWidth,
      pixelRatio: e.pixelRatio
    });
  }
  static computeContainedMinimapLineCount(e) {
    const t = e.height / e.lineHeight, i = e.scrollBeyondLastLine ? t - 1 : 0, r = (e.viewLineCount + i) / (e.pixelRatio * e.height), o = Math.floor(e.viewLineCount / r);
    return { typicalViewportLineCount: t, extraLinesBeyondLastLine: i, desiredRatio: r, minimapLineCount: o };
  }
  static _computeMinimapLayout(e, t) {
    const i = e.outerWidth, r = e.outerHeight, o = e.pixelRatio;
    if (!e.minimap.enabled)
      return {
        renderMinimap: 0,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: !1,
        minimapIsSampling: !1,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: Math.floor(o * r),
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: r
      };
    const s = t.stableMinimapLayoutInput, a = s && e.outerHeight === s.outerHeight && e.lineHeight === s.lineHeight && e.typicalHalfwidthCharacterWidth === s.typicalHalfwidthCharacterWidth && e.pixelRatio === s.pixelRatio && e.scrollBeyondLastLine === s.scrollBeyondLastLine && e.minimap.enabled === s.minimap.enabled && e.minimap.side === s.minimap.side && e.minimap.size === s.minimap.size && e.minimap.showSlider === s.minimap.showSlider && e.minimap.renderCharacters === s.minimap.renderCharacters && e.minimap.maxColumn === s.minimap.maxColumn && e.minimap.scale === s.minimap.scale && e.verticalScrollbarWidth === s.verticalScrollbarWidth && e.isViewportWrapping === s.isViewportWrapping, l = e.lineHeight, u = e.typicalHalfwidthCharacterWidth, c = e.scrollBeyondLastLine, h = e.minimap.renderCharacters;
    let d = o >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale;
    const f = e.minimap.maxColumn, p = e.minimap.size, g = e.minimap.side, _ = e.verticalScrollbarWidth, m = e.viewLineCount, v = e.remainingWidth, C = e.isViewportWrapping, y = h ? 2 : 3;
    let b = Math.floor(o * r);
    const L = b / o;
    let S = !1, E = !1, D = y * d, O = d / o, T = 1;
    if (p === "fill" || p === "fit") {
      const { typicalViewportLineCount: se, extraLinesBeyondLastLine: ne, desiredRatio: Ce, minimapLineCount: ue } = up.computeContainedMinimapLineCount({
        viewLineCount: m,
        scrollBeyondLastLine: c,
        height: r,
        lineHeight: l,
        pixelRatio: o
      });
      if (m / ue > 1)
        S = !0, E = !0, d = 1, D = 1, O = d / o;
      else {
        let z = !1, Y = d + 1;
        if (p === "fit") {
          const x = Math.ceil((m + ne) * D);
          C && a && v <= t.stableFitRemainingWidth ? (z = !0, Y = t.stableFitMaxMinimapScale) : (z = x > b, C && z ? (t.stableMinimapLayoutInput = e, t.stableFitRemainingWidth = v) : (t.stableMinimapLayoutInput = null, t.stableFitRemainingWidth = 0));
        }
        if (p === "fill" || z) {
          S = !0;
          const x = d;
          D = Math.min(l * o, Math.max(1, Math.floor(1 / Ce))), d = Math.min(Y, Math.max(1, Math.floor(D / y))), d > x && (T = Math.min(2, d / x)), O = d / o / T, b = Math.ceil(Math.max(se, m + ne) * D), C && z && (t.stableFitMaxMinimapScale = d);
        }
      }
    }
    const A = Math.floor(f * O), P = Math.min(A, Math.max(0, Math.floor((v - _ - 2) * O / (u + O))) + Vm);
    let G = Math.floor(o * P);
    const U = G / o;
    G = Math.floor(G * T);
    const $ = h ? 1 : 2, k = g === "left" ? 0 : i - P - _;
    return {
      renderMinimap: $,
      minimapLeft: k,
      minimapWidth: P,
      minimapHeightIsEditorHeight: S,
      minimapIsSampling: E,
      minimapScale: d,
      minimapLineHeight: D,
      minimapCanvasInnerWidth: G,
      minimapCanvasInnerHeight: b,
      minimapCanvasOuterWidth: U,
      minimapCanvasOuterHeight: L
    };
  }
  static computeLayout(e, t) {
    const i = t.outerWidth | 0, r = t.outerHeight | 0, o = t.lineHeight | 0, s = t.lineNumbersDigitCount | 0, a = t.typicalHalfwidthCharacterWidth, l = t.maxDigitWidth, u = t.pixelRatio, c = t.viewLineCount, h = e.get(
      120
      /* wordWrapOverride2 */
    ), d = h === "inherit" ? e.get(
      119
      /* wordWrapOverride1 */
    ) : h, f = d === "inherit" ? e.get(
      115
      /* wordWrap */
    ) : d, p = e.get(
      118
      /* wordWrapColumn */
    ), g = e.get(
      2
      /* accessibilitySupport */
    ), _ = t.isDominatedByLongLines, m = e.get(
      46
      /* glyphMargin */
    ), v = e.get(
      57
      /* lineNumbers */
    ).renderType !== 0, C = e.get(
      58
      /* lineNumbersMinChars */
    ), y = e.get(
      92
      /* scrollBeyondLastLine */
    ), b = e.get(
      62
      /* minimap */
    ), L = e.get(
      90
      /* scrollbar */
    ), S = L.verticalScrollbarSize, E = L.verticalHasArrows, D = L.arrowSize, O = L.horizontalScrollbarSize, T = e.get(
      55
      /* lineDecorationsWidth */
    ), A = e.get(
      35
      /* folding */
    );
    let P;
    if (typeof T == "string" && /^\d+(\.\d+)?ch$/.test(T)) {
      const H = parseFloat(T.substr(0, T.length - 2));
      P = oi.clampedInt(H * a, 0, 0, 1e3);
    } else
      P = oi.clampedInt(T, 0, 0, 1e3);
    A && (P += 16);
    let G = 0;
    if (v) {
      const H = Math.max(s, C);
      G = Math.round(H * l);
    }
    let U = 0;
    m && (U = o);
    let $ = 0, k = $ + U, se = k + G, ne = se + P;
    const Ce = i - U - G - P;
    let ue = !1, B = !1, z = -1;
    g !== 2 && (d === "inherit" && _ ? (ue = !0, B = !0) : f === "on" || f === "bounded" ? B = !0 : f === "wordWrapColumn" && (z = p));
    const Y = up._computeMinimapLayout({
      outerWidth: i,
      outerHeight: r,
      lineHeight: o,
      typicalHalfwidthCharacterWidth: a,
      pixelRatio: u,
      scrollBeyondLastLine: y,
      minimap: b,
      verticalScrollbarWidth: S,
      viewLineCount: c,
      remainingWidth: Ce,
      isViewportWrapping: B
    }, t.memory || new nG());
    Y.renderMinimap !== 0 && Y.minimapLeft === 0 && ($ += Y.minimapWidth, k += Y.minimapWidth, se += Y.minimapWidth, ne += Y.minimapWidth);
    const x = Ce - Y.minimapWidth, M = Math.max(1, Math.floor((x - S - 2) / a)), F = E ? D : 0;
    return B && (z = Math.max(1, M), f === "bounded" && (z = Math.min(z, p))), {
      width: i,
      height: r,
      glyphMarginLeft: $,
      glyphMarginWidth: U,
      lineNumbersLeft: k,
      lineNumbersWidth: G,
      decorationsLeft: se,
      decorationsWidth: P,
      contentLeft: ne,
      contentWidth: x,
      minimap: Y,
      viewportColumn: M,
      isWordWrapMinified: ue,
      isViewportWrapping: B,
      wrappingColumn: z,
      verticalScrollbarWidth: S,
      horizontalScrollbarHeight: O,
      overviewRuler: {
        top: F,
        width: S,
        height: r - 2 * F,
        right: 0
      }
    };
  }
}
class wie extends Yn {
  constructor() {
    const e = { enabled: !0 };
    super(54, "lightbulb", e, {
      "editor.lightbulb.enabled": {
        type: "boolean",
        default: e.enabled,
        description: w("codeActions", "Enables the code action lightbulb in the editor.")
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      enabled: Ge(e.enabled, this.defaultValue.enabled)
    };
  }
}
class bie extends Yn {
  constructor() {
    const e = { enabled: !0, fontSize: 0, fontFamily: Ss.fontFamily };
    super(124, "inlayHints", e, {
      "editor.inlayHints.enabled": {
        type: "boolean",
        default: e.enabled,
        description: w("inlayHints.enable", "Enables the inlay hints in the editor.")
      },
      "editor.inlayHints.fontSize": {
        type: "number",
        default: e.fontSize,
        description: w("inlayHints.fontSize", "Controls font size of inlay hints in the editor. When set to `0`, the 90% of `#editor.fontSize#` is used.")
      },
      "editor.inlayHints.fontFamily": {
        type: "string",
        default: e.fontFamily,
        description: w("inlayHints.fontFamily", "Controls font family of inlay hints in the editor.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: Ge(t.enabled, this.defaultValue.enabled),
      fontSize: oi.clampedInt(t.fontSize, this.defaultValue.fontSize, 0, 100),
      fontFamily: vo.string(t.fontFamily, this.defaultValue.fontFamily)
    };
  }
}
class Sie extends oi {
  constructor() {
    super(56, "lineHeight", Ss.lineHeight, 0, 150, { description: w("lineHeight", "Controls the line height. Use 0 to compute the line height from the font size.") });
  }
  compute(e, t, i) {
    return e.fontInfo.lineHeight;
  }
}
class Eie extends Yn {
  constructor() {
    const e = {
      enabled: !0,
      size: "proportional",
      side: "right",
      showSlider: "mouseover",
      renderCharacters: !0,
      maxColumn: 120,
      scale: 1
    };
    super(62, "minimap", e, {
      "editor.minimap.enabled": {
        type: "boolean",
        default: e.enabled,
        description: w("minimap.enabled", "Controls whether the minimap is shown.")
      },
      "editor.minimap.size": {
        type: "string",
        enum: ["proportional", "fill", "fit"],
        enumDescriptions: [
          w("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
          w("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
          w("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
        ],
        default: e.size,
        description: w("minimap.size", "Controls the size of the minimap.")
      },
      "editor.minimap.side": {
        type: "string",
        enum: ["left", "right"],
        default: e.side,
        description: w("minimap.side", "Controls the side where to render the minimap.")
      },
      "editor.minimap.showSlider": {
        type: "string",
        enum: ["always", "mouseover"],
        default: e.showSlider,
        description: w("minimap.showSlider", "Controls when the minimap slider is shown.")
      },
      "editor.minimap.scale": {
        type: "number",
        default: e.scale,
        minimum: 1,
        maximum: 3,
        enum: [1, 2, 3],
        description: w("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
      },
      "editor.minimap.renderCharacters": {
        type: "boolean",
        default: e.renderCharacters,
        description: w("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
      },
      "editor.minimap.maxColumn": {
        type: "number",
        default: e.maxColumn,
        description: w("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: Ge(t.enabled, this.defaultValue.enabled),
      size: hs(t.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
      side: hs(t.side, this.defaultValue.side, ["right", "left"]),
      showSlider: hs(t.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
      renderCharacters: Ge(t.renderCharacters, this.defaultValue.renderCharacters),
      scale: oi.clampedInt(t.scale, 1, 1, 3),
      maxColumn: oi.clampedInt(t.maxColumn, this.defaultValue.maxColumn, 1, 1e4)
    };
  }
}
function Lie(n) {
  return n === "ctrlCmd" ? Ft ? "metaKey" : "ctrlKey" : "altKey";
}
class Die extends Yn {
  constructor() {
    super(72, "padding", { top: 0, bottom: 0 }, {
      "editor.padding.top": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: w("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
      },
      "editor.padding.bottom": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: w("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      top: oi.clampedInt(t.top, 0, 0, 1e3),
      bottom: oi.clampedInt(t.bottom, 0, 0, 1e3)
    };
  }
}
class Rie extends Yn {
  constructor() {
    const e = {
      enabled: !0,
      cycle: !1
    };
    super(73, "parameterHints", e, {
      "editor.parameterHints.enabled": {
        type: "boolean",
        default: e.enabled,
        description: w("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
      },
      "editor.parameterHints.cycle": {
        type: "boolean",
        default: e.cycle,
        description: w("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: Ge(t.enabled, this.defaultValue.enabled),
      cycle: Ge(t.cycle, this.defaultValue.cycle)
    };
  }
}
class Tie extends Cg {
  constructor() {
    super(
      126
      /* pixelRatio */
    );
  }
  compute(e, t, i) {
    return e.pixelRatio;
  }
}
class Oie extends Yn {
  constructor() {
    const e = {
      other: !0,
      comments: !1,
      strings: !1
    };
    super(76, "quickSuggestions", e, {
      anyOf: [
        {
          type: "boolean"
        },
        {
          type: "object",
          properties: {
            strings: {
              type: "boolean",
              default: e.strings,
              description: w("quickSuggestions.strings", "Enable quick suggestions inside strings.")
            },
            comments: {
              type: "boolean",
              default: e.comments,
              description: w("quickSuggestions.comments", "Enable quick suggestions inside comments.")
            },
            other: {
              type: "boolean",
              default: e.other,
              description: w("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
            }
          }
        }
      ],
      default: e,
      description: w("quickSuggestions", "Controls whether suggestions should automatically show up while typing.")
    }), this.defaultValue = e;
  }
  validate(e) {
    if (typeof e == "boolean")
      return e;
    if (e && typeof e == "object") {
      const t = e, i = {
        other: Ge(t.other, this.defaultValue.other),
        comments: Ge(t.comments, this.defaultValue.comments),
        strings: Ge(t.strings, this.defaultValue.strings)
      };
      return i.other && i.comments && i.strings ? !0 : !i.other && !i.comments && !i.strings ? !1 : i;
    }
    return this.defaultValue;
  }
}
class xie extends Yn {
  constructor() {
    super(57, "lineNumbers", { renderType: 1, renderFn: null }, {
      type: "string",
      enum: ["off", "on", "relative", "interval"],
      enumDescriptions: [
        w("lineNumbers.off", "Line numbers are not rendered."),
        w("lineNumbers.on", "Line numbers are rendered as absolute number."),
        w("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
        w("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
      ],
      default: "on",
      description: w("lineNumbers", "Controls the display of line numbers.")
    });
  }
  validate(e) {
    let t = this.defaultValue.renderType, i = this.defaultValue.renderFn;
    return typeof e < "u" && (typeof e == "function" ? (t = 4, i = e) : e === "interval" ? t = 3 : e === "relative" ? t = 2 : e === "on" ? t = 1 : t = 0), {
      renderType: t,
      renderFn: i
    };
  }
}
function rN(n) {
  const e = n.get(
    85
    /* renderValidationDecorations */
  );
  return e === "editable" ? n.get(
    78
    /* readOnly */
  ) : e !== "on";
}
class Nie extends Yn {
  constructor() {
    const e = [], t = { type: "number", description: w("rulers.size", "Number of monospace characters at which this editor ruler will render.") };
    super(89, "rulers", e, {
      type: "array",
      items: {
        anyOf: [
          t,
          {
            type: [
              "object"
            ],
            properties: {
              column: t,
              color: {
                type: "string",
                description: w("rulers.color", "Color of this editor ruler."),
                format: "color-hex"
              }
            }
          }
        ]
      },
      default: e,
      description: w("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
    });
  }
  validate(e) {
    if (Array.isArray(e)) {
      let t = [];
      for (let i of e)
        if (typeof i == "number")
          t.push({
            column: oi.clampedInt(i, 0, 0, 1e4),
            color: null
          });
        else if (i && typeof i == "object") {
          const r = i;
          t.push({
            column: oi.clampedInt(r.column, 0, 0, 1e4),
            color: r.color
          });
        }
      return t.sort((i, r) => i.column - r.column), t;
    }
    return this.defaultValue;
  }
}
function pF(n, e) {
  if (typeof n != "string")
    return e;
  switch (n) {
    case "hidden":
      return 2;
    case "visible":
      return 3;
    default:
      return 1;
  }
}
let Iie = class extends Yn {
  constructor() {
    super(90, "scrollbar", {
      vertical: 1,
      horizontal: 1,
      arrowSize: 11,
      useShadows: !0,
      verticalHasArrows: !1,
      horizontalHasArrows: !1,
      horizontalScrollbarSize: 12,
      horizontalSliderSize: 12,
      verticalScrollbarSize: 14,
      verticalSliderSize: 14,
      handleMouseWheel: !0,
      alwaysConsumeMouseWheel: !0,
      scrollByPage: !1
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e, i = oi.clampedInt(t.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3), r = oi.clampedInt(t.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
    return {
      arrowSize: oi.clampedInt(t.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
      vertical: pF(t.vertical, this.defaultValue.vertical),
      horizontal: pF(t.horizontal, this.defaultValue.horizontal),
      useShadows: Ge(t.useShadows, this.defaultValue.useShadows),
      verticalHasArrows: Ge(t.verticalHasArrows, this.defaultValue.verticalHasArrows),
      horizontalHasArrows: Ge(t.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
      handleMouseWheel: Ge(t.handleMouseWheel, this.defaultValue.handleMouseWheel),
      alwaysConsumeMouseWheel: Ge(t.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
      horizontalScrollbarSize: i,
      horizontalSliderSize: oi.clampedInt(t.horizontalSliderSize, i, 0, 1e3),
      verticalScrollbarSize: r,
      verticalSliderSize: oi.clampedInt(t.verticalSliderSize, r, 0, 1e3),
      scrollByPage: Ge(t.scrollByPage, this.defaultValue.scrollByPage)
    };
  }
};
class Pie extends Yn {
  constructor() {
    const e = {
      enabled: !1
    };
    super(52, "inlineSuggest", e, {
      "editor.inlineSuggest.enabled": {
        type: "boolean",
        default: e.enabled,
        description: w("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      enabled: Ge(e.enabled, this.defaultValue.enabled)
    };
  }
}
class Aie extends Yn {
  constructor() {
    const e = {
      insertMode: "insert",
      filterGraceful: !0,
      snippetsPreventQuickSuggestions: !0,
      localityBonus: !1,
      shareSuggestSelections: !1,
      showIcons: !0,
      showStatusBar: !1,
      preview: !1,
      showInlineDetails: !0,
      showMethods: !0,
      showFunctions: !0,
      showConstructors: !0,
      showDeprecated: !0,
      showFields: !0,
      showVariables: !0,
      showClasses: !0,
      showStructs: !0,
      showInterfaces: !0,
      showModules: !0,
      showProperties: !0,
      showEvents: !0,
      showOperators: !0,
      showUnits: !0,
      showValues: !0,
      showConstants: !0,
      showEnums: !0,
      showEnumMembers: !0,
      showKeywords: !0,
      showWords: !0,
      showColors: !0,
      showFiles: !0,
      showReferences: !0,
      showFolders: !0,
      showTypeParameters: !0,
      showSnippets: !0,
      showUsers: !0,
      showIssues: !0
    };
    super(104, "suggest", e, {
      "editor.suggest.insertMode": {
        type: "string",
        enum: ["insert", "replace"],
        enumDescriptions: [
          w("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
          w("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
        ],
        default: e.insertMode,
        description: w("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
      },
      "editor.suggest.filterGraceful": {
        type: "boolean",
        default: e.filterGraceful,
        description: w("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
      },
      "editor.suggest.localityBonus": {
        type: "boolean",
        default: e.localityBonus,
        description: w("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
      },
      "editor.suggest.shareSuggestSelections": {
        type: "boolean",
        default: e.shareSuggestSelections,
        markdownDescription: w("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
      },
      "editor.suggest.snippetsPreventQuickSuggestions": {
        type: "boolean",
        default: e.snippetsPreventQuickSuggestions,
        description: w("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
      },
      "editor.suggest.showIcons": {
        type: "boolean",
        default: e.showIcons,
        description: w("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
      },
      "editor.suggest.showStatusBar": {
        type: "boolean",
        default: e.showStatusBar,
        description: w("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
      },
      "editor.suggest.preview": {
        type: "boolean",
        default: e.preview,
        description: w("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
      },
      "editor.suggest.showInlineDetails": {
        type: "boolean",
        default: e.showInlineDetails,
        description: w("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget")
      },
      "editor.suggest.maxVisibleSuggestions": {
        type: "number",
        deprecationMessage: w("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
      },
      "editor.suggest.filteredTypes": {
        type: "object",
        deprecationMessage: w("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
      },
      "editor.suggest.showMethods": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
      },
      "editor.suggest.showFunctions": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
      },
      "editor.suggest.showConstructors": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
      },
      "editor.suggest.showDeprecated": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
      },
      "editor.suggest.showFields": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
      },
      "editor.suggest.showVariables": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
      },
      "editor.suggest.showClasses": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
      },
      "editor.suggest.showStructs": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
      },
      "editor.suggest.showInterfaces": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
      },
      "editor.suggest.showModules": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
      },
      "editor.suggest.showProperties": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
      },
      "editor.suggest.showEvents": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
      },
      "editor.suggest.showOperators": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
      },
      "editor.suggest.showUnits": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
      },
      "editor.suggest.showValues": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
      },
      "editor.suggest.showConstants": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
      },
      "editor.suggest.showEnums": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
      },
      "editor.suggest.showEnumMembers": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
      },
      "editor.suggest.showKeywords": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
      },
      "editor.suggest.showWords": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
      },
      "editor.suggest.showColors": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
      },
      "editor.suggest.showFiles": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
      },
      "editor.suggest.showReferences": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
      },
      "editor.suggest.showCustomcolors": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
      },
      "editor.suggest.showFolders": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
      },
      "editor.suggest.showTypeParameters": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
      },
      "editor.suggest.showSnippets": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
      },
      "editor.suggest.showUsers": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
      },
      "editor.suggest.showIssues": {
        type: "boolean",
        default: !0,
        markdownDescription: w("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertMode: hs(t.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
      filterGraceful: Ge(t.filterGraceful, this.defaultValue.filterGraceful),
      snippetsPreventQuickSuggestions: Ge(t.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
      localityBonus: Ge(t.localityBonus, this.defaultValue.localityBonus),
      shareSuggestSelections: Ge(t.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
      showIcons: Ge(t.showIcons, this.defaultValue.showIcons),
      showStatusBar: Ge(t.showStatusBar, this.defaultValue.showStatusBar),
      preview: Ge(t.preview, this.defaultValue.preview),
      showInlineDetails: Ge(t.showInlineDetails, this.defaultValue.showInlineDetails),
      showMethods: Ge(t.showMethods, this.defaultValue.showMethods),
      showFunctions: Ge(t.showFunctions, this.defaultValue.showFunctions),
      showConstructors: Ge(t.showConstructors, this.defaultValue.showConstructors),
      showDeprecated: Ge(t.showDeprecated, this.defaultValue.showDeprecated),
      showFields: Ge(t.showFields, this.defaultValue.showFields),
      showVariables: Ge(t.showVariables, this.defaultValue.showVariables),
      showClasses: Ge(t.showClasses, this.defaultValue.showClasses),
      showStructs: Ge(t.showStructs, this.defaultValue.showStructs),
      showInterfaces: Ge(t.showInterfaces, this.defaultValue.showInterfaces),
      showModules: Ge(t.showModules, this.defaultValue.showModules),
      showProperties: Ge(t.showProperties, this.defaultValue.showProperties),
      showEvents: Ge(t.showEvents, this.defaultValue.showEvents),
      showOperators: Ge(t.showOperators, this.defaultValue.showOperators),
      showUnits: Ge(t.showUnits, this.defaultValue.showUnits),
      showValues: Ge(t.showValues, this.defaultValue.showValues),
      showConstants: Ge(t.showConstants, this.defaultValue.showConstants),
      showEnums: Ge(t.showEnums, this.defaultValue.showEnums),
      showEnumMembers: Ge(t.showEnumMembers, this.defaultValue.showEnumMembers),
      showKeywords: Ge(t.showKeywords, this.defaultValue.showKeywords),
      showWords: Ge(t.showWords, this.defaultValue.showWords),
      showColors: Ge(t.showColors, this.defaultValue.showColors),
      showFiles: Ge(t.showFiles, this.defaultValue.showFiles),
      showReferences: Ge(t.showReferences, this.defaultValue.showReferences),
      showFolders: Ge(t.showFolders, this.defaultValue.showFolders),
      showTypeParameters: Ge(t.showTypeParameters, this.defaultValue.showTypeParameters),
      showSnippets: Ge(t.showSnippets, this.defaultValue.showSnippets),
      showUsers: Ge(t.showUsers, this.defaultValue.showUsers),
      showIssues: Ge(t.showIssues, this.defaultValue.showIssues)
    };
  }
}
class Mie extends Yn {
  constructor() {
    super(100, "smartSelect", {
      selectLeadingAndTrailingWhitespace: !0
    }, {
      "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
        description: w("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
        default: !0,
        type: "boolean"
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      selectLeadingAndTrailingWhitespace: Ge(e.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace)
    };
  }
}
class Fie extends Cg {
  constructor() {
    super(127, [
      78
      /* readOnly */
    ]);
  }
  compute(e, t, i) {
    return t.get(
      78
      /* readOnly */
    ) ? !0 : e.tabFocusMode;
  }
}
function kie(n) {
  switch (n) {
    case "none":
      return 0;
    case "same":
      return 1;
    case "indent":
      return 2;
    case "deepIndent":
      return 3;
  }
}
class Wie extends Cg {
  constructor() {
    super(129, [
      128
      /* layoutInfo */
    ]);
  }
  compute(e, t, i) {
    const r = t.get(
      128
      /* layoutInfo */
    );
    return {
      isDominatedByLongLines: e.isDominatedByLongLines,
      isWordWrapMinified: r.isWordWrapMinified,
      isViewportWrapping: r.isViewportWrapping,
      wrappingColumn: r.wrappingColumn
    };
  }
}
const Vie = "Consolas, 'Courier New', monospace", Bie = "Menlo, Monaco, 'Courier New', monospace", Hie = "'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback'", Ss = {
  fontFamily: Ft ? Bie : Rs ? Hie : Vie,
  fontWeight: "normal",
  fontSize: Ft ? 12 : 14,
  lineHeight: 0,
  letterSpacing: 0
}, Co = {
  tabSize: 4,
  indentSize: 4,
  insertSpaces: !0,
  detectIndentation: !0,
  trimAutoWhitespace: !0,
  largeFileOptimizations: !0
}, jf = [];
function ae(n) {
  return jf[n.id] = n, n;
}
const Kd = {
  acceptSuggestionOnCommitCharacter: ae(new ut(0, "acceptSuggestionOnCommitCharacter", !0, { markdownDescription: w("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
  acceptSuggestionOnEnter: ae(new sn(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
    markdownEnumDescriptions: [
      "",
      w("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
      ""
    ],
    markdownDescription: w("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
  })),
  accessibilitySupport: ae(new cie()),
  accessibilityPageSize: ae(new oi(3, "accessibilityPageSize", 10, 1, 1073741824, {
    description: w("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default.")
  })),
  ariaLabel: ae(new vo(4, "ariaLabel", w("editorViewAccessibleLabel", "Editor content"))),
  autoClosingBrackets: ae(new sn(5, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      w("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
      w("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
      ""
    ],
    description: w("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
  })),
  autoClosingDelete: ae(new sn(6, "autoClosingDelete", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      w("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: w("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
  })),
  autoClosingOvertype: ae(new sn(7, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      w("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: w("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
  })),
  autoClosingQuotes: ae(new sn(8, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      w("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
      w("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
      ""
    ],
    description: w("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
  })),
  autoIndent: ae(new Sm(9, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], uie, {
    enumDescriptions: [
      w("editor.autoIndent.none", "The editor will not insert indentation automatically."),
      w("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
      w("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
      w("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
      w("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
    ],
    description: w("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
  })),
  automaticLayout: ae(new ut(10, "automaticLayout", !1)),
  autoSurround: ae(new sn(11, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
    enumDescriptions: [
      w("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
      w("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
      w("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
      ""
    ],
    description: w("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
  })),
  stickyTabStops: ae(new ut(102, "stickyTabStops", !1, { description: w("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
  codeLens: ae(new ut(12, "codeLens", !0, { description: w("codeLens", "Controls whether the editor shows CodeLens.") })),
  codeLensFontFamily: ae(new vo(13, "codeLensFontFamily", "", { description: w("codeLensFontFamily", "Controls the font family for CodeLens.") })),
  codeLensFontSize: ae(new oi(14, "codeLensFontSize", 0, 0, 100, {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 100,
    description: w("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to `0`, the 90% of `#editor.fontSize#` is used.")
  })),
  colorDecorators: ae(new ut(15, "colorDecorators", !0, { description: w("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.") })),
  columnSelection: ae(new ut(16, "columnSelection", !1, { description: w("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.") })),
  comments: ae(new hie()),
  contextmenu: ae(new ut(18, "contextmenu", !0)),
  copyWithSyntaxHighlighting: ae(new ut(19, "copyWithSyntaxHighlighting", !0, { description: w("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.") })),
  cursorBlinking: ae(new Sm(20, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], die, { description: w("cursorBlinking", "Control the cursor animation style.") })),
  cursorSmoothCaretAnimation: ae(new ut(21, "cursorSmoothCaretAnimation", !1, { description: w("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.") })),
  cursorStyle: ae(new Sm(22, "cursorStyle", kn.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], fie, { description: w("cursorStyle", "Controls the cursor style.") })),
  cursorSurroundingLines: ae(new oi(23, "cursorSurroundingLines", 0, 0, 1073741824, { description: w("cursorSurroundingLines", "Controls the minimal number of visible leading and trailing lines surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
  cursorSurroundingLinesStyle: ae(new sn(24, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
    enumDescriptions: [
      w("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
      w("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
    ],
    description: w("cursorSurroundingLinesStyle", "Controls when `cursorSurroundingLines` should be enforced.")
  })),
  cursorWidth: ae(new oi(25, "cursorWidth", 0, 0, 1073741824, { markdownDescription: w("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
  disableLayerHinting: ae(new ut(26, "disableLayerHinting", !1)),
  disableMonospaceOptimizations: ae(new ut(27, "disableMonospaceOptimizations", !1)),
  domReadOnly: ae(new ut(28, "domReadOnly", !1)),
  dragAndDrop: ae(new ut(29, "dragAndDrop", !0, { description: w("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.") })),
  emptySelectionClipboard: ae(new gie()),
  extraEditorClassName: ae(new vo(31, "extraEditorClassName", "")),
  fastScrollSensitivity: ae(new Hc(32, "fastScrollSensitivity", 5, (n) => n <= 0 ? 5 : n, { markdownDescription: w("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.") })),
  find: ae(new mie()),
  fixedOverflowWidgets: ae(new ut(34, "fixedOverflowWidgets", !1)),
  folding: ae(new ut(35, "folding", !0, { description: w("folding", "Controls whether the editor has code folding enabled.") })),
  foldingStrategy: ae(new sn(36, "foldingStrategy", "auto", ["auto", "indentation"], {
    enumDescriptions: [
      w("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
      w("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
    ],
    description: w("foldingStrategy", "Controls the strategy for computing folding ranges.")
  })),
  foldingHighlight: ae(new ut(37, "foldingHighlight", !0, { description: w("foldingHighlight", "Controls whether the editor should highlight folded ranges.") })),
  unfoldOnClickAfterEndOfLine: ae(new ut(38, "unfoldOnClickAfterEndOfLine", !1, { description: w("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
  fontFamily: ae(new vo(39, "fontFamily", Ss.fontFamily, { description: w("fontFamily", "Controls the font family.") })),
  fontInfo: ae(new vie()),
  fontLigatures2: ae(new fs()),
  fontSize: ae(new _ie()),
  fontWeight: ae(new Nl()),
  formatOnPaste: ae(new ut(44, "formatOnPaste", !1, { description: w("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
  formatOnType: ae(new ut(45, "formatOnType", !1, { description: w("formatOnType", "Controls whether the editor should automatically format the line after typing.") })),
  glyphMargin: ae(new ut(46, "glyphMargin", !0, { description: w("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
  gotoLocation: ae(new Cie()),
  hideCursorInOverviewRuler: ae(new ut(48, "hideCursorInOverviewRuler", !1, { description: w("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.") })),
  highlightActiveIndentGuide: ae(new ut(49, "highlightActiveIndentGuide", !0, { description: w("highlightActiveIndentGuide", "Controls whether the editor should highlight the active indent guide.") })),
  hover: ae(new yie()),
  inDiffEditor: ae(new ut(51, "inDiffEditor", !1)),
  letterSpacing: ae(new Hc(53, "letterSpacing", Ss.letterSpacing, (n) => Hc.clamp(n, -5, 20), { description: w("letterSpacing", "Controls the letter spacing in pixels.") })),
  lightbulb: ae(new wie()),
  lineDecorationsWidth: ae(new $d(55, "lineDecorationsWidth", 10)),
  lineHeight: ae(new Sie()),
  lineNumbers: ae(new xie()),
  lineNumbersMinChars: ae(new oi(58, "lineNumbersMinChars", 5, 1, 300)),
  linkedEditing: ae(new ut(59, "linkedEditing", !1, { description: w("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols, e.g. HTML tags, are updated while editing.") })),
  links: ae(new ut(60, "links", !0, { description: w("links", "Controls whether the editor should detect links and make them clickable.") })),
  matchBrackets: ae(new sn(61, "matchBrackets", "always", ["always", "near", "never"], { description: w("matchBrackets", "Highlight matching brackets.") })),
  minimap: ae(new Eie()),
  mouseStyle: ae(new sn(63, "mouseStyle", "text", ["text", "default", "copy"])),
  mouseWheelScrollSensitivity: ae(new Hc(64, "mouseWheelScrollSensitivity", 1, (n) => n === 0 ? 1 : n, { markdownDescription: w("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
  mouseWheelZoom: ae(new ut(65, "mouseWheelZoom", !1, { markdownDescription: w("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.") })),
  multiCursorMergeOverlapping: ae(new ut(66, "multiCursorMergeOverlapping", !0, { description: w("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.") })),
  multiCursorModifier: ae(new Sm(67, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], Lie, {
    markdownEnumDescriptions: [
      w("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
      w("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
    ],
    markdownDescription: w({
      key: "multiCursorModifier",
      comment: [
        "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
        "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
      ]
    }, "The modifier to be used to add multiple cursors with the mouse. The Go To Definition and Open Link mouse gestures will adapt such that they do not conflict with the multicursor modifier. [Read more](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
  })),
  multiCursorPaste: ae(new sn(68, "multiCursorPaste", "spread", ["spread", "full"], {
    markdownEnumDescriptions: [
      w("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
      w("multiCursorPaste.full", "Each cursor pastes the full text.")
    ],
    markdownDescription: w("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
  })),
  occurrencesHighlight: ae(new ut(69, "occurrencesHighlight", !0, { description: w("occurrencesHighlight", "Controls whether the editor should highlight semantic symbol occurrences.") })),
  overviewRulerBorder: ae(new ut(70, "overviewRulerBorder", !0, { description: w("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.") })),
  overviewRulerLanes: ae(new oi(71, "overviewRulerLanes", 3, 0, 3)),
  padding: ae(new Die()),
  parameterHints: ae(new Rie()),
  peekWidgetDefaultFocus: ae(new sn(74, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
    enumDescriptions: [
      w("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
      w("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
    ],
    description: w("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
  })),
  definitionLinkOpensInPeek: ae(new ut(75, "definitionLinkOpensInPeek", !1, { description: w("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
  quickSuggestions: ae(new Oie()),
  quickSuggestionsDelay: ae(new oi(77, "quickSuggestionsDelay", 10, 0, 1073741824, { description: w("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.") })),
  readOnly: ae(new ut(78, "readOnly", !1)),
  renameOnType: ae(new ut(79, "renameOnType", !1, { description: w("renameOnType", "Controls whether the editor auto renames on type."), markdownDeprecationMessage: w("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.") })),
  renderControlCharacters: ae(new ut(80, "renderControlCharacters", !1, { description: w("renderControlCharacters", "Controls whether the editor should render control characters.") })),
  renderIndentGuides: ae(new ut(81, "renderIndentGuides", !0, { description: w("renderIndentGuides", "Controls whether the editor should render indent guides.") })),
  renderFinalNewline: ae(new ut(82, "renderFinalNewline", !0, { description: w("renderFinalNewline", "Render last line number when the file ends with a newline.") })),
  renderLineHighlight: ae(new sn(83, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
    enumDescriptions: [
      "",
      "",
      "",
      w("renderLineHighlight.all", "Highlights both the gutter and the current line.")
    ],
    description: w("renderLineHighlight", "Controls how the editor should render the current line highlight.")
  })),
  renderLineHighlightOnlyWhenFocus: ae(new ut(84, "renderLineHighlightOnlyWhenFocus", !1, { description: w("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.") })),
  renderValidationDecorations: ae(new sn(85, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
  renderWhitespace: ae(new sn(86, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
    enumDescriptions: [
      "",
      w("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
      w("renderWhitespace.selection", "Render whitespace characters only on selected text."),
      w("renderWhitespace.trailing", "Render only trailing whitespace characters."),
      ""
    ],
    description: w("renderWhitespace", "Controls how the editor should render whitespace characters.")
  })),
  revealHorizontalRightPadding: ae(new oi(87, "revealHorizontalRightPadding", 30, 0, 1e3)),
  roundedSelection: ae(new ut(88, "roundedSelection", !0, { description: w("roundedSelection", "Controls whether selections should have rounded corners.") })),
  rulers: ae(new Nie()),
  scrollbar: ae(new Iie()),
  scrollBeyondLastColumn: ae(new oi(91, "scrollBeyondLastColumn", 5, 0, 1073741824, { description: w("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
  scrollBeyondLastLine: ae(new ut(92, "scrollBeyondLastLine", !0, { description: w("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.") })),
  scrollPredominantAxis: ae(new ut(93, "scrollPredominantAxis", !0, { description: w("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
  selectionClipboard: ae(new ut(94, "selectionClipboard", !0, {
    description: w("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
    included: Rs
  })),
  selectionHighlight: ae(new ut(95, "selectionHighlight", !0, { description: w("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.") })),
  selectOnLineNumbers: ae(new ut(96, "selectOnLineNumbers", !0)),
  showFoldingControls: ae(new sn(97, "showFoldingControls", "mouseover", ["always", "mouseover"], {
    enumDescriptions: [
      w("showFoldingControls.always", "Always show the folding controls."),
      w("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
    ],
    description: w("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
  })),
  showUnused: ae(new ut(98, "showUnused", !0, { description: w("showUnused", "Controls fading out of unused code.") })),
  showDeprecated: ae(new ut(123, "showDeprecated", !0, { description: w("showDeprecated", "Controls strikethrough deprecated variables.") })),
  inlayHints: ae(new bie()),
  snippetSuggestions: ae(new sn(99, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
    enumDescriptions: [
      w("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
      w("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
      w("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
      w("snippetSuggestions.none", "Do not show snippet suggestions.")
    ],
    description: w("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
  })),
  smartSelect: ae(new Mie()),
  smoothScrolling: ae(new ut(101, "smoothScrolling", !1, { description: w("smoothScrolling", "Controls whether the editor will scroll using an animation.") })),
  stopRenderingLineAfter: ae(new oi(
    103,
    "stopRenderingLineAfter",
    1e4,
    -1,
    1073741824
    /* MAX_SAFE_SMALL_INTEGER */
  )),
  suggest: ae(new Aie()),
  inlineSuggest: ae(new Pie()),
  suggestFontSize: ae(new oi(105, "suggestFontSize", 0, 0, 1e3, { markdownDescription: w("suggestFontSize", "Font size for the suggest widget. When set to `0`, the value of `#editor.fontSize#` is used.") })),
  suggestLineHeight: ae(new oi(106, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: w("suggestLineHeight", "Line height for the suggest widget. When set to `0`, the value of `#editor.lineHeight#` is used. The minimum value is 8.") })),
  suggestOnTriggerCharacters: ae(new ut(107, "suggestOnTriggerCharacters", !0, { description: w("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.") })),
  suggestSelection: ae(new sn(108, "suggestSelection", "recentlyUsed", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
    markdownEnumDescriptions: [
      w("suggestSelection.first", "Always select the first suggestion."),
      w("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
      w("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
    ],
    description: w("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
  })),
  tabCompletion: ae(new sn(109, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
    enumDescriptions: [
      w("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
      w("tabCompletion.off", "Disable tab completions."),
      w("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
    ],
    description: w("tabCompletion", "Enables tab completions.")
  })),
  tabIndex: ae(new oi(
    110,
    "tabIndex",
    0,
    -1,
    1073741824
    /* MAX_SAFE_SMALL_INTEGER */
  )),
  unusualLineTerminators: ae(new sn(111, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
    enumDescriptions: [
      w("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
      w("unusualLineTerminators.off", "Unusual line terminators are ignored."),
      w("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
    ],
    description: w("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
  })),
  useShadowDOM: ae(new ut(112, "useShadowDOM", !0)),
  useTabStops: ae(new ut(113, "useTabStops", !0, { description: w("useTabStops", "Inserting and deleting whitespace follows tab stops.") })),
  wordSeparators: ae(new vo(114, "wordSeparators", eG, { description: w("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.") })),
  wordWrap: ae(new sn(115, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
    markdownEnumDescriptions: [
      w("wordWrap.off", "Lines will never wrap."),
      w("wordWrap.on", "Lines will wrap at the viewport width."),
      w({
        key: "wordWrap.wordWrapColumn",
        comment: [
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at `#editor.wordWrapColumn#`."),
      w({
        key: "wordWrap.bounded",
        comment: [
          "- viewport means the edge of the visible window size.",
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
    ],
    description: w({
      key: "wordWrap",
      comment: [
        "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
        "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
      ]
    }, "Controls how lines should wrap.")
  })),
  wordWrapBreakAfterCharacters: ae(new vo(116, "wordWrapBreakAfterCharacters", " 	})]?|/&.,;")),
  wordWrapBreakBeforeCharacters: ae(new vo(117, "wordWrapBreakBeforeCharacters", "([{+")),
  wordWrapColumn: ae(new oi(118, "wordWrapColumn", 80, 1, 1073741824, {
    markdownDescription: w({
      key: "wordWrapColumn",
      comment: [
        "- `editor.wordWrap` refers to a different setting and should not be localized.",
        "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
      ]
    }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
  })),
  wordWrapOverride1: ae(new sn(119, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
  wordWrapOverride2: ae(new sn(120, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
  wrappingIndent: ae(new Sm(121, "wrappingIndent", 1, "same", ["none", "same", "indent", "deepIndent"], kie, {
    enumDescriptions: [
      w("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
      w("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
      w("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
      w("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
    ],
    description: w("wrappingIndent", "Controls the indentation of wrapped lines.")
  })),
  wrappingStrategy: ae(new sn(122, "wrappingStrategy", "simple", ["simple", "advanced"], {
    enumDescriptions: [
      w("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
      w("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
    ],
    description: w("wrappingStrategy", "Controls the algorithm that computes wrapping points.")
  })),
  // Leave these at the end (because they have dependencies!)
  editorClassName: ae(new pie()),
  pixelRatio: ae(new Tie()),
  tabFocusMode: ae(new Fie()),
  layoutInfo: ae(new up()),
  wrappingInfo: ae(new Wie())
};
class Gie {
  constructor() {
    this.listeners = [], this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        throw e.stack ? new Error(e.message + `

` + e.stack) : e;
      }, 0);
    };
  }
  emit(e) {
    this.listeners.forEach((t) => {
      t(e);
    });
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e), this.emit(e);
  }
  // For external errors, we don't want the listeners to be called
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
}
const rG = new Gie();
function Ni(n) {
  I_(n) || rG.onUnexpectedError(n);
}
function N_(n) {
  I_(n) || rG.onUnexpectedExternalError(n);
}
function gF(n) {
  if (n instanceof Error) {
    let { name: e, message: t } = n;
    const i = n.stacktrace || n.stack;
    return {
      $isError: !0,
      name: e,
      message: t,
      stack: i
    };
  }
  return n;
}
const Y1 = "Canceled";
function I_(n) {
  return n instanceof Error && n.name === Y1 && n.message === Y1;
}
function HS() {
  const n = new Error(Y1);
  return n.name = n.message, n;
}
function P_(n) {
  return n ? new Error(`Illegal argument: ${n}`) : new Error("Illegal argument");
}
function Uie(n) {
  return n ? new Error(`Illegal state: ${n}`) : new Error("Illegal state");
}
var _t;
(function(n) {
  function e(v) {
    return v && typeof v == "object" && typeof v[Symbol.iterator] == "function";
  }
  n.is = e;
  const t = Object.freeze([]);
  function i() {
    return t;
  }
  n.empty = i;
  function* r(v) {
    yield v;
  }
  n.single = r;
  function o(v) {
    return v || t;
  }
  n.from = o;
  function s(v) {
    return !v || v[Symbol.iterator]().next().done === !0;
  }
  n.isEmpty = s;
  function a(v) {
    return v[Symbol.iterator]().next().value;
  }
  n.first = a;
  function l(v, C) {
    for (const y of v)
      if (C(y))
        return !0;
    return !1;
  }
  n.some = l;
  function u(v, C) {
    for (const y of v)
      if (C(y))
        return y;
  }
  n.find = u;
  function* c(v, C) {
    for (const y of v)
      C(y) && (yield y);
  }
  n.filter = c;
  function* h(v, C) {
    let y = 0;
    for (const b of v)
      yield C(b, y++);
  }
  n.map = h;
  function* d(...v) {
    for (const C of v)
      for (const y of C)
        yield y;
  }
  n.concat = d;
  function* f(v) {
    for (const C of v)
      for (const y of C)
        yield y;
  }
  n.concatNested = f;
  function p(v, C, y) {
    let b = y;
    for (const L of v)
      b = C(b, L);
    return b;
  }
  n.reduce = p;
  function* g(v, C, y = v.length) {
    for (C < 0 && (C += v.length), y < 0 ? y += v.length : y > v.length && (y = v.length); C < y; C++)
      yield v[C];
  }
  n.slice = g;
  function _(v, C = Number.POSITIVE_INFINITY) {
    const y = [];
    if (C === 0)
      return [y, v];
    const b = v[Symbol.iterator]();
    for (let L = 0; L < C; L++) {
      const S = b.next();
      if (S.done)
        return [y, n.empty()];
      y.push(S.value);
    }
    return [y, { [Symbol.iterator]() {
      return b;
    } }];
  }
  n.consume = _;
  function m(v, C, y = (b, L) => b === L) {
    const b = v[Symbol.iterator](), L = C[Symbol.iterator]();
    for (; ; ) {
      const S = b.next(), E = L.next();
      if (S.done !== E.done)
        return !1;
      if (S.done)
        return !0;
      if (!y(S.value, E.value))
        return !1;
    }
  }
  n.equals = m;
})(_t || (_t = {}));
function zie(n) {
}
class jie extends Error {
  constructor(e) {
    super(`Encountered errors while disposing of store. Errors: [${e.join(", ")}]`), this.errors = e;
  }
}
function $ie(n) {
  return typeof n.dispose == "function" && n.dispose.length === 0;
}
function yi(n) {
  if (_t.is(n)) {
    let e = [];
    for (const t of n)
      if (t)
        try {
          t.dispose();
        } catch (i) {
          e.push(i);
        }
    if (e.length === 1)
      throw e[0];
    if (e.length > 1)
      throw new jie(e);
    return Array.isArray(n) ? [] : n;
  } else if (n)
    return n.dispose(), n;
}
function cp(...n) {
  return n.forEach(zie), Ri(() => yi(n));
}
function Ri(n) {
  return {
    dispose: () => {
      n();
    }
  };
}
class ht {
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set(), this._isDisposed = !1;
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this.clear());
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    try {
      yi(this._toDispose.values());
    } finally {
      this._toDispose.clear();
    }
  }
  add(e) {
    if (!e)
      return e;
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._isDisposed ? ht.DISABLE_DISPOSED_WARNING || console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this._toDispose.add(e), e;
  }
}
ht.DISABLE_DISPOSED_WARNING = !1;
class ge {
  constructor() {
    this._store = new ht();
  }
  dispose() {
    this._store.dispose();
  }
  _register(e) {
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._store.add(e);
  }
}
ge.None = Object.freeze({ dispose() {
} });
class Kie {
  constructor() {
    this._isDisposed = !1;
  }
  get value() {
    return this._isDisposed ? void 0 : this._value;
  }
  set value(e) {
    var t;
    this._isDisposed || e === this._value || ((t = this._value) === null || t === void 0 || t.dispose(), this._value = e);
  }
  clear() {
    this.value = void 0;
  }
  dispose() {
    var e;
    this._isDisposed = !0, (e = this._value) === null || e === void 0 || e.dispose(), this._value = void 0;
  }
}
class qie {
  constructor(e) {
    this.object = e;
  }
  dispose() {
  }
}
let nn = class X1 {
  constructor(e) {
    this.element = e, this.next = X1.Undefined, this.prev = X1.Undefined;
  }
};
nn.Undefined = new nn(void 0);
class ua {
  constructor() {
    this._first = nn.Undefined, this._last = nn.Undefined, this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === nn.Undefined;
  }
  clear() {
    let e = this._first;
    for (; e !== nn.Undefined; ) {
      const t = e.next;
      e.prev = nn.Undefined, e.next = nn.Undefined, e = t;
    }
    this._first = nn.Undefined, this._last = nn.Undefined, this._size = 0;
  }
  unshift(e) {
    return this._insert(e, !1);
  }
  push(e) {
    return this._insert(e, !0);
  }
  _insert(e, t) {
    const i = new nn(e);
    if (this._first === nn.Undefined)
      this._first = i, this._last = i;
    else if (t) {
      const o = this._last;
      this._last = i, i.prev = o, o.next = i;
    } else {
      const o = this._first;
      this._first = i, i.next = o, o.prev = i;
    }
    this._size += 1;
    let r = !1;
    return () => {
      r || (r = !0, this._remove(i));
    };
  }
  shift() {
    if (this._first !== nn.Undefined) {
      const e = this._first.element;
      return this._remove(this._first), e;
    }
  }
  pop() {
    if (this._last !== nn.Undefined) {
      const e = this._last.element;
      return this._remove(this._last), e;
    }
  }
  _remove(e) {
    if (e.prev !== nn.Undefined && e.next !== nn.Undefined) {
      const t = e.prev;
      t.next = e.next, e.next.prev = t;
    } else
      e.prev === nn.Undefined && e.next === nn.Undefined ? (this._first = nn.Undefined, this._last = nn.Undefined) : e.next === nn.Undefined ? (this._last = this._last.prev, this._last.next = nn.Undefined) : e.prev === nn.Undefined && (this._first = this._first.next, this._first.prev = nn.Undefined);
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let e = this._first;
    for (; e !== nn.Undefined; )
      yield e.element, e = e.next;
  }
}
const Yie = gn.performance && typeof gn.performance.now == "function";
class yg {
  constructor(e) {
    this._highResolution = Yie && e, this._startTime = this._now(), this._stopTime = -1;
  }
  static create(e = !0) {
    return new yg(e);
  }
  stop() {
    this._stopTime = this._now();
  }
  elapsed() {
    return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
  }
  _now() {
    return this._highResolution ? gn.performance.now() : Date.now();
  }
}
var Ae;
(function(n) {
  n.None = () => ge.None;
  function e(y) {
    return (b, L = null, S) => {
      let E = !1, D;
      return D = y((O) => {
        if (!E)
          return D ? D.dispose() : E = !0, b.call(L, O);
      }, null, S), E && D.dispose(), D;
    };
  }
  n.once = e;
  function t(y, b) {
    return l((L, S = null, E) => y((D) => L.call(S, b(D)), null, E));
  }
  n.map = t;
  function i(y, b) {
    return l((L, S = null, E) => y((D) => {
      b(D), L.call(S, D);
    }, null, E));
  }
  n.forEach = i;
  function r(y, b) {
    return l((L, S = null, E) => y((D) => b(D) && L.call(S, D), null, E));
  }
  n.filter = r;
  function o(y) {
    return y;
  }
  n.signal = o;
  function s(...y) {
    return (b, L = null, S) => cp(...y.map((E) => E((D) => b.call(L, D), null, S)));
  }
  n.any = s;
  function a(y, b, L) {
    let S = L;
    return t(y, (E) => (S = b(S, E), S));
  }
  n.reduce = a;
  function l(y) {
    let b;
    const L = new j({
      onFirstListenerAdd() {
        b = y(L.fire, L);
      },
      onLastListenerRemove() {
        b.dispose();
      }
    });
    return L.event;
  }
  n.snapshot = l;
  function u(y, b, L = 100, S = !1, E) {
    let D, O, T, A = 0;
    const P = new j({
      leakWarningThreshold: E,
      onFirstListenerAdd() {
        D = y((G) => {
          A++, O = b(O, G), S && !T && (P.fire(O), O = void 0), clearTimeout(T), T = setTimeout(() => {
            const U = O;
            O = void 0, T = void 0, (!S || A > 1) && P.fire(U), A = 0;
          }, L);
        });
      },
      onLastListenerRemove() {
        D.dispose();
      }
    });
    return P.event;
  }
  n.debounce = u;
  function c(y) {
    const b = (/* @__PURE__ */ new Date()).getTime();
    return t(e(y), (L) => (/* @__PURE__ */ new Date()).getTime() - b);
  }
  n.stopwatch = c;
  function h(y, b = (L, S) => L === S) {
    let L = !0, S;
    return r(y, (E) => {
      const D = L || !b(E, S);
      return L = !1, S = E, D;
    });
  }
  n.latch = h;
  function d(y, b) {
    return [
      n.filter(y, b),
      n.filter(y, (L) => !b(L))
    ];
  }
  n.split = d;
  function f(y, b = !1, L = []) {
    let S = L.slice(), E = y((T) => {
      S ? S.push(T) : O.fire(T);
    });
    const D = () => {
      S && S.forEach((T) => O.fire(T)), S = null;
    }, O = new j({
      onFirstListenerAdd() {
        E || (E = y((T) => O.fire(T)));
      },
      onFirstListenerDidAdd() {
        S && (b ? setTimeout(D) : D());
      },
      onLastListenerRemove() {
        E && E.dispose(), E = null;
      }
    });
    return O.event;
  }
  n.buffer = f;
  class p {
    constructor(b) {
      this.event = b;
    }
    map(b) {
      return new p(t(this.event, b));
    }
    forEach(b) {
      return new p(i(this.event, b));
    }
    filter(b) {
      return new p(r(this.event, b));
    }
    reduce(b, L) {
      return new p(a(this.event, b, L));
    }
    latch() {
      return new p(h(this.event));
    }
    debounce(b, L = 100, S = !1, E) {
      return new p(u(this.event, b, L, S, E));
    }
    on(b, L, S) {
      return this.event(b, L, S);
    }
    once(b, L, S) {
      return e(this.event)(b, L, S);
    }
  }
  function g(y) {
    return new p(y);
  }
  n.chain = g;
  function _(y, b, L = (S) => S) {
    const S = (...T) => O.fire(L(...T)), E = () => y.on(b, S), D = () => y.removeListener(b, S), O = new j({ onFirstListenerAdd: E, onLastListenerRemove: D });
    return O.event;
  }
  n.fromNodeEventEmitter = _;
  function m(y, b, L = (S) => S) {
    const S = (...T) => O.fire(L(...T)), E = () => y.addEventListener(b, S), D = () => y.removeEventListener(b, S), O = new j({ onFirstListenerAdd: E, onLastListenerRemove: D });
    return O.event;
  }
  n.fromDOMEventEmitter = m;
  function v(y) {
    const b = new j();
    let L = !1;
    return y.then(void 0, () => null).then(() => {
      L ? b.fire(void 0) : setTimeout(() => b.fire(void 0), 0);
    }), L = !0, b.event;
  }
  n.fromPromise = v;
  function C(y) {
    return new Promise((b) => e(y)(b));
  }
  n.toPromise = C;
})(Ae || (Ae = {}));
class GS {
  constructor(e) {
    this._listenerCount = 0, this._invocationCount = 0, this._elapsedOverall = 0, this._name = `${e}_${GS._idPool++}`;
  }
  start(e) {
    this._stopWatch = new yg(!0), this._listenerCount = e;
  }
  stop() {
    if (this._stopWatch) {
      const e = this._stopWatch.elapsed();
      this._elapsedOverall += e, this._invocationCount += 1, console.info(`did FIRE ${this._name}: elapsed_ms: ${e.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`), this._stopWatch = void 0;
    }
  }
}
GS._idPool = 0;
let j = class oG {
  constructor(e) {
    var t;
    this._disposed = !1, this._options = e, this._leakageMon = void 0, this._perfMon = !((t = this._options) === null || t === void 0) && t._profName ? new GS(this._options._profName) : void 0;
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    return this._event || (this._event = (e, t, i) => {
      var r;
      this._listeners || (this._listeners = new ua());
      const o = this._listeners.isEmpty();
      o && this._options && this._options.onFirstListenerAdd && this._options.onFirstListenerAdd(this);
      const s = this._listeners.push(t ? [e, t] : e);
      o && this._options && this._options.onFirstListenerDidAdd && this._options.onFirstListenerDidAdd(this), this._options && this._options.onListenerDidAdd && this._options.onListenerDidAdd(this, e, t);
      const a = (r = this._leakageMon) === null || r === void 0 ? void 0 : r.check(this._listeners.size);
      let l;
      return l = {
        dispose: () => {
          a && a(), l.dispose = oG._noop, this._disposed || (s(), this._options && this._options.onLastListenerRemove && (this._listeners && !this._listeners.isEmpty() || this._options.onLastListenerRemove(this)));
        }
      }, i instanceof ht ? i.add(l) : Array.isArray(i) && i.push(l), l;
    }), this._event;
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(e) {
    var t, i;
    if (this._listeners) {
      this._deliveryQueue || (this._deliveryQueue = new ua());
      for (let r of this._listeners)
        this._deliveryQueue.push([r, e]);
      for ((t = this._perfMon) === null || t === void 0 || t.start(this._deliveryQueue.size); this._deliveryQueue.size > 0; ) {
        const [r, o] = this._deliveryQueue.shift();
        try {
          typeof r == "function" ? r.call(void 0, o) : r[0].call(r[1], o);
        } catch (s) {
          Ni(s);
        }
      }
      (i = this._perfMon) === null || i === void 0 || i.stop();
    }
  }
  dispose() {
    var e, t, i, r, o;
    this._disposed || (this._disposed = !0, (e = this._listeners) === null || e === void 0 || e.clear(), (t = this._deliveryQueue) === null || t === void 0 || t.clear(), (r = (i = this._options) === null || i === void 0 ? void 0 : i.onLastListenerRemove) === null || r === void 0 || r.call(i), (o = this._leakageMon) === null || o === void 0 || o.dispose());
  }
};
j._noop = function() {
};
class Z1 extends j {
  constructor(e) {
    super(e), this._isPaused = 0, this._eventQueue = new ua(), this._mergeFn = e == null ? void 0 : e.merge;
  }
  pause() {
    this._isPaused++;
  }
  resume() {
    if (this._isPaused !== 0 && --this._isPaused === 0)
      if (this._mergeFn) {
        const e = Array.from(this._eventQueue);
        this._eventQueue.clear(), super.fire(this._mergeFn(e));
      } else
        for (; !this._isPaused && this._eventQueue.size !== 0; )
          super.fire(this._eventQueue.shift());
  }
  fire(e) {
    this._listeners && (this._isPaused !== 0 ? this._eventQueue.push(e) : super.fire(e));
  }
}
class oN {
  constructor() {
    this.buffers = [];
  }
  wrapEvent(e) {
    return (t, i, r) => e((o) => {
      const s = this.buffers[this.buffers.length - 1];
      s ? s.push(() => t.call(i, o)) : t.call(i, o);
    }, void 0, r);
  }
  bufferEvents(e) {
    const t = [];
    this.buffers.push(t);
    const i = e();
    return this.buffers.pop(), t.forEach((r) => r()), i;
  }
}
class mF {
  constructor() {
    this.listening = !1, this.inputEvent = Ae.None, this.inputEventListener = ge.None, this.emitter = new j({
      onFirstListenerDidAdd: () => {
        this.listening = !0, this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
      },
      onLastListenerRemove: () => {
        this.listening = !1, this.inputEventListener.dispose();
      }
    }), this.event = this.emitter.event;
  }
  set input(e) {
    this.inputEvent = e, this.listening && (this.inputEventListener.dispose(), this.inputEventListener = e(this.emitter.fire, this.emitter));
  }
  dispose() {
    this.inputEventListener.dispose(), this.emitter.dispose();
  }
}
const sG = Object.freeze(function(n, e) {
  const t = setTimeout(n.bind(e), 0);
  return { dispose() {
    clearTimeout(t);
  } };
});
var zo;
(function(n) {
  function e(t) {
    return t === n.None || t === n.Cancelled || t instanceof Xy ? !0 : !t || typeof t != "object" ? !1 : typeof t.isCancellationRequested == "boolean" && typeof t.onCancellationRequested == "function";
  }
  n.isCancellationToken = e, n.None = Object.freeze({
    isCancellationRequested: !1,
    onCancellationRequested: Ae.None
  }), n.Cancelled = Object.freeze({
    isCancellationRequested: !0,
    onCancellationRequested: sG
  });
})(zo || (zo = {}));
class Xy {
  constructor() {
    this._isCancelled = !1, this._emitter = null;
  }
  cancel() {
    this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    return this._isCancelled ? sG : (this._emitter || (this._emitter = new j()), this._emitter.event);
  }
  dispose() {
    this._emitter && (this._emitter.dispose(), this._emitter = null);
  }
}
let uh = class {
  constructor(e) {
    this._token = void 0, this._parentListener = void 0, this._parentListener = e && e.onCancellationRequested(this.cancel, this);
  }
  get token() {
    return this._token || (this._token = new Xy()), this._token;
  }
  cancel() {
    this._token ? this._token instanceof Xy && this._token.cancel() : this._token = zo.Cancelled;
  }
  dispose(e = !1) {
    e && this.cancel(), this._parentListener && this._parentListener.dispose(), this._token ? this._token instanceof Xy && this._token.dispose() : this._token = zo.None;
  }
};
class sN {
  constructor() {
    this._keyCodeToStr = [], this._strToKeyCode = /* @__PURE__ */ Object.create(null);
  }
  define(e, t) {
    this._keyCodeToStr[e] = t, this._strToKeyCode[t.toLowerCase()] = e;
  }
  keyCodeToStr(e) {
    return this._keyCodeToStr[e];
  }
  strToKeyCode(e) {
    return this._strToKeyCode[e.toLowerCase()] || 0;
  }
}
const Q1 = new sN(), J1 = new sN(), eR = new sN();
(function() {
  function n(e, t, i = t, r = i) {
    Q1.define(e, t), J1.define(e, i), eR.define(e, r);
  }
  n(0, "unknown"), n(1, "Backspace"), n(2, "Tab"), n(3, "Enter"), n(4, "Shift"), n(5, "Ctrl"), n(6, "Alt"), n(7, "PauseBreak"), n(8, "CapsLock"), n(9, "Escape"), n(10, "Space"), n(11, "PageUp"), n(12, "PageDown"), n(13, "End"), n(14, "Home"), n(15, "LeftArrow", "Left"), n(16, "UpArrow", "Up"), n(17, "RightArrow", "Right"), n(18, "DownArrow", "Down"), n(19, "Insert"), n(20, "Delete"), n(21, "0"), n(22, "1"), n(23, "2"), n(24, "3"), n(25, "4"), n(26, "5"), n(27, "6"), n(28, "7"), n(29, "8"), n(30, "9"), n(31, "A"), n(32, "B"), n(33, "C"), n(34, "D"), n(35, "E"), n(36, "F"), n(37, "G"), n(38, "H"), n(39, "I"), n(40, "J"), n(41, "K"), n(42, "L"), n(43, "M"), n(44, "N"), n(45, "O"), n(46, "P"), n(47, "Q"), n(48, "R"), n(49, "S"), n(50, "T"), n(51, "U"), n(52, "V"), n(53, "W"), n(54, "X"), n(55, "Y"), n(56, "Z"), n(57, "Meta"), n(58, "ContextMenu"), n(59, "F1"), n(60, "F2"), n(61, "F3"), n(62, "F4"), n(63, "F5"), n(64, "F6"), n(65, "F7"), n(66, "F8"), n(67, "F9"), n(68, "F10"), n(69, "F11"), n(70, "F12"), n(71, "F13"), n(72, "F14"), n(73, "F15"), n(74, "F16"), n(75, "F17"), n(76, "F18"), n(77, "F19"), n(78, "NumLock"), n(79, "ScrollLock"), n(80, ";", ";", "OEM_1"), n(81, "=", "=", "OEM_PLUS"), n(82, ",", ",", "OEM_COMMA"), n(83, "-", "-", "OEM_MINUS"), n(84, ".", ".", "OEM_PERIOD"), n(85, "/", "/", "OEM_2"), n(86, "`", "`", "OEM_3"), n(110, "ABNT_C1"), n(111, "ABNT_C2"), n(87, "[", "[", "OEM_4"), n(88, "\\", "\\", "OEM_5"), n(89, "]", "]", "OEM_6"), n(90, "'", "'", "OEM_7"), n(91, "OEM_8"), n(92, "OEM_102"), n(93, "NumPad0"), n(94, "NumPad1"), n(95, "NumPad2"), n(96, "NumPad3"), n(97, "NumPad4"), n(98, "NumPad5"), n(99, "NumPad6"), n(100, "NumPad7"), n(101, "NumPad8"), n(102, "NumPad9"), n(103, "NumPad_Multiply"), n(104, "NumPad_Add"), n(105, "NumPad_Separator"), n(106, "NumPad_Subtract"), n(107, "NumPad_Decimal"), n(108, "NumPad_Divide");
})();
var hp;
(function(n) {
  function e(s) {
    return Q1.keyCodeToStr(s);
  }
  n.toString = e;
  function t(s) {
    return Q1.strToKeyCode(s);
  }
  n.fromString = t;
  function i(s) {
    return J1.keyCodeToStr(s);
  }
  n.toUserSettingsUS = i;
  function r(s) {
    return eR.keyCodeToStr(s);
  }
  n.toUserSettingsGeneral = r;
  function o(s) {
    return J1.strToKeyCode(s) || eR.strToKeyCode(s);
  }
  n.fromUserSettings = o;
})(hp || (hp = {}));
function Xie(n, e) {
  const t = (e & 65535) << 16 >>> 0;
  return (n | t) >>> 0;
}
function tR(n, e) {
  if (n === 0)
    return null;
  const t = (n & 65535) >>> 0, i = (n & 4294901760) >>> 16;
  return i !== 0 ? new iR([
    GL(t, e),
    GL(i, e)
  ]) : new iR([GL(t, e)]);
}
function GL(n, e) {
  const t = !!(n & 2048), i = !!(n & 256), r = e === 2 ? i : t, o = !!(n & 1024), s = !!(n & 512), a = e === 2 ? t : i, l = n & 255;
  return new aN(r, o, s, a, l);
}
class aN {
  constructor(e, t, i, r, o) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = r, this.keyCode = o;
  }
  equals(e) {
    return this.ctrlKey === e.ctrlKey && this.shiftKey === e.shiftKey && this.altKey === e.altKey && this.metaKey === e.metaKey && this.keyCode === e.keyCode;
  }
  isModifierKey() {
    return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
  }
  toChord() {
    return new iR([this]);
  }
  /**
   * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
   */
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
  }
}
class iR {
  constructor(e) {
    if (e.length === 0)
      throw P_("parts");
    this.parts = e;
  }
}
class Zie {
  constructor(e, t, i, r, o, s) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = r, this.keyLabel = o, this.keyAriaLabel = s;
  }
}
class Qie {
}
let dp;
if (typeof gn.vscode < "u" && typeof gn.vscode.process < "u") {
  const n = gn.vscode.process;
  dp = {
    get platform() {
      return n.platform;
    },
    get env() {
      return n.env;
    },
    cwd() {
      return n.cwd();
    },
    nextTick(e) {
      return Jw(e);
    }
  };
} else
  typeof process < "u" ? dp = {
    get platform() {
      return process.platform;
    },
    get env() {
      return process.env;
    },
    cwd() {
      return process.env.VSCODE_CWD || process.cwd();
    },
    nextTick(n) {
      return process.nextTick(n);
    }
  } : dp = {
    // Supported
    get platform() {
      return Eo ? "win32" : Ft ? "darwin" : "linux";
    },
    nextTick(n) {
      return Jw(n);
    },
    // Unsupported
    get env() {
      return {};
    },
    cwd() {
      return "/";
    }
  };
const nR = dp.cwd, Jie = dp.env, qd = dp.platform, ene = 65, tne = 97, ine = 90, nne = 122, Kc = 46, Sr = 47, Ao = 92, wc = 58, rne = 63;
class aG extends Error {
  constructor(e, t, i) {
    let r;
    typeof t == "string" && t.indexOf("not ") === 0 ? (r = "must not be", t = t.replace(/^not /, "")) : r = "must be";
    const o = e.indexOf(".") !== -1 ? "property" : "argument";
    let s = `The "${e}" ${o} ${r} of type ${t}`;
    s += `. Received type ${typeof i}`, super(s), this.code = "ERR_INVALID_ARG_TYPE";
  }
}
function Dn(n, e) {
  if (typeof n != "string")
    throw new aG(e, "string", n);
}
function Rt(n) {
  return n === Sr || n === Ao;
}
function rR(n) {
  return n === Sr;
}
function bc(n) {
  return n >= ene && n <= ine || n >= tne && n <= nne;
}
function tb(n, e, t, i) {
  let r = "", o = 0, s = -1, a = 0, l = 0;
  for (let u = 0; u <= n.length; ++u) {
    if (u < n.length)
      l = n.charCodeAt(u);
    else {
      if (i(l))
        break;
      l = Sr;
    }
    if (i(l)) {
      if (!(s === u - 1 || a === 1))
        if (a === 2) {
          if (r.length < 2 || o !== 2 || r.charCodeAt(r.length - 1) !== Kc || r.charCodeAt(r.length - 2) !== Kc) {
            if (r.length > 2) {
              const c = r.lastIndexOf(t);
              c === -1 ? (r = "", o = 0) : (r = r.slice(0, c), o = r.length - 1 - r.lastIndexOf(t)), s = u, a = 0;
              continue;
            } else if (r.length !== 0) {
              r = "", o = 0, s = u, a = 0;
              continue;
            }
          }
          e && (r += r.length > 0 ? `${t}..` : "..", o = 2);
        } else
          r.length > 0 ? r += `${t}${n.slice(s + 1, u)}` : r = n.slice(s + 1, u), o = u - s - 1;
      s = u, a = 0;
    } else
      l === Kc && a !== -1 ? ++a : a = -1;
  }
  return r;
}
function lG(n, e) {
  if (e === null || typeof e != "object")
    throw new aG("pathObject", "Object", e);
  const t = e.dir || e.root, i = e.base || `${e.name || ""}${e.ext || ""}`;
  return t ? t === e.root ? `${t}${i}` : `${t}${n}${i}` : i;
}
const bo = {
  // path.resolve([from ...], to)
  resolve(...n) {
    let e = "", t = "", i = !1;
    for (let r = n.length - 1; r >= -1; r--) {
      let o;
      if (r >= 0) {
        if (o = n[r], Dn(o, "path"), o.length === 0)
          continue;
      } else
        e.length === 0 ? o = nR() : (o = Jie[`=${e}`] || nR(), (o === void 0 || o.slice(0, 2).toLowerCase() !== e.toLowerCase() && o.charCodeAt(2) === Ao) && (o = `${e}\\`));
      const s = o.length;
      let a = 0, l = "", u = !1;
      const c = o.charCodeAt(0);
      if (s === 1)
        Rt(c) && (a = 1, u = !0);
      else if (Rt(c))
        if (u = !0, Rt(o.charCodeAt(1))) {
          let h = 2, d = h;
          for (; h < s && !Rt(o.charCodeAt(h)); )
            h++;
          if (h < s && h !== d) {
            const f = o.slice(d, h);
            for (d = h; h < s && Rt(o.charCodeAt(h)); )
              h++;
            if (h < s && h !== d) {
              for (d = h; h < s && !Rt(o.charCodeAt(h)); )
                h++;
              (h === s || h !== d) && (l = `\\\\${f}\\${o.slice(d, h)}`, a = h);
            }
          }
        } else
          a = 1;
      else
        bc(c) && o.charCodeAt(1) === wc && (l = o.slice(0, 2), a = 2, s > 2 && Rt(o.charCodeAt(2)) && (u = !0, a = 3));
      if (l.length > 0)
        if (e.length > 0) {
          if (l.toLowerCase() !== e.toLowerCase())
            continue;
        } else
          e = l;
      if (i) {
        if (e.length > 0)
          break;
      } else if (t = `${o.slice(a)}\\${t}`, i = u, u && e.length > 0)
        break;
    }
    return t = tb(t, !i, "\\", Rt), i ? `${e}\\${t}` : `${e}${t}` || ".";
  },
  normalize(n) {
    Dn(n, "path");
    const e = n.length;
    if (e === 0)
      return ".";
    let t = 0, i, r = !1;
    const o = n.charCodeAt(0);
    if (e === 1)
      return rR(o) ? "\\" : n;
    if (Rt(o))
      if (r = !0, Rt(n.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !Rt(n.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          const u = n.slice(l, a);
          for (l = a; a < e && Rt(n.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !Rt(n.charCodeAt(a)); )
              a++;
            if (a === e)
              return `\\\\${u}\\${n.slice(l)}\\`;
            a !== l && (i = `\\\\${u}\\${n.slice(l, a)}`, t = a);
          }
        }
      } else
        t = 1;
    else
      bc(o) && n.charCodeAt(1) === wc && (i = n.slice(0, 2), t = 2, e > 2 && Rt(n.charCodeAt(2)) && (r = !0, t = 3));
    let s = t < e ? tb(n.slice(t), !r, "\\", Rt) : "";
    return s.length === 0 && !r && (s = "."), s.length > 0 && Rt(n.charCodeAt(e - 1)) && (s += "\\"), i === void 0 ? r ? `\\${s}` : s : r ? `${i}\\${s}` : `${i}${s}`;
  },
  isAbsolute(n) {
    Dn(n, "path");
    const e = n.length;
    if (e === 0)
      return !1;
    const t = n.charCodeAt(0);
    return Rt(t) || // Possible device root
    e > 2 && bc(t) && n.charCodeAt(1) === wc && Rt(n.charCodeAt(2));
  },
  join(...n) {
    if (n.length === 0)
      return ".";
    let e, t;
    for (let o = 0; o < n.length; ++o) {
      const s = n[o];
      Dn(s, "path"), s.length > 0 && (e === void 0 ? e = t = s : e += `\\${s}`);
    }
    if (e === void 0)
      return ".";
    let i = !0, r = 0;
    if (typeof t == "string" && Rt(t.charCodeAt(0))) {
      ++r;
      const o = t.length;
      o > 1 && Rt(t.charCodeAt(1)) && (++r, o > 2 && (Rt(t.charCodeAt(2)) ? ++r : i = !1));
    }
    if (i) {
      for (; r < e.length && Rt(e.charCodeAt(r)); )
        r++;
      r >= 2 && (e = `\\${e.slice(r)}`);
    }
    return bo.normalize(e);
  },
  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(n, e) {
    if (Dn(n, "from"), Dn(e, "to"), n === e)
      return "";
    const t = bo.resolve(n), i = bo.resolve(e);
    if (t === i || (n = t.toLowerCase(), e = i.toLowerCase(), n === e))
      return "";
    let r = 0;
    for (; r < n.length && n.charCodeAt(r) === Ao; )
      r++;
    let o = n.length;
    for (; o - 1 > r && n.charCodeAt(o - 1) === Ao; )
      o--;
    const s = o - r;
    let a = 0;
    for (; a < e.length && e.charCodeAt(a) === Ao; )
      a++;
    let l = e.length;
    for (; l - 1 > a && e.charCodeAt(l - 1) === Ao; )
      l--;
    const u = l - a, c = s < u ? s : u;
    let h = -1, d = 0;
    for (; d < c; d++) {
      const p = n.charCodeAt(r + d);
      if (p !== e.charCodeAt(a + d))
        break;
      p === Ao && (h = d);
    }
    if (d !== c) {
      if (h === -1)
        return i;
    } else {
      if (u > c) {
        if (e.charCodeAt(a + d) === Ao)
          return i.slice(a + d + 1);
        if (d === 2)
          return i.slice(a + d);
      }
      s > c && (n.charCodeAt(r + d) === Ao ? h = d : d === 2 && (h = 3)), h === -1 && (h = 0);
    }
    let f = "";
    for (d = r + h + 1; d <= o; ++d)
      (d === o || n.charCodeAt(d) === Ao) && (f += f.length === 0 ? ".." : "\\..");
    return a += h, f.length > 0 ? `${f}${i.slice(a, l)}` : (i.charCodeAt(a) === Ao && ++a, i.slice(a, l));
  },
  toNamespacedPath(n) {
    if (typeof n != "string")
      return n;
    if (n.length === 0)
      return "";
    const e = bo.resolve(n);
    if (e.length <= 2)
      return n;
    if (e.charCodeAt(0) === Ao) {
      if (e.charCodeAt(1) === Ao) {
        const t = e.charCodeAt(2);
        if (t !== rne && t !== Kc)
          return `\\\\?\\UNC\\${e.slice(2)}`;
      }
    } else if (bc(e.charCodeAt(0)) && e.charCodeAt(1) === wc && e.charCodeAt(2) === Ao)
      return `\\\\?\\${e}`;
    return n;
  },
  dirname(n) {
    Dn(n, "path");
    const e = n.length;
    if (e === 0)
      return ".";
    let t = -1, i = 0;
    const r = n.charCodeAt(0);
    if (e === 1)
      return Rt(r) ? n : ".";
    if (Rt(r)) {
      if (t = i = 1, Rt(n.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !Rt(n.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          for (l = a; a < e && Rt(n.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !Rt(n.charCodeAt(a)); )
              a++;
            if (a === e)
              return n;
            a !== l && (t = i = a + 1);
          }
        }
      }
    } else
      bc(r) && n.charCodeAt(1) === wc && (t = e > 2 && Rt(n.charCodeAt(2)) ? 3 : 2, i = t);
    let o = -1, s = !0;
    for (let a = e - 1; a >= i; --a)
      if (Rt(n.charCodeAt(a))) {
        if (!s) {
          o = a;
          break;
        }
      } else
        s = !1;
    if (o === -1) {
      if (t === -1)
        return ".";
      o = t;
    }
    return n.slice(0, o);
  },
  basename(n, e) {
    e !== void 0 && Dn(e, "ext"), Dn(n, "path");
    let t = 0, i = -1, r = !0, o;
    if (n.length >= 2 && bc(n.charCodeAt(0)) && n.charCodeAt(1) === wc && (t = 2), e !== void 0 && e.length > 0 && e.length <= n.length) {
      if (e === n)
        return "";
      let s = e.length - 1, a = -1;
      for (o = n.length - 1; o >= t; --o) {
        const l = n.charCodeAt(o);
        if (Rt(l)) {
          if (!r) {
            t = o + 1;
            break;
          }
        } else
          a === -1 && (r = !1, a = o + 1), s >= 0 && (l === e.charCodeAt(s) ? --s === -1 && (i = o) : (s = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = n.length), n.slice(t, i);
    }
    for (o = n.length - 1; o >= t; --o)
      if (Rt(n.charCodeAt(o))) {
        if (!r) {
          t = o + 1;
          break;
        }
      } else
        i === -1 && (r = !1, i = o + 1);
    return i === -1 ? "" : n.slice(t, i);
  },
  extname(n) {
    Dn(n, "path");
    let e = 0, t = -1, i = 0, r = -1, o = !0, s = 0;
    n.length >= 2 && n.charCodeAt(1) === wc && bc(n.charCodeAt(0)) && (e = i = 2);
    for (let a = n.length - 1; a >= e; --a) {
      const l = n.charCodeAt(a);
      if (Rt(l)) {
        if (!o) {
          i = a + 1;
          break;
        }
        continue;
      }
      r === -1 && (o = !1, r = a + 1), l === Kc ? t === -1 ? t = a : s !== 1 && (s = 1) : t !== -1 && (s = -1);
    }
    return t === -1 || r === -1 || // We saw a non-dot character immediately before the dot
    s === 0 || // The (right-most) trimmed path component is exactly '..'
    s === 1 && t === r - 1 && t === i + 1 ? "" : n.slice(t, r);
  },
  format: lG.bind(null, "\\"),
  parse(n) {
    Dn(n, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (n.length === 0)
      return e;
    const t = n.length;
    let i = 0, r = n.charCodeAt(0);
    if (t === 1)
      return Rt(r) ? (e.root = e.dir = n, e) : (e.base = e.name = n, e);
    if (Rt(r)) {
      if (i = 1, Rt(n.charCodeAt(1))) {
        let h = 2, d = h;
        for (; h < t && !Rt(n.charCodeAt(h)); )
          h++;
        if (h < t && h !== d) {
          for (d = h; h < t && Rt(n.charCodeAt(h)); )
            h++;
          if (h < t && h !== d) {
            for (d = h; h < t && !Rt(n.charCodeAt(h)); )
              h++;
            h === t ? i = h : h !== d && (i = h + 1);
          }
        }
      }
    } else if (bc(r) && n.charCodeAt(1) === wc) {
      if (t <= 2)
        return e.root = e.dir = n, e;
      if (i = 2, Rt(n.charCodeAt(2))) {
        if (t === 3)
          return e.root = e.dir = n, e;
        i = 3;
      }
    }
    i > 0 && (e.root = n.slice(0, i));
    let o = -1, s = i, a = -1, l = !0, u = n.length - 1, c = 0;
    for (; u >= i; --u) {
      if (r = n.charCodeAt(u), Rt(r)) {
        if (!l) {
          s = u + 1;
          break;
        }
        continue;
      }
      a === -1 && (l = !1, a = u + 1), r === Kc ? o === -1 ? o = u : c !== 1 && (c = 1) : o !== -1 && (c = -1);
    }
    return a !== -1 && (o === -1 || // We saw a non-dot character immediately before the dot
    c === 0 || // The (right-most) trimmed path component is exactly '..'
    c === 1 && o === a - 1 && o === s + 1 ? e.base = e.name = n.slice(s, a) : (e.name = n.slice(s, o), e.base = n.slice(s, a), e.ext = n.slice(o, a))), s > 0 && s !== i ? e.dir = n.slice(0, s - 1) : e.dir = e.root, e;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
}, mn = {
  // path.resolve([from ...], to)
  resolve(...n) {
    let e = "", t = !1;
    for (let i = n.length - 1; i >= -1 && !t; i--) {
      const r = i >= 0 ? n[i] : nR();
      Dn(r, "path"), r.length !== 0 && (e = `${r}/${e}`, t = r.charCodeAt(0) === Sr);
    }
    return e = tb(e, !t, "/", rR), t ? `/${e}` : e.length > 0 ? e : ".";
  },
  normalize(n) {
    if (Dn(n, "path"), n.length === 0)
      return ".";
    const e = n.charCodeAt(0) === Sr, t = n.charCodeAt(n.length - 1) === Sr;
    return n = tb(n, !e, "/", rR), n.length === 0 ? e ? "/" : t ? "./" : "." : (t && (n += "/"), e ? `/${n}` : n);
  },
  isAbsolute(n) {
    return Dn(n, "path"), n.length > 0 && n.charCodeAt(0) === Sr;
  },
  join(...n) {
    if (n.length === 0)
      return ".";
    let e;
    for (let t = 0; t < n.length; ++t) {
      const i = n[t];
      Dn(i, "path"), i.length > 0 && (e === void 0 ? e = i : e += `/${i}`);
    }
    return e === void 0 ? "." : mn.normalize(e);
  },
  relative(n, e) {
    if (Dn(n, "from"), Dn(e, "to"), n === e || (n = mn.resolve(n), e = mn.resolve(e), n === e))
      return "";
    const t = 1, i = n.length, r = i - t, o = 1, s = e.length - o, a = r < s ? r : s;
    let l = -1, u = 0;
    for (; u < a; u++) {
      const h = n.charCodeAt(t + u);
      if (h !== e.charCodeAt(o + u))
        break;
      h === Sr && (l = u);
    }
    if (u === a)
      if (s > a) {
        if (e.charCodeAt(o + u) === Sr)
          return e.slice(o + u + 1);
        if (u === 0)
          return e.slice(o + u);
      } else
        r > a && (n.charCodeAt(t + u) === Sr ? l = u : u === 0 && (l = 0));
    let c = "";
    for (u = t + l + 1; u <= i; ++u)
      (u === i || n.charCodeAt(u) === Sr) && (c += c.length === 0 ? ".." : "/..");
    return `${c}${e.slice(o + l)}`;
  },
  toNamespacedPath(n) {
    return n;
  },
  dirname(n) {
    if (Dn(n, "path"), n.length === 0)
      return ".";
    const e = n.charCodeAt(0) === Sr;
    let t = -1, i = !0;
    for (let r = n.length - 1; r >= 1; --r)
      if (n.charCodeAt(r) === Sr) {
        if (!i) {
          t = r;
          break;
        }
      } else
        i = !1;
    return t === -1 ? e ? "/" : "." : e && t === 1 ? "//" : n.slice(0, t);
  },
  basename(n, e) {
    e !== void 0 && Dn(e, "ext"), Dn(n, "path");
    let t = 0, i = -1, r = !0, o;
    if (e !== void 0 && e.length > 0 && e.length <= n.length) {
      if (e === n)
        return "";
      let s = e.length - 1, a = -1;
      for (o = n.length - 1; o >= 0; --o) {
        const l = n.charCodeAt(o);
        if (l === Sr) {
          if (!r) {
            t = o + 1;
            break;
          }
        } else
          a === -1 && (r = !1, a = o + 1), s >= 0 && (l === e.charCodeAt(s) ? --s === -1 && (i = o) : (s = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = n.length), n.slice(t, i);
    }
    for (o = n.length - 1; o >= 0; --o)
      if (n.charCodeAt(o) === Sr) {
        if (!r) {
          t = o + 1;
          break;
        }
      } else
        i === -1 && (r = !1, i = o + 1);
    return i === -1 ? "" : n.slice(t, i);
  },
  extname(n) {
    Dn(n, "path");
    let e = -1, t = 0, i = -1, r = !0, o = 0;
    for (let s = n.length - 1; s >= 0; --s) {
      const a = n.charCodeAt(s);
      if (a === Sr) {
        if (!r) {
          t = s + 1;
          break;
        }
        continue;
      }
      i === -1 && (r = !1, i = s + 1), a === Kc ? e === -1 ? e = s : o !== 1 && (o = 1) : e !== -1 && (o = -1);
    }
    return e === -1 || i === -1 || // We saw a non-dot character immediately before the dot
    o === 0 || // The (right-most) trimmed path component is exactly '..'
    o === 1 && e === i - 1 && e === t + 1 ? "" : n.slice(e, i);
  },
  format: lG.bind(null, "/"),
  parse(n) {
    Dn(n, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (n.length === 0)
      return e;
    const t = n.charCodeAt(0) === Sr;
    let i;
    t ? (e.root = "/", i = 1) : i = 0;
    let r = -1, o = 0, s = -1, a = !0, l = n.length - 1, u = 0;
    for (; l >= i; --l) {
      const c = n.charCodeAt(l);
      if (c === Sr) {
        if (!a) {
          o = l + 1;
          break;
        }
        continue;
      }
      s === -1 && (a = !1, s = l + 1), c === Kc ? r === -1 ? r = l : u !== 1 && (u = 1) : r !== -1 && (u = -1);
    }
    if (s !== -1) {
      const c = o === 0 && t ? 1 : o;
      r === -1 || // We saw a non-dot character immediately before the dot
      u === 0 || // The (right-most) trimmed path component is exactly '..'
      u === 1 && r === s - 1 && r === o + 1 ? e.base = e.name = n.slice(c, s) : (e.name = n.slice(c, r), e.base = n.slice(c, s), e.ext = n.slice(r, s));
    }
    return o > 0 ? e.dir = n.slice(0, o - 1) : t && (e.dir = "/"), e;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
mn.win32 = bo.win32 = bo;
mn.posix = bo.posix = mn;
const lN = qd === "win32" ? bo.normalize : mn.normalize, one = qd === "win32" ? bo.resolve : mn.resolve, sne = qd === "win32" ? bo.relative : mn.relative, ane = qd === "win32" ? bo.dirname : mn.dirname, uG = qd === "win32" ? bo.basename : mn.basename, lne = qd === "win32" ? bo.extname : mn.extname, Zy = qd === "win32" ? bo.sep : mn.sep, une = /^\w[\w\d+.-]*$/, cne = /^\//, hne = /^\/\//;
function vF(n, e) {
  if (!n.scheme && e)
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${n.authority}", path: "${n.path}", query: "${n.query}", fragment: "${n.fragment}"}`);
  if (n.scheme && !une.test(n.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.");
  if (n.path) {
    if (n.authority) {
      if (!cne.test(n.path))
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
    } else if (hne.test(n.path))
      throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
  }
}
function dne(n, e) {
  return !n && !e ? "file" : n;
}
function fne(n, e) {
  switch (n) {
    case "https":
    case "http":
    case "file":
      e ? e[0] !== Va && (e = Va + e) : e = Va;
      break;
  }
  return e;
}
const Mi = "", Va = "/", pne = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
class dt {
  /**
   * @internal
   */
  constructor(e, t, i, r, o, s = !1) {
    typeof e == "object" ? (this.scheme = e.scheme || Mi, this.authority = e.authority || Mi, this.path = e.path || Mi, this.query = e.query || Mi, this.fragment = e.fragment || Mi) : (this.scheme = dne(e, s), this.authority = t || Mi, this.path = fne(this.scheme, i || Mi), this.query = r || Mi, this.fragment = o || Mi, vF(this, s));
  }
  static isUri(e) {
    return e instanceof dt ? !0 : e ? typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function" : !1;
  }
  // ---- filesystem path -----------------------
  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
      const u = URI.parse('file://server/c$/folder/file.txt')
      u.authority === 'server'
      u.path === '/shares/c$/file.txt'
      u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */
  get fsPath() {
    return ib(this, !1);
  }
  // ---- modify to new -------------------------
  with(e) {
    if (!e)
      return this;
    let { scheme: t, authority: i, path: r, query: o, fragment: s } = e;
    return t === void 0 ? t = this.scheme : t === null && (t = Mi), i === void 0 ? i = this.authority : i === null && (i = Mi), r === void 0 ? r = this.path : r === null && (r = Mi), o === void 0 ? o = this.query : o === null && (o = Mi), s === void 0 ? s = this.fragment : s === null && (s = Mi), t === this.scheme && i === this.authority && r === this.path && o === this.query && s === this.fragment ? this : new wf(t, i, r, o, s);
  }
  // ---- parse & validate ------------------------
  /**
   * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */
  static parse(e, t = !1) {
    const i = pne.exec(e);
    return i ? new wf(i[2] || Mi, sy(i[4] || Mi), sy(i[5] || Mi), sy(i[7] || Mi), sy(i[9] || Mi), t) : new wf(Mi, Mi, Mi, Mi, Mi);
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */
  static file(e) {
    let t = Mi;
    if (Eo && (e = e.replace(/\\/g, Va)), e[0] === Va && e[1] === Va) {
      const i = e.indexOf(Va, 2);
      i === -1 ? (t = e.substring(2), e = Va) : (t = e.substring(2, i), e = e.substring(i) || Va);
    }
    return new wf("file", t, e, Mi, Mi);
  }
  static from(e) {
    const t = new wf(e.scheme, e.authority, e.path, e.query, e.fragment);
    return vF(t, !0), t;
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */
  static joinPath(e, ...t) {
    if (!e.path)
      throw new Error("[UriError]: cannot call joinPath on URI without path");
    let i;
    return Eo && e.scheme === "file" ? i = dt.file(bo.join(ib(e, !0), ...t)).path : i = mn.join(e.path, ...t), e.with({ path: i });
  }
  // ---- printing/externalize ---------------------------
  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */
  toString(e = !1) {
    return oR(this, e);
  }
  toJSON() {
    return this;
  }
  static revive(e) {
    if (e) {
      if (e instanceof dt)
        return e;
      {
        const t = new wf(e);
        return t._formatted = e.external, t._fsPath = e._sep === cG ? e.fsPath : null, t;
      }
    } else
      return e;
  }
}
const cG = Eo ? 1 : void 0;
let wf = class extends dt {
  constructor() {
    super(...arguments), this._formatted = null, this._fsPath = null;
  }
  get fsPath() {
    return this._fsPath || (this._fsPath = ib(this, !1)), this._fsPath;
  }
  toString(e = !1) {
    return e ? oR(this, !0) : (this._formatted || (this._formatted = oR(this, !1)), this._formatted);
  }
  toJSON() {
    const e = {
      $mid: 1
    };
    return this._fsPath && (e.fsPath = this._fsPath, e._sep = cG), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
  }
};
const hG = {
  [
    58
    /* Colon */
  ]: "%3A",
  [
    47
    /* Slash */
  ]: "%2F",
  [
    63
    /* QuestionMark */
  ]: "%3F",
  [
    35
    /* Hash */
  ]: "%23",
  [
    91
    /* OpenSquareBracket */
  ]: "%5B",
  [
    93
    /* CloseSquareBracket */
  ]: "%5D",
  [
    64
    /* AtSign */
  ]: "%40",
  [
    33
    /* ExclamationMark */
  ]: "%21",
  [
    36
    /* DollarSign */
  ]: "%24",
  [
    38
    /* Ampersand */
  ]: "%26",
  [
    39
    /* SingleQuote */
  ]: "%27",
  [
    40
    /* OpenParen */
  ]: "%28",
  [
    41
    /* CloseParen */
  ]: "%29",
  [
    42
    /* Asterisk */
  ]: "%2A",
  [
    43
    /* Plus */
  ]: "%2B",
  [
    44
    /* Comma */
  ]: "%2C",
  [
    59
    /* Semicolon */
  ]: "%3B",
  [
    61
    /* Equals */
  ]: "%3D",
  [
    32
    /* Space */
  ]: "%20"
};
function _F(n, e) {
  let t, i = -1;
  for (let r = 0; r < n.length; r++) {
    const o = n.charCodeAt(r);
    if (o >= 97 && o <= 122 || o >= 65 && o <= 90 || o >= 48 && o <= 57 || o === 45 || o === 46 || o === 95 || o === 126 || e && o === 47)
      i !== -1 && (t += encodeURIComponent(n.substring(i, r)), i = -1), t !== void 0 && (t += n.charAt(r));
    else {
      t === void 0 && (t = n.substr(0, r));
      const s = hG[o];
      s !== void 0 ? (i !== -1 && (t += encodeURIComponent(n.substring(i, r)), i = -1), t += s) : i === -1 && (i = r);
    }
  }
  return i !== -1 && (t += encodeURIComponent(n.substring(i))), t !== void 0 ? t : n;
}
function gne(n) {
  let e;
  for (let t = 0; t < n.length; t++) {
    const i = n.charCodeAt(t);
    i === 35 || i === 63 ? (e === void 0 && (e = n.substr(0, t)), e += hG[i]) : e !== void 0 && (e += n[t]);
  }
  return e !== void 0 ? e : n;
}
function ib(n, e) {
  let t;
  return n.authority && n.path.length > 1 && n.scheme === "file" ? t = `//${n.authority}${n.path}` : n.path.charCodeAt(0) === 47 && (n.path.charCodeAt(1) >= 65 && n.path.charCodeAt(1) <= 90 || n.path.charCodeAt(1) >= 97 && n.path.charCodeAt(1) <= 122) && n.path.charCodeAt(2) === 58 ? e ? t = n.path.substr(1) : t = n.path[1].toLowerCase() + n.path.substr(2) : t = n.path, Eo && (t = t.replace(/\//g, "\\")), t;
}
function oR(n, e) {
  const t = e ? gne : _F;
  let i = "", { scheme: r, authority: o, path: s, query: a, fragment: l } = n;
  if (r && (i += r, i += ":"), (o || r === "file") && (i += Va, i += Va), o) {
    let u = o.indexOf("@");
    if (u !== -1) {
      const c = o.substr(0, u);
      o = o.substr(u + 1), u = c.indexOf(":"), u === -1 ? i += t(c, !1) : (i += t(c.substr(0, u), !1), i += ":", i += t(c.substr(u + 1), !1)), i += "@";
    }
    o = o.toLowerCase(), u = o.indexOf(":"), u === -1 ? i += t(o, !1) : (i += t(o.substr(0, u), !1), i += o.substr(u));
  }
  if (s) {
    if (s.length >= 3 && s.charCodeAt(0) === 47 && s.charCodeAt(2) === 58) {
      const u = s.charCodeAt(1);
      u >= 65 && u <= 90 && (s = `/${String.fromCharCode(u + 32)}:${s.substr(3)}`);
    } else if (s.length >= 2 && s.charCodeAt(1) === 58) {
      const u = s.charCodeAt(0);
      u >= 65 && u <= 90 && (s = `${String.fromCharCode(u + 32)}:${s.substr(2)}`);
    }
    i += t(s, !0);
  }
  return a && (i += "?", i += t(a, !1)), l && (i += "#", i += e ? l : _F(l, !1)), i;
}
function dG(n) {
  try {
    return decodeURIComponent(n);
  } catch {
    return n.length > 3 ? n.substr(0, 3) + dG(n.substr(3)) : n;
  }
}
const CF = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function sy(n) {
  return n.match(CF) ? n.replace(CF, (e) => dG(e)) : n;
}
let J = class Bh {
  constructor(e, t) {
    this.lineNumber = e, this.column = t;
  }
  /**
   * Create a new position from this position.
   *
   * @param newLineNumber new line number
   * @param newColumn new column
   */
  with(e = this.lineNumber, t = this.column) {
    return e === this.lineNumber && t === this.column ? this : new Bh(e, t);
  }
  /**
   * Derive a new position from this position.
   *
   * @param deltaLineNumber line number delta
   * @param deltaColumn column delta
   */
  delta(e = 0, t = 0) {
    return this.with(this.lineNumber + e, this.column + t);
  }
  /**
   * Test if this position equals other position
   */
  equals(e) {
    return Bh.equals(this, e);
  }
  /**
   * Test if position `a` equals position `b`
   */
  static equals(e, t) {
    return !e && !t ? !0 : !!e && !!t && e.lineNumber === t.lineNumber && e.column === t.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be false.
   */
  isBefore(e) {
    return Bh.isBefore(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be false.
   */
  static isBefore(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column < t.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be true.
   */
  isBeforeOrEqual(e) {
    return Bh.isBeforeOrEqual(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be true.
   */
  static isBeforeOrEqual(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column <= t.column;
  }
  /**
   * A function that compares positions, useful for sorting
   */
  static compare(e, t) {
    let i = e.lineNumber | 0, r = t.lineNumber | 0;
    if (i === r) {
      let o = e.column | 0, s = t.column | 0;
      return o - s;
    }
    return i - r;
  }
  /**
   * Clone this position.
   */
  clone() {
    return new Bh(this.lineNumber, this.column);
  }
  /**
   * Convert to a human-readable representation.
   */
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  // ---
  /**
   * Create a `Position` from an `IPosition`.
   */
  static lift(e) {
    return new Bh(e.lineNumber, e.column);
  }
  /**
   * Test if `obj` is an `IPosition`.
   */
  static isIPosition(e) {
    return e && typeof e.lineNumber == "number" && typeof e.column == "number";
  }
}, V = class br {
  constructor(e, t, i, r) {
    e > i || e === i && t > r ? (this.startLineNumber = i, this.startColumn = r, this.endLineNumber = e, this.endColumn = t) : (this.startLineNumber = e, this.startColumn = t, this.endLineNumber = i, this.endColumn = r);
  }
  /**
   * Test if this range is empty.
   */
  isEmpty() {
    return br.isEmpty(this);
  }
  /**
   * Test if `range` is empty.
   */
  static isEmpty(e) {
    return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn;
  }
  /**
   * Test if position is in this range. If the position is at the edges, will return true.
   */
  containsPosition(e) {
    return br.containsPosition(this, e);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return true.
   */
  static containsPosition(e, t) {
    return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column < e.startColumn || t.lineNumber === e.endLineNumber && t.column > e.endColumn);
  }
  /**
   * Test if range is in this range. If the range is equal to this range, will return true.
   */
  containsRange(e) {
    return br.containsRange(this, e);
  }
  /**
   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
   */
  static containsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn < e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn > e.endColumn);
  }
  /**
   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
   */
  strictContainsRange(e) {
    return br.strictContainsRange(this, e);
  }
  /**
   * Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.
   */
  static strictContainsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn <= e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn >= e.endColumn);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  plusRange(e) {
    return br.plusRange(this, e);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  static plusRange(e, t) {
    let i, r, o, s;
    return t.startLineNumber < e.startLineNumber ? (i = t.startLineNumber, r = t.startColumn) : t.startLineNumber === e.startLineNumber ? (i = t.startLineNumber, r = Math.min(t.startColumn, e.startColumn)) : (i = e.startLineNumber, r = e.startColumn), t.endLineNumber > e.endLineNumber ? (o = t.endLineNumber, s = t.endColumn) : t.endLineNumber === e.endLineNumber ? (o = t.endLineNumber, s = Math.max(t.endColumn, e.endColumn)) : (o = e.endLineNumber, s = e.endColumn), new br(i, r, o, s);
  }
  /**
   * A intersection of the two ranges.
   */
  intersectRanges(e) {
    return br.intersectRanges(this, e);
  }
  /**
   * A intersection of the two ranges.
   */
  static intersectRanges(e, t) {
    let i = e.startLineNumber, r = e.startColumn, o = e.endLineNumber, s = e.endColumn, a = t.startLineNumber, l = t.startColumn, u = t.endLineNumber, c = t.endColumn;
    return i < a ? (i = a, r = l) : i === a && (r = Math.max(r, l)), o > u ? (o = u, s = c) : o === u && (s = Math.min(s, c)), i > o || i === o && r > s ? null : new br(i, r, o, s);
  }
  /**
   * Test if this range equals other.
   */
  equalsRange(e) {
    return br.equalsRange(this, e);
  }
  /**
   * Test if range `a` equals `b`.
   */
  static equalsRange(e, t) {
    return !!e && !!t && e.startLineNumber === t.startLineNumber && e.startColumn === t.startColumn && e.endLineNumber === t.endLineNumber && e.endColumn === t.endColumn;
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  getEndPosition() {
    return br.getEndPosition(this);
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  static getEndPosition(e) {
    return new J(e.endLineNumber, e.endColumn);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  getStartPosition() {
    return br.getStartPosition(this);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  static getStartPosition(e) {
    return new J(e.startLineNumber, e.startColumn);
  }
  /**
   * Transform to a user presentable string representation.
   */
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  /**
   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
   */
  setEndPosition(e, t) {
    return new br(this.startLineNumber, this.startColumn, e, t);
  }
  /**
   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
   */
  setStartPosition(e, t) {
    return new br(e, t, this.endLineNumber, this.endColumn);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  collapseToStart() {
    return br.collapseToStart(this);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  static collapseToStart(e) {
    return new br(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn);
  }
  // ---
  static fromPositions(e, t = e) {
    return new br(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  static lift(e) {
    return e ? new br(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null;
  }
  /**
   * Test if `obj` is an `IRange`.
   */
  static isIRange(e) {
    return e && typeof e.startLineNumber == "number" && typeof e.startColumn == "number" && typeof e.endLineNumber == "number" && typeof e.endColumn == "number";
  }
  /**
   * Test if the two ranges are touching in any way.
   */
  static areIntersectingOrTouching(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn);
  }
  /**
   * Test if the two ranges are intersecting. If the ranges are touching it returns true.
   */
  static areIntersecting(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn <= e.startColumn);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the startPosition and then on the endPosition
   */
  static compareRangesUsingStarts(e, t) {
    if (e && t) {
      const o = e.startLineNumber | 0, s = t.startLineNumber | 0;
      if (o === s) {
        const a = e.startColumn | 0, l = t.startColumn | 0;
        if (a === l) {
          const u = e.endLineNumber | 0, c = t.endLineNumber | 0;
          if (u === c) {
            const h = e.endColumn | 0, d = t.endColumn | 0;
            return h - d;
          }
          return u - c;
        }
        return a - l;
      }
      return o - s;
    }
    return (e ? 1 : 0) - (t ? 1 : 0);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the endPosition and then on the startPosition
   */
  static compareRangesUsingEnds(e, t) {
    return e.endLineNumber === t.endLineNumber ? e.endColumn === t.endColumn ? e.startLineNumber === t.startLineNumber ? e.startColumn - t.startColumn : e.startLineNumber - t.startLineNumber : e.endColumn - t.endColumn : e.endLineNumber - t.endLineNumber;
  }
  /**
   * Test if the range spans multiple lines.
   */
  static spansMultipleLines(e) {
    return e.endLineNumber > e.startLineNumber;
  }
}, Ut = class El extends V {
  constructor(e, t, i, r) {
    super(e, t, i, r), this.selectionStartLineNumber = e, this.selectionStartColumn = t, this.positionLineNumber = i, this.positionColumn = r;
  }
  /**
   * Transform to a human-readable representation.
   */
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  /**
   * Test if equals other selection.
   */
  equalsSelection(e) {
    return El.selectionsEqual(this, e);
  }
  /**
   * Test if the two selections are equal.
   */
  static selectionsEqual(e, t) {
    return e.selectionStartLineNumber === t.selectionStartLineNumber && e.selectionStartColumn === t.selectionStartColumn && e.positionLineNumber === t.positionLineNumber && e.positionColumn === t.positionColumn;
  }
  /**
   * Get directions (LTR or RTL).
   */
  getDirection() {
    return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? 0 : 1;
  }
  /**
   * Create a new selection with a different `positionLineNumber` and `positionColumn`.
   */
  setEndPosition(e, t) {
    return this.getDirection() === 0 ? new El(this.startLineNumber, this.startColumn, e, t) : new El(e, t, this.startLineNumber, this.startColumn);
  }
  /**
   * Get the position at `positionLineNumber` and `positionColumn`.
   */
  getPosition() {
    return new J(this.positionLineNumber, this.positionColumn);
  }
  /**
   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
   */
  setStartPosition(e, t) {
    return this.getDirection() === 0 ? new El(e, t, this.endLineNumber, this.endColumn) : new El(this.endLineNumber, this.endColumn, e, t);
  }
  // ----
  /**
   * Create a `Selection` from one or two positions
   */
  static fromPositions(e, t = e) {
    return new El(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  /**
   * Create a `Selection` from an `ISelection`.
   */
  static liftSelection(e) {
    return new El(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
  }
  /**
   * `a` equals `b`.
   */
  static selectionsArrEqual(e, t) {
    if (e && !t || !e && t)
      return !1;
    if (!e && !t)
      return !0;
    if (e.length !== t.length)
      return !1;
    for (let i = 0, r = e.length; i < r; i++)
      if (!this.selectionsEqual(e[i], t[i]))
        return !1;
    return !0;
  }
  /**
   * Test if `obj` is an `ISelection`.
   */
  static isISelection(e) {
    return e && typeof e.selectionStartLineNumber == "number" && typeof e.selectionStartColumn == "number" && typeof e.positionLineNumber == "number" && typeof e.positionColumn == "number";
  }
  /**
   * Create with a direction.
   */
  static createWithDirection(e, t, i, r, o) {
    return o === 0 ? new El(e, t, i, r) : new El(i, r, e, t);
  }
}, US = class {
  constructor(e, t, i) {
    this.offset = e | 0, this.type = t, this.language = i;
  }
  toString() {
    return "(" + this.offset + ", " + this.type + ")";
  }
};
class uN {
  constructor(e, t) {
    this.tokens = e, this.endState = t;
  }
}
class zS {
  constructor(e, t) {
    this.tokens = e, this.endState = t;
  }
}
var sR;
(function(n) {
  n[n.Unknown = 0] = "Unknown", n[n.Disabled = 1] = "Disabled", n[n.Enabled = 2] = "Enabled";
})(sR || (sR = {}));
var aR;
(function(n) {
  n[n.KeepWhitespace = 1] = "KeepWhitespace", n[n.InsertAsSnippet = 4] = "InsertAsSnippet";
})(aR || (aR = {}));
var lR;
(function(n) {
  n[n.Method = 0] = "Method", n[n.Function = 1] = "Function", n[n.Constructor = 2] = "Constructor", n[n.Field = 3] = "Field", n[n.Variable = 4] = "Variable", n[n.Class = 5] = "Class", n[n.Struct = 6] = "Struct", n[n.Interface = 7] = "Interface", n[n.Module = 8] = "Module", n[n.Property = 9] = "Property", n[n.Event = 10] = "Event", n[n.Operator = 11] = "Operator", n[n.Unit = 12] = "Unit", n[n.Value = 13] = "Value", n[n.Constant = 14] = "Constant", n[n.Enum = 15] = "Enum", n[n.EnumMember = 16] = "EnumMember", n[n.Keyword = 17] = "Keyword", n[n.Text = 18] = "Text", n[n.Color = 19] = "Color", n[n.File = 20] = "File", n[n.Reference = 21] = "Reference", n[n.Customcolor = 22] = "Customcolor", n[n.Folder = 23] = "Folder", n[n.TypeParameter = 24] = "TypeParameter", n[n.User = 25] = "User", n[n.Issue = 26] = "Issue", n[n.Snippet = 27] = "Snippet";
})(lR || (lR = {}));
var uR;
(function(n) {
  n[n.Deprecated = 1] = "Deprecated";
})(uR || (uR = {}));
var cR;
(function(n) {
  n[n.Invoke = 0] = "Invoke", n[n.TriggerCharacter = 1] = "TriggerCharacter", n[n.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
})(cR || (cR = {}));
var hR;
(function(n) {
  n[n.EXACT = 0] = "EXACT", n[n.ABOVE = 1] = "ABOVE", n[n.BELOW = 2] = "BELOW";
})(hR || (hR = {}));
var dR;
(function(n) {
  n[n.NotSet = 0] = "NotSet", n[n.ContentFlush = 1] = "ContentFlush", n[n.RecoverFromMarkers = 2] = "RecoverFromMarkers", n[n.Explicit = 3] = "Explicit", n[n.Paste = 4] = "Paste", n[n.Undo = 5] = "Undo", n[n.Redo = 6] = "Redo";
})(dR || (dR = {}));
var fR;
(function(n) {
  n[n.LF = 1] = "LF", n[n.CRLF = 2] = "CRLF";
})(fR || (fR = {}));
var pR;
(function(n) {
  n[n.Text = 0] = "Text", n[n.Read = 1] = "Read", n[n.Write = 2] = "Write";
})(pR || (pR = {}));
var gR;
(function(n) {
  n[n.None = 0] = "None", n[n.Keep = 1] = "Keep", n[n.Brackets = 2] = "Brackets", n[n.Advanced = 3] = "Advanced", n[n.Full = 4] = "Full";
})(gR || (gR = {}));
var mR;
(function(n) {
  n[n.acceptSuggestionOnCommitCharacter = 0] = "acceptSuggestionOnCommitCharacter", n[n.acceptSuggestionOnEnter = 1] = "acceptSuggestionOnEnter", n[n.accessibilitySupport = 2] = "accessibilitySupport", n[n.accessibilityPageSize = 3] = "accessibilityPageSize", n[n.ariaLabel = 4] = "ariaLabel", n[n.autoClosingBrackets = 5] = "autoClosingBrackets", n[n.autoClosingDelete = 6] = "autoClosingDelete", n[n.autoClosingOvertype = 7] = "autoClosingOvertype", n[n.autoClosingQuotes = 8] = "autoClosingQuotes", n[n.autoIndent = 9] = "autoIndent", n[n.automaticLayout = 10] = "automaticLayout", n[n.autoSurround = 11] = "autoSurround", n[n.codeLens = 12] = "codeLens", n[n.codeLensFontFamily = 13] = "codeLensFontFamily", n[n.codeLensFontSize = 14] = "codeLensFontSize", n[n.colorDecorators = 15] = "colorDecorators", n[n.columnSelection = 16] = "columnSelection", n[n.comments = 17] = "comments", n[n.contextmenu = 18] = "contextmenu", n[n.copyWithSyntaxHighlighting = 19] = "copyWithSyntaxHighlighting", n[n.cursorBlinking = 20] = "cursorBlinking", n[n.cursorSmoothCaretAnimation = 21] = "cursorSmoothCaretAnimation", n[n.cursorStyle = 22] = "cursorStyle", n[n.cursorSurroundingLines = 23] = "cursorSurroundingLines", n[n.cursorSurroundingLinesStyle = 24] = "cursorSurroundingLinesStyle", n[n.cursorWidth = 25] = "cursorWidth", n[n.disableLayerHinting = 26] = "disableLayerHinting", n[n.disableMonospaceOptimizations = 27] = "disableMonospaceOptimizations", n[n.domReadOnly = 28] = "domReadOnly", n[n.dragAndDrop = 29] = "dragAndDrop", n[n.emptySelectionClipboard = 30] = "emptySelectionClipboard", n[n.extraEditorClassName = 31] = "extraEditorClassName", n[n.fastScrollSensitivity = 32] = "fastScrollSensitivity", n[n.find = 33] = "find", n[n.fixedOverflowWidgets = 34] = "fixedOverflowWidgets", n[n.folding = 35] = "folding", n[n.foldingStrategy = 36] = "foldingStrategy", n[n.foldingHighlight = 37] = "foldingHighlight", n[n.unfoldOnClickAfterEndOfLine = 38] = "unfoldOnClickAfterEndOfLine", n[n.fontFamily = 39] = "fontFamily", n[n.fontInfo = 40] = "fontInfo", n[n.fontLigatures = 41] = "fontLigatures", n[n.fontSize = 42] = "fontSize", n[n.fontWeight = 43] = "fontWeight", n[n.formatOnPaste = 44] = "formatOnPaste", n[n.formatOnType = 45] = "formatOnType", n[n.glyphMargin = 46] = "glyphMargin", n[n.gotoLocation = 47] = "gotoLocation", n[n.hideCursorInOverviewRuler = 48] = "hideCursorInOverviewRuler", n[n.highlightActiveIndentGuide = 49] = "highlightActiveIndentGuide", n[n.hover = 50] = "hover", n[n.inDiffEditor = 51] = "inDiffEditor", n[n.inlineSuggest = 52] = "inlineSuggest", n[n.letterSpacing = 53] = "letterSpacing", n[n.lightbulb = 54] = "lightbulb", n[n.lineDecorationsWidth = 55] = "lineDecorationsWidth", n[n.lineHeight = 56] = "lineHeight", n[n.lineNumbers = 57] = "lineNumbers", n[n.lineNumbersMinChars = 58] = "lineNumbersMinChars", n[n.linkedEditing = 59] = "linkedEditing", n[n.links = 60] = "links", n[n.matchBrackets = 61] = "matchBrackets", n[n.minimap = 62] = "minimap", n[n.mouseStyle = 63] = "mouseStyle", n[n.mouseWheelScrollSensitivity = 64] = "mouseWheelScrollSensitivity", n[n.mouseWheelZoom = 65] = "mouseWheelZoom", n[n.multiCursorMergeOverlapping = 66] = "multiCursorMergeOverlapping", n[n.multiCursorModifier = 67] = "multiCursorModifier", n[n.multiCursorPaste = 68] = "multiCursorPaste", n[n.occurrencesHighlight = 69] = "occurrencesHighlight", n[n.overviewRulerBorder = 70] = "overviewRulerBorder", n[n.overviewRulerLanes = 71] = "overviewRulerLanes", n[n.padding = 72] = "padding", n[n.parameterHints = 73] = "parameterHints", n[n.peekWidgetDefaultFocus = 74] = "peekWidgetDefaultFocus", n[n.definitionLinkOpensInPeek = 75] = "definitionLinkOpensInPeek", n[n.quickSuggestions = 76] = "quickSuggestions", n[n.quickSuggestionsDelay = 77] = "quickSuggestionsDelay", n[n.readOnly = 78] = "readOnly", n[n.renameOnType = 79] = "renameOnType", n[n.renderControlCharacters = 80] = "renderControlCharacters", n[n.renderIndentGuides = 81] = "renderIndentGuides", n[n.renderFinalNewline = 82] = "renderFinalNewline", n[n.renderLineHighlight = 83] = "renderLineHighlight", n[n.renderLineHighlightOnlyWhenFocus = 84] = "renderLineHighlightOnlyWhenFocus", n[n.renderValidationDecorations = 85] = "renderValidationDecorations", n[n.renderWhitespace = 86] = "renderWhitespace", n[n.revealHorizontalRightPadding = 87] = "revealHorizontalRightPadding", n[n.roundedSelection = 88] = "roundedSelection", n[n.rulers = 89] = "rulers", n[n.scrollbar = 90] = "scrollbar", n[n.scrollBeyondLastColumn = 91] = "scrollBeyondLastColumn", n[n.scrollBeyondLastLine = 92] = "scrollBeyondLastLine", n[n.scrollPredominantAxis = 93] = "scrollPredominantAxis", n[n.selectionClipboard = 94] = "selectionClipboard", n[n.selectionHighlight = 95] = "selectionHighlight", n[n.selectOnLineNumbers = 96] = "selectOnLineNumbers", n[n.showFoldingControls = 97] = "showFoldingControls", n[n.showUnused = 98] = "showUnused", n[n.snippetSuggestions = 99] = "snippetSuggestions", n[n.smartSelect = 100] = "smartSelect", n[n.smoothScrolling = 101] = "smoothScrolling", n[n.stickyTabStops = 102] = "stickyTabStops", n[n.stopRenderingLineAfter = 103] = "stopRenderingLineAfter", n[n.suggest = 104] = "suggest", n[n.suggestFontSize = 105] = "suggestFontSize", n[n.suggestLineHeight = 106] = "suggestLineHeight", n[n.suggestOnTriggerCharacters = 107] = "suggestOnTriggerCharacters", n[n.suggestSelection = 108] = "suggestSelection", n[n.tabCompletion = 109] = "tabCompletion", n[n.tabIndex = 110] = "tabIndex", n[n.unusualLineTerminators = 111] = "unusualLineTerminators", n[n.useShadowDOM = 112] = "useShadowDOM", n[n.useTabStops = 113] = "useTabStops", n[n.wordSeparators = 114] = "wordSeparators", n[n.wordWrap = 115] = "wordWrap", n[n.wordWrapBreakAfterCharacters = 116] = "wordWrapBreakAfterCharacters", n[n.wordWrapBreakBeforeCharacters = 117] = "wordWrapBreakBeforeCharacters", n[n.wordWrapColumn = 118] = "wordWrapColumn", n[n.wordWrapOverride1 = 119] = "wordWrapOverride1", n[n.wordWrapOverride2 = 120] = "wordWrapOverride2", n[n.wrappingIndent = 121] = "wrappingIndent", n[n.wrappingStrategy = 122] = "wrappingStrategy", n[n.showDeprecated = 123] = "showDeprecated", n[n.inlayHints = 124] = "inlayHints", n[n.editorClassName = 125] = "editorClassName", n[n.pixelRatio = 126] = "pixelRatio", n[n.tabFocusMode = 127] = "tabFocusMode", n[n.layoutInfo = 128] = "layoutInfo", n[n.wrappingInfo = 129] = "wrappingInfo";
})(mR || (mR = {}));
var vR;
(function(n) {
  n[n.TextDefined = 0] = "TextDefined", n[n.LF = 1] = "LF", n[n.CRLF = 2] = "CRLF";
})(vR || (vR = {}));
var _R;
(function(n) {
  n[n.LF = 0] = "LF", n[n.CRLF = 1] = "CRLF";
})(_R || (_R = {}));
var CR;
(function(n) {
  n[n.None = 0] = "None", n[n.Indent = 1] = "Indent", n[n.IndentOutdent = 2] = "IndentOutdent", n[n.Outdent = 3] = "Outdent";
})(CR || (CR = {}));
var yR;
(function(n) {
  n[n.Other = 0] = "Other", n[n.Type = 1] = "Type", n[n.Parameter = 2] = "Parameter";
})(yR || (yR = {}));
var wR;
(function(n) {
  n[n.Automatic = 0] = "Automatic", n[n.Explicit = 1] = "Explicit";
})(wR || (wR = {}));
var bR;
(function(n) {
  n[n.DependsOnKbLayout = -1] = "DependsOnKbLayout", n[n.Unknown = 0] = "Unknown", n[n.Backspace = 1] = "Backspace", n[n.Tab = 2] = "Tab", n[n.Enter = 3] = "Enter", n[n.Shift = 4] = "Shift", n[n.Ctrl = 5] = "Ctrl", n[n.Alt = 6] = "Alt", n[n.PauseBreak = 7] = "PauseBreak", n[n.CapsLock = 8] = "CapsLock", n[n.Escape = 9] = "Escape", n[n.Space = 10] = "Space", n[n.PageUp = 11] = "PageUp", n[n.PageDown = 12] = "PageDown", n[n.End = 13] = "End", n[n.Home = 14] = "Home", n[n.LeftArrow = 15] = "LeftArrow", n[n.UpArrow = 16] = "UpArrow", n[n.RightArrow = 17] = "RightArrow", n[n.DownArrow = 18] = "DownArrow", n[n.Insert = 19] = "Insert", n[n.Delete = 20] = "Delete", n[n.KEY_0 = 21] = "KEY_0", n[n.KEY_1 = 22] = "KEY_1", n[n.KEY_2 = 23] = "KEY_2", n[n.KEY_3 = 24] = "KEY_3", n[n.KEY_4 = 25] = "KEY_4", n[n.KEY_5 = 26] = "KEY_5", n[n.KEY_6 = 27] = "KEY_6", n[n.KEY_7 = 28] = "KEY_7", n[n.KEY_8 = 29] = "KEY_8", n[n.KEY_9 = 30] = "KEY_9", n[n.KEY_A = 31] = "KEY_A", n[n.KEY_B = 32] = "KEY_B", n[n.KEY_C = 33] = "KEY_C", n[n.KEY_D = 34] = "KEY_D", n[n.KEY_E = 35] = "KEY_E", n[n.KEY_F = 36] = "KEY_F", n[n.KEY_G = 37] = "KEY_G", n[n.KEY_H = 38] = "KEY_H", n[n.KEY_I = 39] = "KEY_I", n[n.KEY_J = 40] = "KEY_J", n[n.KEY_K = 41] = "KEY_K", n[n.KEY_L = 42] = "KEY_L", n[n.KEY_M = 43] = "KEY_M", n[n.KEY_N = 44] = "KEY_N", n[n.KEY_O = 45] = "KEY_O", n[n.KEY_P = 46] = "KEY_P", n[n.KEY_Q = 47] = "KEY_Q", n[n.KEY_R = 48] = "KEY_R", n[n.KEY_S = 49] = "KEY_S", n[n.KEY_T = 50] = "KEY_T", n[n.KEY_U = 51] = "KEY_U", n[n.KEY_V = 52] = "KEY_V", n[n.KEY_W = 53] = "KEY_W", n[n.KEY_X = 54] = "KEY_X", n[n.KEY_Y = 55] = "KEY_Y", n[n.KEY_Z = 56] = "KEY_Z", n[n.Meta = 57] = "Meta", n[n.ContextMenu = 58] = "ContextMenu", n[n.F1 = 59] = "F1", n[n.F2 = 60] = "F2", n[n.F3 = 61] = "F3", n[n.F4 = 62] = "F4", n[n.F5 = 63] = "F5", n[n.F6 = 64] = "F6", n[n.F7 = 65] = "F7", n[n.F8 = 66] = "F8", n[n.F9 = 67] = "F9", n[n.F10 = 68] = "F10", n[n.F11 = 69] = "F11", n[n.F12 = 70] = "F12", n[n.F13 = 71] = "F13", n[n.F14 = 72] = "F14", n[n.F15 = 73] = "F15", n[n.F16 = 74] = "F16", n[n.F17 = 75] = "F17", n[n.F18 = 76] = "F18", n[n.F19 = 77] = "F19", n[n.NumLock = 78] = "NumLock", n[n.ScrollLock = 79] = "ScrollLock", n[n.US_SEMICOLON = 80] = "US_SEMICOLON", n[n.US_EQUAL = 81] = "US_EQUAL", n[n.US_COMMA = 82] = "US_COMMA", n[n.US_MINUS = 83] = "US_MINUS", n[n.US_DOT = 84] = "US_DOT", n[n.US_SLASH = 85] = "US_SLASH", n[n.US_BACKTICK = 86] = "US_BACKTICK", n[n.US_OPEN_SQUARE_BRACKET = 87] = "US_OPEN_SQUARE_BRACKET", n[n.US_BACKSLASH = 88] = "US_BACKSLASH", n[n.US_CLOSE_SQUARE_BRACKET = 89] = "US_CLOSE_SQUARE_BRACKET", n[n.US_QUOTE = 90] = "US_QUOTE", n[n.OEM_8 = 91] = "OEM_8", n[n.OEM_102 = 92] = "OEM_102", n[n.NUMPAD_0 = 93] = "NUMPAD_0", n[n.NUMPAD_1 = 94] = "NUMPAD_1", n[n.NUMPAD_2 = 95] = "NUMPAD_2", n[n.NUMPAD_3 = 96] = "NUMPAD_3", n[n.NUMPAD_4 = 97] = "NUMPAD_4", n[n.NUMPAD_5 = 98] = "NUMPAD_5", n[n.NUMPAD_6 = 99] = "NUMPAD_6", n[n.NUMPAD_7 = 100] = "NUMPAD_7", n[n.NUMPAD_8 = 101] = "NUMPAD_8", n[n.NUMPAD_9 = 102] = "NUMPAD_9", n[n.NUMPAD_MULTIPLY = 103] = "NUMPAD_MULTIPLY", n[n.NUMPAD_ADD = 104] = "NUMPAD_ADD", n[n.NUMPAD_SEPARATOR = 105] = "NUMPAD_SEPARATOR", n[n.NUMPAD_SUBTRACT = 106] = "NUMPAD_SUBTRACT", n[n.NUMPAD_DECIMAL = 107] = "NUMPAD_DECIMAL", n[n.NUMPAD_DIVIDE = 108] = "NUMPAD_DIVIDE", n[n.KEY_IN_COMPOSITION = 109] = "KEY_IN_COMPOSITION", n[n.ABNT_C1 = 110] = "ABNT_C1", n[n.ABNT_C2 = 111] = "ABNT_C2", n[n.MAX_VALUE = 112] = "MAX_VALUE";
})(bR || (bR = {}));
var SR;
(function(n) {
  n[n.Hint = 1] = "Hint", n[n.Info = 2] = "Info", n[n.Warning = 4] = "Warning", n[n.Error = 8] = "Error";
})(SR || (SR = {}));
var ER;
(function(n) {
  n[n.Unnecessary = 1] = "Unnecessary", n[n.Deprecated = 2] = "Deprecated";
})(ER || (ER = {}));
var LR;
(function(n) {
  n[n.Inline = 1] = "Inline", n[n.Gutter = 2] = "Gutter";
})(LR || (LR = {}));
var DR;
(function(n) {
  n[n.UNKNOWN = 0] = "UNKNOWN", n[n.TEXTAREA = 1] = "TEXTAREA", n[n.GUTTER_GLYPH_MARGIN = 2] = "GUTTER_GLYPH_MARGIN", n[n.GUTTER_LINE_NUMBERS = 3] = "GUTTER_LINE_NUMBERS", n[n.GUTTER_LINE_DECORATIONS = 4] = "GUTTER_LINE_DECORATIONS", n[n.GUTTER_VIEW_ZONE = 5] = "GUTTER_VIEW_ZONE", n[n.CONTENT_TEXT = 6] = "CONTENT_TEXT", n[n.CONTENT_EMPTY = 7] = "CONTENT_EMPTY", n[n.CONTENT_VIEW_ZONE = 8] = "CONTENT_VIEW_ZONE", n[n.CONTENT_WIDGET = 9] = "CONTENT_WIDGET", n[n.OVERVIEW_RULER = 10] = "OVERVIEW_RULER", n[n.SCROLLBAR = 11] = "SCROLLBAR", n[n.OVERLAY_WIDGET = 12] = "OVERLAY_WIDGET", n[n.OUTSIDE_EDITOR = 13] = "OUTSIDE_EDITOR";
})(DR || (DR = {}));
var RR;
(function(n) {
  n[n.TOP_RIGHT_CORNER = 0] = "TOP_RIGHT_CORNER", n[n.BOTTOM_RIGHT_CORNER = 1] = "BOTTOM_RIGHT_CORNER", n[n.TOP_CENTER = 2] = "TOP_CENTER";
})(RR || (RR = {}));
var TR;
(function(n) {
  n[n.Left = 1] = "Left", n[n.Center = 2] = "Center", n[n.Right = 4] = "Right", n[n.Full = 7] = "Full";
})(TR || (TR = {}));
var OR;
(function(n) {
  n[n.Off = 0] = "Off", n[n.On = 1] = "On", n[n.Relative = 2] = "Relative", n[n.Interval = 3] = "Interval", n[n.Custom = 4] = "Custom";
})(OR || (OR = {}));
var xR;
(function(n) {
  n[n.None = 0] = "None", n[n.Text = 1] = "Text", n[n.Blocks = 2] = "Blocks";
})(xR || (xR = {}));
var NR;
(function(n) {
  n[n.Smooth = 0] = "Smooth", n[n.Immediate = 1] = "Immediate";
})(NR || (NR = {}));
var IR;
(function(n) {
  n[n.Auto = 1] = "Auto", n[n.Hidden = 2] = "Hidden", n[n.Visible = 3] = "Visible";
})(IR || (IR = {}));
var PR;
(function(n) {
  n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL";
})(PR || (PR = {}));
var AR;
(function(n) {
  n[n.Invoke = 1] = "Invoke", n[n.TriggerCharacter = 2] = "TriggerCharacter", n[n.ContentChange = 3] = "ContentChange";
})(AR || (AR = {}));
var MR;
(function(n) {
  n[n.File = 0] = "File", n[n.Module = 1] = "Module", n[n.Namespace = 2] = "Namespace", n[n.Package = 3] = "Package", n[n.Class = 4] = "Class", n[n.Method = 5] = "Method", n[n.Property = 6] = "Property", n[n.Field = 7] = "Field", n[n.Constructor = 8] = "Constructor", n[n.Enum = 9] = "Enum", n[n.Interface = 10] = "Interface", n[n.Function = 11] = "Function", n[n.Variable = 12] = "Variable", n[n.Constant = 13] = "Constant", n[n.String = 14] = "String", n[n.Number = 15] = "Number", n[n.Boolean = 16] = "Boolean", n[n.Array = 17] = "Array", n[n.Object = 18] = "Object", n[n.Key = 19] = "Key", n[n.Null = 20] = "Null", n[n.EnumMember = 21] = "EnumMember", n[n.Struct = 22] = "Struct", n[n.Event = 23] = "Event", n[n.Operator = 24] = "Operator", n[n.TypeParameter = 25] = "TypeParameter";
})(MR || (MR = {}));
var FR;
(function(n) {
  n[n.Deprecated = 1] = "Deprecated";
})(FR || (FR = {}));
var kR;
(function(n) {
  n[n.Hidden = 0] = "Hidden", n[n.Blink = 1] = "Blink", n[n.Smooth = 2] = "Smooth", n[n.Phase = 3] = "Phase", n[n.Expand = 4] = "Expand", n[n.Solid = 5] = "Solid";
})(kR || (kR = {}));
var WR;
(function(n) {
  n[n.Line = 1] = "Line", n[n.Block = 2] = "Block", n[n.Underline = 3] = "Underline", n[n.LineThin = 4] = "LineThin", n[n.BlockOutline = 5] = "BlockOutline", n[n.UnderlineThin = 6] = "UnderlineThin";
})(WR || (WR = {}));
var VR;
(function(n) {
  n[n.AlwaysGrowsWhenTypingAtEdges = 0] = "AlwaysGrowsWhenTypingAtEdges", n[n.NeverGrowsWhenTypingAtEdges = 1] = "NeverGrowsWhenTypingAtEdges", n[n.GrowsOnlyWhenTypingBefore = 2] = "GrowsOnlyWhenTypingBefore", n[n.GrowsOnlyWhenTypingAfter = 3] = "GrowsOnlyWhenTypingAfter";
})(VR || (VR = {}));
var BR;
(function(n) {
  n[n.None = 0] = "None", n[n.Same = 1] = "Same", n[n.Indent = 2] = "Indent", n[n.DeepIndent = 3] = "DeepIndent";
})(BR || (BR = {}));
let A_ = class {
  static chord(e, t) {
    return Xie(e, t);
  }
};
A_.CtrlCmd = 2048;
A_.Shift = 1024;
A_.Alt = 512;
A_.WinCtrl = 256;
function fG() {
  return {
    editor: void 0,
    languages: void 0,
    CancellationTokenSource: uh,
    Emitter: j,
    KeyCode: bR,
    KeyMod: A_,
    Position: J,
    Range: V,
    Selection: Ut,
    SelectionDirection: PR,
    MarkerSeverity: SR,
    MarkerTag: ER,
    Uri: dt,
    Token: US
  };
}
var za;
(function(n) {
  n.serviceIds = /* @__PURE__ */ new Map(), n.DI_TARGET = "$di$target", n.DI_DEPENDENCIES = "$di$dependencies";
  function e(t) {
    return t[n.DI_DEPENDENCIES] || [];
  }
  n.getServiceDependencies = e;
})(za || (za = {}));
const eo = Vt("instantiationService");
function pG(n, e, t, i) {
  e[za.DI_TARGET] === e ? e[za.DI_DEPENDENCIES].push({ id: n, index: t, optional: i }) : (e[za.DI_DEPENDENCIES] = [{ id: n, index: t, optional: i }], e[za.DI_TARGET] = e);
}
function Vt(n) {
  if (za.serviceIds.has(n))
    return za.serviceIds.get(n);
  const e = function(t, i, r) {
    if (arguments.length !== 3)
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    pG(e, t, r, !1);
  };
  return e.toString = () => n, za.serviceIds.set(n, e), e;
}
function mne(n) {
  return function(e, t, i) {
    if (arguments.length !== 3)
      throw new Error("@optional-decorator can only be used to decorate a parameter");
    pG(n, e, i, !0);
  };
}
const pr = Vt("codeEditorService");
class Rd {
  constructor() {
    this._zoomLevel = 0, this._lastZoomLevelChangeTime = 0, this._onDidChangeZoomLevel = new j(), this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event, this._zoomFactor = 1;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  getTimeSinceLastZoomLevelChanged() {
    return Date.now() - this._lastZoomLevelChangeTime;
  }
  getZoomFactor() {
    return this._zoomFactor;
  }
  // --- Pixel Ratio
  getPixelRatio() {
    let e = document.createElement("canvas").getContext("2d"), t = window.devicePixelRatio || 1, i = e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1;
    return t / i;
  }
}
Rd.INSTANCE = new Rd();
function HR() {
  return Rd.INSTANCE.getZoomLevel();
}
function vne() {
  return Rd.INSTANCE.getTimeSinceLastZoomLevelChanged();
}
function _ne(n) {
  return Rd.INSTANCE.onDidChangeZoomLevel(n);
}
function Cne() {
  return Rd.INSTANCE.getZoomFactor();
}
function nb() {
  return Rd.INSTANCE.getPixelRatio();
}
const M_ = navigator.userAgent, Qr = M_.indexOf("Firefox") >= 0, hd = M_.indexOf("AppleWebKit") >= 0, rb = M_.indexOf("Chrome") >= 0, Td = !rb && M_.indexOf("Safari") >= 0, yne = !rb && !Td && hd, Bm = M_.indexOf("Android") >= 0, wne = window.matchMedia && window.matchMedia("(display-mode: standalone)").matches, yt = (n, e, t) => {
  const i = (o) => r.fire(o), r = new j({
    onFirstListenerAdd: () => {
      n.addEventListener(e, i, t);
    },
    onLastListenerRemove: () => {
      n.removeEventListener(e, i, t);
    }
  });
  return r.event;
};
class Er {
  constructor(e, t, i) {
    const r = (o) => this.emitter.fire(o);
    this.emitter = new j({
      onFirstListenerAdd: () => e.addEventListener(t, r, i),
      onLastListenerRemove: () => e.removeEventListener(t, r, i)
    });
  }
  get event() {
    return this.emitter.event;
  }
  dispose() {
    this.emitter.dispose();
  }
}
function GR(n) {
  return n.preventDefault(), n.stopPropagation(), n;
}
function rCe(n) {
  return Ae.map(n, GR);
}
let gG = new Array(230), UL = new Array(
  112
  /* MAX_VALUE */
);
(function() {
  for (let e = 0; e < UL.length; e++)
    UL[e] = -1;
  function n(e, t) {
    gG[e] = t, UL[t] = e;
  }
  n(
    3,
    7
    /* PauseBreak */
  ), n(
    8,
    1
    /* Backspace */
  ), n(
    9,
    2
    /* Tab */
  ), n(
    13,
    3
    /* Enter */
  ), n(
    16,
    4
    /* Shift */
  ), n(
    17,
    5
    /* Ctrl */
  ), n(
    18,
    6
    /* Alt */
  ), n(
    19,
    7
    /* PauseBreak */
  ), n(
    20,
    8
    /* CapsLock */
  ), n(
    27,
    9
    /* Escape */
  ), n(
    32,
    10
    /* Space */
  ), n(
    33,
    11
    /* PageUp */
  ), n(
    34,
    12
    /* PageDown */
  ), n(
    35,
    13
    /* End */
  ), n(
    36,
    14
    /* Home */
  ), n(
    37,
    15
    /* LeftArrow */
  ), n(
    38,
    16
    /* UpArrow */
  ), n(
    39,
    17
    /* RightArrow */
  ), n(
    40,
    18
    /* DownArrow */
  ), n(
    45,
    19
    /* Insert */
  ), n(
    46,
    20
    /* Delete */
  ), n(
    48,
    21
    /* KEY_0 */
  ), n(
    49,
    22
    /* KEY_1 */
  ), n(
    50,
    23
    /* KEY_2 */
  ), n(
    51,
    24
    /* KEY_3 */
  ), n(
    52,
    25
    /* KEY_4 */
  ), n(
    53,
    26
    /* KEY_5 */
  ), n(
    54,
    27
    /* KEY_6 */
  ), n(
    55,
    28
    /* KEY_7 */
  ), n(
    56,
    29
    /* KEY_8 */
  ), n(
    57,
    30
    /* KEY_9 */
  ), n(
    65,
    31
    /* KEY_A */
  ), n(
    66,
    32
    /* KEY_B */
  ), n(
    67,
    33
    /* KEY_C */
  ), n(
    68,
    34
    /* KEY_D */
  ), n(
    69,
    35
    /* KEY_E */
  ), n(
    70,
    36
    /* KEY_F */
  ), n(
    71,
    37
    /* KEY_G */
  ), n(
    72,
    38
    /* KEY_H */
  ), n(
    73,
    39
    /* KEY_I */
  ), n(
    74,
    40
    /* KEY_J */
  ), n(
    75,
    41
    /* KEY_K */
  ), n(
    76,
    42
    /* KEY_L */
  ), n(
    77,
    43
    /* KEY_M */
  ), n(
    78,
    44
    /* KEY_N */
  ), n(
    79,
    45
    /* KEY_O */
  ), n(
    80,
    46
    /* KEY_P */
  ), n(
    81,
    47
    /* KEY_Q */
  ), n(
    82,
    48
    /* KEY_R */
  ), n(
    83,
    49
    /* KEY_S */
  ), n(
    84,
    50
    /* KEY_T */
  ), n(
    85,
    51
    /* KEY_U */
  ), n(
    86,
    52
    /* KEY_V */
  ), n(
    87,
    53
    /* KEY_W */
  ), n(
    88,
    54
    /* KEY_X */
  ), n(
    89,
    55
    /* KEY_Y */
  ), n(
    90,
    56
    /* KEY_Z */
  ), n(
    93,
    58
    /* ContextMenu */
  ), n(
    96,
    93
    /* NUMPAD_0 */
  ), n(
    97,
    94
    /* NUMPAD_1 */
  ), n(
    98,
    95
    /* NUMPAD_2 */
  ), n(
    99,
    96
    /* NUMPAD_3 */
  ), n(
    100,
    97
    /* NUMPAD_4 */
  ), n(
    101,
    98
    /* NUMPAD_5 */
  ), n(
    102,
    99
    /* NUMPAD_6 */
  ), n(
    103,
    100
    /* NUMPAD_7 */
  ), n(
    104,
    101
    /* NUMPAD_8 */
  ), n(
    105,
    102
    /* NUMPAD_9 */
  ), n(
    106,
    103
    /* NUMPAD_MULTIPLY */
  ), n(
    107,
    104
    /* NUMPAD_ADD */
  ), n(
    108,
    105
    /* NUMPAD_SEPARATOR */
  ), n(
    109,
    106
    /* NUMPAD_SUBTRACT */
  ), n(
    110,
    107
    /* NUMPAD_DECIMAL */
  ), n(
    111,
    108
    /* NUMPAD_DIVIDE */
  ), n(
    112,
    59
    /* F1 */
  ), n(
    113,
    60
    /* F2 */
  ), n(
    114,
    61
    /* F3 */
  ), n(
    115,
    62
    /* F4 */
  ), n(
    116,
    63
    /* F5 */
  ), n(
    117,
    64
    /* F6 */
  ), n(
    118,
    65
    /* F7 */
  ), n(
    119,
    66
    /* F8 */
  ), n(
    120,
    67
    /* F9 */
  ), n(
    121,
    68
    /* F10 */
  ), n(
    122,
    69
    /* F11 */
  ), n(
    123,
    70
    /* F12 */
  ), n(
    124,
    71
    /* F13 */
  ), n(
    125,
    72
    /* F14 */
  ), n(
    126,
    73
    /* F15 */
  ), n(
    127,
    74
    /* F16 */
  ), n(
    128,
    75
    /* F17 */
  ), n(
    129,
    76
    /* F18 */
  ), n(
    130,
    77
    /* F19 */
  ), n(
    144,
    78
    /* NumLock */
  ), n(
    145,
    79
    /* ScrollLock */
  ), n(
    186,
    80
    /* US_SEMICOLON */
  ), n(
    187,
    81
    /* US_EQUAL */
  ), n(
    188,
    82
    /* US_COMMA */
  ), n(
    189,
    83
    /* US_MINUS */
  ), n(
    190,
    84
    /* US_DOT */
  ), n(
    191,
    85
    /* US_SLASH */
  ), n(
    192,
    86
    /* US_BACKTICK */
  ), n(
    193,
    110
    /* ABNT_C1 */
  ), n(
    194,
    111
    /* ABNT_C2 */
  ), n(
    219,
    87
    /* US_OPEN_SQUARE_BRACKET */
  ), n(
    220,
    88
    /* US_BACKSLASH */
  ), n(
    221,
    89
    /* US_CLOSE_SQUARE_BRACKET */
  ), n(
    222,
    90
    /* US_QUOTE */
  ), n(
    223,
    91
    /* OEM_8 */
  ), n(
    226,
    92
    /* OEM_102 */
  ), n(
    229,
    109
    /* KEY_IN_COMPOSITION */
  ), Qr ? (n(
    59,
    80
    /* US_SEMICOLON */
  ), n(
    107,
    81
    /* US_EQUAL */
  ), n(
    109,
    83
    /* US_MINUS */
  ), Ft && n(
    224,
    57
    /* Meta */
  )) : hd && (n(
    91,
    57
    /* Meta */
  ), n(
    Ft ? 93 : 92,
    57
    /* Meta */
  ));
})();
function bne(n) {
  if (n.charCode) {
    let e = String.fromCharCode(n.charCode).toUpperCase();
    return hp.fromString(e);
  }
  return gG[n.keyCode] || 0;
}
const Sne = Ft ? 256 : 2048, Ene = 512, Lne = 1024, Dne = Ft ? 2048 : 256;
class Ki {
  constructor(e) {
    this._standardKeyboardEventBrand = !0;
    let t = e;
    this.browserEvent = t, this.target = t.target, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, this.keyCode = bne(t), this.code = t.code, this.ctrlKey = this.ctrlKey || this.keyCode === 5, this.altKey = this.altKey || this.keyCode === 6, this.shiftKey = this.shiftKey || this.keyCode === 4, this.metaKey = this.metaKey || this.keyCode === 57, this._asKeybinding = this._computeKeybinding(), this._asRuntimeKeybinding = this._computeRuntimeKeybinding();
  }
  preventDefault() {
    this.browserEvent && this.browserEvent.preventDefault && this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent && this.browserEvent.stopPropagation && this.browserEvent.stopPropagation();
  }
  toKeybinding() {
    return this._asRuntimeKeybinding;
  }
  equals(e) {
    return this._asKeybinding === e;
  }
  _computeKeybinding() {
    let e = 0;
    this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode);
    let t = 0;
    return this.ctrlKey && (t |= Sne), this.altKey && (t |= Ene), this.shiftKey && (t |= Lne), this.metaKey && (t |= Dne), t |= e, t;
  }
  _computeRuntimeKeybinding() {
    let e = 0;
    return this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode), new aN(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, e);
  }
}
let UR = !1, bf = null;
function Rne(n) {
  if (!n.parent || n.parent === n)
    return null;
  try {
    let e = n.location, t = n.parent.location;
    if (e.origin !== "null" && t.origin !== "null" && (e.protocol !== t.protocol || e.hostname !== t.hostname || e.port !== t.port))
      return UR = !0, null;
  } catch {
    return UR = !0, null;
  }
  return n.parent;
}
class zR {
  /**
   * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).
   * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.
   * To distinguish if at one point the current execution environment is running inside a window with a different origin, see hasDifferentOriginAncestor()
   */
  static getSameOriginWindowChain() {
    if (!bf) {
      bf = [];
      let e = window, t;
      do
        t = Rne(e), t ? bf.push({
          window: e,
          iframeElement: e.frameElement || null
        }) : bf.push({
          window: e,
          iframeElement: null
        }), e = t;
      while (e);
    }
    return bf.slice(0);
  }
  /**
   * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.
   * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.
   */
  static hasDifferentOriginAncestor() {
    return bf || this.getSameOriginWindowChain(), UR;
  }
  /**
   * Returns the position of `childWindow` relative to `ancestorWindow`
   */
  static getPositionOfChildWindowRelativeToAncestorWindow(e, t) {
    if (!t || e === t)
      return {
        top: 0,
        left: 0
      };
    let i = 0, r = 0, o = this.getSameOriginWindowChain();
    for (const s of o) {
      if (i += s.window.scrollY, r += s.window.scrollX, s.window === t || !s.iframeElement)
        break;
      let a = s.iframeElement.getBoundingClientRect();
      i += a.top, r += a.left;
    }
    return {
      top: i,
      left: r
    };
  }
}
class ca {
  constructor(e) {
    this.timestamp = Date.now(), this.browserEvent = e, this.leftButton = e.button === 0, this.middleButton = e.button === 1, this.rightButton = e.button === 2, this.buttons = e.buttons, this.target = e.target, this.detail = e.detail || 1, e.type === "dblclick" && (this.detail = 2), this.ctrlKey = e.ctrlKey, this.shiftKey = e.shiftKey, this.altKey = e.altKey, this.metaKey = e.metaKey, typeof e.pageX == "number" ? (this.posx = e.pageX, this.posy = e.pageY) : (this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop);
    let t = zR.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);
    this.posx -= t.left, this.posy -= t.top;
  }
  preventDefault() {
    this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent.stopPropagation();
  }
}
class Vp {
  constructor(e, t = 0, i = 0) {
    if (this.browserEvent = e || null, this.target = e ? e.target || e.targetNode || e.srcElement : null, this.deltaY = i, this.deltaX = t, e) {
      let r = e, o = e;
      if (typeof r.wheelDeltaY < "u")
        this.deltaY = r.wheelDeltaY / 120;
      else if (typeof o.VERTICAL_AXIS < "u" && o.axis === o.VERTICAL_AXIS)
        this.deltaY = -o.detail / 3;
      else if (e.type === "wheel") {
        const s = e;
        s.deltaMode === s.DOM_DELTA_LINE ? Qr && !Ft ? this.deltaY = -e.deltaY / 3 : this.deltaY = -e.deltaY : this.deltaY = -e.deltaY / 40;
      }
      if (typeof r.wheelDeltaX < "u")
        Td && Eo ? this.deltaX = -(r.wheelDeltaX / 120) : this.deltaX = r.wheelDeltaX / 120;
      else if (typeof o.HORIZONTAL_AXIS < "u" && o.axis === o.HORIZONTAL_AXIS)
        this.deltaX = -e.detail / 3;
      else if (e.type === "wheel") {
        const s = e;
        s.deltaMode === s.DOM_DELTA_LINE ? Qr && !Ft ? this.deltaX = -e.deltaX / 3 : this.deltaX = -e.deltaX : this.deltaX = -e.deltaX / 40;
      }
      this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta && (this.deltaY = e.wheelDelta / 120);
    }
  }
  preventDefault() {
    this.browserEvent && this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent && this.browserEvent.stopPropagation();
  }
}
var ay = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function Tne(n) {
  return !!n && typeof n.then == "function";
}
function mG(n) {
  const e = new uh(), t = n(e.token), i = new Promise((r, o) => {
    e.token.onCancellationRequested(() => {
      o(HS());
    }), Promise.resolve(t).then((s) => {
      e.dispose(), r(s);
    }, (s) => {
      e.dispose(), o(s);
    });
  });
  return new class {
    cancel() {
      e.cancel();
    }
    then(r, o) {
      return i.then(r, o);
    }
    catch(r) {
      return this.then(void 0, r);
    }
    finally(r) {
      return i.finally(r);
    }
  }();
}
function oCe(n, e, t) {
  return Promise.race([n, new Promise((i) => e.onCancellationRequested(() => i(t)))]);
}
class One {
  constructor() {
    this.activePromise = null, this.queuedPromise = null, this.queuedPromiseFactory = null;
  }
  queue(e) {
    if (this.activePromise) {
      if (this.queuedPromiseFactory = e, !this.queuedPromise) {
        const t = () => {
          this.queuedPromise = null;
          const i = this.queue(this.queuedPromiseFactory);
          return this.queuedPromiseFactory = null, i;
        };
        this.queuedPromise = new Promise((i) => {
          this.activePromise.then(t, t).then(i);
        });
      }
      return new Promise((t, i) => {
        this.queuedPromise.then(t, i);
      });
    }
    return this.activePromise = e(), new Promise((t, i) => {
      this.activePromise.then((r) => {
        this.activePromise = null, t(r);
      }, (r) => {
        this.activePromise = null, i(r);
      });
    });
  }
}
class cN {
  constructor(e) {
    this.defaultDelay = e, this.timeout = null, this.completionPromise = null, this.doResolve = null, this.doReject = null, this.task = null;
  }
  trigger(e, t = this.defaultDelay) {
    return this.task = e, this.cancelTimeout(), this.completionPromise || (this.completionPromise = new Promise((i, r) => {
      this.doResolve = i, this.doReject = r;
    }).then(() => {
      if (this.completionPromise = null, this.doResolve = null, this.task) {
        const i = this.task;
        return this.task = null, i();
      }
    })), this.timeout = setTimeout(() => {
      this.timeout = null, this.doResolve && this.doResolve(null);
    }, t), this.completionPromise;
  }
  isTriggered() {
    return this.timeout !== null;
  }
  cancel() {
    this.cancelTimeout(), this.completionPromise && (this.doReject && this.doReject(HS()), this.completionPromise = null);
  }
  cancelTimeout() {
    this.timeout !== null && (clearTimeout(this.timeout), this.timeout = null);
  }
  dispose() {
    this.cancelTimeout();
  }
}
class xne {
  constructor(e) {
    this.delayer = new cN(e), this.throttler = new One();
  }
  trigger(e, t) {
    return this.delayer.trigger(() => this.throttler.queue(e), t);
  }
  cancel() {
    this.delayer.cancel();
  }
  dispose() {
    this.delayer.dispose();
  }
}
function Vv(n, e) {
  return e ? new Promise((t, i) => {
    const r = setTimeout(t, n);
    e.onCancellationRequested(() => {
      clearTimeout(r), i(HS());
    });
  }) : mG((t) => Vv(n, t));
}
function jR(n, e = 0) {
  const t = setTimeout(n, e);
  return Ri(() => clearTimeout(t));
}
function sCe(n, e = (i) => !!i, t = null) {
  let i = 0;
  const r = n.length, o = () => {
    if (i >= r)
      return Promise.resolve(t);
    const s = n[i++];
    return Promise.resolve(s()).then((l) => e(l) ? Promise.resolve(l) : o());
  };
  return o();
}
class ec {
  constructor(e, t) {
    this._token = -1, typeof e == "function" && typeof t == "number" && this.setIfNotSet(e, t);
  }
  dispose() {
    this.cancel();
  }
  cancel() {
    this._token !== -1 && (clearTimeout(this._token), this._token = -1);
  }
  cancelAndSet(e, t) {
    this.cancel(), this._token = setTimeout(() => {
      this._token = -1, e();
    }, t);
  }
  setIfNotSet(e, t) {
    this._token === -1 && (this._token = setTimeout(() => {
      this._token = -1, e();
    }, t));
  }
}
class F_ {
  constructor() {
    this._token = -1;
  }
  dispose() {
    this.cancel();
  }
  cancel() {
    this._token !== -1 && (clearInterval(this._token), this._token = -1);
  }
  cancelAndSet(e, t) {
    this.cancel(), this._token = setInterval(() => {
      e();
    }, t);
  }
}
class to {
  constructor(e, t) {
    this.timeoutToken = -1, this.runner = e, this.timeout = t, this.timeoutHandler = this.onTimeout.bind(this);
  }
  /**
   * Dispose RunOnceScheduler
   */
  dispose() {
    this.cancel(), this.runner = null;
  }
  /**
   * Cancel current scheduled runner (if any).
   */
  cancel() {
    this.isScheduled() && (clearTimeout(this.timeoutToken), this.timeoutToken = -1);
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */
  schedule(e = this.timeout) {
    this.cancel(), this.timeoutToken = setTimeout(this.timeoutHandler, e);
  }
  get delay() {
    return this.timeout;
  }
  set delay(e) {
    this.timeout = e;
  }
  /**
   * Returns true if scheduled.
   */
  isScheduled() {
    return this.timeoutToken !== -1;
  }
  onTimeout() {
    this.timeoutToken = -1, this.runner && this.doRun();
  }
  doRun() {
    this.runner && this.runner();
  }
}
let $R;
(function() {
  if (typeof requestIdleCallback != "function" || typeof cancelIdleCallback != "function") {
    const n = Object.freeze({
      didTimeout: !0,
      timeRemaining() {
        return 15;
      }
    });
    $R = (e) => {
      const t = setTimeout(() => e(n));
      let i = !1;
      return {
        dispose() {
          i || (i = !0, clearTimeout(t));
        }
      };
    };
  } else
    $R = (n, e) => {
      const t = requestIdleCallback(n, typeof e == "number" ? { timeout: e } : void 0);
      let i = !1;
      return {
        dispose() {
          i || (i = !0, cancelIdleCallback(t));
        }
      };
    };
})();
class vG {
  constructor(e) {
    this._didRun = !1, this._executor = () => {
      try {
        this._value = e();
      } catch (t) {
        this._error = t;
      } finally {
        this._didRun = !0;
      }
    }, this._handle = $R(() => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (this._didRun || (this._handle.dispose(), this._executor()), this._error)
      throw this._error;
    return this._value;
  }
}
var KR;
(function(n) {
  function e(o) {
    return ay(this, void 0, void 0, function* () {
      return typeof Promise.allSettled == "function" ? t(o) : i(o);
    });
  }
  n.allSettled = e;
  function t(o) {
    return ay(this, void 0, void 0, function* () {
      return Promise.allSettled(o);
    });
  }
  function i(o) {
    return ay(this, void 0, void 0, function* () {
      return Promise.all(o.map((s) => s.then((a) => ({ status: "fulfilled", value: a }), (a) => ({ status: "rejected", reason: a }))));
    });
  }
  function r(o) {
    return ay(this, void 0, void 0, function* () {
      let s;
      const a = yield Promise.all(o.map((l) => l.then((u) => u, (u) => {
        s || (s = u);
      })));
      if (typeof s < "u")
        throw s;
      return a;
    });
  }
  n.settled = r;
})(KR || (KR = {}));
var vi;
(function(n) {
  n.inMemory = "inmemory", n.vscode = "vscode", n.internal = "private", n.walkThrough = "walkThrough", n.walkThroughSnippet = "walkThroughSnippet", n.http = "http", n.https = "https", n.file = "file", n.mailto = "mailto", n.untitled = "untitled", n.data = "data", n.command = "command", n.vscodeRemote = "vscode-remote", n.vscodeRemoteResource = "vscode-remote-resource", n.userData = "vscode-userdata", n.vscodeCustomEditor = "vscode-custom-editor", n.vscodeNotebook = "vscode-notebook", n.vscodeNotebookCell = "vscode-notebook-cell", n.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", n.vscodeNotebookCellOutput = "vscode-notebook-cell-output", n.vscodeSettings = "vscode-settings", n.vscodeWorkspaceTrust = "vscode-workspace-trust", n.vscodeTerminal = "vscode-terminal", n.webviewPanel = "webview-panel", n.vscodeWebview = "vscode-webview", n.extension = "extension", n.vscodeFileResource = "vscode-file", n.tmp = "tmp";
})(vi || (vi = {}));
class Nne {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null;
  }
  setPreferredWebSchema(e) {
    this._preferredWebSchema = e;
  }
  rewrite(e) {
    if (this._delegate)
      return this._delegate(e);
    const t = e.authority;
    let i = this._hosts[t];
    i && i.indexOf(":") !== -1 && (i = `[${i}]`);
    const r = this._ports[t], o = this._connectionTokens[t];
    let s = `path=${encodeURIComponent(e.path)}`;
    return typeof o == "string" && (s += `&tkn=${encodeURIComponent(o)}`), dt.from({
      scheme: BS ? this._preferredWebSchema : vi.vscodeRemoteResource,
      authority: `${i}:${r}`,
      path: "/vscode-remote-resource",
      query: s
    });
  }
}
const _G = new Nne();
class Ine {
  constructor() {
    this.FALLBACK_AUTHORITY = "vscode-app";
  }
  asBrowserUri(e, t, i) {
    const r = this.toUri(e, t);
    return r.scheme === vi.vscodeRemote ? _G.rewrite(r) : iv && (i || nie) && r.scheme === vi.file ? r.with({
      scheme: vi.vscodeFileResource,
      // We need to provide an authority here so that it can serve
      // as origin for network and loading matters in chromium.
      // If the URI is not coming with an authority already, we
      // add our own
      authority: r.authority || this.FALLBACK_AUTHORITY,
      query: null,
      fragment: null
    }) : r;
  }
  toUri(e, t) {
    return dt.isUri(e) ? e : dt.parse(t.toUrl(e));
  }
}
const Pne = new Ine(), jS = {
  clipboard: {
    writeText: iv || document.queryCommandSupported && document.queryCommandSupported("copy") || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
    readText: iv || !!(navigator && navigator.clipboard && navigator.clipboard.readText)
  },
  keyboard: (() => iv || wne ? 0 : navigator.keyboard || Td ? 1 : 2)(),
  // 'ontouchstart' in window always evaluates to true with typescript's modern typings. This causes `window` to be
  // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast
  touch: "ontouchstart" in window || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0,
  pointerEvents: window.PointerEvent && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0 || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0)
};
function Ts(n) {
  for (; n.firstChild; )
    n.firstChild.remove();
}
function CG(n) {
  var e;
  return (e = n == null ? void 0 : n.isConnected) !== null && e !== void 0 ? e : !1;
}
class Ane {
  constructor(e, t, i, r) {
    this._node = e, this._type = t, this._handler = i, this._options = r || !1, this._node.addEventListener(this._type, this._handler, this._options);
  }
  dispose() {
    this._handler && (this._node.removeEventListener(this._type, this._handler, this._options), this._node = null, this._handler = null);
  }
}
function ye(n, e, t, i) {
  return new Ane(n, e, t, i);
}
function yG(n) {
  return function(e) {
    return n(new ca(e));
  };
}
function Mne(n) {
  return function(e) {
    return n(new Ki(e));
  };
}
let Jr = function(e, t, i, r) {
  let o = i;
  return t === "click" || t === "mousedown" ? o = yG(i) : (t === "keydown" || t === "keypress" || t === "keyup") && (o = Mne(i)), ye(e, t, o, r);
}, aCe = function(e, t, i) {
  let r = yG(t);
  return Fne(e, r, i);
};
function Fne(n, e, t) {
  return ye(n, _g && jS.pointerEvents ? Be.POINTER_DOWN : Be.MOUSE_DOWN, e, t);
}
function lCe(n, e, t) {
  return ye(n, _g && jS.pointerEvents ? Be.POINTER_UP : Be.MOUSE_UP, e, t);
}
function wG(n, e) {
  return ye(n, "mouseout", (t) => {
    let i = t.relatedTarget;
    for (; i && i !== n; )
      i = i.parentNode;
    i !== n && e(t);
  });
}
function kne(n, e) {
  return ye(n, "pointerout", (t) => {
    let i = t.relatedTarget;
    for (; i && i !== n; )
      i = i.parentNode;
    i !== n && e(t);
  });
}
let zL = null;
function Wne(n) {
  if (!zL) {
    const e = (t) => setTimeout(() => t((/* @__PURE__ */ new Date()).getTime()), 0);
    zL = self.requestAnimationFrame || self.msRequestAnimationFrame || self.webkitRequestAnimationFrame || self.mozRequestAnimationFrame || self.oRequestAnimationFrame || e;
  }
  return zL.call(self, n);
}
let bG, zl;
class jL {
  constructor(e, t = 0) {
    this._runner = e, this.priority = t, this._canceled = !1;
  }
  dispose() {
    this._canceled = !0;
  }
  execute() {
    if (!this._canceled)
      try {
        this._runner();
      } catch (e) {
        Ni(e);
      }
  }
  // Sort by priority (largest to lowest)
  static sort(e, t) {
    return t.priority - e.priority;
  }
}
(function() {
  let n = [], e = null, t = !1, i = !1, r = () => {
    for (t = !1, e = n, n = [], i = !0; e.length > 0; )
      e.sort(jL.sort), e.shift().execute();
    i = !1;
  };
  zl = (o, s = 0) => {
    let a = new jL(o, s);
    return n.push(a), t || (t = !0, Wne(r)), a;
  }, bG = (o, s) => {
    if (i) {
      let a = new jL(o, s);
      return e.push(a), a;
    } else
      return zl(o, s);
  };
})();
const Vne = 8, Bne = function(n, e) {
  return e;
};
class Hne extends ge {
  constructor(e, t, i, r = Bne, o = Vne) {
    super();
    let s = null, a = 0, l = this._register(new ec()), u = () => {
      a = (/* @__PURE__ */ new Date()).getTime(), i(s), s = null;
    };
    this._register(ye(e, t, (c) => {
      s = r(s, c);
      let h = (/* @__PURE__ */ new Date()).getTime() - a;
      h >= o ? (l.cancel(), u()) : l.setIfNotSet(u, o - h);
    }));
  }
}
function hN(n, e, t, i, r) {
  return new Hne(n, e, t, i, r);
}
function SG(n) {
  return document.defaultView.getComputedStyle(n, null);
}
function EG(n) {
  if (n !== document.body)
    return new Ua(n.clientWidth, n.clientHeight);
  if (_g && window.visualViewport)
    return new Ua(window.visualViewport.width, window.visualViewport.height);
  if (window.innerWidth && window.innerHeight)
    return new Ua(window.innerWidth, window.innerHeight);
  if (document.body && document.body.clientWidth && document.body.clientHeight)
    return new Ua(document.body.clientWidth, document.body.clientHeight);
  if (document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight)
    return new Ua(document.documentElement.clientWidth, document.documentElement.clientHeight);
  throw new Error("Unable to figure out browser width and height");
}
class xi {
  // Adapted from WinJS
  // Converts a CSS positioning string for the specified element to pixels.
  static convertToPixels(e, t) {
    return parseFloat(t) || 0;
  }
  static getDimension(e, t, i) {
    let r = SG(e), o = "0";
    return r && (r.getPropertyValue ? o = r.getPropertyValue(t) : o = r.getAttribute(i)), xi.convertToPixels(e, o);
  }
  static getBorderLeftWidth(e) {
    return xi.getDimension(e, "border-left-width", "borderLeftWidth");
  }
  static getBorderRightWidth(e) {
    return xi.getDimension(e, "border-right-width", "borderRightWidth");
  }
  static getBorderTopWidth(e) {
    return xi.getDimension(e, "border-top-width", "borderTopWidth");
  }
  static getBorderBottomWidth(e) {
    return xi.getDimension(e, "border-bottom-width", "borderBottomWidth");
  }
  static getPaddingLeft(e) {
    return xi.getDimension(e, "padding-left", "paddingLeft");
  }
  static getPaddingRight(e) {
    return xi.getDimension(e, "padding-right", "paddingRight");
  }
  static getPaddingTop(e) {
    return xi.getDimension(e, "padding-top", "paddingTop");
  }
  static getPaddingBottom(e) {
    return xi.getDimension(e, "padding-bottom", "paddingBottom");
  }
  static getMarginLeft(e) {
    return xi.getDimension(e, "margin-left", "marginLeft");
  }
  static getMarginTop(e) {
    return xi.getDimension(e, "margin-top", "marginTop");
  }
  static getMarginRight(e) {
    return xi.getDimension(e, "margin-right", "marginRight");
  }
  static getMarginBottom(e) {
    return xi.getDimension(e, "margin-bottom", "marginBottom");
  }
}
class Ua {
  constructor(e, t) {
    this.width = e, this.height = t;
  }
  with(e = this.width, t = this.height) {
    return e !== this.width || t !== this.height ? new Ua(e, t) : this;
  }
  static is(e) {
    return typeof e == "object" && typeof e.height == "number" && typeof e.width == "number";
  }
  static lift(e) {
    return e instanceof Ua ? e : new Ua(e.width, e.height);
  }
  static equals(e, t) {
    return e === t ? !0 : !e || !t ? !1 : e.width === t.width && e.height === t.height;
  }
}
function Gne(n) {
  let e = n.offsetParent, t = n.offsetTop, i = n.offsetLeft;
  for (; (n = n.parentNode) !== null && n !== document.body && n !== document.documentElement; ) {
    t -= n.scrollTop;
    const r = DG(n) ? null : SG(n);
    r && (i -= r.direction !== "rtl" ? n.scrollLeft : -n.scrollLeft), n === e && (i += xi.getBorderLeftWidth(n), t += xi.getBorderTopWidth(n), t += n.offsetTop, i += n.offsetLeft, e = n.offsetParent);
  }
  return {
    left: i,
    top: t
  };
}
function uCe(n, e, t) {
  typeof e == "number" && (n.style.width = `${e}px`), typeof t == "number" && (n.style.height = `${t}px`);
}
function ja(n) {
  let e = n.getBoundingClientRect();
  return {
    left: e.left + Bu.scrollX,
    top: e.top + Bu.scrollY,
    width: e.width,
    height: e.height
  };
}
const Bu = new class {
  get scrollX() {
    return typeof window.scrollX == "number" ? window.scrollX : document.body.scrollLeft + document.documentElement.scrollLeft;
  }
  get scrollY() {
    return typeof window.scrollY == "number" ? window.scrollY : document.body.scrollTop + document.documentElement.scrollTop;
  }
}();
function qR(n) {
  let e = xi.getMarginLeft(n) + xi.getMarginRight(n);
  return n.offsetWidth + e;
}
function $L(n) {
  let e = xi.getBorderLeftWidth(n) + xi.getBorderRightWidth(n), t = xi.getPaddingLeft(n) + xi.getPaddingRight(n);
  return n.offsetWidth - e - t;
}
function Une(n) {
  let e = xi.getBorderTopWidth(n) + xi.getBorderBottomWidth(n), t = xi.getPaddingTop(n) + xi.getPaddingBottom(n);
  return n.offsetHeight - e - t;
}
function YR(n) {
  let e = xi.getMarginTop(n) + xi.getMarginBottom(n);
  return n.offsetHeight + e;
}
function Ku(n, e) {
  for (; n; ) {
    if (n === e)
      return !0;
    n = n.parentNode;
  }
  return !1;
}
function LG(n, e, t) {
  for (; n && n.nodeType === n.ELEMENT_NODE; ) {
    if (n.classList.contains(e))
      return n;
    if (t) {
      if (typeof t == "string") {
        if (n.classList.contains(t))
          return null;
      } else if (n === t)
        return null;
    }
    n = n.parentNode;
  }
  return null;
}
function yF(n, e, t) {
  return !!LG(n, e, t);
}
function DG(n) {
  return n && !!n.host && !!n.mode;
}
function dN(n) {
  return !!k_(n);
}
function k_(n) {
  for (; n.parentNode; ) {
    if (n === document.body)
      return null;
    n = n.parentNode;
  }
  return DG(n) ? n : null;
}
function fp() {
  let n = document.activeElement;
  for (; n != null && n.shadowRoot; )
    n = n.shadowRoot.activeElement;
  return n;
}
function Os(n = document.getElementsByTagName("head")[0]) {
  let e = document.createElement("style");
  return e.type = "text/css", e.media = "screen", n.appendChild(e), e;
}
let KL = null;
function RG() {
  return KL || (KL = Os()), KL;
}
function zne(n) {
  var e, t;
  return !((e = n == null ? void 0 : n.sheet) === null || e === void 0) && e.rules ? n.sheet.rules : !((t = n == null ? void 0 : n.sheet) === null || t === void 0) && t.cssRules ? n.sheet.cssRules : [];
}
function wF(n, e, t = RG()) {
  !t || !e || t.sheet.insertRule(n + "{" + e + "}", 0);
}
function TG(n, e = RG()) {
  if (!e)
    return;
  let t = zne(e), i = [];
  for (let r = 0; r < t.length; r++)
    t[r].selectorText.indexOf(n) !== -1 && i.push(r);
  for (let r = i.length - 1; r >= 0; r--)
    e.sheet.deleteRule(i[r]);
}
function OG(n) {
  return typeof HTMLElement == "object" ? n instanceof HTMLElement : n && typeof n == "object" && n.nodeType === 1 && typeof n.nodeName == "string";
}
const Be = {
  // Mouse
  CLICK: "click",
  AUXCLICK: "auxclick",
  DBLCLICK: "dblclick",
  MOUSE_UP: "mouseup",
  MOUSE_DOWN: "mousedown",
  MOUSE_OVER: "mouseover",
  MOUSE_MOVE: "mousemove",
  MOUSE_OUT: "mouseout",
  MOUSE_ENTER: "mouseenter",
  MOUSE_LEAVE: "mouseleave",
  MOUSE_WHEEL: "wheel",
  POINTER_UP: "pointerup",
  POINTER_DOWN: "pointerdown",
  POINTER_MOVE: "pointermove",
  CONTEXT_MENU: "contextmenu",
  WHEEL: "wheel",
  // Keyboard
  KEY_DOWN: "keydown",
  KEY_PRESS: "keypress",
  KEY_UP: "keyup",
  // HTML Document
  LOAD: "load",
  BEFORE_UNLOAD: "beforeunload",
  UNLOAD: "unload",
  ABORT: "abort",
  ERROR: "error",
  RESIZE: "resize",
  SCROLL: "scroll",
  FULLSCREEN_CHANGE: "fullscreenchange",
  WK_FULLSCREEN_CHANGE: "webkitfullscreenchange",
  // Form
  SELECT: "select",
  CHANGE: "change",
  SUBMIT: "submit",
  RESET: "reset",
  FOCUS: "focus",
  FOCUS_IN: "focusin",
  FOCUS_OUT: "focusout",
  BLUR: "blur",
  INPUT: "input",
  // Local Storage
  STORAGE: "storage",
  // Drag
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "drop",
  DRAG_END: "dragend",
  // Animation
  ANIMATION_START: hd ? "webkitAnimationStart" : "animationstart",
  ANIMATION_END: hd ? "webkitAnimationEnd" : "animationend",
  ANIMATION_ITERATION: hd ? "webkitAnimationIteration" : "animationiteration"
}, gi = {
  stop: function(n, e) {
    n.preventDefault ? n.preventDefault() : n.returnValue = !1, e && (n.stopPropagation ? n.stopPropagation() : n.cancelBubble = !0);
  }
};
function jne(n) {
  let e = [];
  for (let t = 0; n && n.nodeType === n.ELEMENT_NODE; t++)
    e[t] = n.scrollTop, n = n.parentNode;
  return e;
}
function $ne(n, e) {
  for (let t = 0; n && n.nodeType === n.ELEMENT_NODE; t++)
    n.scrollTop !== e[t] && (n.scrollTop = e[t]), n = n.parentNode;
}
class Kne extends ge {
  constructor(e) {
    super(), this._onDidFocus = this._register(new j()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new j()), this.onDidBlur = this._onDidBlur.event;
    let t = Ku(document.activeElement, e), i = !1;
    const r = () => {
      i = !1, t || (t = !0, this._onDidFocus.fire());
    }, o = () => {
      t && (i = !0, window.setTimeout(() => {
        i && (i = !1, t = !1, this._onDidBlur.fire());
      }, 0));
    };
    this._refreshStateHandler = () => {
      Ku(document.activeElement, e) !== t && (t ? o() : r());
    }, this._register(yt(e, Be.FOCUS, !0)(r)), this._register(yt(e, Be.BLUR, !0)(o));
  }
}
function $S(n) {
  return new Kne(n);
}
function Ie(n, ...e) {
  if (n.append(...e), e.length === 1 && typeof e[0] != "string")
    return e[0];
}
function KS(n, ...e) {
  n.innerText = "", Ie(n, ...e);
}
const qne = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
var Bv;
(function(n) {
  n.HTML = "http://www.w3.org/1999/xhtml", n.SVG = "http://www.w3.org/2000/svg";
})(Bv || (Bv = {}));
function xG(n, e, t, ...i) {
  let r = qne.exec(e);
  if (!r)
    throw new Error("Bad use of emmet");
  t = Object.assign({}, t || {});
  let o = r[1] || "div", s;
  return n !== Bv.HTML ? s = document.createElementNS(n, o) : s = document.createElement(o), r[3] && (s.id = r[3]), r[4] && (s.className = r[4].replace(/\./g, " ").trim()), Object.keys(t).forEach((a) => {
    const l = t[a];
    typeof l > "u" || (/^on\w+$/.test(a) ? s[a] = l : a === "selected" ? l && s.setAttribute(a, "true") : s.setAttribute(a, l));
  }), s.append(...i), s;
}
function Xe(n, e, ...t) {
  return xG(Bv.HTML, n, e, ...t);
}
Xe.SVG = function(n, e, ...t) {
  return xG(Bv.SVG, n, e, ...t);
};
function NG(...n) {
  for (let e of n)
    e.style.display = "", e.removeAttribute("aria-hidden");
}
function bF(...n) {
  for (let e of n)
    e.style.display = "none", e.setAttribute("aria-hidden", "true");
}
function SF(n) {
  return Array.prototype.slice.call(document.getElementsByTagName(n), 0);
}
function EF(n) {
  const e = window.devicePixelRatio * n;
  return Math.max(1, Math.floor(e)) / window.devicePixelRatio;
}
function IG(n) {
  window.open(n, "_blank", "noopener");
}
function Yne(n) {
  const e = () => {
    n(), t = zl(e);
  };
  let t = zl(e);
  return Ri(() => t.dispose());
}
_G.setPreferredWebSchema(/^https:/.test(window.location.href) ? "https" : "http");
function Hv(n) {
  return n ? `url('${Pne.asBrowserUri(n).toString(!0).replace(/'/g, "%27")}')` : "url('')";
}
function LF(n) {
  return `'${n.replace(/'/g, "%27")}'`;
}
class $f extends j {
  constructor() {
    super(), this._subscriptions = new ht(), this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    }, this._subscriptions.add(yt(window, "keydown", !0)((e) => {
      if (e.defaultPrevented)
        return;
      const t = new Ki(e);
      if (!(t.keyCode === 6 && e.repeat)) {
        if (e.altKey && !this._keyStatus.altKey)
          this._keyStatus.lastKeyPressed = "alt";
        else if (e.ctrlKey && !this._keyStatus.ctrlKey)
          this._keyStatus.lastKeyPressed = "ctrl";
        else if (e.metaKey && !this._keyStatus.metaKey)
          this._keyStatus.lastKeyPressed = "meta";
        else if (e.shiftKey && !this._keyStatus.shiftKey)
          this._keyStatus.lastKeyPressed = "shift";
        else if (t.keyCode !== 6)
          this._keyStatus.lastKeyPressed = void 0;
        else
          return;
        this._keyStatus.altKey = e.altKey, this._keyStatus.ctrlKey = e.ctrlKey, this._keyStatus.metaKey = e.metaKey, this._keyStatus.shiftKey = e.shiftKey, this._keyStatus.lastKeyPressed && (this._keyStatus.event = e, this.fire(this._keyStatus));
      }
    })), this._subscriptions.add(yt(window, "keyup", !0)((e) => {
      e.defaultPrevented || (!e.altKey && this._keyStatus.altKey ? this._keyStatus.lastKeyReleased = "alt" : !e.ctrlKey && this._keyStatus.ctrlKey ? this._keyStatus.lastKeyReleased = "ctrl" : !e.metaKey && this._keyStatus.metaKey ? this._keyStatus.lastKeyReleased = "meta" : !e.shiftKey && this._keyStatus.shiftKey ? this._keyStatus.lastKeyReleased = "shift" : this._keyStatus.lastKeyReleased = void 0, this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased && (this._keyStatus.lastKeyPressed = void 0), this._keyStatus.altKey = e.altKey, this._keyStatus.ctrlKey = e.ctrlKey, this._keyStatus.metaKey = e.metaKey, this._keyStatus.shiftKey = e.shiftKey, this._keyStatus.lastKeyReleased && (this._keyStatus.event = e, this.fire(this._keyStatus)));
    })), this._subscriptions.add(yt(document.body, "mousedown", !0)((e) => {
      this._keyStatus.lastKeyPressed = void 0;
    })), this._subscriptions.add(yt(document.body, "mouseup", !0)((e) => {
      this._keyStatus.lastKeyPressed = void 0;
    })), this._subscriptions.add(yt(document.body, "mousemove", !0)((e) => {
      e.buttons && (this._keyStatus.lastKeyPressed = void 0);
    })), this._subscriptions.add(yt(window, "blur")((e) => {
      this.resetKeyStatus();
    }));
  }
  get keyStatus() {
    return this._keyStatus;
  }
  /**
   * Allows to explicitly reset the key status based on more knowledge (#109062)
   */
  resetKeyStatus() {
    this.doResetKeyStatus(), this.fire(this._keyStatus);
  }
  doResetKeyStatus() {
    this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    };
  }
  static getInstance() {
    return $f.instance || ($f.instance = new $f()), $f.instance;
  }
  dispose() {
    super.dispose(), this._subscriptions.dispose();
  }
}
function Xne(n, e) {
  const t = window.matchMedia(n);
  typeof t.addEventListener == "function" ? t.addEventListener("change", e) : t.addListener(e);
}
function Zne(n) {
  return !n || typeof n != "string" ? !0 : n.trim().length === 0;
}
const Qne = /{(\d+)}/g;
function xl(n, ...e) {
  return e.length === 0 ? n : n.replace(Qne, function(t, i) {
    const r = parseInt(i, 10);
    return isNaN(r) || r < 0 || r >= e.length ? t : e[r];
  });
}
function PG(n) {
  return n.replace(/[<>&]/g, function(e) {
    switch (e) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      default:
        return e;
    }
  });
}
function Bp(n) {
  return n.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function cCe(n, e = " ") {
  const t = fN(n, e);
  return AG(t, e);
}
function fN(n, e) {
  if (!n || !e)
    return n;
  const t = e.length;
  if (t === 0 || n.length === 0)
    return n;
  let i = 0;
  for (; n.indexOf(e, i) === i; )
    i = i + t;
  return n.substring(i);
}
function AG(n, e) {
  if (!n || !e)
    return n;
  const t = e.length, i = n.length;
  if (t === 0 || i === 0)
    return n;
  let r = i, o = -1;
  for (; o = n.lastIndexOf(e, r - 1), !(o === -1 || o + t !== r); ) {
    if (o === 0)
      return "";
    r = o;
  }
  return n.substring(0, r);
}
function Jne(n) {
  return n.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
}
function hCe(n) {
  return n.replace(/\*/g, "");
}
function MG(n, e, t = {}) {
  if (!n)
    throw new Error("Cannot create regex from empty string");
  e || (n = Bp(n)), t.wholeWord && (/\B/.test(n.charAt(0)) || (n = "\\b" + n), /\B/.test(n.charAt(n.length - 1)) || (n = n + "\\b"));
  let i = "";
  return t.global && (i += "g"), t.matchCase || (i += "i"), t.multiline && (i += "m"), t.unicode && (i += "u"), new RegExp(n, i);
}
function ere(n) {
  return n.source === "^" || n.source === "^$" || n.source === "$" || n.source === "^\\s*$" ? !1 : !!(n.exec("") && n.lastIndex === 0);
}
function qL(n) {
  return (n.global ? "g" : "") + (n.ignoreCase ? "i" : "") + (n.multiline ? "m" : "") + (n.unicode ? "u" : "");
}
function W_(n) {
  return n.split(/\r\n|\r|\n/);
}
function Es(n) {
  for (let e = 0, t = n.length; e < t; e++) {
    const i = n.charCodeAt(e);
    if (i !== 32 && i !== 9)
      return e;
  }
  return -1;
}
function Pr(n, e = 0, t = n.length) {
  for (let i = e; i < t; i++) {
    const r = n.charCodeAt(i);
    if (r !== 32 && r !== 9)
      return n.substring(e, i);
  }
  return n.substring(e, t);
}
function wg(n, e = n.length - 1) {
  for (let t = e; t >= 0; t--) {
    const i = n.charCodeAt(t);
    if (i !== 32 && i !== 9)
      return t;
  }
  return -1;
}
function XR(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
function pN(n, e, t = 0, i = n.length, r = 0, o = e.length) {
  for (; t < i && r < o; t++, r++) {
    let l = n.charCodeAt(t), u = e.charCodeAt(r);
    if (l < u)
      return -1;
    if (l > u)
      return 1;
  }
  const s = i - t, a = o - r;
  return s < a ? -1 : s > a ? 1 : 0;
}
function DF(n, e) {
  return gN(n, e, 0, n.length, 0, e.length);
}
function gN(n, e, t = 0, i = n.length, r = 0, o = e.length) {
  for (; t < i && r < o; t++, r++) {
    let l = n.charCodeAt(t), u = e.charCodeAt(r);
    if (l === u)
      continue;
    const c = l - u;
    if (!(c === 32 && Eu(u)) && !(c === -32 && Eu(l)))
      return Jh(l) && Jh(u) ? c : pN(n.toLowerCase(), e.toLowerCase(), t, i, r, o);
  }
  const s = i - t, a = o - r;
  return s < a ? -1 : s > a ? 1 : 0;
}
function Jh(n) {
  return n >= 97 && n <= 122;
}
function Eu(n) {
  return n >= 65 && n <= 90;
}
function RF(n) {
  return Jh(n) || Eu(n);
}
function Hm(n, e) {
  return n.length === e.length && FG(n, e);
}
function FG(n, e, t = n.length) {
  for (let i = 0; i < t; i++) {
    const r = n.charCodeAt(i), o = e.charCodeAt(i);
    if (r !== o) {
      if (RF(r) && RF(o)) {
        const s = Math.abs(r - o);
        if (s !== 0 && s !== 32)
          return !1;
      } else if (String.fromCharCode(r).toLowerCase() !== String.fromCharCode(o).toLowerCase())
        return !1;
    }
  }
  return !0;
}
function mN(n, e) {
  const t = e.length;
  return e.length > n.length ? !1 : FG(n, e, t);
}
function TF(n, e) {
  let t, i = Math.min(n.length, e.length);
  for (t = 0; t < i; t++)
    if (n.charCodeAt(t) !== e.charCodeAt(t))
      return t;
  return i;
}
function OF(n, e) {
  let t, i = Math.min(n.length, e.length);
  const r = n.length - 1, o = e.length - 1;
  for (t = 0; t < i; t++)
    if (n.charCodeAt(r - t) !== e.charCodeAt(o - t))
      return t;
  return i;
}
function jn(n) {
  return 55296 <= n && n <= 56319;
}
function Gv(n) {
  return 56320 <= n && n <= 57343;
}
function vN(n, e) {
  return (n - 55296 << 10) + (e - 56320) + 65536;
}
function Lu(n, e, t) {
  const i = n.charCodeAt(t);
  if (jn(i) && t + 1 < e) {
    const r = n.charCodeAt(t + 1);
    if (Gv(r))
      return vN(i, r);
  }
  return i;
}
function pp(n, e) {
  const t = n.charCodeAt(e - 1);
  if (Gv(t) && e > 1) {
    const i = n.charCodeAt(e - 2);
    if (jn(i))
      return vN(i, t);
  }
  return t;
}
function ob(n, e) {
  const t = ku.getInstance(), i = e, r = n.length, o = Lu(n, r, e);
  e += o >= 65536 ? 2 : 1;
  let s = t.getGraphemeBreakType(o);
  for (; e < r; ) {
    const a = Lu(n, r, e), l = t.getGraphemeBreakType(a);
    if (rv(s, l))
      break;
    e += a >= 65536 ? 2 : 1, s = l;
  }
  return e - i;
}
function tre(n, e) {
  const t = ku.getInstance(), i = e, r = pp(n, e);
  e -= r >= 65536 ? 2 : 1;
  let o = t.getGraphemeBreakType(r);
  for (; e > 0; ) {
    const s = pp(n, e), a = t.getGraphemeBreakType(s);
    if (rv(a, o))
      break;
    e -= s >= 65536 ? 2 : 1, o = a;
  }
  return i - e;
}
function ire(n) {
  const e = n.byteLength, t = [];
  let i = 0;
  for (; i < e; ) {
    const r = n[i];
    let o;
    if (r >= 240 && i + 3 < e ? o = (n[i++] & 7) << 18 >>> 0 | (n[i++] & 63) << 12 >>> 0 | (n[i++] & 63) << 6 >>> 0 | (n[i++] & 63) << 0 >>> 0 : r >= 224 && i + 2 < e ? o = (n[i++] & 15) << 12 >>> 0 | (n[i++] & 63) << 6 >>> 0 | (n[i++] & 63) << 0 >>> 0 : r >= 192 && i + 1 < e ? o = (n[i++] & 31) << 6 >>> 0 | (n[i++] & 63) << 0 >>> 0 : o = n[i++], o >= 0 && o <= 55295 || o >= 57344 && o <= 65535)
      t.push(String.fromCharCode(o));
    else if (o >= 65536 && o <= 1114111) {
      const s = o - 65536, a = 55296 + ((s & 1047552) >>> 10), l = 56320 + ((s & 1023) >>> 0);
      t.push(String.fromCharCode(a)), t.push(String.fromCharCode(l));
    } else
      t.push(String.fromCharCode(65533));
  }
  return t.join("");
}
const nre = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
function _N(n) {
  return nre.test(n);
}
const rre = /(?:[\u231A\u231B\u23F0\u23F3\u2600-\u27BF\u2B50\u2B55]|\uD83C[\uDDE6-\uDDFF\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F\uDE80-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD00-\uDDFF\uDE70-\uDED6])/;
function ore(n) {
  return rre.test(n);
}
const sre = /^[\t\n\r\x20-\x7E]*$/;
function kG(n) {
  return sre.test(n);
}
const WG = /[\u2028\u2029]/;
function VG(n) {
  return WG.test(n);
}
function are(n) {
  for (let e = 0, t = n.length; e < t; e++)
    if (Xa(n.charCodeAt(e)))
      return !0;
  return !1;
}
function Xa(n) {
  return n = +n, n >= 11904 && n <= 55215 || n >= 63744 && n <= 64255 || n >= 65281 && n <= 65374;
}
function nv(n) {
  return n >= 127462 && n <= 127487 || n === 8986 || n === 8987 || n === 9200 || n === 9203 || n >= 9728 && n <= 10175 || n === 11088 || n === 11093 || n >= 127744 && n <= 128591 || n >= 128640 && n <= 128764 || n >= 128992 && n <= 129003 || n >= 129280 && n <= 129535 || n >= 129648 && n <= 129750;
}
const lre = String.fromCharCode(
  65279
  /* UTF8_BOM */
);
function CN(n) {
  return !!(n && n.length > 0 && n.charCodeAt(0) === 65279);
}
function dCe(n, e = !1) {
  return n ? (e && (n = n.replace(/\\./g, "")), n.toLowerCase() !== n) : !1;
}
function BG(n) {
  return n = n % (2 * 26), n < 26 ? String.fromCharCode(97 + n) : String.fromCharCode(65 + n - 26);
}
function Sf(n) {
  return ku.getInstance().getGraphemeBreakType(n);
}
function rv(n, e) {
  return n === 0 ? e !== 5 && e !== 7 : n === 2 && e === 3 ? !1 : n === 4 || n === 2 || n === 3 || e === 4 || e === 2 || e === 3 ? !0 : !(n === 8 && (e === 8 || e === 9 || e === 11 || e === 12) || (n === 11 || n === 9) && (e === 9 || e === 10) || (n === 12 || n === 10) && e === 10 || e === 5 || e === 13 || e === 7 || n === 1 || n === 13 && e === 14 || n === 6 && e === 6);
}
class ku {
  constructor() {
    this._data = ure();
  }
  static getInstance() {
    return ku._INSTANCE || (ku._INSTANCE = new ku()), ku._INSTANCE;
  }
  getGraphemeBreakType(e) {
    if (e < 32)
      return e === 10 ? 3 : e === 13 ? 2 : 4;
    if (e < 127)
      return 0;
    const t = this._data, i = t.length / 3;
    let r = 1;
    for (; r <= i; )
      if (e < t[3 * r])
        r = 2 * r;
      else if (e > t[3 * r + 1])
        r = 2 * r + 1;
      else
        return t[3 * r + 2];
    return 0;
  }
}
ku._INSTANCE = null;
function ure() {
  return JSON.parse("[0,0,0,51592,51592,11,44424,44424,11,72251,72254,5,7150,7150,7,48008,48008,11,55176,55176,11,128420,128420,14,3276,3277,5,9979,9980,14,46216,46216,11,49800,49800,11,53384,53384,11,70726,70726,5,122915,122916,5,129320,129327,14,2558,2558,5,5906,5908,5,9762,9763,14,43360,43388,8,45320,45320,11,47112,47112,11,48904,48904,11,50696,50696,11,52488,52488,11,54280,54280,11,70082,70083,1,71350,71350,7,73111,73111,5,127892,127893,14,128726,128727,14,129473,129474,14,2027,2035,5,2901,2902,5,3784,3789,5,6754,6754,5,8418,8420,5,9877,9877,14,11088,11088,14,44008,44008,5,44872,44872,11,45768,45768,11,46664,46664,11,47560,47560,11,48456,48456,11,49352,49352,11,50248,50248,11,51144,51144,11,52040,52040,11,52936,52936,11,53832,53832,11,54728,54728,11,69811,69814,5,70459,70460,5,71096,71099,7,71998,71998,5,72874,72880,5,119149,119149,7,127374,127374,14,128335,128335,14,128482,128482,14,128765,128767,14,129399,129400,14,129680,129685,14,1476,1477,5,2377,2380,7,2759,2760,5,3137,3140,7,3458,3459,7,4153,4154,5,6432,6434,5,6978,6978,5,7675,7679,5,9723,9726,14,9823,9823,14,9919,9923,14,10035,10036,14,42736,42737,5,43596,43596,5,44200,44200,11,44648,44648,11,45096,45096,11,45544,45544,11,45992,45992,11,46440,46440,11,46888,46888,11,47336,47336,11,47784,47784,11,48232,48232,11,48680,48680,11,49128,49128,11,49576,49576,11,50024,50024,11,50472,50472,11,50920,50920,11,51368,51368,11,51816,51816,11,52264,52264,11,52712,52712,11,53160,53160,11,53608,53608,11,54056,54056,11,54504,54504,11,54952,54952,11,68108,68111,5,69933,69940,5,70197,70197,7,70498,70499,7,70845,70845,5,71229,71229,5,71727,71735,5,72154,72155,5,72344,72345,5,73023,73029,5,94095,94098,5,121403,121452,5,126981,127182,14,127538,127546,14,127990,127990,14,128391,128391,14,128445,128449,14,128500,128505,14,128752,128752,14,129160,129167,14,129356,129356,14,129432,129442,14,129648,129651,14,129751,131069,14,173,173,4,1757,1757,1,2274,2274,1,2494,2494,5,2641,2641,5,2876,2876,5,3014,3016,7,3262,3262,7,3393,3396,5,3570,3571,7,3968,3972,5,4228,4228,7,6086,6086,5,6679,6680,5,6912,6915,5,7080,7081,5,7380,7392,5,8252,8252,14,9096,9096,14,9748,9749,14,9784,9786,14,9833,9850,14,9890,9894,14,9938,9938,14,9999,9999,14,10085,10087,14,12349,12349,14,43136,43137,7,43454,43456,7,43755,43755,7,44088,44088,11,44312,44312,11,44536,44536,11,44760,44760,11,44984,44984,11,45208,45208,11,45432,45432,11,45656,45656,11,45880,45880,11,46104,46104,11,46328,46328,11,46552,46552,11,46776,46776,11,47000,47000,11,47224,47224,11,47448,47448,11,47672,47672,11,47896,47896,11,48120,48120,11,48344,48344,11,48568,48568,11,48792,48792,11,49016,49016,11,49240,49240,11,49464,49464,11,49688,49688,11,49912,49912,11,50136,50136,11,50360,50360,11,50584,50584,11,50808,50808,11,51032,51032,11,51256,51256,11,51480,51480,11,51704,51704,11,51928,51928,11,52152,52152,11,52376,52376,11,52600,52600,11,52824,52824,11,53048,53048,11,53272,53272,11,53496,53496,11,53720,53720,11,53944,53944,11,54168,54168,11,54392,54392,11,54616,54616,11,54840,54840,11,55064,55064,11,65438,65439,5,69633,69633,5,69837,69837,1,70018,70018,7,70188,70190,7,70368,70370,7,70465,70468,7,70712,70719,5,70835,70840,5,70850,70851,5,71132,71133,5,71340,71340,7,71458,71461,5,71985,71989,7,72002,72002,7,72193,72202,5,72281,72283,5,72766,72766,7,72885,72886,5,73104,73105,5,92912,92916,5,113824,113827,4,119173,119179,5,121505,121519,5,125136,125142,5,127279,127279,14,127489,127490,14,127570,127743,14,127900,127901,14,128254,128254,14,128369,128370,14,128400,128400,14,128425,128432,14,128468,128475,14,128489,128494,14,128715,128720,14,128745,128745,14,128759,128760,14,129004,129023,14,129296,129304,14,129340,129342,14,129388,129392,14,129404,129407,14,129454,129455,14,129485,129487,14,129659,129663,14,129719,129727,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2363,2363,7,2402,2403,5,2507,2508,7,2622,2624,7,2691,2691,7,2786,2787,5,2881,2884,5,3006,3006,5,3072,3072,5,3170,3171,5,3267,3268,7,3330,3331,7,3406,3406,1,3538,3540,5,3655,3662,5,3897,3897,5,4038,4038,5,4184,4185,5,4352,4447,8,6068,6069,5,6155,6157,5,6448,6449,7,6742,6742,5,6783,6783,5,6966,6970,5,7042,7042,7,7143,7143,7,7212,7219,5,7412,7412,5,8206,8207,4,8294,8303,4,8596,8601,14,9410,9410,14,9742,9742,14,9757,9757,14,9770,9770,14,9794,9794,14,9828,9828,14,9855,9855,14,9882,9882,14,9900,9903,14,9929,9933,14,9963,9967,14,9987,9988,14,10006,10006,14,10062,10062,14,10175,10175,14,11744,11775,5,42607,42607,5,43043,43044,7,43263,43263,5,43444,43445,7,43569,43570,5,43698,43700,5,43766,43766,5,44032,44032,11,44144,44144,11,44256,44256,11,44368,44368,11,44480,44480,11,44592,44592,11,44704,44704,11,44816,44816,11,44928,44928,11,45040,45040,11,45152,45152,11,45264,45264,11,45376,45376,11,45488,45488,11,45600,45600,11,45712,45712,11,45824,45824,11,45936,45936,11,46048,46048,11,46160,46160,11,46272,46272,11,46384,46384,11,46496,46496,11,46608,46608,11,46720,46720,11,46832,46832,11,46944,46944,11,47056,47056,11,47168,47168,11,47280,47280,11,47392,47392,11,47504,47504,11,47616,47616,11,47728,47728,11,47840,47840,11,47952,47952,11,48064,48064,11,48176,48176,11,48288,48288,11,48400,48400,11,48512,48512,11,48624,48624,11,48736,48736,11,48848,48848,11,48960,48960,11,49072,49072,11,49184,49184,11,49296,49296,11,49408,49408,11,49520,49520,11,49632,49632,11,49744,49744,11,49856,49856,11,49968,49968,11,50080,50080,11,50192,50192,11,50304,50304,11,50416,50416,11,50528,50528,11,50640,50640,11,50752,50752,11,50864,50864,11,50976,50976,11,51088,51088,11,51200,51200,11,51312,51312,11,51424,51424,11,51536,51536,11,51648,51648,11,51760,51760,11,51872,51872,11,51984,51984,11,52096,52096,11,52208,52208,11,52320,52320,11,52432,52432,11,52544,52544,11,52656,52656,11,52768,52768,11,52880,52880,11,52992,52992,11,53104,53104,11,53216,53216,11,53328,53328,11,53440,53440,11,53552,53552,11,53664,53664,11,53776,53776,11,53888,53888,11,54000,54000,11,54112,54112,11,54224,54224,11,54336,54336,11,54448,54448,11,54560,54560,11,54672,54672,11,54784,54784,11,54896,54896,11,55008,55008,11,55120,55120,11,64286,64286,5,66272,66272,5,68900,68903,5,69762,69762,7,69817,69818,5,69927,69931,5,70003,70003,5,70070,70078,5,70094,70094,7,70194,70195,7,70206,70206,5,70400,70401,5,70463,70463,7,70475,70477,7,70512,70516,5,70722,70724,5,70832,70832,5,70842,70842,5,70847,70848,5,71088,71089,7,71102,71102,7,71219,71226,5,71231,71232,5,71342,71343,7,71453,71455,5,71463,71467,5,71737,71738,5,71995,71996,5,72000,72000,7,72145,72147,7,72160,72160,5,72249,72249,7,72273,72278,5,72330,72342,5,72752,72758,5,72850,72871,5,72882,72883,5,73018,73018,5,73031,73031,5,73109,73109,5,73461,73462,7,94031,94031,5,94192,94193,7,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,126976,126979,14,127184,127231,14,127344,127345,14,127405,127461,14,127514,127514,14,127561,127567,14,127778,127779,14,127896,127896,14,127985,127986,14,127995,127999,5,128326,128328,14,128360,128366,14,128378,128378,14,128394,128397,14,128405,128406,14,128422,128423,14,128435,128443,14,128453,128464,14,128479,128480,14,128484,128487,14,128496,128498,14,128640,128709,14,128723,128724,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129096,129103,14,129292,129292,14,129311,129311,14,129329,129330,14,129344,129349,14,129360,129374,14,129394,129394,14,129402,129402,14,129413,129425,14,129445,129450,14,129466,129471,14,129483,129483,14,129511,129535,14,129653,129655,14,129667,129670,14,129705,129711,14,129731,129743,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2307,2307,7,2366,2368,7,2382,2383,7,2434,2435,7,2497,2500,5,2519,2519,5,2563,2563,7,2631,2632,5,2677,2677,5,2750,2752,7,2763,2764,7,2817,2817,5,2879,2879,5,2891,2892,7,2914,2915,5,3008,3008,5,3021,3021,5,3076,3076,5,3146,3149,5,3202,3203,7,3264,3265,7,3271,3272,7,3298,3299,5,3390,3390,5,3402,3404,7,3426,3427,5,3535,3535,5,3544,3550,7,3635,3635,7,3763,3763,7,3893,3893,5,3953,3966,5,3981,3991,5,4145,4145,7,4157,4158,5,4209,4212,5,4237,4237,5,4520,4607,10,5970,5971,5,6071,6077,5,6089,6099,5,6277,6278,5,6439,6440,5,6451,6456,7,6683,6683,5,6744,6750,5,6765,6770,7,6846,6846,5,6964,6964,5,6972,6972,5,7019,7027,5,7074,7077,5,7083,7085,5,7146,7148,7,7154,7155,7,7222,7223,5,7394,7400,5,7416,7417,5,8204,8204,5,8233,8233,4,8288,8292,4,8413,8416,5,8482,8482,14,8986,8987,14,9193,9203,14,9654,9654,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9775,14,9792,9792,14,9800,9811,14,9825,9826,14,9831,9831,14,9852,9853,14,9872,9873,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9936,9936,14,9941,9960,14,9974,9974,14,9982,9985,14,9992,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10145,10145,14,11013,11015,14,11503,11505,5,12334,12335,5,12951,12951,14,42612,42621,5,43014,43014,5,43047,43047,7,43204,43205,5,43335,43345,5,43395,43395,7,43450,43451,7,43561,43566,5,43573,43574,5,43644,43644,5,43710,43711,5,43758,43759,7,44005,44005,5,44012,44012,7,44060,44060,11,44116,44116,11,44172,44172,11,44228,44228,11,44284,44284,11,44340,44340,11,44396,44396,11,44452,44452,11,44508,44508,11,44564,44564,11,44620,44620,11,44676,44676,11,44732,44732,11,44788,44788,11,44844,44844,11,44900,44900,11,44956,44956,11,45012,45012,11,45068,45068,11,45124,45124,11,45180,45180,11,45236,45236,11,45292,45292,11,45348,45348,11,45404,45404,11,45460,45460,11,45516,45516,11,45572,45572,11,45628,45628,11,45684,45684,11,45740,45740,11,45796,45796,11,45852,45852,11,45908,45908,11,45964,45964,11,46020,46020,11,46076,46076,11,46132,46132,11,46188,46188,11,46244,46244,11,46300,46300,11,46356,46356,11,46412,46412,11,46468,46468,11,46524,46524,11,46580,46580,11,46636,46636,11,46692,46692,11,46748,46748,11,46804,46804,11,46860,46860,11,46916,46916,11,46972,46972,11,47028,47028,11,47084,47084,11,47140,47140,11,47196,47196,11,47252,47252,11,47308,47308,11,47364,47364,11,47420,47420,11,47476,47476,11,47532,47532,11,47588,47588,11,47644,47644,11,47700,47700,11,47756,47756,11,47812,47812,11,47868,47868,11,47924,47924,11,47980,47980,11,48036,48036,11,48092,48092,11,48148,48148,11,48204,48204,11,48260,48260,11,48316,48316,11,48372,48372,11,48428,48428,11,48484,48484,11,48540,48540,11,48596,48596,11,48652,48652,11,48708,48708,11,48764,48764,11,48820,48820,11,48876,48876,11,48932,48932,11,48988,48988,11,49044,49044,11,49100,49100,11,49156,49156,11,49212,49212,11,49268,49268,11,49324,49324,11,49380,49380,11,49436,49436,11,49492,49492,11,49548,49548,11,49604,49604,11,49660,49660,11,49716,49716,11,49772,49772,11,49828,49828,11,49884,49884,11,49940,49940,11,49996,49996,11,50052,50052,11,50108,50108,11,50164,50164,11,50220,50220,11,50276,50276,11,50332,50332,11,50388,50388,11,50444,50444,11,50500,50500,11,50556,50556,11,50612,50612,11,50668,50668,11,50724,50724,11,50780,50780,11,50836,50836,11,50892,50892,11,50948,50948,11,51004,51004,11,51060,51060,11,51116,51116,11,51172,51172,11,51228,51228,11,51284,51284,11,51340,51340,11,51396,51396,11,51452,51452,11,51508,51508,11,51564,51564,11,51620,51620,11,51676,51676,11,51732,51732,11,51788,51788,11,51844,51844,11,51900,51900,11,51956,51956,11,52012,52012,11,52068,52068,11,52124,52124,11,52180,52180,11,52236,52236,11,52292,52292,11,52348,52348,11,52404,52404,11,52460,52460,11,52516,52516,11,52572,52572,11,52628,52628,11,52684,52684,11,52740,52740,11,52796,52796,11,52852,52852,11,52908,52908,11,52964,52964,11,53020,53020,11,53076,53076,11,53132,53132,11,53188,53188,11,53244,53244,11,53300,53300,11,53356,53356,11,53412,53412,11,53468,53468,11,53524,53524,11,53580,53580,11,53636,53636,11,53692,53692,11,53748,53748,11,53804,53804,11,53860,53860,11,53916,53916,11,53972,53972,11,54028,54028,11,54084,54084,11,54140,54140,11,54196,54196,11,54252,54252,11,54308,54308,11,54364,54364,11,54420,54420,11,54476,54476,11,54532,54532,11,54588,54588,11,54644,54644,11,54700,54700,11,54756,54756,11,54812,54812,11,54868,54868,11,54924,54924,11,54980,54980,11,55036,55036,11,55092,55092,11,55148,55148,11,55216,55238,9,65056,65071,5,65529,65531,4,68097,68099,5,68159,68159,5,69446,69456,5,69688,69702,5,69808,69810,7,69815,69816,7,69821,69821,1,69888,69890,5,69932,69932,7,69957,69958,7,70016,70017,5,70067,70069,7,70079,70080,7,70089,70092,5,70095,70095,5,70191,70193,5,70196,70196,5,70198,70199,5,70367,70367,5,70371,70378,5,70402,70403,7,70462,70462,5,70464,70464,5,70471,70472,7,70487,70487,5,70502,70508,5,70709,70711,7,70720,70721,7,70725,70725,7,70750,70750,5,70833,70834,7,70841,70841,7,70843,70844,7,70846,70846,7,70849,70849,7,71087,71087,5,71090,71093,5,71100,71101,5,71103,71104,5,71216,71218,7,71227,71228,7,71230,71230,7,71339,71339,5,71341,71341,5,71344,71349,5,71351,71351,5,71456,71457,7,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123628,123631,5,125252,125258,5,126980,126980,14,127183,127183,14,127245,127247,14,127340,127343,14,127358,127359,14,127377,127386,14,127462,127487,6,127491,127503,14,127535,127535,14,127548,127551,14,127568,127569,14,127744,127777,14,127780,127891,14,127894,127895,14,127897,127899,14,127902,127984,14,127987,127989,14,127991,127994,14,128000,128253,14,128255,128317,14,128329,128334,14,128336,128359,14,128367,128368,14,128371,128377,14,128379,128390,14,128392,128393,14,128398,128399,14,128401,128404,14,128407,128419,14,128421,128421,14,128424,128424,14,128433,128434,14,128444,128444,14,128450,128452,14,128465,128467,14,128476,128478,14,128481,128481,14,128483,128483,14,128488,128488,14,128495,128495,14,128499,128499,14,128506,128591,14,128710,128714,14,128721,128722,14,128725,128725,14,128728,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129664,129666,14,129671,129679,14,129686,129704,14,129712,129718,14,129728,129730,14,129744,129750,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2259,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3134,3136,5,3142,3144,5,3157,3158,5,3201,3201,5,3260,3260,5,3263,3263,5,3266,3266,5,3270,3270,5,3274,3275,7,3285,3286,5,3328,3329,5,3387,3388,5,3391,3392,7,3398,3400,7,3405,3405,5,3415,3415,5,3457,3457,5,3530,3530,5,3536,3537,7,3542,3542,5,3551,3551,5,3633,3633,5,3636,3642,5,3761,3761,5,3764,3772,5,3864,3865,5,3895,3895,5,3902,3903,7,3967,3967,7,3974,3975,5,3993,4028,5,4141,4144,5,4146,4151,5,4155,4156,7,4182,4183,7,4190,4192,5,4226,4226,5,4229,4230,5,4253,4253,5,4448,4519,9,4957,4959,5,5938,5940,5,6002,6003,5,6070,6070,7,6078,6085,7,6087,6088,7,6109,6109,5,6158,6158,4,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6848,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7673,5,8203,8203,4,8205,8205,13,8232,8232,4,8234,8238,4,8265,8265,14,8293,8293,4,8400,8412,5,8417,8417,5,8421,8432,5,8505,8505,14,8617,8618,14,9000,9000,14,9167,9167,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9776,9783,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9935,14,9937,9937,14,9939,9940,14,9961,9962,14,9968,9973,14,9975,9978,14,9981,9981,14,9986,9986,14,9989,9989,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10084,14,10133,10135,14,10160,10160,14,10548,10549,14,11035,11036,14,11093,11093,14,11647,11647,5,12330,12333,5,12336,12336,14,12441,12442,5,12953,12953,14,42608,42610,5,42654,42655,5,43010,43010,5,43019,43019,5,43045,43046,5,43052,43052,5,43188,43203,7,43232,43249,5,43302,43309,5,43346,43347,7,43392,43394,5,43443,43443,5,43446,43449,5,43452,43453,5,43493,43493,5,43567,43568,7,43571,43572,7,43587,43587,5,43597,43597,7,43696,43696,5,43703,43704,5,43713,43713,5,43756,43757,5,43765,43765,7,44003,44004,7,44006,44007,7,44009,44010,7,44013,44013,5,44033,44059,12,44061,44087,12,44089,44115,12,44117,44143,12,44145,44171,12,44173,44199,12,44201,44227,12,44229,44255,12,44257,44283,12,44285,44311,12,44313,44339,12,44341,44367,12,44369,44395,12,44397,44423,12,44425,44451,12,44453,44479,12,44481,44507,12,44509,44535,12,44537,44563,12,44565,44591,12,44593,44619,12,44621,44647,12,44649,44675,12,44677,44703,12,44705,44731,12,44733,44759,12,44761,44787,12,44789,44815,12,44817,44843,12,44845,44871,12,44873,44899,12,44901,44927,12,44929,44955,12,44957,44983,12,44985,45011,12,45013,45039,12,45041,45067,12,45069,45095,12,45097,45123,12,45125,45151,12,45153,45179,12,45181,45207,12,45209,45235,12,45237,45263,12,45265,45291,12,45293,45319,12,45321,45347,12,45349,45375,12,45377,45403,12,45405,45431,12,45433,45459,12,45461,45487,12,45489,45515,12,45517,45543,12,45545,45571,12,45573,45599,12,45601,45627,12,45629,45655,12,45657,45683,12,45685,45711,12,45713,45739,12,45741,45767,12,45769,45795,12,45797,45823,12,45825,45851,12,45853,45879,12,45881,45907,12,45909,45935,12,45937,45963,12,45965,45991,12,45993,46019,12,46021,46047,12,46049,46075,12,46077,46103,12,46105,46131,12,46133,46159,12,46161,46187,12,46189,46215,12,46217,46243,12,46245,46271,12,46273,46299,12,46301,46327,12,46329,46355,12,46357,46383,12,46385,46411,12,46413,46439,12,46441,46467,12,46469,46495,12,46497,46523,12,46525,46551,12,46553,46579,12,46581,46607,12,46609,46635,12,46637,46663,12,46665,46691,12,46693,46719,12,46721,46747,12,46749,46775,12,46777,46803,12,46805,46831,12,46833,46859,12,46861,46887,12,46889,46915,12,46917,46943,12,46945,46971,12,46973,46999,12,47001,47027,12,47029,47055,12,47057,47083,12,47085,47111,12,47113,47139,12,47141,47167,12,47169,47195,12,47197,47223,12,47225,47251,12,47253,47279,12,47281,47307,12,47309,47335,12,47337,47363,12,47365,47391,12,47393,47419,12,47421,47447,12,47449,47475,12,47477,47503,12,47505,47531,12,47533,47559,12,47561,47587,12,47589,47615,12,47617,47643,12,47645,47671,12,47673,47699,12,47701,47727,12,47729,47755,12,47757,47783,12,47785,47811,12,47813,47839,12,47841,47867,12,47869,47895,12,47897,47923,12,47925,47951,12,47953,47979,12,47981,48007,12,48009,48035,12,48037,48063,12,48065,48091,12,48093,48119,12,48121,48147,12,48149,48175,12,48177,48203,12,48205,48231,12,48233,48259,12,48261,48287,12,48289,48315,12,48317,48343,12,48345,48371,12,48373,48399,12,48401,48427,12,48429,48455,12,48457,48483,12,48485,48511,12,48513,48539,12,48541,48567,12,48569,48595,12,48597,48623,12,48625,48651,12,48653,48679,12,48681,48707,12,48709,48735,12,48737,48763,12,48765,48791,12,48793,48819,12,48821,48847,12,48849,48875,12,48877,48903,12,48905,48931,12,48933,48959,12,48961,48987,12,48989,49015,12,49017,49043,12,49045,49071,12,49073,49099,12,49101,49127,12,49129,49155,12,49157,49183,12,49185,49211,12,49213,49239,12,49241,49267,12,49269,49295,12,49297,49323,12,49325,49351,12,49353,49379,12,49381,49407,12,49409,49435,12,49437,49463,12,49465,49491,12,49493,49519,12,49521,49547,12,49549,49575,12,49577,49603,12,49605,49631,12,49633,49659,12,49661,49687,12,49689,49715,12,49717,49743,12,49745,49771,12,49773,49799,12,49801,49827,12,49829,49855,12,49857,49883,12,49885,49911,12,49913,49939,12,49941,49967,12,49969,49995,12,49997,50023,12,50025,50051,12,50053,50079,12,50081,50107,12,50109,50135,12,50137,50163,12,50165,50191,12,50193,50219,12,50221,50247,12,50249,50275,12,50277,50303,12,50305,50331,12,50333,50359,12,50361,50387,12,50389,50415,12,50417,50443,12,50445,50471,12,50473,50499,12,50501,50527,12,50529,50555,12,50557,50583,12,50585,50611,12,50613,50639,12,50641,50667,12,50669,50695,12,50697,50723,12,50725,50751,12,50753,50779,12,50781,50807,12,50809,50835,12,50837,50863,12,50865,50891,12,50893,50919,12,50921,50947,12,50949,50975,12,50977,51003,12,51005,51031,12,51033,51059,12,51061,51087,12,51089,51115,12,51117,51143,12,51145,51171,12,51173,51199,12,51201,51227,12,51229,51255,12,51257,51283,12,51285,51311,12,51313,51339,12,51341,51367,12,51369,51395,12,51397,51423,12,51425,51451,12,51453,51479,12,51481,51507,12,51509,51535,12,51537,51563,12,51565,51591,12,51593,51619,12,51621,51647,12,51649,51675,12,51677,51703,12,51705,51731,12,51733,51759,12,51761,51787,12,51789,51815,12,51817,51843,12,51845,51871,12,51873,51899,12,51901,51927,12,51929,51955,12,51957,51983,12,51985,52011,12,52013,52039,12,52041,52067,12,52069,52095,12,52097,52123,12,52125,52151,12,52153,52179,12,52181,52207,12,52209,52235,12,52237,52263,12,52265,52291,12,52293,52319,12,52321,52347,12,52349,52375,12,52377,52403,12,52405,52431,12,52433,52459,12,52461,52487,12,52489,52515,12,52517,52543,12,52545,52571,12,52573,52599,12,52601,52627,12,52629,52655,12,52657,52683,12,52685,52711,12,52713,52739,12,52741,52767,12,52769,52795,12,52797,52823,12,52825,52851,12,52853,52879,12,52881,52907,12,52909,52935,12,52937,52963,12,52965,52991,12,52993,53019,12,53021,53047,12,53049,53075,12,53077,53103,12,53105,53131,12,53133,53159,12,53161,53187,12,53189,53215,12,53217,53243,12,53245,53271,12,53273,53299,12,53301,53327,12,53329,53355,12,53357,53383,12,53385,53411,12,53413,53439,12,53441,53467,12,53469,53495,12,53497,53523,12,53525,53551,12,53553,53579,12,53581,53607,12,53609,53635,12,53637,53663,12,53665,53691,12,53693,53719,12,53721,53747,12,53749,53775,12,53777,53803,12,53805,53831,12,53833,53859,12,53861,53887,12,53889,53915,12,53917,53943,12,53945,53971,12,53973,53999,12,54001,54027,12,54029,54055,12,54057,54083,12,54085,54111,12,54113,54139,12,54141,54167,12,54169,54195,12,54197,54223,12,54225,54251,12,54253,54279,12,54281,54307,12,54309,54335,12,54337,54363,12,54365,54391,12,54393,54419,12,54421,54447,12,54449,54475,12,54477,54503,12,54505,54531,12,54533,54559,12,54561,54587,12,54589,54615,12,54617,54643,12,54645,54671,12,54673,54699,12,54701,54727,12,54729,54755,12,54757,54783,12,54785,54811,12,54813,54839,12,54841,54867,12,54869,54895,12,54897,54923,12,54925,54951,12,54953,54979,12,54981,55007,12,55009,55035,12,55037,55063,12,55065,55091,12,55093,55119,12,55121,55147,12,55149,55175,12,55177,55203,12,55243,55291,10,65024,65039,5,65279,65279,4,65520,65528,4,66045,66045,5,66422,66426,5,68101,68102,5,68152,68154,5,68325,68326,5,69291,69292,5,69632,69632,7,69634,69634,7,69759,69761,5]");
}
function cre(n, e) {
  if (n === 0)
    return 0;
  const t = hre(n, e);
  if (t !== void 0)
    return t;
  const i = pp(e, n);
  return n -= Qy(i), n;
}
function hre(n, e) {
  let t = pp(e, n);
  for (n -= Qy(t); dre(t) || t === 65039 || t === 8419; ) {
    if (n === 0)
      return;
    t = pp(e, n), n -= Qy(t);
  }
  if (nv(t)) {
    if (n >= 0) {
      const i = pp(e, n);
      i === 8205 && (n -= Qy(i));
    }
    return n;
  }
}
function Qy(n) {
  return n >= 65536 ? 2 : 1;
}
function dre(n) {
  return 127995 <= n && n <= 127999;
}
var xF, NF;
class fre {
  constructor() {
    this._value = "", this._pos = 0;
  }
  reset(e) {
    return this._value = e, this._pos = 0, this;
  }
  next() {
    return this._pos += 1, this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(e) {
    const t = e.charCodeAt(0), i = this._value.charCodeAt(this._pos);
    return t - i;
  }
  value() {
    return this._value[this._pos];
  }
}
class pre {
  constructor(e = !0) {
    this._caseSensitive = e;
  }
  reset(e) {
    return this._value = e, this._from = 0, this._to = 0, this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._value.length; this._to++)
      if (this._value.charCodeAt(this._to) === 46)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? pN(e, this._value, 0, e.length, this._from, this._to) : gN(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class gre {
  constructor(e = !0, t = !0) {
    this._splitOnBackslash = e, this._caseSensitive = t;
  }
  reset(e) {
    return this._value = e.replace(/\\$|\/$/, ""), this._from = 0, this._to = 0, this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._value.length; this._to++) {
      const t = this._value.charCodeAt(this._to);
      if (t === 47 || this._splitOnBackslash && t === 92)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    }
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? pN(e, this._value, 0, e.length, this._from, this._to) : gN(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class mre {
  constructor(e) {
    this._ignorePathCasing = e, this._states = [], this._stateIdx = 0;
  }
  reset(e) {
    return this._value = e, this._states = [], this._value.scheme && this._states.push(
      1
      /* Scheme */
    ), this._value.authority && this._states.push(
      2
      /* Authority */
    ), this._value.path && (this._pathIterator = new gre(!1, !this._ignorePathCasing(e)), this._pathIterator.reset(e.path), this._pathIterator.value() && this._states.push(
      3
      /* Path */
    )), this._value.query && this._states.push(
      4
      /* Query */
    ), this._value.fragment && this._states.push(
      5
      /* Fragment */
    ), this._stateIdx = 0, this;
  }
  next() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() ? this._pathIterator.next() : this._stateIdx += 1, this;
  }
  hasNext() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(e) {
    if (this._states[this._stateIdx] === 1)
      return DF(e, this._value.scheme);
    if (this._states[this._stateIdx] === 2)
      return DF(e, this._value.authority);
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.cmp(e);
    if (this._states[this._stateIdx] === 4)
      return XR(e, this._value.query);
    if (this._states[this._stateIdx] === 5)
      return XR(e, this._value.fragment);
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === 1)
      return this._value.scheme;
    if (this._states[this._stateIdx] === 2)
      return this._value.authority;
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.value();
    if (this._states[this._stateIdx] === 4)
      return this._value.query;
    if (this._states[this._stateIdx] === 5)
      return this._value.fragment;
    throw new Error();
  }
}
class ly {
  isEmpty() {
    return !this.left && !this.mid && !this.right && !this.value;
  }
}
class ov {
  constructor(e) {
    this._iter = e;
  }
  static forUris(e = () => !1) {
    return new ov(new mre(e));
  }
  static forStrings() {
    return new ov(new fre());
  }
  static forConfigKeys() {
    return new ov(new pre());
  }
  clear() {
    this._root = void 0;
  }
  set(e, t) {
    const i = this._iter.reset(e);
    let r;
    for (this._root || (this._root = new ly(), this._root.segment = i.value()), r = this._root; ; ) {
      const s = i.cmp(r.segment);
      if (s > 0)
        r.left || (r.left = new ly(), r.left.segment = i.value()), r = r.left;
      else if (s < 0)
        r.right || (r.right = new ly(), r.right.segment = i.value()), r = r.right;
      else if (i.hasNext())
        i.next(), r.mid || (r.mid = new ly(), r.mid.segment = i.value()), r = r.mid;
      else
        break;
    }
    const o = r.value;
    return r.value = t, r.key = e, o;
  }
  get(e) {
    var t;
    return (t = this._getNode(e)) === null || t === void 0 ? void 0 : t.value;
  }
  _getNode(e) {
    const t = this._iter.reset(e);
    let i = this._root;
    for (; i; ) {
      const r = t.cmp(i.segment);
      if (r > 0)
        i = i.left;
      else if (r < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), i = i.mid;
      else
        break;
    }
    return i;
  }
  has(e) {
    const t = this._getNode(e);
    return !((t == null ? void 0 : t.value) === void 0 && (t == null ? void 0 : t.mid) === void 0);
  }
  delete(e) {
    return this._delete(e, !1);
  }
  deleteSuperstr(e) {
    return this._delete(e, !0);
  }
  _delete(e, t) {
    const i = this._iter.reset(e), r = [];
    let o = this._root;
    for (; o; ) {
      const s = i.cmp(o.segment);
      if (s > 0)
        r.push([1, o]), o = o.left;
      else if (s < 0)
        r.push([-1, o]), o = o.right;
      else if (i.hasNext())
        i.next(), r.push([0, o]), o = o.mid;
      else {
        for (t ? (o.left = void 0, o.mid = void 0, o.right = void 0) : o.value = void 0; r.length > 0 && o.isEmpty(); ) {
          let [a, l] = r.pop();
          switch (a) {
            case 1:
              l.left = void 0;
              break;
            case 0:
              l.mid = void 0;
              break;
            case -1:
              l.right = void 0;
              break;
          }
          o = l;
        }
        break;
      }
    }
  }
  findSubstr(e) {
    const t = this._iter.reset(e);
    let i = this._root, r;
    for (; i; ) {
      const o = t.cmp(i.segment);
      if (o > 0)
        i = i.left;
      else if (o < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), r = i.value || r, i = i.mid;
      else
        break;
    }
    return i && i.value || r;
  }
  findSuperstr(e) {
    const t = this._iter.reset(e);
    let i = this._root;
    for (; i; ) {
      const r = t.cmp(i.segment);
      if (r > 0)
        i = i.left;
      else if (r < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), i = i.mid;
      else
        return i.mid ? this._entries(i.mid) : void 0;
    }
  }
  forEach(e) {
    for (const [t, i] of this)
      e(i, t);
  }
  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }
  *_entries(e, t = 0) {
    if (t > 5e3) {
      console.log("potential CYCLE detected", new Error().stack);
      return;
    }
    e && (yield* this._entries(e.left, t++), e.value && (yield [e.key, e.value]), yield* this._entries(e.mid, t++), yield* this._entries(e.right, t++));
  }
}
class yo {
  constructor(e, t) {
    this[xF] = "ResourceMap", e instanceof yo ? (this.map = new Map(e.map), this.toKey = t ?? yo.defaultToKey) : (this.map = /* @__PURE__ */ new Map(), this.toKey = e ?? yo.defaultToKey);
  }
  set(e, t) {
    return this.map.set(this.toKey(e), t), this;
  }
  get(e) {
    return this.map.get(this.toKey(e));
  }
  has(e) {
    return this.map.has(this.toKey(e));
  }
  get size() {
    return this.map.size;
  }
  clear() {
    this.map.clear();
  }
  delete(e) {
    return this.map.delete(this.toKey(e));
  }
  forEach(e, t) {
    typeof t < "u" && (e = e.bind(t));
    for (let [i, r] of this.map)
      e(r, dt.parse(i), this);
  }
  values() {
    return this.map.values();
  }
  *keys() {
    for (let e of this.map.keys())
      yield dt.parse(e);
  }
  *entries() {
    for (let e of this.map.entries())
      yield [dt.parse(e[0]), e[1]];
  }
  *[(xF = Symbol.toStringTag, Symbol.iterator)]() {
    for (let e of this.map)
      yield [dt.parse(e[0]), e[1]];
  }
}
yo.defaultToKey = (n) => n.toString();
class vre {
  constructor() {
    this[NF] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
  }
  clear() {
    this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    var e;
    return (e = this._head) === null || e === void 0 ? void 0 : e.value;
  }
  get last() {
    var e;
    return (e = this._tail) === null || e === void 0 ? void 0 : e.value;
  }
  has(e) {
    return this._map.has(e);
  }
  get(e, t = 0) {
    const i = this._map.get(e);
    if (i)
      return t !== 0 && this.touch(i, t), i.value;
  }
  set(e, t, i = 0) {
    let r = this._map.get(e);
    if (r)
      r.value = t, i !== 0 && this.touch(r, i);
    else {
      switch (r = { key: e, value: t, next: void 0, previous: void 0 }, i) {
        case 0:
          this.addItemLast(r);
          break;
        case 1:
          this.addItemFirst(r);
          break;
        case 2:
          this.addItemLast(r);
          break;
        default:
          this.addItemLast(r);
          break;
      }
      this._map.set(e, r), this._size++;
    }
    return this;
  }
  delete(e) {
    return !!this.remove(e);
  }
  remove(e) {
    const t = this._map.get(e);
    if (t)
      return this._map.delete(e), this.removeItem(t), this._size--, t.value;
  }
  shift() {
    if (!this._head && !this._tail)
      return;
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    const e = this._head;
    return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
  }
  forEach(e, t) {
    const i = this._state;
    let r = this._head;
    for (; r; ) {
      if (t ? e.bind(t)(r.value, r.key, this) : e(r.value, r.key, this), this._state !== i)
        throw new Error("LinkedMap got modified during iteration.");
      r = r.next;
    }
  }
  keys() {
    const e = this, t = this._state;
    let i = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: i.key, done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  values() {
    const e = this, t = this._state;
    let i = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: i.value, done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  entries() {
    const e = this, t = this._state;
    let i = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: [i.key, i.value], done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  [(NF = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let t = this._head, i = this.size;
    for (; t && i > e; )
      this._map.delete(t.key), t = t.next, i--;
    this._head = t, this._size = i, t && (t.previous = void 0), this._state++;
  }
  addItemFirst(e) {
    if (!this._head && !this._tail)
      this._tail = e;
    else if (this._head)
      e.next = this._head, this._head.previous = e;
    else
      throw new Error("Invalid list");
    this._head = e, this._state++;
  }
  addItemLast(e) {
    if (!this._head && !this._tail)
      this._head = e;
    else if (this._tail)
      e.previous = this._tail, this._tail.next = e;
    else
      throw new Error("Invalid list");
    this._tail = e, this._state++;
  }
  removeItem(e) {
    if (e === this._head && e === this._tail)
      this._head = void 0, this._tail = void 0;
    else if (e === this._head) {
      if (!e.next)
        throw new Error("Invalid list");
      e.next.previous = void 0, this._head = e.next;
    } else if (e === this._tail) {
      if (!e.previous)
        throw new Error("Invalid list");
      e.previous.next = void 0, this._tail = e.previous;
    } else {
      const t = e.next, i = e.previous;
      if (!t || !i)
        throw new Error("Invalid list");
      t.previous = i, i.next = t;
    }
    e.next = void 0, e.previous = void 0, this._state++;
  }
  touch(e, t) {
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    if (!(t !== 1 && t !== 2)) {
      if (t === 1) {
        if (e === this._head)
          return;
        const i = e.next, r = e.previous;
        e === this._tail ? (r.next = void 0, this._tail = r) : (i.previous = r, r.next = i), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
      } else if (t === 2) {
        if (e === this._tail)
          return;
        const i = e.next, r = e.previous;
        e === this._head ? (i.previous = void 0, this._head = i) : (i.previous = r, r.next = i), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
      }
    }
  }
  toJSON() {
    const e = [];
    return this.forEach((t, i) => {
      e.push([i, t]);
    }), e;
  }
  fromJSON(e) {
    this.clear();
    for (const [t, i] of e)
      this.set(t, i);
  }
}
class yN extends vre {
  constructor(e, t = 1) {
    super(), this._limit = e, this._ratio = Math.min(Math.max(0, t), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(e) {
    this._limit = e, this.checkTrim();
  }
  get(e, t = 2) {
    return super.get(e, t);
  }
  peek(e) {
    return super.get(
      e,
      0
      /* None */
    );
  }
  set(e, t) {
    return super.set(
      e,
      t,
      2
      /* AsNew */
    ), this.checkTrim(), this;
  }
  checkTrim() {
    this.size > this._limit && this.trimOld(Math.round(this._limit * this._ratio));
  }
}
const IF = typeof Buffer < "u", _re = typeof TextDecoder < "u";
let YL;
class qS {
  constructor(e) {
    this.buffer = e, this.byteLength = this.buffer.byteLength;
  }
  static wrap(e) {
    return IF && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new qS(e);
  }
  toString() {
    return IF ? this.buffer.toString() : _re ? (YL || (YL = new TextDecoder()), YL.decode(this.buffer)) : ire(this.buffer);
  }
}
function Cre(n, e) {
  return n[e + 0] << 0 >>> 0 | n[e + 1] << 8 >>> 0;
}
function yre(n, e, t) {
  n[t + 0] = e & 255, e = e >>> 8, n[t + 1] = e & 255;
}
function Na(n, e) {
  return n[e] * Math.pow(2, 24) + n[e + 1] * Math.pow(2, 16) + n[e + 2] * Math.pow(2, 8) + n[e + 3];
}
function Ia(n, e, t) {
  n[t + 3] = e, e = e >>> 8, n[t + 2] = e, e = e >>> 8, n[t + 1] = e, e = e >>> 8, n[t] = e;
}
function PF(n, e) {
  return n[e];
}
function AF(n, e, t) {
  n[t] = e;
}
function MF(n) {
  let e = JSON.parse(n);
  return e = ZR(e), e;
}
function ZR(n, e = 0) {
  if (!n || e > 200)
    return n;
  if (typeof n == "object") {
    switch (n.$mid) {
      case 1:
        return dt.revive(n);
      case 2:
        return new RegExp(n.source, n.flags);
    }
    if (n instanceof qS || n instanceof Uint8Array)
      return n;
    if (Array.isArray(n))
      for (let t = 0; t < n.length; ++t)
        n[t] = ZR(n[t], e + 1);
    else
      for (const t in n)
        Object.hasOwnProperty.call(n, t) && (n[t] = ZR(n[t], e + 1));
  }
  return n;
}
function wre(n) {
  return n.replace(/[\\/]/g, mn.sep);
}
function bre(n) {
  return n.indexOf("/") === -1 && (n = wre(n)), /^[a-zA-Z]:(\/|$)/.test(n) && (n = "/" + n), n;
}
function Sre(n, e, t, i = Zy) {
  if (n === e)
    return !0;
  if (!n || !e || e.length > n.length)
    return !1;
  if (t) {
    if (!mN(n, e))
      return !1;
    if (e.length === n.length)
      return !0;
    let o = e.length;
    return e.charAt(e.length - 1) === i && o--, n.charAt(o) === i;
  }
  return e.charAt(e.length - 1) !== i && (e += i), n.indexOf(e) === 0;
}
function Ere(n) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122;
}
function fCe(n) {
  const e = lN(n);
  return Eo ? n.length > 3 ? !1 : Lre(e) && (n.length === 2 || e.charCodeAt(2) === 92) : e === mn.sep;
}
function Lre(n) {
  return Eo ? Ere(n.charCodeAt(0)) && n.charCodeAt(1) === 58 : !1;
}
function XL(n) {
  return ib(n, !0);
}
class Dre {
  constructor(e) {
    this._ignorePathCasing = e;
  }
  compare(e, t, i = !1) {
    return e === t ? 0 : XR(this.getComparisonKey(e, i), this.getComparisonKey(t, i));
  }
  isEqual(e, t, i = !1) {
    return e === t ? !0 : !e || !t ? !1 : this.getComparisonKey(e, i) === this.getComparisonKey(t, i);
  }
  getComparisonKey(e, t = !1) {
    return e.with({
      path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0,
      fragment: t ? null : void 0
    }).toString();
  }
  // --- path math
  joinPath(e, ...t) {
    return dt.joinPath(e, ...t);
  }
  basenameOrAuthority(e) {
    return HG(e) || e.authority;
  }
  basename(e) {
    return mn.basename(e.path);
  }
  dirname(e) {
    if (e.path.length === 0)
      return e;
    let t;
    return e.scheme === vi.file ? t = dt.file(ane(XL(e))).path : (t = mn.dirname(e.path), e.authority && t.length && t.charCodeAt(0) !== 47 && (console.error(`dirname("${e.toString})) resulted in a relative path`), t = "/")), e.with({
      path: t
    });
  }
  normalizePath(e) {
    if (!e.path.length)
      return e;
    let t;
    return e.scheme === vi.file ? t = dt.file(lN(XL(e))).path : t = mn.normalize(e.path), e.with({
      path: t
    });
  }
  resolvePath(e, t) {
    if (e.scheme === vi.file) {
      const i = dt.file(one(XL(e), t));
      return e.with({
        authority: i.authority,
        path: i.path
      });
    }
    return t = bre(t), e.with({
      path: mn.resolve(e.path, t)
    });
  }
}
const jo = new Dre(() => !1), pCe = jo.isEqual.bind(jo), gCe = jo.basenameOrAuthority.bind(jo), HG = jo.basename.bind(jo), mCe = jo.dirname.bind(jo), vCe = jo.joinPath.bind(jo), Rre = jo.normalizePath.bind(jo), _Ce = jo.resolvePath.bind(jo);
var sb;
(function(n) {
  n.META_DATA_LABEL = "label", n.META_DATA_DESCRIPTION = "description", n.META_DATA_SIZE = "size", n.META_DATA_MIME = "mime";
  function e(t) {
    const i = /* @__PURE__ */ new Map();
    t.path.substring(t.path.indexOf(";") + 1, t.path.lastIndexOf(";")).split(";").forEach((s) => {
      const [a, l] = s.split(":");
      a && l && i.set(a, l);
    });
    const o = t.path.substring(0, t.path.indexOf(";"));
    return o && i.set(n.META_DATA_MIME, o), i;
  }
  n.parseMetaData = e;
})(sb || (sb = {}));
function Tre(n) {
  return Array.isArray(n);
}
function Za(n) {
  return typeof n == "string";
}
function Bo(n) {
  return typeof n == "object" && n !== null && !Array.isArray(n) && !(n instanceof RegExp) && !(n instanceof Date);
}
function V_(n) {
  return typeof n == "number" && !isNaN(n);
}
function GG(n) {
  return n === !0 || n === !1;
}
function Ls(n) {
  return typeof n > "u";
}
function ps(n) {
  return Ls(n) || n === null;
}
function Uo(n, e) {
  if (!n)
    throw new Error(e ? `Unexpected type, expected '${e}'` : "Unexpected type");
}
function CCe(n) {
  if (ps(n))
    throw new Error("Assertion Failed: argument is undefined or null");
  return n;
}
function sv(n) {
  return typeof n == "function";
}
function Ore(n, e) {
  const t = Math.min(n.length, e.length);
  for (let i = 0; i < t; i++)
    xre(n[i], e[i]);
}
function xre(n, e) {
  if (Za(e)) {
    if (typeof n !== e)
      throw new Error(`argument does not match constraint: typeof ${e}`);
  } else if (sv(e)) {
    try {
      if (n instanceof e)
        return;
    } catch {
    }
    if (!ps(n) && n.constructor === e || e.length === 1 && e.call(void 0, n) === !0)
      return;
    throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
  }
}
function Nre(n) {
  let e = [], t = Object.getPrototypeOf(n);
  for (; Object.prototype !== t; )
    e = e.concat(Object.getOwnPropertyNames(t)), t = Object.getPrototypeOf(t);
  return e;
}
function wN(n) {
  const e = [];
  for (const t of Nre(n))
    typeof n[t] == "function" && e.push(t);
  return e;
}
function UG(n, e) {
  const t = (r) => function() {
    const o = Array.prototype.slice.call(arguments, 0);
    return e(r, o);
  };
  let i = {};
  for (const r of n)
    i[r] = t(r);
  return i;
}
function Kf(n) {
  return n === null ? void 0 : n;
}
function Ire(n) {
  throw new Error("Unreachable");
}
const Ko = Vt("commandService"), Xn = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._onDidRegisterCommand = new j(), this.onDidRegisterCommand = this._onDidRegisterCommand.event;
  }
  registerCommand(n, e) {
    if (!n)
      throw new Error("invalid command");
    if (typeof n == "string") {
      if (!e)
        throw new Error("invalid command");
      return this.registerCommand({ id: n, handler: e });
    }
    if (n.description) {
      const s = [];
      for (let l of n.description.args)
        s.push(l.constraint);
      const a = n.handler;
      n.handler = function(l, ...u) {
        return Ore(u, s), a(l, ...u);
      };
    }
    const { id: t } = n;
    let i = this._commands.get(t);
    i || (i = new ua(), this._commands.set(t, i));
    let r = i.unshift(n), o = Ri(() => {
      r();
      const s = this._commands.get(t);
      s != null && s.isEmpty() && this._commands.delete(t);
    });
    return this._onDidRegisterCommand.fire(t), o;
  }
  registerCommandAlias(n, e) {
    return Xn.registerCommand(n, (t, ...i) => t.get(Ko).executeCommand(e, ...i));
  }
  getCommand(n) {
    const e = this._commands.get(n);
    if (!(!e || e.isEmpty()))
      return _t.first(e);
  }
  getCommands() {
    const n = /* @__PURE__ */ new Map();
    for (const e of this._commands.keys()) {
      const t = this.getCommand(e);
      t && n.set(e, t);
    }
    return n;
  }
}();
Xn.registerCommand("noop", () => {
});
var ab;
(function(n) {
  n[n.API = 0] = "API", n[n.USER = 1] = "USER";
})(ab || (ab = {}));
var FF = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
const kF = Vt("openerService"), yCe = Object.freeze({
  _serviceBrand: void 0,
  registerOpener() {
    return ge.None;
  },
  registerValidator() {
    return ge.None;
  },
  registerExternalUriResolver() {
    return ge.None;
  },
  setDefaultExternalOpener() {
  },
  registerExternalOpener() {
    return ge.None;
  },
  open() {
    return FF(this, void 0, void 0, function* () {
      return !1;
    });
  },
  resolveExternalUri(n) {
    return FF(this, void 0, void 0, function* () {
      return { resolved: n, dispose() {
      } };
    });
  }
});
function Mf(n, e) {
  return dt.isUri(n) ? Hm(n.scheme, e) : mN(n, e + ":");
}
var bN = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, lb = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, Hh = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
let QR = class {
  constructor(e) {
    this._commandService = e;
  }
  open(e, t) {
    return Hh(this, void 0, void 0, function* () {
      if (!Mf(e, vi.command))
        return !1;
      if (!(t != null && t.allowCommands))
        return !0;
      typeof e == "string" && (e = dt.parse(e));
      let i = [];
      try {
        i = MF(decodeURIComponent(e.query));
      } catch {
        try {
          i = MF(e.query);
        } catch {
        }
      }
      return Array.isArray(i) || (i = [i]), yield this._commandService.executeCommand(e.path, ...i), !0;
    });
  }
};
QR = bN([
  lb(0, Ko)
], QR);
let JR = class {
  constructor(e) {
    this._editorService = e;
  }
  open(e, t) {
    return Hh(this, void 0, void 0, function* () {
      typeof e == "string" && (e = dt.parse(e));
      let i;
      const r = /^L?(\d+)(?:,(\d+))?/.exec(e.fragment);
      return r && (i = {
        startLineNumber: parseInt(r[1]),
        startColumn: r[2] ? parseInt(r[2]) : 1
      }, e = e.with({ fragment: "" })), e.scheme === vi.file && (e = Rre(e)), yield this._editorService.openCodeEditor({
        resource: e,
        options: Object.assign({ selection: i, context: t != null && t.fromUserGesture ? ab.USER : ab.API }, t == null ? void 0 : t.editorOptions)
      }, this._editorService.getFocusedCodeEditor(), t == null ? void 0 : t.openToSide), !0;
    });
  }
};
JR = bN([
  lb(0, pr)
], JR);
let eT = class {
  constructor(e, t) {
    this._openers = new ua(), this._validators = new ua(), this._resolvers = new ua(), this._resolvedUriTargets = new yo((i) => i.with({ path: null, fragment: null, query: null }).toString()), this._externalOpeners = new ua(), this._defaultExternalOpener = {
      openExternal: (i) => Hh(this, void 0, void 0, function* () {
        return Mf(i, vi.http) || Mf(i, vi.https) ? IG(i) : window.location.href = i, !0;
      })
    }, this._openers.push({
      open: (i, r) => Hh(this, void 0, void 0, function* () {
        return r != null && r.openExternal || Mf(i, vi.mailto) || Mf(i, vi.http) || Mf(i, vi.https) ? (yield this._doOpenExternal(i, r), !0) : !1;
      })
    }), this._openers.push(new QR(t)), this._openers.push(new JR(e));
  }
  registerOpener(e) {
    return { dispose: this._openers.unshift(e) };
  }
  registerValidator(e) {
    return { dispose: this._validators.push(e) };
  }
  registerExternalUriResolver(e) {
    return { dispose: this._resolvers.push(e) };
  }
  setDefaultExternalOpener(e) {
    this._defaultExternalOpener = e;
  }
  registerExternalOpener(e) {
    return { dispose: this._externalOpeners.push(e) };
  }
  open(e, t) {
    var i;
    return Hh(this, void 0, void 0, function* () {
      const r = typeof e == "string" ? dt.parse(e) : e, o = (i = this._resolvedUriTargets.get(r)) !== null && i !== void 0 ? i : e;
      for (const s of this._validators)
        if (!(yield s.shouldOpen(o)))
          return !1;
      for (const s of this._openers)
        if (yield s.open(e, t))
          return !0;
      return !1;
    });
  }
  resolveExternalUri(e, t) {
    return Hh(this, void 0, void 0, function* () {
      for (const i of this._resolvers)
        try {
          const r = yield i.resolveExternalUri(e, t);
          if (r)
            return this._resolvedUriTargets.has(r.resolved) || this._resolvedUriTargets.set(r.resolved, e), r;
        } catch {
        }
      throw new Error("Could not resolve external URI: " + e.toString());
    });
  }
  _doOpenExternal(e, t) {
    return Hh(this, void 0, void 0, function* () {
      const i = typeof e == "string" ? dt.parse(e) : e;
      let r;
      try {
        r = (yield this.resolveExternalUri(i, t)).resolved;
      } catch {
        r = i;
      }
      let o;
      if (typeof e == "string" && i.toString() === r.toString() ? o = e : o = encodeURI(r.toString(!0)), t != null && t.allowContributedOpeners) {
        const s = typeof (t == null ? void 0 : t.allowContributedOpeners) == "string" ? t == null ? void 0 : t.allowContributedOpeners : void 0;
        for (const a of this._externalOpeners)
          if (yield a.openExternal(o, {
            sourceUri: i,
            preferredOpenerId: s
          }, zo.None))
            return !0;
      }
      return this._defaultExternalOpener.openExternal(o, { sourceUri: i }, zo.None);
    });
  }
  dispose() {
    this._validators.clear();
  }
};
eT = bN([
  lb(0, pr),
  lb(1, Ko)
], eT);
function Jy(n, e) {
  if (!n)
    throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed");
}
function Gh(n) {
  if (!n || typeof n != "object" || n instanceof RegExp)
    return n;
  const e = Array.isArray(n) ? [] : {};
  return Object.keys(n).forEach((t) => {
    n[t] && typeof n[t] == "object" ? e[t] = Gh(n[t]) : e[t] = n[t];
  }), e;
}
function Pre(n) {
  if (!n || typeof n != "object")
    return n;
  const e = [n];
  for (; e.length > 0; ) {
    const t = e.shift();
    Object.freeze(t);
    for (const i in t)
      if (zG.call(t, i)) {
        const r = t[i];
        typeof r == "object" && !Object.isFrozen(r) && e.push(r);
      }
  }
  return n;
}
const zG = Object.prototype.hasOwnProperty;
function ECe(n, e) {
  return tT(n, e, /* @__PURE__ */ new Set());
}
function tT(n, e, t) {
  if (ps(n))
    return n;
  const i = e(n);
  if (typeof i < "u")
    return i;
  if (Tre(n)) {
    const r = [];
    for (const o of n)
      r.push(tT(o, e, t));
    return r;
  }
  if (Bo(n)) {
    if (t.has(n))
      throw new Error("Cannot clone recursive data-structure");
    t.add(n);
    const r = {};
    for (let o in n)
      zG.call(n, o) && (r[o] = tT(n[o], e, t));
    return t.delete(n), r;
  }
  return n;
}
function ch(n, e, t = !0) {
  return Bo(n) ? (Bo(e) && Object.keys(e).forEach((i) => {
    i in n ? t && (Bo(n[i]) && Bo(e[i]) ? ch(n[i], e[i], t) : n[i] = e[i]) : n[i] = e[i];
  }), n) : e;
}
function Hu(n, e) {
  if (n === e)
    return !0;
  if (n == null || e === null || e === void 0 || typeof n != typeof e || typeof n != "object" || Array.isArray(n) !== Array.isArray(e))
    return !1;
  let t, i;
  if (Array.isArray(n)) {
    if (n.length !== e.length)
      return !1;
    for (t = 0; t < n.length; t++)
      if (!Hu(n[t], e[t]))
        return !1;
  } else {
    const r = [];
    for (i in n)
      r.push(i);
    r.sort();
    const o = [];
    for (i in e)
      o.push(i);
    if (o.sort(), !Hu(r, o))
      return !1;
    for (t = 0; t < r.length; t++)
      if (!Hu(n[r[t]], e[r[t]]))
        return !1;
  }
  return !0;
}
function bl(n, e, t) {
  const i = e(n);
  return typeof i > "u" ? t : i;
}
const Are = {
  followsCaret: !0,
  ignoreCharChanges: !0,
  alwaysRevealFirst: !0
};
class Mre extends ge {
  constructor(e, t = {}) {
    super(), this._onDidUpdate = this._register(new j()), this._editor = e, this._options = ch(t, Are, !1), this.disposed = !1, this.nextIdx = -1, this.ranges = [], this.ignoreSelectionChange = !1, this.revealFirst = !!this._options.alwaysRevealFirst, this._register(this._editor.onDidDispose(() => this.dispose())), this._register(this._editor.onDidUpdateDiff(() => this._onDiffUpdated())), this._options.followsCaret && this._register(this._editor.getModifiedEditor().onDidChangeCursorPosition((i) => {
      this.ignoreSelectionChange || (this.nextIdx = -1);
    })), this._options.alwaysRevealFirst && this._register(this._editor.getModifiedEditor().onDidChangeModel((i) => {
      this.revealFirst = !0;
    })), this._init();
  }
  _init() {
    this._editor.getLineChanges();
  }
  _onDiffUpdated() {
    this._init(), this._compute(this._editor.getLineChanges()), this.revealFirst && this._editor.getLineChanges() !== null && (this.revealFirst = !1, this.nextIdx = -1, this.next(
      1
      /* Immediate */
    ));
  }
  _compute(e) {
    this.ranges = [], e && e.forEach((t) => {
      !this._options.ignoreCharChanges && t.charChanges ? t.charChanges.forEach((i) => {
        this.ranges.push({
          rhs: !0,
          range: new V(i.modifiedStartLineNumber, i.modifiedStartColumn, i.modifiedEndLineNumber, i.modifiedEndColumn)
        });
      }) : this.ranges.push({
        rhs: !0,
        range: new V(t.modifiedStartLineNumber, 1, t.modifiedStartLineNumber, 1)
      });
    }), this.ranges.sort((t, i) => t.range.getStartPosition().isBeforeOrEqual(i.range.getStartPosition()) ? -1 : i.range.getStartPosition().isBeforeOrEqual(t.range.getStartPosition()) ? 1 : 0), this._onDidUpdate.fire(this);
  }
  _initIdx(e) {
    let t = !1, i = this._editor.getPosition();
    if (!i) {
      this.nextIdx = 0;
      return;
    }
    for (let r = 0, o = this.ranges.length; r < o && !t; r++) {
      let s = this.ranges[r].range;
      i.isBeforeOrEqual(s.getStartPosition()) && (this.nextIdx = r + (e ? 0 : -1), t = !0);
    }
    t || (this.nextIdx = e ? 0 : this.ranges.length - 1), this.nextIdx < 0 && (this.nextIdx = this.ranges.length - 1);
  }
  _move(e, t) {
    if (Jy(!this.disposed, "Illegal State - diff navigator has been disposed"), !this.canNavigate())
      return;
    this.nextIdx === -1 ? this._initIdx(e) : e ? (this.nextIdx += 1, this.nextIdx >= this.ranges.length && (this.nextIdx = 0)) : (this.nextIdx -= 1, this.nextIdx < 0 && (this.nextIdx = this.ranges.length - 1));
    let i = this.ranges[this.nextIdx];
    this.ignoreSelectionChange = !0;
    try {
      let r = i.range.getStartPosition();
      this._editor.setPosition(r), this._editor.revealPositionInCenter(r, t);
    } finally {
      this.ignoreSelectionChange = !1;
    }
  }
  canNavigate() {
    return this.ranges && this.ranges.length > 0;
  }
  next(e = 0) {
    this._move(!0, e);
  }
  previous(e = 0) {
    this._move(!1, e);
  }
  dispose() {
    super.dispose(), this.ranges = [], this.disposed = !0;
  }
}
const ub = new class {
  constructor() {
    this._zoomLevel = 0, this._onDidChangeZoomLevel = new j(), this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  setZoomLevel(n) {
    n = Math.min(Math.max(-5, n), 20), this._zoomLevel !== n && (this._zoomLevel = n, this._onDidChangeZoomLevel.fire(this._zoomLevel));
  }
}(), Fre = Ft ? 1.5 : 1.35, WF = 8;
class Hp {
  /**
   * @internal
   */
  constructor(e) {
    this.zoomLevel = e.zoomLevel, this.pixelRatio = e.pixelRatio, this.fontFamily = String(e.fontFamily), this.fontWeight = String(e.fontWeight), this.fontSize = e.fontSize, this.fontFeatureSettings = e.fontFeatureSettings, this.lineHeight = e.lineHeight | 0, this.letterSpacing = e.letterSpacing;
  }
  /**
   * @internal
   */
  static createFromValidatedSettings(e, t, i, r) {
    const o = e.get(
      39
      /* fontFamily */
    ), s = e.get(
      43
      /* fontWeight */
    ), a = e.get(
      42
      /* fontSize */
    ), l = e.get(
      41
      /* fontLigatures */
    ), u = e.get(
      56
      /* lineHeight */
    ), c = e.get(
      53
      /* letterSpacing */
    );
    return Hp._create(o, s, a, l, u, c, t, i, r);
  }
  /**
   * @internal
   */
  static _create(e, t, i, r, o, s, a, l, u) {
    o === 0 ? o = Math.round(Fre * i) : o < WF && (o = WF);
    const c = 1 + (u ? 0 : ub.getZoomLevel() * 0.1);
    return i *= c, o *= c, new Hp({
      zoomLevel: a,
      pixelRatio: l,
      fontFamily: e,
      fontWeight: t,
      fontSize: i,
      fontFeatureSettings: r,
      lineHeight: o,
      letterSpacing: s
    });
  }
  /**
   * @internal
   */
  getId() {
    return this.zoomLevel + "-" + this.pixelRatio + "-" + this.fontFamily + "-" + this.fontWeight + "-" + this.fontSize + "-" + this.fontFeatureSettings + "-" + this.lineHeight + "-" + this.letterSpacing;
  }
  /**
   * @internal
   */
  getMassagedFontFamily() {
    return /[,"']/.test(this.fontFamily) ? this.fontFamily : /[+ ]/.test(this.fontFamily) ? `"${this.fontFamily}"` : this.fontFamily;
  }
}
const kre = 1;
class iT extends Hp {
  /**
   * @internal
   */
  constructor(e, t) {
    super(e), this.version = kre, this.isTrusted = t, this.isMonospace = e.isMonospace, this.typicalHalfwidthCharacterWidth = e.typicalHalfwidthCharacterWidth, this.typicalFullwidthCharacterWidth = e.typicalFullwidthCharacterWidth, this.canUseHalfwidthRightwardsArrow = e.canUseHalfwidthRightwardsArrow, this.spaceWidth = e.spaceWidth, this.middotWidth = e.middotWidth, this.wsmiddotWidth = e.wsmiddotWidth, this.maxDigitWidth = e.maxDigitWidth;
  }
  /**
   * @internal
   */
  equals(e) {
    return this.fontFamily === e.fontFamily && this.fontWeight === e.fontWeight && this.fontSize === e.fontSize && this.fontFeatureSettings === e.fontFeatureSettings && this.lineHeight === e.lineHeight && this.letterSpacing === e.letterSpacing && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === e.typicalFullwidthCharacterWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.maxDigitWidth === e.maxDigitWidth;
  }
}
function Wre(n) {
  return n && typeof n.id == "string";
}
const B_ = {
  ICodeEditor: "vs.editor.ICodeEditor",
  IDiffEditor: "vs.editor.IDiffEditor"
};
var Uv;
(function(n) {
  n[n.Left = 1] = "Left", n[n.Center = 2] = "Center", n[n.Right = 4] = "Right", n[n.Full = 7] = "Full";
})(Uv || (Uv = {}));
var Gp;
(function(n) {
  n[n.Inline = 1] = "Inline", n[n.Gutter = 2] = "Gutter";
})(Gp || (Gp = {}));
class ew {
  /**
   * @internal
   */
  constructor(e) {
    this.tabSize = Math.max(1, e.tabSize | 0), this.indentSize = e.tabSize | 0, this.insertSpaces = !!e.insertSpaces, this.defaultEOL = e.defaultEOL | 0, this.trimAutoWhitespace = !!e.trimAutoWhitespace;
  }
  /**
   * @internal
   */
  equals(e) {
    return this.tabSize === e.tabSize && this.indentSize === e.indentSize && this.insertSpaces === e.insertSpaces && this.defaultEOL === e.defaultEOL && this.trimAutoWhitespace === e.trimAutoWhitespace;
  }
  /**
   * @internal
   */
  createChangeEvent(e) {
    return {
      tabSize: this.tabSize !== e.tabSize,
      indentSize: this.indentSize !== e.indentSize,
      insertSpaces: this.insertSpaces !== e.insertSpaces,
      trimAutoWhitespace: this.trimAutoWhitespace !== e.trimAutoWhitespace
    };
  }
}
class zv {
  /**
   * @internal
   */
  constructor(e, t) {
    this.range = e, this.matches = t;
  }
}
class ZL {
  constructor(e, t, i, r, o, s) {
    this.identifier = e, this.range = t, this.text = i, this.forceMoveMarkers = r, this.isAutoWhitespaceEdit = o, this._isTracked = s;
  }
}
class Vre {
  constructor(e, t, i) {
    this.reverseEdits = e, this.changes = t, this.trimAutoWhitespaceLineNumbers = i;
  }
}
function Bre(n) {
  return SN(n, 0);
}
function SN(n, e) {
  switch (typeof n) {
    case "object":
      return n === null ? Wu(349, e) : Array.isArray(n) ? Gre(n, e) : Ure(n, e);
    case "string":
      return EN(n, e);
    case "boolean":
      return Hre(n, e);
    case "number":
      return Wu(n, e);
    case "undefined":
      return Wu(937, e);
    default:
      return Wu(617, e);
  }
}
function Wu(n, e) {
  return (e << 5) - e + n | 0;
}
function Hre(n, e) {
  return Wu(n ? 433 : 863, e);
}
function EN(n, e) {
  e = Wu(149417, e);
  for (let t = 0, i = n.length; t < i; t++)
    e = Wu(n.charCodeAt(t), e);
  return e;
}
function Gre(n, e) {
  return e = Wu(104579, e), n.reduce((t, i) => SN(i, t), e);
}
function Ure(n, e) {
  return e = Wu(181387, e), Object.keys(n).sort().reduce((t, i) => (t = EN(i, t), SN(n[i], t)), e);
}
function QL(n, e, t = 32) {
  const i = t - e, r = ~((1 << i) - 1);
  return (n << e | (r & n) >>> i) >>> 0;
}
function VF(n, e = 0, t = n.byteLength, i = 0) {
  for (let r = 0; r < t; r++)
    n[e + r] = i;
}
function zre(n, e, t = "0") {
  for (; n.length < e; )
    n = t + n;
  return n;
}
function Em(n, e = 32) {
  return n instanceof ArrayBuffer ? Array.from(new Uint8Array(n)).map((t) => t.toString(16).padStart(2, "0")).join("") : zre((n >>> 0).toString(16), e / 4);
}
class YS {
  constructor() {
    this._h0 = 1732584193, this._h1 = 4023233417, this._h2 = 2562383102, this._h3 = 271733878, this._h4 = 3285377520, this._buff = new Uint8Array(
      64 + 3
      /* to fit any utf-8 */
    ), this._buffDV = new DataView(this._buff.buffer), this._buffLen = 0, this._totalLen = 0, this._leftoverHighSurrogate = 0, this._finished = !1;
  }
  update(e) {
    const t = e.length;
    if (t === 0)
      return;
    const i = this._buff;
    let r = this._buffLen, o = this._leftoverHighSurrogate, s, a;
    for (o !== 0 ? (s = o, a = -1, o = 0) : (s = e.charCodeAt(0), a = 0); ; ) {
      let l = s;
      if (jn(s))
        if (a + 1 < t) {
          const u = e.charCodeAt(a + 1);
          Gv(u) ? (a++, l = vN(s, u)) : l = 65533;
        } else {
          o = s;
          break;
        }
      else
        Gv(s) && (l = 65533);
      if (r = this._push(i, r, l), a++, a < t)
        s = e.charCodeAt(a);
      else
        break;
    }
    this._buffLen = r, this._leftoverHighSurrogate = o;
  }
  _push(e, t, i) {
    return i < 128 ? e[t++] = i : i < 2048 ? (e[t++] = 192 | (i & 1984) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : i < 65536 ? (e[t++] = 224 | (i & 61440) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : (e[t++] = 240 | (i & 1835008) >>> 18, e[t++] = 128 | (i & 258048) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0), t >= 64 && (this._step(), t -= 64, this._totalLen += 64, e[0] = e[64 + 0], e[1] = e[64 + 1], e[2] = e[64 + 2]), t;
  }
  digest() {
    return this._finished || (this._finished = !0, this._leftoverHighSurrogate && (this._leftoverHighSurrogate = 0, this._buffLen = this._push(
      this._buff,
      this._buffLen,
      65533
      /* UNICODE_REPLACEMENT */
    )), this._totalLen += this._buffLen, this._wrapUp()), Em(this._h0) + Em(this._h1) + Em(this._h2) + Em(this._h3) + Em(this._h4);
  }
  _wrapUp() {
    this._buff[this._buffLen++] = 128, VF(this._buff, this._buffLen), this._buffLen > 56 && (this._step(), VF(this._buff));
    const e = 8 * this._totalLen;
    this._buffDV.setUint32(56, Math.floor(e / 4294967296), !1), this._buffDV.setUint32(60, e % 4294967296, !1), this._step();
  }
  _step() {
    const e = YS._bigBlock32, t = this._buffDV;
    for (let h = 0; h < 64; h += 4)
      e.setUint32(h, t.getUint32(h, !1), !1);
    for (let h = 64; h < 320; h += 4)
      e.setUint32(h, QL(e.getUint32(h - 12, !1) ^ e.getUint32(h - 32, !1) ^ e.getUint32(h - 56, !1) ^ e.getUint32(h - 64, !1), 1), !1);
    let i = this._h0, r = this._h1, o = this._h2, s = this._h3, a = this._h4, l, u, c;
    for (let h = 0; h < 80; h++)
      h < 20 ? (l = r & o | ~r & s, u = 1518500249) : h < 40 ? (l = r ^ o ^ s, u = 1859775393) : h < 60 ? (l = r & o | r & s | o & s, u = 2400959708) : (l = r ^ o ^ s, u = 3395469782), c = QL(i, 5) + l + a + u + e.getUint32(h * 4, !1) & 4294967295, a = s, s = o, o = QL(r, 30), r = i, i = c;
    this._h0 = this._h0 + i & 4294967295, this._h1 = this._h1 + r & 4294967295, this._h2 = this._h2 + o & 4294967295, this._h3 = this._h3 + s & 4294967295, this._h4 = this._h4 + a & 4294967295;
  }
}
YS._bigBlock32 = new DataView(new ArrayBuffer(320));
function Pa(n, e, t) {
  return Math.min(Math.max(n, e), t);
}
class jre {
  constructor() {
    this._n = 1, this._val = 0;
  }
  update(e) {
    return this._val = this._val + (e - this._val) / this._n, this._n += 1, this;
  }
  get value() {
    return this._val;
  }
}
const JL = "**", BF = "/", tw = "[/\\\\]", iw = "[^/\\\\]", $re = /\//g;
function HF(n) {
  switch (n) {
    case 0:
      return "";
    case 1:
      return `${iw}*?`;
    default:
      return `(?:${tw}|${iw}+${tw}|${tw}${iw}+)*?`;
  }
}
function GF(n, e) {
  if (!n)
    return [];
  const t = [];
  let i = !1, r = !1, o = "";
  for (const s of n) {
    switch (s) {
      case e:
        if (!i && !r) {
          t.push(o), o = "";
          continue;
        }
        break;
      case "{":
        i = !0;
        break;
      case "}":
        i = !1;
        break;
      case "[":
        r = !0;
        break;
      case "]":
        r = !1;
        break;
    }
    o += s;
  }
  return o && t.push(o), t;
}
function jG(n) {
  if (!n)
    return "";
  let e = "";
  const t = GF(n, BF);
  if (t.every((i) => i === JL))
    e = ".*";
  else {
    let i = !1;
    t.forEach((r, o) => {
      if (r === JL) {
        i || (e += HF(2), i = !0);
        return;
      }
      let s = !1, a = "", l = !1, u = "";
      for (const c of r) {
        if (c !== "}" && s) {
          a += c;
          continue;
        }
        if (l && (c !== "]" || !u)) {
          let h;
          c === "-" ? h = c : (c === "^" || c === "!") && !u ? h = "^" : c === BF ? h = "" : h = Bp(c), u += h;
          continue;
        }
        switch (c) {
          case "{":
            s = !0;
            continue;
          case "[":
            l = !0;
            continue;
          case "}":
            const d = `(?:${GF(a, ",").map((f) => jG(f)).join("|")})`;
            e += d, s = !1, a = "";
            break;
          case "]":
            e += "[" + u + "]", l = !1, u = "";
            break;
          case "?":
            e += iw;
            continue;
          case "*":
            e += HF(1);
            continue;
          default:
            e += Bp(c);
        }
      }
      o < t.length - 1 && (t[o + 1] !== JL || o + 2 < t.length) && (e += tw), i = !1;
    });
  }
  return e;
}
const Kre = /^\*\*\/\*\.[\w\.-]+$/, qre = /^\*\*\/([\w\.-]+)\/?$/, Yre = /^{\*\*\/[\*\.]?[\w\.-]+\/?(,\*\*\/[\*\.]?[\w\.-]+\/?)*}$/, Xre = /^{\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?(,\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?)*}$/, Zre = /^\*\*((\/[\w\.-]+)+)\/?$/, Qre = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/, UF = new yN(1e4), zF = function() {
  return !1;
}, kl = function() {
  return null;
};
function LN(n, e) {
  if (!n)
    return kl;
  let t;
  typeof n != "string" ? t = n.pattern : t = n, t = t.trim();
  const i = `${t}_${!!e.trimForExclusions}`;
  let r = UF.get(i);
  if (r)
    return jF(r, n);
  let o;
  if (Kre.test(t)) {
    const s = t.substr(4);
    r = function(a, l) {
      return typeof a == "string" && a.endsWith(s) ? t : null;
    };
  } else
    (o = qre.exec(eD(t, e))) ? r = Jre(o[1], t) : (e.trimForExclusions ? Xre : Yre).test(t) ? r = eoe(t, e) : (o = Zre.exec(eD(t, e))) ? r = $F(o[1].substr(1), t, !0) : (o = Qre.exec(eD(t, e))) ? r = $F(o[1], t, !1) : r = toe(t);
  return UF.set(i, r), jF(r, n);
}
function jF(n, e) {
  return typeof e == "string" ? n : function(t, i) {
    return Sre(t, e.base) ? n(sne(e.base, t), i) : null;
  };
}
function eD(n, e) {
  return e.trimForExclusions && n.endsWith("/**") ? n.substr(0, n.length - 2) : n;
}
function Jre(n, e) {
  const t = `/${n}`, i = `\\${n}`, r = function(s, a) {
    return typeof s != "string" ? null : a ? a === n ? e : null : s === n || s.endsWith(t) || s.endsWith(i) ? e : null;
  }, o = [n];
  return r.basenames = o, r.patterns = [e], r.allBasenames = o, r;
}
function eoe(n, e) {
  const t = KG(n.slice(1, -1).split(",").map((a) => LN(a, e)).filter((a) => a !== kl), n), i = t.length;
  if (!i)
    return kl;
  if (i === 1)
    return t[0];
  const r = function(a, l) {
    for (let u = 0, c = t.length; u < c; u++)
      if (t[u](a, l))
        return n;
    return null;
  }, o = t.find((a) => !!a.allBasenames);
  o && (r.allBasenames = o.allBasenames);
  const s = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return s.length && (r.allPaths = s), r;
}
function $F(n, e, t) {
  const i = Zy === mn.sep, r = i ? n : n.replace($re, Zy), o = Zy + r, s = mn.sep + n, a = t ? function(l, u) {
    return typeof l == "string" && (l === r || l.endsWith(o) || !i && (l === n || l.endsWith(s))) ? e : null;
  } : function(l, u) {
    return typeof l == "string" && (l === r || !i && l === n) ? e : null;
  };
  return a.allPaths = [(t ? "*/" : "./") + n], a;
}
function toe(n) {
  try {
    const e = new RegExp(`^${jG(n)}$`);
    return function(t) {
      return e.lastIndex = 0, typeof t == "string" && e.test(t) ? n : null;
    };
  } catch {
    return kl;
  }
}
function $G(n, e, t) {
  return !n || typeof e != "string" ? !1 : ioe(n)(e, void 0, t);
}
function ioe(n, e = {}) {
  if (!n)
    return zF;
  if (typeof n == "string" || noe(n)) {
    const t = LN(n, e);
    if (t === kl)
      return zF;
    const i = function(r, o) {
      return !!t(r, o);
    };
    return t.allBasenames && (i.allBasenames = t.allBasenames), t.allPaths && (i.allPaths = t.allPaths), i;
  }
  return roe(n, e);
}
function noe(n) {
  const e = n;
  return e && typeof e.base == "string" && typeof e.pattern == "string";
}
function roe(n, e) {
  const t = KG(Object.getOwnPropertyNames(n).map((a) => ooe(a, n[a], e)).filter((a) => a !== kl)), i = t.length;
  if (!i)
    return kl;
  if (!t.some((a) => !!a.requiresSiblings)) {
    if (i === 1)
      return t[0];
    const a = function(c, h) {
      for (let d = 0, f = t.length; d < f; d++) {
        const p = t[d](c, h);
        if (p)
          return p;
      }
      return null;
    }, l = t.find((c) => !!c.allBasenames);
    l && (a.allBasenames = l.allBasenames);
    const u = t.reduce((c, h) => h.allPaths ? c.concat(h.allPaths) : c, []);
    return u.length && (a.allPaths = u), a;
  }
  const r = function(a, l, u) {
    let c;
    for (let h = 0, d = t.length; h < d; h++) {
      const f = t[h];
      f.requiresSiblings && u && (l || (l = uG(a)), c || (c = l.substr(0, l.length - lne(a).length)));
      const p = f(a, l, c, u);
      if (p)
        return p;
    }
    return null;
  }, o = t.find((a) => !!a.allBasenames);
  o && (r.allBasenames = o.allBasenames);
  const s = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return s.length && (r.allPaths = s), r;
}
function ooe(n, e, t) {
  if (e === !1)
    return kl;
  const i = LN(n, t);
  if (i === kl)
    return kl;
  if (typeof e == "boolean")
    return i;
  if (e) {
    const r = e.when;
    if (typeof r == "string") {
      const o = (s, a, l, u) => {
        if (!u || !i(s, a))
          return null;
        const c = r.replace("$(basename)", l), h = u(c);
        return Tne(h) ? h.then((d) => d ? n : null) : h ? n : null;
      };
      return o.requiresSiblings = !0, o;
    }
  }
  return i;
}
function KG(n, e) {
  const t = n.filter((a) => !!a.basenames);
  if (t.length < 2)
    return n;
  const i = t.reduce((a, l) => {
    const u = l.basenames;
    return u ? a.concat(u) : a;
  }, []);
  let r;
  if (e) {
    r = [];
    for (let a = 0, l = i.length; a < l; a++)
      r.push(e);
  } else
    r = t.reduce((a, l) => {
      const u = l.patterns;
      return u ? a.concat(u) : a;
    }, []);
  const o = function(a, l) {
    if (typeof a != "string")
      return null;
    if (!l) {
      let c;
      for (c = a.length; c > 0; c--) {
        const h = a.charCodeAt(c - 1);
        if (h === 47 || h === 92)
          break;
      }
      l = a.substr(c);
    }
    const u = i.indexOf(l);
    return u !== -1 ? r[u] : null;
  };
  o.basenames = i, o.patterns = r, o.allBasenames = i;
  const s = n.filter((a) => !a.basenames);
  return s.push(o), s;
}
function qG(n, e, t, i) {
  if (Array.isArray(n)) {
    let r = 0;
    for (const o of n) {
      const s = qG(o, e, t, i);
      if (s === 10)
        return s;
      s > r && (r = s);
    }
    return r;
  } else {
    if (typeof n == "string")
      return i ? n === "*" ? 5 : n === t ? 10 : 0 : 0;
    if (n) {
      const { language: r, pattern: o, scheme: s, hasAccessToAllModels: a } = n;
      if (!i && !a)
        return 0;
      let l = 0;
      if (s)
        if (s === e.scheme)
          l = 10;
        else if (s === "*")
          l = 5;
        else
          return 0;
      if (r)
        if (r === t)
          l = 10;
        else if (r === "*")
          l = Math.max(l, 5);
        else
          return 0;
      if (o) {
        let u;
        if (typeof o == "string" ? u = o : u = Object.assign(Object.assign({}, o), { base: lN(o.base) }), u === e.fsPath || $G(u, e.fsPath))
          l = 10;
        else
          return 0;
      }
      return l;
    } else
      return 0;
  }
}
const ro = Vt("modelService");
function soe(n) {
  return !n.isTooLargeForSyncing() && !n.isForSimpleWidget;
}
function YG(n) {
  return typeof n == "string" ? !1 : Array.isArray(n) ? n.every(YG) : !!n.exclusive;
}
class Bi {
  constructor() {
    this._clock = 0, this._entries = [], this._onDidChange = new j();
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  register(e, t) {
    let i = {
      selector: e,
      provider: t,
      _score: -1,
      _time: this._clock++
    };
    return this._entries.push(i), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), Ri(() => {
      if (i) {
        let r = this._entries.indexOf(i);
        r >= 0 && (this._entries.splice(r, 1), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), i = void 0);
      }
    });
  }
  has(e) {
    return this.all(e).length > 0;
  }
  all(e) {
    if (!e)
      return [];
    this._updateScores(e);
    const t = [];
    for (let i of this._entries)
      i._score > 0 && t.push(i.provider);
    return t;
  }
  ordered(e) {
    const t = [];
    return this._orderedForEach(e, (i) => t.push(i.provider)), t;
  }
  orderedGroups(e) {
    const t = [];
    let i, r;
    return this._orderedForEach(e, (o) => {
      i && r === o._score ? i.push(o.provider) : (r = o._score, i = [o.provider], t.push(i));
    }), t;
  }
  _orderedForEach(e, t) {
    if (e) {
      this._updateScores(e);
      for (const i of this._entries)
        i._score > 0 && t(i);
    }
  }
  _updateScores(e) {
    let t = {
      uri: e.uri.toString(),
      language: e.getLanguageIdentifier().language
    };
    if (!(this._lastCandidate && this._lastCandidate.language === t.language && this._lastCandidate.uri === t.uri)) {
      this._lastCandidate = t;
      for (let i of this._entries)
        if (i._score = qG(i.selector, e.uri, e.getLanguageIdentifier().language, soe(e)), YG(i.selector) && i._score > 0) {
          for (let r of this._entries)
            r._score = 0;
          i._score = 1e3;
          break;
        }
      this._entries.sort(Bi._compareByScoreAndTime);
    }
  }
  static _compareByScoreAndTime(e, t) {
    return e._score < t._score ? 1 : e._score > t._score ? -1 : e._time < t._time ? 1 : e._time > t._time ? -1 : 0;
  }
}
class LCe {
  constructor(e, t, i = Number.MAX_SAFE_INTEGER) {
    this._registry = e, this.min = t, this.max = i, this._cache = new yN(50, 0.7);
  }
  _key(e) {
    return e.id + Bre(this._registry.all(e));
  }
  _clamp(e) {
    return e === void 0 ? this.min : Math.min(this.max, Math.max(this.min, Math.floor(e * 1.3)));
  }
  get(e) {
    const t = this._key(e), i = this._cache.get(t);
    return this._clamp(i == null ? void 0 : i.value);
  }
  update(e, t) {
    const i = this._key(e);
    let r = this._cache.get(i);
    return r || (r = new jre(), this._cache.set(i, r)), r.update(t), this.get(e);
  }
}
class aoe {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._promises = /* @__PURE__ */ new Map(), this._onDidChange = new j(), this.onDidChange = this._onDidChange.event, this._colorMap = null;
  }
  fire(e) {
    this._onDidChange.fire({
      changedLanguages: e,
      changedColorMap: !1
    });
  }
  register(e, t) {
    return this._map.set(e, t), this.fire([e]), Ri(() => {
      this._map.get(e) === t && (this._map.delete(e), this.fire([e]));
    });
  }
  registerPromise(e, t) {
    let i = null, r = !1;
    return this._promises.set(e, t.then((o) => {
      this._promises.delete(e), !(r || !o) && (i = this.register(e, o));
    })), Ri(() => {
      r = !0, i && i.dispose();
    });
  }
  getPromise(e) {
    const t = this.get(e);
    if (t)
      return Promise.resolve(t);
    const i = this._promises.get(e);
    return i ? i.then((r) => this.get(e)) : null;
  }
  get(e) {
    return this._map.get(e) || null;
  }
  setColorMap(e) {
    this._colorMap = e, this._onDidChange.fire({
      changedLanguages: Array.from(this._map.keys()),
      changedColorMap: !0
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    return this._colorMap && this._colorMap.length > 2 ? this._colorMap[
      2
      /* DefaultBackground */
    ] : null;
  }
}
let loe = class {
  constructor() {
    this._icons = /* @__PURE__ */ new Map(), this._onDidRegister = new j();
  }
  add(e) {
    const t = this._icons.get(e.id);
    t ? e.description ? t.description = e.description : console.error(`Duplicate registration of codicon ${e.id}`) : (this._icons.set(e.id, e), this._onDidRegister.fire(e));
  }
  get(e) {
    return this._icons.get(e);
  }
  get all() {
    return this._icons.values();
  }
  get onDidRegister() {
    return this._onDidRegister.event;
  }
};
const XG = new loe(), cb = XG;
function va(n, e) {
  return new Vi(n, e);
}
function uoe(n) {
  return n ? n.replace(/\$\((.*?)\)/g, (e, t) => ` ${t} `).trim() : "";
}
class Vi {
  constructor(e, t, i) {
    this.id = e, this.definition = t, this.description = i, XG.add(this);
  }
  get classNames() {
    return "codicon codicon-" + this.id;
  }
  // classNamesArray is useful for migrating to ES6 classlist
  get classNamesArray() {
    return ["codicon", "codicon-" + this.id];
  }
  get cssSelector() {
    return ".codicon.codicon-" + this.id;
  }
}
var Vo;
(function(n) {
  n.iconNameSegment = "[A-Za-z0-9]+", n.iconNameExpression = "[A-Za-z0-9\\-]+", n.iconModifierExpression = "~[A-Za-z]+";
  const e = new RegExp(`^(${n.iconNameExpression})(${n.iconModifierExpression})?$`);
  function t(o) {
    if (o instanceof Vi)
      return ["codicon", "codicon-" + o.id];
    const s = e.exec(o.id);
    if (!s)
      return t(Vi.error);
    let [, a, l] = s;
    const u = ["codicon", "codicon-" + a];
    return l && u.push("codicon-modifier-" + l.substr(1)), u;
  }
  n.asClassNameArray = t;
  function i(o) {
    return t(o).join(" ");
  }
  n.asClassName = i;
  function r(o) {
    return "." + t(o).join(".");
  }
  n.asCSSSelector = r;
})(Vo || (Vo = {}));
(function(n) {
  n.add = new n("add", { fontCharacter: "\\ea60" }), n.plus = new n("plus", { fontCharacter: "\\ea60" }), n.gistNew = new n("gist-new", { fontCharacter: "\\ea60" }), n.repoCreate = new n("repo-create", { fontCharacter: "\\ea60" }), n.lightbulb = new n("lightbulb", { fontCharacter: "\\ea61" }), n.lightBulb = new n("light-bulb", { fontCharacter: "\\ea61" }), n.repo = new n("repo", { fontCharacter: "\\ea62" }), n.repoDelete = new n("repo-delete", { fontCharacter: "\\ea62" }), n.gistFork = new n("gist-fork", { fontCharacter: "\\ea63" }), n.repoForked = new n("repo-forked", { fontCharacter: "\\ea63" }), n.gitPullRequest = new n("git-pull-request", { fontCharacter: "\\ea64" }), n.gitPullRequestAbandoned = new n("git-pull-request-abandoned", { fontCharacter: "\\ea64" }), n.recordKeys = new n("record-keys", { fontCharacter: "\\ea65" }), n.keyboard = new n("keyboard", { fontCharacter: "\\ea65" }), n.tag = new n("tag", { fontCharacter: "\\ea66" }), n.tagAdd = new n("tag-add", { fontCharacter: "\\ea66" }), n.tagRemove = new n("tag-remove", { fontCharacter: "\\ea66" }), n.person = new n("person", { fontCharacter: "\\ea67" }), n.personFollow = new n("person-follow", { fontCharacter: "\\ea67" }), n.personOutline = new n("person-outline", { fontCharacter: "\\ea67" }), n.personFilled = new n("person-filled", { fontCharacter: "\\ea67" }), n.gitBranch = new n("git-branch", { fontCharacter: "\\ea68" }), n.gitBranchCreate = new n("git-branch-create", { fontCharacter: "\\ea68" }), n.gitBranchDelete = new n("git-branch-delete", { fontCharacter: "\\ea68" }), n.sourceControl = new n("source-control", { fontCharacter: "\\ea68" }), n.mirror = new n("mirror", { fontCharacter: "\\ea69" }), n.mirrorPublic = new n("mirror-public", { fontCharacter: "\\ea69" }), n.star = new n("star", { fontCharacter: "\\ea6a" }), n.starAdd = new n("star-add", { fontCharacter: "\\ea6a" }), n.starDelete = new n("star-delete", { fontCharacter: "\\ea6a" }), n.starEmpty = new n("star-empty", { fontCharacter: "\\ea6a" }), n.comment = new n("comment", { fontCharacter: "\\ea6b" }), n.commentAdd = new n("comment-add", { fontCharacter: "\\ea6b" }), n.alert = new n("alert", { fontCharacter: "\\ea6c" }), n.warning = new n("warning", { fontCharacter: "\\ea6c" }), n.search = new n("search", { fontCharacter: "\\ea6d" }), n.searchSave = new n("search-save", { fontCharacter: "\\ea6d" }), n.logOut = new n("log-out", { fontCharacter: "\\ea6e" }), n.signOut = new n("sign-out", { fontCharacter: "\\ea6e" }), n.logIn = new n("log-in", { fontCharacter: "\\ea6f" }), n.signIn = new n("sign-in", { fontCharacter: "\\ea6f" }), n.eye = new n("eye", { fontCharacter: "\\ea70" }), n.eyeUnwatch = new n("eye-unwatch", { fontCharacter: "\\ea70" }), n.eyeWatch = new n("eye-watch", { fontCharacter: "\\ea70" }), n.circleFilled = new n("circle-filled", { fontCharacter: "\\ea71" }), n.primitiveDot = new n("primitive-dot", { fontCharacter: "\\ea71" }), n.closeDirty = new n("close-dirty", { fontCharacter: "\\ea71" }), n.debugBreakpoint = new n("debug-breakpoint", { fontCharacter: "\\ea71" }), n.debugBreakpointDisabled = new n("debug-breakpoint-disabled", { fontCharacter: "\\ea71" }), n.debugHint = new n("debug-hint", { fontCharacter: "\\ea71" }), n.primitiveSquare = new n("primitive-square", { fontCharacter: "\\ea72" }), n.edit = new n("edit", { fontCharacter: "\\ea73" }), n.pencil = new n("pencil", { fontCharacter: "\\ea73" }), n.info = new n("info", { fontCharacter: "\\ea74" }), n.issueOpened = new n("issue-opened", { fontCharacter: "\\ea74" }), n.gistPrivate = new n("gist-private", { fontCharacter: "\\ea75" }), n.gitForkPrivate = new n("git-fork-private", { fontCharacter: "\\ea75" }), n.lock = new n("lock", { fontCharacter: "\\ea75" }), n.mirrorPrivate = new n("mirror-private", { fontCharacter: "\\ea75" }), n.close = new n("close", { fontCharacter: "\\ea76" }), n.removeClose = new n("remove-close", { fontCharacter: "\\ea76" }), n.x = new n("x", { fontCharacter: "\\ea76" }), n.repoSync = new n("repo-sync", { fontCharacter: "\\ea77" }), n.sync = new n("sync", { fontCharacter: "\\ea77" }), n.clone = new n("clone", { fontCharacter: "\\ea78" }), n.desktopDownload = new n("desktop-download", { fontCharacter: "\\ea78" }), n.beaker = new n("beaker", { fontCharacter: "\\ea79" }), n.microscope = new n("microscope", { fontCharacter: "\\ea79" }), n.vm = new n("vm", { fontCharacter: "\\ea7a" }), n.deviceDesktop = new n("device-desktop", { fontCharacter: "\\ea7a" }), n.file = new n("file", { fontCharacter: "\\ea7b" }), n.fileText = new n("file-text", { fontCharacter: "\\ea7b" }), n.more = new n("more", { fontCharacter: "\\ea7c" }), n.ellipsis = new n("ellipsis", { fontCharacter: "\\ea7c" }), n.kebabHorizontal = new n("kebab-horizontal", { fontCharacter: "\\ea7c" }), n.mailReply = new n("mail-reply", { fontCharacter: "\\ea7d" }), n.reply = new n("reply", { fontCharacter: "\\ea7d" }), n.organization = new n("organization", { fontCharacter: "\\ea7e" }), n.organizationFilled = new n("organization-filled", { fontCharacter: "\\ea7e" }), n.organizationOutline = new n("organization-outline", { fontCharacter: "\\ea7e" }), n.newFile = new n("new-file", { fontCharacter: "\\ea7f" }), n.fileAdd = new n("file-add", { fontCharacter: "\\ea7f" }), n.newFolder = new n("new-folder", { fontCharacter: "\\ea80" }), n.fileDirectoryCreate = new n("file-directory-create", { fontCharacter: "\\ea80" }), n.trash = new n("trash", { fontCharacter: "\\ea81" }), n.trashcan = new n("trashcan", { fontCharacter: "\\ea81" }), n.history = new n("history", { fontCharacter: "\\ea82" }), n.clock = new n("clock", { fontCharacter: "\\ea82" }), n.folder = new n("folder", { fontCharacter: "\\ea83" }), n.fileDirectory = new n("file-directory", { fontCharacter: "\\ea83" }), n.symbolFolder = new n("symbol-folder", { fontCharacter: "\\ea83" }), n.logoGithub = new n("logo-github", { fontCharacter: "\\ea84" }), n.markGithub = new n("mark-github", { fontCharacter: "\\ea84" }), n.github = new n("github", { fontCharacter: "\\ea84" }), n.terminal = new n("terminal", { fontCharacter: "\\ea85" }), n.console = new n("console", { fontCharacter: "\\ea85" }), n.repl = new n("repl", { fontCharacter: "\\ea85" }), n.zap = new n("zap", { fontCharacter: "\\ea86" }), n.symbolEvent = new n("symbol-event", { fontCharacter: "\\ea86" }), n.error = new n("error", { fontCharacter: "\\ea87" }), n.stop = new n("stop", { fontCharacter: "\\ea87" }), n.variable = new n("variable", { fontCharacter: "\\ea88" }), n.symbolVariable = new n("symbol-variable", { fontCharacter: "\\ea88" }), n.array = new n("array", { fontCharacter: "\\ea8a" }), n.symbolArray = new n("symbol-array", { fontCharacter: "\\ea8a" }), n.symbolModule = new n("symbol-module", { fontCharacter: "\\ea8b" }), n.symbolPackage = new n("symbol-package", { fontCharacter: "\\ea8b" }), n.symbolNamespace = new n("symbol-namespace", { fontCharacter: "\\ea8b" }), n.symbolObject = new n("symbol-object", { fontCharacter: "\\ea8b" }), n.symbolMethod = new n("symbol-method", { fontCharacter: "\\ea8c" }), n.symbolFunction = new n("symbol-function", { fontCharacter: "\\ea8c" }), n.symbolConstructor = new n("symbol-constructor", { fontCharacter: "\\ea8c" }), n.symbolBoolean = new n("symbol-boolean", { fontCharacter: "\\ea8f" }), n.symbolNull = new n("symbol-null", { fontCharacter: "\\ea8f" }), n.symbolNumeric = new n("symbol-numeric", { fontCharacter: "\\ea90" }), n.symbolNumber = new n("symbol-number", { fontCharacter: "\\ea90" }), n.symbolStructure = new n("symbol-structure", { fontCharacter: "\\ea91" }), n.symbolStruct = new n("symbol-struct", { fontCharacter: "\\ea91" }), n.symbolParameter = new n("symbol-parameter", { fontCharacter: "\\ea92" }), n.symbolTypeParameter = new n("symbol-type-parameter", { fontCharacter: "\\ea92" }), n.symbolKey = new n("symbol-key", { fontCharacter: "\\ea93" }), n.symbolText = new n("symbol-text", { fontCharacter: "\\ea93" }), n.symbolReference = new n("symbol-reference", { fontCharacter: "\\ea94" }), n.goToFile = new n("go-to-file", { fontCharacter: "\\ea94" }), n.symbolEnum = new n("symbol-enum", { fontCharacter: "\\ea95" }), n.symbolValue = new n("symbol-value", { fontCharacter: "\\ea95" }), n.symbolRuler = new n("symbol-ruler", { fontCharacter: "\\ea96" }), n.symbolUnit = new n("symbol-unit", { fontCharacter: "\\ea96" }), n.activateBreakpoints = new n("activate-breakpoints", { fontCharacter: "\\ea97" }), n.archive = new n("archive", { fontCharacter: "\\ea98" }), n.arrowBoth = new n("arrow-both", { fontCharacter: "\\ea99" }), n.arrowDown = new n("arrow-down", { fontCharacter: "\\ea9a" }), n.arrowLeft = new n("arrow-left", { fontCharacter: "\\ea9b" }), n.arrowRight = new n("arrow-right", { fontCharacter: "\\ea9c" }), n.arrowSmallDown = new n("arrow-small-down", { fontCharacter: "\\ea9d" }), n.arrowSmallLeft = new n("arrow-small-left", { fontCharacter: "\\ea9e" }), n.arrowSmallRight = new n("arrow-small-right", { fontCharacter: "\\ea9f" }), n.arrowSmallUp = new n("arrow-small-up", { fontCharacter: "\\eaa0" }), n.arrowUp = new n("arrow-up", { fontCharacter: "\\eaa1" }), n.bell = new n("bell", { fontCharacter: "\\eaa2" }), n.bold = new n("bold", { fontCharacter: "\\eaa3" }), n.book = new n("book", { fontCharacter: "\\eaa4" }), n.bookmark = new n("bookmark", { fontCharacter: "\\eaa5" }), n.debugBreakpointConditionalUnverified = new n("debug-breakpoint-conditional-unverified", { fontCharacter: "\\eaa6" }), n.debugBreakpointConditional = new n("debug-breakpoint-conditional", { fontCharacter: "\\eaa7" }), n.debugBreakpointConditionalDisabled = new n("debug-breakpoint-conditional-disabled", { fontCharacter: "\\eaa7" }), n.debugBreakpointDataUnverified = new n("debug-breakpoint-data-unverified", { fontCharacter: "\\eaa8" }), n.debugBreakpointData = new n("debug-breakpoint-data", { fontCharacter: "\\eaa9" }), n.debugBreakpointDataDisabled = new n("debug-breakpoint-data-disabled", { fontCharacter: "\\eaa9" }), n.debugBreakpointLogUnverified = new n("debug-breakpoint-log-unverified", { fontCharacter: "\\eaaa" }), n.debugBreakpointLog = new n("debug-breakpoint-log", { fontCharacter: "\\eaab" }), n.debugBreakpointLogDisabled = new n("debug-breakpoint-log-disabled", { fontCharacter: "\\eaab" }), n.briefcase = new n("briefcase", { fontCharacter: "\\eaac" }), n.broadcast = new n("broadcast", { fontCharacter: "\\eaad" }), n.browser = new n("browser", { fontCharacter: "\\eaae" }), n.bug = new n("bug", { fontCharacter: "\\eaaf" }), n.calendar = new n("calendar", { fontCharacter: "\\eab0" }), n.caseSensitive = new n("case-sensitive", { fontCharacter: "\\eab1" }), n.check = new n("check", { fontCharacter: "\\eab2" }), n.checklist = new n("checklist", { fontCharacter: "\\eab3" }), n.chevronDown = new n("chevron-down", { fontCharacter: "\\eab4" }), n.chevronLeft = new n("chevron-left", { fontCharacter: "\\eab5" }), n.chevronRight = new n("chevron-right", { fontCharacter: "\\eab6" }), n.chevronUp = new n("chevron-up", { fontCharacter: "\\eab7" }), n.chromeClose = new n("chrome-close", { fontCharacter: "\\eab8" }), n.chromeMaximize = new n("chrome-maximize", { fontCharacter: "\\eab9" }), n.chromeMinimize = new n("chrome-minimize", { fontCharacter: "\\eaba" }), n.chromeRestore = new n("chrome-restore", { fontCharacter: "\\eabb" }), n.circleOutline = new n("circle-outline", { fontCharacter: "\\eabc" }), n.debugBreakpointUnverified = new n("debug-breakpoint-unverified", { fontCharacter: "\\eabc" }), n.circleSlash = new n("circle-slash", { fontCharacter: "\\eabd" }), n.circuitBoard = new n("circuit-board", { fontCharacter: "\\eabe" }), n.clearAll = new n("clear-all", { fontCharacter: "\\eabf" }), n.clippy = new n("clippy", { fontCharacter: "\\eac0" }), n.closeAll = new n("close-all", { fontCharacter: "\\eac1" }), n.cloudDownload = new n("cloud-download", { fontCharacter: "\\eac2" }), n.cloudUpload = new n("cloud-upload", { fontCharacter: "\\eac3" }), n.code = new n("code", { fontCharacter: "\\eac4" }), n.collapseAll = new n("collapse-all", { fontCharacter: "\\eac5" }), n.colorMode = new n("color-mode", { fontCharacter: "\\eac6" }), n.commentDiscussion = new n("comment-discussion", { fontCharacter: "\\eac7" }), n.compareChanges = new n("compare-changes", { fontCharacter: "\\eafd" }), n.creditCard = new n("credit-card", { fontCharacter: "\\eac9" }), n.dash = new n("dash", { fontCharacter: "\\eacc" }), n.dashboard = new n("dashboard", { fontCharacter: "\\eacd" }), n.database = new n("database", { fontCharacter: "\\eace" }), n.debugContinue = new n("debug-continue", { fontCharacter: "\\eacf" }), n.debugDisconnect = new n("debug-disconnect", { fontCharacter: "\\ead0" }), n.debugPause = new n("debug-pause", { fontCharacter: "\\ead1" }), n.debugRestart = new n("debug-restart", { fontCharacter: "\\ead2" }), n.debugStart = new n("debug-start", { fontCharacter: "\\ead3" }), n.debugStepInto = new n("debug-step-into", { fontCharacter: "\\ead4" }), n.debugStepOut = new n("debug-step-out", { fontCharacter: "\\ead5" }), n.debugStepOver = new n("debug-step-over", { fontCharacter: "\\ead6" }), n.debugStop = new n("debug-stop", { fontCharacter: "\\ead7" }), n.debug = new n("debug", { fontCharacter: "\\ead8" }), n.deviceCameraVideo = new n("device-camera-video", { fontCharacter: "\\ead9" }), n.deviceCamera = new n("device-camera", { fontCharacter: "\\eada" }), n.deviceMobile = new n("device-mobile", { fontCharacter: "\\eadb" }), n.diffAdded = new n("diff-added", { fontCharacter: "\\eadc" }), n.diffIgnored = new n("diff-ignored", { fontCharacter: "\\eadd" }), n.diffModified = new n("diff-modified", { fontCharacter: "\\eade" }), n.diffRemoved = new n("diff-removed", { fontCharacter: "\\eadf" }), n.diffRenamed = new n("diff-renamed", { fontCharacter: "\\eae0" }), n.diff = new n("diff", { fontCharacter: "\\eae1" }), n.discard = new n("discard", { fontCharacter: "\\eae2" }), n.editorLayout = new n("editor-layout", { fontCharacter: "\\eae3" }), n.emptyWindow = new n("empty-window", { fontCharacter: "\\eae4" }), n.exclude = new n("exclude", { fontCharacter: "\\eae5" }), n.extensions = new n("extensions", { fontCharacter: "\\eae6" }), n.eyeClosed = new n("eye-closed", { fontCharacter: "\\eae7" }), n.fileBinary = new n("file-binary", { fontCharacter: "\\eae8" }), n.fileCode = new n("file-code", { fontCharacter: "\\eae9" }), n.fileMedia = new n("file-media", { fontCharacter: "\\eaea" }), n.filePdf = new n("file-pdf", { fontCharacter: "\\eaeb" }), n.fileSubmodule = new n("file-submodule", { fontCharacter: "\\eaec" }), n.fileSymlinkDirectory = new n("file-symlink-directory", { fontCharacter: "\\eaed" }), n.fileSymlinkFile = new n("file-symlink-file", { fontCharacter: "\\eaee" }), n.fileZip = new n("file-zip", { fontCharacter: "\\eaef" }), n.files = new n("files", { fontCharacter: "\\eaf0" }), n.filter = new n("filter", { fontCharacter: "\\eaf1" }), n.flame = new n("flame", { fontCharacter: "\\eaf2" }), n.foldDown = new n("fold-down", { fontCharacter: "\\eaf3" }), n.foldUp = new n("fold-up", { fontCharacter: "\\eaf4" }), n.fold = new n("fold", { fontCharacter: "\\eaf5" }), n.folderActive = new n("folder-active", { fontCharacter: "\\eaf6" }), n.folderOpened = new n("folder-opened", { fontCharacter: "\\eaf7" }), n.gear = new n("gear", { fontCharacter: "\\eaf8" }), n.gift = new n("gift", { fontCharacter: "\\eaf9" }), n.gistSecret = new n("gist-secret", { fontCharacter: "\\eafa" }), n.gist = new n("gist", { fontCharacter: "\\eafb" }), n.gitCommit = new n("git-commit", { fontCharacter: "\\eafc" }), n.gitCompare = new n("git-compare", { fontCharacter: "\\eafd" }), n.gitMerge = new n("git-merge", { fontCharacter: "\\eafe" }), n.githubAction = new n("github-action", { fontCharacter: "\\eaff" }), n.githubAlt = new n("github-alt", { fontCharacter: "\\eb00" }), n.globe = new n("globe", { fontCharacter: "\\eb01" }), n.grabber = new n("grabber", { fontCharacter: "\\eb02" }), n.graph = new n("graph", { fontCharacter: "\\eb03" }), n.gripper = new n("gripper", { fontCharacter: "\\eb04" }), n.heart = new n("heart", { fontCharacter: "\\eb05" }), n.home = new n("home", { fontCharacter: "\\eb06" }), n.horizontalRule = new n("horizontal-rule", { fontCharacter: "\\eb07" }), n.hubot = new n("hubot", { fontCharacter: "\\eb08" }), n.inbox = new n("inbox", { fontCharacter: "\\eb09" }), n.issueClosed = new n("issue-closed", { fontCharacter: "\\eb0a" }), n.issueReopened = new n("issue-reopened", { fontCharacter: "\\eb0b" }), n.issues = new n("issues", { fontCharacter: "\\eb0c" }), n.italic = new n("italic", { fontCharacter: "\\eb0d" }), n.jersey = new n("jersey", { fontCharacter: "\\eb0e" }), n.json = new n("json", { fontCharacter: "\\eb0f" }), n.kebabVertical = new n("kebab-vertical", { fontCharacter: "\\eb10" }), n.key = new n("key", { fontCharacter: "\\eb11" }), n.law = new n("law", { fontCharacter: "\\eb12" }), n.lightbulbAutofix = new n("lightbulb-autofix", { fontCharacter: "\\eb13" }), n.linkExternal = new n("link-external", { fontCharacter: "\\eb14" }), n.link = new n("link", { fontCharacter: "\\eb15" }), n.listOrdered = new n("list-ordered", { fontCharacter: "\\eb16" }), n.listUnordered = new n("list-unordered", { fontCharacter: "\\eb17" }), n.liveShare = new n("live-share", { fontCharacter: "\\eb18" }), n.loading = new n("loading", { fontCharacter: "\\eb19" }), n.location = new n("location", { fontCharacter: "\\eb1a" }), n.mailRead = new n("mail-read", { fontCharacter: "\\eb1b" }), n.mail = new n("mail", { fontCharacter: "\\eb1c" }), n.markdown = new n("markdown", { fontCharacter: "\\eb1d" }), n.megaphone = new n("megaphone", { fontCharacter: "\\eb1e" }), n.mention = new n("mention", { fontCharacter: "\\eb1f" }), n.milestone = new n("milestone", { fontCharacter: "\\eb20" }), n.mortarBoard = new n("mortar-board", { fontCharacter: "\\eb21" }), n.move = new n("move", { fontCharacter: "\\eb22" }), n.multipleWindows = new n("multiple-windows", { fontCharacter: "\\eb23" }), n.mute = new n("mute", { fontCharacter: "\\eb24" }), n.noNewline = new n("no-newline", { fontCharacter: "\\eb25" }), n.note = new n("note", { fontCharacter: "\\eb26" }), n.octoface = new n("octoface", { fontCharacter: "\\eb27" }), n.openPreview = new n("open-preview", { fontCharacter: "\\eb28" }), n.package_ = new n("package", { fontCharacter: "\\eb29" }), n.paintcan = new n("paintcan", { fontCharacter: "\\eb2a" }), n.pin = new n("pin", { fontCharacter: "\\eb2b" }), n.play = new n("play", { fontCharacter: "\\eb2c" }), n.run = new n("run", { fontCharacter: "\\eb2c" }), n.plug = new n("plug", { fontCharacter: "\\eb2d" }), n.preserveCase = new n("preserve-case", { fontCharacter: "\\eb2e" }), n.preview = new n("preview", { fontCharacter: "\\eb2f" }), n.project = new n("project", { fontCharacter: "\\eb30" }), n.pulse = new n("pulse", { fontCharacter: "\\eb31" }), n.question = new n("question", { fontCharacter: "\\eb32" }), n.quote = new n("quote", { fontCharacter: "\\eb33" }), n.radioTower = new n("radio-tower", { fontCharacter: "\\eb34" }), n.reactions = new n("reactions", { fontCharacter: "\\eb35" }), n.references = new n("references", { fontCharacter: "\\eb36" }), n.refresh = new n("refresh", { fontCharacter: "\\eb37" }), n.regex = new n("regex", { fontCharacter: "\\eb38" }), n.remoteExplorer = new n("remote-explorer", { fontCharacter: "\\eb39" }), n.remote = new n("remote", { fontCharacter: "\\eb3a" }), n.remove = new n("remove", { fontCharacter: "\\eb3b" }), n.replaceAll = new n("replace-all", { fontCharacter: "\\eb3c" }), n.replace = new n("replace", { fontCharacter: "\\eb3d" }), n.repoClone = new n("repo-clone", { fontCharacter: "\\eb3e" }), n.repoForcePush = new n("repo-force-push", { fontCharacter: "\\eb3f" }), n.repoPull = new n("repo-pull", { fontCharacter: "\\eb40" }), n.repoPush = new n("repo-push", { fontCharacter: "\\eb41" }), n.report = new n("report", { fontCharacter: "\\eb42" }), n.requestChanges = new n("request-changes", { fontCharacter: "\\eb43" }), n.rocket = new n("rocket", { fontCharacter: "\\eb44" }), n.rootFolderOpened = new n("root-folder-opened", { fontCharacter: "\\eb45" }), n.rootFolder = new n("root-folder", { fontCharacter: "\\eb46" }), n.rss = new n("rss", { fontCharacter: "\\eb47" }), n.ruby = new n("ruby", { fontCharacter: "\\eb48" }), n.saveAll = new n("save-all", { fontCharacter: "\\eb49" }), n.saveAs = new n("save-as", { fontCharacter: "\\eb4a" }), n.save = new n("save", { fontCharacter: "\\eb4b" }), n.screenFull = new n("screen-full", { fontCharacter: "\\eb4c" }), n.screenNormal = new n("screen-normal", { fontCharacter: "\\eb4d" }), n.searchStop = new n("search-stop", { fontCharacter: "\\eb4e" }), n.server = new n("server", { fontCharacter: "\\eb50" }), n.settingsGear = new n("settings-gear", { fontCharacter: "\\eb51" }), n.settings = new n("settings", { fontCharacter: "\\eb52" }), n.shield = new n("shield", { fontCharacter: "\\eb53" }), n.smiley = new n("smiley", { fontCharacter: "\\eb54" }), n.sortPrecedence = new n("sort-precedence", { fontCharacter: "\\eb55" }), n.splitHorizontal = new n("split-horizontal", { fontCharacter: "\\eb56" }), n.splitVertical = new n("split-vertical", { fontCharacter: "\\eb57" }), n.squirrel = new n("squirrel", { fontCharacter: "\\eb58" }), n.starFull = new n("star-full", { fontCharacter: "\\eb59" }), n.starHalf = new n("star-half", { fontCharacter: "\\eb5a" }), n.symbolClass = new n("symbol-class", { fontCharacter: "\\eb5b" }), n.symbolColor = new n("symbol-color", { fontCharacter: "\\eb5c" }), n.symbolConstant = new n("symbol-constant", { fontCharacter: "\\eb5d" }), n.symbolEnumMember = new n("symbol-enum-member", { fontCharacter: "\\eb5e" }), n.symbolField = new n("symbol-field", { fontCharacter: "\\eb5f" }), n.symbolFile = new n("symbol-file", { fontCharacter: "\\eb60" }), n.symbolInterface = new n("symbol-interface", { fontCharacter: "\\eb61" }), n.symbolKeyword = new n("symbol-keyword", { fontCharacter: "\\eb62" }), n.symbolMisc = new n("symbol-misc", { fontCharacter: "\\eb63" }), n.symbolOperator = new n("symbol-operator", { fontCharacter: "\\eb64" }), n.symbolProperty = new n("symbol-property", { fontCharacter: "\\eb65" }), n.wrench = new n("wrench", { fontCharacter: "\\eb65" }), n.wrenchSubaction = new n("wrench-subaction", { fontCharacter: "\\eb65" }), n.symbolSnippet = new n("symbol-snippet", { fontCharacter: "\\eb66" }), n.tasklist = new n("tasklist", { fontCharacter: "\\eb67" }), n.telescope = new n("telescope", { fontCharacter: "\\eb68" }), n.textSize = new n("text-size", { fontCharacter: "\\eb69" }), n.threeBars = new n("three-bars", { fontCharacter: "\\eb6a" }), n.thumbsdown = new n("thumbsdown", { fontCharacter: "\\eb6b" }), n.thumbsup = new n("thumbsup", { fontCharacter: "\\eb6c" }), n.tools = new n("tools", { fontCharacter: "\\eb6d" }), n.triangleDown = new n("triangle-down", { fontCharacter: "\\eb6e" }), n.triangleLeft = new n("triangle-left", { fontCharacter: "\\eb6f" }), n.triangleRight = new n("triangle-right", { fontCharacter: "\\eb70" }), n.triangleUp = new n("triangle-up", { fontCharacter: "\\eb71" }), n.twitter = new n("twitter", { fontCharacter: "\\eb72" }), n.unfold = new n("unfold", { fontCharacter: "\\eb73" }), n.unlock = new n("unlock", { fontCharacter: "\\eb74" }), n.unmute = new n("unmute", { fontCharacter: "\\eb75" }), n.unverified = new n("unverified", { fontCharacter: "\\eb76" }), n.verified = new n("verified", { fontCharacter: "\\eb77" }), n.versions = new n("versions", { fontCharacter: "\\eb78" }), n.vmActive = new n("vm-active", { fontCharacter: "\\eb79" }), n.vmOutline = new n("vm-outline", { fontCharacter: "\\eb7a" }), n.vmRunning = new n("vm-running", { fontCharacter: "\\eb7b" }), n.watch = new n("watch", { fontCharacter: "\\eb7c" }), n.whitespace = new n("whitespace", { fontCharacter: "\\eb7d" }), n.wholeWord = new n("whole-word", { fontCharacter: "\\eb7e" }), n.window = new n("window", { fontCharacter: "\\eb7f" }), n.wordWrap = new n("word-wrap", { fontCharacter: "\\eb80" }), n.zoomIn = new n("zoom-in", { fontCharacter: "\\eb81" }), n.zoomOut = new n("zoom-out", { fontCharacter: "\\eb82" }), n.listFilter = new n("list-filter", { fontCharacter: "\\eb83" }), n.listFlat = new n("list-flat", { fontCharacter: "\\eb84" }), n.listSelection = new n("list-selection", { fontCharacter: "\\eb85" }), n.selection = new n("selection", { fontCharacter: "\\eb85" }), n.listTree = new n("list-tree", { fontCharacter: "\\eb86" }), n.debugBreakpointFunctionUnverified = new n("debug-breakpoint-function-unverified", { fontCharacter: "\\eb87" }), n.debugBreakpointFunction = new n("debug-breakpoint-function", { fontCharacter: "\\eb88" }), n.debugBreakpointFunctionDisabled = new n("debug-breakpoint-function-disabled", { fontCharacter: "\\eb88" }), n.debugStackframeActive = new n("debug-stackframe-active", { fontCharacter: "\\eb89" }), n.debugStackframeDot = new n("debug-stackframe-dot", { fontCharacter: "\\eb8a" }), n.debugStackframe = new n("debug-stackframe", { fontCharacter: "\\eb8b" }), n.debugStackframeFocused = new n("debug-stackframe-focused", { fontCharacter: "\\eb8b" }), n.debugBreakpointUnsupported = new n("debug-breakpoint-unsupported", { fontCharacter: "\\eb8c" }), n.symbolString = new n("symbol-string", { fontCharacter: "\\eb8d" }), n.debugReverseContinue = new n("debug-reverse-continue", { fontCharacter: "\\eb8e" }), n.debugStepBack = new n("debug-step-back", { fontCharacter: "\\eb8f" }), n.debugRestartFrame = new n("debug-restart-frame", { fontCharacter: "\\eb90" }), n.callIncoming = new n("call-incoming", { fontCharacter: "\\eb92" }), n.callOutgoing = new n("call-outgoing", { fontCharacter: "\\eb93" }), n.menu = new n("menu", { fontCharacter: "\\eb94" }), n.expandAll = new n("expand-all", { fontCharacter: "\\eb95" }), n.feedback = new n("feedback", { fontCharacter: "\\eb96" }), n.groupByRefType = new n("group-by-ref-type", { fontCharacter: "\\eb97" }), n.ungroupByRefType = new n("ungroup-by-ref-type", { fontCharacter: "\\eb98" }), n.account = new n("account", { fontCharacter: "\\eb99" }), n.bellDot = new n("bell-dot", { fontCharacter: "\\eb9a" }), n.debugConsole = new n("debug-console", { fontCharacter: "\\eb9b" }), n.library = new n("library", { fontCharacter: "\\eb9c" }), n.output = new n("output", { fontCharacter: "\\eb9d" }), n.runAll = new n("run-all", { fontCharacter: "\\eb9e" }), n.syncIgnored = new n("sync-ignored", { fontCharacter: "\\eb9f" }), n.pinned = new n("pinned", { fontCharacter: "\\eba0" }), n.githubInverted = new n("github-inverted", { fontCharacter: "\\eba1" }), n.debugAlt = new n("debug-alt", { fontCharacter: "\\eb91" }), n.serverProcess = new n("server-process", { fontCharacter: "\\eba2" }), n.serverEnvironment = new n("server-environment", { fontCharacter: "\\eba3" }), n.pass = new n("pass", { fontCharacter: "\\eba4" }), n.stopCircle = new n("stop-circle", { fontCharacter: "\\eba5" }), n.playCircle = new n("play-circle", { fontCharacter: "\\eba6" }), n.record = new n("record", { fontCharacter: "\\eba7" }), n.debugAltSmall = new n("debug-alt-small", { fontCharacter: "\\eba8" }), n.vmConnect = new n("vm-connect", { fontCharacter: "\\eba9" }), n.cloud = new n("cloud", { fontCharacter: "\\ebaa" }), n.merge = new n("merge", { fontCharacter: "\\ebab" }), n.exportIcon = new n("export", { fontCharacter: "\\ebac" }), n.graphLeft = new n("graph-left", { fontCharacter: "\\ebad" }), n.magnet = new n("magnet", { fontCharacter: "\\ebae" }), n.notebook = new n("notebook", { fontCharacter: "\\ebaf" }), n.redo = new n("redo", { fontCharacter: "\\ebb0" }), n.checkAll = new n("check-all", { fontCharacter: "\\ebb1" }), n.pinnedDirty = new n("pinned-dirty", { fontCharacter: "\\ebb2" }), n.passFilled = new n("pass-filled", { fontCharacter: "\\ebb3" }), n.circleLargeFilled = new n("circle-large-filled", { fontCharacter: "\\ebb4" }), n.circleLargeOutline = new n("circle-large-outline", { fontCharacter: "\\ebb5" }), n.combine = new n("combine", { fontCharacter: "\\ebb6" }), n.gather = new n("gather", { fontCharacter: "\\ebb6" }), n.table = new n("table", { fontCharacter: "\\ebb7" }), n.variableGroup = new n("variable-group", { fontCharacter: "\\ebb8" }), n.typeHierarchy = new n("type-hierarchy", { fontCharacter: "\\ebb9" }), n.typeHierarchySub = new n("type-hierarchy-sub", { fontCharacter: "\\ebba" }), n.typeHierarchySuper = new n("type-hierarchy-super", { fontCharacter: "\\ebbb" }), n.gitPullRequestCreate = new n("git-pull-request-create", { fontCharacter: "\\ebbc" }), n.runAbove = new n("run-above", { fontCharacter: "\\ebbd" }), n.runBelow = new n("run-below", { fontCharacter: "\\ebbe" }), n.notebookTemplate = new n("notebook-template", { fontCharacter: "\\ebbf" }), n.debugRerun = new n("debug-rerun", { fontCharacter: "\\ebc0" }), n.workspaceTrusted = new n("workspace-trusted", { fontCharacter: "\\ebc1" }), n.workspaceUntrusted = new n("workspace-untrusted", { fontCharacter: "\\ebc2" }), n.workspaceUnspecified = new n("workspace-unspecified", { fontCharacter: "\\ebc3" }), n.terminalCmd = new n("terminal-cmd", { fontCharacter: "\\ebc4" }), n.terminalDebian = new n("terminal-debian", { fontCharacter: "\\ebc5" }), n.terminalLinux = new n("terminal-linux", { fontCharacter: "\\ebc6" }), n.terminalPowershell = new n("terminal-powershell", { fontCharacter: "\\ebc7" }), n.terminalTmux = new n("terminal-tmux", { fontCharacter: "\\ebc8" }), n.terminalUbuntu = new n("terminal-ubuntu", { fontCharacter: "\\ebc9" }), n.terminalBash = new n("terminal-bash", { fontCharacter: "\\ebca" }), n.arrowSwap = new n("arrow-swap", { fontCharacter: "\\ebcb" }), n.copy = new n("copy", { fontCharacter: "\\ebcc" }), n.personAdd = new n("person-add", { fontCharacter: "\\ebcd" }), n.filterFilled = new n("filter-filled", { fontCharacter: "\\ebce" }), n.wand = new n("wand", { fontCharacter: "\\ebcf" }), n.debugLineByLine = new n("debug-line-by-line", { fontCharacter: "\\ebd0" }), n.inspect = new n("inspect", { fontCharacter: "\\ebd1" }), n.dropDownButton = new n("drop-down-button", n.chevronDown.definition);
})(Vi || (Vi = {}));
class DN {
  constructor(e, t) {
    this.language = e, this.id = t;
  }
}
class ra {
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 1792) >>> 8;
  }
  static getFontStyle(e) {
    return (e & 14336) >>> 11;
  }
  static getForeground(e) {
    return (e & 8372224) >>> 14;
  }
  static getBackground(e) {
    return (e & 4286578688) >>> 23;
  }
  static getClassNameFromMetadata(e) {
    let i = "mtk" + this.getForeground(e), r = this.getFontStyle(e);
    return r & 1 && (i += " mtki"), r & 2 && (i += " mtkb"), r & 4 && (i += " mtku"), i;
  }
  static getInlineStyleFromMetadata(e, t) {
    const i = this.getForeground(e), r = this.getFontStyle(e);
    let o = `color: ${t[i]};`;
    return r & 1 && (o += "font-style: italic;"), r & 2 && (o += "font-weight: bold;"), r & 4 && (o += "text-decoration: underline;"), o;
  }
}
const RCe = function() {
  let n = /* @__PURE__ */ Object.create(null);
  return n[
    0
    /* Method */
  ] = "symbol-method", n[
    1
    /* Function */
  ] = "symbol-function", n[
    2
    /* Constructor */
  ] = "symbol-constructor", n[
    3
    /* Field */
  ] = "symbol-field", n[
    4
    /* Variable */
  ] = "symbol-variable", n[
    5
    /* Class */
  ] = "symbol-class", n[
    6
    /* Struct */
  ] = "symbol-struct", n[
    7
    /* Interface */
  ] = "symbol-interface", n[
    8
    /* Module */
  ] = "symbol-module", n[
    9
    /* Property */
  ] = "symbol-property", n[
    10
    /* Event */
  ] = "symbol-event", n[
    11
    /* Operator */
  ] = "symbol-operator", n[
    12
    /* Unit */
  ] = "symbol-unit", n[
    13
    /* Value */
  ] = "symbol-value", n[
    14
    /* Constant */
  ] = "symbol-constant", n[
    15
    /* Enum */
  ] = "symbol-enum", n[
    16
    /* EnumMember */
  ] = "symbol-enum-member", n[
    17
    /* Keyword */
  ] = "symbol-keyword", n[
    27
    /* Snippet */
  ] = "symbol-snippet", n[
    18
    /* Text */
  ] = "symbol-text", n[
    19
    /* Color */
  ] = "symbol-color", n[
    20
    /* File */
  ] = "symbol-file", n[
    21
    /* Reference */
  ] = "symbol-reference", n[
    22
    /* Customcolor */
  ] = "symbol-customcolor", n[
    23
    /* Folder */
  ] = "symbol-folder", n[
    24
    /* TypeParameter */
  ] = "symbol-type-parameter", n[
    25
    /* User */
  ] = "account", n[
    26
    /* Issue */
  ] = "issues", function(e) {
    const t = n[e];
    let i = t && cb.get(t);
    return i || (console.info("No codicon found for CompletionItemKind " + e), i = Vi.symbolProperty), i.classNames;
  };
}();
let TCe = function() {
  let n = /* @__PURE__ */ Object.create(null);
  return n.method = 0, n.function = 1, n.constructor = 2, n.field = 3, n.variable = 4, n.class = 5, n.struct = 6, n.interface = 7, n.module = 8, n.property = 9, n.event = 10, n.operator = 11, n.unit = 12, n.value = 13, n.constant = 14, n.enum = 15, n["enum-member"] = 16, n.enumMember = 16, n.keyword = 17, n.snippet = 27, n.text = 18, n.color = 19, n.file = 20, n.reference = 21, n.customcolor = 22, n.folder = 23, n["type-parameter"] = 24, n.typeParameter = 24, n.account = 25, n.issue = 26, function(e, t) {
    let i = n[e];
    return typeof i > "u" && !t && (i = 9), i;
  };
}();
var KF;
(function(n) {
  n[n.Automatic = 0] = "Automatic", n[n.Explicit = 1] = "Explicit";
})(KF || (KF = {}));
var qF;
(function(n) {
  n[n.Invoke = 1] = "Invoke", n[n.TriggerCharacter = 2] = "TriggerCharacter", n[n.ContentChange = 3] = "ContentChange";
})(qF || (qF = {}));
var YF;
(function(n) {
  n[n.Text = 0] = "Text", n[n.Read = 1] = "Read", n[n.Write = 2] = "Write";
})(YF || (YF = {}));
function OCe(n) {
  return n && dt.isUri(n.uri) && V.isIRange(n.range) && (V.isIRange(n.originSelectionRange) || V.isIRange(n.targetSelectionRange));
}
var XF;
(function(n) {
  const e = /* @__PURE__ */ new Map();
  e.set(
    "file",
    0
    /* File */
  ), e.set(
    "module",
    1
    /* Module */
  ), e.set(
    "namespace",
    2
    /* Namespace */
  ), e.set(
    "package",
    3
    /* Package */
  ), e.set(
    "class",
    4
    /* Class */
  ), e.set(
    "method",
    5
    /* Method */
  ), e.set(
    "property",
    6
    /* Property */
  ), e.set(
    "field",
    7
    /* Field */
  ), e.set(
    "constructor",
    8
    /* Constructor */
  ), e.set(
    "enum",
    9
    /* Enum */
  ), e.set(
    "interface",
    10
    /* Interface */
  ), e.set(
    "function",
    11
    /* Function */
  ), e.set(
    "variable",
    12
    /* Variable */
  ), e.set(
    "constant",
    13
    /* Constant */
  ), e.set(
    "string",
    14
    /* String */
  ), e.set(
    "number",
    15
    /* Number */
  ), e.set(
    "boolean",
    16
    /* Boolean */
  ), e.set(
    "array",
    17
    /* Array */
  ), e.set(
    "object",
    18
    /* Object */
  ), e.set(
    "key",
    19
    /* Key */
  ), e.set(
    "null",
    20
    /* Null */
  ), e.set(
    "enum-member",
    21
    /* EnumMember */
  ), e.set(
    "struct",
    22
    /* Struct */
  ), e.set(
    "event",
    23
    /* Event */
  ), e.set(
    "operator",
    24
    /* Operator */
  ), e.set(
    "type-parameter",
    25
    /* TypeParameter */
  );
  const t = /* @__PURE__ */ new Map();
  t.set(0, "file"), t.set(1, "module"), t.set(2, "namespace"), t.set(3, "package"), t.set(4, "class"), t.set(5, "method"), t.set(6, "property"), t.set(7, "field"), t.set(8, "constructor"), t.set(9, "enum"), t.set(10, "interface"), t.set(11, "function"), t.set(12, "variable"), t.set(13, "constant"), t.set(14, "string"), t.set(15, "number"), t.set(16, "boolean"), t.set(17, "array"), t.set(18, "object"), t.set(19, "key"), t.set(20, "null"), t.set(21, "enum-member"), t.set(22, "struct"), t.set(23, "event"), t.set(24, "operator"), t.set(25, "type-parameter");
  function i(s) {
    return e.get(s);
  }
  n.fromString = i;
  function r(s) {
    return t.get(s);
  }
  n.toString = r;
  function o(s, a) {
    const l = t.get(s);
    let u = l && cb.get("symbol-" + l);
    return u || (console.info("No codicon found for SymbolKind " + s), u = Vi.symbolProperty), `${a ? "inline" : "block"} ${u.classNames}`;
  }
  n.toCssClassName = o;
})(XF || (XF = {}));
class Od {
  /**
   * Creates a new {@link FoldingRangeKind}.
   *
   * @param value of the kind.
   */
  constructor(e) {
    this.value = e;
  }
}
Od.Comment = new Od("comment");
Od.Imports = new Od("imports");
Od.Region = new Od("region");
var ZF;
(function(n) {
  n[n.Other = 0] = "Other", n[n.Type = 1] = "Type", n[n.Parameter = 2] = "Parameter";
})(ZF || (ZF = {}));
const nT = new Bi(), rT = new Bi(), hb = new Bi(), coe = new Bi(), oT = new Bi(), sT = new Bi(), aT = new Bi(), lT = new Bi(), hoe = new Bi(), uT = new Bi(), cT = new Bi(), hT = new Bi(), dT = new Bi(), fT = new Bi(), QF = new Bi(), pT = new Bi(), av = new Bi(), Au = new Bi(), ZG = new Bi(), QG = new Bi(), doe = new Bi(), foe = new Bi(), poe = new Bi(), db = new Bi(), JG = new Bi(), ln = new aoe();
class goe {
  clone() {
    return this;
  }
  equals(e) {
    return this === e;
  }
}
const XS = new goe(), RN = "vs.editor.nullMode", fb = new DN(
  RN,
  0
  /* Null */
);
function moe(n, e, t, i) {
  return new uN([new US(i, "", n)], t);
}
function e5(n, e, t, i) {
  let r = new Uint32Array(2);
  return r[0] = i, r[1] = (n << 0 | 0 << 8 | 0 << 11 | 1 << 14 | 2 << 23) >>> 0, new zS(r, t === null ? XS : t);
}
const voe = "editorWorkerService", tc = Vt(voe), TN = Vt("modeService"), pb = Vt("textModelService"), _oe = "$initialize";
let JF = !1;
function gT(n) {
  BS && (JF || (JF = !0, console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq")), console.warn(n.message));
}
class Coe {
  constructor(e) {
    this._workerId = -1, this._handler = e, this._lastSentReq = 0, this._pendingReplies = /* @__PURE__ */ Object.create(null);
  }
  setWorkerId(e) {
    this._workerId = e;
  }
  sendMessage(e, t) {
    let i = String(++this._lastSentReq);
    return new Promise((r, o) => {
      this._pendingReplies[i] = {
        resolve: r,
        reject: o
      }, this._send({
        vsWorker: this._workerId,
        req: i,
        method: e,
        args: t
      });
    });
  }
  handleMessage(e) {
    !e || !e.vsWorker || this._workerId !== -1 && e.vsWorker !== this._workerId || this._handleMessage(e);
  }
  _handleMessage(e) {
    if (e.seq) {
      let o = e;
      if (!this._pendingReplies[o.seq]) {
        console.warn("Got reply to unknown seq");
        return;
      }
      let s = this._pendingReplies[o.seq];
      if (delete this._pendingReplies[o.seq], o.err) {
        let a = o.err;
        o.err.$isError && (a = new Error(), a.name = o.err.name, a.message = o.err.message, a.stack = o.err.stack), s.reject(a);
        return;
      }
      s.resolve(o.res);
      return;
    }
    let t = e, i = t.req;
    this._handler.handleMessage(t.method, t.args).then((o) => {
      this._send({
        vsWorker: this._workerId,
        seq: i,
        res: o,
        err: void 0
      });
    }, (o) => {
      o.detail instanceof Error && (o.detail = gF(o.detail)), this._send({
        vsWorker: this._workerId,
        seq: i,
        res: void 0,
        err: gF(o)
      });
    });
  }
  _send(e) {
    let t = [];
    if (e.req) {
      const i = e;
      for (let r = 0; r < i.args.length; r++)
        i.args[r] instanceof ArrayBuffer && t.push(i.args[r]);
    } else {
      const i = e;
      i.res instanceof ArrayBuffer && t.push(i.res);
    }
    this._handler.sendMessage(e, t);
  }
}
class yoe extends ge {
  constructor(e, t, i) {
    super();
    let r = null;
    this._worker = this._register(e.create("vs/base/common/worker/simpleWorker", (l) => {
      this._protocol.handleMessage(l);
    }, (l) => {
      r && r(l);
    })), this._protocol = new Coe({
      sendMessage: (l, u) => {
        this._worker.postMessage(l, u);
      },
      handleMessage: (l, u) => {
        if (typeof i[l] != "function")
          return Promise.reject(new Error("Missing method " + l + " on main thread host."));
        try {
          return Promise.resolve(i[l].apply(i, u));
        } catch (c) {
          return Promise.reject(c);
        }
      }
    }), this._protocol.setWorkerId(this._worker.getId());
    let o = null;
    typeof self.require < "u" && typeof self.require.getConfig == "function" ? o = self.require.getConfig() : typeof self.requirejs < "u" && (o = self.requirejs.s.contexts._.config);
    const s = wN(i);
    this._onModuleLoaded = this._protocol.sendMessage(_oe, [
      this._worker.getId(),
      JSON.parse(JSON.stringify(o)),
      t,
      s
    ]);
    const a = (l, u) => this._request(l, u);
    this._lazyProxy = new Promise((l, u) => {
      r = u, this._onModuleLoaded.then((c) => {
        l(UG(c, a));
      }, (c) => {
        u(c), this._onError("Worker failed to load " + t, c);
      });
    });
  }
  getProxyObject() {
    return this._lazyProxy;
  }
  _request(e, t) {
    return new Promise((i, r) => {
      this._onModuleLoaded.then(() => {
        this._protocol.sendMessage(e, t).then(i, r);
      }, r);
    });
  }
  _onError(e, t) {
    console.error(e), console.info(t);
  }
}
var tD;
const ek = (tD = window.trustedTypes) === null || tD === void 0 ? void 0 : tD.createPolicy("defaultWorkerFactory", { createScriptURL: (n) => n });
function woe(n, e) {
  if (gn.MonacoEnvironment) {
    if (typeof gn.MonacoEnvironment.getWorker == "function")
      return gn.MonacoEnvironment.getWorker(n, e);
    if (typeof gn.MonacoEnvironment.getWorkerUrl == "function") {
      const t = gn.MonacoEnvironment.getWorkerUrl(n, e);
      return new Worker(ek ? ek.createScriptURL(t) : t, { name: e });
    }
  }
  throw new Error("You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker");
}
function boe(n) {
  return typeof n.then == "function";
}
class Soe {
  constructor(e, t, i, r, o) {
    this.id = t;
    const s = woe("workerMain.js", i);
    boe(s) ? this.worker = s : this.worker = Promise.resolve(s), this.postMessage(e, []), this.worker.then((a) => {
      a.onmessage = function(l) {
        r(l.data);
      }, a.onmessageerror = o, typeof a.addEventListener == "function" && a.addEventListener("error", o);
    });
  }
  getId() {
    return this.id;
  }
  postMessage(e, t) {
    this.worker && this.worker.then((i) => i.postMessage(e, t));
  }
  dispose() {
    this.worker && this.worker.then((e) => e.terminate()), this.worker = null;
  }
}
class ZS {
  constructor(e) {
    this._label = e, this._webWorkerFailedBeforeError = !1;
  }
  create(e, t, i) {
    let r = ++ZS.LAST_WORKER_ID;
    if (this._webWorkerFailedBeforeError)
      throw this._webWorkerFailedBeforeError;
    return new Soe(e, r, this._label || "anonymous" + r, t, (o) => {
      gT(o), this._webWorkerFailedBeforeError = o, i(o);
    });
  }
}
ZS.LAST_WORKER_ID = 0;
var Ln;
(function(n) {
  n[n.None = 0] = "None", n[n.Indent = 1] = "Indent", n[n.IndentOutdent = 2] = "IndentOutdent", n[n.Outdent = 3] = "Outdent";
})(Ln || (Ln = {}));
class iD {
  constructor(e) {
    if (this.open = e.open, this.close = e.close, this._standardTokenMask = 0, Array.isArray(e.notIn))
      for (let t = 0, i = e.notIn.length; t < i; t++)
        switch (e.notIn[t]) {
          case "string":
            this._standardTokenMask |= 2;
            break;
          case "comment":
            this._standardTokenMask |= 1;
            break;
          case "regex":
            this._standardTokenMask |= 4;
            break;
        }
  }
  isOK(e) {
    return (this._standardTokenMask & e) === 0;
  }
}
class Eoe {
  constructor(e) {
    this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
    for (const t of e)
      Lm(this.autoClosingPairsOpenByStart, t.open.charAt(0), t), Lm(this.autoClosingPairsOpenByEnd, t.open.charAt(t.open.length - 1), t), Lm(this.autoClosingPairsCloseByStart, t.close.charAt(0), t), Lm(this.autoClosingPairsCloseByEnd, t.close.charAt(t.close.length - 1), t), t.close.length === 1 && t.open.length === 1 && Lm(this.autoClosingPairsCloseSingleChar, t.close, t);
  }
}
function Lm(n, e, t) {
  n.has(e) ? n.get(e).push(t) : n.set(e, [t]);
}
function uy(n, e) {
  let t = n.getCount(), i = n.findTokenIndexAtOffset(e), r = n.getLanguageId(i), o = i;
  for (; o + 1 < t && n.getLanguageId(o + 1) === r; )
    o++;
  let s = i;
  for (; s > 0 && n.getLanguageId(s - 1) === r; )
    s--;
  return new Loe(n, r, s, o + 1, n.getStartOffset(s), n.getEndOffset(o));
}
class Loe {
  constructor(e, t, i, r, o, s) {
    this._actual = e, this.languageId = t, this._firstTokenIndex = i, this._lastTokenIndex = r, this.firstCharOffset = o, this._lastCharOffset = s;
  }
  getLineContent() {
    return this._actual.getLineContent().substring(this.firstCharOffset, this._lastCharOffset);
  }
  getActualLineContentBefore(e) {
    return this._actual.getLineContent().substring(0, this.firstCharOffset + e);
  }
  getTokenCount() {
    return this._lastTokenIndex - this._firstTokenIndex;
  }
  findTokenIndexAtOffset(e) {
    return this._actual.findTokenIndexAtOffset(e + this.firstCharOffset) - this._firstTokenIndex;
  }
  getStandardTokenType(e) {
    return this._actual.getStandardTokenType(e + this._firstTokenIndex);
  }
}
function Ll(n) {
  return (n & 7) !== 0;
}
class Up {
  constructor(e) {
    if (e.autoClosingPairs ? this._autoClosingPairs = e.autoClosingPairs.map((t) => new iD(t)) : e.brackets ? this._autoClosingPairs = e.brackets.map((t) => new iD({ open: t[0], close: t[1] })) : this._autoClosingPairs = [], e.__electricCharacterSupport && e.__electricCharacterSupport.docComment) {
      const t = e.__electricCharacterSupport.docComment;
      this._autoClosingPairs.push(new iD({ open: t.open, close: t.close || "" }));
    }
    this._autoCloseBefore = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : Up.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED, this._surroundingPairs = e.surroundingPairs || this._autoClosingPairs;
  }
  getAutoClosingPairs() {
    return this._autoClosingPairs;
  }
  getAutoCloseBeforeSet() {
    return this._autoCloseBefore;
  }
  static shouldAutoClosePair(e, t, i) {
    if (t.getTokenCount() === 0)
      return !0;
    const r = t.findTokenIndexAtOffset(i - 2), o = t.getStandardTokenType(r);
    return e.isOK(o);
  }
  getSurroundingPairs() {
    return this._surroundingPairs;
  }
}
Up.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = `;:.,=}])> 
	`;
let nD;
function t5() {
  return nD || (nD = new TextDecoder("UTF-16LE")), nD;
}
let rD;
function Doe() {
  return rD || (rD = new TextDecoder("UTF-16BE")), rD;
}
let oD;
function i5() {
  return oD || (oD = J4() ? t5() : Doe()), oD;
}
const n5 = typeof TextDecoder < "u";
let zp, mT;
n5 ? (zp = (n) => new Toe(n), mT = Roe) : (zp = (n) => new Ooe(), mT = r5);
function Roe(n, e, t) {
  const i = new Uint16Array(n.buffer, e, t);
  return t > 0 && (i[0] === 65279 || i[0] === 65534) ? r5(n, e, t) : t5().decode(i);
}
function r5(n, e, t) {
  let i = [], r = 0;
  for (let o = 0; o < t; o++) {
    const s = Cre(n, e);
    e += 2, i[r++] = String.fromCharCode(s);
  }
  return i.join("");
}
class Toe {
  constructor(e) {
    this._capacity = e | 0, this._buffer = new Uint16Array(this._capacity), this._completedStrings = null, this._bufferLength = 0;
  }
  reset() {
    this._completedStrings = null, this._bufferLength = 0;
  }
  build() {
    return this._completedStrings !== null ? (this._flushBuffer(), this._completedStrings.join("")) : this._buildBuffer();
  }
  _buildBuffer() {
    if (this._bufferLength === 0)
      return "";
    const e = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
    return i5().decode(e);
  }
  _flushBuffer() {
    const e = this._buildBuffer();
    this._bufferLength = 0, this._completedStrings === null ? this._completedStrings = [e] : this._completedStrings[this._completedStrings.length] = e;
  }
  write1(e) {
    const t = this._capacity - this._bufferLength;
    t <= 1 && (t === 0 || jn(e)) && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  appendASCII(e) {
    this._bufferLength === this._capacity && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  appendASCIIString(e) {
    const t = e.length;
    if (this._bufferLength + t >= this._capacity) {
      this._flushBuffer(), this._completedStrings[this._completedStrings.length] = e;
      return;
    }
    for (let i = 0; i < t; i++)
      this._buffer[this._bufferLength++] = e.charCodeAt(i);
  }
}
class Ooe {
  constructor() {
    this._pieces = [], this._piecesLen = 0;
  }
  reset() {
    this._pieces = [], this._piecesLen = 0;
  }
  build() {
    return this._pieces.join("");
  }
  write1(e) {
    this._pieces[this._piecesLen++] = String.fromCharCode(e);
  }
  appendASCII(e) {
    this._pieces[this._piecesLen++] = String.fromCharCode(e);
  }
  appendASCIIString(e) {
    this._pieces[this._piecesLen++] = e;
  }
}
class gb {
  constructor(e, t, i, r, o, s) {
    this.languageIdentifier = e, this.index = t, this.open = i, this.close = r, this.forwardRegex = o, this.reversedRegex = s, this._openSet = gb._toSet(this.open), this._closeSet = gb._toSet(this.close);
  }
  isOpen(e) {
    return this._openSet.has(e);
  }
  isClose(e) {
    return this._closeSet.has(e);
  }
  static _toSet(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      t.add(i);
    return t;
  }
}
function xoe(n) {
  const e = n.length;
  n = n.map((s) => [s[0].toLowerCase(), s[1].toLowerCase()]);
  const t = [];
  for (let s = 0; s < e; s++)
    t[s] = s;
  const i = (s, a) => {
    const [l, u] = s, [c, h] = a;
    return l === c || l === h || u === c || u === h;
  }, r = (s, a) => {
    const l = Math.min(s, a), u = Math.max(s, a);
    for (let c = 0; c < e; c++)
      t[c] === u && (t[c] = l);
  };
  for (let s = 0; s < e; s++) {
    const a = n[s];
    for (let l = s + 1; l < e; l++) {
      const u = n[l];
      i(a, u) && r(t[s], t[l]);
    }
  }
  const o = [];
  for (let s = 0; s < e; s++) {
    let a = [], l = [];
    for (let u = 0; u < e; u++)
      if (t[u] === s) {
        const [c, h] = n[u];
        a.push(c), l.push(h);
      }
    a.length > 0 && o.push({
      open: a,
      close: l
    });
  }
  return o;
}
class Noe {
  constructor(e, t) {
    const i = xoe(t);
    this.brackets = i.map((r, o) => new gb(e, o, r.open, r.close, Ioe(r.open, r.close, i, o), Poe(r.open, r.close, i, o))), this.forwardRegex = Aoe(this.brackets), this.reversedRegex = Moe(this.brackets), this.textIsBracket = {}, this.textIsOpenBracket = {}, this.maxBracketLength = 0;
    for (const r of this.brackets) {
      for (const o of r.open)
        this.textIsBracket[o] = r, this.textIsOpenBracket[o] = !0, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
      for (const o of r.close)
        this.textIsBracket[o] = r, this.textIsOpenBracket[o] = !1, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
    }
  }
}
function o5(n, e, t, i) {
  for (let r = 0, o = e.length; r < o; r++) {
    if (r === t)
      continue;
    const s = e[r];
    for (const a of s.open)
      a.indexOf(n) >= 0 && i.push(a);
    for (const a of s.close)
      a.indexOf(n) >= 0 && i.push(a);
  }
}
function s5(n, e) {
  return n.length - e.length;
}
function QS(n) {
  if (n.length <= 1)
    return n;
  const e = [], t = /* @__PURE__ */ new Set();
  for (const i of n)
    t.has(i) || (e.push(i), t.add(i));
  return e;
}
function Ioe(n, e, t, i) {
  let r = [];
  r = r.concat(n), r = r.concat(e);
  for (let o = 0, s = r.length; o < s; o++)
    o5(r[o], t, i, r);
  return r = QS(r), r.sort(s5), r.reverse(), JS(r);
}
function Poe(n, e, t, i) {
  let r = [];
  r = r.concat(n), r = r.concat(e);
  for (let o = 0, s = r.length; o < s; o++)
    o5(r[o], t, i, r);
  return r = QS(r), r.sort(s5), r.reverse(), JS(r.map(ON));
}
function Aoe(n) {
  let e = [];
  for (const t of n) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = QS(e), JS(e);
}
function Moe(n) {
  let e = [];
  for (const t of n) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = QS(e), JS(e.map(ON));
}
function Foe(n) {
  const e = /^[\w ]+$/.test(n);
  return n = Bp(n), e ? `\\b${n}\\b` : n;
}
function JS(n) {
  let e = `(${n.map(Foe).join(")|(")})`;
  return MG(e, !0);
}
const ON = function() {
  function n(i) {
    if (n5) {
      const r = new Uint16Array(i.length);
      let o = 0;
      for (let s = i.length - 1; s >= 0; s--)
        r[o++] = i.charCodeAt(s);
      return i5().decode(r);
    } else {
      let r = [], o = 0;
      for (let s = i.length - 1; s >= 0; s--)
        r[o++] = i.charAt(s);
      return r.join("");
    }
  }
  let e = null, t = null;
  return function(r) {
    return e !== r && (e = r, t = n(e)), t;
  };
}();
class Zs {
  static _findPrevBracketInText(e, t, i, r) {
    let o = i.match(e);
    if (!o)
      return null;
    let s = i.length - (o.index || 0), a = o[0].length, l = r + s;
    return new V(t, l - a + 1, t, l + 1);
  }
  static findPrevBracketInRange(e, t, i, r, o) {
    const a = ON(i).substring(i.length - o, i.length - r);
    return this._findPrevBracketInText(e, t, a, r);
  }
  static findNextBracketInText(e, t, i, r) {
    let o = i.match(e);
    if (!o)
      return null;
    let s = o.index || 0, a = o[0].length;
    if (a === 0)
      return null;
    let l = r + s;
    return new V(t, l + 1, t, l + 1 + a);
  }
  static findNextBracketInRange(e, t, i, r, o) {
    const s = i.substring(r, o);
    return this.findNextBracketInText(e, t, s, r);
  }
}
class koe {
  constructor(e) {
    this._richEditBrackets = e;
  }
  getElectricCharacters() {
    let e = [];
    if (this._richEditBrackets)
      for (const t of this._richEditBrackets.brackets)
        for (const i of t.close) {
          const r = i.charAt(i.length - 1);
          e.push(r);
        }
    return e = e.filter((t, i, r) => r.indexOf(t) === i), e;
  }
  onElectricCharacter(e, t, i) {
    if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0)
      return null;
    const r = t.findTokenIndexAtOffset(i - 1);
    if (Ll(t.getStandardTokenType(r)))
      return null;
    const o = this._richEditBrackets.reversedRegex, s = t.getLineContent().substring(0, i - 1) + e, a = Zs.findPrevBracketInRange(o, 1, s, 0, s.length);
    if (!a)
      return null;
    const l = s.substring(a.startColumn - 1, a.endColumn - 1).toLowerCase();
    if (this._richEditBrackets.textIsOpenBracket[l])
      return null;
    const c = t.getActualLineContentBefore(a.startColumn - 1);
    return /^\s*$/.test(c) ? {
      matchOpenBracket: l
    } : null;
  }
}
function cy(n) {
  return n.global && (n.lastIndex = 0), !0;
}
class Woe {
  constructor(e) {
    this._indentationRules = e;
  }
  shouldIncrease(e) {
    return !!(this._indentationRules && this._indentationRules.increaseIndentPattern && cy(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(e));
  }
  shouldDecrease(e) {
    return !!(this._indentationRules && this._indentationRules.decreaseIndentPattern && cy(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(e));
  }
  shouldIndentNextLine(e) {
    return !!(this._indentationRules && this._indentationRules.indentNextLinePattern && cy(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(e));
  }
  shouldIgnore(e) {
    return !!(this._indentationRules && this._indentationRules.unIndentedLinePattern && cy(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(e));
  }
  getIndentMetadata(e) {
    let t = 0;
    return this.shouldIncrease(e) && (t += 1), this.shouldDecrease(e) && (t += 2), this.shouldIndentNextLine(e) && (t += 4), this.shouldIgnore(e) && (t += 8), t;
  }
}
class qf {
  constructor(e) {
    e = e || {}, e.brackets = e.brackets || [
      ["(", ")"],
      ["{", "}"],
      ["[", "]"]
    ], this._brackets = [], e.brackets.forEach((t) => {
      const i = qf._createOpenBracketRegExp(t[0]), r = qf._createCloseBracketRegExp(t[1]);
      i && r && this._brackets.push({
        open: t[0],
        openRegExp: i,
        close: t[1],
        closeRegExp: r
      });
    }), this._regExpRules = e.onEnterRules || [];
  }
  onEnter(e, t, i, r) {
    if (e >= 3)
      for (let o = 0, s = this._regExpRules.length; o < s; o++) {
        let a = this._regExpRules[o];
        if ([{
          reg: a.beforeText,
          text: i
        }, {
          reg: a.afterText,
          text: r
        }, {
          reg: a.previousLineText,
          text: t
        }].every((u) => u.reg ? (u.reg.lastIndex = 0, u.reg.test(u.text)) : !0))
          return a.action;
      }
    if (e >= 2 && i.length > 0 && r.length > 0)
      for (let o = 0, s = this._brackets.length; o < s; o++) {
        let a = this._brackets[o];
        if (a.openRegExp.test(i) && a.closeRegExp.test(r))
          return { indentAction: Ln.IndentOutdent };
      }
    if (e >= 2 && i.length > 0) {
      for (let o = 0, s = this._brackets.length; o < s; o++)
        if (this._brackets[o].openRegExp.test(i))
          return { indentAction: Ln.Indent };
    }
    return null;
  }
  static _createOpenBracketRegExp(e) {
    let t = Bp(e);
    return /\B/.test(t.charAt(0)) || (t = "\\b" + t), t += "\\s*$", qf._safeRegExp(t);
  }
  static _createCloseBracketRegExp(e) {
    let t = Bp(e);
    return /\B/.test(t.charAt(t.length - 1)) || (t = t + "\\b"), t = "^\\s*" + t, qf._safeRegExp(t);
  }
  static _safeRegExp(e) {
    try {
      return new RegExp(e);
    } catch (t) {
      return Ni(t), null;
    }
  }
}
class xN {
  constructor(e, t) {
    this._languageIdentifier = e, this._brackets = null, this._electricCharacter = null, this._conf = t, this._onEnterSupport = this._conf.brackets || this._conf.indentationRules || this._conf.onEnterRules ? new qf(this._conf) : null, this.comments = xN._handleComments(this._conf), this.characterPair = new Up(this._conf), this.wordDefinition = this._conf.wordPattern || tG, this.indentationRules = this._conf.indentationRules, this._conf.indentationRules ? this.indentRulesSupport = new Woe(this._conf.indentationRules) : this.indentRulesSupport = null, this.foldingRules = this._conf.folding || {};
  }
  get brackets() {
    return !this._brackets && this._conf.brackets && (this._brackets = new Noe(this._languageIdentifier, this._conf.brackets)), this._brackets;
  }
  get electricCharacter() {
    return this._electricCharacter || (this._electricCharacter = new koe(this.brackets)), this._electricCharacter;
  }
  onEnter(e, t, i, r) {
    return this._onEnterSupport ? this._onEnterSupport.onEnter(e, t, i, r) : null;
  }
  static _handleComments(e) {
    let t = e.comments;
    if (!t)
      return null;
    let i = {};
    if (t.lineComment && (i.lineCommentToken = t.lineComment), t.blockComment) {
      let [r, o] = t.blockComment;
      i.blockCommentStartToken = r, i.blockCommentEndToken = o;
    }
    return i;
  }
}
class tk {
  constructor(e) {
    this.languageIdentifier = e;
  }
}
class ik {
  constructor(e, t, i) {
    this.configuration = e, this.priority = t, this.order = i;
  }
  static cmp(e, t) {
    return e.priority === t.priority ? e.order - t.order : e.priority - t.priority;
  }
}
class Voe {
  constructor(e) {
    this.languageIdentifier = e, this._resolved = null, this._entries = [], this._order = 0, this._resolved = null;
  }
  register(e, t) {
    const i = new ik(e, t, ++this._order);
    return this._entries.push(i), this._resolved = null, Ri(() => {
      for (let r = 0; r < this._entries.length; r++)
        if (this._entries[r] === i) {
          this._entries.splice(r, 1), this._resolved = null;
          break;
        }
    });
  }
  getRichEditSupport() {
    if (!this._resolved) {
      const e = this._resolve();
      e && (this._resolved = new xN(this.languageIdentifier, e));
    }
    return this._resolved;
  }
  _resolve() {
    if (this._entries.length === 0)
      return null;
    this._entries.sort(ik.cmp);
    const e = {};
    for (const t of this._entries) {
      const i = t.configuration;
      e.comments = i.comments || e.comments, e.brackets = i.brackets || e.brackets, e.wordPattern = i.wordPattern || e.wordPattern, e.indentationRules = i.indentationRules || e.indentationRules, e.onEnterRules = i.onEnterRules || e.onEnterRules, e.autoClosingPairs = i.autoClosingPairs || e.autoClosingPairs, e.surroundingPairs = i.surroundingPairs || e.surroundingPairs, e.autoCloseBefore = i.autoCloseBefore || e.autoCloseBefore, e.folding = i.folding || e.folding, e.__electricCharacterSupport = i.__electricCharacterSupport || e.__electricCharacterSupport;
    }
    return e;
  }
}
class Boe {
  constructor() {
    this._entries2 = /* @__PURE__ */ new Map(), this._onDidChange = new j(), this.onDidChange = this._onDidChange.event;
  }
  /**
   * @param priority Use a higher number for higher priority
   */
  register(e, t, i = 0) {
    let r = this._entries2.get(e.id);
    r || (r = new Voe(e), this._entries2.set(e.id, r));
    const o = r.register(t, i);
    return this._onDidChange.fire(new tk(e)), Ri(() => {
      o.dispose(), this._onDidChange.fire(new tk(e));
    });
  }
  _getRichEditSupport(e) {
    const t = this._entries2.get(e);
    return t ? t.getRichEditSupport() : null;
  }
  getIndentationRules(e) {
    const t = this._getRichEditSupport(e);
    return t && t.indentationRules || null;
  }
  // begin electricCharacter
  _getElectricCharacterSupport(e) {
    let t = this._getRichEditSupport(e);
    return t && t.electricCharacter || null;
  }
  getElectricCharacters(e) {
    let t = this._getElectricCharacterSupport(e);
    return t ? t.getElectricCharacters() : [];
  }
  /**
   * Should return opening bracket type to match indentation with
   */
  onElectricCharacter(e, t, i) {
    let r = uy(t, i - 1), o = this._getElectricCharacterSupport(r.languageId);
    return o ? o.onElectricCharacter(e, r, i - r.firstCharOffset) : null;
  }
  // end electricCharacter
  getComments(e) {
    let t = this._getRichEditSupport(e);
    return t && t.comments || null;
  }
  // begin characterPair
  _getCharacterPairSupport(e) {
    let t = this._getRichEditSupport(e);
    return t && t.characterPair || null;
  }
  getAutoClosingPairs(e) {
    const t = this._getCharacterPairSupport(e);
    return new Eoe(t ? t.getAutoClosingPairs() : []);
  }
  getAutoCloseBeforeSet(e) {
    let t = this._getCharacterPairSupport(e);
    return t ? t.getAutoCloseBeforeSet() : Up.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;
  }
  getSurroundingPairs(e) {
    let t = this._getCharacterPairSupport(e);
    return t ? t.getSurroundingPairs() : [];
  }
  shouldAutoClosePair(e, t, i) {
    const r = uy(t, i - 1);
    return Up.shouldAutoClosePair(e, r, i - r.firstCharOffset);
  }
  // end characterPair
  getWordDefinition(e) {
    let t = this._getRichEditSupport(e);
    return q1(t && t.wordDefinition || null);
  }
  getFoldingRules(e) {
    let t = this._getRichEditSupport(e);
    return t ? t.foldingRules : {};
  }
  // begin Indent Rules
  getIndentRulesSupport(e) {
    let t = this._getRichEditSupport(e);
    return t && t.indentRulesSupport || null;
  }
  /**
   * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.
   * Result:
   * -1: run into the boundary of embedded languages
   * 0: every line above are invalid
   * else: nearest preceding line of the same language
   */
  getPrecedingValidLine(e, t, i) {
    let r = e.getLanguageIdAtPosition(t, 0);
    if (t > 1) {
      let o, s = -1;
      for (o = t - 1; o >= 1; o--) {
        if (e.getLanguageIdAtPosition(o, 0) !== r)
          return s;
        let a = e.getLineContent(o);
        if (i.shouldIgnore(a) || /^\s+$/.test(a) || a === "") {
          s = o;
          continue;
        }
        return o;
      }
    }
    return -1;
  }
  /**
   * Get inherited indentation from above lines.
   * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.
   * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.
   * 3. If this line doesn't match any indent rules
   *   a. check whether the line above it matches indentNextLinePattern
   *   b. If not, the indent level of this line is the result
   *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).
   * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`
   *
   * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.
   */
  getInheritIndentForLine(e, t, i, r = !0) {
    if (e < 4)
      return null;
    const o = this.getIndentRulesSupport(t.getLanguageIdentifier().id);
    if (!o)
      return null;
    if (i <= 1)
      return {
        indentation: "",
        action: null
      };
    const s = this.getPrecedingValidLine(t, i, o);
    if (s < 0)
      return null;
    if (s < 1)
      return {
        indentation: "",
        action: null
      };
    const a = t.getLineContent(s);
    if (o.shouldIncrease(a) || o.shouldIndentNextLine(a))
      return {
        indentation: Pr(a),
        action: Ln.Indent,
        line: s
      };
    if (o.shouldDecrease(a))
      return {
        indentation: Pr(a),
        action: null,
        line: s
      };
    {
      if (s === 1)
        return {
          indentation: Pr(t.getLineContent(s)),
          action: null,
          line: s
        };
      const l = s - 1, u = o.getIndentMetadata(t.getLineContent(l));
      if (!(u & 3) && u & 4) {
        let c = 0;
        for (let h = l - 1; h > 0; h--)
          if (!o.shouldIndentNextLine(t.getLineContent(h))) {
            c = h;
            break;
          }
        return {
          indentation: Pr(t.getLineContent(c + 1)),
          action: null,
          line: c + 1
        };
      }
      if (r)
        return {
          indentation: Pr(t.getLineContent(s)),
          action: null,
          line: s
        };
      for (let c = s; c > 0; c--) {
        const h = t.getLineContent(c);
        if (o.shouldIncrease(h))
          return {
            indentation: Pr(h),
            action: Ln.Indent,
            line: c
          };
        if (o.shouldIndentNextLine(h)) {
          let d = 0;
          for (let f = c - 1; f > 0; f--)
            if (!o.shouldIndentNextLine(t.getLineContent(c))) {
              d = f;
              break;
            }
          return {
            indentation: Pr(t.getLineContent(d + 1)),
            action: null,
            line: d + 1
          };
        } else if (o.shouldDecrease(h))
          return {
            indentation: Pr(h),
            action: null,
            line: c
          };
      }
      return {
        indentation: Pr(t.getLineContent(1)),
        action: null,
        line: 1
      };
    }
  }
  getGoodIndentForLine(e, t, i, r, o) {
    if (e < 4)
      return null;
    const s = this._getRichEditSupport(i);
    if (!s)
      return null;
    const a = this.getIndentRulesSupport(i);
    if (!a)
      return null;
    const l = this.getInheritIndentForLine(e, t, r), u = t.getLineContent(r);
    if (l) {
      const c = l.line;
      if (c !== void 0) {
        const h = s.onEnter(e, "", t.getLineContent(c), "");
        if (h) {
          let d = Pr(t.getLineContent(c));
          return h.removeText && (d = d.substring(0, d.length - h.removeText)), h.indentAction === Ln.Indent || h.indentAction === Ln.IndentOutdent ? d = o.shiftIndent(d) : h.indentAction === Ln.Outdent && (d = o.unshiftIndent(d)), a.shouldDecrease(u) && (d = o.unshiftIndent(d)), h.appendText && (d += h.appendText), Pr(d);
        }
      }
      return a.shouldDecrease(u) ? l.action === Ln.Indent ? l.indentation : o.unshiftIndent(l.indentation) : l.action === Ln.Indent ? o.shiftIndent(l.indentation) : l.indentation;
    }
    return null;
  }
  getIndentForEnter(e, t, i, r) {
    if (e < 4)
      return null;
    t.forceTokenization(i.startLineNumber);
    const o = t.getLineTokens(i.startLineNumber), s = uy(o, i.startColumn - 1), a = s.getLineContent();
    let l = !1, u;
    s.firstCharOffset > 0 && o.getLanguageId(0) !== s.languageId ? (l = !0, u = a.substr(0, i.startColumn - 1 - s.firstCharOffset)) : u = o.getLineContent().substring(0, i.startColumn - 1);
    let c;
    i.isEmpty() ? c = a.substr(i.startColumn - 1 - s.firstCharOffset) : c = this.getScopedLineTokens(t, i.endLineNumber, i.endColumn).getLineContent().substr(i.endColumn - 1 - s.firstCharOffset);
    const h = this.getIndentRulesSupport(s.languageId);
    if (!h)
      return null;
    const d = u, f = Pr(u), p = {
      getLineTokens: (v) => t.getLineTokens(v),
      getLanguageIdentifier: () => t.getLanguageIdentifier(),
      getLanguageIdAtPosition: (v, C) => t.getLanguageIdAtPosition(v, C),
      getLineContent: (v) => v === i.startLineNumber ? d : t.getLineContent(v)
    }, g = Pr(o.getLineContent()), _ = this.getInheritIndentForLine(e, p, i.startLineNumber + 1);
    if (!_) {
      const v = l ? g : f;
      return {
        beforeEnter: v,
        afterEnter: v
      };
    }
    let m = l ? g : _.indentation;
    return _.action === Ln.Indent && (m = r.shiftIndent(m)), h.shouldDecrease(c) && (m = r.unshiftIndent(m)), {
      beforeEnter: l ? g : f,
      afterEnter: m
    };
  }
  /**
   * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of
   * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.
   */
  getIndentActionForType(e, t, i, r, o) {
    if (e < 4)
      return null;
    const s = this.getScopedLineTokens(t, i.startLineNumber, i.startColumn);
    if (s.firstCharOffset)
      return null;
    const a = this.getIndentRulesSupport(s.languageId);
    if (!a)
      return null;
    const l = s.getLineContent(), u = l.substr(0, i.startColumn - 1 - s.firstCharOffset);
    let c;
    if (i.isEmpty() ? c = l.substr(i.startColumn - 1 - s.firstCharOffset) : c = this.getScopedLineTokens(t, i.endLineNumber, i.endColumn).getLineContent().substr(i.endColumn - 1 - s.firstCharOffset), !a.shouldDecrease(u + c) && a.shouldDecrease(u + r + c)) {
      const h = this.getInheritIndentForLine(e, t, i.startLineNumber, !1);
      if (!h)
        return null;
      let d = h.indentation;
      return h.action !== Ln.Indent && (d = o.unshiftIndent(d)), d;
    }
    return null;
  }
  getIndentMetadata(e, t) {
    const i = this.getIndentRulesSupport(e.getLanguageIdentifier().id);
    return !i || t < 1 || t > e.getLineCount() ? null : i.getIndentMetadata(e.getLineContent(t));
  }
  // end Indent Rules
  // begin onEnter
  getEnterAction(e, t, i) {
    const r = this.getScopedLineTokens(t, i.startLineNumber, i.startColumn), o = this._getRichEditSupport(r.languageId);
    if (!o)
      return null;
    const s = r.getLineContent(), a = s.substr(0, i.startColumn - 1 - r.firstCharOffset);
    let l;
    i.isEmpty() ? l = s.substr(i.startColumn - 1 - r.firstCharOffset) : l = this.getScopedLineTokens(t, i.endLineNumber, i.endColumn).getLineContent().substr(i.endColumn - 1 - r.firstCharOffset);
    let u = "";
    if (i.startLineNumber > 1 && r.firstCharOffset === 0) {
      const g = this.getScopedLineTokens(t, i.startLineNumber - 1);
      g.languageId === r.languageId && (u = g.getLineContent());
    }
    const c = o.onEnter(e, u, a, l);
    if (!c)
      return null;
    const h = c.indentAction;
    let d = c.appendText;
    const f = c.removeText || 0;
    d ? h === Ln.Indent && (d = "	" + d) : h === Ln.Indent || h === Ln.IndentOutdent ? d = "	" : d = "";
    let p = this.getIndentationAtPosition(t, i.startLineNumber, i.startColumn);
    return f && (p = p.substring(0, p.length - f)), {
      indentAction: h,
      appendText: d,
      removeText: f,
      indentation: p
    };
  }
  getIndentationAtPosition(e, t, i) {
    const r = e.getLineContent(t);
    let o = Pr(r);
    return o.length > i - 1 && (o = o.substring(0, i - 1)), o;
  }
  getScopedLineTokens(e, t, i) {
    e.forceTokenization(t);
    const r = e.getLineTokens(t), o = typeof i > "u" ? e.getLineMaxColumn(t) - 1 : i - 1;
    return uy(r, o);
  }
  // end onEnter
  getBracketsSupport(e) {
    const t = this._getRichEditSupport(e);
    return t && t.brackets || null;
  }
}
const ui = new Boe();
class Rc {
  /**
   * Constructs a new DiffChange with the given sequence information
   * and content.
   */
  constructor(e, t, i, r) {
    this.originalStart = e, this.originalLength = t, this.modifiedStart = i, this.modifiedLength = r;
  }
  /**
   * The end point (exclusive) of the change in the original sequence.
   */
  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  /**
   * The end point (exclusive) of the change in the modified sequence.
   */
  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
}
class nk {
  constructor(e) {
    this.source = e;
  }
  getElements() {
    const e = this.source, t = new Int32Array(e.length);
    for (let i = 0, r = e.length; i < r; i++)
      t[i] = e.charCodeAt(i);
    return t;
  }
}
function Hoe(n, e, t) {
  return new dd(new nk(n), new nk(e)).ComputeDiff(t).changes;
}
class Ef {
  static Assert(e, t) {
    if (!e)
      throw new Error(t);
  }
}
class Lf {
  /**
   * Copies a range of elements from an Array starting at the specified source index and pastes
   * them to another Array starting at the specified destination index. The length and the indexes
   * are specified as 64-bit integers.
   * sourceArray:
   *		The Array that contains the data to copy.
   * sourceIndex:
   *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
   * destinationArray:
   *		The Array that receives the data.
   * destinationIndex:
   *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
   * length:
   *		A 64-bit integer that represents the number of elements to copy.
   */
  static Copy(e, t, i, r, o) {
    for (let s = 0; s < o; s++)
      i[r + s] = e[t + s];
  }
  static Copy2(e, t, i, r, o) {
    for (let s = 0; s < o; s++)
      i[r + s] = e[t + s];
  }
}
class rk {
  /**
   * Constructs a new DiffChangeHelper for the given DiffSequences.
   */
  constructor() {
    this.m_changes = [], this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824, this.m_originalCount = 0, this.m_modifiedCount = 0;
  }
  /**
   * Marks the beginning of the next change in the set of differences.
   */
  MarkNextChange() {
    (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.m_changes.push(new Rc(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount)), this.m_originalCount = 0, this.m_modifiedCount = 0, this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824;
  }
  /**
   * Adds the original element at the given position to the elements
   * affected by the current change. The modified index gives context
   * to the change position with respect to the original sequence.
   * @param originalIndex The index of the original element to add.
   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
   */
  AddOriginalElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_originalCount++;
  }
  /**
   * Adds the modified element at the given position to the elements
   * affected by the current change. The original index gives context
   * to the change position with respect to the modified sequence.
   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
   * @param modifiedIndex The index of the modified element to add.
   */
  AddModifiedElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_modifiedCount++;
  }
  /**
   * Retrieves all of the changes marked by the class.
   */
  getChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes;
  }
  /**
   * Retrieves all of the changes marked by the class in the reverse order
   */
  getReverseChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes.reverse(), this.m_changes;
  }
}
class dd {
  /**
   * Constructs the DiffFinder
   */
  constructor(e, t, i = null) {
    this.ContinueProcessingPredicate = i;
    const [r, o, s] = dd._getElements(e), [a, l, u] = dd._getElements(t);
    this._hasStrings = s && u, this._originalStringElements = r, this._originalElementsOrHash = o, this._modifiedStringElements = a, this._modifiedElementsOrHash = l, this.m_forwardHistory = [], this.m_reverseHistory = [];
  }
  static _isStringArray(e) {
    return e.length > 0 && typeof e[0] == "string";
  }
  static _getElements(e) {
    const t = e.getElements();
    if (dd._isStringArray(t)) {
      const i = new Int32Array(t.length);
      for (let r = 0, o = t.length; r < o; r++)
        i[r] = EN(t[r], 0);
      return [t, i, !0];
    }
    return t instanceof Int32Array ? [[], t, !1] : [[], new Int32Array(t), !1];
  }
  ElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  OriginalElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._originalElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._originalStringElements[t] : !0;
  }
  ModifiedElementsAreEqual(e, t) {
    return this._modifiedElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._modifiedStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  ComputeDiff(e) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, e);
  }
  /**
   * Computes the differences between the original and modified input
   * sequences on the bounded range.
   * @returns An array of the differences between the two input sequences.
   */
  _ComputeDiff(e, t, i, r, o) {
    const s = [!1];
    let a = this.ComputeDiffRecursive(e, t, i, r, s);
    return o && (a = this.PrettifyChanges(a)), {
      quitEarly: s[0],
      changes: a
    };
  }
  /**
   * Private helper method which computes the differences on the bounded range
   * recursively.
   * @returns An array of the differences between the two input sequences.
   */
  ComputeDiffRecursive(e, t, i, r, o) {
    for (o[0] = !1; e <= t && i <= r && this.ElementsAreEqual(e, i); )
      e++, i++;
    for (; t >= e && r >= i && this.ElementsAreEqual(t, r); )
      t--, r--;
    if (e > t || i > r) {
      let h;
      return i <= r ? (Ef.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), h = [
        new Rc(e, 0, i, r - i + 1)
      ]) : e <= t ? (Ef.Assert(i === r + 1, "modifiedStart should only be one more than modifiedEnd"), h = [
        new Rc(e, t - e + 1, i, 0)
      ]) : (Ef.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), Ef.Assert(i === r + 1, "modifiedStart should only be one more than modifiedEnd"), h = []), h;
    }
    const s = [0], a = [0], l = this.ComputeRecursionPoint(e, t, i, r, s, a, o), u = s[0], c = a[0];
    if (l !== null)
      return l;
    if (!o[0]) {
      const h = this.ComputeDiffRecursive(e, u, i, c, o);
      let d = [];
      return o[0] ? d = [
        new Rc(u + 1, t - (u + 1) + 1, c + 1, r - (c + 1) + 1)
      ] : d = this.ComputeDiffRecursive(u + 1, t, c + 1, r, o), this.ConcatenateChanges(h, d);
    }
    return [
      new Rc(e, t - e + 1, i, r - i + 1)
    ];
  }
  WALKTRACE(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g, _, m, v) {
    let C = null, y = null, b = new rk(), L = t, S = i, E = f[0] - _[0] - r, D = -1073741824, O = this.m_forwardHistory.length - 1;
    do {
      const T = E + e;
      T === L || T < S && u[T - 1] < u[T + 1] ? (h = u[T + 1], p = h - E - r, h < D && b.MarkNextChange(), D = h, b.AddModifiedElement(h + 1, p), E = T + 1 - e) : (h = u[T - 1] + 1, p = h - E - r, h < D && b.MarkNextChange(), D = h - 1, b.AddOriginalElement(h, p + 1), E = T - 1 - e), O >= 0 && (u = this.m_forwardHistory[O], e = u[0], L = 1, S = u.length - 1);
    } while (--O >= -1);
    if (C = b.getReverseChanges(), v[0]) {
      let T = f[0] + 1, A = _[0] + 1;
      if (C !== null && C.length > 0) {
        const P = C[C.length - 1];
        T = Math.max(T, P.getOriginalEnd()), A = Math.max(A, P.getModifiedEnd());
      }
      y = [
        new Rc(T, d - T + 1, A, g - A + 1)
      ];
    } else {
      b = new rk(), L = s, S = a, E = f[0] - _[0] - l, D = 1073741824, O = m ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
      do {
        const T = E + o;
        T === L || T < S && c[T - 1] >= c[T + 1] ? (h = c[T + 1] - 1, p = h - E - l, h > D && b.MarkNextChange(), D = h + 1, b.AddOriginalElement(h + 1, p + 1), E = T + 1 - o) : (h = c[T - 1], p = h - E - l, h > D && b.MarkNextChange(), D = h, b.AddModifiedElement(h + 1, p + 1), E = T - 1 - o), O >= 0 && (c = this.m_reverseHistory[O], o = c[0], L = 1, S = c.length - 1);
      } while (--O >= -1);
      y = b.getChanges();
    }
    return this.ConcatenateChanges(C, y);
  }
  /**
   * Given the range to compute the diff on, this method finds the point:
   * (midOriginal, midModified)
   * that exists in the middle of the LCS of the two sequences and
   * is the point at which the LCS problem may be broken down recursively.
   * This method will try to keep the LCS trace in memory. If the LCS recursion
   * point is calculated and the full trace is available in memory, then this method
   * will return the change list.
   * @param originalStart The start bound of the original sequence range
   * @param originalEnd The end bound of the original sequence range
   * @param modifiedStart The start bound of the modified sequence range
   * @param modifiedEnd The end bound of the modified sequence range
   * @param midOriginal The middle point of the original sequence range
   * @param midModified The middle point of the modified sequence range
   * @returns The diff changes, if available, otherwise null
   */
  ComputeRecursionPoint(e, t, i, r, o, s, a) {
    let l = 0, u = 0, c = 0, h = 0, d = 0, f = 0;
    e--, i--, o[0] = 0, s[0] = 0, this.m_forwardHistory = [], this.m_reverseHistory = [];
    const p = t - e + (r - i), g = p + 1, _ = new Int32Array(g), m = new Int32Array(g), v = r - i, C = t - e, y = e - i, b = t - r, S = (C - v) % 2 === 0;
    _[v] = e, m[C] = t, a[0] = !1;
    for (let E = 1; E <= p / 2 + 1; E++) {
      let D = 0, O = 0;
      c = this.ClipDiagonalBound(v - E, E, v, g), h = this.ClipDiagonalBound(v + E, E, v, g);
      for (let A = c; A <= h; A += 2) {
        A === c || A < h && _[A - 1] < _[A + 1] ? l = _[A + 1] : l = _[A - 1] + 1, u = l - (A - v) - y;
        const P = l;
        for (; l < t && u < r && this.ElementsAreEqual(l + 1, u + 1); )
          l++, u++;
        if (_[A] = l, l + u > D + O && (D = l, O = u), !S && Math.abs(A - C) <= E - 1 && l >= m[A])
          return o[0] = l, s[0] = u, P <= m[A] && 1447 > 0 && E <= 1447 + 1 ? this.WALKTRACE(v, c, h, y, C, d, f, b, _, m, l, t, o, u, r, s, S, a) : null;
      }
      const T = (D - e + (O - i) - E) / 2;
      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(D, T))
        return a[0] = !0, o[0] = D, s[0] = O, T > 0 && 1447 > 0 && E <= 1447 + 1 ? this.WALKTRACE(v, c, h, y, C, d, f, b, _, m, l, t, o, u, r, s, S, a) : (e++, i++, [
          new Rc(e, t - e + 1, i, r - i + 1)
        ]);
      d = this.ClipDiagonalBound(C - E, E, C, g), f = this.ClipDiagonalBound(C + E, E, C, g);
      for (let A = d; A <= f; A += 2) {
        A === d || A < f && m[A - 1] >= m[A + 1] ? l = m[A + 1] - 1 : l = m[A - 1], u = l - (A - C) - b;
        const P = l;
        for (; l > e && u > i && this.ElementsAreEqual(l, u); )
          l--, u--;
        if (m[A] = l, S && Math.abs(A - v) <= E && l <= _[A])
          return o[0] = l, s[0] = u, P >= _[A] && 1447 > 0 && E <= 1447 + 1 ? this.WALKTRACE(v, c, h, y, C, d, f, b, _, m, l, t, o, u, r, s, S, a) : null;
      }
      if (E <= 1447) {
        let A = new Int32Array(h - c + 2);
        A[0] = v - c + 1, Lf.Copy2(_, c, A, 1, h - c + 1), this.m_forwardHistory.push(A), A = new Int32Array(f - d + 2), A[0] = C - d + 1, Lf.Copy2(m, d, A, 1, f - d + 1), this.m_reverseHistory.push(A);
      }
    }
    return this.WALKTRACE(v, c, h, y, C, d, f, b, _, m, l, t, o, u, r, s, S, a);
  }
  /**
   * Shifts the given changes to provide a more intuitive diff.
   * While the first element in a diff matches the first element after the diff,
   * we shift the diff down.
   *
   * @param changes The list of changes to shift
   * @returns The shifted changes
   */
  PrettifyChanges(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t], r = t < e.length - 1 ? e[t + 1].originalStart : this._originalElementsOrHash.length, o = t < e.length - 1 ? e[t + 1].modifiedStart : this._modifiedElementsOrHash.length, s = i.originalLength > 0, a = i.modifiedLength > 0;
      for (; i.originalStart + i.originalLength < r && i.modifiedStart + i.modifiedLength < o && (!s || this.OriginalElementsAreEqual(i.originalStart, i.originalStart + i.originalLength)) && (!a || this.ModifiedElementsAreEqual(i.modifiedStart, i.modifiedStart + i.modifiedLength)); )
        i.originalStart++, i.modifiedStart++;
      let l = [null];
      if (t < e.length - 1 && this.ChangesOverlap(e[t], e[t + 1], l)) {
        e[t] = l[0], e.splice(t + 1, 1), t--;
        continue;
      }
    }
    for (let t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      let r = 0, o = 0;
      if (t > 0) {
        const h = e[t - 1];
        r = h.originalStart + h.originalLength, o = h.modifiedStart + h.modifiedLength;
      }
      const s = i.originalLength > 0, a = i.modifiedLength > 0;
      let l = 0, u = this._boundaryScore(i.originalStart, i.originalLength, i.modifiedStart, i.modifiedLength);
      for (let h = 1; ; h++) {
        const d = i.originalStart - h, f = i.modifiedStart - h;
        if (d < r || f < o || s && !this.OriginalElementsAreEqual(d, d + i.originalLength) || a && !this.ModifiedElementsAreEqual(f, f + i.modifiedLength))
          break;
        const g = (d === r && f === o ? 5 : 0) + this._boundaryScore(d, i.originalLength, f, i.modifiedLength);
        g > u && (u = g, l = h);
      }
      i.originalStart -= l, i.modifiedStart -= l;
      const c = [null];
      if (t > 0 && this.ChangesOverlap(e[t - 1], e[t], c)) {
        e[t - 1] = c[0], e.splice(t, 1), t++;
        continue;
      }
    }
    if (this._hasStrings)
      for (let t = 1, i = e.length; t < i; t++) {
        const r = e[t - 1], o = e[t], s = o.originalStart - r.originalStart - r.originalLength, a = r.originalStart, l = o.originalStart + o.originalLength, u = l - a, c = r.modifiedStart, h = o.modifiedStart + o.modifiedLength, d = h - c;
        if (s < 5 && u < 20 && d < 20) {
          const f = this._findBetterContiguousSequence(a, u, c, d, s);
          if (f) {
            const [p, g] = f;
            (p !== r.originalStart + r.originalLength || g !== r.modifiedStart + r.modifiedLength) && (r.originalLength = p - r.originalStart, r.modifiedLength = g - r.modifiedStart, o.originalStart = p + s, o.modifiedStart = g + s, o.originalLength = l - o.originalStart, o.modifiedLength = h - o.modifiedStart);
          }
        }
      }
    return e;
  }
  _findBetterContiguousSequence(e, t, i, r, o) {
    if (t < o || r < o)
      return null;
    const s = e + t - o + 1, a = i + r - o + 1;
    let l = 0, u = 0, c = 0;
    for (let h = e; h < s; h++)
      for (let d = i; d < a; d++) {
        const f = this._contiguousSequenceScore(h, d, o);
        f > 0 && f > l && (l = f, u = h, c = d);
      }
    return l > 0 ? [u, c] : null;
  }
  _contiguousSequenceScore(e, t, i) {
    let r = 0;
    for (let o = 0; o < i; o++) {
      if (!this.ElementsAreEqual(e + o, t + o))
        return 0;
      r += this._originalStringElements[e + o].length;
    }
    return r;
  }
  _OriginalIsBoundary(e) {
    return e <= 0 || e >= this._originalElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._originalStringElements[e]);
  }
  _OriginalRegionIsBoundary(e, t) {
    if (this._OriginalIsBoundary(e) || this._OriginalIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._OriginalIsBoundary(i - 1) || this._OriginalIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _ModifiedIsBoundary(e) {
    return e <= 0 || e >= this._modifiedElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._modifiedStringElements[e]);
  }
  _ModifiedRegionIsBoundary(e, t) {
    if (this._ModifiedIsBoundary(e) || this._ModifiedIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._ModifiedIsBoundary(i - 1) || this._ModifiedIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _boundaryScore(e, t, i, r) {
    const o = this._OriginalRegionIsBoundary(e, t) ? 1 : 0, s = this._ModifiedRegionIsBoundary(i, r) ? 1 : 0;
    return o + s;
  }
  /**
   * Concatenates the two input DiffChange lists and returns the resulting
   * list.
   * @param The left changes
   * @param The right changes
   * @returns The concatenated list
   */
  ConcatenateChanges(e, t) {
    let i = [];
    if (e.length === 0 || t.length === 0)
      return t.length > 0 ? t : e;
    if (this.ChangesOverlap(e[e.length - 1], t[0], i)) {
      const r = new Array(e.length + t.length - 1);
      return Lf.Copy(e, 0, r, 0, e.length - 1), r[e.length - 1] = i[0], Lf.Copy(t, 1, r, e.length, t.length - 1), r;
    } else {
      const r = new Array(e.length + t.length);
      return Lf.Copy(e, 0, r, 0, e.length), Lf.Copy(t, 0, r, e.length, t.length), r;
    }
  }
  /**
   * Returns true if the two changes overlap and can be merged into a single
   * change
   * @param left The left change
   * @param right The right change
   * @param mergedChange The merged change if the two overlap, null otherwise
   * @returns True if the two changes overlap
   */
  ChangesOverlap(e, t, i) {
    if (Ef.Assert(e.originalStart <= t.originalStart, "Left change is not less than or equal to right change"), Ef.Assert(e.modifiedStart <= t.modifiedStart, "Left change is not less than or equal to right change"), e.originalStart + e.originalLength >= t.originalStart || e.modifiedStart + e.modifiedLength >= t.modifiedStart) {
      const r = e.originalStart;
      let o = e.originalLength;
      const s = e.modifiedStart;
      let a = e.modifiedLength;
      return e.originalStart + e.originalLength >= t.originalStart && (o = t.originalStart + t.originalLength - e.originalStart), e.modifiedStart + e.modifiedLength >= t.modifiedStart && (a = t.modifiedStart + t.modifiedLength - e.modifiedStart), i[0] = new Rc(r, o, s, a), !0;
    } else
      return i[0] = null, !1;
  }
  /**
   * Helper method used to clip a diagonal index to the range of valid
   * diagonals. This also decides whether or not the diagonal index,
   * if it exceeds the boundary, should be clipped to the boundary or clipped
   * one inside the boundary depending on the Even/Odd status of the boundary
   * and numDifferences.
   * @param diagonal The index of the diagonal to clip.
   * @param numDifferences The current number of differences being iterated upon.
   * @param diagonalBaseIndex The base reference diagonal.
   * @param numDiagonals The total number of diagonals.
   * @returns The clipped diagonal index.
   */
  ClipDiagonalBound(e, t, i, r) {
    if (e >= 0 && e < r)
      return e;
    const o = i, s = r - i - 1, a = t % 2 === 0;
    if (e < 0) {
      const l = o % 2 === 0;
      return a === l ? 0 : 1;
    } else {
      const l = s % 2 === 0;
      return a === l ? r - 1 : r - 2;
    }
  }
}
const Goe = 3;
function a5(n, e, t, i) {
  return new dd(n, e, t).ComputeDiff(i);
}
class ok {
  constructor(e) {
    const t = [], i = [];
    for (let r = 0, o = e.length; r < o; r++)
      t[r] = vT(e[r], 1), i[r] = _T(e[r], 1);
    this.lines = e, this._startColumns = t, this._endColumns = i;
  }
  getElements() {
    const e = [];
    for (let t = 0, i = this.lines.length; t < i; t++)
      e[t] = this.lines[t].substring(this._startColumns[t] - 1, this._endColumns[t] - 1);
    return e;
  }
  getStartLineNumber(e) {
    return e + 1;
  }
  getEndLineNumber(e) {
    return e + 1;
  }
  createCharSequence(e, t, i) {
    const r = [], o = [], s = [];
    let a = 0;
    for (let l = t; l <= i; l++) {
      const u = this.lines[l], c = e ? this._startColumns[l] : 1, h = e ? this._endColumns[l] : u.length + 1;
      for (let d = c; d < h; d++)
        r[a] = u.charCodeAt(d - 1), o[a] = l + 1, s[a] = d, a++;
    }
    return new Uoe(r, o, s);
  }
}
class Uoe {
  constructor(e, t, i) {
    this._charCodes = e, this._lineNumbers = t, this._columns = i;
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(e) {
    return this._lineNumbers[e];
  }
  getStartColumn(e) {
    return this._columns[e];
  }
  getEndLineNumber(e) {
    return this._lineNumbers[e];
  }
  getEndColumn(e) {
    return this._columns[e] + 1;
  }
}
class jv {
  constructor(e, t, i, r, o, s, a, l) {
    this.originalStartLineNumber = e, this.originalStartColumn = t, this.originalEndLineNumber = i, this.originalEndColumn = r, this.modifiedStartLineNumber = o, this.modifiedStartColumn = s, this.modifiedEndLineNumber = a, this.modifiedEndColumn = l;
  }
  static createFromDiffChange(e, t, i) {
    let r, o, s, a, l, u, c, h;
    return e.originalLength === 0 ? (r = 0, o = 0, s = 0, a = 0) : (r = t.getStartLineNumber(e.originalStart), o = t.getStartColumn(e.originalStart), s = t.getEndLineNumber(e.originalStart + e.originalLength - 1), a = t.getEndColumn(e.originalStart + e.originalLength - 1)), e.modifiedLength === 0 ? (l = 0, u = 0, c = 0, h = 0) : (l = i.getStartLineNumber(e.modifiedStart), u = i.getStartColumn(e.modifiedStart), c = i.getEndLineNumber(e.modifiedStart + e.modifiedLength - 1), h = i.getEndColumn(e.modifiedStart + e.modifiedLength - 1)), new jv(r, o, s, a, l, u, c, h);
  }
}
function zoe(n) {
  if (n.length <= 1)
    return n;
  const e = [n[0]];
  let t = e[0];
  for (let i = 1, r = n.length; i < r; i++) {
    const o = n[i], s = o.originalStart - (t.originalStart + t.originalLength), a = o.modifiedStart - (t.modifiedStart + t.modifiedLength);
    Math.min(s, a) < Goe ? (t.originalLength = o.originalStart + o.originalLength - t.originalStart, t.modifiedLength = o.modifiedStart + o.modifiedLength - t.modifiedStart) : (e.push(o), t = o);
  }
  return e;
}
class lv {
  constructor(e, t, i, r, o) {
    this.originalStartLineNumber = e, this.originalEndLineNumber = t, this.modifiedStartLineNumber = i, this.modifiedEndLineNumber = r, this.charChanges = o;
  }
  static createFromDiffResult(e, t, i, r, o, s, a) {
    let l, u, c, h, d;
    if (t.originalLength === 0 ? (l = i.getStartLineNumber(t.originalStart) - 1, u = 0) : (l = i.getStartLineNumber(t.originalStart), u = i.getEndLineNumber(t.originalStart + t.originalLength - 1)), t.modifiedLength === 0 ? (c = r.getStartLineNumber(t.modifiedStart) - 1, h = 0) : (c = r.getStartLineNumber(t.modifiedStart), h = r.getEndLineNumber(t.modifiedStart + t.modifiedLength - 1)), s && t.originalLength > 0 && t.originalLength < 20 && t.modifiedLength > 0 && t.modifiedLength < 20 && o()) {
      const f = i.createCharSequence(e, t.originalStart, t.originalStart + t.originalLength - 1), p = r.createCharSequence(e, t.modifiedStart, t.modifiedStart + t.modifiedLength - 1);
      let g = a5(f, p, o, !0).changes;
      a && (g = zoe(g)), d = [];
      for (let _ = 0, m = g.length; _ < m; _++)
        d.push(jv.createFromDiffChange(g[_], f, p));
    }
    return new lv(l, u, c, h, d);
  }
}
class joe {
  constructor(e, t, i) {
    this.shouldComputeCharChanges = i.shouldComputeCharChanges, this.shouldPostProcessCharChanges = i.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = i.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = i.shouldMakePrettyDiff, this.originalLines = e, this.modifiedLines = t, this.original = new ok(e), this.modified = new ok(t), this.continueLineDiff = sk(i.maxComputationTime), this.continueCharDiff = sk(i.maxComputationTime === 0 ? 0 : Math.min(i.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0)
      return this.modified.lines.length === 1 && this.modified.lines[0].length === 0 ? {
        quitEarly: !1,
        changes: []
      } : {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: [{
            modifiedEndColumn: 0,
            modifiedEndLineNumber: 0,
            modifiedStartColumn: 0,
            modifiedStartLineNumber: 0,
            originalEndColumn: 0,
            originalEndLineNumber: 0,
            originalStartColumn: 0,
            originalStartLineNumber: 0
          }]
        }]
      };
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0)
      return {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: [{
            modifiedEndColumn: 0,
            modifiedEndLineNumber: 0,
            modifiedStartColumn: 0,
            modifiedStartLineNumber: 0,
            originalEndColumn: 0,
            originalEndLineNumber: 0,
            originalStartColumn: 0,
            originalStartLineNumber: 0
          }]
        }]
      };
    const e = a5(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff), t = e.changes, i = e.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const a = [];
      for (let l = 0, u = t.length; l < u; l++)
        a.push(lv.createFromDiffResult(this.shouldIgnoreTrimWhitespace, t[l], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      return {
        quitEarly: i,
        changes: a
      };
    }
    const r = [];
    let o = 0, s = 0;
    for (let a = -1, l = t.length; a < l; a++) {
      const u = a + 1 < l ? t[a + 1] : null, c = u ? u.originalStart : this.originalLines.length, h = u ? u.modifiedStart : this.modifiedLines.length;
      for (; o < c && s < h; ) {
        const d = this.originalLines[o], f = this.modifiedLines[s];
        if (d !== f) {
          {
            let p = vT(d, 1), g = vT(f, 1);
            for (; p > 1 && g > 1; ) {
              const _ = d.charCodeAt(p - 2), m = f.charCodeAt(g - 2);
              if (_ !== m)
                break;
              p--, g--;
            }
            (p > 1 || g > 1) && this._pushTrimWhitespaceCharChange(r, o + 1, 1, p, s + 1, 1, g);
          }
          {
            let p = _T(d, 1), g = _T(f, 1);
            const _ = d.length + 1, m = f.length + 1;
            for (; p < _ && g < m; ) {
              const v = d.charCodeAt(p - 1), C = d.charCodeAt(g - 1);
              if (v !== C)
                break;
              p++, g++;
            }
            (p < _ || g < m) && this._pushTrimWhitespaceCharChange(r, o + 1, p, _, s + 1, g, m);
          }
        }
        o++, s++;
      }
      u && (r.push(lv.createFromDiffResult(this.shouldIgnoreTrimWhitespace, u, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), o += u.originalLength, s += u.modifiedLength);
    }
    return {
      quitEarly: i,
      changes: r
    };
  }
  _pushTrimWhitespaceCharChange(e, t, i, r, o, s, a) {
    if (this._mergeTrimWhitespaceCharChange(e, t, i, r, o, s, a))
      return;
    let l;
    this.shouldComputeCharChanges && (l = [new jv(t, i, t, r, o, s, o, a)]), e.push(new lv(t, t, o, o, l));
  }
  _mergeTrimWhitespaceCharChange(e, t, i, r, o, s, a) {
    const l = e.length;
    if (l === 0)
      return !1;
    const u = e[l - 1];
    return u.originalEndLineNumber === 0 || u.modifiedEndLineNumber === 0 ? !1 : u.originalEndLineNumber + 1 === t && u.modifiedEndLineNumber + 1 === o ? (u.originalEndLineNumber = t, u.modifiedEndLineNumber = o, this.shouldComputeCharChanges && u.charChanges && u.charChanges.push(new jv(t, i, t, r, o, s, o, a)), !0) : !1;
  }
}
function vT(n, e) {
  const t = Es(n);
  return t === -1 ? e : t + 1;
}
function _T(n, e) {
  const t = wg(n);
  return t === -1 ? e : t + 2;
}
function sk(n) {
  if (n === 0)
    return () => !0;
  const e = Date.now();
  return () => Date.now() - e < n;
}
function mb(n) {
  return n < 0 ? 0 : n > 255 ? 255 : n | 0;
}
function Df(n) {
  return n < 0 ? 0 : n > 4294967295 ? 4294967295 : n | 0;
}
class l5 {
  constructor(e, t) {
    this.index = e, this.remainder = t;
  }
}
class $oe {
  constructor(e) {
    this.values = e, this.prefixSum = new Uint32Array(e.length), this.prefixSumValidIndex = new Int32Array(1), this.prefixSumValidIndex[0] = -1;
  }
  insertValues(e, t) {
    e = Df(e);
    const i = this.values, r = this.prefixSum, o = t.length;
    return o === 0 ? !1 : (this.values = new Uint32Array(i.length + o), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e), e + o), this.values.set(t, e), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSum = new Uint32Array(this.values.length), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  changeValue(e, t) {
    return e = Df(e), t = Df(t), this.values[e] === t ? !1 : (this.values[e] = t, e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), !0);
  }
  removeValues(e, t) {
    e = Df(e), t = Df(t);
    const i = this.values, r = this.prefixSum;
    if (e >= i.length)
      return !1;
    let o = i.length - e;
    return t >= o && (t = o), t === 0 ? !1 : (this.values = new Uint32Array(i.length - t), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e + t), e), this.prefixSum = new Uint32Array(this.values.length), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  getTotalValue() {
    return this.values.length === 0 ? 0 : this._getAccumulatedValue(this.values.length - 1);
  }
  getAccumulatedValue(e) {
    return e < 0 ? 0 : (e = Df(e), this._getAccumulatedValue(e));
  }
  _getAccumulatedValue(e) {
    if (e <= this.prefixSumValidIndex[0])
      return this.prefixSum[e];
    let t = this.prefixSumValidIndex[0] + 1;
    t === 0 && (this.prefixSum[0] = this.values[0], t++), e >= this.values.length && (e = this.values.length - 1);
    for (let i = t; i <= e; i++)
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    return this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e), this.prefixSum[e];
  }
  getIndexOf(e) {
    e = Math.floor(e), this.getTotalValue();
    let t = 0, i = this.values.length - 1, r = 0, o = 0, s = 0;
    for (; t <= i; )
      if (r = t + (i - t) / 2 | 0, o = this.prefixSum[r], s = o - this.values[r], e < s)
        i = r - 1;
      else if (e >= o)
        t = r + 1;
      else
        break;
    return new l5(r, e - s);
  }
}
class Koe {
  constructor(e, t, i, r) {
    this._uri = e, this._lines = t, this._eol = i, this._versionId = r, this._lineStarts = null, this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    return this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)), this._cachedTextValue;
  }
  onEvents(e) {
    e.eol && e.eol !== this._eol && (this._eol = e.eol, this._lineStarts = null);
    const t = e.changes;
    for (const i of t)
      this._acceptDeleteRange(i.range), this._acceptInsertText(new J(i.range.startLineNumber, i.range.startColumn), i.text);
    this._versionId = e.versionId, this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const e = this._eol.length, t = this._lines.length, i = new Uint32Array(t);
      for (let r = 0; r < t; r++)
        i[r] = this._lines[r].length + e;
      this._lineStarts = new $oe(i);
    }
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(e, t) {
    this._lines[e] = t, this._lineStarts && this._lineStarts.changeValue(e, this._lines[e].length + this._eol.length);
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.startLineNumber - 1].substring(e.endColumn - 1));
      return;
    }
    this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.endLineNumber - 1].substring(e.endColumn - 1)), this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t) {
    if (t.length === 0)
      return;
    let i = W_(t);
    if (i.length === 1) {
      this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0] + this._lines[e.lineNumber - 1].substring(e.column - 1));
      return;
    }
    i[i.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1), this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0]);
    let r = new Uint32Array(i.length - 1);
    for (let o = 1; o < i.length; o++)
      this._lines.splice(e.lineNumber + o - 1, 0, i[o]), r[o - 1] = i[o].length + this._eol.length;
    this._lineStarts && this._lineStarts.insertValues(e.lineNumber, r);
  }
}
class bg {
  constructor(e) {
    let t = mb(e);
    this._defaultValue = t, this._asciiMap = bg._createAsciiMap(t), this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(e) {
    let t = new Uint8Array(256);
    for (let i = 0; i < 256; i++)
      t[i] = e;
    return t;
  }
  set(e, t) {
    let i = mb(t);
    e >= 0 && e < 256 ? this._asciiMap[e] = i : this._map.set(e, i);
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue;
  }
}
class xCe {
  constructor() {
    this._actual = new bg(
      0
      /* False */
    );
  }
  add(e) {
    this._actual.set(
      e,
      1
      /* True */
    );
  }
  has(e) {
    return this._actual.get(e) === 1;
  }
}
class qoe {
  constructor(e, t, i) {
    const r = new Uint8Array(e * t);
    for (let o = 0, s = e * t; o < s; o++)
      r[o] = i;
    this._data = r, this.rows = e, this.cols = t;
  }
  get(e, t) {
    return this._data[e * this.cols + t];
  }
  set(e, t, i) {
    this._data[e * this.cols + t] = i;
  }
}
class Yoe {
  constructor(e) {
    let t = 0, i = 0;
    for (let o = 0, s = e.length; o < s; o++) {
      let [a, l, u] = e[o];
      l > t && (t = l), a > i && (i = a), u > i && (i = u);
    }
    t++, i++;
    let r = new qoe(
      i,
      t,
      0
      /* Invalid */
    );
    for (let o = 0, s = e.length; o < s; o++) {
      let [a, l, u] = e[o];
      r.set(a, l, u);
    }
    this._states = r, this._maxCharCode = t;
  }
  nextState(e, t) {
    return t < 0 || t >= this._maxCharCode ? 0 : this._states.get(e, t);
  }
}
let sD = null;
function Xoe() {
  return sD === null && (sD = new Yoe([
    [
      1,
      104,
      2
      /* H */
    ],
    [
      1,
      72,
      2
      /* H */
    ],
    [
      1,
      102,
      6
      /* F */
    ],
    [
      1,
      70,
      6
      /* F */
    ],
    [
      2,
      116,
      3
      /* HT */
    ],
    [
      2,
      84,
      3
      /* HT */
    ],
    [
      3,
      116,
      4
      /* HTT */
    ],
    [
      3,
      84,
      4
      /* HTT */
    ],
    [
      4,
      112,
      5
      /* HTTP */
    ],
    [
      4,
      80,
      5
      /* HTTP */
    ],
    [
      5,
      115,
      9
      /* BeforeColon */
    ],
    [
      5,
      83,
      9
      /* BeforeColon */
    ],
    [
      5,
      58,
      10
      /* AfterColon */
    ],
    [
      6,
      105,
      7
      /* FI */
    ],
    [
      6,
      73,
      7
      /* FI */
    ],
    [
      7,
      108,
      8
      /* FIL */
    ],
    [
      7,
      76,
      8
      /* FIL */
    ],
    [
      8,
      101,
      9
      /* BeforeColon */
    ],
    [
      8,
      69,
      9
      /* BeforeColon */
    ],
    [
      9,
      58,
      10
      /* AfterColon */
    ],
    [
      10,
      47,
      11
      /* AlmostThere */
    ],
    [
      11,
      47,
      12
      /* End */
    ]
  ])), sD;
}
let Dm = null;
function Zoe() {
  if (Dm === null) {
    Dm = new bg(
      0
      /* None */
    );
    const n = ` 	<>'"`;
    for (let t = 0; t < n.length; t++)
      Dm.set(
        n.charCodeAt(t),
        1
        /* ForceTermination */
      );
    const e = ".,;";
    for (let t = 0; t < e.length; t++)
      Dm.set(
        e.charCodeAt(t),
        2
        /* CannotEndIn */
      );
  }
  return Dm;
}
class vb {
  static _createLink(e, t, i, r, o) {
    let s = o - 1;
    do {
      const a = t.charCodeAt(s);
      if (e.get(a) !== 2)
        break;
      s--;
    } while (s > r);
    if (r > 0) {
      const a = t.charCodeAt(r - 1), l = t.charCodeAt(s);
      (a === 40 && l === 41 || a === 91 && l === 93 || a === 123 && l === 125) && s--;
    }
    return {
      range: {
        startLineNumber: i,
        startColumn: r + 1,
        endLineNumber: i,
        endColumn: s + 2
      },
      url: t.substring(r, s + 1)
    };
  }
  static computeLinks(e, t = Xoe()) {
    const i = Zoe();
    let r = [];
    for (let o = 1, s = e.getLineCount(); o <= s; o++) {
      const a = e.getLineContent(o), l = a.length;
      let u = 0, c = 0, h = 0, d = 1, f = !1, p = !1, g = !1, _ = !1;
      for (; u < l; ) {
        let m = !1;
        const v = a.charCodeAt(u);
        if (d === 13) {
          let C;
          switch (v) {
            case 40:
              f = !0, C = 0;
              break;
            case 41:
              C = f ? 0 : 1;
              break;
            case 91:
              g = !0, p = !0, C = 0;
              break;
            case 93:
              g = !1, C = p ? 0 : 1;
              break;
            case 123:
              _ = !0, C = 0;
              break;
            case 125:
              C = _ ? 0 : 1;
              break;
            case 39:
              C = h === 34 || h === 96 ? 0 : 1;
              break;
            case 34:
              C = h === 39 || h === 96 ? 0 : 1;
              break;
            case 96:
              C = h === 39 || h === 34 ? 0 : 1;
              break;
            case 42:
              C = h === 42 ? 1 : 0;
              break;
            case 124:
              C = h === 124 ? 1 : 0;
              break;
            case 32:
              C = g ? 0 : 1;
              break;
            default:
              C = i.get(v);
          }
          C === 1 && (r.push(vb._createLink(i, a, o, c, u)), m = !0);
        } else if (d === 12) {
          let C;
          v === 91 ? (p = !0, C = 0) : C = i.get(v), C === 1 ? m = !0 : d = 13;
        } else
          d = t.nextState(d, v), d === 0 && (m = !0);
        m && (d = 1, f = !1, p = !1, _ = !1, c = u + 1, h = v), u++;
      }
      d === 13 && r.push(vb._createLink(i, a, o, c, l));
    }
    return r;
  }
}
function Qoe(n) {
  return !n || typeof n.getLineCount != "function" || typeof n.getLineContent != "function" ? [] : vb.computeLinks(n);
}
class CT {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  navigateValueSet(e, t, i, r, o) {
    if (e && t) {
      let s = this.doNavigateValueSet(t, o);
      if (s)
        return {
          range: e,
          value: s
        };
    }
    if (i && r) {
      let s = this.doNavigateValueSet(r, o);
      if (s)
        return {
          range: i,
          value: s
        };
    }
    return null;
  }
  doNavigateValueSet(e, t) {
    let i = this.numberReplace(e, t);
    return i !== null ? i : this.textReplace(e, t);
  }
  numberReplace(e, t) {
    let i = Math.pow(10, e.length - (e.lastIndexOf(".") + 1)), r = Number(e), o = parseFloat(e);
    return !isNaN(r) && !isNaN(o) && r === o ? r === 0 && !t ? null : (r = Math.floor(r * i), r += t ? i : -i, String(r / i)) : null;
  }
  textReplace(e, t) {
    return this.valueSetsReplace(this._defaultValueSet, e, t);
  }
  valueSetsReplace(e, t, i) {
    let r = null;
    for (let o = 0, s = e.length; r === null && o < s; o++)
      r = this.valueSetReplace(e[o], t, i);
    return r;
  }
  valueSetReplace(e, t, i) {
    let r = e.indexOf(t);
    return r >= 0 ? (r += i ? 1 : -1, r < 0 ? r = e.length - 1 : r %= e.length, e[r]) : null;
  }
}
CT.INSTANCE = new CT();
var Rf = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class Joe extends Koe {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(e) {
    return this._lines[e - 1];
  }
  getWordAtPosition(e, t) {
    let i = eb(e.column, q1(t), this._lines[e.lineNumber - 1], 0);
    return i ? new V(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn) : null;
  }
  words(e) {
    const t = this._lines, i = this._wordenize.bind(this);
    let r = 0, o = "", s = 0, a = [];
    return {
      *[Symbol.iterator]() {
        for (; ; )
          if (s < a.length) {
            const l = o.substring(a[s].start, a[s].end);
            s += 1, yield l;
          } else if (r < t.length)
            o = t[r], a = i(o, e), s = 0, r += 1;
          else
            break;
      }
    };
  }
  getLineWords(e, t) {
    let i = this._lines[e - 1], r = this._wordenize(i, t), o = [];
    for (const s of r)
      o.push({
        word: i.substring(s.start, s.end),
        startColumn: s.start + 1,
        endColumn: s.end + 1
      });
    return o;
  }
  _wordenize(e, t) {
    const i = [];
    let r;
    for (t.lastIndex = 0; (r = t.exec(e)) && r[0].length !== 0; )
      i.push({ start: r.index, end: r.index + r[0].length });
    return i;
  }
  getValueInRange(e) {
    if (e = this._validateRange(e), e.startLineNumber === e.endLineNumber)
      return this._lines[e.startLineNumber - 1].substring(e.startColumn - 1, e.endColumn - 1);
    let t = this._eol, i = e.startLineNumber - 1, r = e.endLineNumber - 1, o = [];
    o.push(this._lines[i].substring(e.startColumn - 1));
    for (let s = i + 1; s < r; s++)
      o.push(this._lines[s]);
    return o.push(this._lines[r].substring(0, e.endColumn - 1)), o.join(t);
  }
  offsetAt(e) {
    return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getAccumulatedValue(e.lineNumber - 2) + (e.column - 1);
  }
  positionAt(e) {
    e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
    let t = this._lineStarts.getIndexOf(e), i = this._lines[t.index].length;
    return {
      lineNumber: 1 + t.index,
      column: 1 + Math.min(t.remainder, i)
    };
  }
  _validateRange(e) {
    const t = this._validatePosition({ lineNumber: e.startLineNumber, column: e.startColumn }), i = this._validatePosition({ lineNumber: e.endLineNumber, column: e.endColumn });
    return t.lineNumber !== e.startLineNumber || t.column !== e.startColumn || i.lineNumber !== e.endLineNumber || i.column !== e.endColumn ? {
      startLineNumber: t.lineNumber,
      startColumn: t.column,
      endLineNumber: i.lineNumber,
      endColumn: i.column
    } : e;
  }
  _validatePosition(e) {
    if (!J.isIPosition(e))
      throw new Error("bad position");
    let { lineNumber: t, column: i } = e, r = !1;
    if (t < 1)
      t = 1, i = 1, r = !0;
    else if (t > this._lines.length)
      t = this._lines.length, i = this._lines[t - 1].length + 1, r = !0;
    else {
      let o = this._lines[t - 1].length + 1;
      i < 1 ? (i = 1, r = !0) : i > o && (i = o, r = !0);
    }
    return r ? { lineNumber: t, column: i } : e;
  }
}
class xd {
  constructor(e, t) {
    this._host = e, this._models = /* @__PURE__ */ Object.create(null), this._foreignModuleFactory = t, this._foreignModule = null;
  }
  dispose() {
    this._models = /* @__PURE__ */ Object.create(null);
  }
  _getModel(e) {
    return this._models[e];
  }
  _getModels() {
    let e = [];
    return Object.keys(this._models).forEach((t) => e.push(this._models[t])), e;
  }
  acceptNewModel(e) {
    this._models[e.url] = new Joe(dt.parse(e.url), e.lines, e.EOL, e.versionId);
  }
  acceptModelChanged(e, t) {
    if (!this._models[e])
      return;
    this._models[e].onEvents(t);
  }
  acceptRemovedModel(e) {
    this._models[e] && delete this._models[e];
  }
  // ---- BEGIN diff --------------------------------------------------------------------------
  computeDiff(e, t, i, r) {
    return Rf(this, void 0, void 0, function* () {
      const o = this._getModel(e), s = this._getModel(t);
      if (!o || !s)
        return null;
      const a = o.getLinesContent(), l = s.getLinesContent(), c = new joe(a, l, {
        shouldComputeCharChanges: !0,
        shouldPostProcessCharChanges: !0,
        shouldIgnoreTrimWhitespace: i,
        shouldMakePrettyDiff: !0,
        maxComputationTime: r
      }).computeDiff(), h = c.changes.length > 0 ? !1 : this._modelsAreIdentical(o, s);
      return {
        quitEarly: c.quitEarly,
        identical: h,
        changes: c.changes
      };
    });
  }
  _modelsAreIdentical(e, t) {
    const i = e.getLineCount(), r = t.getLineCount();
    if (i !== r)
      return !1;
    for (let o = 1; o <= i; o++) {
      const s = e.getLineContent(o), a = t.getLineContent(o);
      if (s !== a)
        return !1;
    }
    return !0;
  }
  computeMoreMinimalEdits(e, t) {
    return Rf(this, void 0, void 0, function* () {
      const i = this._getModel(e);
      if (!i)
        return t;
      const r = [];
      let o;
      t = t.slice(0).sort((s, a) => {
        if (s.range && a.range)
          return V.compareRangesUsingStarts(s.range, a.range);
        let l = s.range ? 0 : 1, u = a.range ? 0 : 1;
        return l - u;
      });
      for (let { range: s, text: a, eol: l } of t) {
        if (typeof l == "number" && (o = l), V.isEmpty(s) && !a)
          continue;
        const u = i.getValueInRange(s);
        if (a = a.replace(/\r\n|\n|\r/g, i.eol), u === a)
          continue;
        if (Math.max(a.length, u.length) > xd._diffLimit) {
          r.push({ range: s, text: a });
          continue;
        }
        const c = Hoe(u, a, !1), h = i.offsetAt(V.lift(s).getStartPosition());
        for (const d of c) {
          const f = i.positionAt(h + d.originalStart), p = i.positionAt(h + d.originalStart + d.originalLength), g = {
            text: a.substr(d.modifiedStart, d.modifiedLength),
            range: { startLineNumber: f.lineNumber, startColumn: f.column, endLineNumber: p.lineNumber, endColumn: p.column }
          };
          i.getValueInRange(g.range) !== g.text && r.push(g);
        }
      }
      return typeof o == "number" && r.push({ eol: o, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } }), r;
    });
  }
  // ---- END minimal edits ---------------------------------------------------------------
  computeLinks(e) {
    return Rf(this, void 0, void 0, function* () {
      let t = this._getModel(e);
      return t ? Qoe(t) : null;
    });
  }
  textualSuggest(e, t, i, r) {
    return Rf(this, void 0, void 0, function* () {
      const o = new yg(!0), s = new RegExp(i, r), a = /* @__PURE__ */ new Set();
      e:
        for (let l of e) {
          const u = this._getModel(l);
          if (u) {
            for (let c of u.words(s))
              if (!(c === t || !isNaN(Number(c))) && (a.add(c), a.size > xd._suggestionsLimit))
                break e;
          }
        }
      return { words: Array.from(a), duration: o.elapsed() };
    });
  }
  // ---- END suggest --------------------------------------------------------------------------
  //#region -- word ranges --
  computeWordRanges(e, t, i, r) {
    return Rf(this, void 0, void 0, function* () {
      let o = this._getModel(e);
      if (!o)
        return /* @__PURE__ */ Object.create(null);
      const s = new RegExp(i, r), a = /* @__PURE__ */ Object.create(null);
      for (let l = t.startLineNumber; l < t.endLineNumber; l++) {
        let u = o.getLineWords(l, s);
        for (const c of u) {
          if (!isNaN(Number(c.word)))
            continue;
          let h = a[c.word];
          h || (h = [], a[c.word] = h), h.push({
            startLineNumber: l,
            startColumn: c.startColumn,
            endLineNumber: l,
            endColumn: c.endColumn
          });
        }
      }
      return a;
    });
  }
  //#endregion
  navigateValueSet(e, t, i, r, o) {
    return Rf(this, void 0, void 0, function* () {
      let s = this._getModel(e);
      if (!s)
        return null;
      let a = new RegExp(r, o);
      t.startColumn === t.endColumn && (t = {
        startLineNumber: t.startLineNumber,
        startColumn: t.startColumn,
        endLineNumber: t.endLineNumber,
        endColumn: t.endColumn + 1
      });
      let l = s.getValueInRange(t), u = s.getWordAtPosition({ lineNumber: t.startLineNumber, column: t.startColumn }, a);
      if (!u)
        return null;
      let c = s.getValueInRange(u);
      return CT.INSTANCE.navigateValueSet(t, l, u, c, i);
    });
  }
  // ---- BEGIN foreign module support --------------------------------------------------------------------------
  loadForeignModule(e, t, i) {
    let s = {
      host: UG(i, (a, l) => this._host.fhr(a, l)),
      getMirrorModels: () => this._getModels()
    };
    return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(s, t), Promise.resolve(wN(this._foreignModule))) : Promise.reject(new Error("Unexpected usage"));
  }
  // foreign method request
  fmr(e, t) {
    if (!this._foreignModule || typeof this._foreignModule[e] != "function")
      return Promise.reject(new Error("Missing requestHandler or method: " + e));
    try {
      return Promise.resolve(this._foreignModule[e].apply(this._foreignModule, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
}
xd._diffLimit = 1e5;
xd._suggestionsLimit = 1e4;
typeof importScripts == "function" && (gn.monaco = fG());
const u5 = Vt("textResourceConfigurationService"), c5 = Vt("textResourcePropertiesService");
function ss(n, e = 0) {
  return n[n.length - (1 + e)];
}
function ese(n) {
  if (n.length === 0)
    throw new Error("Invalid tail call");
  return [n.slice(0, n.length - 1), n[n.length - 1]];
}
function Gu(n, e, t = (i, r) => i === r) {
  if (n === e)
    return !0;
  if (!n || !e || n.length !== e.length)
    return !1;
  for (let i = 0, r = n.length; i < r; i++)
    if (!t(n[i], e[i]))
      return !1;
  return !0;
}
function tse(n, e, t) {
  let i = 0, r = n.length - 1;
  for (; i <= r; ) {
    const o = (i + r) / 2 | 0, s = t(n[o], e);
    if (s < 0)
      i = o + 1;
    else if (s > 0)
      r = o - 1;
    else
      return o;
  }
  return -(i + 1);
}
function NCe(n, e) {
  let t = 0, i = n.length;
  if (i === 0)
    return 0;
  for (; t < i; ) {
    const r = Math.floor((t + i) / 2);
    e(n[r]) ? i = r : t = r + 1;
  }
  return t;
}
function ak(n, e, t) {
  if (n = n | 0, n >= e.length)
    throw new TypeError("invalid index");
  let i = e[Math.floor(e.length * Math.random())], r = [], o = [], s = [];
  for (let a of e) {
    const l = t(a, i);
    l < 0 ? r.push(a) : l > 0 ? o.push(a) : s.push(a);
  }
  return n < r.length ? ak(n, r, t) : n < r.length + s.length ? s[0] : ak(n - (r.length + s.length), o, t);
}
function ICe(n, e) {
  const t = [];
  let i;
  for (const r of n.slice(0).sort(e))
    !i || e(i[0], r) !== 0 ? (i = [r], t.push(i)) : i.push(r);
  return t;
}
function ise(n) {
  return n.filter((e) => !!e);
}
function nse(n) {
  return !Array.isArray(n) || n.length === 0;
}
function NN(n) {
  return Array.isArray(n) && n.length > 0;
}
function h5(n, e) {
  if (!e)
    return n.filter((i, r) => n.indexOf(i) === r);
  const t = /* @__PURE__ */ Object.create(null);
  return n.filter((i) => {
    const r = e(i);
    return t[r] ? !1 : (t[r] = !0, !0);
  });
}
function lk(n) {
  const e = /* @__PURE__ */ new Set();
  return n.filter((t) => e.has(t) ? !1 : (e.add(t), !0));
}
function yT(n, e) {
  return n.length > 0 ? n[0] : e;
}
function PCe(n) {
  return [].concat(...n);
}
function Ar(n, e) {
  let t = typeof e == "number" ? n : 0;
  typeof e == "number" ? t = n : (t = 0, e = n);
  const i = [];
  if (t <= e)
    for (let r = t; r < e; r++)
      i.push(r);
  else
    for (let r = t; r > e; r--)
      i.push(r);
  return i;
}
function $v(n, e, t) {
  const i = n.slice(0, e), r = n.slice(e);
  return i.concat(t, r);
}
function aD(n, e) {
  const t = n.indexOf(e);
  t > -1 && (n.splice(t, 1), n.unshift(e));
}
function hy(n, e) {
  const t = n.indexOf(e);
  t > -1 && (n.splice(t, 1), n.push(e));
}
function rse(n) {
  return Array.isArray(n) ? n : [n];
}
const H_ = Vt("logService");
var $a;
(function(n) {
  n[n.Trace = 0] = "Trace", n[n.Debug = 1] = "Debug", n[n.Info = 2] = "Info", n[n.Warning = 3] = "Warning", n[n.Error = 4] = "Error", n[n.Critical = 5] = "Critical", n[n.Off = 6] = "Off";
})($a || ($a = {}));
const d5 = $a.Info;
class ose extends ge {
  constructor() {
    super(...arguments), this.level = d5, this._onDidChangeLogLevel = this._register(new j());
  }
  setLevel(e) {
    this.level !== e && (this.level = e, this._onDidChangeLogLevel.fire(this.level));
  }
  getLevel() {
    return this.level;
  }
}
class sse extends ose {
  constructor(e = d5) {
    super(), this.setLevel(e);
  }
  trace(e, ...t) {
    this.getLevel() <= $a.Trace && console.log("%cTRACE", "color: #888", e, ...t);
  }
  debug(e, ...t) {
    this.getLevel() <= $a.Debug && console.log("%cDEBUG", "background: #eee; color: #888", e, ...t);
  }
  info(e, ...t) {
    this.getLevel() <= $a.Info && console.log("%c INFO", "color: #33f", e, ...t);
  }
  error(e, ...t) {
    this.getLevel() <= $a.Error && console.log("%c  ERR", "color: #f33", e, ...t);
  }
  dispose() {
  }
}
class ase extends ge {
  constructor(e) {
    super(), this.logger = e, this._register(e);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(e, ...t) {
    this.logger.trace(e, ...t);
  }
  debug(e, ...t) {
    this.logger.debug(e, ...t);
  }
  info(e, ...t) {
    this.logger.info(e, ...t);
  }
  error(e, ...t) {
    this.logger.error(e, ...t);
  }
}
var lse = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, lD = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, f5 = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
const uk = 60 * 1e3, ck = 5 * 60 * 1e3;
function Nc(n, e) {
  let t = n.getModel(e);
  return !(!t || t.isTooLargeForSyncing());
}
let wT = class extends ge {
  constructor(e, t, i) {
    super(), this._modelService = e, this._workerManager = this._register(new cse(this._modelService)), this._logService = i, this._register(QG.register("*", {
      provideLinks: (r, o) => Nc(this._modelService, r.uri) ? this._workerManager.withWorker().then((s) => s.computeLinks(r.uri)).then((s) => s && { links: s }) : Promise.resolve({ links: [] })
    })), this._register(hb.register("*", new use(this._workerManager, t, this._modelService)));
  }
  dispose() {
    super.dispose();
  }
  canComputeDiff(e, t) {
    return Nc(this._modelService, e) && Nc(this._modelService, t);
  }
  computeDiff(e, t, i, r) {
    return this._workerManager.withWorker().then((o) => o.computeDiff(e, t, i, r));
  }
  computeMoreMinimalEdits(e, t) {
    if (NN(t)) {
      if (!Nc(this._modelService, e))
        return Promise.resolve(t);
      const i = yg.create(!0), r = this._workerManager.withWorker().then((o) => o.computeMoreMinimalEdits(e, t));
      return r.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", e.toString(!0), i.elapsed())), Promise.race([r, Vv(1e3).then(() => t)]);
    } else
      return Promise.resolve(void 0);
  }
  canNavigateValueSet(e) {
    return Nc(this._modelService, e);
  }
  navigateValueSet(e, t, i) {
    return this._workerManager.withWorker().then((r) => r.navigateValueSet(e, t, i));
  }
  canComputeWordRanges(e) {
    return Nc(this._modelService, e);
  }
  computeWordRanges(e, t) {
    return this._workerManager.withWorker().then((i) => i.computeWordRanges(e, t));
  }
};
wT = lse([
  lD(0, ro),
  lD(1, u5),
  lD(2, H_)
], wT);
class use {
  constructor(e, t, i) {
    this._debugDisplayName = "wordbasedCompletions", this._workerManager = e, this._configurationService = t, this._modelService = i;
  }
  provideCompletionItems(e, t) {
    return f5(this, void 0, void 0, function* () {
      const i = this._configurationService.getValue(e.uri, t, "editor");
      if (!i.wordBasedSuggestions)
        return;
      const r = [];
      if (i.wordBasedSuggestionsMode === "currentDocument")
        Nc(this._modelService, e.uri) && r.push(e.uri);
      else
        for (const h of this._modelService.getModels())
          Nc(this._modelService, h.uri) && (h === e ? r.unshift(h.uri) : (i.wordBasedSuggestionsMode === "allDocuments" || h.getLanguageIdentifier().id === e.getLanguageIdentifier().id) && r.push(h.uri));
      if (r.length === 0)
        return;
      const o = ui.getWordDefinition(e.getLanguageIdentifier().id), s = e.getWordAtPosition(t), a = s ? new V(t.lineNumber, s.startColumn, t.lineNumber, s.endColumn) : V.fromPositions(t), l = a.setEndPosition(t.lineNumber, t.column), c = yield (yield this._workerManager.withWorker()).textualSuggest(r, s == null ? void 0 : s.word, o);
      if (c)
        return {
          duration: c.duration,
          suggestions: c.words.map((h) => ({
            kind: 18,
            label: h,
            insertText: h,
            range: { insert: l, replace: a }
          }))
        };
    });
  }
}
class cse extends ge {
  constructor(e) {
    super(), this._modelService = e, this._editorWorkerClient = null, this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._register(new F_()).cancelAndSet(() => this._checkStopIdleWorker(), Math.round(ck / 2)), this._register(this._modelService.onModelRemoved((i) => this._checkStopEmptyWorker()));
  }
  dispose() {
    this._editorWorkerClient && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null), super.dispose();
  }
  /**
   * Check if the model service has no more models and stop the worker if that is the case.
   */
  _checkStopEmptyWorker() {
    if (!this._editorWorkerClient)
      return;
    this._modelService.getModels().length === 0 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  /**
   * Check if the worker has been idle for a while and then stop it.
   */
  _checkStopIdleWorker() {
    if (!this._editorWorkerClient)
      return;
    (/* @__PURE__ */ new Date()).getTime() - this._lastWorkerUsedTime > ck && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  withWorker() {
    return this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._editorWorkerClient || (this._editorWorkerClient = new p5(this._modelService, !1, "editorWorkerService")), Promise.resolve(this._editorWorkerClient);
  }
}
class hse extends ge {
  constructor(e, t, i) {
    if (super(), this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), this._proxy = e, this._modelService = t, !i) {
      let r = new F_();
      r.cancelAndSet(() => this._checkStopModelSync(), Math.round(uk / 2)), this._register(r);
    }
  }
  dispose() {
    for (let e in this._syncedModels)
      yi(this._syncedModels[e]);
    this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), super.dispose();
  }
  ensureSyncedResources(e) {
    for (const t of e) {
      let i = t.toString();
      this._syncedModels[i] || this._beginModelSync(t), this._syncedModels[i] && (this._syncedModelsLastUsedTime[i] = (/* @__PURE__ */ new Date()).getTime());
    }
  }
  _checkStopModelSync() {
    let e = (/* @__PURE__ */ new Date()).getTime(), t = [];
    for (let i in this._syncedModelsLastUsedTime)
      e - this._syncedModelsLastUsedTime[i] > uk && t.push(i);
    for (const i of t)
      this._stopModelSync(i);
  }
  _beginModelSync(e) {
    let t = this._modelService.getModel(e);
    if (!t || t.isTooLargeForSyncing())
      return;
    let i = e.toString();
    this._proxy.acceptNewModel({
      url: t.uri.toString(),
      lines: t.getLinesContent(),
      EOL: t.getEOL(),
      versionId: t.getVersionId()
    });
    const r = new ht();
    r.add(t.onDidChangeContent((o) => {
      this._proxy.acceptModelChanged(i.toString(), o);
    })), r.add(t.onWillDispose(() => {
      this._stopModelSync(i);
    })), r.add(Ri(() => {
      this._proxy.acceptRemovedModel(i);
    })), this._syncedModels[i] = r;
  }
  _stopModelSync(e) {
    let t = this._syncedModels[e];
    delete this._syncedModels[e], delete this._syncedModelsLastUsedTime[e], yi(t);
  }
}
class hk {
  constructor(e) {
    this._instance = e, this._proxyObj = Promise.resolve(this._instance);
  }
  dispose() {
    this._instance.dispose();
  }
  getProxyObject() {
    return this._proxyObj;
  }
}
class uD {
  constructor(e) {
    this._workerClient = e;
  }
  // foreign host request
  fhr(e, t) {
    return this._workerClient.fhr(e, t);
  }
}
class p5 extends ge {
  constructor(e, t, i) {
    super(), this._disposed = !1, this._modelService = e, this._keepIdleModels = t, this._workerFactory = new ZS(i), this._worker = null, this._modelManager = null;
  }
  // foreign host request
  fhr(e, t) {
    throw new Error("Not implemented!");
  }
  _getOrCreateWorker() {
    if (!this._worker)
      try {
        this._worker = this._register(new yoe(this._workerFactory, "vs/editor/common/services/editorSimpleWorker", new uD(this)));
      } catch (e) {
        gT(e), this._worker = new hk(new xd(new uD(this), null));
      }
    return this._worker;
  }
  _getProxy() {
    return this._getOrCreateWorker().getProxyObject().then(void 0, (e) => (gT(e), this._worker = new hk(new xd(new uD(this), null)), this._getOrCreateWorker().getProxyObject()));
  }
  _getOrCreateModelManager(e) {
    return this._modelManager || (this._modelManager = this._register(new hse(e, this._modelService, this._keepIdleModels))), this._modelManager;
  }
  _withSyncedResources(e) {
    return this._disposed ? Promise.reject(HS()) : this._getProxy().then((t) => (this._getOrCreateModelManager(t).ensureSyncedResources(e), t));
  }
  computeDiff(e, t, i, r) {
    return this._withSyncedResources([e, t]).then((o) => o.computeDiff(e.toString(), t.toString(), i, r));
  }
  computeMoreMinimalEdits(e, t) {
    return this._withSyncedResources([e]).then((i) => i.computeMoreMinimalEdits(e.toString(), t));
  }
  computeLinks(e) {
    return this._withSyncedResources([e]).then((t) => t.computeLinks(e.toString()));
  }
  textualSuggest(e, t, i) {
    return f5(this, void 0, void 0, function* () {
      const r = yield this._withSyncedResources(e), o = i.source, s = qL(i);
      return r.textualSuggest(e.map((a) => a.toString()), t, o, s);
    });
  }
  computeWordRanges(e, t) {
    return this._withSyncedResources([e]).then((i) => {
      let r = this._modelService.getModel(e);
      if (!r)
        return Promise.resolve(null);
      let o = ui.getWordDefinition(r.getLanguageIdentifier().id), s = o.source, a = qL(o);
      return i.computeWordRanges(e.toString(), t, s, a);
    });
  }
  navigateValueSet(e, t, i) {
    return this._withSyncedResources([e]).then((r) => {
      let o = this._modelService.getModel(e);
      if (!o)
        return null;
      let s = ui.getWordDefinition(o.getLanguageIdentifier().id), a = s.source, l = qL(s);
      return r.navigateValueSet(e.toString(), t, i, a, l);
    });
  }
  dispose() {
    super.dispose(), this._disposed = !0;
  }
}
function dse(n, e) {
  return new fse(n, e);
}
class fse extends p5 {
  constructor(e, t) {
    super(e, t.keepIdleModels || !1, t.label), this._foreignModuleId = t.moduleId, this._foreignModuleCreateData = t.createData || null, this._foreignModuleHost = t.host || null, this._foreignProxy = null;
  }
  // foreign host request
  fhr(e, t) {
    if (!this._foreignModuleHost || typeof this._foreignModuleHost[e] != "function")
      return Promise.reject(new Error("Missing method " + e + " or missing main thread foreign host."));
    try {
      return Promise.resolve(this._foreignModuleHost[e].apply(this._foreignModuleHost, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
  _getForeignProxy() {
    return this._foreignProxy || (this._foreignProxy = this._getProxy().then((e) => {
      const t = this._foreignModuleHost ? wN(this._foreignModuleHost) : [];
      return e.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, t).then((i) => {
        this._foreignModuleCreateData = null;
        const r = (a, l) => e.fmr(a, l), o = (a, l) => function() {
          const u = Array.prototype.slice.call(arguments, 0);
          return l(a, u);
        };
        let s = {};
        for (const a of i)
          s[a] = o(a, r);
        return s;
      });
    })), this._foreignProxy;
  }
  getProxy() {
    return this._getForeignProxy();
  }
  withSyncedResources(e) {
    return this._withSyncedResources(e).then((t) => this.getProxy());
  }
}
class Zr {
  constructor(e, t) {
    this._tokens = e, this._tokensCount = this._tokens.length >>> 1, this._text = t;
  }
  static createEmpty(e) {
    const i = new Uint32Array(2);
    return i[0] = e.length, i[1] = 16793600, new Zr(i, e);
  }
  equals(e) {
    return e instanceof Zr ? this.slicedEquals(e, 0, this._tokensCount) : !1;
  }
  slicedEquals(e, t, i) {
    if (this._text !== e._text || this._tokensCount !== e._tokensCount)
      return !1;
    const r = t << 1, o = r + (i << 1);
    for (let s = r; s < o; s++)
      if (this._tokens[s] !== e._tokens[s])
        return !1;
    return !0;
  }
  getLineContent() {
    return this._text;
  }
  getCount() {
    return this._tokensCount;
  }
  getStartOffset(e) {
    return e > 0 ? this._tokens[e - 1 << 1] : 0;
  }
  getMetadata(e) {
    return this._tokens[(e << 1) + 1];
  }
  getLanguageId(e) {
    const t = this._tokens[(e << 1) + 1];
    return ra.getLanguageId(t);
  }
  getStandardTokenType(e) {
    const t = this._tokens[(e << 1) + 1];
    return ra.getTokenType(t);
  }
  getForeground(e) {
    const t = this._tokens[(e << 1) + 1];
    return ra.getForeground(t);
  }
  getClassName(e) {
    const t = this._tokens[(e << 1) + 1];
    return ra.getClassNameFromMetadata(t);
  }
  getInlineStyle(e, t) {
    const i = this._tokens[(e << 1) + 1];
    return ra.getInlineStyleFromMetadata(i, t);
  }
  getEndOffset(e) {
    return this._tokens[e << 1];
  }
  /**
   * Find the token containing offset `offset`.
   * @param offset The search offset
   * @return The index of the token containing the offset.
   */
  findTokenIndexAtOffset(e) {
    return Zr.findIndexInTokensArray(this._tokens, e);
  }
  inflate() {
    return this;
  }
  sliceAndInflate(e, t, i) {
    return new IN(this, e, t, i);
  }
  static convertToEndOffset(e, t) {
    const r = (e.length >>> 1) - 1;
    for (let o = 0; o < r; o++)
      e[o << 1] = e[o + 1 << 1];
    e[r << 1] = t;
  }
  static findIndexInTokensArray(e, t) {
    if (e.length <= 2)
      return 0;
    let i = 0, r = (e.length >>> 1) - 1;
    for (; i < r; ) {
      const o = i + Math.floor((r - i) / 2), s = e[o << 1];
      if (s === t)
        return o + 1;
      s < t ? i = o + 1 : s > t && (r = o);
    }
    return i;
  }
}
class IN {
  constructor(e, t, i, r) {
    this._source = e, this._startOffset = t, this._endOffset = i, this._deltaOffset = r, this._firstTokenIndex = e.findTokenIndexAtOffset(t), this._tokensCount = 0;
    for (let o = this._firstTokenIndex, s = e.getCount(); o < s && !(e.getStartOffset(o) >= i); o++)
      this._tokensCount++;
  }
  equals(e) {
    return e instanceof IN ? this._startOffset === e._startOffset && this._endOffset === e._endOffset && this._deltaOffset === e._deltaOffset && this._source.slicedEquals(e._source, this._firstTokenIndex, this._tokensCount) : !1;
  }
  getCount() {
    return this._tokensCount;
  }
  getForeground(e) {
    return this._source.getForeground(this._firstTokenIndex + e);
  }
  getEndOffset(e) {
    const t = this._source.getEndOffset(this._firstTokenIndex + e);
    return Math.min(this._endOffset, t) - this._startOffset + this._deltaOffset;
  }
  getClassName(e) {
    return this._source.getClassName(this._firstTokenIndex + e);
  }
  getInlineStyle(e, t) {
    return this._source.getInlineStyle(this._firstTokenIndex + e, t);
  }
  findTokenIndexAtOffset(e) {
    return this._source.findTokenIndexAtOffset(e + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
  }
}
class ha {
  constructor(e, t, i, r) {
    this.startColumn = e, this.endColumn = t, this.className = i, this.type = r;
  }
  static _equals(e, t) {
    return e.startColumn === t.startColumn && e.endColumn === t.endColumn && e.className === t.className && e.type === t.type;
  }
  static equalsArr(e, t) {
    const i = e.length, r = t.length;
    if (i !== r)
      return !1;
    for (let o = 0; o < i; o++)
      if (!ha._equals(e[o], t[o]))
        return !1;
    return !0;
  }
  static extractWrapped(e, t, i) {
    if (e.length === 0)
      return e;
    const r = t + 1, o = i + 1, s = i - t, a = [];
    let l = 0;
    for (const u of e)
      u.endColumn <= r || u.startColumn >= o || (a[l++] = new ha(Math.max(1, u.startColumn - r + 1), Math.min(s + 1, u.endColumn - r + 1), u.className, u.type));
    return a;
  }
  static filter(e, t, i, r) {
    if (e.length === 0)
      return [];
    let o = [], s = 0;
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a], c = u.range;
      if (c.endLineNumber < t || c.startLineNumber > t || c.isEmpty() && (u.type === 0 || u.type === 3))
        continue;
      const h = c.startLineNumber === t ? c.startColumn : i, d = c.endLineNumber === t ? c.endColumn : r;
      o[s++] = new ha(h, d, u.inlineClassName, u.type);
    }
    return o;
  }
  static _typeCompare(e, t) {
    const i = [2, 0, 1, 3];
    return i[e] - i[t];
  }
  static compare(e, t) {
    if (e.startColumn === t.startColumn) {
      if (e.endColumn === t.endColumn) {
        const i = ha._typeCompare(e.type, t.type);
        return i === 0 ? e.className < t.className ? -1 : e.className > t.className ? 1 : 0 : i;
      }
      return e.endColumn - t.endColumn;
    }
    return e.startColumn - t.startColumn;
  }
}
class dk {
  constructor(e, t, i, r) {
    this.startOffset = e, this.endOffset = t, this.className = i, this.metadata = r;
  }
}
class _b {
  constructor() {
    this.stopOffsets = [], this.classNames = [], this.metadata = [], this.count = 0;
  }
  static _metadata(e) {
    let t = 0;
    for (let i = 0, r = e.length; i < r; i++)
      t |= e[i];
    return t;
  }
  consumeLowerThan(e, t, i) {
    for (; this.count > 0 && this.stopOffsets[0] < e; ) {
      let r = 0;
      for (; r + 1 < this.count && this.stopOffsets[r] === this.stopOffsets[r + 1]; )
        r++;
      i.push(new dk(t, this.stopOffsets[r], this.classNames.join(" "), _b._metadata(this.metadata))), t = this.stopOffsets[r] + 1, this.stopOffsets.splice(0, r + 1), this.classNames.splice(0, r + 1), this.metadata.splice(0, r + 1), this.count -= r + 1;
    }
    return this.count > 0 && t < e && (i.push(new dk(t, e - 1, this.classNames.join(" "), _b._metadata(this.metadata))), t = e), t;
  }
  insert(e, t, i) {
    if (this.count === 0 || this.stopOffsets[this.count - 1] <= e)
      this.stopOffsets.push(e), this.classNames.push(t), this.metadata.push(i);
    else
      for (let r = 0; r < this.count; r++)
        if (this.stopOffsets[r] >= e) {
          this.stopOffsets.splice(r, 0, e), this.classNames.splice(r, 0, t), this.metadata.splice(r, 0, i);
          break;
        }
    this.count++;
  }
}
class pse {
  /**
   * Normalize line decorations. Overlapping decorations will generate multiple segments
   */
  static normalize(e, t) {
    if (t.length === 0)
      return [];
    let i = [];
    const r = new _b();
    let o = 0;
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      let u = l.startColumn, c = l.endColumn;
      const h = l.className, d = l.type === 1 ? 2 : l.type === 2 ? 4 : 0;
      if (u > 1) {
        const g = e.charCodeAt(u - 2);
        jn(g) && u--;
      }
      if (c > 1) {
        const g = e.charCodeAt(c - 2);
        jn(g) && c--;
      }
      const f = u - 1, p = c - 2;
      o = r.consumeLowerThan(f, o, i), r.count === 0 && (o = f), r.insert(p, h, d);
    }
    return r.consumeLowerThan(1073741824, o, i), i;
  }
}
class Lr {
  constructor(e, t, i) {
    this.endIndex = e, this.type = t, this.metadata = i;
  }
  isWhitespace() {
    return !!(this.metadata & 1);
  }
  isPseudoAfter() {
    return !!(this.metadata & 4);
  }
}
class gse {
  constructor(e, t) {
    this.startOffset = e, this.endOffset = t;
  }
  equals(e) {
    return this.startOffset === e.startOffset && this.endOffset === e.endOffset;
  }
}
class Sg {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g, _, m, v, C) {
    this.useMonospaceOptimizations = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.continuesWithWrappedLine = r, this.isBasicASCII = o, this.containsRTL = s, this.fauxIndentLength = a, this.lineTokens = l, this.lineDecorations = u.sort(ha.compare), this.tabSize = c, this.startVisibleColumn = h, this.spaceWidth = d, this.stopRenderingLineAfter = g, this.renderWhitespace = _ === "all" ? 4 : _ === "boundary" ? 1 : _ === "selection" ? 2 : _ === "trailing" ? 3 : 0, this.renderControlCharacters = m, this.fontLigatures = v, this.selectionsOnLine = C && C.sort((L, S) => L.startOffset < S.startOffset ? -1 : 1);
    const y = Math.abs(p - d), b = Math.abs(f - d);
    y < b ? (this.renderSpaceWidth = p, this.renderSpaceCharCode = 11825) : (this.renderSpaceWidth = f, this.renderSpaceCharCode = 183);
  }
  sameSelection(e) {
    if (this.selectionsOnLine === null)
      return e === null;
    if (e === null || e.length !== this.selectionsOnLine.length)
      return !1;
    for (let t = 0; t < this.selectionsOnLine.length; t++)
      if (!this.selectionsOnLine[t].equals(e[t]))
        return !1;
    return !0;
  }
  equals(e) {
    return this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineContent === e.lineContent && this.continuesWithWrappedLine === e.continuesWithWrappedLine && this.isBasicASCII === e.isBasicASCII && this.containsRTL === e.containsRTL && this.fauxIndentLength === e.fauxIndentLength && this.tabSize === e.tabSize && this.startVisibleColumn === e.startVisibleColumn && this.spaceWidth === e.spaceWidth && this.renderSpaceWidth === e.renderSpaceWidth && this.renderSpaceCharCode === e.renderSpaceCharCode && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.fontLigatures === e.fontLigatures && ha.equalsArr(this.lineDecorations, e.lineDecorations) && this.lineTokens.equals(e.lineTokens) && this.sameSelection(e.selectionsOnLine);
  }
}
class Wo {
  constructor(e, t) {
    this.length = e, this._data = new Uint32Array(this.length), this._absoluteOffsets = new Uint32Array(this.length);
  }
  static getPartIndex(e) {
    return (e & 4294901760) >>> 16;
  }
  static getCharIndex(e) {
    return (e & 65535) >>> 0;
  }
  setPartData(e, t, i, r) {
    let o = (t << 16 | i << 0) >>> 0;
    this._data[e] = o, this._absoluteOffsets[e] = r + i;
  }
  getAbsoluteOffsets() {
    return this._absoluteOffsets;
  }
  charOffsetToPartData(e) {
    return this.length === 0 ? 0 : e < 0 ? this._data[0] : e >= this.length ? this._data[this.length - 1] : this._data[e];
  }
  partDataToCharOffset(e, t, i) {
    if (this.length === 0)
      return 0;
    let r = (e << 16 | i << 0) >>> 0, o = 0, s = this.length - 1;
    for (; o + 1 < s; ) {
      let g = o + s >>> 1, _ = this._data[g];
      if (_ === r)
        return g;
      _ > r ? s = g : o = g;
    }
    if (o === s)
      return o;
    let a = this._data[o], l = this._data[s];
    if (a === r)
      return o;
    if (l === r)
      return s;
    let u = Wo.getPartIndex(a), c = Wo.getCharIndex(a), h = Wo.getPartIndex(l), d;
    u !== h ? d = t : d = Wo.getCharIndex(l);
    let f = i - c, p = d - i;
    return f <= p ? o : s;
  }
}
class bT {
  constructor(e, t, i) {
    this.characterMapping = e, this.containsRTL = t, this.containsForeignElements = i;
  }
}
function PN(n, e) {
  if (n.lineContent.length === 0) {
    if (n.lineDecorations.length > 0) {
      e.appendASCIIString("<span>");
      let t = 0, i = 0, r = 0;
      for (const s of n.lineDecorations)
        (s.type === 1 || s.type === 2) && (e.appendASCIIString('<span class="'), e.appendASCIIString(s.className), e.appendASCIIString('"></span>'), s.type === 1 && (r |= 1, t++), s.type === 2 && (r |= 2, i++));
      e.appendASCIIString("</span>");
      const o = new Wo(1, t + i);
      return o.setPartData(0, t, 0, 0), new bT(o, !1, r);
    }
    return e.appendASCIIString("<span><span></span></span>"), new bT(
      new Wo(0, 0),
      !1,
      0
      /* None */
    );
  }
  return Sse(_se(n), e);
}
class mse {
  constructor(e, t, i, r) {
    this.characterMapping = e, this.html = t, this.containsRTL = i, this.containsForeignElements = r;
  }
}
function e0(n) {
  let e = zp(1e4), t = PN(n, e);
  return new mse(t.characterMapping, e.build(), t.containsRTL, t.containsForeignElements);
}
class vse {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g) {
    this.fontIsMonospace = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.len = r, this.isOverflowing = o, this.parts = s, this.containsForeignElements = a, this.fauxIndentLength = l, this.tabSize = u, this.startVisibleColumn = c, this.containsRTL = h, this.spaceWidth = d, this.renderSpaceCharCode = f, this.renderWhitespace = p, this.renderControlCharacters = g;
  }
}
function _se(n) {
  const e = n.lineContent;
  let t, i;
  n.stopRenderingLineAfter !== -1 && n.stopRenderingLineAfter < e.length ? (t = !0, i = n.stopRenderingLineAfter) : (t = !1, i = e.length);
  let r = Cse(n.lineTokens, n.fauxIndentLength, i);
  (n.renderWhitespace === 4 || n.renderWhitespace === 1 || n.renderWhitespace === 2 && n.selectionsOnLine || n.renderWhitespace === 3) && (r = wse(n, e, i, r));
  let o = 0;
  if (n.lineDecorations.length > 0) {
    for (let s = 0, a = n.lineDecorations.length; s < a; s++) {
      const l = n.lineDecorations[s];
      l.type === 3 || l.type === 1 ? o |= 1 : l.type === 2 && (o |= 2);
    }
    r = bse(e, i, r, n.lineDecorations);
  }
  return n.containsRTL || (r = yse(e, r, !n.isBasicASCII || n.fontLigatures)), new vse(n.useMonospaceOptimizations, n.canUseHalfwidthRightwardsArrow, e, i, t, r, o, n.fauxIndentLength, n.tabSize, n.startVisibleColumn, n.containsRTL, n.spaceWidth, n.renderSpaceCharCode, n.renderWhitespace, n.renderControlCharacters);
}
function Cse(n, e, t) {
  let i = [], r = 0;
  e > 0 && (i[r++] = new Lr(e, "", 0));
  for (let o = 0, s = n.getCount(); o < s; o++) {
    const a = n.getEndOffset(o);
    if (a <= e)
      continue;
    const l = n.getClassName(o);
    if (a >= t) {
      i[r++] = new Lr(t, l, 0);
      break;
    }
    i[r++] = new Lr(a, l, 0);
  }
  return i;
}
function yse(n, e, t) {
  let i = 0, r = [], o = 0;
  if (t)
    for (let s = 0, a = e.length; s < a; s++) {
      const l = e[s], u = l.endIndex;
      if (i + 50 < u) {
        const c = l.type, h = l.metadata;
        let d = -1, f = i;
        for (let p = i; p < u; p++)
          n.charCodeAt(p) === 32 && (d = p), d !== -1 && p - f >= 50 && (r[o++] = new Lr(d + 1, c, h), f = d + 1, d = -1);
        f !== u && (r[o++] = new Lr(u, c, h));
      } else
        r[o++] = l;
      i = u;
    }
  else
    for (let s = 0, a = e.length; s < a; s++) {
      const l = e[s], u = l.endIndex;
      let c = u - i;
      if (c > 50) {
        const h = l.type, d = l.metadata, f = Math.ceil(
          c / 50
          /* LongToken */
        );
        for (let p = 1; p < f; p++) {
          let g = i + p * 50;
          r[o++] = new Lr(g, h, d);
        }
        r[o++] = new Lr(u, h, d);
      } else
        r[o++] = l;
      i = u;
    }
  return r;
}
function wse(n, e, t, i) {
  const r = n.continuesWithWrappedLine, o = n.fauxIndentLength, s = n.tabSize, a = n.startVisibleColumn, l = n.useMonospaceOptimizations, u = n.selectionsOnLine, c = n.renderWhitespace === 1, h = n.renderWhitespace === 3, d = n.renderSpaceWidth !== n.spaceWidth;
  let f = [], p = 0, g = 0, _ = i[g].type, m = i[g].endIndex;
  const v = i.length;
  let C = !1, y = Es(e), b;
  y === -1 ? (C = !0, y = t, b = t) : b = wg(e);
  let L = !1, S = 0, E = u && u[S], D = a % s;
  for (let T = o; T < t; T++) {
    const A = e.charCodeAt(T);
    E && T >= E.endOffset && (S++, E = u && u[S]);
    let P;
    if (T < y || T > b)
      P = !0;
    else if (A === 9)
      P = !0;
    else if (A === 32)
      if (c)
        if (L)
          P = !0;
        else {
          const G = T + 1 < t ? e.charCodeAt(T + 1) : 0;
          P = G === 32 || G === 9;
        }
      else
        P = !0;
    else
      P = !1;
    if (P && u && (P = !!E && E.startOffset <= T && E.endOffset > T), P && h && (P = C || T > b), L) {
      if (!P || !l && D >= s) {
        if (d) {
          const G = p > 0 ? f[p - 1].endIndex : o;
          for (let U = G + 1; U <= T; U++)
            f[p++] = new Lr(
              U,
              "mtkw",
              1
              /* IS_WHITESPACE */
            );
        } else
          f[p++] = new Lr(
            T,
            "mtkw",
            1
            /* IS_WHITESPACE */
          );
        D = D % s;
      }
    } else
      (T === m || P && T > o) && (f[p++] = new Lr(T, _, 0), D = D % s);
    for (A === 9 ? D = s : Xa(A) ? D += 2 : D++, L = P; T === m; )
      g++, g < v && (_ = i[g].type, m = i[g].endIndex);
  }
  let O = !1;
  if (L)
    if (r && c) {
      let T = t > 0 ? e.charCodeAt(t - 1) : 0, A = t > 1 ? e.charCodeAt(t - 2) : 0;
      T === 32 && A !== 32 && A !== 9 || (O = !0);
    } else
      O = !0;
  if (O)
    if (d) {
      const T = p > 0 ? f[p - 1].endIndex : o;
      for (let A = T + 1; A <= t; A++)
        f[p++] = new Lr(
          A,
          "mtkw",
          1
          /* IS_WHITESPACE */
        );
    } else
      f[p++] = new Lr(
        t,
        "mtkw",
        1
        /* IS_WHITESPACE */
      );
  else
    f[p++] = new Lr(t, _, 0);
  return f;
}
function bse(n, e, t, i) {
  i.sort(ha.compare);
  const r = pse.normalize(n, i), o = r.length;
  let s = 0, a = [], l = 0, u = 0;
  for (let h = 0, d = t.length; h < d; h++) {
    const f = t[h], p = f.endIndex, g = f.type, _ = f.metadata;
    for (; s < o && r[s].startOffset < p; ) {
      const m = r[s];
      if (m.startOffset > u && (u = m.startOffset, a[l++] = new Lr(u, g, _)), m.endOffset + 1 <= p)
        u = m.endOffset + 1, a[l++] = new Lr(u, g + " " + m.className, _ | m.metadata), s++;
      else {
        u = p, a[l++] = new Lr(u, g + " " + m.className, _ | m.metadata);
        break;
      }
    }
    p > u && (u = p, a[l++] = new Lr(u, g, _));
  }
  const c = t[t.length - 1].endIndex;
  if (s < o && r[s].startOffset === c)
    for (; s < o && r[s].startOffset === c; ) {
      const h = r[s];
      a[l++] = new Lr(u, h.className, h.metadata), s++;
    }
  return a;
}
function Sse(n, e) {
  const t = n.fontIsMonospace, i = n.canUseHalfwidthRightwardsArrow, r = n.containsForeignElements, o = n.lineContent, s = n.len, a = n.isOverflowing, l = n.parts, u = n.fauxIndentLength, c = n.tabSize, h = n.startVisibleColumn, d = n.containsRTL, f = n.spaceWidth, p = n.renderSpaceCharCode, g = n.renderWhitespace, _ = n.renderControlCharacters, m = new Wo(s + 1, l.length);
  let v = !1, C = 0, y = h, b = 0, L = 0, S = 0, E = 0;
  d ? e.appendASCIIString('<span dir="ltr">') : e.appendASCIIString("<span>");
  for (let D = 0, O = l.length; D < O; D++) {
    E += S;
    const T = l[D], A = T.endIndex, P = T.type, G = g !== 0 && T.isWhitespace(), U = G && !t && (P === "mtkw" || !r), $ = C === A && T.isPseudoAfter();
    if (b = 0, e.appendASCIIString('<span class="'), e.appendASCIIString(U ? "mtkz" : P), e.appendASCII(
      34
      /* DoubleQuote */
    ), G) {
      let k = 0;
      {
        let se = C, ne = y;
        for (; se < A; se++) {
          const ue = (o.charCodeAt(se) === 9 ? c - ne % c : 1) | 0;
          k += ue, se >= u && (ne += ue);
        }
      }
      for (U && (e.appendASCIIString(' style="width:'), e.appendASCIIString(String(f * k)), e.appendASCIIString('px"')), e.appendASCII(
        62
        /* GreaterThan */
      ); C < A; C++) {
        m.setPartData(C, D - L, b, E), L = 0;
        const se = o.charCodeAt(C);
        let ne;
        if (se === 9) {
          ne = c - y % c | 0, !i || ne > 1 ? e.write1(8594) : e.write1(65515);
          for (let Ce = 2; Ce <= ne; Ce++)
            e.write1(160);
        } else
          ne = 1, e.write1(p);
        b += ne, C >= u && (y += ne);
      }
      S = k;
    } else {
      let k = 0;
      for (e.appendASCII(
        62
        /* GreaterThan */
      ); C < A; C++) {
        m.setPartData(C, D - L, b, E), L = 0;
        const se = o.charCodeAt(C);
        let ne = 1, Ce = 1;
        switch (se) {
          case 9:
            ne = c - y % c, Ce = ne;
            for (let ue = 1; ue <= ne; ue++)
              e.write1(160);
            break;
          case 32:
            e.write1(160);
            break;
          case 60:
            e.appendASCIIString("&lt;");
            break;
          case 62:
            e.appendASCIIString("&gt;");
            break;
          case 38:
            e.appendASCIIString("&amp;");
            break;
          case 0:
            _ ? e.write1(9216) : e.appendASCIIString("&#00;");
            break;
          case 65279:
          case 8232:
          case 8233:
          case 133:
            e.write1(65533);
            break;
          default:
            Xa(se) && Ce++, _ && se < 32 ? e.write1(9216 + se) : _ && se === 127 ? e.write1(9249) : e.write1(se);
        }
        b += ne, k += ne, C >= u && (y += Ce);
      }
      S = k;
    }
    $ ? L++ : L = 0, C >= s && !v && T.isPseudoAfter() && (v = !0, m.setPartData(C, D, b, E)), e.appendASCIIString("</span>");
  }
  return v || m.setPartData(s, l.length - 1, b, E), a && e.appendASCIIString("<span>&hellip;</span>"), e.appendASCIIString("</span>"), new bT(m, d, r);
}
class fk {
  constructor(e, t, i, r) {
    this.top = e | 0, this.left = t | 0, this.width = i | 0, this.height = r | 0;
  }
}
class Ese {
  constructor(e, t) {
    this.outputLineIndex = e, this.outputOffset = t;
  }
}
class Uh {
  constructor(e, t, i) {
    this.breakOffsets = e, this.breakOffsetsVisibleColumn = t, this.wrappedTextIndentLength = i;
  }
  static getInputOffsetOfOutputPosition(e, t, i) {
    return t === 0 ? i : e[t - 1] + i;
  }
  static getOutputPositionOfInputOffset(e, t) {
    let i = 0, r = e.length - 1, o = 0, s = 0;
    for (; i <= r; ) {
      o = i + (r - i) / 2 | 0;
      const a = e[o];
      if (s = o > 0 ? e[o - 1] : 0, t < s)
        r = o - 1;
      else if (t >= a)
        i = o + 1;
      else
        break;
    }
    return new Ese(o, t - s);
  }
}
class Lse {
  constructor(e, t) {
    this.tabSize = e, this.data = t;
  }
}
class AN {
  constructor(e, t, i, r, o, s) {
    this.content = e, this.continuesWithWrappedLine = t, this.minColumn = i, this.maxColumn = r, this.startVisibleColumn = o, this.tokens = s;
  }
}
class $o {
  constructor(e, t, i, r, o, s, a, l, u, c) {
    this.minColumn = e, this.maxColumn = t, this.content = i, this.continuesWithWrappedLine = r, this.isBasicASCII = $o.isBasicASCII(i, s), this.containsRTL = $o.containsRTL(i, this.isBasicASCII, o), this.tokens = a, this.inlineDecorations = l, this.tabSize = u, this.startVisibleColumn = c;
  }
  static isBasicASCII(e, t) {
    return t ? kG(e) : !0;
  }
  static containsRTL(e, t, i) {
    return !t && i ? _N(e) : !1;
  }
}
class nw {
  constructor(e, t, i) {
    this.range = e, this.inlineClassName = t, this.type = i;
  }
}
class g5 {
  constructor(e, t) {
    this.range = e, this.options = t;
  }
}
function Dse(n) {
  return Array.isArray(n);
}
function Rse(n) {
  return !Dse(n);
}
function m5(n) {
  return typeof n == "string";
}
function pk(n) {
  return !m5(n);
}
function Ff(n) {
  return !n;
}
function qc(n, e) {
  return n.ignoreCase && e ? e.toLowerCase() : e;
}
function gk(n) {
  return n.replace(/[&<>'"_]/g, "-");
}
function Tse(n, e) {
  console.log(`${n.languageId}: ${e}`);
}
function ei(n, e) {
  return new Error(`${n.languageId}: ${e}`);
}
function Ac(n, e, t, i, r) {
  const o = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
  let s = null;
  return e.replace(o, function(a, l, u, c, h, d, f, p, g) {
    return Ff(u) ? Ff(c) ? !Ff(h) && h < i.length ? qc(n, i[h]) : !Ff(f) && n && typeof n[f] == "string" ? n[f] : (s === null && (s = r.split("."), s.unshift(r)), !Ff(d) && d < s.length ? qc(n, s[d]) : "") : qc(n, t) : "$";
  });
}
function dy(n, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    const i = n.tokenizer[t];
    if (i)
      return i;
    const r = t.lastIndexOf(".");
    r < 0 ? t = null : t = t.substr(0, r);
  }
  return null;
}
function Ose(n, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    if (n.stateNames[t])
      return !0;
    const r = t.lastIndexOf(".");
    r < 0 ? t = null : t = t.substr(0, r);
  }
  return !1;
}
const v5 = 5;
class Kv {
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  create(e, t) {
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new gp(e, t);
    let i = gp.getStackElementId(e);
    i.length > 0 && (i += "|"), i += t;
    let r = this._entries[i];
    return r || (r = new gp(e, t), this._entries[i] = r, r);
  }
}
Kv._INSTANCE = new Kv(v5);
class gp {
  constructor(e, t) {
    this.parent = e, this.state = t, this.depth = (this.parent ? this.parent.depth : 0) + 1;
  }
  static getStackElementId(e) {
    let t = "";
    for (; e !== null; )
      t.length > 0 && (t += "|"), t += e.state, e = e.parent;
    return t;
  }
  static _equals(e, t) {
    for (; e !== null && t !== null; ) {
      if (e === t)
        return !0;
      if (e.state !== t.state)
        return !1;
      e = e.parent, t = t.parent;
    }
    return e === null && t === null;
  }
  equals(e) {
    return gp._equals(this, e);
  }
  push(e) {
    return Kv.create(this, e);
  }
  pop() {
    return this.parent;
  }
  popall() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  switchTo(e) {
    return Kv.create(this.parent, e);
  }
}
class uv {
  constructor(e, t) {
    this.modeId = e, this.state = t;
  }
  equals(e) {
    return this.modeId === e.modeId && this.state.equals(e.state);
  }
  clone() {
    return this.state.clone() === this.state ? this : new uv(this.modeId, this.state);
  }
}
class Mc {
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  create(e, t) {
    if (t !== null)
      return new cv(e, t);
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new cv(e, t);
    let i = gp.getStackElementId(e), r = this._entries[i];
    return r || (r = new cv(e, null), this._entries[i] = r, r);
  }
}
Mc._INSTANCE = new Mc(v5);
class cv {
  constructor(e, t) {
    this.stack = e, this.embeddedModeData = t;
  }
  clone() {
    return (this.embeddedModeData ? this.embeddedModeData.clone() : null) === this.embeddedModeData ? this : Mc.create(this.stack, this.embeddedModeData);
  }
  equals(e) {
    return !(e instanceof cv) || !this.stack.equals(e.stack) ? !1 : this.embeddedModeData === null && e.embeddedModeData === null ? !0 : this.embeddedModeData === null || e.embeddedModeData === null ? !1 : this.embeddedModeData.equals(e.embeddedModeData);
  }
}
class xse {
  constructor() {
    this._tokens = [], this._language = null, this._lastTokenType = null, this._lastTokenLanguage = null;
  }
  enterMode(e, t) {
    this._language = t;
  }
  emit(e, t) {
    this._lastTokenType === t && this._lastTokenLanguage === this._language || (this._lastTokenType = t, this._lastTokenLanguage = this._language, this._tokens.push(new US(e, t, this._language)));
  }
  nestedModeTokenize(e, t, i, r) {
    const o = i.modeId, s = i.state, a = ln.get(o);
    if (!a)
      return this.enterMode(r, o), this.emit(r, ""), s;
    let l = a.tokenize(e, t, s, r);
    return this._tokens = this._tokens.concat(l.tokens), this._lastTokenType = null, this._lastTokenLanguage = null, this._language = null, l.endState;
  }
  finalize(e) {
    return new uN(this._tokens, e);
  }
}
class Cb {
  constructor(e, t) {
    this._modeService = e, this._theme = t, this._prependTokens = null, this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0;
  }
  enterMode(e, t) {
    this._currentLanguageId = this._modeService.getLanguageIdentifier(t).id;
  }
  emit(e, t) {
    let i = this._theme.match(this._currentLanguageId, t);
    this._lastTokenMetadata !== i && (this._lastTokenMetadata = i, this._tokens.push(e), this._tokens.push(i));
  }
  static _merge(e, t, i) {
    let r = e !== null ? e.length : 0, o = t.length, s = i !== null ? i.length : 0;
    if (r === 0 && o === 0 && s === 0)
      return new Uint32Array(0);
    if (r === 0 && o === 0)
      return i;
    if (o === 0 && s === 0)
      return e;
    let a = new Uint32Array(r + o + s);
    e !== null && a.set(e);
    for (let l = 0; l < o; l++)
      a[r + l] = t[l];
    return i !== null && a.set(i, r + o), a;
  }
  nestedModeTokenize(e, t, i, r) {
    const o = i.modeId, s = i.state, a = ln.get(o);
    if (!a)
      return this.enterMode(r, o), this.emit(r, ""), s;
    let l = a.tokenize2(e, t, s, r);
    return this._prependTokens = Cb._merge(this._prependTokens, this._tokens, l.tokens), this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0, l.endState;
  }
  finalize(e) {
    return new zS(Cb._merge(this._prependTokens, this._tokens, null), e);
  }
}
class t0 {
  constructor(e, t, i, r) {
    this._modeService = e, this._standaloneThemeService = t, this._modeId = i, this._lexer = r, this._embeddedModes = /* @__PURE__ */ Object.create(null), this.embeddedLoaded = Promise.resolve(void 0);
    let o = !1;
    this._tokenizationRegistryListener = ln.onDidChange((s) => {
      if (o)
        return;
      let a = !1;
      for (let l = 0, u = s.changedLanguages.length; l < u; l++) {
        let c = s.changedLanguages[l];
        if (this._embeddedModes[c]) {
          a = !0;
          break;
        }
      }
      a && (o = !0, ln.fire([this._modeId]), o = !1);
    });
  }
  dispose() {
    this._tokenizationRegistryListener.dispose();
  }
  getLoadStatus() {
    let e = [];
    for (let t in this._embeddedModes) {
      const i = ln.get(t);
      if (i) {
        if (i instanceof t0) {
          const o = i.getLoadStatus();
          o.loaded === !1 && e.push(o.promise);
        }
        continue;
      }
      const r = ln.getPromise(t);
      r && e.push(r);
    }
    return e.length === 0 ? {
      loaded: !0
    } : {
      loaded: !1,
      promise: Promise.all(e).then((t) => {
      })
    };
  }
  getInitialState() {
    let e = Kv.create(null, this._lexer.start);
    return Mc.create(e, null);
  }
  tokenize(e, t, i, r) {
    let o = new xse(), s = this._tokenize(e, t, i, r, o);
    return o.finalize(s);
  }
  tokenize2(e, t, i, r) {
    let o = new Cb(this._modeService, this._standaloneThemeService.getColorTheme().tokenTheme), s = this._tokenize(e, t, i, r, o);
    return o.finalize(s);
  }
  _tokenize(e, t, i, r, o) {
    return i.embeddedModeData ? this._nestedTokenize(e, t, i, r, o) : this._myTokenize(e, t, i, r, o);
  }
  _findLeavingNestedModeOffset(e, t) {
    let i = this._lexer.tokenizer[t.stack.state];
    if (!i && (i = dy(this._lexer, t.stack.state), !i))
      throw ei(this._lexer, "tokenizer state is not defined: " + t.stack.state);
    let r = -1, o = !1;
    for (const s of i) {
      if (!pk(s.action) || s.action.nextEmbedded !== "@pop")
        continue;
      o = !0;
      let a = s.regex, l = s.regex.source;
      if (l.substr(0, 4) === "^(?:" && l.substr(l.length - 1, 1) === ")") {
        let c = (a.ignoreCase ? "i" : "") + (a.unicode ? "u" : "");
        a = new RegExp(l.substr(4, l.length - 5), c);
      }
      let u = e.search(a);
      u === -1 || u !== 0 && s.matchOnlyAtLineStart || (r === -1 || u < r) && (r = u);
    }
    if (!o)
      throw ei(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + t.stack.state);
    return r;
  }
  _nestedTokenize(e, t, i, r, o) {
    let s = this._findLeavingNestedModeOffset(e, i);
    if (s === -1) {
      let u = o.nestedModeTokenize(e, t, i.embeddedModeData, r);
      return Mc.create(i.stack, new uv(i.embeddedModeData.modeId, u));
    }
    let a = e.substring(0, s);
    a.length > 0 && o.nestedModeTokenize(a, !1, i.embeddedModeData, r);
    let l = e.substring(s);
    return this._myTokenize(l, t, i, r + s, o);
  }
  _safeRuleName(e) {
    return e ? e.name : "(unknown)";
  }
  _myTokenize(e, t, i, r, o) {
    o.enterMode(r, this._modeId);
    const s = e.length, a = t && this._lexer.includeLF ? e + `
` : e, l = a.length;
    let u = i.embeddedModeData, c = i.stack, h = 0, d = null, f = !0;
    for (; f || h < l; ) {
      const p = h, g = c.depth, _ = d ? d.groups.length : 0, m = c.state;
      let v = null, C = null, y = null, b = null, L = null;
      if (d) {
        v = d.matches;
        const D = d.groups.shift();
        C = D.matched, y = D.action, b = d.rule, d.groups.length === 0 && (d = null);
      } else {
        if (!f && h >= l)
          break;
        f = !1;
        let D = this._lexer.tokenizer[m];
        if (!D && (D = dy(this._lexer, m), !D))
          throw ei(this._lexer, "tokenizer state is not defined: " + m);
        let O = a.substr(h);
        for (const T of D)
          if ((h === 0 || !T.matchOnlyAtLineStart) && (v = O.match(T.regex), v)) {
            C = v[0], y = T.action;
            break;
          }
      }
      if (v || (v = [""], C = ""), y || (h < l && (v = [a.charAt(h)], C = v[0]), y = this._lexer.defaultToken), C === null)
        break;
      for (h += C.length; Rse(y) && pk(y) && y.test; )
        y = y.test(C, v, m, h === l);
      let S = null;
      if (typeof y == "string" || Array.isArray(y))
        S = y;
      else if (y.group)
        S = y.group;
      else if (y.token !== null && y.token !== void 0) {
        if (y.tokenSubst ? S = Ac(this._lexer, y.token, C, v, m) : S = y.token, y.nextEmbedded)
          if (y.nextEmbedded === "@pop") {
            if (!u)
              throw ei(this._lexer, "cannot pop embedded mode if not inside one");
            u = null;
          } else {
            if (u)
              throw ei(this._lexer, "cannot enter embedded mode from within an embedded mode");
            L = Ac(this._lexer, y.nextEmbedded, C, v, m);
          }
        if (y.goBack && (h = Math.max(0, h - y.goBack)), y.switchTo && typeof y.switchTo == "string") {
          let D = Ac(this._lexer, y.switchTo, C, v, m);
          if (D[0] === "@" && (D = D.substr(1)), dy(this._lexer, D))
            c = c.switchTo(D);
          else
            throw ei(this._lexer, "trying to switch to a state '" + D + "' that is undefined in rule: " + this._safeRuleName(b));
        } else {
          if (y.transform && typeof y.transform == "function")
            throw ei(this._lexer, "action.transform not supported");
          if (y.next)
            if (y.next === "@push") {
              if (c.depth >= this._lexer.maxStack)
                throw ei(this._lexer, "maximum tokenizer stack size reached: [" + c.state + "," + c.parent.state + ",...]");
              c = c.push(m);
            } else if (y.next === "@pop") {
              if (c.depth <= 1)
                throw ei(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(b));
              c = c.pop();
            } else if (y.next === "@popall")
              c = c.popall();
            else {
              let D = Ac(this._lexer, y.next, C, v, m);
              if (D[0] === "@" && (D = D.substr(1)), dy(this._lexer, D))
                c = c.push(D);
              else
                throw ei(this._lexer, "trying to set a next state '" + D + "' that is undefined in rule: " + this._safeRuleName(b));
            }
        }
        y.log && typeof y.log == "string" && Tse(this._lexer, this._lexer.languageId + ": " + Ac(this._lexer, y.log, C, v, m));
      }
      if (S === null)
        throw ei(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(b));
      const E = (D) => {
        let O = this._modeService.getModeIdForLanguageName(D);
        O && (D = O);
        const T = this._getNestedEmbeddedModeData(D);
        if (h < l) {
          const A = e.substr(h);
          return this._nestedTokenize(A, t, Mc.create(c, T), r + h, o);
        } else
          return Mc.create(c, T);
      };
      if (Array.isArray(S)) {
        if (d && d.groups.length > 0)
          throw ei(this._lexer, "groups cannot be nested: " + this._safeRuleName(b));
        if (v.length !== S.length + 1)
          throw ei(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(b));
        let D = 0;
        for (let O = 1; O < v.length; O++)
          D += v[O].length;
        if (D !== C.length)
          throw ei(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(b));
        d = {
          rule: b,
          matches: v,
          groups: []
        };
        for (let O = 0; O < S.length; O++)
          d.groups[O] = {
            action: S[O],
            matched: v[O + 1]
          };
        h -= C.length;
        continue;
      } else {
        if (S === "@rematch" && (h -= C.length, C = "", v = null, S = "", L !== null))
          return E(L);
        if (C.length === 0) {
          if (l === 0 || g !== c.depth || m !== c.state || (d ? d.groups.length : 0) !== _)
            continue;
          throw ei(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(b));
        }
        let D = null;
        if (m5(S) && S.indexOf("@brackets") === 0) {
          let O = S.substr(9), T = Nse(this._lexer, C);
          if (!T)
            throw ei(this._lexer, "@brackets token returned but no bracket defined as: " + C);
          D = gk(T.token + O);
        } else {
          let O = S === "" ? "" : S + this._lexer.tokenPostfix;
          D = gk(O);
        }
        p < s && o.emit(p + r, D);
      }
      if (L !== null)
        return E(L);
    }
    return Mc.create(c, u);
  }
  _getNestedEmbeddedModeData(e) {
    let t = this._locateMode(e);
    if (t) {
      let i = ln.get(t);
      if (i)
        return new uv(t, i.getInitialState());
    }
    return new uv(t || RN, XS);
  }
  _locateMode(e) {
    if (!e || !this._modeService.isRegisteredMode(e))
      return null;
    if (e === this._modeId)
      return e;
    let t = this._modeService.getModeId(e);
    return t && (this._modeService.triggerMode(t), this._embeddedModes[t] = !0), t;
  }
}
function Nse(n, e) {
  if (!e)
    return null;
  e = qc(n, e);
  let t = n.brackets;
  for (const i of t) {
    if (i.open === e)
      return {
        token: i.token,
        bracketType: 1
        /* Open */
      };
    if (i.close === e)
      return {
        token: i.token,
        bracketType: -1
        /* Close */
      };
  }
  return null;
}
function Ise(n, e, t, i) {
  return new t0(n, e, t, i);
}
var cD;
const hD = (cD = window.trustedTypes) === null || cD === void 0 ? void 0 : cD.createPolicy("standaloneColorizer", { createHTML: (n) => n });
class MN {
  static colorizeElement(e, t, i, r) {
    r = r || {};
    let o = r.theme || "vs", s = r.mimeType || i.getAttribute("lang") || i.getAttribute("data-lang");
    if (!s)
      return console.error("Mode not detected"), Promise.resolve();
    e.setTheme(o);
    let a = i.firstChild ? i.firstChild.nodeValue : "";
    i.className += " " + o;
    let l = (u) => {
      var c;
      const h = (c = hD == null ? void 0 : hD.createHTML(u)) !== null && c !== void 0 ? c : u;
      i.innerHTML = h;
    };
    return this.colorize(t, a || "", s, r).then(l, (u) => console.error(u));
  }
  static colorize(e, t, i, r) {
    let o = 4;
    r && typeof r.tabSize == "number" && (o = r.tabSize), CN(t) && (t = t.substr(1));
    let s = W_(t), a = e.getModeId(i);
    if (!a)
      return Promise.resolve(mk(s, o));
    e.triggerMode(a);
    const l = ln.get(a);
    if (l)
      return dD(s, o, l);
    const u = ln.getPromise(a);
    return u ? new Promise((c, h) => {
      u.then((d) => {
        dD(s, o, d).then(c, h);
      }, h);
    }) : new Promise((c, h) => {
      let d = null, f = null;
      const p = () => {
        d && (d.dispose(), d = null), f && (f.dispose(), f = null);
        const g = ln.get(a);
        if (g) {
          dD(s, o, g).then(c, h);
          return;
        }
        c(mk(s, o));
      };
      f = new ec(), f.cancelAndSet(p, 500), d = ln.onDidChange((g) => {
        g.changedLanguages.indexOf(a) >= 0 && p();
      });
    });
  }
  static colorizeLine(e, t, i, r, o = 4) {
    const s = $o.isBasicASCII(e, t), a = $o.containsRTL(e, s, i);
    return e0(new Sg(!1, !0, e, !1, s, a, 0, r, [], o, 0, 0, 0, 0, -1, "none", !1, !1, null)).html;
  }
  static colorizeModelLine(e, t, i = 4) {
    let r = e.getLineContent(t);
    e.forceTokenization(t);
    let s = e.getLineTokens(t).inflate();
    return this.colorizeLine(r, e.mightContainNonBasicASCII(), e.mightContainRTL(), s, i);
  }
}
function dD(n, e, t) {
  return new Promise((i, r) => {
    const o = () => {
      const s = Pse(n, e, t);
      if (t instanceof t0) {
        const a = t.getLoadStatus();
        if (a.loaded === !1) {
          a.promise.then(o, r);
          return;
        }
      }
      i(s);
    };
    o();
  });
}
function mk(n, e) {
  let t = [];
  const r = new Uint32Array(2);
  r[0] = 0, r[1] = 16793600;
  for (let o = 0, s = n.length; o < s; o++) {
    let a = n[o];
    r[0] = a.length;
    const l = new Zr(r, a), u = $o.isBasicASCII(
      a,
      /* check for basic ASCII */
      !0
    ), c = $o.containsRTL(
      a,
      u,
      /* check for RTL */
      !0
    );
    let h = e0(new Sg(!1, !0, a, !1, u, c, 0, l, [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    t = t.concat(h.html), t.push("<br/>");
  }
  return t.join("");
}
function Pse(n, e, t) {
  let i = [], r = t.getInitialState();
  for (let o = 0, s = n.length; o < s; o++) {
    let a = n[o], l = t.tokenize2(a, !0, r, 0);
    Zr.convertToEndOffset(l.tokens, a.length);
    let u = new Zr(l.tokens, a);
    const c = $o.isBasicASCII(
      a,
      /* check for basic ASCII */
      !0
    ), h = $o.containsRTL(
      a,
      c,
      /* check for RTL */
      !0
    );
    let d = e0(new Sg(!1, !0, a, !1, c, h, 0, u.inflate(), [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    i = i.concat(d.html), i.push("<br/>"), r = l.endState;
  }
  return i.join("");
}
var qv;
(function(n) {
  n[n.Ignore = 0] = "Ignore", n[n.Info = 1] = "Info", n[n.Warning = 2] = "Warning", n[n.Error = 3] = "Error";
})(qv || (qv = {}));
(function(n) {
  const e = "error", t = "warning", i = "warn", r = "info", o = "ignore";
  function s(l) {
    return l ? Hm(e, l) ? n.Error : Hm(t, l) || Hm(i, l) ? n.Warning : Hm(r, l) ? n.Info : n.Ignore : n.Ignore;
  }
  n.fromValue = s;
  function a(l) {
    switch (l) {
      case n.Error:
        return e;
      case n.Warning:
        return t;
      case n.Info:
        return r;
      default:
        return o;
    }
  }
  n.toString = a;
})(qv || (qv = {}));
const pn = qv;
function ih(n) {
  return n && typeof n.getEditorType == "function" ? n.getEditorType() === B_.ICodeEditor : !1;
}
function Ase(n) {
  return n && typeof n.getEditorType == "function" ? n.getEditorType() === B_.IDiffEditor : !1;
}
function MCe(n) {
  return ih(n) ? n : Ase(n) ? n.getModifiedEditor() : null;
}
const Mse = Vt("IWorkspaceEditService");
function Fse(n) {
  return Bo(n) && (!!n.newUri || !!n.oldUri);
}
function kse(n) {
  return Bo(n) && dt.isUri(n.resource) && Bo(n.edit);
}
class _5 {
  constructor(e) {
    this.metadata = e;
  }
  static convert(e) {
    return e.edits.map((t) => {
      if (kse(t))
        return new C5(t.resource, t.edit, t.modelVersionId, t.metadata);
      if (Fse(t))
        return new Wse(t.oldUri, t.newUri, t.options, t.metadata);
      throw new Error("Unsupported edit");
    });
  }
}
class C5 extends _5 {
  constructor(e, t, i, r) {
    super(r), this.resource = e, this.textEdit = t, this.versionId = i;
  }
}
class Wse extends _5 {
  constructor(e, t, i, r) {
    super(r), this.oldResource = e, this.newResource = t, this.options = i;
  }
}
class Vse {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    Jy(Za(e)), Jy(Bo(t)), Jy(!this.data.has(e), "There is already an extension with this id"), this.data.set(e, t);
  }
  as(e) {
    return this.data.get(e) || null;
  }
}
const Zn = new Vse(), i0 = {
  JSONContribution: "base.contributions.json"
};
function Bse(n) {
  return n.length > 0 && n.charAt(n.length - 1) === "#" ? n.substring(0, n.length - 1) : n;
}
class Hse {
  constructor() {
    this._onDidChangeSchema = new j(), this.schemasById = {};
  }
  registerSchema(e, t) {
    this.schemasById[Bse(e)] = t, this._onDidChangeSchema.fire(e);
  }
  notifySchemaChanged(e) {
    this._onDidChangeSchema.fire(e);
  }
}
const Gse = new Hse();
Zn.add(i0.JSONContribution, Gse);
const Eg = {
  Configuration: "base.contributions.configuration"
}, fD = "vscode://schemas/settings/resourceLanguage", vk = Zn.as(i0.JSONContribution);
class Use {
  constructor() {
    this.overrideIdentifiers = /* @__PURE__ */ new Set(), this._onDidSchemaChange = new j(), this._onDidUpdateConfiguration = new j(), this.defaultValues = {}, this.defaultLanguageConfigurationOverridesNode = {
      id: "defaultOverrides",
      title: w("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
      properties: {}
    }, this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode], this.resourceLanguageSettingsSchema = { properties: {}, patternProperties: {}, additionalProperties: !1, errorMessage: "Unknown editor configuration setting", allowTrailingCommas: !0, allowComments: !0 }, this.configurationProperties = {}, this.excludedConfigurationProperties = {}, vk.registerSchema(fD, this.resourceLanguageSettingsSchema);
  }
  registerConfiguration(e, t = !0) {
    this.registerConfigurations([e], t);
  }
  registerConfigurations(e, t = !0) {
    const i = [];
    e.forEach((r) => {
      i.push(...this.validateAndRegisterProperties(r, t, r.extensionInfo)), this.configurationContributors.push(r), this.registerJSONConfiguration(r);
    }), vk.registerSchema(fD, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire(i);
  }
  registerOverrideIdentifiers(e) {
    for (const t of e)
      this.overrideIdentifiers.add(t);
    this.updateOverridePropertyPatternKey();
  }
  validateAndRegisterProperties(e, t = !0, i, r = 3) {
    var o;
    r = ps(e.scope) ? r : e.scope;
    let s = [], a = e.properties;
    if (a)
      for (let u in a) {
        if (t && Kse(u)) {
          delete a[u];
          continue;
        }
        const c = a[u];
        if (this.updatePropertyDefaultValue(u, c), FN.test(u) ? c.scope = void 0 : (c.scope = ps(c.scope) ? r : c.scope, c.restricted = ps(c.restricted) ? !!(!((o = i == null ? void 0 : i.restrictedConfigurations) === null || o === void 0) && o.includes(u)) : c.restricted), a[u].hasOwnProperty("included") && !a[u].included) {
          this.excludedConfigurationProperties[u] = a[u], delete a[u];
          continue;
        } else
          this.configurationProperties[u] = a[u];
        !a[u].deprecationMessage && a[u].markdownDeprecationMessage && (a[u].deprecationMessage = a[u].markdownDeprecationMessage), s.push(u);
      }
    let l = e.allOf;
    if (l)
      for (let u of l)
        s.push(...this.validateAndRegisterProperties(u, t, i, r));
    return s;
  }
  getConfigurationProperties() {
    return this.configurationProperties;
  }
  registerJSONConfiguration(e) {
    const t = (i) => {
      let r = i.properties;
      if (r)
        for (const s in r)
          this.updateSchema(s, r[s]);
      let o = i.allOf;
      o && o.forEach(t);
    };
    t(e);
  }
  updateSchema(e, t) {
    switch (t.scope) {
      case 1:
        break;
      case 2:
        break;
      case 6:
        break;
      case 3:
        break;
      case 4:
        break;
      case 5:
        this.resourceLanguageSettingsSchema.properties[e] = t;
        break;
    }
  }
  updateOverridePropertyPatternKey() {
    for (const e of this.overrideIdentifiers.values()) {
      const t = `[${e}]`, i = {
        type: "object",
        description: w("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
        errorMessage: w("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
        $ref: fD
      };
      this.updatePropertyDefaultValue(t, i);
    }
    this._onDidSchemaChange.fire();
  }
  updatePropertyDefaultValue(e, t) {
    let i = this.defaultValues[e];
    Ls(i) && (i = t.default), Ls(i) && (i = $se(t.type)), t.default = i;
  }
}
const zse = "\\[.*\\]$", FN = new RegExp(zse);
function jse(n) {
  return n.substring(1, n.length - 1);
}
function $se(n) {
  switch (Array.isArray(n) ? n[0] : n) {
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
const y5 = new Use();
Zn.add(Eg.Configuration, y5);
function Kse(n) {
  return n.trim() ? FN.test(n) ? w("config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", n) : y5.getConfigurationProperties()[n] !== void 0 ? w("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", n) : null : w("config.property.empty", "Cannot register an empty property");
}
const qse = Object.prototype.hasOwnProperty;
function Yse(n, e) {
  for (let t in n)
    if (qse.call(n, t) && e({ key: t, value: n[t] }, function() {
      delete n[t];
    }) === !1)
      return;
}
class Xse {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    let i = this.map.get(e);
    i || (i = /* @__PURE__ */ new Set(), this.map.set(e, i)), i.add(t);
  }
  delete(e, t) {
    const i = this.map.get(e);
    i && (i.delete(t), i.size === 0 && this.map.delete(e));
  }
  forEach(e, t) {
    const i = this.map.get(e);
    i && i.forEach(t);
  }
}
const _k = new class {
  constructor() {
    this._tabFocus = !1, this._onDidChangeTabFocus = new j(), this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
  }
  getTabFocusMode() {
    return this._tabFocus;
  }
  setTabFocusMode(n) {
    this._tabFocus !== n && (this._tabFocus = n, this._onDidChangeTabFocus.fire(this._tabFocus));
  }
}(), w5 = Object.hasOwnProperty;
class Zse {
  constructor() {
    this._values = [];
  }
  _read(e) {
    return this._values[e];
  }
  get(e) {
    return this._values[e];
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class Qse {
  constructor() {
    this._values = [];
  }
  _read(e) {
    return this._values[e];
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class Du {
  static readOptions(e) {
    const t = e, i = new Qse();
    for (const r of jf) {
      const o = r.name === "_never_" ? void 0 : t[r.name];
      i._write(r.id, o);
    }
    return i;
  }
  static validateOptions(e) {
    const t = new lie();
    for (const i of jf)
      t._write(i.id, i.validate(e._read(i.id)));
    return t;
  }
  static computeOptions(e, t) {
    const i = new Zse();
    for (const r of jf)
      i._write(r.id, r.compute(t, i, e._read(r.id)));
    return i;
  }
  static _deepEquals(e, t) {
    if (typeof e != "object" || typeof t != "object")
      return e === t;
    if (Array.isArray(e) || Array.isArray(t))
      return Array.isArray(e) && Array.isArray(t) ? Gu(e, t) : !1;
    for (let i in e)
      if (!Du._deepEquals(e[i], t[i]))
        return !1;
    return !0;
  }
  static checkEquals(e, t) {
    const i = [];
    let r = !1;
    for (const o of jf) {
      const s = !Du._deepEquals(e._read(o.id), t._read(o.id));
      i[o.id] = s, s && (r = !0);
    }
    return r ? new iG(i) : null;
  }
}
function Jse(n) {
  const e = n.wordWrap;
  e === !0 ? n.wordWrap = "on" : e === !1 && (n.wordWrap = "off");
  const t = n.lineNumbers;
  t === !0 ? n.lineNumbers = "on" : t === !1 && (n.lineNumbers = "off"), n.autoClosingBrackets === !1 && (n.autoClosingBrackets = "never", n.autoClosingQuotes = "never", n.autoSurround = "never"), n.cursorBlinking === "visible" && (n.cursorBlinking = "solid");
  const o = n.renderWhitespace;
  o === !0 ? n.renderWhitespace = "boundary" : o === !1 && (n.renderWhitespace = "none");
  const s = n.renderLineHighlight;
  s === !0 ? n.renderLineHighlight = "line" : s === !1 && (n.renderLineHighlight = "none");
  const a = n.acceptSuggestionOnEnter;
  a === !0 ? n.acceptSuggestionOnEnter = "on" : a === !1 && (n.acceptSuggestionOnEnter = "off");
  const l = n.tabCompletion;
  l === !1 ? n.tabCompletion = "off" : l === !0 && (n.tabCompletion = "onlySnippets");
  const u = n.suggest;
  if (u && typeof u.filteredTypes == "object" && u.filteredTypes) {
    const p = {};
    p.method = "showMethods", p.function = "showFunctions", p.constructor = "showConstructors", p.deprecated = "showDeprecated", p.field = "showFields", p.variable = "showVariables", p.class = "showClasses", p.struct = "showStructs", p.interface = "showInterfaces", p.module = "showModules", p.property = "showProperties", p.event = "showEvents", p.operator = "showOperators", p.unit = "showUnits", p.value = "showValues", p.constant = "showConstants", p.enum = "showEnums", p.enumMember = "showEnumMembers", p.keyword = "showKeywords", p.text = "showWords", p.color = "showColors", p.file = "showFiles", p.reference = "showReferences", p.folder = "showFolders", p.typeParameter = "showTypeParameters", p.snippet = "showSnippets", Yse(p, (g) => {
      const _ = u.filteredTypes[g.key];
      _ === !1 && (u[g.value] = _);
    });
  }
  const c = n.hover;
  c === !0 ? n.hover = {
    enabled: !0
  } : c === !1 && (n.hover = {
    enabled: !1
  });
  const h = n.parameterHints;
  h === !0 ? n.parameterHints = {
    enabled: !0
  } : h === !1 && (n.parameterHints = {
    enabled: !1
  });
  const d = n.autoIndent;
  d === !0 ? n.autoIndent = "full" : d === !1 && (n.autoIndent = "advanced");
  const f = n.matchBrackets;
  f === !0 ? n.matchBrackets = "always" : f === !1 && (n.matchBrackets = "never");
}
function Ck(n) {
  const e = Gh(n);
  return Jse(e), e;
}
class yb extends ge {
  constructor(e, t) {
    super(), this._onDidChange = this._register(new j()), this.onDidChange = this._onDidChange.event, this._onDidChangeFast = this._register(new j()), this.onDidChangeFast = this._onDidChangeFast.event, this.isSimpleWidget = e, this._isDominatedByLongLines = !1, this._computeOptionsMemory = new nG(), this._viewLineCount = 1, this._lineNumbersDigitCount = 1, this._rawOptions = Ck(t), this._readOptions = Du.readOptions(this._rawOptions), this._validatedOptions = Du.validateOptions(this._readOptions), this._register(ub.onDidChangeZoomLevel((i) => this._recomputeOptions())), this._register(_k.onDidChangeTabFocus((i) => this._recomputeOptions()));
  }
  observeReferenceElement(e) {
  }
  updatePixelRatio() {
  }
  _recomputeOptions() {
    const e = this.options, t = this._computeInternalOptions();
    if (!e)
      this.options = t;
    else {
      const i = Du.checkEquals(e, t);
      if (i === null)
        return;
      this.options = t, this._onDidChangeFast.fire(i), this._onDidChange.fire(i);
    }
  }
  getRawOptions() {
    return this._rawOptions;
  }
  _computeInternalOptions() {
    const e = this._getEnvConfiguration(), t = Hp.createFromValidatedSettings(this._validatedOptions, e.zoomLevel, e.pixelRatio, this.isSimpleWidget), i = {
      memory: this._computeOptionsMemory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight,
      fontInfo: this.readConfiguration(t),
      extraEditorClassName: e.extraEditorClassName,
      isDominatedByLongLines: this._isDominatedByLongLines,
      viewLineCount: this._viewLineCount,
      lineNumbersDigitCount: this._lineNumbersDigitCount,
      emptySelectionClipboard: e.emptySelectionClipboard,
      pixelRatio: e.pixelRatio,
      tabFocusMode: _k.getTabFocusMode(),
      accessibilitySupport: e.accessibilitySupport
    };
    return Du.computeOptions(this._validatedOptions, i);
  }
  static _subsetEquals(e, t) {
    for (const i in t)
      if (w5.call(t, i)) {
        const r = t[i], o = e[i];
        if (o === r)
          continue;
        if (Array.isArray(o) && Array.isArray(r)) {
          if (!Gu(o, r))
            return !1;
          continue;
        }
        if (o && typeof o == "object" && r && typeof r == "object") {
          if (!this._subsetEquals(o, r))
            return !1;
          continue;
        }
        return !1;
      }
    return !0;
  }
  updateOptions(e) {
    if (typeof e > "u")
      return;
    const t = Ck(e);
    yb._subsetEquals(this._rawOptions, t) || (this._rawOptions = ch(this._rawOptions, t || {}), this._readOptions = Du.readOptions(this._rawOptions), this._validatedOptions = Du.validateOptions(this._readOptions), this._recomputeOptions());
  }
  setIsDominatedByLongLines(e) {
    this._isDominatedByLongLines = e, this._recomputeOptions();
  }
  setMaxLineNumber(e) {
    const t = yb._digitCount(e);
    this._lineNumbersDigitCount !== t && (this._lineNumbersDigitCount = t, this._recomputeOptions());
  }
  setViewLineCount(e) {
    this._viewLineCount !== e && (this._viewLineCount = e, this._recomputeOptions());
  }
  static _digitCount(e) {
    let t = 0;
    for (; e; )
      e = Math.floor(e / 10), t++;
    return t || 1;
  }
}
const eae = Object.freeze({
  id: "editor",
  order: 5,
  type: "object",
  title: w("editorConfigurationTitle", "Editor"),
  scope: 5
}), tae = Zn.as(Eg.Configuration), wb = Object.assign(Object.assign({}, eae), { properties: {
  "editor.tabSize": {
    type: "number",
    default: Co.tabSize,
    minimum: 1,
    markdownDescription: w("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
  },
  // 'editor.indentSize': {
  // 	'anyOf': [
  // 		{
  // 			type: 'string',
  // 			enum: ['tabSize']
  // 		},
  // 		{
  // 			type: 'number',
  // 			minimum: 1
  // 		}
  // 	],
  // 	default: 'tabSize',
  // 	markdownDescription: nls.localize('indentSize', "The number of spaces used for indentation or 'tabSize' to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
  // },
  "editor.insertSpaces": {
    type: "boolean",
    default: Co.insertSpaces,
    markdownDescription: w("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
  },
  "editor.detectIndentation": {
    type: "boolean",
    default: Co.detectIndentation,
    markdownDescription: w("detectIndentation", "Controls whether `#editor.tabSize#` and `#editor.insertSpaces#` will be automatically detected when a file is opened based on the file contents.")
  },
  "editor.trimAutoWhitespace": {
    type: "boolean",
    default: Co.trimAutoWhitespace,
    description: w("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
  },
  "editor.largeFileOptimizations": {
    type: "boolean",
    default: Co.largeFileOptimizations,
    description: w("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
  },
  "editor.wordBasedSuggestions": {
    type: "boolean",
    default: !0,
    description: w("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document.")
  },
  "editor.wordBasedSuggestionsMode": {
    enum: ["currentDocument", "matchingDocuments", "allDocuments"],
    default: "matchingDocuments",
    enumDescriptions: [
      w("wordBasedSuggestionsMode.currentDocument", "Only suggest words from the active document."),
      w("wordBasedSuggestionsMode.matchingDocuments", "Suggest words from all open documents of the same language."),
      w("wordBasedSuggestionsMode.allDocuments", "Suggest words from all open documents.")
    ],
    description: w("wordBasedSuggestionsMode", "Controls from which documents word based completions are computed.")
  },
  "editor.semanticHighlighting.enabled": {
    enum: [!0, !1, "configuredByTheme"],
    enumDescriptions: [
      w("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
      w("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
      w("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
    ],
    default: "configuredByTheme",
    description: w("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
  },
  "editor.stablePeek": {
    type: "boolean",
    default: !1,
    markdownDescription: w("stablePeek", "Keep peek editors open even when double clicking their content or when hitting `Escape`.")
  },
  "editor.maxTokenizationLineLength": {
    type: "integer",
    default: 2e4,
    description: w("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
  },
  "diffEditor.maxComputationTime": {
    type: "number",
    default: 5e3,
    description: w("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
  },
  "diffEditor.renderSideBySide": {
    type: "boolean",
    default: !0,
    description: w("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
  },
  "diffEditor.ignoreTrimWhitespace": {
    type: "boolean",
    default: !0,
    description: w("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
  },
  "diffEditor.renderIndicators": {
    type: "boolean",
    default: !0,
    description: w("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
  },
  "diffEditor.codeLens": {
    type: "boolean",
    default: !1,
    description: w("codeLens", "Controls whether the editor shows CodeLens.")
  },
  "diffEditor.wordWrap": {
    type: "string",
    enum: ["off", "on", "inherit"],
    default: "inherit",
    markdownEnumDescriptions: [
      w("wordWrap.off", "Lines will never wrap."),
      w("wordWrap.on", "Lines will wrap at the viewport width."),
      w("wordWrap.inherit", "Lines will wrap according to the `#editor.wordWrap#` setting.")
    ]
  }
} });
function iae(n) {
  return typeof n.type < "u" || typeof n.anyOf < "u";
}
for (const n of jf) {
  const e = n.schema;
  if (typeof e < "u")
    if (iae(e))
      wb.properties[`editor.${n.name}`] = e;
    else
      for (let t in e)
        w5.call(e, t) && (wb.properties[t] = e[t]);
}
let fy = null;
function b5() {
  return fy === null && (fy = /* @__PURE__ */ Object.create(null), Object.keys(wb.properties).forEach((n) => {
    fy[n] = !0;
  })), fy;
}
function nae(n) {
  return b5()[`editor.${n}`] || !1;
}
function rae(n) {
  return b5()[`diffEditor.${n}`] || !1;
}
tae.registerConfiguration(wb);
class ST {
  static insert(e, t) {
    return {
      range: new V(e.lineNumber, e.column, e.lineNumber, e.column),
      text: t,
      forceMoveMarkers: !0
    };
  }
  static delete(e) {
    return {
      range: e,
      text: null
    };
  }
  static replace(e, t) {
    return {
      range: e,
      text: t
    };
  }
  static replaceMove(e, t) {
    return {
      range: e,
      text: t,
      forceMoveMarkers: !0
    };
  }
}
const mr = Vt("configurationService");
function S5(n, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (let i in n)
    kN(t, i, n[i], e);
  return t;
}
function kN(n, e, t, i) {
  const r = e.split("."), o = r.pop();
  let s = n;
  for (let a = 0; a < r.length; a++) {
    let l = r[a], u = s[l];
    switch (typeof u) {
      case "undefined":
        u = s[l] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        break;
      default:
        i(`Ignoring ${e} as ${r.slice(0, a + 1).join(".")} is ${JSON.stringify(u)}`);
        return;
    }
    s = u;
  }
  if (typeof s == "object" && s !== null)
    try {
      s[o] = t;
    } catch {
      i(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(s)}`);
    }
  else
    i(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(s)}`);
}
function oae(n, e) {
  const t = e.split(".");
  E5(n, t);
}
function E5(n, e) {
  const t = e.shift();
  if (e.length === 0) {
    delete n[t];
    return;
  }
  if (Object.keys(n).indexOf(t) !== -1) {
    const i = n[t];
    typeof i == "object" && !Array.isArray(i) && (E5(i, e), Object.keys(i).length === 0 && delete n[t]);
  }
}
function sae(n, e, t) {
  function i(s, a) {
    let l = s;
    for (const u of a) {
      if (typeof l != "object" || l === null)
        return;
      l = l[u];
    }
    return l;
  }
  const r = e.split("."), o = i(n, r);
  return typeof o > "u" ? t : o;
}
function aae() {
  const n = Zn.as(Eg.Configuration).getConfigurationProperties();
  return Object.keys(n);
}
function lae() {
  const n = /* @__PURE__ */ Object.create(null), e = Zn.as(Eg.Configuration).getConfigurationProperties();
  for (let t in e) {
    let i = e[t].default;
    kN(n, t, i, (r) => console.error(`Conflict in default settings: ${r}`));
  }
  return n;
}
class cs {
  constructor(e = {}, t = [], i = []) {
    this._contents = e, this._keys = t, this._overrides = i, this.isFrozen = !1;
  }
  get contents() {
    return this.checkAndFreeze(this._contents);
  }
  get overrides() {
    return this.checkAndFreeze(this._overrides);
  }
  get keys() {
    return this.checkAndFreeze(this._keys);
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(e) {
    return e ? sae(this.contents, e) : this.contents;
  }
  override(e) {
    const t = this.getContentsForOverrideIdentifer(e);
    if (!t || typeof t != "object" || !Object.keys(t).length)
      return this;
    let i = {};
    for (const r of h5([...Object.keys(this.contents), ...Object.keys(t)])) {
      let o = this.contents[r], s = t[r];
      s && (typeof o == "object" && typeof s == "object" ? (o = Gh(o), this.mergeContents(o, s)) : o = s), i[r] = o;
    }
    return new cs(i, this.keys, this.overrides);
  }
  merge(...e) {
    const t = Gh(this.contents), i = Gh(this.overrides), r = [...this.keys];
    for (const o of e) {
      this.mergeContents(t, o.contents);
      for (const s of o.overrides) {
        const [a] = i.filter((l) => Gu(l.identifiers, s.identifiers));
        a ? this.mergeContents(a.contents, s.contents) : i.push(Gh(s));
      }
      for (const s of o.keys)
        r.indexOf(s) === -1 && r.push(s);
    }
    return new cs(t, r, i);
  }
  freeze() {
    return this.isFrozen = !0, this;
  }
  mergeContents(e, t) {
    for (const i of Object.keys(t)) {
      if (i in e && Bo(e[i]) && Bo(t[i])) {
        this.mergeContents(e[i], t[i]);
        continue;
      }
      e[i] = Gh(t[i]);
    }
  }
  checkAndFreeze(e) {
    return this.isFrozen && !Object.isFrozen(e) ? Pre(e) : e;
  }
  getContentsForOverrideIdentifer(e) {
    for (const t of this.overrides)
      if (t.identifiers.indexOf(e) !== -1)
        return t.contents;
    return null;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  // Update methods
  setValue(e, t) {
    this.addKey(e), kN(this.contents, e, t, (i) => {
      throw new Error(i);
    });
  }
  removeValue(e) {
    this.removeKey(e) && oae(this.contents, e);
  }
  addKey(e) {
    let t = this.keys.length;
    for (let i = 0; i < t; i++)
      e.indexOf(this.keys[i]) === 0 && (t = i);
    this.keys.splice(t, 1, e);
  }
  removeKey(e) {
    let t = this.keys.indexOf(e);
    return t !== -1 ? (this.keys.splice(t, 1), !0) : !1;
  }
}
class uae extends cs {
  constructor() {
    const e = lae(), t = aae(), i = [];
    for (const r of Object.keys(e))
      FN.test(r) && i.push({
        identifiers: [jse(r).trim()],
        keys: Object.keys(e[r]),
        contents: S5(e[r], (o) => console.error(`Conflict in default settings file: ${o}`))
      });
    super(e, t, i);
  }
}
let L5 = class D5 {
  constructor(e, t, i = new cs(), r = new cs(), o = new yo(), s = new cs(), a = new yo(), l = !0) {
    this._defaultConfiguration = e, this._localUserConfiguration = t, this._remoteUserConfiguration = i, this._workspaceConfiguration = r, this._folderConfigurations = o, this._memoryConfiguration = s, this._memoryConfigurationByResource = a, this._freeze = l, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations = new yo(), this._userConfiguration = null;
  }
  getValue(e, t, i) {
    return this.getConsolidateConfigurationModel(t, i).getValue(e);
  }
  updateValue(e, t, i = {}) {
    let r;
    i.resource ? (r = this._memoryConfigurationByResource.get(i.resource), r || (r = new cs(), this._memoryConfigurationByResource.set(i.resource, r))) : r = this._memoryConfiguration, t === void 0 ? r.removeValue(e) : r.setValue(e, t), i.resource || (this._workspaceConsolidatedConfiguration = null);
  }
  get userConfiguration() {
    return this._userConfiguration || (this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration), this._freeze && this._userConfiguration.freeze()), this._userConfiguration;
  }
  getConsolidateConfigurationModel(e, t) {
    let i = this.getConsolidatedConfigurationModelForResource(e, t);
    return e.overrideIdentifier ? i.override(e.overrideIdentifier) : i;
  }
  getConsolidatedConfigurationModelForResource({ resource: e }, t) {
    let i = this.getWorkspaceConsolidatedConfiguration();
    if (t && e) {
      const r = t.getFolder(e);
      r && (i = this.getFolderConsolidatedConfiguration(r.uri) || i);
      const o = this._memoryConfigurationByResource.get(e);
      o && (i = i.merge(o));
    }
    return i;
  }
  getWorkspaceConsolidatedConfiguration() {
    return this._workspaceConsolidatedConfiguration || (this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration), this._freeze && (this._workspaceConfiguration = this._workspaceConfiguration.freeze())), this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(e) {
    let t = this._foldersConsolidatedConfigurations.get(e);
    if (!t) {
      const i = this.getWorkspaceConsolidatedConfiguration(), r = this._folderConfigurations.get(e);
      r ? (t = i.merge(r), this._freeze && (t = t.freeze()), this._foldersConsolidatedConfigurations.set(e, t)) : t = i;
    }
    return t;
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      user: {
        contents: this.userConfiguration.contents,
        overrides: this.userConfiguration.overrides,
        keys: this.userConfiguration.keys
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((e, t) => {
        const { contents: i, overrides: r, keys: o } = this._folderConfigurations.get(t);
        return e.push([t, { contents: i, overrides: r, keys: o }]), e;
      }, [])
    };
  }
  static parse(e) {
    const t = this.parseConfigurationModel(e.defaults), i = this.parseConfigurationModel(e.user), r = this.parseConfigurationModel(e.workspace), o = e.folders.reduce((s, a) => (s.set(dt.revive(a[0]), this.parseConfigurationModel(a[1])), s), new yo());
    return new D5(t, i, new cs(), r, o, new cs(), new yo(), !1);
  }
  static parseConfigurationModel(e) {
    return new cs(e.contents, e.keys, e.overrides).freeze();
  }
};
class cae {
  constructor(e, t, i, r) {
    this.change = e, this.previous = t, this.currentConfiguraiton = i, this.currentWorkspace = r, this._previousConfiguration = void 0;
    const o = /* @__PURE__ */ new Set();
    e.keys.forEach((a) => o.add(a)), e.overrides.forEach(([, a]) => a.forEach((l) => o.add(l))), this.affectedKeys = [...o.values()];
    const s = new cs();
    this.affectedKeys.forEach((a) => s.setValue(a, {})), this.affectedKeysTree = s.contents;
  }
  get previousConfiguration() {
    return !this._previousConfiguration && this.previous && (this._previousConfiguration = L5.parse(this.previous.data)), this._previousConfiguration;
  }
  affectsConfiguration(e, t) {
    var i;
    if (this.doesAffectedKeysTreeContains(this.affectedKeysTree, e)) {
      if (t) {
        const r = this.previousConfiguration ? this.previousConfiguration.getValue(e, t, (i = this.previous) === null || i === void 0 ? void 0 : i.workspace) : void 0, o = this.currentConfiguraiton.getValue(e, t, this.currentWorkspace);
        return !Hu(r, o);
      }
      return !0;
    }
    return !1;
  }
  doesAffectedKeysTreeContains(e, t) {
    let i = S5({ [t]: !0 }, () => {
    }), r;
    for (; typeof i == "object" && (r = Object.keys(i)[0]); ) {
      if (e = e[r], !e)
        return !1;
      i = i[r];
    }
    return !0;
  }
}
class hae extends ge {
  constructor(e, t, i, r, o) {
    super(), this._contextKeyService = e, this._commandService = t, this._telemetryService = i, this._notificationService = r, this._logService = o, this._onDidUpdateKeybindings = this._register(new j()), this._currentChord = null, this._currentChordChecker = new F_(), this._currentChordStatusMessage = null, this._currentSingleModifier = null, this._currentSingleModifierClearTimeout = new ec(), this._logging = !1;
  }
  get onDidUpdateKeybindings() {
    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Ae.None;
  }
  dispose() {
    super.dispose();
  }
  _log(e) {
    this._logging && this._logService.info(`[KeybindingService]: ${e}`);
  }
  getKeybindings() {
    return this._getResolver().getKeybindings();
  }
  lookupKeybinding(e, t) {
    const i = this._getResolver().lookupPrimaryKeybinding(e, t);
    if (i)
      return i.resolvedKeybinding;
  }
  dispatchEvent(e, t) {
    return this._dispatch(e, t);
  }
  softDispatch(e, t) {
    const i = this.resolveKeyboardEvent(e);
    if (i.isChord())
      return console.warn("Unexpected keyboard event mapped to a chord"), null;
    const [r] = i.getDispatchParts();
    if (r === null)
      return null;
    const o = this._contextKeyService.getContext(t), s = this._currentChord ? this._currentChord.keypress : null;
    return this._getResolver().resolve(o, s, r);
  }
  _enterChordMode(e, t) {
    this._currentChord = {
      keypress: e,
      label: t
    }, this._currentChordStatusMessage = this._notificationService.status(w("first.chord", "({0}) was pressed. Waiting for second key of chord...", t));
    const i = Date.now();
    this._currentChordChecker.cancelAndSet(() => {
      if (!this._documentHasFocus()) {
        this._leaveChordMode();
        return;
      }
      Date.now() - i > 5e3 && this._leaveChordMode();
    }, 500);
  }
  _leaveChordMode() {
    this._currentChordStatusMessage && (this._currentChordStatusMessage.dispose(), this._currentChordStatusMessage = null), this._currentChordChecker.cancel(), this._currentChord = null;
  }
  _dispatch(e, t) {
    return this._doDispatch(
      this.resolveKeyboardEvent(e),
      t,
      /*isSingleModiferChord*/
      !1
    );
  }
  _singleModifierDispatch(e, t) {
    const i = this.resolveKeyboardEvent(e), [r] = i.getSingleModifierDispatchParts();
    return r !== null && this._currentSingleModifier === null ? (this._log(`+ Storing single modifier for possible chord ${r}.`), this._currentSingleModifier = r, this._currentSingleModifierClearTimeout.cancelAndSet(() => {
      this._log("+ Clearing single modifier due to 300ms elapsed."), this._currentSingleModifier = null;
    }, 300), !1) : r !== null && r === this._currentSingleModifier ? (this._log(`/ Dispatching single modifier chord ${r} ${r}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, this._doDispatch(
      i,
      t,
      /*isSingleModiferChord*/
      !0
    )) : (this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1);
  }
  _doDispatch(e, t, i = !1) {
    let r = !1;
    if (e.isChord())
      return console.warn("Unexpected keyboard event mapped to a chord"), !1;
    let o = null, s = null;
    if (i) {
      const [c] = e.getSingleModifierDispatchParts();
      o = c, s = c;
    } else
      [o] = e.getDispatchParts(), s = this._currentChord ? this._currentChord.keypress : null;
    if (o === null)
      return this._log("\\ Keyboard event cannot be dispatched in keydown phase."), r;
    const a = this._contextKeyService.getContext(t), l = e.getLabel(), u = this._getResolver().resolve(a, s, o);
    return this._logService.trace("KeybindingService#dispatch", l, u == null ? void 0 : u.commandId), u && u.enterChord ? (r = !0, this._enterChordMode(o, l), r) : (this._currentChord && (!u || !u.commandId) && (this._notificationService.status(w("missing.chord", "The key combination ({0}, {1}) is not a command.", this._currentChord.label, l), {
      hideAfter: 10 * 1e3
      /* 10s */
    }), r = !0), this._leaveChordMode(), u && u.commandId && (u.bubble || (r = !0), typeof u.commandArgs > "u" ? this._commandService.executeCommand(u.commandId).then(void 0, (c) => this._notificationService.warn(c)) : this._commandService.executeCommand(u.commandId, u.commandArgs).then(void 0, (c) => this._notificationService.warn(c)), this._telemetryService.publicLog2("workbenchActionExecuted", { id: u.commandId, from: "keybinding" })), r);
  }
  mightProducePrintableCharacter(e) {
    return e.ctrlKey || e.metaKey ? !1 : e.keyCode >= 31 && e.keyCode <= 56 || e.keyCode >= 21 && e.keyCode <= 30;
  }
}
class mp {
  constructor(e, t, i) {
    this._log = i, this._defaultKeybindings = e, this._defaultBoundCommands = /* @__PURE__ */ new Map();
    for (let r = 0, o = e.length; r < o; r++) {
      const s = e[r].command;
      s && this._defaultBoundCommands.set(s, !0);
    }
    this._map = /* @__PURE__ */ new Map(), this._lookupMap = /* @__PURE__ */ new Map(), this._keybindings = mp.combine(e, t);
    for (let r = 0, o = this._keybindings.length; r < o; r++) {
      let s = this._keybindings[r];
      s.keypressParts.length !== 0 && (s.when && s.when.type === 0 || this._addKeyPress(s.keypressParts[0], s));
    }
  }
  static _isTargetedForRemoval(e, t, i, r, o) {
    return !(e.command !== r || t && e.keypressParts[0] !== t || i && e.keypressParts[1] !== i || o && (!e.when || !o.equals(e.when)));
  }
  /**
   * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.
   */
  static combine(e, t) {
    e = e.slice(0);
    let i = [];
    for (const r of t) {
      if (!r.command || r.command.length === 0 || r.command.charAt(0) !== "-") {
        i.push(r);
        continue;
      }
      const o = r.command.substr(1), s = r.keypressParts[0], a = r.keypressParts[1], l = r.when;
      for (let u = e.length - 1; u >= 0; u--)
        this._isTargetedForRemoval(e[u], s, a, o, l) && e.splice(u, 1);
    }
    return e.concat(i);
  }
  _addKeyPress(e, t) {
    const i = this._map.get(e);
    if (typeof i > "u") {
      this._map.set(e, [t]), this._addToLookupMap(t);
      return;
    }
    for (let r = i.length - 1; r >= 0; r--) {
      let o = i[r];
      if (o.command === t.command)
        continue;
      const s = o.keypressParts.length > 1, a = t.keypressParts.length > 1;
      s && a && o.keypressParts[1] !== t.keypressParts[1] || mp.whenIsEntirelyIncluded(o.when, t.when) && this._removeFromLookupMap(o);
    }
    i.push(t), this._addToLookupMap(t);
  }
  _addToLookupMap(e) {
    if (!e.command)
      return;
    let t = this._lookupMap.get(e.command);
    typeof t > "u" ? (t = [e], this._lookupMap.set(e.command, t)) : t.push(e);
  }
  _removeFromLookupMap(e) {
    if (!e.command)
      return;
    let t = this._lookupMap.get(e.command);
    if (!(typeof t > "u")) {
      for (let i = 0, r = t.length; i < r; i++)
        if (t[i] === e) {
          t.splice(i, 1);
          return;
        }
    }
  }
  /**
   * Returns true if it is provable `a` implies `b`.
   */
  static whenIsEntirelyIncluded(e, t) {
    return t ? e ? this._implies(e, t) : !1 : !0;
  }
  /**
   * Returns true if it is provable `p` implies `q`.
   */
  static _implies(e, t) {
    const i = e.negate(), r = (s) => s.type === 9 ? s.expr : [s];
    let o = r(i).concat(r(t));
    for (let s = 0; s < o.length; s++) {
      const l = o[s].negate();
      for (let u = s + 1; u < o.length; u++) {
        const c = o[u];
        if (l.equals(c))
          return !0;
      }
    }
    return !1;
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupPrimaryKeybinding(e, t) {
    let i = this._lookupMap.get(e);
    if (typeof i > "u" || i.length === 0)
      return null;
    const r = t && Array.from(i).reverse().find((o) => t.contextMatchesRules(o.when));
    return r ?? i[i.length - 1];
  }
  resolve(e, t, i) {
    this._log(`| Resolving ${i}${t ? ` chorded from ${t}` : ""}`);
    let r = null;
    if (t !== null) {
      const s = this._map.get(t);
      if (typeof s > "u")
        return this._log("\\ No keybinding entries."), null;
      r = [];
      for (let a = 0, l = s.length; a < l; a++) {
        let u = s[a];
        u.keypressParts[1] === i && r.push(u);
      }
    } else {
      const s = this._map.get(i);
      if (typeof s > "u")
        return this._log("\\ No keybinding entries."), null;
      r = s;
    }
    let o = this._findCommand(e, r);
    return o ? t === null && o.keypressParts.length > 1 && o.keypressParts[1] !== null ? (this._log(`\\ From ${r.length} keybinding entries, matched chord, when: ${yk(o.when)}, source: ${wk(o)}.`), {
      enterChord: !0,
      leaveChord: !1,
      commandId: null,
      commandArgs: null,
      bubble: !1
    }) : (this._log(`\\ From ${r.length} keybinding entries, matched ${o.command}, when: ${yk(o.when)}, source: ${wk(o)}.`), {
      enterChord: !1,
      leaveChord: o.keypressParts.length > 1,
      commandId: o.command,
      commandArgs: o.commandArgs,
      bubble: o.bubble
    }) : (this._log(`\\ From ${r.length} keybinding entries, no when clauses matched the context.`), null);
  }
  _findCommand(e, t) {
    for (let i = t.length - 1; i >= 0; i--) {
      let r = t[i];
      if (mp.contextMatchesRules(e, r.when))
        return r;
    }
    return null;
  }
  static contextMatchesRules(e, t) {
    return t ? t.evaluate(e) : !0;
  }
}
function yk(n) {
  return n ? `${n.serialize()}` : "no when condition";
}
function wk(n) {
  return n.extensionId ? n.isBuiltinExtension ? `built-in extension ${n.extensionId}` : `user extension ${n.extensionId}` : n.isDefault ? "built-in" : "user";
}
class bb {
  constructor() {
    this._coreKeybindings = [], this._extensionKeybindings = [], this._cachedMergedKeybindings = null;
  }
  /**
   * Take current platform into account and reduce to primary & secondary.
   */
  static bindToCurrentPlatform(e) {
    if (Ga === 1) {
      if (e && e.win)
        return e.win;
    } else if (Ga === 2) {
      if (e && e.mac)
        return e.mac;
    } else if (e && e.linux)
      return e.linux;
    return e;
  }
  registerKeybindingRule(e) {
    const t = bb.bindToCurrentPlatform(e);
    if (t && t.primary) {
      const i = tR(t.primary, Ga);
      i && this._registerDefaultKeybinding(i, e.id, e.args, e.weight, 0, e.when);
    }
    if (t && Array.isArray(t.secondary))
      for (let i = 0, r = t.secondary.length; i < r; i++) {
        const o = t.secondary[i], s = tR(o, Ga);
        s && this._registerDefaultKeybinding(s, e.id, e.args, e.weight, -i - 1, e.when);
      }
  }
  registerCommandAndKeybindingRule(e) {
    this.registerKeybindingRule(e), Xn.registerCommand(e);
  }
  static _mightProduceChar(e) {
    return e >= 21 && e <= 30 || e >= 31 && e <= 56 ? !0 : e === 80 || e === 81 || e === 82 || e === 83 || e === 84 || e === 85 || e === 86 || e === 110 || e === 111 || e === 87 || e === 88 || e === 89 || e === 90 || e === 91 || e === 92;
  }
  _assertNoCtrlAlt(e, t) {
    e.ctrlKey && e.altKey && !e.metaKey && bb._mightProduceChar(e.keyCode) && console.warn("Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ", e, " for ", t);
  }
  _registerDefaultKeybinding(e, t, i, r, o, s) {
    Ga === 1 && this._assertNoCtrlAlt(e.parts[0], t), this._coreKeybindings.push({
      keybinding: e,
      command: t,
      commandArgs: i,
      when: s,
      weight1: r,
      weight2: o,
      extensionId: null,
      isBuiltinExtension: !1
    }), this._cachedMergedKeybindings = null;
  }
  getDefaultKeybindings() {
    return this._cachedMergedKeybindings || (this._cachedMergedKeybindings = [].concat(this._coreKeybindings).concat(this._extensionKeybindings), this._cachedMergedKeybindings.sort(fae)), this._cachedMergedKeybindings.slice(0);
  }
}
const n0 = new bb(), dae = {
  EditorModes: "platform.keybindingsRegistry"
};
Zn.add(dae.EditorModes, n0);
function fae(n, e) {
  return n.weight1 !== e.weight1 ? n.weight1 - e.weight1 : n.command < e.command ? -1 : n.command > e.command ? 1 : n.weight2 - e.weight2;
}
class bk {
  constructor(e, t, i, r, o, s, a) {
    this.resolvedKeybinding = e, this.keypressParts = e ? Sk(e.getDispatchParts()) : [], e && this.keypressParts.length === 0 && (this.keypressParts = Sk(e.getSingleModifierDispatchParts())), this.bubble = t ? t.charCodeAt(0) === 94 : !1, this.command = this.bubble ? t.substr(1) : t, this.commandArgs = i, this.when = r, this.isDefault = o, this.extensionId = s, this.isBuiltinExtension = a;
  }
}
function Sk(n) {
  let e = [];
  for (let t = 0, i = n.length; t < i; t++) {
    const r = n[t];
    if (!r)
      return e;
    e.push(r);
  }
  return e;
}
class R5 {
  constructor(e, t, i = t) {
    this.modifierLabels = [null], this.modifierLabels[
      2
      /* Macintosh */
    ] = e, this.modifierLabels[
      1
      /* Windows */
    ] = t, this.modifierLabels[
      3
      /* Linux */
    ] = i;
  }
  toLabel(e, t, i) {
    if (t.length === 0)
      return null;
    const r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = i(a);
      if (l === null)
        return null;
      r[o] = gae(a, l, this.modifierLabels[e]);
    }
    return r.join(" ");
  }
}
const T5 = new R5({
  ctrlKey: "",
  shiftKey: "",
  altKey: "",
  metaKey: "",
  separator: ""
}, {
  ctrlKey: w({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: w({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: w({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: w({ key: "windowsKey", comment: ["This is the short form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: w({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: w({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: w({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: w({ key: "superKey", comment: ["This is the short form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), pae = new R5({
  ctrlKey: w({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: w({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: w({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: w({ key: "cmdKey.long", comment: ["This is the long form for the Command key on the keyboard"] }, "Command"),
  separator: "+"
}, {
  ctrlKey: w({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: w({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: w({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: w({ key: "windowsKey.long", comment: ["This is the long form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: w({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: w({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: w({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: w({ key: "superKey.long", comment: ["This is the long form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
});
function gae(n, e, t) {
  if (e === null)
    return "";
  const i = [];
  return n.ctrlKey && i.push(t.ctrlKey), n.shiftKey && i.push(t.shiftKey), n.altKey && i.push(t.altKey), n.metaKey && i.push(t.metaKey), e !== "" && i.push(e), i.join(t.separator);
}
class mae extends Qie {
  constructor(e, t) {
    if (super(), t.length === 0)
      throw P_("parts");
    this._os = e, this._parts = t;
  }
  getLabel() {
    return T5.toLabel(this._os, this._parts, (e) => this._getLabel(e));
  }
  getAriaLabel() {
    return pae.toLabel(this._os, this._parts, (e) => this._getAriaLabel(e));
  }
  isChord() {
    return this._parts.length > 1;
  }
  getParts() {
    return this._parts.map((e) => this._getPart(e));
  }
  _getPart(e) {
    return new Zie(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, this._getLabel(e), this._getAriaLabel(e));
  }
  getDispatchParts() {
    return this._parts.map((e) => this._getDispatchPart(e));
  }
  getSingleModifierDispatchParts() {
    return this._parts.map((e) => this._getSingleModifierDispatchPart(e));
  }
}
class Sb extends mae {
  constructor(e, t) {
    super(t, e.parts);
  }
  _keyCodeToUILabel(e) {
    if (this._os === 2)
      switch (e) {
        case 15:
          return "";
        case 16:
          return "";
        case 17:
          return "";
        case 18:
          return "";
      }
    return hp.toString(e);
  }
  _getLabel(e) {
    return e.isDuplicateModifierCase() ? "" : this._keyCodeToUILabel(e.keyCode);
  }
  _getAriaLabel(e) {
    return e.isDuplicateModifierCase() ? "" : hp.toString(e.keyCode);
  }
  _getDispatchPart(e) {
    return Sb.getDispatchStr(e);
  }
  static getDispatchStr(e) {
    if (e.isModifierKey())
      return null;
    let t = "";
    return e.ctrlKey && (t += "ctrl+"), e.shiftKey && (t += "shift+"), e.altKey && (t += "alt+"), e.metaKey && (t += "meta+"), t += hp.toString(e.keyCode), t;
  }
  _getSingleModifierDispatchPart(e) {
    return e.keyCode === 5 && !e.shiftKey && !e.altKey && !e.metaKey ? "ctrl" : e.keyCode === 4 && !e.ctrlKey && !e.altKey && !e.metaKey ? "shift" : e.keyCode === 6 && !e.ctrlKey && !e.shiftKey && !e.metaKey ? "alt" : e.keyCode === 57 && !e.ctrlKey && !e.shiftKey && !e.altKey ? "meta" : null;
  }
}
const tl = Vt("notificationService");
class vae {
}
const _ae = Vt("contextService");
class Cae {
  constructor(e, t) {
    this.raw = t, this.uri = e.uri, this.index = e.index, this.name = e.name;
  }
  toJSON() {
    return { uri: this.uri, name: this.name, index: this.index };
  }
}
var Ek;
(function(n) {
  n.noSelection = w("noSelection", "No selection"), n.singleSelectionRange = w("singleSelectionRange", "Line {0}, Column {1} ({2} selected)"), n.singleSelection = w("singleSelection", "Line {0}, Column {1}"), n.multiSelectionRange = w("multiSelectionRange", "{0} selections ({1} characters selected)"), n.multiSelection = w("multiSelection", "{0} selections"), n.emergencyConfOn = w("emergencyConfOn", "Now changing the setting `accessibilitySupport` to 'on'."), n.openingDocs = w("openingDocs", "Now opening the Editor Accessibility documentation page."), n.readonlyDiffEditor = w("readonlyDiffEditor", " in a read-only pane of a diff editor."), n.editableDiffEditor = w("editableDiffEditor", " in a pane of a diff editor."), n.readonlyEditor = w("readonlyEditor", " in a read-only code editor"), n.editableEditor = w("editableEditor", " in a code editor"), n.changeConfigToOnMac = w("changeConfigToOnMac", "To configure the editor to be optimized for usage with a Screen Reader press Command+E now."), n.changeConfigToOnWinLinux = w("changeConfigToOnWinLinux", "To configure the editor to be optimized for usage with a Screen Reader press Control+E now."), n.auto_on = w("auto_on", "The editor is configured to be optimized for usage with a Screen Reader."), n.auto_off = w("auto_off", "The editor is configured to never be optimized for usage with a Screen Reader, which is not the case at this time."), n.tabFocusModeOnMsg = w("tabFocusModeOnMsg", "Pressing Tab in the current editor will move focus to the next focusable element. Toggle this behavior by pressing {0}."), n.tabFocusModeOnMsgNoKb = w("tabFocusModeOnMsgNoKb", "Pressing Tab in the current editor will move focus to the next focusable element. The command {0} is currently not triggerable by a keybinding."), n.tabFocusModeOffMsg = w("tabFocusModeOffMsg", "Pressing Tab in the current editor will insert the tab character. Toggle this behavior by pressing {0}."), n.tabFocusModeOffMsgNoKb = w("tabFocusModeOffMsgNoKb", "Pressing Tab in the current editor will insert the tab character. The command {0} is currently not triggerable by a keybinding."), n.openDocMac = w("openDocMac", "Press Command+H now to open a browser window with more information related to editor accessibility."), n.openDocWinLinux = w("openDocWinLinux", "Press Control+H now to open a browser window with more information related to editor accessibility."), n.outroMsg = w("outroMsg", "You can dismiss this tooltip and return to the editor by pressing Escape or Shift+Escape."), n.showAccessibilityHelpAction = w("showAccessibilityHelpAction", "Show Accessibility Help");
})(Ek || (Ek = {}));
var Lk;
(function(n) {
  n.inspectTokensAction = w("inspectTokens", "Developer: Inspect Tokens");
})(Lk || (Lk = {}));
var Dk;
(function(n) {
  n.gotoLineActionLabel = w("gotoLineActionLabel", "Go to Line/Column...");
})(Dk || (Dk = {}));
var Rk;
(function(n) {
  n.helpQuickAccessActionLabel = w("helpQuickAccess", "Show all Quick Access Providers");
})(Rk || (Rk = {}));
var Tk;
(function(n) {
  n.quickCommandActionLabel = w("quickCommandActionLabel", "Command Palette"), n.quickCommandHelp = w("quickCommandActionHelp", "Show And Run Commands");
})(Tk || (Tk = {}));
var Ok;
(function(n) {
  n.quickOutlineActionLabel = w("quickOutlineActionLabel", "Go to Symbol..."), n.quickOutlineByCategoryActionLabel = w("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
})(Ok || (Ok = {}));
var Eb;
(function(n) {
  n.editorViewAccessibleLabel = w("editorViewAccessibleLabel", "Editor content"), n.accessibilityHelpMessage = w("accessibilityHelpMessage", "Press Alt+F1 for Accessibility Options.");
})(Eb || (Eb = {}));
var xk;
(function(n) {
  n.toggleHighContrast = w("toggleHighContrast", "Toggle High Contrast Theme");
})(xk || (xk = {}));
var ET;
(function(n) {
  n.bulkEditServiceSummary = w("bulkEditServiceSummary", "Made {0} edits in {1} files");
})(ET || (ET = {}));
var O5 = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, x5 = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, N5 = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class yae {
  constructor(e) {
    this.disposed = !1, this.model = e, this._onWillDispose = new j();
  }
  get textEditorModel() {
    return this.model;
  }
  dispose() {
    this.disposed = !0, this._onWillDispose.fire();
  }
}
function wae(n, e, t) {
  return ih(n) ? e(n) : t(n);
}
let LT = class {
  constructor(e) {
    this.modelService = e;
  }
  setEditor(e) {
    this.editor = e;
  }
  createModelReference(e) {
    let t = null;
    return this.editor && (t = wae(this.editor, (i) => this.findModel(i, e), (i) => this.findModel(i.getOriginalEditor(), e) || this.findModel(i.getModifiedEditor(), e))), t ? Promise.resolve(new qie(new yae(t))) : Promise.reject(new Error("Model not found"));
  }
  findModel(e, t) {
    let i = this.modelService.getModel(t);
    return i && i.uri.toString() !== t.toString() ? null : i;
  }
};
LT = O5([
  x5(0, ro)
], LT);
class r0 {
  show() {
    return r0.NULL_PROGRESS_RUNNER;
  }
  showWhile(e, t) {
    return N5(this, void 0, void 0, function* () {
      yield e;
    });
  }
}
r0.NULL_PROGRESS_RUNNER = {
  done: () => {
  },
  total: () => {
  },
  worked: () => {
  }
};
class bae {
  confirm(e) {
    return this.doConfirm(e).then((t) => ({
      confirmed: t,
      checkboxChecked: !1
      // unsupported
    }));
  }
  doConfirm(e) {
    let t = e.message;
    return e.detail && (t = t + `

` + e.detail), Promise.resolve(window.confirm(t));
  }
  show(e, t, i, r) {
    return Promise.resolve({ choice: 0 });
  }
}
class o0 {
  info(e) {
    return this.notify({ severity: pn.Info, message: e });
  }
  warn(e) {
    return this.notify({ severity: pn.Warning, message: e });
  }
  error(e) {
    return this.notify({ severity: pn.Error, message: e });
  }
  notify(e) {
    switch (e.severity) {
      case pn.Error:
        console.error(e.message);
        break;
      case pn.Warning:
        console.warn(e.message);
        break;
      default:
        console.log(e.message);
        break;
    }
    return o0.NO_OP;
  }
  status(e, t) {
    return ge.None;
  }
}
o0.NO_OP = new vae();
class Sae {
  constructor(e) {
    this._onWillExecuteCommand = new j(), this._onDidExecuteCommand = new j(), this.onDidExecuteCommand = this._onDidExecuteCommand.event, this._instantiationService = e;
  }
  executeCommand(e, ...t) {
    const i = Xn.getCommand(e);
    if (!i)
      return Promise.reject(new Error(`command '${e}' not found`));
    try {
      this._onWillExecuteCommand.fire({ commandId: e, args: t });
      const r = this._instantiationService.invokeFunction.apply(this._instantiationService, [i.handler, ...t]);
      return this._onDidExecuteCommand.fire({ commandId: e, args: t }), Promise.resolve(r);
    } catch (r) {
      return Promise.reject(r);
    }
  }
}
class I5 extends hae {
  constructor(e, t, i, r, o, s) {
    super(e, t, i, r, o), this._cachedResolver = null, this._dynamicKeybindings = [], this._register(ye(s, Be.KEY_DOWN, (a) => {
      const l = new Ki(a);
      this._dispatch(l, l.target) && (l.preventDefault(), l.stopPropagation());
    })), this._register(ye(window, Be.KEY_UP, (a) => {
      const l = new Ki(a);
      this._singleModifierDispatch(l, l.target) && l.preventDefault();
    }));
  }
  addDynamicKeybinding(e, t, i, r) {
    const o = tR(t, Ga), s = new ht();
    return o && (this._dynamicKeybindings.push({
      keybinding: o,
      command: e,
      when: r,
      weight1: 1e3,
      weight2: 0,
      extensionId: null,
      isBuiltinExtension: !1
    }), s.add(Ri(() => {
      for (let a = 0; a < this._dynamicKeybindings.length; a++)
        if (this._dynamicKeybindings[a].command === e) {
          this._dynamicKeybindings.splice(a, 1), this.updateResolver({
            source: 1
            /* Default */
          });
          return;
        }
    }))), s.add(Xn.registerCommand(e, i)), this.updateResolver({
      source: 1
      /* Default */
    }), s;
  }
  updateResolver(e) {
    this._cachedResolver = null, this._onDidUpdateKeybindings.fire(e);
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const e = this._toNormalizedKeybindingItems(n0.getDefaultKeybindings(), !0), t = this._toNormalizedKeybindingItems(this._dynamicKeybindings, !1);
      this._cachedResolver = new mp(e, t, (i) => this._log(i));
    }
    return this._cachedResolver;
  }
  _documentHasFocus() {
    return document.hasFocus();
  }
  _toNormalizedKeybindingItems(e, t) {
    let i = [], r = 0;
    for (const o of e) {
      const s = o.when || void 0, a = o.keybinding;
      if (!a)
        i[r++] = new bk(void 0, o.command, o.commandArgs, s, t, null, !1);
      else {
        const l = this.resolveKeybinding(a);
        for (const u of l)
          i[r++] = new bk(u, o.command, o.commandArgs, s, t, null, !1);
      }
    }
    return i;
  }
  resolveKeybinding(e) {
    return [new Sb(e, Ga)];
  }
  resolveKeyboardEvent(e) {
    let t = new aN(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, e.keyCode).toChord();
    return new Sb(t, Ga);
  }
}
function Nk(n) {
  return n && typeof n == "object" && (!n.overrideIdentifier || typeof n.overrideIdentifier == "string") && (!n.resource || n.resource instanceof dt);
}
class P5 {
  constructor() {
    this._onDidChangeConfiguration = new j(), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._configuration = new L5(new uae(), new cs());
  }
  getValue(e, t) {
    const i = typeof e == "string" ? e : void 0, r = Nk(e) ? e : Nk(t) ? t : {};
    return this._configuration.getValue(i, r, void 0);
  }
  updateValues(e) {
    const t = { data: this._configuration.toData() };
    let i = [];
    for (const r of e) {
      const [o, s] = r;
      this.getValue(o) !== s && (this._configuration.updateValue(o, s), i.push(o));
    }
    if (i.length > 0) {
      const r = new cae({ keys: i, overrides: [] }, t, this._configuration);
      r.source = 7, r.sourceConfig = null, this._onDidChangeConfiguration.fire(r);
    }
    return Promise.resolve();
  }
}
class Eae {
  constructor(e) {
    this.configurationService = e, this._onDidChangeConfiguration = new j(), this.configurationService.onDidChangeConfiguration((t) => {
      this._onDidChangeConfiguration.fire({ affectedKeys: t.affectedKeys, affectsConfiguration: (i, r) => t.affectsConfiguration(r) });
    });
  }
  getValue(e, t, i) {
    const o = (J.isIPosition(t) ? t : null) ? typeof i == "string" ? i : void 0 : typeof t == "string" ? t : void 0;
    return typeof o > "u" ? this.configurationService.getValue() : this.configurationService.getValue(o);
  }
}
let DT = class {
  constructor(e) {
    this.configurationService = e;
  }
  getEOL(e, t) {
    const i = this.configurationService.getValue("files.eol", { overrideIdentifier: t, resource: e });
    return i && i !== "auto" ? i : Rs || Ft ? `
` : `\r
`;
  }
};
DT = O5([
  x5(0, mr)
], DT);
class Lae {
  publicLog(e, t) {
    return Promise.resolve(void 0);
  }
  publicLog2(e, t) {
    return this.publicLog(e, t);
  }
}
class s0 {
  constructor() {
    const e = dt.from({ scheme: s0.SCHEME, authority: "model", path: "/" });
    this.workspace = { id: "4064f6ec-cb38-4ad0-af64-ee6467e63c82", folders: [new Cae({ uri: e, name: "", index: 0 })] };
  }
  getWorkspace() {
    return this.workspace;
  }
}
s0.SCHEME = "inmemory";
function Lb(n, e, t) {
  if (!e || !(n instanceof P5))
    return;
  let i = [];
  Object.keys(e).forEach((r) => {
    nae(r) && i.push([`editor.${r}`, e[r]]), t && rae(r) && i.push([`diffEditor.${r}`, e[r]]);
  }), i.length > 0 && n.updateValues(i);
}
class Dae {
  constructor(e) {
    this._modelService = e;
  }
  hasPreviewHandler() {
    return !1;
  }
  apply(e, t) {
    return N5(this, void 0, void 0, function* () {
      const i = /* @__PURE__ */ new Map();
      for (let s of e) {
        if (!(s instanceof C5))
          throw new Error("bad edit - only text edits are supported");
        const a = this._modelService.getModel(s.resource);
        if (!a)
          throw new Error("bad edit - model not found");
        if (typeof s.versionId == "number" && a.getVersionId() !== s.versionId)
          throw new Error("bad state - model changed in the meantime");
        let l = i.get(a);
        l || (l = [], i.set(a, l)), l.push(ST.replaceMove(V.lift(s.textEdit.range), s.textEdit.text));
      }
      let r = 0, o = 0;
      for (const [s, a] of i)
        s.pushStackElement(), s.pushEditOperations([], a, () => []), s.pushStackElement(), o += 1, r += a.length;
      return {
        ariaSummary: xl(ET.bulkEditServiceSummary, r, o)
      };
    });
  }
}
class Rae {
  getUriLabel(e, t) {
    return e.scheme === "file" ? e.fsPath : e.path;
  }
}
class Tae {
  constructor(e, t) {
    this._codeEditorService = e, this._container = t, this.onDidLayout = Ae.None;
  }
  get dimension() {
    return this._dimension || (this._dimension = EG(window.document.body)), this._dimension;
  }
  get container() {
    return this._container;
  }
  focus() {
    var e;
    (e = this._codeEditorService.getFocusedCodeEditor()) === null || e === void 0 || e.focus();
  }
}
const Ik = 2e4;
let zh, rw, RT, ow, TT;
function Oae(n) {
  zh = document.createElement("div"), zh.className = "monaco-aria-container";
  const e = () => {
    const i = document.createElement("div");
    return i.className = "monaco-alert", i.setAttribute("role", "alert"), i.setAttribute("aria-atomic", "true"), zh.appendChild(i), i;
  };
  rw = e(), RT = e();
  const t = () => {
    const i = document.createElement("div");
    return i.className = "monaco-status", i.setAttribute("role", "complementary"), i.setAttribute("aria-live", "polite"), i.setAttribute("aria-atomic", "true"), zh.appendChild(i), i;
  };
  ow = t(), TT = t(), n.appendChild(zh);
}
function ed(n) {
  zh && (rw.textContent !== n ? (Ts(RT), Db(rw, n)) : (Ts(rw), Db(RT, n)));
}
function OT(n) {
  zh && (Ft ? ed(n) : ow.textContent !== n ? (Ts(TT), Db(ow, n)) : (Ts(ow), Db(TT, n)));
}
function Db(n, e) {
  Ts(n), e.length > Ik && (e = e.substr(0, Ik)), n.textContent = e, n.style.visibility = "hidden", n.style.visibility = "visible";
}
const A5 = Vt("markerDecorationsService");
var Rb = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class Wl extends ge {
  constructor(e, t = "", i = "", r = !0, o) {
    super(), this._onDidChange = this._register(new j()), this.onDidChange = this._onDidChange.event, this._enabled = !0, this._checked = !1, this._id = e, this._label = t, this._cssClass = i, this._enabled = r, this._actionCallback = o;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(e) {
    this._setLabel(e);
  }
  _setLabel(e) {
    this._label !== e && (this._label = e, this._onDidChange.fire({ label: e }));
  }
  get tooltip() {
    return this._tooltip || "";
  }
  set tooltip(e) {
    this._setTooltip(e);
  }
  _setTooltip(e) {
    this._tooltip !== e && (this._tooltip = e, this._onDidChange.fire({ tooltip: e }));
  }
  get class() {
    return this._cssClass;
  }
  set class(e) {
    this._setClass(e);
  }
  _setClass(e) {
    this._cssClass !== e && (this._cssClass = e, this._onDidChange.fire({ class: e }));
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._setEnabled(e);
  }
  _setEnabled(e) {
    this._enabled !== e && (this._enabled = e, this._onDidChange.fire({ enabled: e }));
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._setChecked(e);
  }
  _setChecked(e) {
    this._checked !== e && (this._checked = e, this._onDidChange.fire({ checked: e }));
  }
  run(e, t) {
    return Rb(this, void 0, void 0, function* () {
      this._actionCallback && (yield this._actionCallback(e));
    });
  }
}
class WN extends ge {
  constructor() {
    super(...arguments), this._onBeforeRun = this._register(new j()), this.onBeforeRun = this._onBeforeRun.event, this._onDidRun = this._register(new j()), this.onDidRun = this._onDidRun.event;
  }
  run(e, t) {
    return Rb(this, void 0, void 0, function* () {
      if (!e.enabled)
        return;
      this._onBeforeRun.fire({ action: e });
      let i;
      try {
        yield this.runAction(e, t);
      } catch (r) {
        i = r;
      }
      this._onDidRun.fire({ action: e, error: i });
    });
  }
  runAction(e, t) {
    return Rb(this, void 0, void 0, function* () {
      yield e.run(t);
    });
  }
}
class Yd extends Wl {
  constructor(e) {
    super(Yd.ID, e, e ? "separator text" : "separator"), this.checked = !1, this.enabled = !1;
  }
}
Yd.ID = "vs.actions.separator";
class M5 {
  constructor(e, t, i, r) {
    this.tooltip = "", this.enabled = !0, this.checked = !1, this.id = e, this.label = t, this.class = r, this._actions = i;
  }
  get actions() {
    return this._actions;
  }
  dispose() {
  }
  run() {
    return Rb(this, void 0, void 0, function* () {
    });
  }
}
class a0 extends Wl {
  constructor() {
    super(a0.ID, w("submenu.empty", "(empty)"), void 0, !1);
  }
}
a0.ID = "vs.actions.empty";
let l0 = rie || "";
const Do = /* @__PURE__ */ new Map();
Do.set("false", !1);
Do.set("true", !0);
Do.set("isMac", Ft);
Do.set("isLinux", Rs);
Do.set("isWindows", Eo);
Do.set("isWeb", BS);
Do.set("isMacNative", Ft && !BS);
Do.set("isEdge", l0.indexOf("Edg/") >= 0);
Do.set("isFirefox", l0.indexOf("Firefox") >= 0);
Do.set("isChrome", l0.indexOf("Chrome") >= 0);
Do.set("isSafari", l0.indexOf("Safari") >= 0);
const xae = Object.prototype.hasOwnProperty;
class hr {
  static has(e) {
    return nh.create(e);
  }
  static equals(e, t) {
    return Yv.create(e, t);
  }
  static regex(e, t) {
    return Tb.create(e, t);
  }
  static not(e) {
    return Nd.create(e);
  }
  static and(...e) {
    return vp.create(e);
  }
  static or(...e) {
    return Id.create(e);
  }
  static deserialize(e, t = !1) {
    if (e)
      return this._deserializeOrExpression(e, t);
  }
  static _deserializeOrExpression(e, t) {
    let i = e.split("||");
    return Id.create(i.map((r) => this._deserializeAndExpression(r, t)));
  }
  static _deserializeAndExpression(e, t) {
    let i = e.split("&&");
    return vp.create(i.map((r) => this._deserializeOne(r, t)));
  }
  static _deserializeOne(e, t) {
    if (e = e.trim(), e.indexOf("!=") >= 0) {
      let i = e.split("!=");
      return u0.create(i[0].trim(), this._deserializeValue(i[1], t));
    }
    if (e.indexOf("==") >= 0) {
      let i = e.split("==");
      return Yv.create(i[0].trim(), this._deserializeValue(i[1], t));
    }
    if (e.indexOf("=~") >= 0) {
      let i = e.split("=~");
      return Tb.create(i[0].trim(), this._deserializeRegexValue(i[1], t));
    }
    if (e.indexOf(" in ") >= 0) {
      let i = e.split(" in ");
      return VN.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+>=[^<=>]+$/.test(e)) {
      const i = e.split(">=");
      return h0.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+>[^<=>]+$/.test(e)) {
      const i = e.split(">");
      return c0.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+<=[^<=>]+$/.test(e)) {
      const i = e.split("<=");
      return f0.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+<[^<=>]+$/.test(e)) {
      const i = e.split("<");
      return d0.create(i[0].trim(), i[1].trim());
    }
    return /^\!\s*/.test(e) ? Nd.create(e.substr(1).trim()) : nh.create(e);
  }
  static _deserializeValue(e, t) {
    if (e = e.trim(), e === "true")
      return !0;
    if (e === "false")
      return !1;
    let i = /^'([^']*)'$/.exec(e);
    return i ? i[1].trim() : e;
  }
  static _deserializeRegexValue(e, t) {
    if (Zne(e)) {
      if (t)
        throw new Error("missing regexp-value for =~-expression");
      return console.warn("missing regexp-value for =~-expression"), null;
    }
    let i = e.indexOf("/"), r = e.lastIndexOf("/");
    if (i === r || i < 0) {
      if (t)
        throw new Error(`bad regexp-value '${e}', missing /-enclosure`);
      return console.warn(`bad regexp-value '${e}', missing /-enclosure`), null;
    }
    let o = e.slice(i + 1, r), s = e[r + 1] === "i" ? "i" : "";
    try {
      return new RegExp(o, s);
    } catch (a) {
      if (t)
        throw new Error(`bad regexp-value '${e}', parse error: ${a}`);
      return console.warn(`bad regexp-value '${e}', parse error: ${a}`), null;
    }
  }
}
function hv(n, e) {
  return n.cmp(e);
}
class qu {
  constructor() {
    this.type = 0;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  evaluate(e) {
    return !1;
  }
  serialize() {
    return "false";
  }
  keys() {
    return [];
  }
  negate() {
    return Yu.INSTANCE;
  }
}
qu.INSTANCE = new qu();
class Yu {
  constructor() {
    this.type = 1;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  evaluate(e) {
    return !0;
  }
  serialize() {
    return "true";
  }
  keys() {
    return [];
  }
  negate() {
    return qu.INSTANCE;
  }
}
Yu.INSTANCE = new Yu();
class nh {
  constructor(e) {
    this.key = e, this.type = 2;
  }
  static create(e) {
    const t = Do.get(e);
    return typeof t == "boolean" ? t ? Yu.INSTANCE : qu.INSTANCE : new nh(e);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : F5(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  evaluate(e) {
    return !!e.getValue(this.key);
  }
  serialize() {
    return this.key;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return Nd.create(this.key);
  }
}
class Yv {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 4;
  }
  static create(e, t) {
    if (typeof t == "boolean")
      return t ? nh.create(e) : Nd.create(e);
    const i = Do.get(e);
    return typeof i == "boolean" ? t === (i ? "true" : "false") ? Yu.INSTANCE : qu.INSTANCE : new Yv(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xd(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return e.getValue(this.key) == this.value;
  }
  serialize() {
    return `${this.key} == '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return u0.create(this.key, this.value);
  }
}
class VN {
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 10;
  }
  static create(e, t) {
    return new VN(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xd(this.key, this.valueKey, e.key, e.valueKey);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : !1;
  }
  evaluate(e) {
    const t = e.getValue(this.valueKey), i = e.getValue(this.key);
    return Array.isArray(t) ? t.indexOf(i) >= 0 : typeof i == "string" && typeof t == "object" && t !== null ? xae.call(t, i) : !1;
  }
  serialize() {
    return `${this.key} in '${this.valueKey}'`;
  }
  keys() {
    return [this.key, this.valueKey];
  }
  negate() {
    return BN.create(this);
  }
}
class BN {
  constructor(e) {
    this._actual = e, this.type = 11;
  }
  static create(e) {
    return new BN(e);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
  }
  equals(e) {
    return e.type === this.type ? this._actual.equals(e._actual) : !1;
  }
  evaluate(e) {
    return !this._actual.evaluate(e);
  }
  serialize() {
    throw new Error("Method not implemented.");
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
}
class u0 {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 5;
  }
  static create(e, t) {
    if (typeof t == "boolean")
      return t ? Nd.create(e) : nh.create(e);
    const i = Do.get(e);
    return typeof i == "boolean" ? t === (i ? "true" : "false") ? qu.INSTANCE : Yu.INSTANCE : new u0(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xd(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return e.getValue(this.key) != this.value;
  }
  serialize() {
    return `${this.key} != '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return Yv.create(this.key, this.value);
  }
}
class Nd {
  constructor(e) {
    this.key = e, this.type = 3;
  }
  static create(e) {
    const t = Do.get(e);
    return typeof t == "boolean" ? t ? qu.INSTANCE : Yu.INSTANCE : new Nd(e);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : F5(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  evaluate(e) {
    return !e.getValue(this.key);
  }
  serialize() {
    return `!${this.key}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return nh.create(this.key);
  }
}
class c0 {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 12;
  }
  static create(e, t) {
    return new c0(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xd(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return parseFloat(e.getValue(this.key)) > parseFloat(this.value);
  }
  serialize() {
    return `${this.key} > ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return f0.create(this.key, this.value);
  }
}
class h0 {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 13;
  }
  static create(e, t) {
    return new h0(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xd(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return parseFloat(e.getValue(this.key)) >= parseFloat(this.value);
  }
  serialize() {
    return `${this.key} >= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return d0.create(this.key, this.value);
  }
}
class d0 {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 14;
  }
  static create(e, t) {
    return new d0(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xd(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return parseFloat(e.getValue(this.key)) < parseFloat(this.value);
  }
  serialize() {
    return `${this.key} < ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return h0.create(this.key, this.value);
  }
}
class f0 {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 15;
  }
  static create(e, t) {
    return new f0(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Xd(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return parseFloat(e.getValue(this.key)) <= parseFloat(this.value);
  }
  serialize() {
    return `${this.key} <= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return c0.create(this.key, this.value);
  }
}
class Tb {
  constructor(e, t) {
    this.key = e, this.regexp = t, this.type = 7;
  }
  static create(e, t) {
    return new Tb(e, t);
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.key < e.key)
      return -1;
    if (this.key > e.key)
      return 1;
    const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
    return t < i ? -1 : t > i ? 1 : 0;
  }
  equals(e) {
    if (e.type === this.type) {
      const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
      return this.key === e.key && t === i;
    }
    return !1;
  }
  evaluate(e) {
    let t = e.getValue(this.key);
    return this.regexp ? this.regexp.test(t) : !1;
  }
  serialize() {
    const e = this.regexp ? `/${this.regexp.source}/${this.regexp.ignoreCase ? "i" : ""}` : "/invalid/";
    return `${this.key} =~ ${e}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return HN.create(this);
  }
}
class HN {
  constructor(e) {
    this._actual = e, this.type = 8;
  }
  static create(e) {
    return new HN(e);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
  }
  equals(e) {
    return e.type === this.type ? this._actual.equals(e._actual) : !1;
  }
  evaluate(e) {
    return !this._actual.evaluate(e);
  }
  serialize() {
    throw new Error("Method not implemented.");
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
}
class vp {
  constructor(e) {
    this.expr = e, this.type = 6;
  }
  static create(e) {
    return vp._normalizeArr(e);
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const r = hv(this.expr[t], e.expr[t]);
      if (r !== 0)
        return r;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (!this.expr[t].evaluate(e))
        return !1;
    return !0;
  }
  static _normalizeArr(e) {
    const t = [];
    let i = !1;
    for (const r of e)
      if (r) {
        if (r.type === 1) {
          i = !0;
          continue;
        }
        if (r.type === 0)
          return qu.INSTANCE;
        if (r.type === 6) {
          t.push(...r.expr);
          continue;
        }
        t.push(r);
      }
    if (t.length === 0 && i)
      return Yu.INSTANCE;
    if (t.length !== 0) {
      if (t.length === 1)
        return t[0];
      for (t.sort(hv); t.length > 1; ) {
        const r = t[t.length - 1];
        if (r.type !== 9)
          break;
        t.pop();
        const o = t.pop(), s = Id.create(r.expr.map((a) => vp.create([a, o])));
        s && (t.push(s), t.sort(hv));
      }
      return t.length === 1 ? t[0] : new vp(t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" && ");
  }
  keys() {
    const e = [];
    for (let t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    let e = [];
    for (let t of this.expr)
      e.push(t.negate());
    return Id.create(e);
  }
}
class Id {
  constructor(e) {
    this.expr = e, this.type = 9;
  }
  static create(e) {
    const t = Id._normalizeArr(e);
    if (t.length !== 0)
      return t.length === 1 ? t[0] : new Id(t);
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const r = hv(this.expr[t], e.expr[t]);
      if (r !== 0)
        return r;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (this.expr[t].evaluate(e))
        return !0;
    return !1;
  }
  static _normalizeArr(e) {
    let t = [], i = !1;
    if (e) {
      for (let r = 0, o = e.length; r < o; r++) {
        const s = e[r];
        if (s) {
          if (s.type === 0) {
            i = !0;
            continue;
          }
          if (s.type === 1)
            return [Yu.INSTANCE];
          if (s.type === 9) {
            t = t.concat(s.expr);
            continue;
          }
          t.push(s);
        }
      }
      if (t.length === 0 && i)
        return [qu.INSTANCE];
      t.sort(hv);
    }
    return t;
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" || ");
  }
  keys() {
    const e = [];
    for (let t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    let e = [];
    for (let i of this.expr)
      e.push(i.negate());
    const t = (i) => i.type === 9 ? i.expr : [i];
    for (; e.length > 1; ) {
      const i = e.shift(), r = e.shift(), o = [];
      for (const s of t(i))
        for (const a of t(r))
          o.push(hr.and(s, a));
      e.unshift(hr.or(...o));
    }
    return e[0];
  }
}
class it extends nh {
  constructor(e, t, i) {
    super(e), this._defaultValue = t, typeof i == "object" ? it._info.push(Object.assign(Object.assign({}, i), { key: e })) : i !== !0 && it._info.push({ key: e, description: i, type: t != null ? typeof t : void 0 });
  }
  static all() {
    return it._info.values();
  }
  bindTo(e) {
    return e.createKey(this.key, this._defaultValue);
  }
  getValue(e) {
    return e.getContextKeyValue(this.key);
  }
  toNegated() {
    return hr.not(this.key);
  }
  isEqualTo(e) {
    return hr.equals(this.key, e);
  }
}
it._info = [];
const Ti = Vt("contextKeyService"), Nae = "setContext";
function F5(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
function Xd(n, e, t, i) {
  return n < t ? -1 : n > t ? 1 : e < i ? -1 : e > i ? 1 : 0;
}
var Vl;
(function(n) {
  n.DARK = "dark", n.LIGHT = "light", n.HIGH_CONTRAST = "hc";
})(Vl || (Vl = {}));
const Qn = Vt("themeService");
var xT;
(function(n) {
  function e(t) {
    return t && typeof t == "object" && typeof t.id == "string";
  }
  n.isThemeColor = e;
})(xT || (xT = {}));
function Rm(n) {
  return { id: n };
}
var fa;
(function(n) {
  function e(a) {
    return a && typeof a == "object" && typeof a.id == "string" && (typeof a.color > "u" || xT.isThemeColor(a.color));
  }
  n.isThemeIcon = e;
  const t = new RegExp(`^\\$\\((${Vo.iconNameExpression}(?:${Vo.iconModifierExpression})?)\\)$`);
  function i(a) {
    const l = t.exec(a);
    if (!l)
      return;
    let [, u] = l;
    return { id: u };
  }
  n.fromString = i;
  function r(a, l) {
    let u = a.id;
    const c = u.lastIndexOf("~");
    return c !== -1 && (u = u.substring(0, c)), l && (u = `${u}~${l}`), { id: u };
  }
  n.modify = r;
  function o(a, l) {
    var u, c;
    return a.id === l.id && ((u = a.color) === null || u === void 0 ? void 0 : u.id) === ((c = l.color) === null || c === void 0 ? void 0 : c.id);
  }
  n.isEqual = o;
  function s(a) {
    return { id: a.id };
  }
  n.asThemeIcon = s, n.asClassNameArray = Vo.asClassNameArray, n.asClassName = Vo.asClassName, n.asCSSSelector = Vo.asCSSSelector;
})(fa || (fa = {}));
function Ob(n) {
  switch (n) {
    case Vl.DARK:
      return "vs-dark";
    case Vl.HIGH_CONTRAST:
      return "hc-black";
    default:
      return "vs";
  }
}
const k5 = {
  ThemingContribution: "base.contributions.theming"
};
class Iae {
  constructor() {
    this.themingParticipants = [], this.themingParticipants = [], this.onThemingParticipantAddedEmitter = new j();
  }
  onColorThemeChange(e) {
    return this.themingParticipants.push(e), this.onThemingParticipantAddedEmitter.fire(e), Ri(() => {
      const t = this.themingParticipants.indexOf(e);
      this.themingParticipants.splice(t, 1);
    });
  }
  getThemingParticipants() {
    return this.themingParticipants;
  }
}
let W5 = new Iae();
Zn.add(k5.ThemingContribution, W5);
function _a(n) {
  return W5.onColorThemeChange(n);
}
class Pae extends ge {
  constructor(e) {
    super(), this.themeService = e, this.theme = e.getColorTheme(), this._register(this.themeService.onDidColorThemeChange((t) => this.onThemeChange(t)));
  }
  onThemeChange(e) {
    this.theme = e, this.updateStyles();
  }
  updateStyles() {
  }
}
var Aae = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Pk = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
function Gm(n) {
  return n.command !== void 0;
}
class si {
  constructor(e) {
    this.id = si._idPool++, this._debugName = e;
  }
}
si._idPool = 0;
si.CommandPalette = new si("CommandPalette");
si.EditorContext = new si("EditorContext");
si.SimpleEditorContext = new si("SimpleEditorContext");
si.EditorContextCopy = new si("EditorContextCopy");
si.EditorContextPeek = new si("EditorContextPeek");
si.MenubarEditMenu = new si("MenubarEditMenu");
si.MenubarCopy = new si("MenubarCopy");
si.MenubarGoMenu = new si("MenubarGoMenu");
si.MenubarSelectionMenu = new si("MenubarSelectionMenu");
si.InlineCompletionsActions = new si("InlineCompletionsActions");
const V5 = Vt("menuService"), dv = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._menuItems = /* @__PURE__ */ new Map(), this._onDidChangeMenu = new j(), this.onDidChangeMenu = this._onDidChangeMenu.event, this._commandPaletteChangeEvent = {
      has: (n) => n === si.CommandPalette
    };
  }
  addCommand(n) {
    return this.addCommands(_t.single(n));
  }
  addCommands(n) {
    for (const e of n)
      this._commands.set(e.id, e);
    return this._onDidChangeMenu.fire(this._commandPaletteChangeEvent), Ri(() => {
      let e = !1;
      for (const t of n)
        e = this._commands.delete(t.id) || e;
      e && this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);
    });
  }
  getCommand(n) {
    return this._commands.get(n);
  }
  getCommands() {
    const n = /* @__PURE__ */ new Map();
    return this._commands.forEach((e, t) => n.set(t, e)), n;
  }
  appendMenuItem(n, e) {
    return this.appendMenuItems(_t.single({ id: n, item: e }));
  }
  appendMenuItems(n) {
    const e = /* @__PURE__ */ new Set(), t = new ua();
    for (const { id: i, item: r } of n) {
      let o = this._menuItems.get(i);
      o || (o = new ua(), this._menuItems.set(i, o)), t.push(o.push(r)), e.add(i);
    }
    return this._onDidChangeMenu.fire(e), Ri(() => {
      if (t.size > 0) {
        for (let i of t)
          i();
        this._onDidChangeMenu.fire(e), t.clear();
      }
    });
  }
  getMenuItems(n) {
    let e;
    return this._menuItems.has(n) ? e = [...this._menuItems.get(n)] : e = [], n === si.CommandPalette && this._appendImplicitItems(e), e;
  }
  _appendImplicitItems(n) {
    const e = /* @__PURE__ */ new Set();
    for (const t of n)
      Gm(t) && (e.add(t.command.id), t.alt && e.add(t.alt.id));
    this._commands.forEach((t, i) => {
      e.has(i) || n.push({ command: t });
    });
  }
}();
class Mae extends M5 {
  constructor(e, t, i, r) {
    super(`submenuitem.${e.submenu.id}`, typeof e.title == "string" ? e.title : e.title.value, [], "submenu"), this.item = e, this._menuService = t, this._contextKeyService = i, this._options = r;
  }
  get actions() {
    const e = [], t = this._menuService.createMenu(this.item.submenu, this._contextKeyService), i = t.getActions(this._options);
    t.dispose();
    for (const [, r] of i)
      r.length > 0 && (e.push(...r), e.push(new Yd()));
    return e.length && e.pop(), e;
  }
}
let NT = class B5 {
  constructor(e, t, i, r, o) {
    var s;
    if (this._commandService = o, this.id = e.id, this.label = i != null && i.renderShortTitle && e.shortTitle ? typeof e.shortTitle == "string" ? e.shortTitle : e.shortTitle.value : typeof e.title == "string" ? e.title : e.title.value, this.tooltip = (s = e.tooltip) !== null && s !== void 0 ? s : "", this.enabled = !e.precondition || r.contextMatchesRules(e.precondition), this.checked = !1, e.toggled) {
      const a = e.toggled.condition ? e.toggled : { condition: e.toggled };
      this.checked = r.contextMatchesRules(a.condition), this.checked && a.tooltip && (this.tooltip = typeof a.tooltip == "string" ? a.tooltip : a.tooltip.value), a.title && (this.label = typeof a.title == "string" ? a.title : a.title.value);
    }
    this.item = e, this.alt = t ? new B5(t, void 0, i, r, o) : void 0, this._options = i, fa.isThemeIcon(e.icon) && (this.class = Vo.asClassName(e.icon));
  }
  dispose() {
  }
  run(...e) {
    var t, i;
    let r = [];
    return !((t = this._options) === null || t === void 0) && t.arg && (r = [...r, this._options.arg]), !((i = this._options) === null || i === void 0) && i.shouldForwardArgs && (r = [...r, ...e]), this._commandService.executeCommand(this.id, ...r);
  }
};
NT = Aae([
  Pk(3, Ti),
  Pk(4, Ko)
], NT);
const p0 = Vt("telemetryService");
class g0 {
  constructor(e) {
    this.id = e.id, this.precondition = e.precondition, this._kbOpts = e.kbOpts, this._menuOpts = e.menuOpts, this._description = e.description;
  }
  register() {
    if (Array.isArray(this._menuOpts) ? this._menuOpts.forEach(this._registerMenuItem, this) : this._menuOpts && this._registerMenuItem(this._menuOpts), this._kbOpts) {
      const e = Array.isArray(this._kbOpts) ? this._kbOpts : [this._kbOpts];
      for (const t of e) {
        let i = t.kbExpr;
        this.precondition && (i ? i = hr.and(i, this.precondition) : i = this.precondition);
        const r = {
          id: this.id,
          weight: t.weight,
          args: t.args,
          when: i,
          primary: t.primary,
          secondary: t.secondary,
          win: t.win,
          linux: t.linux,
          mac: t.mac
        };
        n0.registerKeybindingRule(r);
      }
    }
    Xn.registerCommand({
      id: this.id,
      handler: (e, t) => this.runCommand(e, t),
      description: this._description
    });
  }
  _registerMenuItem(e) {
    dv.appendMenuItem(e.menuId, {
      group: e.group,
      command: {
        id: this.id,
        title: e.title,
        icon: e.icon,
        precondition: this.precondition
      },
      when: e.when,
      order: e.order
    });
  }
}
class GN extends g0 {
  constructor() {
    super(...arguments), this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(e, t, i) {
    return this._implementations.push({ priority: e, name: t, implementation: i }), this._implementations.sort((r, o) => o.priority - r.priority), {
      dispose: () => {
        for (let r = 0; r < this._implementations.length; r++)
          if (this._implementations[r].implementation === i) {
            this._implementations.splice(r, 1);
            return;
          }
      }
    };
  }
  runCommand(e, t) {
    const i = e.get(H_);
    for (const r of this._implementations) {
      const o = r.implementation(e, t);
      if (o)
        return i.trace(`Command '${this.id}' was handled by '${r.name}'.`), typeof o == "boolean" ? void 0 : o;
    }
  }
}
class H5 extends g0 {
  constructor(e, t) {
    super(t), this.command = e;
  }
  runCommand(e, t) {
    return this.command.runCommand(e, t);
  }
}
class Lg extends g0 {
  /**
   * Create a command class that is bound to a certain editor contribution.
   */
  static bindToContribution(e) {
    return class extends Lg {
      constructor(i) {
        super(i), this._callback = i.handler;
      }
      runEditorCommand(i, r, o) {
        e(r) && this._callback(e(r), o);
      }
    };
  }
  runCommand(e, t) {
    const i = e.get(pr), r = i.getFocusedCodeEditor() || i.getActiveCodeEditor();
    if (r)
      return r.invokeWithinContext((o) => {
        if (o.get(Ti).contextMatchesRules(Kf(this.precondition)))
          return this.runEditorCommand(o, r, t);
      });
  }
}
class G_ extends Lg {
  constructor(e) {
    super(G_.convertOptions(e)), this.label = e.label, this.alias = e.alias;
  }
  static convertOptions(e) {
    let t;
    Array.isArray(e.menuOpts) ? t = e.menuOpts : e.menuOpts ? t = [e.menuOpts] : t = [];
    function i(r) {
      return r.menuId || (r.menuId = si.EditorContext), r.title || (r.title = e.label), r.when = hr.and(e.precondition, r.when), r;
    }
    return Array.isArray(e.contextMenuOpts) ? t.push(...e.contextMenuOpts.map(i)) : e.contextMenuOpts && t.push(i(e.contextMenuOpts)), e.menuOpts = t, e;
  }
  runEditorCommand(e, t, i) {
    return this.reportTelemetry(e, t), this.run(e, t, i || {});
  }
  reportTelemetry(e, t) {
    e.get(p0).publicLog2("editorActionInvoked", { name: this.label, id: this.id });
  }
}
class VCe extends G_ {
  constructor() {
    super(...arguments), this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(e, t) {
    return this._implementations.push([e, t]), this._implementations.sort((i, r) => r[0] - i[0]), {
      dispose: () => {
        for (let i = 0; i < this._implementations.length; i++)
          if (this._implementations[i][1] === t) {
            this._implementations.splice(i, 1);
            return;
          }
      }
    };
  }
  run(e, t, i) {
    for (const r of this._implementations) {
      const o = r[1](e, t, i);
      if (o)
        return typeof o == "boolean" ? void 0 : o;
    }
  }
}
function BCe(n, e) {
  Xn.registerCommand(n, function(t, ...i) {
    const [r, o] = i;
    Uo(dt.isUri(r)), Uo(J.isIPosition(o));
    const s = t.get(ro).getModel(r);
    if (s) {
      const a = J.lift(o);
      return e(s, a, ...i.slice(2));
    }
    return t.get(pb).createModelReference(r).then((a) => new Promise((l, u) => {
      try {
        const c = e(a.object.textEditorModel, J.lift(o), i.slice(2));
        l(c);
      } catch (c) {
        u(c);
      }
    }).finally(() => {
      a.dispose();
    }));
  });
}
function HCe(n, e) {
  Xn.registerCommand(n, function(t, ...i) {
    const [r] = i;
    Uo(dt.isUri(r));
    const o = t.get(ro).getModel(r);
    return o ? e(o, ...i.slice(1)) : t.get(pb).createModelReference(r).then((s) => new Promise((a, l) => {
      try {
        const u = e(s.object.textEditorModel, i.slice(1));
        a(u);
      } catch (u) {
        l(u);
      }
    }).finally(() => {
      s.dispose();
    }));
  });
}
function Ze(n) {
  return gs.INSTANCE.registerEditorCommand(n), n;
}
function G5(n) {
  const e = new n();
  return gs.INSTANCE.registerEditorAction(e), e;
}
function GCe(n) {
  return gs.INSTANCE.registerEditorAction(n), n;
}
function UCe(n) {
  gs.INSTANCE.registerEditorAction(n);
}
function U5(n, e) {
  gs.INSTANCE.registerEditorContribution(n, e);
}
var _p;
(function(n) {
  function e(s) {
    return gs.INSTANCE.getEditorCommand(s);
  }
  n.getEditorCommand = e;
  function t() {
    return gs.INSTANCE.getEditorActions();
  }
  n.getEditorActions = t;
  function i() {
    return gs.INSTANCE.getEditorContributions();
  }
  n.getEditorContributions = i;
  function r(s) {
    return gs.INSTANCE.getEditorContributions().filter((a) => s.indexOf(a.id) >= 0);
  }
  n.getSomeEditorContributions = r;
  function o() {
    return gs.INSTANCE.getDiffEditorContributions();
  }
  n.getDiffEditorContributions = o;
})(_p || (_p = {}));
const Fae = {
  EditorCommonContributions: "editor.contributions"
};
class gs {
  constructor() {
    this.editorContributions = [], this.diffEditorContributions = [], this.editorActions = [], this.editorCommands = /* @__PURE__ */ Object.create(null);
  }
  registerEditorContribution(e, t) {
    this.editorContributions.push({ id: e, ctor: t });
  }
  getEditorContributions() {
    return this.editorContributions.slice(0);
  }
  getDiffEditorContributions() {
    return this.diffEditorContributions.slice(0);
  }
  registerEditorAction(e) {
    e.register(), this.editorActions.push(e);
  }
  getEditorActions() {
    return this.editorActions.slice(0);
  }
  registerEditorCommand(e) {
    e.register(), this.editorCommands[e.id] = e;
  }
  getEditorCommand(e) {
    return this.editorCommands[e] || null;
  }
}
gs.INSTANCE = new gs();
Zn.add(Fae.EditorCommonContributions, gs.INSTANCE);
function U_(n) {
  return n.register(), n;
}
const z5 = U_(new GN({
  id: "undo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2104
    /* KEY_Z */
  },
  menuOpts: [{
    menuId: si.MenubarEditMenu,
    group: "1_do",
    title: w({ key: "miUndo", comment: ["&& denotes a mnemonic"] }, "&&Undo"),
    order: 1
  }, {
    menuId: si.CommandPalette,
    group: "",
    title: w("undo", "Undo"),
    order: 1
  }]
}));
U_(new H5(z5, { id: "default:undo", precondition: void 0 }));
const j5 = U_(new GN({
  id: "redo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2103,
    secondary: [
      3128
      /* KEY_Z */
    ],
    mac: {
      primary: 3128
      /* KEY_Z */
    }
  },
  menuOpts: [{
    menuId: si.MenubarEditMenu,
    group: "1_do",
    title: w({ key: "miRedo", comment: ["&& denotes a mnemonic"] }, "&&Redo"),
    order: 2
  }, {
    menuId: si.CommandPalette,
    group: "",
    title: w("redo", "Redo"),
    order: 1
  }]
}));
U_(new H5(j5, { id: "default:redo", precondition: void 0 }));
const kae = U_(new GN({
  id: "editor.action.selectAll",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    kbExpr: null,
    primary: 2079
    /* KEY_A */
  },
  menuOpts: [{
    menuId: si.MenubarSelectionMenu,
    group: "1_basic",
    title: w({ key: "miSelectAll", comment: ["&& denotes a mnemonic"] }, "&&Select All"),
    order: 1
  }, {
    menuId: si.CommandPalette,
    group: "",
    title: w("selectAll", "Select All"),
    order: 1
  }]
}));
var Wae = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Vae = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let Xv = class {
  constructor(e, t) {
  }
  dispose() {
  }
};
Xv.ID = "editor.contrib.markerDecorations";
Xv = Wae([
  Vae(1, A5)
], Xv);
U5(Xv.ID, Xv);
class Bae {
  constructor(e, t) {
    this.chr = e, this.type = t, this.width = 0;
  }
  fulfill(e) {
    this.width = e;
  }
}
class UN {
  constructor(e, t) {
    this._bareFontInfo = e, this._requests = t, this._container = null, this._testElements = null;
  }
  read() {
    this._createDomElements(), document.body.appendChild(this._container), this._readFromDomElements(), document.body.removeChild(this._container), this._container = null, this._testElements = null;
  }
  _createDomElements() {
    const e = document.createElement("div");
    e.style.position = "absolute", e.style.top = "-50000px", e.style.width = "50000px";
    const t = document.createElement("div");
    t.style.fontFamily = this._bareFontInfo.getMassagedFontFamily(), t.style.fontWeight = this._bareFontInfo.fontWeight, t.style.fontSize = this._bareFontInfo.fontSize + "px", t.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings, t.style.lineHeight = this._bareFontInfo.lineHeight + "px", t.style.letterSpacing = this._bareFontInfo.letterSpacing + "px", e.appendChild(t);
    const i = document.createElement("div");
    i.style.fontFamily = this._bareFontInfo.getMassagedFontFamily(), i.style.fontWeight = "bold", i.style.fontSize = this._bareFontInfo.fontSize + "px", i.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings, i.style.lineHeight = this._bareFontInfo.lineHeight + "px", i.style.letterSpacing = this._bareFontInfo.letterSpacing + "px", e.appendChild(i);
    const r = document.createElement("div");
    r.style.fontFamily = this._bareFontInfo.getMassagedFontFamily(), r.style.fontWeight = this._bareFontInfo.fontWeight, r.style.fontSize = this._bareFontInfo.fontSize + "px", r.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings, r.style.lineHeight = this._bareFontInfo.lineHeight + "px", r.style.letterSpacing = this._bareFontInfo.letterSpacing + "px", r.style.fontStyle = "italic", e.appendChild(r);
    const o = [];
    for (const s of this._requests) {
      let a;
      s.type === 0 && (a = t), s.type === 2 && (a = i), s.type === 1 && (a = r), a.appendChild(document.createElement("br"));
      const l = document.createElement("span");
      UN._render(l, s), a.appendChild(l), o.push(l);
    }
    this._container = e, this._testElements = o;
  }
  static _render(e, t) {
    if (t.chr === " ") {
      let i = "";
      for (let r = 0; r < 8; r++)
        i += i;
      e.innerText = i;
    } else {
      let i = t.chr;
      for (let r = 0; r < 8; r++)
        i += i;
      e.textContent = i;
    }
  }
  _readFromDomElements() {
    for (let e = 0, t = this._requests.length; e < t; e++) {
      const i = this._requests[e], r = this._testElements[e];
      i.fulfill(r.offsetWidth / 256);
    }
  }
}
function Hae(n, e) {
  new UN(n, e).read();
}
class $5 extends ge {
  constructor(e, t, i) {
    super(), this.referenceDomElement = e, this.changeCallback = i, this.width = -1, this.height = -1, this.resizeObserver = null, this.measureReferenceDomElementToken = -1, this.measureReferenceDomElement(!1, t);
  }
  dispose() {
    this.stopObserving(), super.dispose();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  startObserving() {
    typeof ResizeObserver < "u" ? !this.resizeObserver && this.referenceDomElement && (this.resizeObserver = new ResizeObserver((e) => {
      e && e[0] && e[0].contentRect ? this.observe({ width: e[0].contentRect.width, height: e[0].contentRect.height }) : this.observe();
    }), this.resizeObserver.observe(this.referenceDomElement)) : this.measureReferenceDomElementToken === -1 && (this.measureReferenceDomElementToken = setInterval(() => this.observe(), 100));
  }
  stopObserving() {
    this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null), this.measureReferenceDomElementToken !== -1 && (clearInterval(this.measureReferenceDomElementToken), this.measureReferenceDomElementToken = -1);
  }
  observe(e) {
    this.measureReferenceDomElement(!0, e);
  }
  measureReferenceDomElement(e, t) {
    let i = 0, r = 0;
    t ? (i = t.width, r = t.height) : this.referenceDomElement && (i = this.referenceDomElement.clientWidth, r = this.referenceDomElement.clientHeight), i = Math.max(5, i), r = Math.max(5, r), (this.width !== i || this.height !== r) && (this.width = i, this.height = r, e && this.changeCallback());
  }
}
class Ak {
  constructor() {
    this._keys = /* @__PURE__ */ Object.create(null), this._values = /* @__PURE__ */ Object.create(null);
  }
  has(e) {
    const t = e.getId();
    return !!this._values[t];
  }
  get(e) {
    const t = e.getId();
    return this._values[t];
  }
  put(e, t) {
    const i = e.getId();
    this._keys[i] = e, this._values[i] = t;
  }
  remove(e) {
    const t = e.getId();
    delete this._keys[t], delete this._values[t];
  }
  getValues() {
    return Object.keys(this._keys).map((e) => this._values[e]);
  }
}
function Gae() {
  Pd.INSTANCE.clearCache();
}
class Pd extends ge {
  constructor() {
    super(), this._onDidChange = this._register(new j()), this.onDidChange = this._onDidChange.event, this._cache = new Ak(), this._evictUntrustedReadingsTimeout = -1;
  }
  dispose() {
    this._evictUntrustedReadingsTimeout !== -1 && (clearTimeout(this._evictUntrustedReadingsTimeout), this._evictUntrustedReadingsTimeout = -1), super.dispose();
  }
  clearCache() {
    this._cache = new Ak(), this._onDidChange.fire();
  }
  _writeToCache(e, t) {
    this._cache.put(e, t), !t.isTrusted && this._evictUntrustedReadingsTimeout === -1 && (this._evictUntrustedReadingsTimeout = setTimeout(() => {
      this._evictUntrustedReadingsTimeout = -1, this._evictUntrustedReadings();
    }, 5e3));
  }
  _evictUntrustedReadings() {
    const e = this._cache.getValues();
    let t = !1;
    for (const i of e)
      i.isTrusted || (t = !0, this._cache.remove(i));
    t && this._onDidChange.fire();
  }
  readConfiguration(e) {
    if (!this._cache.has(e)) {
      let t = Pd._actualReadConfiguration(e);
      (t.typicalHalfwidthCharacterWidth <= 2 || t.typicalFullwidthCharacterWidth <= 2 || t.spaceWidth <= 2 || t.maxDigitWidth <= 2) && (t = new iT({
        zoomLevel: HR(),
        pixelRatio: nb(),
        fontFamily: t.fontFamily,
        fontWeight: t.fontWeight,
        fontSize: t.fontSize,
        fontFeatureSettings: t.fontFeatureSettings,
        lineHeight: t.lineHeight,
        letterSpacing: t.letterSpacing,
        isMonospace: t.isMonospace,
        typicalHalfwidthCharacterWidth: Math.max(t.typicalHalfwidthCharacterWidth, 5),
        typicalFullwidthCharacterWidth: Math.max(t.typicalFullwidthCharacterWidth, 5),
        canUseHalfwidthRightwardsArrow: t.canUseHalfwidthRightwardsArrow,
        spaceWidth: Math.max(t.spaceWidth, 5),
        middotWidth: Math.max(t.middotWidth, 5),
        wsmiddotWidth: Math.max(t.wsmiddotWidth, 5),
        maxDigitWidth: Math.max(t.maxDigitWidth, 5)
      }, !1)), this._writeToCache(e, t);
    }
    return this._cache.get(e);
  }
  static createRequest(e, t, i, r) {
    const o = new Bae(e, t);
    return i.push(o), r && r.push(o), o;
  }
  static _actualReadConfiguration(e) {
    const t = [], i = [], r = this.createRequest("n", 0, t, i), o = this.createRequest("", 0, t, null), s = this.createRequest(" ", 0, t, i), a = this.createRequest("0", 0, t, i), l = this.createRequest("1", 0, t, i), u = this.createRequest("2", 0, t, i), c = this.createRequest("3", 0, t, i), h = this.createRequest("4", 0, t, i), d = this.createRequest("5", 0, t, i), f = this.createRequest("6", 0, t, i), p = this.createRequest("7", 0, t, i), g = this.createRequest("8", 0, t, i), _ = this.createRequest("9", 0, t, i), m = this.createRequest("", 0, t, i), v = this.createRequest("", 0, t, null), C = this.createRequest("", 0, t, i), y = this.createRequest(String.fromCharCode(11825), 0, t, null);
    this.createRequest("|", 0, t, i), this.createRequest("/", 0, t, i), this.createRequest("-", 0, t, i), this.createRequest("_", 0, t, i), this.createRequest("i", 0, t, i), this.createRequest("l", 0, t, i), this.createRequest("m", 0, t, i), this.createRequest("|", 1, t, i), this.createRequest("_", 1, t, i), this.createRequest("i", 1, t, i), this.createRequest("l", 1, t, i), this.createRequest("m", 1, t, i), this.createRequest("n", 1, t, i), this.createRequest("|", 2, t, i), this.createRequest("_", 2, t, i), this.createRequest("i", 2, t, i), this.createRequest("l", 2, t, i), this.createRequest("m", 2, t, i), this.createRequest("n", 2, t, i), Hae(e, t);
    const b = Math.max(a.width, l.width, u.width, c.width, h.width, d.width, f.width, p.width, g.width, _.width);
    let L = e.fontFeatureSettings === fs.OFF;
    const S = i[0].width;
    for (let O = 1, T = i.length; L && O < T; O++) {
      const A = S - i[O].width;
      if (A < -1e-3 || A > 1e-3) {
        L = !1;
        break;
      }
    }
    let E = !0;
    L && v.width !== S && (E = !1), v.width > m.width && (E = !1);
    const D = vne() > 2e3;
    return new iT({
      zoomLevel: HR(),
      pixelRatio: nb(),
      fontFamily: e.fontFamily,
      fontWeight: e.fontWeight,
      fontSize: e.fontSize,
      fontFeatureSettings: e.fontFeatureSettings,
      lineHeight: e.lineHeight,
      letterSpacing: e.letterSpacing,
      isMonospace: L,
      typicalHalfwidthCharacterWidth: r.width,
      typicalFullwidthCharacterWidth: o.width,
      canUseHalfwidthRightwardsArrow: E,
      spaceWidth: s.width,
      middotWidth: C.width,
      wsmiddotWidth: y.width,
      maxDigitWidth: b
    }, D);
  }
}
Pd.INSTANCE = new Pd();
class io extends yb {
  constructor(e, t, i = null, r) {
    super(e, t), this.accessibilityService = r, this._elementSizeObserver = this._register(new $5(i, t.dimension, () => this._recomputeOptions())), this._register(Pd.INSTANCE.onDidChange(() => this._recomputeOptions())), this._validatedOptions.get(
      10
      /* automaticLayout */
    ) && this._elementSizeObserver.startObserving(), this._register(_ne((o) => this._recomputeOptions())), this._register(this.accessibilityService.onDidChangeScreenReaderOptimized(() => this._recomputeOptions())), this._recomputeOptions();
  }
  static applyFontInfoSlow(e, t) {
    e.style.fontFamily = t.getMassagedFontFamily(), e.style.fontWeight = t.fontWeight, e.style.fontSize = t.fontSize + "px", e.style.fontFeatureSettings = t.fontFeatureSettings, e.style.lineHeight = t.lineHeight + "px", e.style.letterSpacing = t.letterSpacing + "px";
  }
  static applyFontInfo(e, t) {
    e.setFontFamily(t.getMassagedFontFamily()), e.setFontWeight(t.fontWeight), e.setFontSize(t.fontSize), e.setFontFeatureSettings(t.fontFeatureSettings), e.setLineHeight(t.lineHeight), e.setLetterSpacing(t.letterSpacing);
  }
  observeReferenceElement(e) {
    this._elementSizeObserver.observe(e);
  }
  updatePixelRatio() {
    this._recomputeOptions();
  }
  static _getExtraEditorClassName() {
    let e = "";
    return !Td && !yne && (e += "no-user-select "), Td && (e += "no-minimap-shadow "), Ft && (e += "mac "), e;
  }
  _getEnvConfiguration() {
    return {
      extraEditorClassName: io._getExtraEditorClassName(),
      outerWidth: this._elementSizeObserver.getWidth(),
      outerHeight: this._elementSizeObserver.getHeight(),
      emptySelectionClipboard: hd || Qr,
      pixelRatio: nb(),
      zoomLevel: HR(),
      accessibilitySupport: this.accessibilityService.isScreenReaderOptimized() ? 2 : this.accessibilityService.getAccessibilitySupport()
    };
  }
  readConfiguration(e) {
    return Pd.INSTANCE.readConfiguration(e);
  }
}
class K5 {
  constructor(e) {
    this.domNode = e, this._maxWidth = -1, this._width = -1, this._height = -1, this._top = -1, this._left = -1, this._bottom = -1, this._right = -1, this._fontFamily = "", this._fontWeight = "", this._fontSize = -1, this._fontFeatureSettings = "", this._lineHeight = -1, this._letterSpacing = -100, this._className = "", this._display = "", this._position = "", this._visibility = "", this._backgroundColor = "", this._layerHint = !1, this._contain = "none", this._boxShadow = "";
  }
  setMaxWidth(e) {
    this._maxWidth !== e && (this._maxWidth = e, this.domNode.style.maxWidth = this._maxWidth + "px");
  }
  setWidth(e) {
    this._width !== e && (this._width = e, this.domNode.style.width = this._width + "px");
  }
  setHeight(e) {
    this._height !== e && (this._height = e, this.domNode.style.height = this._height + "px");
  }
  setTop(e) {
    this._top !== e && (this._top = e, this.domNode.style.top = this._top + "px");
  }
  unsetTop() {
    this._top !== -1 && (this._top = -1, this.domNode.style.top = "");
  }
  setLeft(e) {
    this._left !== e && (this._left = e, this.domNode.style.left = this._left + "px");
  }
  setBottom(e) {
    this._bottom !== e && (this._bottom = e, this.domNode.style.bottom = this._bottom + "px");
  }
  setRight(e) {
    this._right !== e && (this._right = e, this.domNode.style.right = this._right + "px");
  }
  setFontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this.domNode.style.fontFamily = this._fontFamily);
  }
  setFontWeight(e) {
    this._fontWeight !== e && (this._fontWeight = e, this.domNode.style.fontWeight = this._fontWeight);
  }
  setFontSize(e) {
    this._fontSize !== e && (this._fontSize = e, this.domNode.style.fontSize = this._fontSize + "px");
  }
  setFontFeatureSettings(e) {
    this._fontFeatureSettings !== e && (this._fontFeatureSettings = e, this.domNode.style.fontFeatureSettings = this._fontFeatureSettings);
  }
  setLineHeight(e) {
    this._lineHeight !== e && (this._lineHeight = e, this.domNode.style.lineHeight = this._lineHeight + "px");
  }
  setLetterSpacing(e) {
    this._letterSpacing !== e && (this._letterSpacing = e, this.domNode.style.letterSpacing = this._letterSpacing + "px");
  }
  setClassName(e) {
    this._className !== e && (this._className = e, this.domNode.className = this._className);
  }
  toggleClassName(e, t) {
    this.domNode.classList.toggle(e, t), this._className = this.domNode.className;
  }
  setDisplay(e) {
    this._display !== e && (this._display = e, this.domNode.style.display = this._display);
  }
  setPosition(e) {
    this._position !== e && (this._position = e, this.domNode.style.position = this._position);
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this.domNode.style.visibility = this._visibility);
  }
  setBackgroundColor(e) {
    this._backgroundColor !== e && (this._backgroundColor = e, this.domNode.style.backgroundColor = this._backgroundColor);
  }
  setLayerHinting(e) {
    this._layerHint !== e && (this._layerHint = e, this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "");
  }
  setBoxShadow(e) {
    this._boxShadow !== e && (this._boxShadow = e, this.domNode.style.boxShadow = e);
  }
  setContain(e) {
    this._contain !== e && (this._contain = e, this.domNode.style.contain = this._contain);
  }
  setAttribute(e, t) {
    this.domNode.setAttribute(e, t);
  }
  removeAttribute(e) {
    this.domNode.removeAttribute(e);
  }
  appendChild(e) {
    this.domNode.appendChild(e.domNode);
  }
  removeChild(e) {
    this.domNode.removeChild(e.domNode);
  }
}
function bt(n) {
  return new K5(n);
}
function Wn(n, e, t) {
  let i = null, r = null;
  if (typeof t.value == "function" ? (i = "value", r = t.value, r.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters")) : typeof t.get == "function" && (i = "get", r = t.get), !r)
    throw new Error("not supported");
  const o = `$memoize$${e}`;
  t[i] = function(...s) {
    return this.hasOwnProperty(o) || Object.defineProperty(this, o, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: r.apply(this, s)
    }), this[o];
  };
}
var Uae = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Li;
(function(n) {
  n.Tap = "-monaco-gesturetap", n.Change = "-monaco-gesturechange", n.Start = "-monaco-gesturestart", n.End = "-monaco-gesturesend", n.Contextmenu = "-monaco-gesturecontextmenu";
})(Li || (Li = {}));
class ri extends ge {
  constructor() {
    super(), this.dispatched = !1, this.activeTouches = {}, this.handle = null, this.targets = [], this.ignoreTargets = [], this._lastSetTapCountTime = 0, this._register(ye(document, "touchstart", (e) => this.onTouchStart(e), { passive: !1 })), this._register(ye(document, "touchend", (e) => this.onTouchEnd(e))), this._register(ye(document, "touchmove", (e) => this.onTouchMove(e), { passive: !1 }));
  }
  static addTarget(e) {
    return ri.isTouchDevice() ? (ri.INSTANCE || (ri.INSTANCE = new ri()), ri.INSTANCE.targets.push(e), {
      dispose: () => {
        ri.INSTANCE.targets = ri.INSTANCE.targets.filter((t) => t !== e);
      }
    }) : ge.None;
  }
  static ignoreTarget(e) {
    return ri.isTouchDevice() ? (ri.INSTANCE || (ri.INSTANCE = new ri()), ri.INSTANCE.ignoreTargets.push(e), {
      dispose: () => {
        ri.INSTANCE.ignoreTargets = ri.INSTANCE.ignoreTargets.filter((t) => t !== e);
      }
    }) : ge.None;
  }
  static isTouchDevice() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0;
  }
  dispose() {
    this.handle && (this.handle.dispose(), this.handle = null), super.dispose();
  }
  onTouchStart(e) {
    let t = Date.now();
    this.handle && (this.handle.dispose(), this.handle = null);
    for (let i = 0, r = e.targetTouches.length; i < r; i++) {
      let o = e.targetTouches.item(i);
      this.activeTouches[o.identifier] = {
        id: o.identifier,
        initialTarget: o.target,
        initialTimeStamp: t,
        initialPageX: o.pageX,
        initialPageY: o.pageY,
        rollingTimestamps: [t],
        rollingPageX: [o.pageX],
        rollingPageY: [o.pageY]
      };
      let s = this.newGestureEvent(Li.Start, o.target);
      s.pageX = o.pageX, s.pageY = o.pageY, this.dispatchEvent(s);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
  onTouchEnd(e) {
    let t = Date.now(), i = Object.keys(this.activeTouches).length;
    for (let r = 0, o = e.changedTouches.length; r < o; r++) {
      let s = e.changedTouches.item(r);
      if (!this.activeTouches.hasOwnProperty(String(s.identifier))) {
        console.warn("move of an UNKNOWN touch", s);
        continue;
      }
      let a = this.activeTouches[s.identifier], l = Date.now() - a.initialTimeStamp;
      if (l < ri.HOLD_DELAY && Math.abs(a.initialPageX - ss(a.rollingPageX)) < 30 && Math.abs(a.initialPageY - ss(a.rollingPageY)) < 30) {
        let u = this.newGestureEvent(Li.Tap, a.initialTarget);
        u.pageX = ss(a.rollingPageX), u.pageY = ss(a.rollingPageY), this.dispatchEvent(u);
      } else if (l >= ri.HOLD_DELAY && Math.abs(a.initialPageX - ss(a.rollingPageX)) < 30 && Math.abs(a.initialPageY - ss(a.rollingPageY)) < 30) {
        let u = this.newGestureEvent(Li.Contextmenu, a.initialTarget);
        u.pageX = ss(a.rollingPageX), u.pageY = ss(a.rollingPageY), this.dispatchEvent(u);
      } else if (i === 1) {
        let u = ss(a.rollingPageX), c = ss(a.rollingPageY), h = ss(a.rollingTimestamps) - a.rollingTimestamps[0], d = u - a.rollingPageX[0], f = c - a.rollingPageY[0];
        const p = this.targets.filter((g) => a.initialTarget instanceof Node && g.contains(a.initialTarget));
        this.inertia(
          p,
          t,
          // time now
          Math.abs(d) / h,
          // speed
          d > 0 ? 1 : -1,
          // x direction
          u,
          // x now
          Math.abs(f) / h,
          // y speed
          f > 0 ? 1 : -1,
          // y direction
          c
          // y now
        );
      }
      this.dispatchEvent(this.newGestureEvent(Li.End, a.initialTarget)), delete this.activeTouches[s.identifier];
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
  newGestureEvent(e, t) {
    let i = document.createEvent("CustomEvent");
    return i.initEvent(e, !1, !0), i.initialTarget = t, i.tapCount = 0, i;
  }
  dispatchEvent(e) {
    if (e.type === Li.Tap) {
      const t = (/* @__PURE__ */ new Date()).getTime();
      let i = 0;
      t - this._lastSetTapCountTime > ri.CLEAR_TAP_COUNT_TIME ? i = 1 : i = 2, this._lastSetTapCountTime = t, e.tapCount = i;
    } else
      (e.type === Li.Change || e.type === Li.Contextmenu) && (this._lastSetTapCountTime = 0);
    for (let t = 0; t < this.ignoreTargets.length; t++)
      if (e.initialTarget instanceof Node && this.ignoreTargets[t].contains(e.initialTarget))
        return;
    this.targets.forEach((t) => {
      e.initialTarget instanceof Node && t.contains(e.initialTarget) && (t.dispatchEvent(e), this.dispatched = !0);
    });
  }
  inertia(e, t, i, r, o, s, a, l) {
    this.handle = zl(() => {
      let u = Date.now(), c = u - t, h = 0, d = 0, f = !0;
      i += ri.SCROLL_FRICTION * c, s += ri.SCROLL_FRICTION * c, i > 0 && (f = !1, h = r * i * c), s > 0 && (f = !1, d = a * s * c);
      let p = this.newGestureEvent(Li.Change);
      p.translationX = h, p.translationY = d, e.forEach((g) => g.dispatchEvent(p)), f || this.inertia(e, u, i, r, o + h, s, a, l + d);
    });
  }
  onTouchMove(e) {
    let t = Date.now();
    for (let i = 0, r = e.changedTouches.length; i < r; i++) {
      let o = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(o.identifier))) {
        console.warn("end of an UNKNOWN touch", o);
        continue;
      }
      let s = this.activeTouches[o.identifier], a = this.newGestureEvent(Li.Change, s.initialTarget);
      a.translationX = o.pageX - ss(s.rollingPageX), a.translationY = o.pageY - ss(s.rollingPageY), a.pageX = o.pageX, a.pageY = o.pageY, this.dispatchEvent(a), s.rollingPageX.length > 3 && (s.rollingPageX.shift(), s.rollingPageY.shift(), s.rollingTimestamps.shift()), s.rollingPageX.push(o.pageX), s.rollingPageY.push(o.pageY), s.rollingTimestamps.push(t);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
}
ri.SCROLL_FRICTION = -5e-3;
ri.HOLD_DELAY = 700;
ri.CLEAR_TAP_COUNT_TIME = 400;
Uae([
  Wn
], ri, "isTouchDevice", null);
function zN(n, e) {
  let t = new ca(e);
  return t.preventDefault(), {
    leftButton: t.leftButton,
    buttons: t.buttons,
    posx: t.posx,
    posy: t.posy
  };
}
class m0 {
  constructor() {
    this._hooks = new ht(), this._mouseMoveEventMerger = null, this._mouseMoveCallback = null, this._onStopCallback = null;
  }
  dispose() {
    this.stopMonitoring(!1), this._hooks.dispose();
  }
  stopMonitoring(e, t) {
    if (!this.isMonitoring())
      return;
    this._hooks.clear(), this._mouseMoveEventMerger = null, this._mouseMoveCallback = null;
    const i = this._onStopCallback;
    this._onStopCallback = null, e && i && i(t);
  }
  isMonitoring() {
    return !!this._mouseMoveEventMerger;
  }
  startMonitoring(e, t, i, r, o) {
    if (this.isMonitoring())
      return;
    this._mouseMoveEventMerger = i, this._mouseMoveCallback = r, this._onStopCallback = o;
    const s = zR.getSameOriginWindowChain(), a = _g ? "pointermove" : "mousemove", l = "mouseup", u = s.map((h) => h.window.document), c = k_(e);
    c && u.unshift(c);
    for (const h of u)
      this._hooks.add(hN(h, a, (d) => {
        if (d.buttons !== t) {
          this.stopMonitoring(!0);
          return;
        }
        this._mouseMoveCallback(d);
      }, (d, f) => this._mouseMoveEventMerger(d, f))), this._hooks.add(ye(h, l, (d) => this.stopMonitoring(!0)));
    if (zR.hasDifferentOriginAncestor()) {
      let h = s[s.length - 1];
      this._hooks.add(ye(h.window.document, "mouseout", (d) => {
        new ca(d).target.tagName.toLowerCase() === "html" && this.stopMonitoring(!0);
      })), this._hooks.add(ye(h.window.document, "mouseover", (d) => {
        new ca(d).target.tagName.toLowerCase() === "html" && this.stopMonitoring(!0);
      })), this._hooks.add(ye(h.window.document.body, "mouseleave", (d) => {
        this.stopMonitoring(!0);
      }));
    }
  }
}
class jN {
  constructor(e, t) {
    this.x = e, this.y = t;
  }
  toClientCoordinates() {
    return new q5(this.x - Bu.scrollX, this.y - Bu.scrollY);
  }
}
class q5 {
  constructor(e, t) {
    this.clientX = e, this.clientY = t;
  }
  toPageCoordinates() {
    return new jN(this.clientX + Bu.scrollX, this.clientY + Bu.scrollY);
  }
}
class zae {
  constructor(e, t, i, r) {
    this.x = e, this.y = t, this.width = i, this.height = r;
  }
}
function Y5(n) {
  const e = ja(n);
  return new zae(e.left, e.top, e.width, e.height);
}
class Ad extends ca {
  constructor(e, t) {
    super(e), this.pos = new jN(this.posx, this.posy), this.editorPos = Y5(t);
  }
}
class jae {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new Ad(e, this._editorViewDomNode);
  }
  onContextMenu(e, t) {
    return ye(e, "contextmenu", (i) => {
      t(this._create(i));
    });
  }
  onMouseUp(e, t) {
    return ye(e, "mouseup", (i) => {
      t(this._create(i));
    });
  }
  onMouseDown(e, t) {
    return ye(e, "mousedown", (i) => {
      t(this._create(i));
    });
  }
  onMouseLeave(e, t) {
    return wG(e, (i) => {
      t(this._create(i));
    });
  }
  onMouseMoveThrottled(e, t, i, r) {
    return hN(e, "mousemove", t, (s, a) => i(s, this._create(a)), r);
  }
}
class $ae {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new Ad(e, this._editorViewDomNode);
  }
  onPointerUp(e, t) {
    return ye(e, "pointerup", (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return ye(e, "pointerdown", (i) => {
      t(this._create(i));
    });
  }
  onPointerLeave(e, t) {
    return kne(e, (i) => {
      t(this._create(i));
    });
  }
  onPointerMoveThrottled(e, t, i, r) {
    return hN(e, "pointermove", t, (s, a) => i(s, this._create(a)), r);
  }
}
class Kae extends ge {
  constructor(e) {
    super(), this._editorViewDomNode = e, this._globalMouseMoveMonitor = this._register(new m0()), this._keydownListener = null;
  }
  startMonitoring(e, t, i, r, o) {
    this._keydownListener = Jr(document, "keydown", (a) => {
      a.toKeybinding().isModifierKey() || this._globalMouseMoveMonitor.stopMonitoring(!0, a.browserEvent);
    }, !0);
    const s = (a, l) => i(a, new Ad(l, this._editorViewDomNode));
    this._globalMouseMoveMonitor.startMonitoring(e, t, s, r, (a) => {
      this._keydownListener.dispose(), o(a);
    });
  }
  stopMonitoring() {
    this._globalMouseMoveMonitor.stopMonitoring(!0);
  }
}
class z_ extends ge {
  constructor() {
    super(), this._shouldRender = !0;
  }
  shouldRender() {
    return this._shouldRender;
  }
  forceShouldRender() {
    this._shouldRender = !0;
  }
  setShouldRender() {
    this._shouldRender = !0;
  }
  onDidRender() {
    this._shouldRender = !1;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return !1;
  }
  onCompositionEnd(e) {
    return !1;
  }
  onConfigurationChanged(e) {
    return !1;
  }
  onCursorStateChanged(e) {
    return !1;
  }
  onDecorationsChanged(e) {
    return !1;
  }
  onFlushed(e) {
    return !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  onLanguageConfigurationChanged(e) {
    return !1;
  }
  onLineMappingChanged(e) {
    return !1;
  }
  onLinesChanged(e) {
    return !1;
  }
  onLinesDeleted(e) {
    return !1;
  }
  onLinesInserted(e) {
    return !1;
  }
  onRevealRangeRequest(e) {
    return !1;
  }
  onScrollChanged(e) {
    return !1;
  }
  onThemeChanged(e) {
    return !1;
  }
  onTokensChanged(e) {
    return !1;
  }
  onTokensColorsChanged(e) {
    return !1;
  }
  onZonesChanged(e) {
    return !1;
  }
  // --- end event handlers
  handleEvents(e) {
    let t = !1;
    for (let i = 0, r = e.length; i < r; i++) {
      let o = e[i];
      switch (o.type) {
        case 0:
          this.onCompositionStart(o) && (t = !0);
          break;
        case 1:
          this.onCompositionEnd(o) && (t = !0);
          break;
        case 2:
          this.onConfigurationChanged(o) && (t = !0);
          break;
        case 3:
          this.onCursorStateChanged(o) && (t = !0);
          break;
        case 4:
          this.onDecorationsChanged(o) && (t = !0);
          break;
        case 5:
          this.onFlushed(o) && (t = !0);
          break;
        case 6:
          this.onFocusChanged(o) && (t = !0);
          break;
        case 7:
          this.onLanguageConfigurationChanged(o) && (t = !0);
          break;
        case 8:
          this.onLineMappingChanged(o) && (t = !0);
          break;
        case 9:
          this.onLinesChanged(o) && (t = !0);
          break;
        case 10:
          this.onLinesDeleted(o) && (t = !0);
          break;
        case 11:
          this.onLinesInserted(o) && (t = !0);
          break;
        case 12:
          this.onRevealRangeRequest(o) && (t = !0);
          break;
        case 13:
          this.onScrollChanged(o) && (t = !0);
          break;
        case 15:
          this.onTokensChanged(o) && (t = !0);
          break;
        case 14:
          this.onThemeChanged(o) && (t = !0);
          break;
        case 16:
          this.onTokensColorsChanged(o) && (t = !0);
          break;
        case 17:
          this.onZonesChanged(o) && (t = !0);
          break;
        default:
          console.info("View received unknown event: "), console.info(o);
      }
    }
    t && (this._shouldRender = !0);
  }
}
class Ns extends z_ {
  constructor(e) {
    super(), this._context = e, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
}
class jl {
  static write(e, t) {
    e instanceof K5, e.setAttribute("data-mprt", String(t));
  }
  static read(e) {
    const t = e.getAttribute("data-mprt");
    return t === null ? 0 : parseInt(t, 10);
  }
  static collect(e, t) {
    let i = [], r = 0;
    for (; e && e !== document.body && e !== t; )
      e.nodeType === e.ELEMENT_NODE && (i[r++] = this.read(e)), e = e.parentElement;
    const o = new Uint8Array(r);
    for (let s = 0; s < r; s++)
      o[s] = i[r - s - 1];
    return o;
  }
}
class qae {
  constructor(e, t) {
    this._viewLayout = e, this.viewportData = t, this.scrollWidth = this._viewLayout.getScrollWidth(), this.scrollHeight = this._viewLayout.getScrollHeight(), this.visibleRange = this.viewportData.visibleRange, this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
    const i = this._viewLayout.getCurrentViewport();
    this.scrollTop = i.top, this.scrollLeft = i.left, this.viewportWidth = i.width, this.viewportHeight = i.height;
  }
  getScrolledTopFromAbsoluteTop(e) {
    return e - this.scrollTop;
  }
  getVerticalOffsetForLineNumber(e) {
    return this._viewLayout.getVerticalOffsetForLineNumber(e);
  }
  getDecorationsInViewport() {
    return this.viewportData.getDecorationsInViewport();
  }
}
class Yae extends qae {
  constructor(e, t, i) {
    super(e, t), this._viewLines = i;
  }
  linesVisibleRangesForRange(e, t) {
    return this._viewLines.linesVisibleRangesForRange(e, t);
  }
  visibleRangeForPosition(e) {
    return this._viewLines.visibleRangeForPosition(e);
  }
}
class Xae {
  constructor(e, t, i) {
    this.outsideRenderedLine = e, this.lineNumber = t, this.ranges = i;
  }
}
class Yc {
  constructor(e, t) {
    this.left = Math.round(e), this.width = Math.round(t);
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
}
class Zae {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.left = Math.round(t);
  }
}
class Qae {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.ranges = t;
  }
}
class Mk {
  constructor(e, t) {
    this.left = e, this.width = t;
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
  static compare(e, t) {
    return e.left - t.left;
  }
}
class pD {
  static _createRange() {
    return this._handyReadyRange || (this._handyReadyRange = document.createRange()), this._handyReadyRange;
  }
  static _detachRange(e, t) {
    e.selectNodeContents(t);
  }
  static _readClientRects(e, t, i, r, o) {
    const s = this._createRange();
    try {
      return s.setStart(e, t), s.setEnd(i, r), s.getClientRects();
    } catch {
      return null;
    } finally {
      this._detachRange(s, o);
    }
  }
  static _mergeAdjacentRanges(e) {
    if (e.length === 1)
      return [new Yc(e[0].left, e[0].width)];
    e.sort(Mk.compare);
    let t = [], i = 0, r = e[0].left, o = e[0].width;
    for (let s = 1, a = e.length; s < a; s++) {
      const l = e[s], u = l.left, c = l.width;
      r + o + 0.9 >= u ? o = Math.max(o, u + c - r) : (t[i++] = new Yc(r, o), r = u, o = c);
    }
    return t[i++] = new Yc(r, o), t;
  }
  static _createHorizontalRangesFromClientRects(e, t) {
    if (!e || e.length === 0)
      return null;
    const i = [];
    for (let r = 0, o = e.length; r < o; r++) {
      const s = e[r];
      i[r] = new Mk(Math.max(0, s.left - t), s.width);
    }
    return this._mergeAdjacentRanges(i);
  }
  static readHorizontalRanges(e, t, i, r, o, s, a) {
    const u = e.children.length - 1;
    if (0 > u)
      return null;
    if (t = Math.min(u, Math.max(0, t)), r = Math.min(u, Math.max(0, r)), t === r && i === o && i === 0 && !e.children[t].firstChild) {
      const f = e.children[t].getClientRects();
      return this._createHorizontalRangesFromClientRects(f, s);
    }
    t !== r && r > 0 && o === 0 && (r--, o = 1073741824);
    let c = e.children[t].firstChild, h = e.children[r].firstChild;
    if ((!c || !h) && (!c && i === 0 && t > 0 && (c = e.children[t - 1].firstChild, i = 1073741824), !h && o === 0 && r > 0 && (h = e.children[r - 1].firstChild, o = 1073741824)), !c || !h)
      return null;
    i = Math.min(c.textContent.length, Math.max(0, i)), o = Math.min(h.textContent.length, Math.max(0, o));
    const d = this._readClientRects(c, i, h, o, a);
    return this._createHorizontalRangesFromClientRects(d, s);
  }
}
const Jae = function() {
  return iv ? !0 : !(Rs || Qr || Td);
}();
let Cp = !0;
class Fk {
  constructor(e, t) {
    this._domNode = e, this._clientRectDeltaLeft = 0, this._clientRectDeltaLeftRead = !1, this.endNode = t;
  }
  get clientRectDeltaLeft() {
    return this._clientRectDeltaLeftRead || (this._clientRectDeltaLeftRead = !0, this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left), this._clientRectDeltaLeft;
  }
}
class kk {
  constructor(e, t) {
    this.themeType = t;
    const i = e.options, r = i.get(
      40
      /* fontInfo */
    );
    this.renderWhitespace = i.get(
      86
      /* renderWhitespace */
    ), this.renderControlCharacters = i.get(
      80
      /* renderControlCharacters */
    ), this.spaceWidth = r.spaceWidth, this.middotWidth = r.middotWidth, this.wsmiddotWidth = r.wsmiddotWidth, this.useMonospaceOptimizations = r.isMonospace && !i.get(
      27
      /* disableMonospaceOptimizations */
    ), this.canUseHalfwidthRightwardsArrow = r.canUseHalfwidthRightwardsArrow, this.lineHeight = i.get(
      56
      /* lineHeight */
    ), this.stopRenderingLineAfter = i.get(
      103
      /* stopRenderingLineAfter */
    ), this.fontLigatures = i.get(
      41
      /* fontLigatures */
    );
  }
  equals(e) {
    return this.themeType === e.themeType && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.fontLigatures === e.fontLigatures;
  }
}
class Il {
  constructor(e) {
    this._options = e, this._isMaybeInvalid = !0, this._renderedViewLine = null;
  }
  // --- begin IVisibleLineData
  getDomNode() {
    return this._renderedViewLine && this._renderedViewLine.domNode ? this._renderedViewLine.domNode.domNode : null;
  }
  setDomNode(e) {
    if (this._renderedViewLine)
      this._renderedViewLine.domNode = bt(e);
    else
      throw new Error("I have no rendered view line to set the dom node to...");
  }
  onContentChanged() {
    this._isMaybeInvalid = !0;
  }
  onTokensChanged() {
    this._isMaybeInvalid = !0;
  }
  onDecorationsChanged() {
    this._isMaybeInvalid = !0;
  }
  onOptionsChanged(e) {
    this._isMaybeInvalid = !0, this._options = e;
  }
  onSelectionChanged() {
    return this._options.themeType === Vl.HIGH_CONTRAST || this._options.renderWhitespace === "selection" ? (this._isMaybeInvalid = !0, !0) : !1;
  }
  renderLine(e, t, i, r) {
    if (this._isMaybeInvalid === !1)
      return !1;
    this._isMaybeInvalid = !1;
    const o = i.getViewLineRenderingData(e), s = this._options, a = ha.filter(o.inlineDecorations, e, o.minColumn, o.maxColumn);
    let l = null;
    if (s.themeType === Vl.HIGH_CONTRAST || this._options.renderWhitespace === "selection") {
      const d = i.selections;
      for (const f of d) {
        if (f.endLineNumber < e || f.startLineNumber > e)
          continue;
        const p = f.startLineNumber === e ? f.startColumn : o.minColumn, g = f.endLineNumber === e ? f.endColumn : o.maxColumn;
        p < g && (s.themeType === Vl.HIGH_CONTRAST || this._options.renderWhitespace !== "selection" ? a.push(new ha(
          p,
          g,
          "inline-selected-text",
          0
          /* Regular */
        )) : (l || (l = []), l.push(new gse(p - 1, g - 1))));
      }
    }
    const u = new Sg(s.useMonospaceOptimizations, s.canUseHalfwidthRightwardsArrow, o.content, o.continuesWithWrappedLine, o.isBasicASCII, o.containsRTL, o.minColumn - 1, o.tokens, a, o.tabSize, o.startVisibleColumn, s.spaceWidth, s.middotWidth, s.wsmiddotWidth, s.stopRenderingLineAfter, s.renderWhitespace, s.renderControlCharacters, s.fontLigatures !== fs.OFF, l);
    if (this._renderedViewLine && this._renderedViewLine.input.equals(u))
      return !1;
    r.appendASCIIString('<div style="top:'), r.appendASCIIString(String(t)), r.appendASCIIString("px;height:"), r.appendASCIIString(String(this._options.lineHeight)), r.appendASCIIString('px;" class="'), r.appendASCIIString(Il.CLASS_NAME), r.appendASCIIString('">');
    const c = PN(u, r);
    r.appendASCIIString("</div>");
    let h = null;
    return Cp && Jae && o.isBasicASCII && s.useMonospaceOptimizations && c.containsForeignElements === 0 && o.content.length < 300 && u.lineTokens.getCount() < 100 && (h = new py(this._renderedViewLine ? this._renderedViewLine.domNode : null, u, c.characterMapping)), h || (h = Z5(this._renderedViewLine ? this._renderedViewLine.domNode : null, u, c.characterMapping, c.containsRTL, c.containsForeignElements)), this._renderedViewLine = h, !0;
  }
  layoutLine(e, t) {
    this._renderedViewLine && this._renderedViewLine.domNode && (this._renderedViewLine.domNode.setTop(t), this._renderedViewLine.domNode.setHeight(this._options.lineHeight));
  }
  // --- end IVisibleLineData
  getWidth() {
    return this._renderedViewLine ? this._renderedViewLine.getWidth() : 0;
  }
  getWidthIsFast() {
    return this._renderedViewLine ? this._renderedViewLine.getWidthIsFast() : !0;
  }
  needsMonospaceFontCheck() {
    return this._renderedViewLine ? this._renderedViewLine instanceof py : !1;
  }
  monospaceAssumptionsAreValid() {
    return this._renderedViewLine && this._renderedViewLine instanceof py ? this._renderedViewLine.monospaceAssumptionsAreValid() : Cp;
  }
  onMonospaceAssumptionsInvalidated() {
    this._renderedViewLine && this._renderedViewLine instanceof py && (this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine());
  }
  getVisibleRangesForRange(e, t, i) {
    if (!this._renderedViewLine)
      return null;
    e = e | 0, t = t | 0, e = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, e)), t = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, t));
    const r = this._renderedViewLine.input.stopRenderingLineAfter | 0;
    let o = !1;
    r !== -1 && e > r + 1 && t > r + 1 && (o = !0), r !== -1 && e > r + 1 && (e = r + 1), r !== -1 && t > r + 1 && (t = r + 1);
    const s = this._renderedViewLine.getVisibleRangesForRange(e, t, i);
    return s && s.length > 0 ? new Qae(o, s) : null;
  }
  getColumnOfNodeOffset(e, t, i) {
    return this._renderedViewLine ? this._renderedViewLine.getColumnOfNodeOffset(e, t, i) : 1;
  }
}
Il.CLASS_NAME = "view-line";
class py {
  constructor(e, t, i) {
    this.domNode = e, this.input = t, this._characterMapping = i, this._charWidth = t.spaceWidth;
  }
  getWidth() {
    return this._getCharPosition(this._characterMapping.length);
  }
  getWidthIsFast() {
    return !0;
  }
  monospaceAssumptionsAreValid() {
    if (!this.domNode)
      return Cp;
    const e = this.getWidth(), t = this.domNode.domNode.firstChild.offsetWidth;
    return Math.abs(e - t) >= 2 && (console.warn("monospace assumptions have been violated, therefore disabling monospace optimizations!"), Cp = !1), Cp;
  }
  toSlowRenderedLine() {
    return Z5(
      this.domNode,
      this.input,
      this._characterMapping,
      !1,
      0
      /* None */
    );
  }
  getVisibleRangesForRange(e, t, i) {
    const r = this._getCharPosition(e), o = this._getCharPosition(t);
    return [new Yc(r, o - r)];
  }
  _getCharPosition(e) {
    const t = this._characterMapping.getAbsoluteOffsets();
    return t.length === 0 ? 0 : Math.round(this._charWidth * t[e - 1]);
  }
  getColumnOfNodeOffset(e, t, i) {
    const r = t.textContent.length;
    let o = -1;
    for (; t; )
      t = t.previousSibling, o++;
    return this._characterMapping.partDataToCharOffset(o, r, i) + 1;
  }
}
class X5 {
  constructor(e, t, i, r, o) {
    if (this.domNode = e, this.input = t, this._characterMapping = i, this._isWhitespaceOnly = /^\s*$/.test(t.lineContent), this._containsForeignElements = o, this._cachedWidth = -1, this._pixelOffsetCache = null, !r || this._characterMapping.length === 0) {
      this._pixelOffsetCache = new Int32Array(Math.max(2, this._characterMapping.length + 1));
      for (let s = 0, a = this._characterMapping.length; s <= a; s++)
        this._pixelOffsetCache[s] = -1;
    }
  }
  // --- Reading from the DOM methods
  _getReadingTarget(e) {
    return e.domNode.firstChild;
  }
  /**
   * Width of the line in pixels
   */
  getWidth() {
    return this.domNode ? (this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth), this._cachedWidth) : 0;
  }
  getWidthIsFast() {
    return this._cachedWidth !== -1;
  }
  /**
   * Visible ranges for a model range
   */
  getVisibleRangesForRange(e, t, i) {
    if (!this.domNode)
      return null;
    if (this._pixelOffsetCache !== null) {
      const r = this._readPixelOffset(this.domNode, e, i);
      if (r === -1)
        return null;
      const o = this._readPixelOffset(this.domNode, t, i);
      return o === -1 ? null : [new Yc(r, o - r)];
    }
    return this._readVisibleRangesForRange(this.domNode, e, t, i);
  }
  _readVisibleRangesForRange(e, t, i, r) {
    if (t === i) {
      const o = this._readPixelOffset(e, t, r);
      return o === -1 ? null : [new Yc(o, 0)];
    } else
      return this._readRawVisibleRangesForRange(e, t, i, r);
  }
  _readPixelOffset(e, t, i) {
    if (this._characterMapping.length === 0) {
      if (this._containsForeignElements === 0 || this._containsForeignElements === 2)
        return 0;
      if (this._containsForeignElements === 1)
        return this.getWidth();
      const r = this._getReadingTarget(e);
      return r.firstChild ? r.firstChild.offsetWidth : 0;
    }
    if (this._pixelOffsetCache !== null) {
      const r = this._pixelOffsetCache[t];
      if (r !== -1)
        return r;
      const o = this._actualReadPixelOffset(e, t, i);
      return this._pixelOffsetCache[t] = o, o;
    }
    return this._actualReadPixelOffset(e, t, i);
  }
  _actualReadPixelOffset(e, t, i) {
    if (this._characterMapping.length === 0) {
      const u = pD.readHorizontalRanges(this._getReadingTarget(e), 0, 0, 0, 0, i.clientRectDeltaLeft, i.endNode);
      return !u || u.length === 0 ? -1 : u[0].left;
    }
    if (t === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0)
      return this.getWidth();
    const r = this._characterMapping.charOffsetToPartData(t - 1), o = Wo.getPartIndex(r), s = Wo.getCharIndex(r), a = pD.readHorizontalRanges(this._getReadingTarget(e), o, s, o, s, i.clientRectDeltaLeft, i.endNode);
    if (!a || a.length === 0)
      return -1;
    const l = a[0].left;
    if (this.input.isBasicASCII) {
      const u = this._characterMapping.getAbsoluteOffsets(), c = Math.round(this.input.spaceWidth * u[t - 1]);
      if (Math.abs(c - l) <= 1)
        return c;
    }
    return l;
  }
  _readRawVisibleRangesForRange(e, t, i, r) {
    if (t === 1 && i === this._characterMapping.length)
      return [new Yc(0, this.getWidth())];
    const o = this._characterMapping.charOffsetToPartData(t - 1), s = Wo.getPartIndex(o), a = Wo.getCharIndex(o), l = this._characterMapping.charOffsetToPartData(i - 1), u = Wo.getPartIndex(l), c = Wo.getCharIndex(l);
    return pD.readHorizontalRanges(this._getReadingTarget(e), s, a, u, c, r.clientRectDeltaLeft, r.endNode);
  }
  /**
   * Returns the column for the text found at a specific offset inside a rendered dom node
   */
  getColumnOfNodeOffset(e, t, i) {
    const r = t.textContent.length;
    let o = -1;
    for (; t; )
      t = t.previousSibling, o++;
    return this._characterMapping.partDataToCharOffset(o, r, i) + 1;
  }
}
class ele extends X5 {
  _readVisibleRangesForRange(e, t, i, r) {
    const o = super._readVisibleRangesForRange(e, t, i, r);
    if (!o || o.length === 0 || t === i || t === 1 && i === this._characterMapping.length)
      return o;
    if (!this.input.containsRTL) {
      const s = this._readPixelOffset(e, i, r);
      if (s !== -1) {
        const a = o[o.length - 1];
        a.left < s && (a.width = s - a.left);
      }
    }
    return o;
  }
}
const Z5 = function() {
  return hd ? tle : ile;
}();
function tle(n, e, t, i, r) {
  return new ele(n, e, t, i, r);
}
function ile(n, e, t, i, r) {
  return new X5(n, e, t, i, r);
}
function gy(n) {
  return n.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
}
class zn {
  constructor(e, t, i, r) {
    this.oldPosition = e, this.oldText = t, this.newPosition = i, this.newText = r;
  }
  get oldLength() {
    return this.oldText.length;
  }
  get oldEnd() {
    return this.oldPosition + this.oldText.length;
  }
  get newLength() {
    return this.newText.length;
  }
  get newEnd() {
    return this.newPosition + this.newText.length;
  }
  toString() {
    return this.oldText.length === 0 ? `(insert@${this.oldPosition} "${gy(this.newText)}")` : this.newText.length === 0 ? `(delete@${this.oldPosition} "${gy(this.oldText)}")` : `(replace@${this.oldPosition} "${gy(this.oldText)}" with "${gy(this.newText)}")`;
  }
  static _writeStringSize(e) {
    return 4 + 2 * e.length;
  }
  static _writeString(e, t, i) {
    const r = t.length;
    Ia(e, r, i), i += 4;
    for (let o = 0; o < r; o++)
      yre(e, t.charCodeAt(o), i), i += 2;
    return i;
  }
  static _readString(e, t) {
    const i = Na(e, t);
    return t += 4, mT(e, t, i);
  }
  writeSize() {
    return 4 + 4 + zn._writeStringSize(this.oldText) + zn._writeStringSize(this.newText);
  }
  write(e, t) {
    return Ia(e, this.oldPosition, t), t += 4, Ia(e, this.newPosition, t), t += 4, t = zn._writeString(e, this.oldText, t), t = zn._writeString(e, this.newText, t), t;
  }
  static read(e, t, i) {
    const r = Na(e, t);
    t += 4;
    const o = Na(e, t);
    t += 4;
    const s = zn._readString(e, t);
    t += zn._writeStringSize(s);
    const a = zn._readString(e, t);
    return t += zn._writeStringSize(a), i.push(new zn(r, s, o, a)), t;
  }
}
function nle(n, e) {
  return n === null || n.length === 0 ? e : new Rl(n, e).compress();
}
class Rl {
  constructor(e, t) {
    this._prevEdits = e, this._currEdits = t, this._result = [], this._resultLen = 0, this._prevLen = this._prevEdits.length, this._prevDeltaOffset = 0, this._currLen = this._currEdits.length, this._currDeltaOffset = 0;
  }
  compress() {
    let e = 0, t = 0, i = this._getPrev(e), r = this._getCurr(t);
    for (; e < this._prevLen || t < this._currLen; ) {
      if (i === null) {
        this._acceptCurr(r), r = this._getCurr(++t);
        continue;
      }
      if (r === null) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (r.oldEnd <= i.newPosition) {
        this._acceptCurr(r), r = this._getCurr(++t);
        continue;
      }
      if (i.newEnd <= r.oldPosition) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (r.oldPosition < i.newPosition) {
        const [u, c] = Rl._splitCurr(r, i.newPosition - r.oldPosition);
        this._acceptCurr(u), r = c;
        continue;
      }
      if (i.newPosition < r.oldPosition) {
        const [u, c] = Rl._splitPrev(i, r.oldPosition - i.newPosition);
        this._acceptPrev(u), i = c;
        continue;
      }
      let a, l;
      if (r.oldEnd === i.newEnd)
        a = i, l = r, i = this._getPrev(++e), r = this._getCurr(++t);
      else if (r.oldEnd < i.newEnd) {
        const [u, c] = Rl._splitPrev(i, r.oldLength);
        a = u, l = r, i = c, r = this._getCurr(++t);
      } else {
        const [u, c] = Rl._splitCurr(r, i.newLength);
        a = i, l = u, i = this._getPrev(++e), r = c;
      }
      this._result[this._resultLen++] = new zn(a.oldPosition, a.oldText, l.newPosition, l.newText), this._prevDeltaOffset += a.newLength - a.oldLength, this._currDeltaOffset += l.newLength - l.oldLength;
    }
    const o = Rl._merge(this._result);
    return Rl._removeNoOps(o);
  }
  _acceptCurr(e) {
    this._result[this._resultLen++] = Rl._rebaseCurr(this._prevDeltaOffset, e), this._currDeltaOffset += e.newLength - e.oldLength;
  }
  _getCurr(e) {
    return e < this._currLen ? this._currEdits[e] : null;
  }
  _acceptPrev(e) {
    this._result[this._resultLen++] = Rl._rebasePrev(this._currDeltaOffset, e), this._prevDeltaOffset += e.newLength - e.oldLength;
  }
  _getPrev(e) {
    return e < this._prevLen ? this._prevEdits[e] : null;
  }
  static _rebaseCurr(e, t) {
    return new zn(t.oldPosition - e, t.oldText, t.newPosition, t.newText);
  }
  static _rebasePrev(e, t) {
    return new zn(t.oldPosition, t.oldText, t.newPosition + e, t.newText);
  }
  static _splitPrev(e, t) {
    const i = e.newText.substr(0, t), r = e.newText.substr(t);
    return [
      new zn(e.oldPosition, e.oldText, e.newPosition, i),
      new zn(e.oldEnd, "", e.newPosition + t, r)
    ];
  }
  static _splitCurr(e, t) {
    const i = e.oldText.substr(0, t), r = e.oldText.substr(t);
    return [
      new zn(e.oldPosition, i, e.newPosition, e.newText),
      new zn(e.oldPosition + t, r, e.newEnd, "")
    ];
  }
  static _merge(e) {
    if (e.length === 0)
      return e;
    let t = [], i = 0, r = e[0];
    for (let o = 1; o < e.length; o++) {
      const s = e[o];
      r.oldEnd === s.oldPosition ? r = new zn(r.oldPosition, r.oldText + s.oldText, r.newPosition, r.newText + s.newText) : (t[i++] = r, r = s);
    }
    return t[i++] = r, t;
  }
  static _removeNoOps(e) {
    if (e.length === 0)
      return e;
    let t = [], i = 0;
    for (let r = 0; r < e.length; r++) {
      const o = e[r];
      o.oldText !== o.newText && (t[i++] = o);
    }
    return t;
  }
}
function Tf(n) {
  return n.toString();
}
class En {
  constructor(e, t, i, r, o, s, a) {
    this.beforeVersionId = e, this.afterVersionId = t, this.beforeEOL = i, this.afterEOL = r, this.beforeCursorState = o, this.afterCursorState = s, this.changes = a;
  }
  static create(e, t) {
    const i = e.getAlternativeVersionId(), r = IT(e);
    return new En(i, i, r, r, t, t, []);
  }
  append(e, t, i, r, o) {
    t.length > 0 && (this.changes = nle(this.changes, t)), this.afterEOL = i, this.afterVersionId = r, this.afterCursorState = o;
  }
  static _writeSelectionsSize(e) {
    return 4 + 4 * 4 * (e ? e.length : 0);
  }
  static _writeSelections(e, t, i) {
    if (Ia(e, t ? t.length : 0, i), i += 4, t)
      for (const r of t)
        Ia(e, r.selectionStartLineNumber, i), i += 4, Ia(e, r.selectionStartColumn, i), i += 4, Ia(e, r.positionLineNumber, i), i += 4, Ia(e, r.positionColumn, i), i += 4;
    return i;
  }
  static _readSelections(e, t, i) {
    const r = Na(e, t);
    t += 4;
    for (let o = 0; o < r; o++) {
      const s = Na(e, t);
      t += 4;
      const a = Na(e, t);
      t += 4;
      const l = Na(e, t);
      t += 4;
      const u = Na(e, t);
      t += 4, i.push(new Ut(s, a, l, u));
    }
    return t;
  }
  serialize() {
    let e = 10 + En._writeSelectionsSize(this.beforeCursorState) + En._writeSelectionsSize(this.afterCursorState) + 4;
    for (const r of this.changes)
      e += r.writeSize();
    const t = new Uint8Array(e);
    let i = 0;
    Ia(t, this.beforeVersionId, i), i += 4, Ia(t, this.afterVersionId, i), i += 4, AF(t, this.beforeEOL, i), i += 1, AF(t, this.afterEOL, i), i += 1, i = En._writeSelections(t, this.beforeCursorState, i), i = En._writeSelections(t, this.afterCursorState, i), Ia(t, this.changes.length, i), i += 4;
    for (const r of this.changes)
      i = r.write(t, i);
    return t.buffer;
  }
  static deserialize(e) {
    const t = new Uint8Array(e);
    let i = 0;
    const r = Na(t, i);
    i += 4;
    const o = Na(t, i);
    i += 4;
    const s = PF(t, i);
    i += 1;
    const a = PF(t, i);
    i += 1;
    const l = [];
    i = En._readSelections(t, i, l);
    const u = [];
    i = En._readSelections(t, i, u);
    const c = Na(t, i);
    i += 4;
    const h = [];
    for (let d = 0; d < c; d++)
      i = zn.read(t, i, h);
    return new En(r, o, s, a, l, u, h);
  }
}
class Q5 {
  constructor(e, t) {
    this.model = e, this._data = En.create(e, t);
  }
  get type() {
    return 0;
  }
  get resource() {
    return dt.isUri(this.model) ? this.model : this.model.uri;
  }
  get label() {
    return w("edit", "Typing");
  }
  toString() {
    return (this._data instanceof En ? this._data : En.deserialize(this._data)).changes.map((t) => t.toString()).join(", ");
  }
  matchesResource(e) {
    return (dt.isUri(this.model) ? this.model : this.model.uri).toString() === e.toString();
  }
  setModel(e) {
    this.model = e;
  }
  canAppend(e) {
    return this.model === e && this._data instanceof En;
  }
  append(e, t, i, r, o) {
    this._data instanceof En && this._data.append(e, t, i, r, o);
  }
  close() {
    this._data instanceof En && (this._data = this._data.serialize());
  }
  open() {
    this._data instanceof En || (this._data = En.deserialize(this._data));
  }
  undo() {
    if (dt.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof En && (this._data = this._data.serialize());
    const e = En.deserialize(this._data);
    this.model._applyUndo(e.changes, e.beforeEOL, e.beforeVersionId, e.beforeCursorState);
  }
  redo() {
    if (dt.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof En && (this._data = this._data.serialize());
    const e = En.deserialize(this._data);
    this.model._applyRedo(e.changes, e.afterEOL, e.afterVersionId, e.afterCursorState);
  }
  heapSize() {
    return this._data instanceof En && (this._data = this._data.serialize()), this._data.byteLength + 168;
  }
}
class rle {
  constructor(e, t) {
    this.type = 1, this.label = e, this._isOpen = !0, this._editStackElementsArr = t.slice(0), this._editStackElementsMap = /* @__PURE__ */ new Map();
    for (const i of this._editStackElementsArr) {
      const r = Tf(i.resource);
      this._editStackElementsMap.set(r, i);
    }
    this._delegate = null;
  }
  get resources() {
    return this._editStackElementsArr.map((e) => e.resource);
  }
  prepareUndoRedo() {
    if (this._delegate)
      return this._delegate.prepareUndoRedo(this);
  }
  matchesResource(e) {
    const t = Tf(e);
    return this._editStackElementsMap.has(t);
  }
  setModel(e) {
    const t = Tf(dt.isUri(e) ? e : e.uri);
    this._editStackElementsMap.has(t) && this._editStackElementsMap.get(t).setModel(e);
  }
  canAppend(e) {
    if (!this._isOpen)
      return !1;
    const t = Tf(e.uri);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).canAppend(e) : !1;
  }
  append(e, t, i, r, o) {
    const s = Tf(e.uri);
    this._editStackElementsMap.get(s).append(e, t, i, r, o);
  }
  close() {
    this._isOpen = !1;
  }
  open() {
  }
  undo() {
    this._isOpen = !1;
    for (const e of this._editStackElementsArr)
      e.undo();
  }
  redo() {
    for (const e of this._editStackElementsArr)
      e.redo();
  }
  heapSize(e) {
    const t = Tf(e);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).heapSize() : 0;
  }
  split() {
    return this._editStackElementsArr;
  }
  toString() {
    let e = [];
    for (const t of this._editStackElementsArr)
      e.push(`${HG(t.resource)}: ${t}`);
    return `{${e.join(", ")}}`;
  }
}
function IT(n) {
  return n.getEOL() === `
` ? 0 : 1;
}
function Ru(n) {
  return n ? n instanceof Q5 || n instanceof rle : !1;
}
class $N {
  constructor(e, t) {
    this._model = e, this._undoRedoService = t;
  }
  pushStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    Ru(e) && e.close();
  }
  popStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    Ru(e) && e.open();
  }
  clear() {
    this._undoRedoService.removeElements(this._model.uri);
  }
  _getOrCreateEditStackElement(e) {
    const t = this._undoRedoService.getLastElement(this._model.uri);
    if (Ru(t) && t.canAppend(this._model))
      return t;
    const i = new Q5(this._model, e);
    return this._undoRedoService.pushElement(i), i;
  }
  pushEOL(e) {
    const t = this._getOrCreateEditStackElement(null);
    this._model.setEOL(e), t.append(this._model, [], IT(this._model), this._model.getAlternativeVersionId(), null);
  }
  pushEditOperation(e, t, i) {
    const r = this._getOrCreateEditStackElement(e), o = this._model.applyEdits(t, !0), s = $N._computeCursorState(i, o), a = o.map((l, u) => ({ index: u, textChange: l.textChange }));
    return a.sort((l, u) => l.textChange.oldPosition === u.textChange.oldPosition ? l.index - u.index : l.textChange.oldPosition - u.textChange.oldPosition), r.append(this._model, a.map((l) => l.textChange), IT(this._model), this._model.getAlternativeVersionId(), s), s;
  }
  static _computeCursorState(e, t) {
    try {
      return e ? e(t) : null;
    } catch (i) {
      return Ni(i), null;
    }
  }
}
class ole {
  constructor() {
    this.spacesDiff = 0, this.looksLikeAlignment = !1;
  }
}
function sle(n, e, t, i, r) {
  r.spacesDiff = 0, r.looksLikeAlignment = !1;
  let o;
  for (o = 0; o < e && o < i; o++) {
    let d = n.charCodeAt(o), f = t.charCodeAt(o);
    if (d !== f)
      break;
  }
  let s = 0, a = 0;
  for (let d = o; d < e; d++)
    n.charCodeAt(d) === 32 ? s++ : a++;
  let l = 0, u = 0;
  for (let d = o; d < i; d++)
    t.charCodeAt(d) === 32 ? l++ : u++;
  if (s > 0 && a > 0 || l > 0 && u > 0)
    return;
  let c = Math.abs(a - u), h = Math.abs(s - l);
  if (c === 0) {
    r.spacesDiff = h, h > 0 && 0 <= l - 1 && l - 1 < n.length && l < t.length && t.charCodeAt(l) !== 32 && n.charCodeAt(l - 1) === 32 && n.charCodeAt(n.length - 1) === 44 && (r.looksLikeAlignment = !0);
    return;
  }
  if (h % c === 0) {
    r.spacesDiff = h / c;
    return;
  }
}
function Wk(n, e, t) {
  const i = Math.min(n.getLineCount(), 1e4);
  let r = 0, o = 0, s = "", a = 0;
  const l = [2, 4, 6, 8, 3, 5, 7], u = 8;
  let c = [0, 0, 0, 0, 0, 0, 0, 0, 0], h = new ole();
  for (let p = 1; p <= i; p++) {
    let g = n.getLineLength(p), _ = n.getLineContent(p);
    const m = g <= 65536;
    let v = !1, C = 0, y = 0, b = 0;
    for (let S = 0, E = g; S < E; S++) {
      let D = m ? _.charCodeAt(S) : n.getLineCharCode(p, S);
      if (D === 9)
        b++;
      else if (D === 32)
        y++;
      else {
        v = !0, C = S;
        break;
      }
    }
    if (!v || (b > 0 ? r++ : y > 1 && o++, sle(s, a, _, C, h), h.looksLikeAlignment && !(t && e === h.spacesDiff)))
      continue;
    let L = h.spacesDiff;
    L <= u && c[L]++, s = _, a = C;
  }
  let d = t;
  r !== o && (d = r < o);
  let f = e;
  if (d) {
    let p = d ? 0 : 0.1 * i;
    l.forEach((g) => {
      let _ = c[g];
      _ > p && (p = _, f = g);
    }), f === 4 && c[4] > 0 && c[2] > 0 && c[2] >= c[4] / 2 && (f = 2);
  }
  return {
    insertSpaces: d,
    tabSize: f
  };
}
function zr(n) {
  return (n.metadata & 1) >>> 0;
}
function Jt(n, e) {
  n.metadata = n.metadata & 254 | e << 0;
}
function qn(n) {
  return (n.metadata & 2) >>> 1 === 1;
}
function qt(n, e) {
  n.metadata = n.metadata & 253 | (e ? 1 : 0) << 1;
}
function J5(n) {
  return (n.metadata & 4) >>> 2 === 1;
}
function Vk(n, e) {
  n.metadata = n.metadata & 251 | (e ? 1 : 0) << 2;
}
function gD(n) {
  return (n.metadata & 8) >>> 3 === 1;
}
function Bk(n, e) {
  n.metadata = n.metadata & 247 | (e ? 1 : 0) << 3;
}
function ale(n) {
  return (n.metadata & 48) >>> 4;
}
function Hk(n, e) {
  n.metadata = n.metadata & 207 | e << 4;
}
function lle(n) {
  return (n.metadata & 64) >>> 6 === 1;
}
function Gk(n, e) {
  n.metadata = n.metadata & 191 | (e ? 1 : 0) << 6;
}
class e3 {
  constructor(e, t, i) {
    this.metadata = 0, this.parent = this, this.left = this, this.right = this, Jt(
      this,
      1
      /* Red */
    ), this.start = t, this.end = i, this.delta = 0, this.maxEnd = i, this.id = e, this.ownerId = 0, this.options = null, Vk(this, !1), Hk(
      this,
      1
      /* NeverGrowsWhenTypingAtEdges */
    ), Bk(this, !1), Gk(this, !1), this.cachedVersionId = 0, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = null, qt(this, !1);
  }
  reset(e, t, i, r) {
    this.start = t, this.end = i, this.maxEnd = i, this.cachedVersionId = e, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = r;
  }
  setOptions(e) {
    this.options = e;
    let t = this.options.className;
    Vk(this, t === "squiggly-error" || t === "squiggly-warning" || t === "squiggly-info"), Hk(this, this.options.stickiness), Bk(this, !!(this.options.overviewRuler && this.options.overviewRuler.color)), Gk(this, this.options.collapseOnReplaceEdit);
  }
  setCachedOffsets(e, t, i) {
    this.cachedVersionId !== i && (this.range = null), this.cachedVersionId = i, this.cachedAbsoluteStart = e, this.cachedAbsoluteEnd = t;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const et = new e3(null, 0, 0);
et.parent = et;
et.left = et;
et.right = et;
Jt(
  et,
  0
  /* Black */
);
class Uk {
  constructor() {
    this.root = et, this.requestNormalizeDelta = !1;
  }
  intervalSearch(e, t, i, r, o) {
    return this.root === et ? [] : mle(this, e, t, i, r, o);
  }
  search(e, t, i) {
    return this.root === et ? [] : gle(this, e, t, i);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesFromOwner(e) {
    return fle(this, e);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesPostOrder() {
    return ple(this);
  }
  insert(e) {
    zk(this, e), this._normalizeDeltaIfNecessary();
  }
  delete(e) {
    jk(this, e), this._normalizeDeltaIfNecessary();
  }
  resolveNode(e, t) {
    const i = e;
    let r = 0;
    for (; e !== this.root; )
      e === e.parent.right && (r += e.parent.delta), e = e.parent;
    const o = i.start + r, s = i.end + r;
    i.setCachedOffsets(o, s, t);
  }
  acceptReplace(e, t, i, r) {
    const o = hle(this, e, e + t);
    for (let s = 0, a = o.length; s < a; s++) {
      const l = o[s];
      jk(this, l);
    }
    this._normalizeDeltaIfNecessary(), dle(this, e, e + t, i), this._normalizeDeltaIfNecessary();
    for (let s = 0, a = o.length; s < a; s++) {
      const l = o[s];
      l.start = l.cachedAbsoluteStart, l.end = l.cachedAbsoluteEnd, cle(l, e, e + t, i, r), l.maxEnd = l.end, zk(this, l);
    }
    this._normalizeDeltaIfNecessary();
  }
  _normalizeDeltaIfNecessary() {
    this.requestNormalizeDelta && (this.requestNormalizeDelta = !1, ule(this));
  }
}
function ule(n) {
  let e = n.root, t = 0;
  for (; e !== et; ) {
    if (e.left !== et && !qn(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== et && !qn(e.right)) {
      t += e.delta, e = e.right;
      continue;
    }
    e.start = t + e.start, e.end = t + e.end, e.delta = 0, rh(e), qt(e, !0), qt(e.left, !1), qt(e.right, !1), e === e.parent.right && (t -= e.parent.delta), e = e.parent;
  }
  qt(n.root, !1);
}
function Of(n, e, t, i) {
  return n < t ? !0 : n > t || i === 1 ? !1 : i === 2 ? !0 : e;
}
function cle(n, e, t, i, r) {
  const o = ale(n), s = o === 0 || o === 2, a = o === 1 || o === 2, l = t - e, u = i, c = Math.min(l, u), h = n.start;
  let d = !1;
  const f = n.end;
  let p = !1;
  e <= h && f <= t && lle(n) && (n.start = e, d = !0, n.end = e, p = !0);
  {
    const _ = r ? 1 : l > 0 ? 2 : 0;
    !d && Of(h, s, e, _) && (d = !0), !p && Of(f, a, e, _) && (p = !0);
  }
  if (c > 0 && !r) {
    const _ = l > u ? 2 : 0;
    !d && Of(h, s, e + c, _) && (d = !0), !p && Of(f, a, e + c, _) && (p = !0);
  }
  {
    const _ = r ? 1 : 0;
    !d && Of(h, s, t, _) && (n.start = e + u, d = !0), !p && Of(f, a, t, _) && (n.end = e + u, p = !0);
  }
  const g = u - l;
  d || (n.start = Math.max(0, h + g)), p || (n.end = Math.max(0, f + g)), n.start > n.end && (n.end = n.start);
}
function hle(n, e, t) {
  let i = n.root, r = 0, o = 0, s = 0, a = 0, l = [], u = 0;
  for (; i !== et; ) {
    if (qn(i)) {
      qt(i.left, !1), qt(i.right, !1), i === i.parent.right && (r -= i.parent.delta), i = i.parent;
      continue;
    }
    if (!qn(i.left)) {
      if (o = r + i.maxEnd, o < e) {
        qt(i, !0);
        continue;
      }
      if (i.left !== et) {
        i = i.left;
        continue;
      }
    }
    if (s = r + i.start, s > t) {
      qt(i, !0);
      continue;
    }
    if (a = r + i.end, a >= e && (i.setCachedOffsets(s, a, 0), l[u++] = i), qt(i, !0), i.right !== et && !qn(i.right)) {
      r += i.delta, i = i.right;
      continue;
    }
  }
  return qt(n.root, !1), l;
}
function dle(n, e, t, i) {
  let r = n.root, o = 0, s = 0, a = 0;
  const l = i - (t - e);
  for (; r !== et; ) {
    if (qn(r)) {
      qt(r.left, !1), qt(r.right, !1), r === r.parent.right && (o -= r.parent.delta), rh(r), r = r.parent;
      continue;
    }
    if (!qn(r.left)) {
      if (s = o + r.maxEnd, s < e) {
        qt(r, !0);
        continue;
      }
      if (r.left !== et) {
        r = r.left;
        continue;
      }
    }
    if (a = o + r.start, a > t) {
      r.start += l, r.end += l, r.delta += l, (r.delta < -1073741824 || r.delta > 1073741824) && (n.requestNormalizeDelta = !0), qt(r, !0);
      continue;
    }
    if (qt(r, !0), r.right !== et && !qn(r.right)) {
      o += r.delta, r = r.right;
      continue;
    }
  }
  qt(n.root, !1);
}
function fle(n, e) {
  let t = n.root, i = [], r = 0;
  for (; t !== et; ) {
    if (qn(t)) {
      qt(t.left, !1), qt(t.right, !1), t = t.parent;
      continue;
    }
    if (t.left !== et && !qn(t.left)) {
      t = t.left;
      continue;
    }
    if (t.ownerId === e && (i[r++] = t), qt(t, !0), t.right !== et && !qn(t.right)) {
      t = t.right;
      continue;
    }
  }
  return qt(n.root, !1), i;
}
function ple(n) {
  let e = n.root, t = [], i = 0;
  for (; e !== et; ) {
    if (qn(e)) {
      qt(e.left, !1), qt(e.right, !1), e = e.parent;
      continue;
    }
    if (e.left !== et && !qn(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== et && !qn(e.right)) {
      e = e.right;
      continue;
    }
    t[i++] = e, qt(e, !0);
  }
  return qt(n.root, !1), t;
}
function gle(n, e, t, i) {
  let r = n.root, o = 0, s = 0, a = 0, l = [], u = 0;
  for (; r !== et; ) {
    if (qn(r)) {
      qt(r.left, !1), qt(r.right, !1), r === r.parent.right && (o -= r.parent.delta), r = r.parent;
      continue;
    }
    if (r.left !== et && !qn(r.left)) {
      r = r.left;
      continue;
    }
    s = o + r.start, a = o + r.end, r.setCachedOffsets(s, a, i);
    let c = !0;
    if (e && r.ownerId && r.ownerId !== e && (c = !1), t && J5(r) && (c = !1), c && (l[u++] = r), qt(r, !0), r.right !== et && !qn(r.right)) {
      o += r.delta, r = r.right;
      continue;
    }
  }
  return qt(n.root, !1), l;
}
function mle(n, e, t, i, r, o) {
  let s = n.root, a = 0, l = 0, u = 0, c = 0, h = [], d = 0;
  for (; s !== et; ) {
    if (qn(s)) {
      qt(s.left, !1), qt(s.right, !1), s === s.parent.right && (a -= s.parent.delta), s = s.parent;
      continue;
    }
    if (!qn(s.left)) {
      if (l = a + s.maxEnd, l < e) {
        qt(s, !0);
        continue;
      }
      if (s.left !== et) {
        s = s.left;
        continue;
      }
    }
    if (u = a + s.start, u > t) {
      qt(s, !0);
      continue;
    }
    if (c = a + s.end, c >= e) {
      s.setCachedOffsets(u, c, o);
      let f = !0;
      i && s.ownerId && s.ownerId !== i && (f = !1), r && J5(s) && (f = !1), f && (h[d++] = s);
    }
    if (qt(s, !0), s.right !== et && !qn(s.right)) {
      a += s.delta, s = s.right;
      continue;
    }
  }
  return qt(n.root, !1), h;
}
function zk(n, e) {
  if (n.root === et)
    return e.parent = et, e.left = et, e.right = et, Jt(
      e,
      0
      /* Black */
    ), n.root = e, n.root;
  vle(n, e), Tc(e.parent);
  let t = e;
  for (; t !== n.root && zr(t.parent) === 1; )
    if (t.parent === t.parent.parent.left) {
      const i = t.parent.parent.right;
      zr(i) === 1 ? (Jt(
        t.parent,
        0
        /* Black */
      ), Jt(
        i,
        0
        /* Black */
      ), Jt(
        t.parent.parent,
        1
        /* Red */
      ), t = t.parent.parent) : (t === t.parent.right && (t = t.parent, fv(n, t)), Jt(
        t.parent,
        0
        /* Black */
      ), Jt(
        t.parent.parent,
        1
        /* Red */
      ), pv(n, t.parent.parent));
    } else {
      const i = t.parent.parent.left;
      zr(i) === 1 ? (Jt(
        t.parent,
        0
        /* Black */
      ), Jt(
        i,
        0
        /* Black */
      ), Jt(
        t.parent.parent,
        1
        /* Red */
      ), t = t.parent.parent) : (t === t.parent.left && (t = t.parent, pv(n, t)), Jt(
        t.parent,
        0
        /* Black */
      ), Jt(
        t.parent.parent,
        1
        /* Red */
      ), fv(n, t.parent.parent));
    }
  return Jt(
    n.root,
    0
    /* Black */
  ), e;
}
function vle(n, e) {
  let t = 0, i = n.root;
  const r = e.start, o = e.end;
  for (; ; )
    if (Cle(r, o, i.start + t, i.end + t) < 0)
      if (i.left === et) {
        e.start -= t, e.end -= t, e.maxEnd -= t, i.left = e;
        break;
      } else
        i = i.left;
    else if (i.right === et) {
      e.start -= t + i.delta, e.end -= t + i.delta, e.maxEnd -= t + i.delta, i.right = e;
      break;
    } else
      t += i.delta, i = i.right;
  e.parent = i, e.left = et, e.right = et, Jt(
    e,
    1
    /* Red */
  );
}
function jk(n, e) {
  let t, i;
  if (e.left === et ? (t = e.right, i = e, t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (n.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta) : e.right === et ? (t = e.left, i = e) : (i = _le(e.right), t = i.right, t.start += i.delta, t.end += i.delta, t.delta += i.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (n.requestNormalizeDelta = !0), i.start += e.delta, i.end += e.delta, i.delta = e.delta, (i.delta < -1073741824 || i.delta > 1073741824) && (n.requestNormalizeDelta = !0)), i === n.root) {
    n.root = t, Jt(
      t,
      0
      /* Black */
    ), e.detach(), mD(), rh(t), n.root.parent = et;
    return;
  }
  let r = zr(i) === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? t.parent = i.parent : (i.parent === e ? t.parent = i : t.parent = i.parent, i.left = e.left, i.right = e.right, i.parent = e.parent, Jt(i, zr(e)), e === n.root ? n.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== et && (i.left.parent = i), i.right !== et && (i.right.parent = i)), e.detach(), r) {
    Tc(t.parent), i !== e && (Tc(i), Tc(i.parent)), mD();
    return;
  }
  Tc(t), Tc(t.parent), i !== e && (Tc(i), Tc(i.parent));
  let o;
  for (; t !== n.root && zr(t) === 0; )
    t === t.parent.left ? (o = t.parent.right, zr(o) === 1 && (Jt(
      o,
      0
      /* Black */
    ), Jt(
      t.parent,
      1
      /* Red */
    ), fv(n, t.parent), o = t.parent.right), zr(o.left) === 0 && zr(o.right) === 0 ? (Jt(
      o,
      1
      /* Red */
    ), t = t.parent) : (zr(o.right) === 0 && (Jt(
      o.left,
      0
      /* Black */
    ), Jt(
      o,
      1
      /* Red */
    ), pv(n, o), o = t.parent.right), Jt(o, zr(t.parent)), Jt(
      t.parent,
      0
      /* Black */
    ), Jt(
      o.right,
      0
      /* Black */
    ), fv(n, t.parent), t = n.root)) : (o = t.parent.left, zr(o) === 1 && (Jt(
      o,
      0
      /* Black */
    ), Jt(
      t.parent,
      1
      /* Red */
    ), pv(n, t.parent), o = t.parent.left), zr(o.left) === 0 && zr(o.right) === 0 ? (Jt(
      o,
      1
      /* Red */
    ), t = t.parent) : (zr(o.left) === 0 && (Jt(
      o.right,
      0
      /* Black */
    ), Jt(
      o,
      1
      /* Red */
    ), fv(n, o), o = t.parent.left), Jt(o, zr(t.parent)), Jt(
      t.parent,
      0
      /* Black */
    ), Jt(
      o.left,
      0
      /* Black */
    ), pv(n, t.parent), t = n.root));
  Jt(
    t,
    0
    /* Black */
  ), mD();
}
function _le(n) {
  for (; n.left !== et; )
    n = n.left;
  return n;
}
function mD() {
  et.parent = et, et.delta = 0, et.start = 0, et.end = 0;
}
function fv(n, e) {
  const t = e.right;
  t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (n.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta, e.right = t.left, t.left !== et && (t.left.parent = e), t.parent = e.parent, e.parent === et ? n.root = t : e === e.parent.left ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t, rh(e), rh(t);
}
function pv(n, e) {
  const t = e.left;
  e.delta -= t.delta, (e.delta < -1073741824 || e.delta > 1073741824) && (n.requestNormalizeDelta = !0), e.start -= t.delta, e.end -= t.delta, e.left = t.right, t.right !== et && (t.right.parent = e), t.parent = e.parent, e.parent === et ? n.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t, rh(e), rh(t);
}
function t3(n) {
  let e = n.end;
  if (n.left !== et) {
    const t = n.left.maxEnd;
    t > e && (e = t);
  }
  if (n.right !== et) {
    const t = n.right.maxEnd + n.delta;
    t > e && (e = t);
  }
  return e;
}
function rh(n) {
  n.maxEnd = t3(n);
}
function Tc(n) {
  for (; n !== et; ) {
    const e = t3(n);
    if (n.maxEnd === e)
      return;
    n.maxEnd = e, n = n.parent;
  }
}
function Cle(n, e, t, i) {
  return n === t ? e - i : n - t;
}
class PT {
  constructor(e, t) {
    this.piece = e, this.color = t, this.size_left = 0, this.lf_left = 0, this.parent = this, this.left = this, this.right = this;
  }
  next() {
    if (this.right !== Ue)
      return KN(this.right);
    let e = this;
    for (; e.parent !== Ue && e.parent.left !== e; )
      e = e.parent;
    return e.parent === Ue ? Ue : e.parent;
  }
  prev() {
    if (this.left !== Ue)
      return i3(this.left);
    let e = this;
    for (; e.parent !== Ue && e.parent.right !== e; )
      e = e.parent;
    return e.parent === Ue ? Ue : e.parent;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const Ue = new PT(
  null,
  0
  /* Black */
);
Ue.parent = Ue;
Ue.left = Ue;
Ue.right = Ue;
Ue.color = 0;
function KN(n) {
  for (; n.left !== Ue; )
    n = n.left;
  return n;
}
function i3(n) {
  for (; n.right !== Ue; )
    n = n.right;
  return n;
}
function qN(n) {
  return n === Ue ? 0 : n.size_left + n.piece.length + qN(n.right);
}
function YN(n) {
  return n === Ue ? 0 : n.lf_left + n.piece.lineFeedCnt + YN(n.right);
}
function vD() {
  Ue.parent = Ue;
}
function gv(n, e) {
  let t = e.right;
  t.size_left += e.size_left + (e.piece ? e.piece.length : 0), t.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0), e.right = t.left, t.left !== Ue && (t.left.parent = e), t.parent = e.parent, e.parent === Ue ? n.root = t : e.parent.left === e ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t;
}
function mv(n, e) {
  let t = e.left;
  e.left = t.right, t.right !== Ue && (t.right.parent = e), t.parent = e.parent, e.size_left -= t.size_left + (t.piece ? t.piece.length : 0), e.lf_left -= t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0), e.parent === Ue ? n.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t;
}
function my(n, e) {
  let t, i;
  if (e.left === Ue ? (i = e, t = i.right) : e.right === Ue ? (i = e, t = i.left) : (i = KN(e.right), t = i.right), i === n.root) {
    n.root = t, t.color = 0, e.detach(), vD(), n.root.parent = Ue;
    return;
  }
  let r = i.color === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? (t.parent = i.parent, Um(n, t)) : (i.parent === e ? t.parent = i : t.parent = i.parent, Um(n, t), i.left = e.left, i.right = e.right, i.parent = e.parent, i.color = e.color, e === n.root ? n.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== Ue && (i.left.parent = i), i.right !== Ue && (i.right.parent = i), i.size_left = e.size_left, i.lf_left = e.lf_left, Um(n, i)), e.detach(), t.parent.left === t) {
    let s = qN(t), a = YN(t);
    if (s !== t.parent.size_left || a !== t.parent.lf_left) {
      let l = s - t.parent.size_left, u = a - t.parent.lf_left;
      t.parent.size_left = s, t.parent.lf_left = a, Cu(n, t.parent, l, u);
    }
  }
  if (Um(n, t.parent), r) {
    vD();
    return;
  }
  let o;
  for (; t !== n.root && t.color === 0; )
    t === t.parent.left ? (o = t.parent.right, o.color === 1 && (o.color = 0, t.parent.color = 1, gv(n, t.parent), o = t.parent.right), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.right.color === 0 && (o.left.color = 0, o.color = 1, mv(n, o), o = t.parent.right), o.color = t.parent.color, t.parent.color = 0, o.right.color = 0, gv(n, t.parent), t = n.root)) : (o = t.parent.left, o.color === 1 && (o.color = 0, t.parent.color = 1, mv(n, t.parent), o = t.parent.left), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.left.color === 0 && (o.right.color = 0, o.color = 1, gv(n, o), o = t.parent.left), o.color = t.parent.color, t.parent.color = 0, o.left.color = 0, mv(n, t.parent), t = n.root));
  t.color = 0, vD();
}
function $k(n, e) {
  for (Um(n, e); e !== n.root && e.parent.color === 1; )
    if (e.parent === e.parent.parent.left) {
      const t = e.parent.parent.right;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, gv(n, e)), e.parent.color = 0, e.parent.parent.color = 1, mv(n, e.parent.parent));
    } else {
      const t = e.parent.parent.left;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, mv(n, e)), e.parent.color = 0, e.parent.parent.color = 1, gv(n, e.parent.parent));
    }
  n.root.color = 0;
}
function Cu(n, e, t, i) {
  for (; e !== n.root && e !== Ue; )
    e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
}
function Um(n, e) {
  let t = 0, i = 0;
  if (e !== n.root) {
    if (t === 0) {
      for (; e !== n.root && e === e.parent.right; )
        e = e.parent;
      if (e === n.root)
        return;
      e = e.parent, t = qN(e.left) - e.size_left, i = YN(e.left) - e.lf_left, e.size_left += t, e.lf_left += i;
    }
    for (; e !== n.root && (t !== 0 || i !== 0); )
      e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
  }
}
class yle extends bg {
  constructor(e) {
    super(
      0
      /* Regular */
    );
    for (let t = 0, i = e.length; t < i; t++)
      this.set(
        e.charCodeAt(t),
        2
        /* WordSeparator */
      );
    this.set(
      32,
      1
      /* Whitespace */
    ), this.set(
      9,
      1
      /* Whitespace */
    );
  }
}
function wle(n) {
  let e = {};
  return (t) => (e.hasOwnProperty(t) || (e[t] = n(t)), e[t]);
}
const jp = wle((n) => new yle(n)), ble = 999;
class xf {
  constructor(e, t, i, r) {
    this.searchString = e, this.isRegex = t, this.matchCase = i, this.wordSeparators = r;
  }
  parseSearchRequest() {
    if (this.searchString === "")
      return null;
    let e;
    this.isRegex ? e = Sle(this.searchString) : e = this.searchString.indexOf(`
`) >= 0;
    let t = null;
    try {
      t = MG(this.searchString, this.isRegex, {
        matchCase: this.matchCase,
        wholeWord: !1,
        multiline: e,
        global: !0,
        unicode: !0
      });
    } catch {
      return null;
    }
    if (!t)
      return null;
    let i = !this.isRegex && !e;
    return i && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (i = this.matchCase), new Ele(t, this.wordSeparators ? jp(this.wordSeparators) : null, i ? this.searchString : null);
  }
}
function Sle(n) {
  if (!n || n.length === 0)
    return !1;
  for (let e = 0, t = n.length; e < t; e++)
    if (n.charCodeAt(e) === 92) {
      if (e++, e >= t)
        break;
      const r = n.charCodeAt(e);
      if (r === 110 || r === 114 || r === 87 || r === 119)
        return !0;
    }
  return !1;
}
class Ele {
  constructor(e, t, i) {
    this.regex = e, this.wordSeparators = t, this.simpleSearch = i;
  }
}
function jh(n, e, t) {
  if (!t)
    return new zv(n, null);
  let i = [];
  for (let r = 0, o = e.length; r < o; r++)
    i[r] = e[r];
  return new zv(n, i);
}
class Kk {
  constructor(e) {
    let t = [], i = 0;
    for (let r = 0, o = e.length; r < o; r++)
      e.charCodeAt(r) === 10 && (t[i++] = r);
    this._lineFeedsOffsets = t;
  }
  findLineFeedCountBeforeOffset(e) {
    const t = this._lineFeedsOffsets;
    let i = 0, r = t.length - 1;
    if (r === -1 || e <= t[0])
      return 0;
    for (; i < r; ) {
      const o = i + ((r - i) / 2 >> 0);
      t[o] >= e ? r = o - 1 : t[o + 1] >= e ? (i = o, r = o) : i = o + 1;
    }
    return i + 1;
  }
}
class vy {
  static findMatches(e, t, i, r, o) {
    const s = t.parseSearchRequest();
    return s ? s.regex.multiline ? this._doFindMatchesMultiline(e, i, new zm(s.wordSeparators, s.regex), r, o) : this._doFindMatchesLineByLine(e, i, s, r, o) : [];
  }
  /**
   * Multiline search always executes on the lines concatenated with \n.
   * We must therefore compensate for the count of \n in case the model is CRLF
   */
  static _getMultilineMatchRange(e, t, i, r, o, s) {
    let a, l = 0;
    r ? (l = r.findLineFeedCountBeforeOffset(o), a = t + o + l) : a = t + o;
    let u;
    if (r) {
      let f = r.findLineFeedCountBeforeOffset(o + s.length) - l;
      u = a + s.length + f;
    } else
      u = a + s.length;
    const c = e.getPositionAt(a), h = e.getPositionAt(u);
    return new V(c.lineNumber, c.column, h.lineNumber, h.column);
  }
  static _doFindMatchesMultiline(e, t, i, r, o) {
    const s = e.getOffsetAt(t.getStartPosition()), a = e.getValueInRange(
      t,
      1
      /* LF */
    ), l = e.getEOL() === `\r
` ? new Kk(a) : null, u = [];
    let c = 0, h;
    for (i.reset(0); h = i.next(a); )
      if (u[c++] = jh(this._getMultilineMatchRange(e, s, a, l, h.index, h[0]), h, r), c >= o)
        return u;
    return u;
  }
  static _doFindMatchesLineByLine(e, t, i, r, o) {
    const s = [];
    let a = 0;
    if (t.startLineNumber === t.endLineNumber) {
      const u = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1, t.endColumn - 1);
      return a = this._findMatchesInLine(i, u, t.startLineNumber, t.startColumn - 1, a, s, r, o), s;
    }
    const l = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1);
    a = this._findMatchesInLine(i, l, t.startLineNumber, t.startColumn - 1, a, s, r, o);
    for (let u = t.startLineNumber + 1; u < t.endLineNumber && a < o; u++)
      a = this._findMatchesInLine(i, e.getLineContent(u), u, 0, a, s, r, o);
    if (a < o) {
      const u = e.getLineContent(t.endLineNumber).substring(0, t.endColumn - 1);
      a = this._findMatchesInLine(i, u, t.endLineNumber, 0, a, s, r, o);
    }
    return s;
  }
  static _findMatchesInLine(e, t, i, r, o, s, a, l) {
    const u = e.wordSeparators;
    if (!a && e.simpleSearch) {
      const d = e.simpleSearch, f = d.length, p = t.length;
      let g = -f;
      for (; (g = t.indexOf(d, g + f)) !== -1; )
        if ((!u || XN(u, t, p, g, f)) && (s[o++] = new zv(new V(i, g + 1 + r, i, g + 1 + f + r), null), o >= l))
          return o;
      return o;
    }
    const c = new zm(e.wordSeparators, e.regex);
    let h;
    c.reset(0);
    do
      if (h = c.next(t), h && (s[o++] = jh(new V(i, h.index + 1 + r, i, h.index + 1 + h[0].length + r), h, a), o >= l))
        return o;
    while (h);
    return o;
  }
  static findNextMatch(e, t, i, r) {
    const o = t.parseSearchRequest();
    if (!o)
      return null;
    const s = new zm(o.wordSeparators, o.regex);
    return o.regex.multiline ? this._doFindNextMatchMultiline(e, i, s, r) : this._doFindNextMatchLineByLine(e, i, s, r);
  }
  static _doFindNextMatchMultiline(e, t, i, r) {
    const o = new J(t.lineNumber, 1), s = e.getOffsetAt(o), a = e.getLineCount(), l = e.getValueInRange(
      new V(o.lineNumber, o.column, a, e.getLineMaxColumn(a)),
      1
      /* LF */
    ), u = e.getEOL() === `\r
` ? new Kk(l) : null;
    i.reset(t.column - 1);
    let c = i.next(l);
    return c ? jh(this._getMultilineMatchRange(e, s, l, u, c.index, c[0]), c, r) : t.lineNumber !== 1 || t.column !== 1 ? this._doFindNextMatchMultiline(e, new J(1, 1), i, r) : null;
  }
  static _doFindNextMatchLineByLine(e, t, i, r) {
    const o = e.getLineCount(), s = t.lineNumber, a = e.getLineContent(s), l = this._findFirstMatchInLine(i, a, s, t.column, r);
    if (l)
      return l;
    for (let u = 1; u <= o; u++) {
      const c = (s + u - 1) % o, h = e.getLineContent(c + 1), d = this._findFirstMatchInLine(i, h, c + 1, 1, r);
      if (d)
        return d;
    }
    return null;
  }
  static _findFirstMatchInLine(e, t, i, r, o) {
    e.reset(r - 1);
    const s = e.next(t);
    return s ? jh(new V(i, s.index + 1, i, s.index + 1 + s[0].length), s, o) : null;
  }
  static findPreviousMatch(e, t, i, r) {
    const o = t.parseSearchRequest();
    if (!o)
      return null;
    const s = new zm(o.wordSeparators, o.regex);
    return o.regex.multiline ? this._doFindPreviousMatchMultiline(e, i, s, r) : this._doFindPreviousMatchLineByLine(e, i, s, r);
  }
  static _doFindPreviousMatchMultiline(e, t, i, r) {
    const o = this._doFindMatchesMultiline(e, new V(1, 1, t.lineNumber, t.column), i, r, 10 * ble);
    if (o.length > 0)
      return o[o.length - 1];
    const s = e.getLineCount();
    return t.lineNumber !== s || t.column !== e.getLineMaxColumn(s) ? this._doFindPreviousMatchMultiline(e, new J(s, e.getLineMaxColumn(s)), i, r) : null;
  }
  static _doFindPreviousMatchLineByLine(e, t, i, r) {
    const o = e.getLineCount(), s = t.lineNumber, a = e.getLineContent(s).substring(0, t.column - 1), l = this._findLastMatchInLine(i, a, s, r);
    if (l)
      return l;
    for (let u = 1; u <= o; u++) {
      const c = (o + s - u - 1) % o, h = e.getLineContent(c + 1), d = this._findLastMatchInLine(i, h, c + 1, r);
      if (d)
        return d;
    }
    return null;
  }
  static _findLastMatchInLine(e, t, i, r) {
    let o = null, s;
    for (e.reset(0); s = e.next(t); )
      o = jh(new V(i, s.index + 1, i, s.index + 1 + s[0].length), s, r);
    return o;
  }
}
function Lle(n, e, t, i, r) {
  if (i === 0)
    return !0;
  const o = e.charCodeAt(i - 1);
  if (n.get(o) !== 0 || o === 13 || o === 10)
    return !0;
  if (r > 0) {
    const s = e.charCodeAt(i);
    if (n.get(s) !== 0)
      return !0;
  }
  return !1;
}
function Dle(n, e, t, i, r) {
  if (i + r === t)
    return !0;
  const o = e.charCodeAt(i + r);
  if (n.get(o) !== 0 || o === 13 || o === 10)
    return !0;
  if (r > 0) {
    const s = e.charCodeAt(i + r - 1);
    if (n.get(s) !== 0)
      return !0;
  }
  return !1;
}
function XN(n, e, t, i, r) {
  return Lle(n, e, t, i, r) && Dle(n, e, t, i, r);
}
class zm {
  constructor(e, t) {
    this._wordSeparators = e, this._searchRegex = t, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  reset(e) {
    this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  next(e) {
    const t = e.length;
    let i;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === t || (i = this._searchRegex.exec(e), !i))
        return null;
      const r = i.index, o = i[0].length;
      if (r === this._prevMatchStartIndex && o === this._prevMatchLength) {
        if (o === 0) {
          Lu(e, t, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
          continue;
        }
        return null;
      }
      if (this._prevMatchStartIndex = r, this._prevMatchLength = o, !this._wordSeparators || XN(this._wordSeparators, e, t, r, o))
        return i;
    } while (i);
    return null;
  }
}
const pu = 65535;
function n3(n) {
  let e;
  return n[n.length - 1] < 65536 ? e = new Uint16Array(n.length) : e = new Uint32Array(n.length), e.set(n, 0), e;
}
class Rle {
  constructor(e, t, i, r, o) {
    this.lineStarts = e, this.cr = t, this.lf = i, this.crlf = r, this.isBasicASCII = o;
  }
}
function wu(n, e = !0) {
  let t = [0], i = 1;
  for (let r = 0, o = n.length; r < o; r++) {
    const s = n.charCodeAt(r);
    s === 13 ? r + 1 < o && n.charCodeAt(r + 1) === 10 ? (t[i++] = r + 2, r++) : t[i++] = r + 1 : s === 10 && (t[i++] = r + 1);
  }
  return e ? n3(t) : t;
}
function Tle(n, e) {
  n.length = 0, n[0] = 0;
  let t = 1, i = 0, r = 0, o = 0, s = !0;
  for (let l = 0, u = e.length; l < u; l++) {
    const c = e.charCodeAt(l);
    c === 13 ? l + 1 < u && e.charCodeAt(l + 1) === 10 ? (o++, n[t++] = l + 2, l++) : (i++, n[t++] = l + 1) : c === 10 ? (r++, n[t++] = l + 1) : s && c !== 9 && (c < 32 || c > 126) && (s = !1);
  }
  const a = new Rle(n3(n), i, r, o, s);
  return n.length = 0, a;
}
class fo {
  constructor(e, t, i, r, o) {
    this.bufferIndex = e, this.start = t, this.end = i, this.lineFeedCnt = r, this.length = o;
  }
}
class $h {
  constructor(e, t) {
    this.buffer = e, this.lineStarts = t;
  }
}
class Ole {
  constructor(e, t) {
    this._pieces = [], this._tree = e, this._BOM = t, this._index = 0, e.root !== Ue && e.iterate(e.root, (i) => (i !== Ue && this._pieces.push(i.piece), !0));
  }
  read() {
    return this._pieces.length === 0 ? this._index === 0 ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : this._index === 0 ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++]);
  }
}
class xle {
  constructor(e) {
    this._limit = e, this._cache = [];
  }
  get(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      let i = this._cache[t];
      if (i.nodeStartOffset <= e && i.nodeStartOffset + i.node.piece.length >= e)
        return i;
    }
    return null;
  }
  get2(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      let i = this._cache[t];
      if (i.nodeStartLineNumber && i.nodeStartLineNumber < e && i.nodeStartLineNumber + i.node.piece.lineFeedCnt >= e)
        return i;
    }
    return null;
  }
  set(e) {
    this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e);
  }
  validate(e) {
    let t = !1, i = this._cache;
    for (let r = 0; r < i.length; r++) {
      let o = i[r];
      if (o.node.parent === null || o.nodeStartOffset >= e) {
        i[r] = null, t = !0;
        continue;
      }
    }
    if (t) {
      let r = [];
      for (const o of i)
        o !== null && r.push(o);
      this._cache = r;
    }
  }
}
class Nle {
  constructor(e, t, i) {
    this.create(e, t, i);
  }
  create(e, t, i) {
    this._buffers = [
      new $h("", [0])
    ], this._lastChangeBufferPos = { line: 0, column: 0 }, this.root = Ue, this._lineCnt = 1, this._length = 0, this._EOL = t, this._EOLLength = t.length, this._EOLNormalized = i;
    let r = null;
    for (let o = 0, s = e.length; o < s; o++)
      if (e[o].buffer.length > 0) {
        e[o].lineStarts || (e[o].lineStarts = wu(e[o].buffer));
        let a = new fo(o + 1, { line: 0, column: 0 }, { line: e[o].lineStarts.length - 1, column: e[o].buffer.length - e[o].lineStarts[e[o].lineStarts.length - 1] }, e[o].lineStarts.length - 1, e[o].buffer.length);
        this._buffers.push(e[o]), r = this.rbInsertRight(r, a);
      }
    this._searchCache = new xle(1), this._lastVisitedLine = { lineNumber: 0, value: "" }, this.computeBufferMetadata();
  }
  normalizeEOL(e) {
    let t = pu, i = t - Math.floor(t / 3), r = i * 2, o = "", s = 0, a = [];
    if (this.iterate(this.root, (l) => {
      let u = this.getNodeContent(l), c = u.length;
      if (s <= i || s + c < r)
        return o += u, s += c, !0;
      let h = o.replace(/\r\n|\r|\n/g, e);
      return a.push(new $h(h, wu(h))), o = u, s = c, !0;
    }), s > 0) {
      let l = o.replace(/\r\n|\r|\n/g, e);
      a.push(new $h(l, wu(l)));
    }
    this.create(a, e, !0);
  }
  // #region Buffer API
  getEOL() {
    return this._EOL;
  }
  setEOL(e) {
    this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL(e);
  }
  createSnapshot(e) {
    return new Ole(this, e);
  }
  getOffsetAt(e, t) {
    let i = 0, r = this.root;
    for (; r !== Ue; )
      if (r.left !== Ue && r.lf_left + 1 >= e)
        r = r.left;
      else if (r.lf_left + r.piece.lineFeedCnt + 1 >= e) {
        i += r.size_left;
        let o = this.getAccumulatedValue(r, e - r.lf_left - 2);
        return i += o + t - 1;
      } else
        e -= r.lf_left + r.piece.lineFeedCnt, i += r.size_left + r.piece.length, r = r.right;
    return i;
  }
  getPositionAt(e) {
    e = Math.floor(e), e = Math.max(0, e);
    let t = this.root, i = 0, r = e;
    for (; t !== Ue; )
      if (t.size_left !== 0 && t.size_left >= e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        let o = this.getIndexOf(t, e - t.size_left);
        if (i += t.lf_left + o.index, o.index === 0) {
          let s = this.getOffsetAt(i + 1, 1), a = r - s;
          return new J(i + 1, a + 1);
        }
        return new J(i + 1, o.remainder + 1);
      } else if (e -= t.size_left + t.piece.length, i += t.lf_left + t.piece.lineFeedCnt, t.right === Ue) {
        let o = this.getOffsetAt(i + 1, 1), s = r - e - o;
        return new J(i + 1, s + 1);
      } else
        t = t.right;
    return new J(1, 1);
  }
  getValueInRange(e, t) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return "";
    let i = this.nodeAt2(e.startLineNumber, e.startColumn), r = this.nodeAt2(e.endLineNumber, e.endColumn), o = this.getValueInRange2(i, r);
    return t ? t !== this._EOL || !this._EOLNormalized ? o.replace(/\r\n|\r|\n/g, t) : t === this.getEOL() && this._EOLNormalized ? o : o.replace(/\r\n|\r|\n/g, t) : o;
  }
  getValueInRange2(e, t) {
    if (e.node === t.node) {
      let a = e.node, l = this._buffers[a.piece.bufferIndex].buffer, u = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start);
      return l.substring(u + e.remainder, u + t.remainder);
    }
    let i = e.node, r = this._buffers[i.piece.bufferIndex].buffer, o = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start), s = r.substring(o + e.remainder, o + i.piece.length);
    for (i = i.next(); i !== Ue; ) {
      let a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (i === t.node) {
        s += a.substring(l, l + t.remainder);
        break;
      } else
        s += a.substr(l, i.piece.length);
      i = i.next();
    }
    return s;
  }
  getLinesContent() {
    let e = [], t = 0, i = "", r = !1;
    return this.iterate(this.root, (o) => {
      if (o === Ue)
        return !0;
      const s = o.piece;
      let a = s.length;
      if (a === 0)
        return !0;
      const l = this._buffers[s.bufferIndex].buffer, u = this._buffers[s.bufferIndex].lineStarts, c = s.start.line, h = s.end.line;
      let d = u[c] + s.start.column;
      if (r && (l.charCodeAt(d) === 10 && (d++, a--), e[t++] = i, i = "", r = !1, a === 0))
        return !0;
      if (c === h)
        return !this._EOLNormalized && l.charCodeAt(d + a - 1) === 13 ? (r = !0, i += l.substr(d, a - 1)) : i += l.substr(d, a), !0;
      i += this._EOLNormalized ? l.substring(d, Math.max(d, u[c + 1] - this._EOLLength)) : l.substring(d, u[c + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      for (let f = c + 1; f < h; f++)
        i = this._EOLNormalized ? l.substring(u[f], u[f + 1] - this._EOLLength) : l.substring(u[f], u[f + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      return !this._EOLNormalized && l.charCodeAt(u[h] + s.end.column - 1) === 13 ? (r = !0, s.end.column === 0 ? t-- : i = l.substr(u[h], s.end.column - 1)) : i = l.substr(u[h], s.end.column), !0;
    }), r && (e[t++] = i, i = ""), e[t++] = i, e;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(e) {
    return this._lastVisitedLine.lineNumber === e ? this._lastVisitedLine.value : (this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent(e) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength) : this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, ""), this._lastVisitedLine.value);
  }
  _getCharCode(e) {
    if (e.remainder === e.node.piece.length) {
      let t = e.node.next();
      if (!t)
        return 0;
      let i = this._buffers[t.piece.bufferIndex], r = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start);
      return i.buffer.charCodeAt(r);
    } else {
      let t = this._buffers[e.node.piece.bufferIndex], r = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder;
      return t.buffer.charCodeAt(r);
    }
  }
  getLineCharCode(e, t) {
    let i = this.nodeAt2(e, t + 1);
    return this._getCharCode(i);
  }
  getLineLength(e) {
    if (e === this.getLineCount()) {
      let t = this.getOffsetAt(e, 1);
      return this.getLength() - t;
    }
    return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength;
  }
  findMatchesInNode(e, t, i, r, o, s, a, l, u, c, h) {
    let d = this._buffers[e.piece.bufferIndex], f = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start), p = this.offsetInBuffer(e.piece.bufferIndex, o), g = this.offsetInBuffer(e.piece.bufferIndex, s), _, m = { line: 0, column: 0 }, v, C;
    t._wordSeparators ? (v = d.buffer.substring(p, g), C = (y) => y + p, t.reset(0)) : (v = d.buffer, C = (y) => y, t.reset(p));
    do
      if (_ = t.next(v), _) {
        if (C(_.index) >= g)
          return c;
        this.positionInBuffer(e, C(_.index) - f, m);
        let y = this.getLineFeedCnt(e.piece.bufferIndex, o, m), b = m.line === o.line ? m.column - o.column + r : m.column + 1, L = b + _[0].length;
        if (h[c++] = jh(new V(i + y, b, i + y, L), _, l), C(_.index) + _[0].length >= g || c >= u)
          return c;
      }
    while (_);
    return c;
  }
  findMatchesLineByLine(e, t, i, r) {
    const o = [];
    let s = 0;
    const a = new zm(t.wordSeparators, t.regex);
    let l = this.nodeAt2(e.startLineNumber, e.startColumn);
    if (l === null)
      return [];
    let u = this.nodeAt2(e.endLineNumber, e.endColumn);
    if (u === null)
      return [];
    let c = this.positionInBuffer(l.node, l.remainder), h = this.positionInBuffer(u.node, u.remainder);
    if (l.node === u.node)
      return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, c, h, t, i, r, s, o), o;
    let d = e.startLineNumber, f = l.node;
    for (; f !== u.node; ) {
      let g = this.getLineFeedCnt(f.piece.bufferIndex, c, f.piece.end);
      if (g >= 1) {
        let m = this._buffers[f.piece.bufferIndex].lineStarts, v = this.offsetInBuffer(f.piece.bufferIndex, f.piece.start), C = m[c.line + g], y = d === e.startLineNumber ? e.startColumn : 1;
        if (s = this.findMatchesInNode(f, a, d, y, c, this.positionInBuffer(f, C - v), t, i, r, s, o), s >= r)
          return o;
        d += g;
      }
      let _ = d === e.startLineNumber ? e.startColumn - 1 : 0;
      if (d === e.endLineNumber) {
        const m = this.getLineContent(d).substring(_, e.endColumn - 1);
        return s = this._findMatchesInLine(t, a, m, e.endLineNumber, _, s, o, i, r), o;
      }
      if (s = this._findMatchesInLine(t, a, this.getLineContent(d).substr(_), d, _, s, o, i, r), s >= r)
        return o;
      d++, l = this.nodeAt2(d, 1), f = l.node, c = this.positionInBuffer(l.node, l.remainder);
    }
    if (d === e.endLineNumber) {
      let g = d === e.startLineNumber ? e.startColumn - 1 : 0;
      const _ = this.getLineContent(d).substring(g, e.endColumn - 1);
      return s = this._findMatchesInLine(t, a, _, e.endLineNumber, g, s, o, i, r), o;
    }
    let p = d === e.startLineNumber ? e.startColumn : 1;
    return s = this.findMatchesInNode(u.node, a, d, p, c, h, t, i, r, s, o), o;
  }
  _findMatchesInLine(e, t, i, r, o, s, a, l, u) {
    const c = e.wordSeparators;
    if (!l && e.simpleSearch) {
      const d = e.simpleSearch, f = d.length, p = i.length;
      let g = -f;
      for (; (g = i.indexOf(d, g + f)) !== -1; )
        if ((!c || XN(c, i, p, g, f)) && (a[s++] = new zv(new V(r, g + 1 + o, r, g + 1 + f + o), null), s >= u))
          return s;
      return s;
    }
    let h;
    t.reset(0);
    do
      if (h = t.next(i), h && (a[s++] = jh(new V(r, h.index + 1 + o, r, h.index + 1 + h[0].length + o), h, l), s >= u))
        return s;
    while (h);
    return s;
  }
  // #endregion
  // #region Piece Table
  insert(e, t, i = !1) {
    if (this._EOLNormalized = this._EOLNormalized && i, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", this.root !== Ue) {
      let { node: r, remainder: o, nodeStartOffset: s } = this.nodeAt(e), a = r.piece, l = a.bufferIndex, u = this.positionInBuffer(r, o);
      if (r.piece.bufferIndex === 0 && a.end.line === this._lastChangeBufferPos.line && a.end.column === this._lastChangeBufferPos.column && s + a.length === e && t.length < pu) {
        this.appendToNode(r, t), this.computeBufferMetadata();
        return;
      }
      if (s === e)
        this.insertContentToNodeLeft(t, r), this._searchCache.validate(e);
      else if (s + r.piece.length > e) {
        let c = [], h = new fo(a.bufferIndex, u, a.end, this.getLineFeedCnt(a.bufferIndex, u, a.end), this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, u));
        if (this.shouldCheckCRLF() && this.endWithCR(t) && this.nodeCharCodeAt(r, o) === 10) {
          let g = { line: h.start.line + 1, column: 0 };
          h = new fo(h.bufferIndex, g, h.end, this.getLineFeedCnt(h.bufferIndex, g, h.end), h.length - 1), t += `
`;
        }
        if (this.shouldCheckCRLF() && this.startWithLF(t))
          if (this.nodeCharCodeAt(r, o - 1) === 13) {
            let g = this.positionInBuffer(r, o - 1);
            this.deleteNodeTail(r, g), t = "\r" + t, r.piece.length === 0 && c.push(r);
          } else
            this.deleteNodeTail(r, u);
        else
          this.deleteNodeTail(r, u);
        let d = this.createNewPieces(t);
        h.length > 0 && this.rbInsertRight(r, h);
        let f = r;
        for (let p = 0; p < d.length; p++)
          f = this.rbInsertRight(f, d[p]);
        this.deleteNodes(c);
      } else
        this.insertContentToNodeRight(t, r);
    } else {
      let r = this.createNewPieces(t), o = this.rbInsertLeft(null, r[0]);
      for (let s = 1; s < r.length; s++)
        o = this.rbInsertRight(o, r[s]);
    }
    this.computeBufferMetadata();
  }
  delete(e, t) {
    if (this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", t <= 0 || this.root === Ue)
      return;
    let i = this.nodeAt(e), r = this.nodeAt(e + t), o = i.node, s = r.node;
    if (o === s) {
      let d = this.positionInBuffer(o, i.remainder), f = this.positionInBuffer(o, r.remainder);
      if (i.nodeStartOffset === e) {
        if (t === o.piece.length) {
          let p = o.next();
          my(this, o), this.validateCRLFWithPrevNode(p), this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(o, f), this._searchCache.validate(e), this.validateCRLFWithPrevNode(o), this.computeBufferMetadata();
        return;
      }
      if (i.nodeStartOffset + o.piece.length === e + t) {
        this.deleteNodeTail(o, d), this.validateCRLFWithNextNode(o), this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(o, d, f), this.computeBufferMetadata();
      return;
    }
    let a = [], l = this.positionInBuffer(o, i.remainder);
    this.deleteNodeTail(o, l), this._searchCache.validate(e), o.piece.length === 0 && a.push(o);
    let u = this.positionInBuffer(s, r.remainder);
    this.deleteNodeHead(s, u), s.piece.length === 0 && a.push(s);
    let c = o.next();
    for (let d = c; d !== Ue && d !== s; d = d.next())
      a.push(d);
    let h = o.piece.length === 0 ? o.prev() : o;
    this.deleteNodes(a), this.validateCRLFWithNextNode(h), this.computeBufferMetadata();
  }
  insertContentToNodeLeft(e, t) {
    let i = [];
    if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
      let s = t.piece, a = { line: s.start.line + 1, column: 0 }, l = new fo(s.bufferIndex, a, s.end, this.getLineFeedCnt(s.bufferIndex, a, s.end), s.length - 1);
      t.piece = l, e += `
`, Cu(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    }
    let r = this.createNewPieces(e), o = this.rbInsertLeft(t, r[r.length - 1]);
    for (let s = r.length - 2; s >= 0; s--)
      o = this.rbInsertLeft(o, r[s]);
    this.validateCRLFWithPrevNode(o), this.deleteNodes(i);
  }
  insertContentToNodeRight(e, t) {
    this.adjustCarriageReturnFromNext(e, t) && (e += `
`);
    let i = this.createNewPieces(e), r = this.rbInsertRight(t, i[0]), o = r;
    for (let s = 1; s < i.length; s++)
      o = this.rbInsertRight(o, i[s]);
    this.validateCRLFWithPrevNode(r);
  }
  positionInBuffer(e, t, i) {
    let r = e.piece, o = e.piece.bufferIndex, s = this._buffers[o].lineStarts, l = s[r.start.line] + r.start.column + t, u = r.start.line, c = r.end.line, h = 0, d = 0, f = 0;
    for (; u <= c && (h = u + (c - u) / 2 | 0, f = s[h], h !== c); )
      if (d = s[h + 1], l < f)
        c = h - 1;
      else if (l >= d)
        u = h + 1;
      else
        break;
    return i ? (i.line = h, i.column = l - f, null) : {
      line: h,
      column: l - f
    };
  }
  getLineFeedCnt(e, t, i) {
    if (i.column === 0)
      return i.line - t.line;
    let r = this._buffers[e].lineStarts;
    if (i.line === r.length - 1)
      return i.line - t.line;
    let o = r[i.line + 1], s = r[i.line] + i.column;
    if (o > s + 1)
      return i.line - t.line;
    let a = s - 1;
    return this._buffers[e].buffer.charCodeAt(a) === 13 ? i.line - t.line + 1 : i.line - t.line;
  }
  offsetInBuffer(e, t) {
    return this._buffers[e].lineStarts[t.line] + t.column;
  }
  deleteNodes(e) {
    for (let t = 0; t < e.length; t++)
      my(this, e[t]);
  }
  createNewPieces(e) {
    if (e.length > pu) {
      let c = [];
      for (; e.length > pu; ) {
        const d = e.charCodeAt(pu - 1);
        let f;
        d === 13 || d >= 55296 && d <= 56319 ? (f = e.substring(0, pu - 1), e = e.substring(pu - 1)) : (f = e.substring(0, pu), e = e.substring(pu));
        let p = wu(f);
        c.push(new fo(
          this._buffers.length,
          /* buffer index */
          { line: 0, column: 0 },
          { line: p.length - 1, column: f.length - p[p.length - 1] },
          p.length - 1,
          f.length
        )), this._buffers.push(new $h(f, p));
      }
      let h = wu(e);
      return c.push(new fo(
        this._buffers.length,
        /* buffer index */
        { line: 0, column: 0 },
        { line: h.length - 1, column: e.length - h[h.length - 1] },
        h.length - 1,
        e.length
      )), this._buffers.push(new $h(e, h)), c;
    }
    let t = this._buffers[0].buffer.length;
    const i = wu(e, !1);
    let r = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t && t !== 0 && this.startWithLF(e) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 }, r = this._lastChangeBufferPos;
      for (let c = 0; c < i.length; c++)
        i[c] += t + 1;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += "_" + e, t += 1;
    } else {
      if (t !== 0)
        for (let c = 0; c < i.length; c++)
          i[c] += t;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += e;
    }
    const o = this._buffers[0].buffer.length;
    let s = this._buffers[0].lineStarts.length - 1, a = o - this._buffers[0].lineStarts[s], l = { line: s, column: a }, u = new fo(
      0,
      /** todo@peng */
      r,
      l,
      this.getLineFeedCnt(0, r, l),
      o - t
    );
    return this._lastChangeBufferPos = l, [u];
  }
  getLineRawContent(e, t = 0) {
    let i = this.root, r = "", o = this._searchCache.get2(e);
    if (o) {
      i = o.node;
      let s = this.getAccumulatedValue(i, e - o.nodeStartLineNumber - 1), a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (o.nodeStartLineNumber + i.piece.lineFeedCnt === e)
        r = a.substring(l + s, l + i.piece.length);
      else {
        let u = this.getAccumulatedValue(i, e - o.nodeStartLineNumber);
        return a.substring(l + s, l + u - t);
      }
    } else {
      let s = 0;
      const a = e;
      for (; i !== Ue; )
        if (i.left !== Ue && i.lf_left >= e - 1)
          i = i.left;
        else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
          let l = this.getAccumulatedValue(i, e - i.lf_left - 2), u = this.getAccumulatedValue(i, e - i.lf_left - 1), c = this._buffers[i.piece.bufferIndex].buffer, h = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          return s += i.size_left, this._searchCache.set({
            node: i,
            nodeStartOffset: s,
            nodeStartLineNumber: a - (e - 1 - i.lf_left)
          }), c.substring(h + l, h + u - t);
        } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
          let l = this.getAccumulatedValue(i, e - i.lf_left - 2), u = this._buffers[i.piece.bufferIndex].buffer, c = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          r = u.substring(c + l, c + i.piece.length);
          break;
        } else
          e -= i.lf_left + i.piece.lineFeedCnt, s += i.size_left + i.piece.length, i = i.right;
    }
    for (i = i.next(); i !== Ue; ) {
      let s = this._buffers[i.piece.bufferIndex].buffer;
      if (i.piece.lineFeedCnt > 0) {
        let a = this.getAccumulatedValue(i, 0), l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        return r += s.substring(l, l + a - t), r;
      } else {
        let a = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        r += s.substr(a, i.piece.length);
      }
      i = i.next();
    }
    return r;
  }
  computeBufferMetadata() {
    let e = this.root, t = 1, i = 0;
    for (; e !== Ue; )
      t += e.lf_left + e.piece.lineFeedCnt, i += e.size_left + e.piece.length, e = e.right;
    this._lineCnt = t, this._length = i, this._searchCache.validate(this._length);
  }
  // #region node operations
  getIndexOf(e, t) {
    let i = e.piece, r = this.positionInBuffer(e, t), o = r.line - i.start.line;
    if (this.offsetInBuffer(i.bufferIndex, i.end) - this.offsetInBuffer(i.bufferIndex, i.start) === t) {
      let s = this.getLineFeedCnt(e.piece.bufferIndex, i.start, r);
      if (s !== o)
        return { index: s, remainder: 0 };
    }
    return { index: o, remainder: r.column };
  }
  getAccumulatedValue(e, t) {
    if (t < 0)
      return 0;
    let i = e.piece, r = this._buffers[i.bufferIndex].lineStarts, o = i.start.line + t + 1;
    return o > i.end.line ? r[i.end.line] + i.end.column - r[i.start.line] - i.start.column : r[o] - r[i.start.line] - i.start.column;
  }
  deleteNodeTail(e, t) {
    const i = e.piece, r = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.end), s = t, a = this.offsetInBuffer(i.bufferIndex, s), l = this.getLineFeedCnt(i.bufferIndex, i.start, s), u = l - r, c = a - o, h = i.length + c;
    e.piece = new fo(i.bufferIndex, i.start, s, l, h), Cu(this, e, c, u);
  }
  deleteNodeHead(e, t) {
    const i = e.piece, r = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.start), s = t, a = this.getLineFeedCnt(i.bufferIndex, s, i.end), l = this.offsetInBuffer(i.bufferIndex, s), u = a - r, c = o - l, h = i.length + c;
    e.piece = new fo(i.bufferIndex, s, i.end, a, h), Cu(this, e, c, u);
  }
  shrinkNode(e, t, i) {
    const r = e.piece, o = r.start, s = r.end, a = r.length, l = r.lineFeedCnt, u = t, c = this.getLineFeedCnt(r.bufferIndex, r.start, u), h = this.offsetInBuffer(r.bufferIndex, t) - this.offsetInBuffer(r.bufferIndex, o);
    e.piece = new fo(r.bufferIndex, r.start, u, c, h), Cu(this, e, h - a, c - l);
    let d = new fo(r.bufferIndex, i, s, this.getLineFeedCnt(r.bufferIndex, i, s), this.offsetInBuffer(r.bufferIndex, s) - this.offsetInBuffer(r.bufferIndex, i)), f = this.rbInsertRight(e, d);
    this.validateCRLFWithPrevNode(f);
  }
  appendToNode(e, t) {
    this.adjustCarriageReturnFromNext(t, e) && (t += `
`);
    const i = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e), r = this._buffers[0].buffer.length;
    this._buffers[0].buffer += t;
    const o = wu(t, !1);
    for (let f = 0; f < o.length; f++)
      o[f] += r;
    if (i) {
      let f = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: r - f };
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(o.slice(1));
    const s = this._buffers[0].lineStarts.length - 1, a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[s], l = { line: s, column: a }, u = e.piece.length + t.length, c = e.piece.lineFeedCnt, h = this.getLineFeedCnt(0, e.piece.start, l), d = h - c;
    e.piece = new fo(e.piece.bufferIndex, e.piece.start, l, h, u), this._lastChangeBufferPos = l, Cu(this, e, t.length, d);
  }
  nodeAt(e) {
    let t = this.root, i = this._searchCache.get(e);
    if (i)
      return {
        node: i.node,
        nodeStartOffset: i.nodeStartOffset,
        remainder: e - i.nodeStartOffset
      };
    let r = 0;
    for (; t !== Ue; )
      if (t.size_left > e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        r += t.size_left;
        let o = {
          node: t,
          remainder: e - t.size_left,
          nodeStartOffset: r
        };
        return this._searchCache.set(o), o;
      } else
        e -= t.size_left + t.piece.length, r += t.size_left + t.piece.length, t = t.right;
    return null;
  }
  nodeAt2(e, t) {
    let i = this.root, r = 0;
    for (; i !== Ue; )
      if (i.left !== Ue && i.lf_left >= e - 1)
        i = i.left;
      else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
        let o = this.getAccumulatedValue(i, e - i.lf_left - 2), s = this.getAccumulatedValue(i, e - i.lf_left - 1);
        return r += i.size_left, {
          node: i,
          remainder: Math.min(o + t - 1, s),
          nodeStartOffset: r
        };
      } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
        let o = this.getAccumulatedValue(i, e - i.lf_left - 2);
        if (o + t - 1 <= i.piece.length)
          return {
            node: i,
            remainder: o + t - 1,
            nodeStartOffset: r
          };
        t -= i.piece.length - o;
        break;
      } else
        e -= i.lf_left + i.piece.lineFeedCnt, r += i.size_left + i.piece.length, i = i.right;
    for (i = i.next(); i !== Ue; ) {
      if (i.piece.lineFeedCnt > 0) {
        let o = this.getAccumulatedValue(i, 0), s = this.offsetOfNode(i);
        return {
          node: i,
          remainder: Math.min(t - 1, o),
          nodeStartOffset: s
        };
      } else if (i.piece.length >= t - 1) {
        let o = this.offsetOfNode(i);
        return {
          node: i,
          remainder: t - 1,
          nodeStartOffset: o
        };
      } else
        t -= i.piece.length;
      i = i.next();
    }
    return null;
  }
  nodeCharCodeAt(e, t) {
    if (e.piece.lineFeedCnt < 1)
      return -1;
    let i = this._buffers[e.piece.bufferIndex], r = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t;
    return i.buffer.charCodeAt(r);
  }
  offsetOfNode(e) {
    if (!e)
      return 0;
    let t = e.size_left;
    for (; e !== this.root; )
      e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), e = e.parent;
    return t;
  }
  // #endregion
  // #region CRLF
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === `
`);
  }
  startWithLF(e) {
    if (typeof e == "string")
      return e.charCodeAt(0) === 10;
    if (e === Ue || e.piece.lineFeedCnt === 0)
      return !1;
    let t = e.piece, i = this._buffers[t.bufferIndex].lineStarts, r = t.start.line, o = i[r] + t.start.column;
    return r === i.length - 1 || i[r + 1] > o + 1 ? !1 : this._buffers[t.bufferIndex].buffer.charCodeAt(o) === 10;
  }
  endWithCR(e) {
    return typeof e == "string" ? e.charCodeAt(e.length - 1) === 13 : e === Ue || e.piece.lineFeedCnt === 0 ? !1 : this.nodeCharCodeAt(e, e.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(e) {
    if (this.shouldCheckCRLF() && this.startWithLF(e)) {
      let t = e.prev();
      this.endWithCR(t) && this.fixCRLF(t, e);
    }
  }
  validateCRLFWithNextNode(e) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      let t = e.next();
      this.startWithLF(t) && this.fixCRLF(e, t);
    }
  }
  fixCRLF(e, t) {
    let i = [], r = this._buffers[e.piece.bufferIndex].lineStarts, o;
    e.piece.end.column === 0 ? o = { line: e.piece.end.line - 1, column: r[e.piece.end.line] - r[e.piece.end.line - 1] - 1 } : o = { line: e.piece.end.line, column: e.piece.end.column - 1 };
    const s = e.piece.length - 1, a = e.piece.lineFeedCnt - 1;
    e.piece = new fo(e.piece.bufferIndex, e.piece.start, o, a, s), Cu(this, e, -1, -1), e.piece.length === 0 && i.push(e);
    let l = { line: t.piece.start.line + 1, column: 0 };
    const u = t.piece.length - 1, c = this.getLineFeedCnt(t.piece.bufferIndex, l, t.piece.end);
    t.piece = new fo(t.piece.bufferIndex, l, t.piece.end, c, u), Cu(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    let h = this.createNewPieces(`\r
`);
    this.rbInsertRight(e, h[0]);
    for (let d = 0; d < i.length; d++)
      my(this, i[d]);
  }
  adjustCarriageReturnFromNext(e, t) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      let i = t.next();
      if (this.startWithLF(i)) {
        if (e += `
`, i.piece.length === 1)
          my(this, i);
        else {
          const r = i.piece, o = { line: r.start.line + 1, column: 0 }, s = r.length - 1, a = this.getLineFeedCnt(r.bufferIndex, o, r.end);
          i.piece = new fo(r.bufferIndex, o, r.end, a, s), Cu(this, i, -1, -1);
        }
        return !0;
      }
    }
    return !1;
  }
  // #endregion
  // #endregion
  // #region Tree operations
  iterate(e, t) {
    if (e === Ue)
      return t(Ue);
    let i = this.iterate(e.left, t);
    return i && t(e) && this.iterate(e.right, t);
  }
  getNodeContent(e) {
    if (e === Ue)
      return "";
    let t = this._buffers[e.piece.bufferIndex], i, r = e.piece, o = this.offsetInBuffer(r.bufferIndex, r.start), s = this.offsetInBuffer(r.bufferIndex, r.end);
    return i = t.buffer.substring(o, s), i;
  }
  getPieceContent(e) {
    let t = this._buffers[e.bufferIndex], i = this.offsetInBuffer(e.bufferIndex, e.start), r = this.offsetInBuffer(e.bufferIndex, e.end);
    return t.buffer.substring(i, r);
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b    <----   a    b
   *                         /
   *                        z
   */
  rbInsertRight(e, t) {
    let i = new PT(
      t,
      1
      /* Red */
    );
    if (i.left = Ue, i.right = Ue, i.parent = Ue, i.size_left = 0, i.lf_left = 0, this.root === Ue)
      this.root = i, i.color = 0;
    else if (e.right === Ue)
      e.right = i, i.parent = e;
    else {
      let o = KN(e.right);
      o.left = i, i.parent = o;
    }
    return $k(this, i), i;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b     ---->   a    b
   *                       \
   *                        z
   */
  rbInsertLeft(e, t) {
    let i = new PT(
      t,
      1
      /* Red */
    );
    if (i.left = Ue, i.right = Ue, i.parent = Ue, i.size_left = 0, i.lf_left = 0, this.root === Ue)
      this.root = i, i.color = 0;
    else if (e.left === Ue)
      e.left = i, i.parent = e;
    else {
      let r = i3(e.left);
      r.right = i, i.parent = r;
    }
    return $k(this, i), i;
  }
}
function Zv(n) {
  let e = 0, t = 0, i = 0, r = 0;
  for (let o = 0, s = n.length; o < s; o++) {
    const a = n.charCodeAt(o);
    a === 13 ? (e === 0 && (t = o), e++, o + 1 < s && n.charCodeAt(o + 1) === 10 ? (r |= 2, o++) : r |= 3, i = o + 1) : a === 10 && (r |= 1, e === 0 && (t = o), e++, i = o + 1);
  }
  return e === 0 && (t = n.length), [e, t, n.length - i, r];
}
function qk(n) {
  return (n << 0 | 0 << 8 | 0 << 11 | 1 << 14 | 2 << 23) >>> 0;
}
const gu = new Uint32Array(0).buffer;
class _D {
  constructor() {
    this.tokens = [];
  }
  add(e, t) {
    if (this.tokens.length > 0) {
      const i = this.tokens[this.tokens.length - 1];
      if (i.startLineNumber + i.tokens.length - 1 + 1 === e) {
        i.tokens.push(t);
        return;
      }
    }
    this.tokens.push(new Ile(e, [t]));
  }
}
class xb {
  constructor(e) {
    this._tokens = e, this._tokenCount = e.length / 4;
  }
  toString(e) {
    let t = [];
    for (let i = 0; i < this._tokenCount; i++)
      t.push(`(${this._getDeltaLine(i) + e},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);
    return `[${t.join(",")}]`;
  }
  getMaxDeltaLine() {
    const e = this._getTokenCount();
    return e === 0 ? -1 : this._getDeltaLine(e - 1);
  }
  getRange() {
    const e = this._getTokenCount();
    if (e === 0)
      return null;
    const t = this._getStartCharacter(0), i = this._getDeltaLine(e - 1), r = this._getEndCharacter(e - 1);
    return new V(0, t + 1, i, r + 1);
  }
  _getTokenCount() {
    return this._tokenCount;
  }
  _getDeltaLine(e) {
    return this._tokens[4 * e];
  }
  _getStartCharacter(e) {
    return this._tokens[4 * e + 1];
  }
  _getEndCharacter(e) {
    return this._tokens[4 * e + 2];
  }
  isEmpty() {
    return this._getTokenCount() === 0;
  }
  getLineTokens(e) {
    let t = 0, i = this._getTokenCount() - 1;
    for (; t < i; ) {
      const r = t + Math.floor((i - t) / 2), o = this._getDeltaLine(r);
      if (o < e)
        t = r + 1;
      else if (o > e)
        i = r - 1;
      else {
        let s = r;
        for (; s > t && this._getDeltaLine(s - 1) === e; )
          s--;
        let a = r;
        for (; a < i && this._getDeltaLine(a + 1) === e; )
          a++;
        return new Yk(this._tokens.subarray(4 * s, 4 * a + 4));
      }
    }
    return this._getDeltaLine(t) === e ? new Yk(this._tokens.subarray(4 * t, 4 * t + 4)) : null;
  }
  clear() {
    this._tokenCount = 0;
  }
  removeTokens(e, t, i, r) {
    const o = this._tokens, s = this._tokenCount;
    let a = 0, l = !1, u = 0;
    for (let c = 0; c < s; c++) {
      const h = 4 * c, d = o[h], f = o[h + 1], p = o[h + 2], g = o[h + 3];
      if ((d > e || d === e && p >= t) && (d < i || d === i && f <= r))
        l = !0;
      else {
        if (a === 0 && (u = d), l) {
          const _ = 4 * a;
          o[_] = d - u, o[_ + 1] = f, o[_ + 2] = p, o[_ + 3] = g;
        }
        a++;
      }
    }
    return this._tokenCount = a, u;
  }
  split(e, t, i, r) {
    const o = this._tokens, s = this._tokenCount;
    let a = [], l = [], u = a, c = 0, h = 0;
    for (let d = 0; d < s; d++) {
      const f = 4 * d, p = o[f], g = o[f + 1], _ = o[f + 2], m = o[f + 3];
      if (p > e || p === e && _ >= t) {
        if (p < i || p === i && g <= r)
          continue;
        u !== l && (u = l, c = 0, h = p);
      }
      u[c++] = p - h, u[c++] = g, u[c++] = _, u[c++] = m;
    }
    return [new xb(new Uint32Array(a)), new xb(new Uint32Array(l)), h];
  }
  acceptDeleteRange(e, t, i, r, o) {
    const s = this._tokens, a = this._tokenCount, l = r - t;
    let u = 0, c = !1;
    for (let h = 0; h < a; h++) {
      const d = 4 * h;
      let f = s[d], p = s[d + 1], g = s[d + 2];
      const _ = s[d + 3];
      if (f < t || f === t && g <= i) {
        u++;
        continue;
      } else if (f === t && p < i)
        f === r && g > o ? g -= o - i : g = i;
      else if (f === t && p === i)
        if (f === r && g > o)
          g -= o - i;
        else {
          c = !0;
          continue;
        }
      else if (f < r || f === r && p < o)
        if (f === r && g > o)
          f === t ? (p = i, g = p + (g - o)) : (p = 0, g = p + (g - o));
        else {
          c = !0;
          continue;
        }
      else if (f > r) {
        if (l === 0 && !c) {
          u = a;
          break;
        }
        f -= l;
      } else if (f === r && p >= o)
        e && f === 0 && (p += e, g += e), f -= l, p -= o - i, g -= o - i;
      else
        throw new Error("Not possible!");
      const m = 4 * u;
      s[m] = f, s[m + 1] = p, s[m + 2] = g, s[m + 3] = _, u++;
    }
    this._tokenCount = u;
  }
  acceptInsertText(e, t, i, r, o, s) {
    const a = i === 0 && r === 1 && (s >= 48 && s <= 57 || s >= 65 && s <= 90 || s >= 97 && s <= 122), l = this._tokens, u = this._tokenCount;
    for (let c = 0; c < u; c++) {
      const h = 4 * c;
      let d = l[h], f = l[h + 1], p = l[h + 2];
      if (!(d < e || d === e && p < t)) {
        if (d === e && p === t)
          if (a)
            p += 1;
          else
            continue;
        else if (d === e && f < t && t < p)
          i === 0 ? p += r : p = t;
        else {
          if (d === e && f === t && a)
            continue;
          if (d === e)
            if (d += i, i === 0)
              f += r, p += r;
            else {
              const g = p - f;
              f = o + (f - t), p = f + g;
            }
          else
            d += i;
        }
        l[h] = d, l[h + 1] = f, l[h + 2] = p;
      }
    }
  }
}
class Yk {
  constructor(e) {
    this._tokens = e;
  }
  getCount() {
    return this._tokens.length / 4;
  }
  getStartCharacter(e) {
    return this._tokens[4 * e + 1];
  }
  getEndCharacter(e) {
    return this._tokens[4 * e + 2];
  }
  getMetadata(e) {
    return this._tokens[4 * e + 3];
  }
}
class Nb {
  constructor(e, t) {
    this.startLineNumber = e, this.tokens = t, this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();
  }
  toString() {
    return this.tokens.toString(this.startLineNumber);
  }
  _updateEndLineNumber() {
    this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();
  }
  isEmpty() {
    return this.tokens.isEmpty();
  }
  getLineTokens(e) {
    return this.startLineNumber <= e && e <= this.endLineNumber ? this.tokens.getLineTokens(e - this.startLineNumber) : null;
  }
  getRange() {
    const e = this.tokens.getRange();
    return e && new V(this.startLineNumber + e.startLineNumber, e.startColumn, this.startLineNumber + e.endLineNumber, e.endColumn);
  }
  removeTokens(e) {
    const t = e.startLineNumber - this.startLineNumber, i = e.endLineNumber - this.startLineNumber;
    this.startLineNumber += this.tokens.removeTokens(t, e.startColumn - 1, i, e.endColumn - 1), this._updateEndLineNumber();
  }
  split(e) {
    const t = e.startLineNumber - this.startLineNumber, i = e.endLineNumber - this.startLineNumber, [r, o, s] = this.tokens.split(t, e.startColumn - 1, i, e.endColumn - 1);
    return [new Nb(this.startLineNumber, r), new Nb(this.startLineNumber + s, o)];
  }
  applyEdit(e, t) {
    const [i, r, o] = Zv(t);
    this.acceptEdit(
      e,
      i,
      r,
      o,
      t.length > 0 ? t.charCodeAt(0) : 0
      /* Null */
    );
  }
  acceptEdit(e, t, i, r, o) {
    this._acceptDeleteRange(e), this._acceptInsertText(new J(e.startLineNumber, e.startColumn), t, i, r, o), this._updateEndLineNumber();
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return;
    const t = e.startLineNumber - this.startLineNumber, i = e.endLineNumber - this.startLineNumber;
    if (i < 0) {
      const o = i - t;
      this.startLineNumber -= o;
      return;
    }
    const r = this.tokens.getMaxDeltaLine();
    if (!(t >= r + 1)) {
      if (t < 0 && i >= r + 1) {
        this.startLineNumber = 0, this.tokens.clear();
        return;
      }
      if (t < 0) {
        const o = -t;
        this.startLineNumber -= o, this.tokens.acceptDeleteRange(e.startColumn - 1, 0, 0, i, e.endColumn - 1);
      } else
        this.tokens.acceptDeleteRange(0, t, e.startColumn - 1, i, e.endColumn - 1);
    }
  }
  _acceptInsertText(e, t, i, r, o) {
    if (t === 0 && i === 0)
      return;
    const s = e.lineNumber - this.startLineNumber;
    if (s < 0) {
      this.startLineNumber += t;
      return;
    }
    const a = this.tokens.getMaxDeltaLine();
    s >= a + 1 || this.tokens.acceptInsertText(s, e.column - 1, t, i, r, o);
  }
}
class Ile {
  constructor(e, t) {
    this.startLineNumber = e, this.tokens = t;
  }
}
function mu(n) {
  return n instanceof Uint32Array ? n : new Uint32Array(n);
}
class ZN {
  constructor() {
    this._pieces = [], this._isComplete = !1;
  }
  flush() {
    this._pieces = [], this._isComplete = !1;
  }
  isEmpty() {
    return this._pieces.length === 0;
  }
  set(e, t) {
    this._pieces = e || [], this._isComplete = t;
  }
  setPartial(e, t) {
    let i = e;
    if (t.length > 0) {
      const o = t[0].getRange(), s = t[t.length - 1].getRange();
      if (!o || !s)
        return e;
      i = e.plusRange(o).plusRange(s);
    }
    let r = null;
    for (let o = 0, s = this._pieces.length; o < s; o++) {
      const a = this._pieces[o];
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        r = r || { index: o };
        break;
      }
      if (a.removeTokens(i), a.isEmpty()) {
        this._pieces.splice(o, 1), o--, s--;
        continue;
      }
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        r = r || { index: o };
        continue;
      }
      const [l, u] = a.split(i);
      if (l.isEmpty()) {
        r = r || { index: o };
        continue;
      }
      u.isEmpty() || (this._pieces.splice(o, 1, l, u), o++, s++, r = r || { index: o });
    }
    return r = r || { index: this._pieces.length }, t.length > 0 && (this._pieces = $v(this._pieces, r.index, t)), i;
  }
  isComplete() {
    return this._isComplete;
  }
  addSemanticTokens(e, t) {
    const i = this._pieces;
    if (i.length === 0)
      return t;
    const r = ZN._findFirstPieceWithLine(i, e), o = i[r].getLineTokens(e);
    if (!o)
      return t;
    const s = t.getCount(), a = o.getCount();
    let l = 0, u = [], c = 0, h = 0;
    const d = (f, p) => {
      f !== h && (h = f, u[c++] = f, u[c++] = p);
    };
    for (let f = 0; f < a; f++) {
      const p = o.getStartCharacter(f), g = o.getEndCharacter(f), _ = o.getMetadata(f), m = ((_ & 1 ? 2048 : 0) | (_ & 2 ? 4096 : 0) | (_ & 4 ? 8192 : 0) | (_ & 8 ? 8372224 : 0) | (_ & 16 ? 4286578688 : 0)) >>> 0, v = ~m >>> 0;
      for (; l < s && t.getEndOffset(l) <= p; )
        d(t.getEndOffset(l), t.getMetadata(l)), l++;
      for (l < s && t.getStartOffset(l) < p && d(p, t.getMetadata(l)); l < s && t.getEndOffset(l) < g; )
        d(t.getEndOffset(l), t.getMetadata(l) & v | _ & m), l++;
      if (l < s)
        d(g, t.getMetadata(l) & v | _ & m), t.getEndOffset(l) === g && l++;
      else {
        const C = Math.min(Math.max(0, l - 1), s - 1);
        d(g, t.getMetadata(C) & v | _ & m);
      }
    }
    for (; l < s; )
      d(t.getEndOffset(l), t.getMetadata(l)), l++;
    return new Zr(new Uint32Array(u), t.getLineContent());
  }
  static _findFirstPieceWithLine(e, t) {
    let i = 0, r = e.length - 1;
    for (; i < r; ) {
      let o = i + Math.floor((r - i) / 2);
      if (e[o].endLineNumber < t)
        i = o + 1;
      else if (e[o].startLineNumber > t)
        r = o - 1;
      else {
        for (; o > i && e[o - 1].startLineNumber <= t && t <= e[o - 1].endLineNumber; )
          o--;
        return o;
      }
    }
    return i;
  }
  //#region Editing
  acceptEdit(e, t, i, r, o) {
    for (const s of this._pieces)
      s.acceptEdit(e, t, i, r, o);
  }
}
class ls {
  constructor() {
    this._lineTokens = [], this._len = 0;
  }
  flush() {
    this._lineTokens = [], this._len = 0;
  }
  getTokens(e, t, i) {
    let r = null;
    if (t < this._len && (r = this._lineTokens[t]), r !== null && r !== gu)
      return new Zr(mu(r), i);
    let o = new Uint32Array(2);
    return o[0] = i.length, o[1] = qk(e), new Zr(o, i);
  }
  static _massageTokens(e, t, i) {
    const r = i ? mu(i) : null;
    if (t === 0) {
      let o = !1;
      if (r && r.length > 1 && (o = ra.getLanguageId(r[1]) !== e), !o)
        return gu;
    }
    if (!r || r.length === 0) {
      const o = new Uint32Array(2);
      return o[0] = t, o[1] = qk(e), o.buffer;
    }
    return r[r.length - 2] = t, r.byteOffset === 0 && r.byteLength === r.buffer.byteLength ? r.buffer : r;
  }
  _ensureLine(e) {
    for (; e >= this._len; )
      this._lineTokens[this._len] = null, this._len++;
  }
  _deleteLines(e, t) {
    t !== 0 && (e + t > this._len && (t = this._len - e), this._lineTokens.splice(e, t), this._len -= t);
  }
  _insertLines(e, t) {
    if (t === 0)
      return;
    let i = [];
    for (let r = 0; r < t; r++)
      i[r] = null;
    this._lineTokens = $v(this._lineTokens, e, i), this._len += t;
  }
  setTokens(e, t, i, r, o) {
    const s = ls._massageTokens(e, i, r);
    this._ensureLine(t);
    const a = this._lineTokens[t];
    return this._lineTokens[t] = s, o ? !ls._equals(a, s) : !1;
  }
  static _equals(e, t) {
    if (!e || !t)
      return !e && !t;
    const i = mu(e), r = mu(t);
    if (i.length !== r.length)
      return !1;
    for (let o = 0, s = i.length; o < s; o++)
      if (i[o] !== r[o])
        return !1;
    return !0;
  }
  //#region Editing
  acceptEdit(e, t, i) {
    this._acceptDeleteRange(e), this._acceptInsertText(new J(e.startLineNumber, e.startColumn), t, i);
  }
  _acceptDeleteRange(e) {
    const t = e.startLineNumber - 1;
    if (t >= this._len)
      return;
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._lineTokens[t] = ls._delete(this._lineTokens[t], e.startColumn - 1, e.endColumn - 1);
      return;
    }
    this._lineTokens[t] = ls._deleteEnding(this._lineTokens[t], e.startColumn - 1);
    const i = e.endLineNumber - 1;
    let r = null;
    i < this._len && (r = ls._deleteBeginning(this._lineTokens[i], e.endColumn - 1)), this._lineTokens[t] = ls._append(this._lineTokens[t], r), this._deleteLines(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t, i) {
    if (t === 0 && i === 0)
      return;
    const r = e.lineNumber - 1;
    if (!(r >= this._len)) {
      if (t === 0) {
        this._lineTokens[r] = ls._insert(this._lineTokens[r], e.column - 1, i);
        return;
      }
      this._lineTokens[r] = ls._deleteEnding(this._lineTokens[r], e.column - 1), this._lineTokens[r] = ls._insert(this._lineTokens[r], e.column - 1, i), this._insertLines(e.lineNumber, t);
    }
  }
  static _deleteBeginning(e, t) {
    return e === null || e === gu ? e : ls._delete(e, 0, t);
  }
  static _deleteEnding(e, t) {
    if (e === null || e === gu)
      return e;
    const i = mu(e), r = i[i.length - 2];
    return ls._delete(e, t, r);
  }
  static _delete(e, t, i) {
    if (e === null || e === gu || t === i)
      return e;
    const r = mu(e), o = r.length >>> 1;
    if (t === 0 && r[r.length - 2] === i)
      return gu;
    const s = Zr.findIndexInTokensArray(r, t), a = s > 0 ? r[s - 1 << 1] : 0, l = r[s << 1];
    if (i < l) {
      const f = i - t;
      for (let p = s; p < o; p++)
        r[p << 1] -= f;
      return e;
    }
    let u, c;
    a !== t ? (r[s << 1] = t, u = s + 1 << 1, c = t) : (u = s << 1, c = a);
    const h = i - t;
    for (let f = s + 1; f < o; f++) {
      const p = r[f << 1] - h;
      p > c && (r[u++] = p, r[u++] = r[(f << 1) + 1], c = p);
    }
    if (u === r.length)
      return e;
    let d = new Uint32Array(u);
    return d.set(r.subarray(0, u), 0), d.buffer;
  }
  static _append(e, t) {
    if (t === gu)
      return e;
    if (e === gu)
      return t;
    if (e === null)
      return e;
    if (t === null)
      return null;
    const i = mu(e), r = mu(t), o = r.length >>> 1;
    let s = new Uint32Array(i.length + r.length);
    s.set(i, 0);
    let a = i.length;
    const l = i[i.length - 2];
    for (let u = 0; u < o; u++)
      s[a++] = r[u << 1] + l, s[a++] = r[(u << 1) + 1];
    return s.buffer;
  }
  static _insert(e, t, i) {
    if (e === null || e === gu)
      return e;
    const r = mu(e), o = r.length >>> 1;
    let s = Zr.findIndexInTokensArray(r, t);
    s > 0 && r[s - 1 << 1] === t && s--;
    for (let a = s; a < o; a++)
      r[a << 1] += i;
    return e;
  }
}
class yp extends ge {
  constructor(e, t, i, r, o, s, a) {
    super(), this._onDidChangeContent = this._register(new j()), this._BOM = t, this._mightContainNonBasicASCII = !s, this._mightContainRTL = r, this._mightContainUnusualLineTerminators = o, this._pieceTree = new Nle(e, i, a);
  }
  mightContainRTL() {
    return this._mightContainRTL;
  }
  mightContainUnusualLineTerminators() {
    return this._mightContainUnusualLineTerminators;
  }
  resetMightContainUnusualLineTerminators() {
    this._mightContainUnusualLineTerminators = !1;
  }
  mightContainNonBasicASCII() {
    return this._mightContainNonBasicASCII;
  }
  getBOM() {
    return this._BOM;
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  createSnapshot(e) {
    return this._pieceTree.createSnapshot(e ? this._BOM : "");
  }
  getOffsetAt(e, t) {
    return this._pieceTree.getOffsetAt(e, t);
  }
  getPositionAt(e) {
    return this._pieceTree.getPositionAt(e);
  }
  getRangeAt(e, t) {
    let i = e + t;
    const r = this.getPositionAt(e), o = this.getPositionAt(i);
    return new V(r.lineNumber, r.column, o.lineNumber, o.column);
  }
  getValueInRange(e, t = 0) {
    if (e.isEmpty())
      return "";
    const i = this._getEndOfLine(t);
    return this._pieceTree.getValueInRange(e, i);
  }
  getValueLengthInRange(e, t = 0) {
    if (e.isEmpty())
      return 0;
    if (e.startLineNumber === e.endLineNumber)
      return e.endColumn - e.startColumn;
    let i = this.getOffsetAt(e.startLineNumber, e.startColumn);
    return this.getOffsetAt(e.endLineNumber, e.endColumn) - i;
  }
  getCharacterCountInRange(e, t = 0) {
    if (this._mightContainNonBasicASCII) {
      let i = 0;
      const r = e.startLineNumber, o = e.endLineNumber;
      for (let s = r; s <= o; s++) {
        const a = this.getLineContent(s), l = s === r ? e.startColumn - 1 : 0, u = s === o ? e.endColumn - 1 : a.length;
        for (let c = l; c < u; c++)
          jn(a.charCodeAt(c)) ? (i = i + 1, c = c + 1) : i = i + 1;
      }
      return i += this._getEndOfLine(t).length * (o - r), i;
    }
    return this.getValueLengthInRange(e, t);
  }
  getLength() {
    return this._pieceTree.getLength();
  }
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  getLinesContent() {
    return this._pieceTree.getLinesContent();
  }
  getLineContent(e) {
    return this._pieceTree.getLineContent(e);
  }
  getLineCharCode(e, t) {
    return this._pieceTree.getLineCharCode(e, t);
  }
  getLineLength(e) {
    return this._pieceTree.getLineLength(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = Es(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = wg(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  _getEndOfLine(e) {
    switch (e) {
      case 1:
        return `
`;
      case 2:
        return `\r
`;
      case 0:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  setEOL(e) {
    this._pieceTree.setEOL(e);
  }
  applyEdits(e, t, i) {
    let r = this._mightContainRTL, o = this._mightContainUnusualLineTerminators, s = this._mightContainNonBasicASCII, a = !0, l = [];
    for (let g = 0; g < e.length; g++) {
      let _ = e[g];
      a && _._isTracked && (a = !1);
      let m = _.range;
      if (_.text) {
        let L = !0;
        s || (L = !kG(_.text), s = L), !r && L && (r = _N(_.text)), !o && L && (o = VG(_.text));
      }
      let v = "", C = 0, y = 0, b = 0;
      if (_.text) {
        let L;
        [C, y, b, L] = Zv(_.text);
        const S = this.getEOL();
        L === 0 || L === (S === `\r
` ? 2 : 1) ? v = _.text : v = _.text.replace(/\r\n|\r|\n/g, S);
      }
      l[g] = {
        sortIndex: g,
        identifier: _.identifier || null,
        range: m,
        rangeOffset: this.getOffsetAt(m.startLineNumber, m.startColumn),
        rangeLength: this.getValueLengthInRange(m),
        text: v,
        eolCount: C,
        firstLineLength: y,
        lastLineLength: b,
        forceMoveMarkers: !!_.forceMoveMarkers,
        isAutoWhitespaceEdit: _.isAutoWhitespaceEdit || !1
      };
    }
    l.sort(yp._sortOpsAscending);
    let u = !1;
    for (let g = 0, _ = l.length - 1; g < _; g++) {
      let m = l[g].range.getEndPosition(), v = l[g + 1].range.getStartPosition();
      if (v.isBeforeOrEqual(m)) {
        if (v.isBefore(m))
          throw new Error("Overlapping ranges are not allowed!");
        u = !0;
      }
    }
    a && (l = this._reduceOperations(l));
    let c = i || t ? yp._getInverseEditRanges(l) : [], h = [];
    if (t)
      for (let g = 0; g < l.length; g++) {
        let _ = l[g], m = c[g];
        if (_.isAutoWhitespaceEdit && _.range.isEmpty())
          for (let v = m.startLineNumber; v <= m.endLineNumber; v++) {
            let C = "";
            v === m.startLineNumber && (C = this.getLineContent(_.range.startLineNumber), Es(C) !== -1) || h.push({ lineNumber: v, oldContent: C });
          }
      }
    let d = null;
    if (i) {
      let g = 0;
      d = [];
      for (let _ = 0; _ < l.length; _++) {
        const m = l[_], v = c[_], C = this.getValueInRange(m.range), y = m.rangeOffset + g;
        g += m.text.length - C.length, d[_] = {
          sortIndex: m.sortIndex,
          identifier: m.identifier,
          range: v,
          text: C,
          textChange: new zn(m.rangeOffset, C, y, m.text)
        };
      }
      u || d.sort((_, m) => _.sortIndex - m.sortIndex);
    }
    this._mightContainRTL = r, this._mightContainUnusualLineTerminators = o, this._mightContainNonBasicASCII = s;
    const f = this._doApplyEdits(l);
    let p = null;
    if (t && h.length > 0) {
      h.sort((g, _) => _.lineNumber - g.lineNumber), p = [];
      for (let g = 0, _ = h.length; g < _; g++) {
        let m = h[g].lineNumber;
        if (g > 0 && h[g - 1].lineNumber === m)
          continue;
        let v = h[g].oldContent, C = this.getLineContent(m);
        C.length === 0 || C === v || Es(C) !== -1 || p.push(m);
      }
    }
    return this._onDidChangeContent.fire(), new Vre(d, f, p);
  }
  /**
   * Transform operations such that they represent the same logic edit,
   * but that they also do not cause OOM crashes.
   */
  _reduceOperations(e) {
    return e.length < 1e3 ? e : [this._toSingleEditOperation(e)];
  }
  _toSingleEditOperation(e) {
    let t = !1;
    const i = e[0].range, r = e[e.length - 1].range, o = new V(i.startLineNumber, i.startColumn, r.endLineNumber, r.endColumn);
    let s = i.startLineNumber, a = i.startColumn;
    const l = [];
    for (let f = 0, p = e.length; f < p; f++) {
      const g = e[f], _ = g.range;
      t = t || g.forceMoveMarkers, l.push(this.getValueInRange(new V(s, a, _.startLineNumber, _.startColumn))), g.text.length > 0 && l.push(g.text), s = _.endLineNumber, a = _.endColumn;
    }
    const u = l.join(""), [c, h, d] = Zv(u);
    return {
      sortIndex: 0,
      identifier: e[0].identifier,
      range: o,
      rangeOffset: this.getOffsetAt(o.startLineNumber, o.startColumn),
      rangeLength: this.getValueLengthInRange(
        o,
        0
        /* TextDefined */
      ),
      text: u,
      eolCount: c,
      firstLineLength: h,
      lastLineLength: d,
      forceMoveMarkers: t,
      isAutoWhitespaceEdit: !1
    };
  }
  _doApplyEdits(e) {
    e.sort(yp._sortOpsDescending);
    let t = [];
    for (let i = 0; i < e.length; i++) {
      let r = e[i];
      const o = r.range.startLineNumber, s = r.range.startColumn, a = r.range.endLineNumber, l = r.range.endColumn;
      if (o === a && s === l && r.text.length === 0)
        continue;
      r.text ? (this._pieceTree.delete(r.rangeOffset, r.rangeLength), this._pieceTree.insert(r.rangeOffset, r.text, !0)) : this._pieceTree.delete(r.rangeOffset, r.rangeLength);
      const u = new V(o, s, a, l);
      t.push({
        range: u,
        rangeLength: r.rangeLength,
        text: r.text,
        rangeOffset: r.rangeOffset,
        forceMoveMarkers: r.forceMoveMarkers
      });
    }
    return t;
  }
  findMatchesLineByLine(e, t, i, r) {
    return this._pieceTree.findMatchesLineByLine(e, t, i, r);
  }
  /**
   * Assumes `operations` are validated and sorted ascending
   */
  static _getInverseEditRanges(e) {
    let t = [], i = 0, r = 0, o = null;
    for (let s = 0, a = e.length; s < a; s++) {
      let l = e[s], u, c;
      o ? o.range.endLineNumber === l.range.startLineNumber ? (u = i, c = r + (l.range.startColumn - o.range.endColumn)) : (u = i + (l.range.startLineNumber - o.range.endLineNumber), c = l.range.startColumn) : (u = l.range.startLineNumber, c = l.range.startColumn);
      let h;
      if (l.text.length > 0) {
        const d = l.eolCount + 1;
        d === 1 ? h = new V(u, c, u, c + l.firstLineLength) : h = new V(u, c, u + d - 1, l.lastLineLength + 1);
      } else
        h = new V(u, c, u, c);
      i = h.endLineNumber, r = h.endColumn, t.push(h), o = l;
    }
    return t;
  }
  static _sortOpsAscending(e, t) {
    let i = V.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? e.sortIndex - t.sortIndex : i;
  }
  static _sortOpsDescending(e, t) {
    let i = V.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? t.sortIndex - e.sortIndex : -i;
  }
}
class Ple {
  constructor(e, t, i, r, o, s, a, l, u) {
    this._chunks = e, this._bom = t, this._cr = i, this._lf = r, this._crlf = o, this._containsRTL = s, this._containsUnusualLineTerminators = a, this._isBasicASCII = l, this._normalizeEOL = u;
  }
  _getEOL(e) {
    const t = this._cr + this._lf + this._crlf, i = this._cr + this._crlf;
    return t === 0 ? e === 1 ? `
` : `\r
` : i > t / 2 ? `\r
` : `
`;
  }
  create(e) {
    const t = this._getEOL(e);
    let i = this._chunks;
    if (this._normalizeEOL && (t === `\r
` && (this._cr > 0 || this._lf > 0) || t === `
` && (this._cr > 0 || this._crlf > 0)))
      for (let o = 0, s = i.length; o < s; o++) {
        let a = i[o].buffer.replace(/\r\n|\r|\n/g, t), l = wu(a);
        i[o] = new $h(a, l);
      }
    const r = new yp(i, this._bom, t, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
    return { textBuffer: r, disposable: r };
  }
}
class Ale {
  constructor() {
    this.chunks = [], this.BOM = "", this._hasPreviousChar = !1, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = !1, this.containsUnusualLineTerminators = !1, this.isBasicASCII = !0;
  }
  acceptChunk(e) {
    if (e.length === 0)
      return;
    this.chunks.length === 0 && CN(e) && (this.BOM = lre, e = e.substr(1));
    const t = e.charCodeAt(e.length - 1);
    t === 13 || t >= 55296 && t <= 56319 ? (this._acceptChunk1(e.substr(0, e.length - 1), !1), this._hasPreviousChar = !0, this._previousChar = t) : (this._acceptChunk1(e, !1), this._hasPreviousChar = !1, this._previousChar = t);
  }
  _acceptChunk1(e, t) {
    !t && e.length === 0 || (this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + e) : this._acceptChunk2(e));
  }
  _acceptChunk2(e) {
    const t = Tle(this._tmpLineStarts, e);
    this.chunks.push(new $h(e, t.lineStarts)), this.cr += t.cr, this.lf += t.lf, this.crlf += t.crlf, this.isBasicASCII && (this.isBasicASCII = t.isBasicASCII), !this.isBasicASCII && !this.containsRTL && (this.containsRTL = _N(e)), !this.isBasicASCII && !this.containsUnusualLineTerminators && (this.containsUnusualLineTerminators = VG(e));
  }
  finish(e = !0) {
    return this._finish(), new Ple(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, e);
  }
  _finish() {
    if (this.chunks.length === 0 && this._acceptChunk1("", !0), this._hasPreviousChar) {
      this._hasPreviousChar = !1;
      let e = this.chunks[this.chunks.length - 1];
      e.buffer += String.fromCharCode(this._previousChar);
      let t = wu(e.buffer);
      e.lineStarts = t, this._previousChar === 13 && this.cr++;
    }
  }
}
class Mle {
  constructor() {
    this.changeType = 1;
  }
}
class Fle {
  constructor(e, t) {
    this.changeType = 2, this.lineNumber = e, this.detail = t;
  }
}
class kle {
  constructor(e, t) {
    this.changeType = 3, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class Wle {
  constructor(e, t, i) {
    this.changeType = 4, this.fromLineNumber = e, this.toLineNumber = t, this.detail = i;
  }
}
class Vle {
  constructor() {
    this.changeType = 5;
  }
}
class wp {
  constructor(e, t, i, r) {
    this.changes = e, this.versionId = t, this.isUndoing = i, this.isRedoing = r, this.resultingSelection = null;
  }
  containsEvent(e) {
    for (let t = 0, i = this.changes.length; t < i; t++)
      if (this.changes[t].changeType === e)
        return !0;
    return !1;
  }
  static merge(e, t) {
    const i = [].concat(e.changes).concat(t.changes), r = t.versionId, o = e.isUndoing || t.isUndoing, s = e.isRedoing || t.isRedoing;
    return new wp(i, r, o, s);
  }
}
class Ib {
  constructor(e, t) {
    this.rawContentChangedEvent = e, this.contentChangedEvent = t;
  }
  merge(e) {
    const t = wp.merge(this.rawContentChangedEvent, e.rawContentChangedEvent), i = Ib._mergeChangeEvents(this.contentChangedEvent, e.contentChangedEvent);
    return new Ib(t, i);
  }
  static _mergeChangeEvents(e, t) {
    const i = [].concat(e.changes).concat(t.changes), r = t.eol, o = t.versionId, s = e.isUndoing || t.isUndoing, a = e.isRedoing || t.isRedoing, l = e.isFlush || t.isFlush;
    return {
      changes: i,
      eol: r,
      versionId: o,
      isUndoing: s,
      isRedoing: a,
      isFlush: l
    };
  }
}
class Ble {
  constructor() {
    this._beginState = [], this._valid = [], this._len = 0, this._invalidLineStartIndex = 0;
  }
  _reset(e) {
    this._beginState = [], this._valid = [], this._len = 0, this._invalidLineStartIndex = 0, e && this._setBeginState(0, e);
  }
  flush(e) {
    this._reset(e);
  }
  get invalidLineStartIndex() {
    return this._invalidLineStartIndex;
  }
  _invalidateLine(e) {
    e < this._len && (this._valid[e] = !1), e < this._invalidLineStartIndex && (this._invalidLineStartIndex = e);
  }
  _isValid(e) {
    return e < this._len ? this._valid[e] : !1;
  }
  getBeginState(e) {
    return e < this._len ? this._beginState[e] : null;
  }
  _ensureLine(e) {
    for (; e >= this._len; )
      this._beginState[this._len] = null, this._valid[this._len] = !1, this._len++;
  }
  _deleteLines(e, t) {
    t !== 0 && (e + t > this._len && (t = this._len - e), this._beginState.splice(e, t), this._valid.splice(e, t), this._len -= t);
  }
  _insertLines(e, t) {
    if (t === 0)
      return;
    let i = [], r = [];
    for (let o = 0; o < t; o++)
      i[o] = null, r[o] = !1;
    this._beginState = $v(this._beginState, e, i), this._valid = $v(this._valid, e, r), this._len += t;
  }
  _setValid(e, t) {
    this._ensureLine(e), this._valid[e] = t;
  }
  _setBeginState(e, t) {
    this._ensureLine(e), this._beginState[e] = t;
  }
  setEndState(e, t, i) {
    if (this._setValid(t, !0), this._invalidLineStartIndex = t + 1, t === e - 1)
      return;
    const r = this.getBeginState(t + 1);
    if (r === null || !i.equals(r)) {
      this._setBeginState(t + 1, i), this._invalidateLine(t + 1);
      return;
    }
    let o = t + 1;
    for (; o < e && this._isValid(o); )
      o++;
    this._invalidLineStartIndex = o;
  }
  setFakeTokens(e) {
    this._setValid(e, !1);
  }
  //#region Editing
  applyEdits(e, t) {
    const i = e.endLineNumber - e.startLineNumber, o = Math.min(i, t);
    for (let s = o; s >= 0; s--)
      this._invalidateLine(e.startLineNumber + s - 1);
    this._acceptDeleteRange(e), this._acceptInsertText(new J(e.startLineNumber, e.startColumn), t);
  }
  _acceptDeleteRange(e) {
    e.startLineNumber - 1 >= this._len || this._deleteLines(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t) {
    e.lineNumber - 1 >= this._len || this._insertLines(e.lineNumber, t);
  }
}
class Hle extends ge {
  constructor(e) {
    super(), this._isDisposed = !1, this._textModel = e, this._tokenizationStateStore = new Ble(), this._tokenizationSupport = null, this._register(ln.onDidChange((t) => {
      const i = this._textModel.getLanguageIdentifier();
      t.changedLanguages.indexOf(i.language) !== -1 && (this._resetTokenizationState(), this._textModel.clearTokens());
    })), this._register(this._textModel.onDidChangeRawContentFast((t) => {
      if (t.containsEvent(
        1
        /* Flush */
      )) {
        this._resetTokenizationState();
        return;
      }
    })), this._register(this._textModel.onDidChangeContentFast((t) => {
      for (let i = 0, r = t.changes.length; i < r; i++) {
        const o = t.changes[i], [s] = Zv(o.text);
        this._tokenizationStateStore.applyEdits(o.range, s);
      }
      this._beginBackgroundTokenization();
    })), this._register(this._textModel.onDidChangeAttached(() => {
      this._beginBackgroundTokenization();
    })), this._register(this._textModel.onDidChangeLanguage(() => {
      this._resetTokenizationState(), this._textModel.clearTokens();
    })), this._resetTokenizationState();
  }
  dispose() {
    this._isDisposed = !0, super.dispose();
  }
  _resetTokenizationState() {
    const [e, t] = Gle(this._textModel);
    this._tokenizationSupport = e, this._tokenizationStateStore.flush(t), this._beginBackgroundTokenization();
  }
  _beginBackgroundTokenization() {
    this._textModel.isAttachedToEditor() && this._hasLinesToTokenize() && Jw(() => {
      this._isDisposed || this._revalidateTokensNow();
    });
  }
  _revalidateTokensNow(e = this._textModel.getLineCount()) {
    const i = new _D(), r = yg.create(!1);
    for (; this._hasLinesToTokenize() && !(r.elapsed() > 1 || this._tokenizeOneInvalidLine(i) >= e); )
      ;
    this._beginBackgroundTokenization(), this._textModel.setTokens(i.tokens);
  }
  tokenizeViewport(e, t) {
    const i = new _D();
    this._tokenizeViewport(i, e, t), this._textModel.setTokens(i.tokens);
  }
  reset() {
    this._resetTokenizationState(), this._textModel.clearTokens();
  }
  forceTokenization(e) {
    const t = new _D();
    this._updateTokensUntilLine(t, e), this._textModel.setTokens(t.tokens);
  }
  isCheapToTokenize(e) {
    if (!this._tokenizationSupport)
      return !0;
    const t = this._tokenizationStateStore.invalidLineStartIndex + 1;
    return e > t ? !1 : e < t || this._textModel.getLineLength(e) < 2048;
  }
  _hasLinesToTokenize() {
    return this._tokenizationSupport ? this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount() : !1;
  }
  _tokenizeOneInvalidLine(e) {
    if (!this._hasLinesToTokenize())
      return this._textModel.getLineCount() + 1;
    const t = this._tokenizationStateStore.invalidLineStartIndex + 1;
    return this._updateTokensUntilLine(e, t), t;
  }
  _updateTokensUntilLine(e, t) {
    if (!this._tokenizationSupport)
      return;
    const i = this._textModel.getLanguageIdentifier(), r = this._textModel.getLineCount(), o = t - 1;
    for (let s = this._tokenizationStateStore.invalidLineStartIndex; s <= o; s++) {
      const a = this._textModel.getLineContent(s + 1), l = this._tokenizationStateStore.getBeginState(s), u = CD(i, this._tokenizationSupport, a, !0, l);
      e.add(s + 1, u.tokens), this._tokenizationStateStore.setEndState(r, s, u.endState), s = this._tokenizationStateStore.invalidLineStartIndex - 1;
    }
  }
  _tokenizeViewport(e, t, i) {
    if (!this._tokenizationSupport || i <= this._tokenizationStateStore.invalidLineStartIndex)
      return;
    if (t <= this._tokenizationStateStore.invalidLineStartIndex) {
      this._updateTokensUntilLine(e, i);
      return;
    }
    let r = this._textModel.getLineFirstNonWhitespaceColumn(t), o = [], s = null;
    for (let u = t - 1; r > 0 && u >= 1; u--) {
      let c = this._textModel.getLineFirstNonWhitespaceColumn(u);
      if (c !== 0 && c < r) {
        if (s = this._tokenizationStateStore.getBeginState(u - 1), s)
          break;
        o.push(this._textModel.getLineContent(u)), r = c;
      }
    }
    s || (s = this._tokenizationSupport.getInitialState());
    const a = this._textModel.getLanguageIdentifier();
    let l = s;
    for (let u = o.length - 1; u >= 0; u--)
      l = CD(a, this._tokenizationSupport, o[u], !1, l).endState;
    for (let u = t; u <= i; u++) {
      let c = this._textModel.getLineContent(u), h = CD(a, this._tokenizationSupport, c, !0, l);
      e.add(u, h.tokens), this._tokenizationStateStore.setFakeTokens(u - 1), l = h.endState;
    }
  }
}
function Gle(n) {
  const e = n.getLanguageIdentifier();
  let t = n.isTooLargeForTokenization() ? null : ln.get(e.language), i = null;
  if (t)
    try {
      i = t.getInitialState();
    } catch (r) {
      Ni(r), t = null;
    }
  return [t, i];
}
function CD(n, e, t, i, r) {
  let o = null;
  if (e)
    try {
      o = e.tokenize2(t, i, r.clone(), 0);
    } catch (s) {
      Ni(s);
    }
  return o || (o = e5(n.id, t, r, 0)), Zr.convertToEndOffset(o.tokens, t.length), o;
}
function Xc(n, e) {
  const t = Math.pow(10, e);
  return Math.round(n * t) / t;
}
class xt {
  constructor(e, t, i, r = 1) {
    this.r = Math.min(255, Math.max(0, e)) | 0, this.g = Math.min(255, Math.max(0, t)) | 0, this.b = Math.min(255, Math.max(0, i)) | 0, this.a = Xc(Math.max(Math.min(1, r), 0), 3);
  }
  static equals(e, t) {
    return e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a;
  }
}
class Ba {
  constructor(e, t, i, r) {
    this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Xc(Math.max(Math.min(1, t), 0), 3), this.l = Xc(Math.max(Math.min(1, i), 0), 3), this.a = Xc(Math.max(Math.min(1, r), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.l === t.l && e.a === t.a;
  }
  /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h in the set [0, 360], s, and l in the set [0, 1].
   */
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, r = e.b / 255, o = e.a, s = Math.max(t, i, r), a = Math.min(t, i, r);
    let l = 0, u = 0;
    const c = (a + s) / 2, h = s - a;
    if (h > 0) {
      switch (u = Math.min(c <= 0.5 ? h / (2 * c) : h / (2 - 2 * c), 1), s) {
        case t:
          l = (i - r) / h + (i < r ? 6 : 0);
          break;
        case i:
          l = (r - t) / h + 2;
          break;
        case r:
          l = (t - i) / h + 4;
          break;
      }
      l *= 60, l = Math.round(l);
    }
    return new Ba(l, u, c, o);
  }
  static _hue2rgb(e, t, i) {
    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (t - e) * 6 * i : i < 1 / 2 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e;
  }
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   */
  static toRGBA(e) {
    const t = e.h / 360, { s: i, l: r, a: o } = e;
    let s, a, l;
    if (i === 0)
      s = a = l = r;
    else {
      const u = r < 0.5 ? r * (1 + i) : r + i - r * i, c = 2 * r - u;
      s = Ba._hue2rgb(c, u, t + 1 / 3), a = Ba._hue2rgb(c, u, t), l = Ba._hue2rgb(c, u, t - 1 / 3);
    }
    return new xt(Math.round(s * 255), Math.round(a * 255), Math.round(l * 255), o);
  }
}
class Yf {
  constructor(e, t, i, r) {
    this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Xc(Math.max(Math.min(1, t), 0), 3), this.v = Xc(Math.max(Math.min(1, i), 0), 3), this.a = Xc(Math.max(Math.min(1, r), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.v === t.v && e.a === t.a;
  }
  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, r = e.b / 255, o = Math.max(t, i, r), s = Math.min(t, i, r), a = o - s, l = o === 0 ? 0 : a / o;
    let u;
    return a === 0 ? u = 0 : o === t ? u = ((i - r) / a % 6 + 6) % 6 : o === i ? u = (r - t) / a + 2 : u = (t - i) / a + 4, new Yf(Math.round(u * 60), l, o, e.a);
  }
  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
  static toRGBA(e) {
    const { h: t, s: i, v: r, a: o } = e, s = r * i, a = s * (1 - Math.abs(t / 60 % 2 - 1)), l = r - s;
    let [u, c, h] = [0, 0, 0];
    return t < 60 ? (u = s, c = a) : t < 120 ? (u = a, c = s) : t < 180 ? (c = s, h = a) : t < 240 ? (c = a, h = s) : t < 300 ? (u = a, h = s) : t <= 360 && (u = s, h = a), u = Math.round((u + l) * 255), c = Math.round((c + l) * 255), h = Math.round((h + l) * 255), new xt(u, c, h, o);
  }
}
class ee {
  constructor(e) {
    if (e)
      if (e instanceof xt)
        this.rgba = e;
      else if (e instanceof Ba)
        this._hsla = e, this.rgba = Ba.toRGBA(e);
      else if (e instanceof Yf)
        this._hsva = e, this.rgba = Yf.toRGBA(e);
      else
        throw new Error("Invalid color ctor argument");
    else
      throw new Error("Color needs a value");
  }
  static fromHex(e) {
    return ee.Format.CSS.parseHex(e) || ee.red;
  }
  get hsla() {
    return this._hsla ? this._hsla : Ba.fromRGBA(this.rgba);
  }
  get hsva() {
    return this._hsva ? this._hsva : Yf.fromRGBA(this.rgba);
  }
  equals(e) {
    return !!e && xt.equals(this.rgba, e.rgba) && Ba.equals(this.hsla, e.hsla) && Yf.equals(this.hsva, e.hsva);
  }
  /**
   * http://www.w3.org/TR/WCAG20/#relativeluminancedef
   * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
   */
  getRelativeLuminance() {
    const e = ee._relativeLuminanceForComponent(this.rgba.r), t = ee._relativeLuminanceForComponent(this.rgba.g), i = ee._relativeLuminanceForComponent(this.rgba.b), r = 0.2126 * e + 0.7152 * t + 0.0722 * i;
    return Xc(r, 4);
  }
  static _relativeLuminanceForComponent(e) {
    const t = e / 255;
    return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
  }
  /**
   *	http://24ways.org/2010/calculating-color-contrast
   *  Return 'true' if lighter color otherwise 'false'
   */
  isLighter() {
    return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 >= 128;
  }
  isLighterThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t > i;
  }
  isDarkerThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t < i;
  }
  lighten(e) {
    return new ee(new Ba(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * e, this.hsla.a));
  }
  darken(e) {
    return new ee(new Ba(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * e, this.hsla.a));
  }
  transparent(e) {
    const { r: t, g: i, b: r, a: o } = this.rgba;
    return new ee(new xt(t, i, r, o * e));
  }
  isTransparent() {
    return this.rgba.a === 0;
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  opposite() {
    return new ee(new xt(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }
  toString() {
    return "" + ee.Format.CSS.format(this);
  }
  static getLighterColor(e, t, i) {
    if (e.isLighterThan(t))
      return e;
    i = i || 0.5;
    const r = e.getRelativeLuminance(), o = t.getRelativeLuminance();
    return i = i * (o - r) / o, e.lighten(i);
  }
  static getDarkerColor(e, t, i) {
    if (e.isDarkerThan(t))
      return e;
    i = i || 0.5;
    const r = e.getRelativeLuminance(), o = t.getRelativeLuminance();
    return i = i * (r - o) / r, e.darken(i);
  }
}
ee.white = new ee(new xt(255, 255, 255, 1));
ee.black = new ee(new xt(0, 0, 0, 1));
ee.red = new ee(new xt(255, 0, 0, 1));
ee.blue = new ee(new xt(0, 0, 255, 1));
ee.cyan = new ee(new xt(0, 255, 255, 1));
ee.lightgrey = new ee(new xt(211, 211, 211, 1));
ee.transparent = new ee(new xt(0, 0, 0, 0));
(function(n) {
  (function(e) {
    (function(t) {
      function i(f) {
        return f.rgba.a === 1 ? `rgb(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b})` : n.Format.CSS.formatRGBA(f);
      }
      t.formatRGB = i;
      function r(f) {
        return `rgba(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b}, ${+f.rgba.a.toFixed(2)})`;
      }
      t.formatRGBA = r;
      function o(f) {
        return f.hsla.a === 1 ? `hsl(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%)` : n.Format.CSS.formatHSLA(f);
      }
      t.formatHSL = o;
      function s(f) {
        return `hsla(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%, ${f.hsla.a.toFixed(2)})`;
      }
      t.formatHSLA = s;
      function a(f) {
        const p = f.toString(16);
        return p.length !== 2 ? "0" + p : p;
      }
      function l(f) {
        return `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}`;
      }
      t.formatHex = l;
      function u(f, p = !1) {
        return p && f.rgba.a === 1 ? n.Format.CSS.formatHex(f) : `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}${a(Math.round(f.rgba.a * 255))}`;
      }
      t.formatHexA = u;
      function c(f) {
        return f.isOpaque() ? n.Format.CSS.formatHex(f) : n.Format.CSS.formatRGBA(f);
      }
      t.format = c;
      function h(f) {
        const p = f.length;
        if (p === 0 || f.charCodeAt(0) !== 35)
          return null;
        if (p === 7) {
          const g = 16 * d(f.charCodeAt(1)) + d(f.charCodeAt(2)), _ = 16 * d(f.charCodeAt(3)) + d(f.charCodeAt(4)), m = 16 * d(f.charCodeAt(5)) + d(f.charCodeAt(6));
          return new n(new xt(g, _, m, 1));
        }
        if (p === 9) {
          const g = 16 * d(f.charCodeAt(1)) + d(f.charCodeAt(2)), _ = 16 * d(f.charCodeAt(3)) + d(f.charCodeAt(4)), m = 16 * d(f.charCodeAt(5)) + d(f.charCodeAt(6)), v = 16 * d(f.charCodeAt(7)) + d(f.charCodeAt(8));
          return new n(new xt(g, _, m, v / 255));
        }
        if (p === 4) {
          const g = d(f.charCodeAt(1)), _ = d(f.charCodeAt(2)), m = d(f.charCodeAt(3));
          return new n(new xt(16 * g + g, 16 * _ + _, 16 * m + m));
        }
        if (p === 5) {
          const g = d(f.charCodeAt(1)), _ = d(f.charCodeAt(2)), m = d(f.charCodeAt(3)), v = d(f.charCodeAt(4));
          return new n(new xt(16 * g + g, 16 * _ + _, 16 * m + m, (16 * v + v) / 255));
        }
        return null;
      }
      t.parseHex = h;
      function d(f) {
        switch (f) {
          case 48:
            return 0;
          case 49:
            return 1;
          case 50:
            return 2;
          case 51:
            return 3;
          case 52:
            return 4;
          case 53:
            return 5;
          case 54:
            return 6;
          case 55:
            return 7;
          case 56:
            return 8;
          case 57:
            return 9;
          case 97:
            return 10;
          case 65:
            return 10;
          case 98:
            return 11;
          case 66:
            return 11;
          case 99:
            return 12;
          case 67:
            return 12;
          case 100:
            return 13;
          case 68:
            return 13;
          case 101:
            return 14;
          case 69:
            return 14;
          case 102:
            return 15;
          case 70:
            return 15;
        }
        return 0;
      }
    })(e.CSS || (e.CSS = {}));
  })(n.Format || (n.Format = {}));
})(ee || (ee = {}));
function Ule() {
  return new Ale();
}
function zle(n) {
  const e = Ule();
  return e.acceptChunk(n), e.finish();
}
function Xk(n, e) {
  return (typeof n == "string" ? zle(n) : n).create(e);
}
let _y = 0;
const jle = 999, $le = 1e4;
class Kle {
  constructor(e) {
    this._source = e, this._eos = !1;
  }
  read() {
    if (this._eos)
      return null;
    let e = [], t = 0, i = 0;
    do {
      let r = this._source.read();
      if (r === null)
        return this._eos = !0, t === 0 ? null : e.join("");
      if (r.length > 0 && (e[t++] = r, i += r.length), i >= 64 * 1024)
        return e.join("");
    } while (!0);
  }
}
const Tm = () => {
  throw new Error("Invalid change accessor");
};
class Tu {
  constructor() {
    this._searchCanceledBrand = void 0;
  }
}
Tu.INSTANCE = new Tu();
function Cy(n) {
  return n instanceof Tu ? null : n;
}
class Kr extends ge {
  //#endregion
  constructor(e, t, i, r = null, o) {
    super(), this._onWillDispose = this._register(new j()), this.onWillDispose = this._onWillDispose.event, this._onDidChangeDecorations = this._register(new Zle()), this.onDidChangeDecorations = this._onDidChangeDecorations.event, this._onDidChangeLanguage = this._register(new j()), this.onDidChangeLanguage = this._onDidChangeLanguage.event, this._onDidChangeLanguageConfiguration = this._register(new j()), this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event, this._onDidChangeTokens = this._register(new j()), this.onDidChangeTokens = this._onDidChangeTokens.event, this._onDidChangeOptions = this._register(new j()), this.onDidChangeOptions = this._onDidChangeOptions.event, this._onDidChangeAttached = this._register(new j()), this.onDidChangeAttached = this._onDidChangeAttached.event, this._eventEmitter = this._register(new Qle()), _y++, this.id = "$model" + _y, this.isForSimpleWidget = t.isForSimpleWidget, typeof r > "u" || r === null ? this._associatedResource = dt.parse("inmemory://model/" + _y) : this._associatedResource = r, this._undoRedoService = o, this._attachedEditorCount = 0;
    const { textBuffer: s, disposable: a } = Xk(e, t.defaultEOL);
    this._buffer = s, this._bufferDisposable = a, this._options = Kr.resolveOptions(this._buffer, t);
    const l = this._buffer.getLineCount(), u = this._buffer.getValueLengthInRange(
      new V(1, 1, l, this._buffer.getLineLength(l) + 1),
      0
      /* TextDefined */
    );
    t.largeFileOptimizations ? this._isTooLargeForTokenization = u > Kr.LARGE_FILE_SIZE_THRESHOLD || l > Kr.LARGE_FILE_LINE_COUNT_THRESHOLD : this._isTooLargeForTokenization = !1, this._isTooLargeForSyncing = u > Kr.MODEL_SYNC_LIMIT, this._versionId = 1, this._alternativeVersionId = 1, this._initialUndoRedoSnapshot = null, this._isDisposed = !1, this._isDisposing = !1, this._languageIdentifier = i || fb, this._languageRegistryListener = ui.onDidChange((c) => {
      c.languageIdentifier.id === this._languageIdentifier.id && this._onDidChangeLanguageConfiguration.fire({});
    }), this._instanceId = BG(_y), this._lastDecorationId = 0, this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new Zk(), this._commandManager = new $N(this, o), this._isUndoing = !1, this._isRedoing = !1, this._trimAutoWhitespaceLines = null, this._tokens = new ls(), this._tokens2 = new ZN(), this._tokenization = new Hle(this);
  }
  static resolveOptions(e, t) {
    if (t.detectIndentation) {
      const i = Wk(e, t.tabSize, t.insertSpaces);
      return new ew({
        tabSize: i.tabSize,
        indentSize: i.tabSize,
        insertSpaces: i.insertSpaces,
        trimAutoWhitespace: t.trimAutoWhitespace,
        defaultEOL: t.defaultEOL
      });
    }
    return new ew({
      tabSize: t.tabSize,
      indentSize: t.indentSize,
      insertSpaces: t.insertSpaces,
      trimAutoWhitespace: t.trimAutoWhitespace,
      defaultEOL: t.defaultEOL
    });
  }
  onDidChangeRawContentFast(e) {
    return this._eventEmitter.fastEvent((t) => e(t.rawContentChangedEvent));
  }
  onDidChangeContentFast(e) {
    return this._eventEmitter.fastEvent((t) => e(t.contentChangedEvent));
  }
  onDidChangeContent(e) {
    return this._eventEmitter.slowEvent((t) => e(t.contentChangedEvent));
  }
  dispose() {
    this._isDisposing = !0, this._onWillDispose.fire(), this._languageRegistryListener.dispose(), this._tokenization.dispose(), this._isDisposed = !0, super.dispose(), this._bufferDisposable.dispose(), this._isDisposing = !1;
    const e = new yp([], "", `
`, !1, !1, !0, !0);
    e.dispose(), this._buffer = e;
  }
  _assertNotDisposed() {
    if (this._isDisposed)
      throw new Error("Model is disposed!");
  }
  _emitContentChangedEvent(e, t) {
    this._isDisposing || this._eventEmitter.fire(new Ib(e, t));
  }
  setValue(e) {
    if (this._assertNotDisposed(), e === null)
      return;
    const { textBuffer: t, disposable: i } = Xk(e, this._options.defaultEOL);
    this._setValueFromTextBuffer(t, i);
  }
  _createContentChanged2(e, t, i, r, o, s, a) {
    return {
      changes: [{
        range: e,
        rangeOffset: t,
        rangeLength: i,
        text: r
      }],
      eol: this._buffer.getEOL(),
      versionId: this.getVersionId(),
      isUndoing: o,
      isRedoing: s,
      isFlush: a
    };
  }
  _setValueFromTextBuffer(e, t) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), r = this.getValueLengthInRange(i), o = this.getLineCount(), s = this.getLineMaxColumn(o);
    this._buffer = e, this._bufferDisposable.dispose(), this._bufferDisposable = t, this._increaseVersionId(), this._tokens.flush(), this._tokens2.flush(), this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new Zk(), this._commandManager.clear(), this._trimAutoWhitespaceLines = null, this._emitContentChangedEvent(new wp([
      new Mle()
    ], this._versionId, !1, !1), this._createContentChanged2(new V(1, 1, o, s), 0, r, this.getValue(), !1, !1, !0));
  }
  setEOL(e) {
    this._assertNotDisposed();
    const t = e === 1 ? `\r
` : `
`;
    if (this._buffer.getEOL() === t)
      return;
    const i = this.getFullModelRange(), r = this.getValueLengthInRange(i), o = this.getLineCount(), s = this.getLineMaxColumn(o);
    this._onBeforeEOLChange(), this._buffer.setEOL(t), this._increaseVersionId(), this._onAfterEOLChange(), this._emitContentChangedEvent(new wp([
      new Vle()
    ], this._versionId, !1, !1), this._createContentChanged2(new V(1, 1, o, s), 0, r, this.getValue(), !1, !1, !1));
  }
  _onBeforeEOLChange() {
    const e = this.getVersionId(), t = this._decorationsTree.search(0, !1, !1, e);
    this._ensureNodesHaveRanges(t);
  }
  _onAfterEOLChange() {
    const e = this.getVersionId(), t = this._decorationsTree.collectNodesPostOrder();
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i], s = o.cachedAbsoluteStart - o.start, a = this._buffer.getOffsetAt(o.range.startLineNumber, o.range.startColumn), l = this._buffer.getOffsetAt(o.range.endLineNumber, o.range.endColumn);
      o.cachedAbsoluteStart = a, o.cachedAbsoluteEnd = l, o.cachedVersionId = e, o.start = a - s, o.end = l - s, rh(o);
    }
  }
  onBeforeAttached() {
    this._attachedEditorCount++, this._attachedEditorCount === 1 && this._onDidChangeAttached.fire(void 0);
  }
  onBeforeDetached() {
    this._attachedEditorCount--, this._attachedEditorCount === 0 && this._onDidChangeAttached.fire(void 0);
  }
  isAttachedToEditor() {
    return this._attachedEditorCount > 0;
  }
  getAttachedEditorCount() {
    return this._attachedEditorCount;
  }
  isTooLargeForSyncing() {
    return this._isTooLargeForSyncing;
  }
  isTooLargeForTokenization() {
    return this._isTooLargeForTokenization;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isDominatedByLongLines() {
    if (this._assertNotDisposed(), this.isTooLargeForTokenization())
      return !1;
    let e = 0, t = 0;
    const i = this._buffer.getLineCount();
    for (let r = 1; r <= i; r++) {
      const o = this._buffer.getLineLength(r);
      o >= $le ? t += o : e += o;
    }
    return t > e;
  }
  get uri() {
    return this._associatedResource;
  }
  //#region Options
  getOptions() {
    return this._assertNotDisposed(), this._options;
  }
  getFormattingOptions() {
    return {
      tabSize: this._options.indentSize,
      insertSpaces: this._options.insertSpaces
    };
  }
  updateOptions(e) {
    this._assertNotDisposed();
    let t = typeof e.tabSize < "u" ? e.tabSize : this._options.tabSize, i = typeof e.indentSize < "u" ? e.indentSize : this._options.indentSize, r = typeof e.insertSpaces < "u" ? e.insertSpaces : this._options.insertSpaces, o = typeof e.trimAutoWhitespace < "u" ? e.trimAutoWhitespace : this._options.trimAutoWhitespace, s = new ew({
      tabSize: t,
      indentSize: i,
      insertSpaces: r,
      defaultEOL: this._options.defaultEOL,
      trimAutoWhitespace: o
    });
    if (this._options.equals(s))
      return;
    let a = this._options.createChangeEvent(s);
    this._options = s, this._onDidChangeOptions.fire(a);
  }
  detectIndentation(e, t) {
    this._assertNotDisposed();
    let i = Wk(this._buffer, t, e);
    this.updateOptions({
      insertSpaces: i.insertSpaces,
      tabSize: i.tabSize,
      indentSize: i.tabSize
      // TODO@Alex: guess indentSize independent of tabSize
    });
  }
  static _normalizeIndentationFromWhitespace(e, t, i) {
    let r = 0;
    for (let s = 0; s < e.length; s++)
      e.charAt(s) === "	" ? r += t : r++;
    let o = "";
    if (!i) {
      let s = Math.floor(r / t);
      r = r % t;
      for (let a = 0; a < s; a++)
        o += "	";
    }
    for (let s = 0; s < r; s++)
      o += " ";
    return o;
  }
  static normalizeIndentation(e, t, i) {
    let r = Es(e);
    return r === -1 && (r = e.length), Kr._normalizeIndentationFromWhitespace(e.substring(0, r), t, i) + e.substring(r);
  }
  normalizeIndentation(e) {
    return this._assertNotDisposed(), Kr.normalizeIndentation(e, this._options.indentSize, this._options.insertSpaces);
  }
  //#endregion
  //#region Reading
  getVersionId() {
    return this._assertNotDisposed(), this._versionId;
  }
  mightContainRTL() {
    return this._buffer.mightContainRTL();
  }
  mightContainUnusualLineTerminators() {
    return this._buffer.mightContainUnusualLineTerminators();
  }
  removeUnusualLineTerminators(e = null) {
    const t = this.findMatches(
      WG.source,
      !1,
      !0,
      !1,
      null,
      !1,
      1073741824
      /* MAX_SAFE_SMALL_INTEGER */
    );
    this._buffer.resetMightContainUnusualLineTerminators(), this.pushEditOperations(e, t.map((i) => ({ range: i.range, text: null })), () => null);
  }
  mightContainNonBasicASCII() {
    return this._buffer.mightContainNonBasicASCII();
  }
  getAlternativeVersionId() {
    return this._assertNotDisposed(), this._alternativeVersionId;
  }
  getInitialUndoRedoSnapshot() {
    return this._assertNotDisposed(), this._initialUndoRedoSnapshot;
  }
  getOffsetAt(e) {
    this._assertNotDisposed();
    let t = this._validatePosition(
      e.lineNumber,
      e.column,
      0
      /* Relaxed */
    );
    return this._buffer.getOffsetAt(t.lineNumber, t.column);
  }
  getPositionAt(e) {
    this._assertNotDisposed();
    let t = Math.min(this._buffer.getLength(), Math.max(0, e));
    return this._buffer.getPositionAt(t);
  }
  _increaseVersionId() {
    this._versionId = this._versionId + 1, this._alternativeVersionId = this._versionId;
  }
  _overwriteVersionId(e) {
    this._versionId = e;
  }
  _overwriteAlternativeVersionId(e) {
    this._alternativeVersionId = e;
  }
  _overwriteInitialUndoRedoSnapshot(e) {
    this._initialUndoRedoSnapshot = e;
  }
  getValue(e, t = !1) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), r = this.getValueInRange(i, e);
    return t ? this._buffer.getBOM() + r : r;
  }
  createSnapshot(e = !1) {
    return new Kle(this._buffer.createSnapshot(e));
  }
  getValueLength(e, t = !1) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), r = this.getValueLengthInRange(i, e);
    return t ? this._buffer.getBOM().length + r : r;
  }
  getValueInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueInRange(this.validateRange(e), t);
  }
  getValueLengthInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueLengthInRange(this.validateRange(e), t);
  }
  getCharacterCountInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getCharacterCountInRange(this.validateRange(e), t);
  }
  getLineCount() {
    return this._assertNotDisposed(), this._buffer.getLineCount();
  }
  getLineContent(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineContent(e);
  }
  getLineLength(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineLength(e);
  }
  getLinesContent() {
    return this._assertNotDisposed(), this._buffer.getLinesContent();
  }
  getEOL() {
    return this._assertNotDisposed(), this._buffer.getEOL();
  }
  getEndOfLineSequence() {
    return this._assertNotDisposed(), this._buffer.getEOL() === `
` ? 0 : 1;
  }
  getLineMinColumn(e) {
    return this._assertNotDisposed(), 1;
  }
  getLineMaxColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineLength(e) + 1;
  }
  getLineFirstNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineFirstNonWhitespaceColumn(e);
  }
  getLineLastNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineLastNonWhitespaceColumn(e);
  }
  /**
   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
   * Will try to not allocate if possible.
   */
  _validateRangeRelaxedNoAllocations(e) {
    const t = this._buffer.getLineCount(), i = e.startLineNumber, r = e.startColumn;
    let o = Math.floor(typeof i == "number" && !isNaN(i) ? i : 1), s = Math.floor(typeof r == "number" && !isNaN(r) ? r : 1);
    if (o < 1)
      o = 1, s = 1;
    else if (o > t)
      o = t, s = this.getLineMaxColumn(o);
    else if (s <= 1)
      s = 1;
    else {
      const h = this.getLineMaxColumn(o);
      s >= h && (s = h);
    }
    const a = e.endLineNumber, l = e.endColumn;
    let u = Math.floor(typeof a == "number" && !isNaN(a) ? a : 1), c = Math.floor(typeof l == "number" && !isNaN(l) ? l : 1);
    if (u < 1)
      u = 1, c = 1;
    else if (u > t)
      u = t, c = this.getLineMaxColumn(u);
    else if (c <= 1)
      c = 1;
    else {
      const h = this.getLineMaxColumn(u);
      c >= h && (c = h);
    }
    return i === o && r === s && a === u && l === c && e instanceof V && !(e instanceof Ut) ? e : new V(o, s, u, c);
  }
  _isValidPosition(e, t, i) {
    if (typeof e != "number" || typeof t != "number" || isNaN(e) || isNaN(t) || e < 1 || t < 1 || (e | 0) !== e || (t | 0) !== t)
      return !1;
    const r = this._buffer.getLineCount();
    if (e > r)
      return !1;
    if (t === 1)
      return !0;
    const o = this.getLineMaxColumn(e);
    if (t > o)
      return !1;
    if (i === 1) {
      const s = this._buffer.getLineCharCode(e, t - 2);
      if (jn(s))
        return !1;
    }
    return !0;
  }
  _validatePosition(e, t, i) {
    const r = Math.floor(typeof e == "number" && !isNaN(e) ? e : 1), o = Math.floor(typeof t == "number" && !isNaN(t) ? t : 1), s = this._buffer.getLineCount();
    if (r < 1)
      return new J(1, 1);
    if (r > s)
      return new J(s, this.getLineMaxColumn(s));
    if (o <= 1)
      return new J(r, 1);
    const a = this.getLineMaxColumn(r);
    if (o >= a)
      return new J(r, a);
    if (i === 1) {
      const l = this._buffer.getLineCharCode(r, o - 2);
      if (jn(l))
        return new J(r, o - 1);
    }
    return new J(r, o);
  }
  validatePosition(e) {
    return this._assertNotDisposed(), e instanceof J && this._isValidPosition(e.lineNumber, e.column, 1) ? e : this._validatePosition(e.lineNumber, e.column, 1);
  }
  _isValidRange(e, t) {
    const i = e.startLineNumber, r = e.startColumn, o = e.endLineNumber, s = e.endColumn;
    if (!this._isValidPosition(
      i,
      r,
      0
      /* Relaxed */
    ) || !this._isValidPosition(
      o,
      s,
      0
      /* Relaxed */
    ))
      return !1;
    if (t === 1) {
      const a = r > 1 ? this._buffer.getLineCharCode(i, r - 2) : 0, l = s > 1 && s <= this._buffer.getLineLength(o) ? this._buffer.getLineCharCode(o, s - 2) : 0, u = jn(a), c = jn(l);
      return !u && !c;
    }
    return !0;
  }
  validateRange(e) {
    if (this._assertNotDisposed(), e instanceof V && !(e instanceof Ut) && this._isValidRange(e, 1))
      return e;
    const i = this._validatePosition(
      e.startLineNumber,
      e.startColumn,
      0
      /* Relaxed */
    ), r = this._validatePosition(
      e.endLineNumber,
      e.endColumn,
      0
      /* Relaxed */
    ), o = i.lineNumber, s = i.column, a = r.lineNumber, l = r.column;
    {
      const u = s > 1 ? this._buffer.getLineCharCode(o, s - 2) : 0, c = l > 1 && l <= this._buffer.getLineLength(a) ? this._buffer.getLineCharCode(a, l - 2) : 0, h = jn(u), d = jn(c);
      return !h && !d ? new V(o, s, a, l) : o === a && s === l ? new V(o, s - 1, a, l - 1) : h && d ? new V(o, s - 1, a, l + 1) : h ? new V(o, s - 1, a, l) : new V(o, s, a, l + 1);
    }
  }
  modifyPosition(e, t) {
    this._assertNotDisposed();
    let i = this.getOffsetAt(e) + t;
    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, i)));
  }
  getFullModelRange() {
    this._assertNotDisposed();
    const e = this.getLineCount();
    return new V(1, 1, e, this.getLineMaxColumn(e));
  }
  findMatchesLineByLine(e, t, i, r) {
    return this._buffer.findMatchesLineByLine(e, t, i, r);
  }
  findMatches(e, t, i, r, o, s, a = jle) {
    this._assertNotDisposed();
    let l = null;
    t !== null && (Array.isArray(t) || (t = [t]), t.every((h) => V.isIRange(h)) && (l = t.map((h) => this.validateRange(h)))), l === null && (l = [this.getFullModelRange()]), l = l.sort((h, d) => h.startLineNumber - d.startLineNumber || h.startColumn - d.startColumn);
    const u = [];
    u.push(l.reduce((h, d) => V.areIntersecting(h, d) ? h.plusRange(d) : (u.push(h), d)));
    let c;
    if (!i && e.indexOf(`
`) < 0) {
      const d = new xf(e, i, r, o).parseSearchRequest();
      if (!d)
        return [];
      c = (f) => this.findMatchesLineByLine(f, d, s, a);
    } else
      c = (h) => vy.findMatches(this, new xf(e, i, r, o), h, s, a);
    return u.map(c).reduce((h, d) => h.concat(d), []);
  }
  findNextMatch(e, t, i, r, o, s) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    if (!i && e.indexOf(`
`) < 0) {
      const u = new xf(e, i, r, o).parseSearchRequest();
      if (!u)
        return null;
      const c = this.getLineCount();
      let h = new V(a.lineNumber, a.column, c, this.getLineMaxColumn(c)), d = this.findMatchesLineByLine(h, u, s, 1);
      return vy.findNextMatch(this, new xf(e, i, r, o), a, s), d.length > 0 || (h = new V(1, 1, a.lineNumber, this.getLineMaxColumn(a.lineNumber)), d = this.findMatchesLineByLine(h, u, s, 1), d.length > 0) ? d[0] : null;
    }
    return vy.findNextMatch(this, new xf(e, i, r, o), a, s);
  }
  findPreviousMatch(e, t, i, r, o, s) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    return vy.findPreviousMatch(this, new xf(e, i, r, o), a, s);
  }
  //#endregion
  //#region Editing
  pushStackElement() {
    this._commandManager.pushStackElement();
  }
  popStackElement() {
    this._commandManager.popStackElement();
  }
  pushEOL(e) {
    if ((this.getEOL() === `
` ? 0 : 1) !== e)
      try {
        this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEOL(e);
      } finally {
        this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
      }
  }
  _validateEditOperation(e) {
    return e instanceof ZL ? e : new ZL(e.identifier || null, this.validateRange(e.range), e.text, e.forceMoveMarkers || !1, e.isAutoWhitespaceEdit || !1, e._isTracked || !1);
  }
  _validateEditOperations(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++)
      t[i] = this._validateEditOperation(e[i]);
    return t;
  }
  pushEditOperations(e, t, i) {
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._pushEditOperations(e, this._validateEditOperations(t), i);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _pushEditOperations(e, t, i) {
    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
      let r = t.map((s) => ({
        range: this.validateRange(s.range),
        text: s.text
      })), o = !0;
      if (e)
        for (let s = 0, a = e.length; s < a; s++) {
          let l = e[s], u = !1;
          for (let c = 0, h = r.length; c < h; c++) {
            let d = r[c].range, f = d.startLineNumber > l.endLineNumber, p = l.startLineNumber > d.endLineNumber;
            if (!f && !p) {
              u = !0;
              break;
            }
          }
          if (!u) {
            o = !1;
            break;
          }
        }
      if (o)
        for (let s = 0, a = this._trimAutoWhitespaceLines.length; s < a; s++) {
          let l = this._trimAutoWhitespaceLines[s], u = this.getLineMaxColumn(l), c = !0;
          for (let h = 0, d = r.length; h < d; h++) {
            let f = r[h].range, p = r[h].text;
            if (!(l < f.startLineNumber || l > f.endLineNumber) && !(l === f.startLineNumber && f.startColumn === u && f.isEmpty() && p && p.length > 0 && p.charAt(0) === `
`) && !(l === f.startLineNumber && f.startColumn === 1 && f.isEmpty() && p && p.length > 0 && p.charAt(p.length - 1) === `
`)) {
              c = !1;
              break;
            }
          }
          if (c) {
            const h = new V(l, 1, l, u);
            t.push(new ZL(null, h, null, !1, !1, !1));
          }
        }
      this._trimAutoWhitespaceLines = null;
    }
    return this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEditOperation(e, t, i);
  }
  _applyUndo(e, t, i, r) {
    const o = e.map((s) => {
      const a = this.getPositionAt(s.newPosition), l = this.getPositionAt(s.newEnd);
      return {
        range: new V(a.lineNumber, a.column, l.lineNumber, l.column),
        text: s.oldText
      };
    });
    this._applyUndoRedoEdits(o, t, !0, !1, i, r);
  }
  _applyRedo(e, t, i, r) {
    const o = e.map((s) => {
      const a = this.getPositionAt(s.oldPosition), l = this.getPositionAt(s.oldEnd);
      return {
        range: new V(a.lineNumber, a.column, l.lineNumber, l.column),
        text: s.newText
      };
    });
    this._applyUndoRedoEdits(o, t, !1, !0, i, r);
  }
  _applyUndoRedoEdits(e, t, i, r, o, s) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._isUndoing = i, this._isRedoing = r, this.applyEdits(e, !1), this.setEOL(t), this._overwriteAlternativeVersionId(o);
    } finally {
      this._isUndoing = !1, this._isRedoing = !1, this._eventEmitter.endDeferredEmit(s), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  applyEdits(e, t = !1) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit();
      const i = this._validateEditOperations(e);
      return this._doApplyEdits(i, t);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _doApplyEdits(e, t) {
    const i = this._buffer.getLineCount(), r = this._buffer.applyEdits(e, this._options.trimAutoWhitespace, t), o = this._buffer.getLineCount(), s = r.changes;
    if (this._trimAutoWhitespaceLines = r.trimAutoWhitespaceLineNumbers, s.length !== 0) {
      let a = [], l = i;
      for (let u = 0, c = s.length; u < c; u++) {
        const h = s[u], [d, f, p] = Zv(h.text);
        this._tokens.acceptEdit(h.range, d, f), this._tokens2.acceptEdit(
          h.range,
          d,
          f,
          p,
          h.text.length > 0 ? h.text.charCodeAt(0) : 0
          /* Null */
        ), this._onDidChangeDecorations.fire(), this._decorationsTree.acceptReplace(h.rangeOffset, h.rangeLength, h.text.length, h.forceMoveMarkers);
        const g = h.range.startLineNumber, _ = h.range.endLineNumber, m = _ - g, v = d, C = Math.min(m, v), y = v - m;
        for (let b = C; b >= 0; b--) {
          const L = g + b, S = o - l - y + L;
          a.push(new Fle(L, this.getLineContent(S)));
        }
        if (C < m) {
          const b = g + C;
          a.push(new kle(b + 1, _));
        }
        if (C < v) {
          const b = g + C, L = v - C, S = o - l - L + b + 1;
          let E = [];
          for (let D = 0; D < L; D++) {
            let O = S + D;
            E[O - S] = this.getLineContent(O);
          }
          a.push(new Wle(b + 1, g + v, E));
        }
        l += y;
      }
      this._increaseVersionId(), this._emitContentChangedEvent(new wp(a, this.getVersionId(), this._isUndoing, this._isRedoing), {
        changes: s,
        eol: this._buffer.getEOL(),
        versionId: this.getVersionId(),
        isUndoing: this._isUndoing,
        isRedoing: this._isRedoing,
        isFlush: !1
      });
    }
    return r.reverseEdits === null ? void 0 : r.reverseEdits;
  }
  undo() {
    return this._undoRedoService.undo(this.uri);
  }
  canUndo() {
    return this._undoRedoService.canUndo(this.uri);
  }
  redo() {
    return this._undoRedoService.redo(this.uri);
  }
  canRedo() {
    return this._undoRedoService.canRedo(this.uri);
  }
  //#endregion
  //#region Decorations
  changeDecorations(e, t = 0) {
    this._assertNotDisposed();
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._changeDecorations(t, e);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _changeDecorations(e, t) {
    let i = {
      addDecoration: (o, s) => this._deltaDecorationsImpl(e, [], [{ range: o, options: s }])[0],
      changeDecoration: (o, s) => {
        this._changeDecorationImpl(o, s);
      },
      changeDecorationOptions: (o, s) => {
        this._changeDecorationOptionsImpl(o, Jk(s));
      },
      removeDecoration: (o) => {
        this._deltaDecorationsImpl(e, [o], []);
      },
      deltaDecorations: (o, s) => o.length === 0 && s.length === 0 ? [] : this._deltaDecorationsImpl(e, o, s)
    }, r = null;
    try {
      r = t(i);
    } catch (o) {
      Ni(o);
    }
    return i.addDecoration = Tm, i.changeDecoration = Tm, i.changeDecorationOptions = Tm, i.removeDecoration = Tm, i.deltaDecorations = Tm, r;
  }
  deltaDecorations(e, t, i = 0) {
    if (this._assertNotDisposed(), e || (e = []), e.length === 0 && t.length === 0)
      return [];
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._deltaDecorationsImpl(i, e, t);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _getTrackedRange(e) {
    return this.getDecorationRange(e);
  }
  _setTrackedRange(e, t, i) {
    const r = e ? this._decorations[e] : null;
    if (!r)
      return t ? this._deltaDecorationsImpl(0, [], [{ range: t, options: Qk[i] }])[0] : null;
    if (!t)
      return this._decorationsTree.delete(r), delete this._decorations[r.id], null;
    const o = this._validateRangeRelaxedNoAllocations(t), s = this._buffer.getOffsetAt(o.startLineNumber, o.startColumn), a = this._buffer.getOffsetAt(o.endLineNumber, o.endColumn);
    return this._decorationsTree.delete(r), r.reset(this.getVersionId(), s, a, o), r.setOptions(Qk[i]), this._decorationsTree.insert(r), r.id;
  }
  removeAllDecorationsWithOwnerId(e) {
    if (this._isDisposed)
      return;
    const t = this._decorationsTree.collectNodesFromOwner(e);
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      this._decorationsTree.delete(o), delete this._decorations[o.id];
    }
  }
  getDecorationOptions(e) {
    const t = this._decorations[e];
    return t ? t.options : null;
  }
  getDecorationRange(e) {
    const t = this._decorations[e];
    if (!t)
      return null;
    const i = this.getVersionId();
    return t.cachedVersionId !== i && this._decorationsTree.resolveNode(t, i), t.range === null && (t.range = this._getRangeAt(t.cachedAbsoluteStart, t.cachedAbsoluteEnd)), t.range;
  }
  getLineDecorations(e, t = 0, i = !1) {
    return e < 1 || e > this.getLineCount() ? [] : this.getLinesDecorations(e, e, t, i);
  }
  getLinesDecorations(e, t, i = 0, r = !1) {
    let o = this.getLineCount(), s = Math.min(o, Math.max(1, e)), a = Math.min(o, Math.max(1, t)), l = this.getLineMaxColumn(a);
    return this._getDecorationsInRange(new V(s, 1, a, l), i, r);
  }
  getDecorationsInRange(e, t = 0, i = !1) {
    let r = this.validateRange(e);
    return this._getDecorationsInRange(r, t, i);
  }
  getOverviewRulerDecorations(e = 0, t = !1) {
    const i = this.getVersionId(), r = this._decorationsTree.search(e, t, !0, i);
    return this._ensureNodesHaveRanges(r);
  }
  getAllDecorations(e = 0, t = !1) {
    const i = this.getVersionId(), r = this._decorationsTree.search(e, t, !1, i);
    return this._ensureNodesHaveRanges(r);
  }
  _getDecorationsInRange(e, t, i) {
    const r = this._buffer.getOffsetAt(e.startLineNumber, e.startColumn), o = this._buffer.getOffsetAt(e.endLineNumber, e.endColumn), s = this.getVersionId(), a = this._decorationsTree.intervalSearch(r, o, t, i, s);
    return this._ensureNodesHaveRanges(a);
  }
  _ensureNodesHaveRanges(e) {
    for (let t = 0, i = e.length; t < i; t++) {
      const r = e[t];
      r.range === null && (r.range = this._getRangeAt(r.cachedAbsoluteStart, r.cachedAbsoluteEnd));
    }
    return e;
  }
  _getRangeAt(e, t) {
    return this._buffer.getRangeAt(e, t - e);
  }
  _changeDecorationImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    const r = this._validateRangeRelaxedNoAllocations(t), o = this._buffer.getOffsetAt(r.startLineNumber, r.startColumn), s = this._buffer.getOffsetAt(r.endLineNumber, r.endColumn);
    this._decorationsTree.delete(i), i.reset(this.getVersionId(), o, s, r), this._decorationsTree.insert(i), this._onDidChangeDecorations.checkAffectedAndFire(i.options);
  }
  _changeDecorationOptionsImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    const r = !!(i.options.overviewRuler && i.options.overviewRuler.color), o = !!(t.overviewRuler && t.overviewRuler.color);
    this._onDidChangeDecorations.checkAffectedAndFire(i.options), this._onDidChangeDecorations.checkAffectedAndFire(t), r !== o ? (this._decorationsTree.delete(i), i.setOptions(t), this._decorationsTree.insert(i)) : i.setOptions(t);
  }
  _deltaDecorationsImpl(e, t, i) {
    const r = this.getVersionId(), o = t.length;
    let s = 0;
    const a = i.length;
    let l = 0, u = new Array(a);
    for (; s < o || l < a; ) {
      let c = null;
      if (s < o) {
        do
          c = this._decorations[t[s++]];
        while (!c && s < o);
        c && (this._decorationsTree.delete(c), this._onDidChangeDecorations.checkAffectedAndFire(c.options));
      }
      if (l < a) {
        if (!c) {
          const _ = ++this._lastDecorationId, m = `${this._instanceId};${_}`;
          c = new e3(m, 0, 0), this._decorations[m] = c;
        }
        const h = i[l], d = this._validateRangeRelaxedNoAllocations(h.range), f = Jk(h.options), p = this._buffer.getOffsetAt(d.startLineNumber, d.startColumn), g = this._buffer.getOffsetAt(d.endLineNumber, d.endColumn);
        c.ownerId = e, c.reset(r, p, g, d), c.setOptions(f), this._onDidChangeDecorations.checkAffectedAndFire(f), this._decorationsTree.insert(c), u[l] = c.id, l++;
      } else
        c && delete this._decorations[c.id];
    }
    return u;
  }
  setTokens(e) {
    if (e.length === 0)
      return;
    let t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i];
      let s = 0, a = 0, l = !1;
      for (let u = 0, c = o.tokens.length; u < c; u++) {
        const h = o.startLineNumber + u;
        l ? (this._tokens.setTokens(this._languageIdentifier.id, h - 1, this._buffer.getLineLength(h), o.tokens[u], !1), a = h) : this._tokens.setTokens(this._languageIdentifier.id, h - 1, this._buffer.getLineLength(h), o.tokens[u], !0) && (l = !0, s = h, a = h);
      }
      l && t.push({ fromLineNumber: s, toLineNumber: a });
    }
    t.length > 0 && this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: !1,
      semanticTokensApplied: !1,
      ranges: t
    });
  }
  setSemanticTokens(e, t) {
    this._tokens2.set(e, t), this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: !1,
      semanticTokensApplied: e !== null,
      ranges: [{ fromLineNumber: 1, toLineNumber: this.getLineCount() }]
    });
  }
  hasCompleteSemanticTokens() {
    return this._tokens2.isComplete();
  }
  hasSomeSemanticTokens() {
    return !this._tokens2.isEmpty();
  }
  setPartialSemanticTokens(e, t) {
    if (this.hasCompleteSemanticTokens())
      return;
    const i = this._tokens2.setPartial(e, t);
    this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: !1,
      semanticTokensApplied: !0,
      ranges: [{ fromLineNumber: i.startLineNumber, toLineNumber: i.endLineNumber }]
    });
  }
  tokenizeViewport(e, t) {
    e = Math.max(1, e), t = Math.min(this._buffer.getLineCount(), t), this._tokenization.tokenizeViewport(e, t);
  }
  clearTokens() {
    this._tokens.flush(), this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: !0,
      semanticTokensApplied: !1,
      ranges: [{
        fromLineNumber: 1,
        toLineNumber: this._buffer.getLineCount()
      }]
    });
  }
  _emitModelTokensChangedEvent(e) {
    this._isDisposing || this._onDidChangeTokens.fire(e);
  }
  resetTokenization() {
    this._tokenization.reset();
  }
  forceTokenization(e) {
    if (e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    this._tokenization.forceTokenization(e);
  }
  isCheapToTokenize(e) {
    return this._tokenization.isCheapToTokenize(e);
  }
  tokenizeIfCheap(e) {
    this.isCheapToTokenize(e) && this.forceTokenization(e);
  }
  getLineTokens(e) {
    if (e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._getLineTokens(e);
  }
  _getLineTokens(e) {
    const t = this.getLineContent(e), i = this._tokens.getTokens(this._languageIdentifier.id, e - 1, t);
    return this._tokens2.addSemanticTokens(e, i);
  }
  getLanguageIdentifier() {
    return this._languageIdentifier;
  }
  getModeId() {
    return this._languageIdentifier.language;
  }
  setMode(e) {
    if (this._languageIdentifier.id === e.id)
      return;
    let t = {
      oldLanguage: this._languageIdentifier.language,
      newLanguage: e.language
    };
    this._languageIdentifier = e, this._onDidChangeLanguage.fire(t), this._onDidChangeLanguageConfiguration.fire({});
  }
  getLanguageIdAtPosition(e, t) {
    const i = this.validatePosition(new J(e, t)), r = this.getLineTokens(i.lineNumber);
    return r.getLanguageId(r.findTokenIndexAtOffset(i.column - 1));
  }
  // Having tokens allows implementing additional helper methods
  getWordAtPosition(e) {
    this._assertNotDisposed();
    const t = this.validatePosition(e), i = this.getLineContent(t.lineNumber), r = this._getLineTokens(t.lineNumber), o = r.findTokenIndexAtOffset(t.column - 1), [s, a] = Kr._findLanguageBoundaries(r, o), l = eb(t.column, ui.getWordDefinition(r.getLanguageId(o)), i.substring(s, a), s);
    if (l && l.startColumn <= e.column && e.column <= l.endColumn)
      return l;
    if (o > 0 && s === t.column - 1) {
      const [u, c] = Kr._findLanguageBoundaries(r, o - 1), h = eb(t.column, ui.getWordDefinition(r.getLanguageId(o - 1)), i.substring(u, c), u);
      if (h && h.startColumn <= e.column && e.column <= h.endColumn)
        return h;
    }
    return null;
  }
  static _findLanguageBoundaries(e, t) {
    const i = e.getLanguageId(t);
    let r = 0;
    for (let s = t; s >= 0 && e.getLanguageId(s) === i; s--)
      r = e.getStartOffset(s);
    let o = e.getLineContent().length;
    for (let s = t, a = e.getCount(); s < a && e.getLanguageId(s) === i; s++)
      o = e.getEndOffset(s);
    return [r, o];
  }
  getWordUntilPosition(e) {
    const t = this.getWordAtPosition(e);
    return t ? {
      word: t.word.substr(0, e.column - t.startColumn),
      startColumn: t.startColumn,
      endColumn: e.column
    } : {
      word: "",
      startColumn: e.column,
      endColumn: e.column
    };
  }
  findMatchingBracketUp(e, t) {
    let i = e.toLowerCase(), r = this.validatePosition(t), o = this._getLineTokens(r.lineNumber), s = o.getLanguageId(o.findTokenIndexAtOffset(r.column - 1)), a = ui.getBracketsSupport(s);
    if (!a)
      return null;
    let l = a.textIsBracket[i];
    return l ? Cy(this._findMatchingBracketUp(l, r, null)) : null;
  }
  matchBracket(e) {
    return this._matchBracket(this.validatePosition(e));
  }
  _establishBracketSearchOffsets(e, t, i, r) {
    const o = t.getCount(), s = t.getLanguageId(r);
    let a = Math.max(0, e.column - 1 - i.maxBracketLength);
    for (let u = r - 1; u >= 0; u--) {
      const c = t.getEndOffset(u);
      if (c <= a)
        break;
      if (Ll(t.getStandardTokenType(u)) || t.getLanguageId(u) !== s) {
        a = c;
        break;
      }
    }
    let l = Math.min(t.getLineContent().length, e.column - 1 + i.maxBracketLength);
    for (let u = r + 1; u < o; u++) {
      const c = t.getStartOffset(u);
      if (c >= l)
        break;
      if (Ll(t.getStandardTokenType(u)) || t.getLanguageId(u) !== s) {
        l = c;
        break;
      }
    }
    return { searchStartOffset: a, searchEndOffset: l };
  }
  _matchBracket(e) {
    const t = e.lineNumber, i = this._getLineTokens(t), r = this._buffer.getLineContent(t), o = i.findTokenIndexAtOffset(e.column - 1);
    if (o < 0)
      return null;
    const s = ui.getBracketsSupport(i.getLanguageId(o));
    if (s && !Ll(i.getStandardTokenType(o))) {
      let { searchStartOffset: a, searchEndOffset: l } = this._establishBracketSearchOffsets(e, i, s, o), u = null;
      for (; ; ) {
        const c = Zs.findNextBracketInRange(s.forwardRegex, t, r, a, l);
        if (!c)
          break;
        if (c.startColumn <= e.column && e.column <= c.endColumn) {
          const h = r.substring(c.startColumn - 1, c.endColumn - 1).toLowerCase(), d = this._matchFoundBracket(c, s.textIsBracket[h], s.textIsOpenBracket[h], null);
          if (d) {
            if (d instanceof Tu)
              return null;
            u = d;
          }
        }
        a = c.endColumn - 1;
      }
      if (u)
        return u;
    }
    if (o > 0 && i.getStartOffset(o) === e.column - 1) {
      const a = o - 1, l = ui.getBracketsSupport(i.getLanguageId(a));
      if (l && !Ll(i.getStandardTokenType(a))) {
        let { searchStartOffset: u, searchEndOffset: c } = this._establishBracketSearchOffsets(e, i, l, a);
        const h = Zs.findPrevBracketInRange(l.reversedRegex, t, r, u, c);
        if (h && h.startColumn <= e.column && e.column <= h.endColumn) {
          const d = r.substring(h.startColumn - 1, h.endColumn - 1).toLowerCase(), f = this._matchFoundBracket(h, l.textIsBracket[d], l.textIsOpenBracket[d], null);
          if (f)
            return f instanceof Tu ? null : f;
        }
      }
    }
    return null;
  }
  _matchFoundBracket(e, t, i, r) {
    if (!t)
      return null;
    const o = i ? this._findMatchingBracketDown(t, e.getEndPosition(), r) : this._findMatchingBracketUp(t, e.getStartPosition(), r);
    return o ? o instanceof Tu ? o : [e, o] : null;
  }
  _findMatchingBracketUp(e, t, i) {
    const r = e.languageIdentifier.id, o = e.reversedRegex;
    let s = -1, a = 0;
    const l = (u, c, h, d) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return Tu.INSTANCE;
        const f = Zs.findPrevBracketInRange(o, u, c, h, d);
        if (!f)
          break;
        const p = c.substring(f.startColumn - 1, f.endColumn - 1).toLowerCase();
        if (e.isOpen(p) ? s++ : e.isClose(p) && s--, s === 0)
          return f;
        d = f.startColumn - 1;
      }
      return null;
    };
    for (let u = t.lineNumber; u >= 1; u--) {
      const c = this._getLineTokens(u), h = c.getCount(), d = this._buffer.getLineContent(u);
      let f = h - 1, p = d.length, g = d.length;
      u === t.lineNumber && (f = c.findTokenIndexAtOffset(t.column - 1), p = t.column - 1, g = t.column - 1);
      let _ = !0;
      for (; f >= 0; f--) {
        const m = c.getLanguageId(f) === r && !Ll(c.getStandardTokenType(f));
        if (m)
          _ ? p = c.getStartOffset(f) : (p = c.getStartOffset(f), g = c.getEndOffset(f));
        else if (_ && p !== g) {
          const v = l(u, d, p, g);
          if (v)
            return v;
        }
        _ = m;
      }
      if (_ && p !== g) {
        const m = l(u, d, p, g);
        if (m)
          return m;
      }
    }
    return null;
  }
  _findMatchingBracketDown(e, t, i) {
    const r = e.languageIdentifier.id, o = e.forwardRegex;
    let s = 1, a = 0;
    const l = (c, h, d, f) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return Tu.INSTANCE;
        const p = Zs.findNextBracketInRange(o, c, h, d, f);
        if (!p)
          break;
        const g = h.substring(p.startColumn - 1, p.endColumn - 1).toLowerCase();
        if (e.isOpen(g) ? s++ : e.isClose(g) && s--, s === 0)
          return p;
        d = p.endColumn - 1;
      }
      return null;
    }, u = this.getLineCount();
    for (let c = t.lineNumber; c <= u; c++) {
      const h = this._getLineTokens(c), d = h.getCount(), f = this._buffer.getLineContent(c);
      let p = 0, g = 0, _ = 0;
      c === t.lineNumber && (p = h.findTokenIndexAtOffset(t.column - 1), g = t.column - 1, _ = t.column - 1);
      let m = !0;
      for (; p < d; p++) {
        const v = h.getLanguageId(p) === r && !Ll(h.getStandardTokenType(p));
        if (v)
          m || (g = h.getStartOffset(p)), _ = h.getEndOffset(p);
        else if (m && g !== _) {
          const C = l(c, f, g, _);
          if (C)
            return C;
        }
        m = v;
      }
      if (m && g !== _) {
        const v = l(c, f, g, _);
        if (v)
          return v;
      }
    }
    return null;
  }
  findPrevBracket(e) {
    const t = this.validatePosition(e);
    let i = -1, r = null;
    for (let o = t.lineNumber; o >= 1; o--) {
      const s = this._getLineTokens(o), a = s.getCount(), l = this._buffer.getLineContent(o);
      let u = a - 1, c = l.length, h = l.length;
      if (o === t.lineNumber) {
        u = s.findTokenIndexAtOffset(t.column - 1), c = t.column - 1, h = t.column - 1;
        const f = s.getLanguageId(u);
        i !== f && (i = f, r = ui.getBracketsSupport(i));
      }
      let d = !0;
      for (; u >= 0; u--) {
        const f = s.getLanguageId(u);
        if (i !== f) {
          if (r && d && c !== h) {
            const g = Zs.findPrevBracketInRange(r.reversedRegex, o, l, c, h);
            if (g)
              return this._toFoundBracket(r, g);
            d = !1;
          }
          i = f, r = ui.getBracketsSupport(i);
        }
        const p = !!r && !Ll(s.getStandardTokenType(u));
        if (p)
          d ? c = s.getStartOffset(u) : (c = s.getStartOffset(u), h = s.getEndOffset(u));
        else if (r && d && c !== h) {
          const g = Zs.findPrevBracketInRange(r.reversedRegex, o, l, c, h);
          if (g)
            return this._toFoundBracket(r, g);
        }
        d = p;
      }
      if (r && d && c !== h) {
        const f = Zs.findPrevBracketInRange(r.reversedRegex, o, l, c, h);
        if (f)
          return this._toFoundBracket(r, f);
      }
    }
    return null;
  }
  findNextBracket(e) {
    const t = this.validatePosition(e), i = this.getLineCount();
    let r = -1, o = null;
    for (let s = t.lineNumber; s <= i; s++) {
      const a = this._getLineTokens(s), l = a.getCount(), u = this._buffer.getLineContent(s);
      let c = 0, h = 0, d = 0;
      if (s === t.lineNumber) {
        c = a.findTokenIndexAtOffset(t.column - 1), h = t.column - 1, d = t.column - 1;
        const p = a.getLanguageId(c);
        r !== p && (r = p, o = ui.getBracketsSupport(r));
      }
      let f = !0;
      for (; c < l; c++) {
        const p = a.getLanguageId(c);
        if (r !== p) {
          if (o && f && h !== d) {
            const _ = Zs.findNextBracketInRange(o.forwardRegex, s, u, h, d);
            if (_)
              return this._toFoundBracket(o, _);
            f = !1;
          }
          r = p, o = ui.getBracketsSupport(r);
        }
        const g = !!o && !Ll(a.getStandardTokenType(c));
        if (g)
          f || (h = a.getStartOffset(c)), d = a.getEndOffset(c);
        else if (o && f && h !== d) {
          const _ = Zs.findNextBracketInRange(o.forwardRegex, s, u, h, d);
          if (_)
            return this._toFoundBracket(o, _);
        }
        f = g;
      }
      if (o && f && h !== d) {
        const p = Zs.findNextBracketInRange(o.forwardRegex, s, u, h, d);
        if (p)
          return this._toFoundBracket(o, p);
      }
    }
    return null;
  }
  findEnclosingBrackets(e, t) {
    let i;
    if (typeof t > "u")
      i = null;
    else {
      const f = Date.now();
      i = () => Date.now() - f <= t;
    }
    const r = this.validatePosition(e), o = this.getLineCount(), s = /* @__PURE__ */ new Map();
    let a = [];
    const l = (f, p) => {
      if (!s.has(f)) {
        let g = [];
        for (let _ = 0, m = p ? p.brackets.length : 0; _ < m; _++)
          g[_] = 0;
        s.set(f, g);
      }
      a = s.get(f);
    };
    let u = 0;
    const c = (f, p, g, _, m) => {
      for (; ; ) {
        if (i && ++u % 100 === 0 && !i())
          return Tu.INSTANCE;
        const v = Zs.findNextBracketInRange(f.forwardRegex, p, g, _, m);
        if (!v)
          break;
        const C = g.substring(v.startColumn - 1, v.endColumn - 1).toLowerCase(), y = f.textIsBracket[C];
        if (y && (y.isOpen(C) ? a[y.index]++ : y.isClose(C) && a[y.index]--, a[y.index] === -1))
          return this._matchFoundBracket(v, y, !1, i);
        _ = v.endColumn - 1;
      }
      return null;
    };
    let h = -1, d = null;
    for (let f = r.lineNumber; f <= o; f++) {
      const p = this._getLineTokens(f), g = p.getCount(), _ = this._buffer.getLineContent(f);
      let m = 0, v = 0, C = 0;
      if (f === r.lineNumber) {
        m = p.findTokenIndexAtOffset(r.column - 1), v = r.column - 1, C = r.column - 1;
        const b = p.getLanguageId(m);
        h !== b && (h = b, d = ui.getBracketsSupport(h), l(h, d));
      }
      let y = !0;
      for (; m < g; m++) {
        const b = p.getLanguageId(m);
        if (h !== b) {
          if (d && y && v !== C) {
            const S = c(d, f, _, v, C);
            if (S)
              return Cy(S);
            y = !1;
          }
          h = b, d = ui.getBracketsSupport(h), l(h, d);
        }
        const L = !!d && !Ll(p.getStandardTokenType(m));
        if (L)
          y || (v = p.getStartOffset(m)), C = p.getEndOffset(m);
        else if (d && y && v !== C) {
          const S = c(d, f, _, v, C);
          if (S)
            return Cy(S);
        }
        y = L;
      }
      if (d && y && v !== C) {
        const b = c(d, f, _, v, C);
        if (b)
          return Cy(b);
      }
    }
    return null;
  }
  _toFoundBracket(e, t) {
    if (!t)
      return null;
    let i = this.getValueInRange(t);
    i = i.toLowerCase();
    let r = e.textIsBracket[i];
    return r ? {
      range: t,
      open: r.open,
      close: r.close,
      isOpen: e.textIsOpenBracket[i]
    } : null;
  }
  /**
   * Returns:
   *  - -1 => the line consists of whitespace
   *  - otherwise => the indent level is returned value
   */
  static computeIndentLevel(e, t) {
    let i = 0, r = 0, o = e.length;
    for (; r < o; ) {
      let s = e.charCodeAt(r);
      if (s === 32)
        i++;
      else if (s === 9)
        i = i - i % t + t;
      else
        break;
      r++;
    }
    return r === o ? -1 : i;
  }
  _computeIndentLevel(e) {
    return Kr.computeIndentLevel(this._buffer.getLineContent(e + 1), this._options.tabSize);
  }
  getActiveIndentGuide(e, t, i) {
    this._assertNotDisposed();
    const r = this.getLineCount();
    if (e < 1 || e > r)
      throw new Error("Illegal value for lineNumber");
    const o = ui.getFoldingRules(this._languageIdentifier.id), s = !!(o && o.offSide);
    let a = -2, l = -1, u = -2, c = -1;
    const h = (S) => {
      if (a !== -1 && (a === -2 || a > S - 1)) {
        a = -1, l = -1;
        for (let E = S - 2; E >= 0; E--) {
          let D = this._computeIndentLevel(E);
          if (D >= 0) {
            a = E, l = D;
            break;
          }
        }
      }
      if (u === -2) {
        u = -1, c = -1;
        for (let E = S; E < r; E++) {
          let D = this._computeIndentLevel(E);
          if (D >= 0) {
            u = E, c = D;
            break;
          }
        }
      }
    };
    let d = -2, f = -1, p = -2, g = -1;
    const _ = (S) => {
      if (d === -2) {
        d = -1, f = -1;
        for (let E = S - 2; E >= 0; E--) {
          let D = this._computeIndentLevel(E);
          if (D >= 0) {
            d = E, f = D;
            break;
          }
        }
      }
      if (p !== -1 && (p === -2 || p < S - 1)) {
        p = -1, g = -1;
        for (let E = S; E < r; E++) {
          let D = this._computeIndentLevel(E);
          if (D >= 0) {
            p = E, g = D;
            break;
          }
        }
      }
    };
    let m = 0, v = !0, C = 0, y = !0, b = 0, L = 0;
    for (let S = 0; v || y; S++) {
      const E = e - S, D = e + S;
      S > 1 && (E < 1 || E < t) && (v = !1), S > 1 && (D > r || D > i) && (y = !1), S > 5e4 && (v = !1, y = !1);
      let O = -1;
      if (v) {
        const A = this._computeIndentLevel(E - 1);
        A >= 0 ? (u = E - 1, c = A, O = Math.ceil(A / this._options.indentSize)) : (h(E), O = this._getIndentLevelForWhitespaceLine(s, l, c));
      }
      let T = -1;
      if (y) {
        const A = this._computeIndentLevel(D - 1);
        A >= 0 ? (d = D - 1, f = A, T = Math.ceil(A / this._options.indentSize)) : (_(D), T = this._getIndentLevelForWhitespaceLine(s, f, g));
      }
      if (S === 0) {
        L = O;
        continue;
      }
      if (S === 1) {
        if (D <= r && T >= 0 && L + 1 === T) {
          v = !1, m = D, C = D, b = T;
          continue;
        }
        if (E >= 1 && O >= 0 && O - 1 === L) {
          y = !1, m = E, C = E, b = O;
          continue;
        }
        if (m = e, C = e, b = L, b === 0)
          return { startLineNumber: m, endLineNumber: C, indent: b };
      }
      v && (O >= b ? m = E : v = !1), y && (T >= b ? C = D : y = !1);
    }
    return { startLineNumber: m, endLineNumber: C, indent: b };
  }
  getLinesIndentGuides(e, t) {
    this._assertNotDisposed();
    const i = this.getLineCount();
    if (e < 1 || e > i)
      throw new Error("Illegal value for startLineNumber");
    if (t < 1 || t > i)
      throw new Error("Illegal value for endLineNumber");
    const r = ui.getFoldingRules(this._languageIdentifier.id), o = !!(r && r.offSide);
    let s = new Array(t - e + 1), a = -2, l = -1, u = -2, c = -1;
    for (let h = e; h <= t; h++) {
      let d = h - e;
      const f = this._computeIndentLevel(h - 1);
      if (f >= 0) {
        a = h - 1, l = f, s[d] = Math.ceil(f / this._options.indentSize);
        continue;
      }
      if (a === -2) {
        a = -1, l = -1;
        for (let p = h - 2; p >= 0; p--) {
          let g = this._computeIndentLevel(p);
          if (g >= 0) {
            a = p, l = g;
            break;
          }
        }
      }
      if (u !== -1 && (u === -2 || u < h - 1)) {
        u = -1, c = -1;
        for (let p = h; p < i; p++) {
          let g = this._computeIndentLevel(p);
          if (g >= 0) {
            u = p, c = g;
            break;
          }
        }
      }
      s[d] = this._getIndentLevelForWhitespaceLine(o, l, c);
    }
    return s;
  }
  _getIndentLevelForWhitespaceLine(e, t, i) {
    return t === -1 || i === -1 ? 0 : t < i ? 1 + Math.floor(t / this._options.indentSize) : t === i ? Math.ceil(i / this._options.indentSize) : e ? Math.ceil(i / this._options.indentSize) : 1 + Math.floor(i / this._options.indentSize);
  }
  //#endregion
  normalizePosition(e, t) {
    return e;
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return qle(this.getLineContent(e)) + 1;
  }
}
Kr.MODEL_SYNC_LIMIT = 50 * 1024 * 1024;
Kr.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024;
Kr.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3;
Kr.DEFAULT_CREATION_OPTIONS = {
  isForSimpleWidget: !1,
  tabSize: Co.tabSize,
  indentSize: Co.indentSize,
  insertSpaces: Co.insertSpaces,
  detectIndentation: !1,
  defaultEOL: 1,
  trimAutoWhitespace: Co.trimAutoWhitespace,
  largeFileOptimizations: Co.largeFileOptimizations
};
function qle(n) {
  let e = 0;
  for (const t of n)
    if (t === " " || t === "	")
      e++;
    else
      break;
  return e;
}
class Zk {
  constructor() {
    this._decorationsTree0 = new Uk(), this._decorationsTree1 = new Uk();
  }
  intervalSearch(e, t, i, r, o) {
    const s = this._decorationsTree0.intervalSearch(e, t, i, r, o), a = this._decorationsTree1.intervalSearch(e, t, i, r, o);
    return s.concat(a);
  }
  search(e, t, i, r) {
    if (i)
      return this._decorationsTree1.search(e, t, r);
    {
      const o = this._decorationsTree0.search(e, t, r), s = this._decorationsTree1.search(e, t, r);
      return o.concat(s);
    }
  }
  collectNodesFromOwner(e) {
    const t = this._decorationsTree0.collectNodesFromOwner(e), i = this._decorationsTree1.collectNodesFromOwner(e);
    return t.concat(i);
  }
  collectNodesPostOrder() {
    const e = this._decorationsTree0.collectNodesPostOrder(), t = this._decorationsTree1.collectNodesPostOrder();
    return e.concat(t);
  }
  insert(e) {
    gD(e) ? this._decorationsTree1.insert(e) : this._decorationsTree0.insert(e);
  }
  delete(e) {
    gD(e) ? this._decorationsTree1.delete(e) : this._decorationsTree0.delete(e);
  }
  resolveNode(e, t) {
    gD(e) ? this._decorationsTree1.resolveNode(e, t) : this._decorationsTree0.resolveNode(e, t);
  }
  acceptReplace(e, t, i, r) {
    this._decorationsTree0.acceptReplace(e, t, i, r), this._decorationsTree1.acceptReplace(e, t, i, r);
  }
}
function Sc(n) {
  return n.replace(/[^a-z0-9\-_]/gi, " ");
}
class r3 {
  constructor(e) {
    this.color = e.color || "", this.darkColor = e.darkColor || "";
  }
}
class Yle extends r3 {
  constructor(e) {
    super(e), this._resolvedColor = null, this.position = typeof e.position == "number" ? e.position : Uv.Center;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = null;
  }
  _resolveColor(e, t) {
    if (typeof e == "string")
      return e;
    let i = e ? t.getColor(e.id) : null;
    return i ? i.toString() : "";
  }
}
class Xle extends r3 {
  constructor(e) {
    super(e), this.position = e.position;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = void 0;
  }
  _resolveColor(e, t) {
    return typeof e == "string" ? ee.fromHex(e) : t.getColor(e.id);
  }
}
class Mn {
  constructor(e) {
    this.description = e.description, this.stickiness = e.stickiness || 0, this.zIndex = e.zIndex || 0, this.className = e.className ? Sc(e.className) : null, this.hoverMessage = e.hoverMessage || null, this.glyphMarginHoverMessage = e.glyphMarginHoverMessage || null, this.isWholeLine = e.isWholeLine || !1, this.showIfCollapsed = e.showIfCollapsed || !1, this.collapseOnReplaceEdit = e.collapseOnReplaceEdit || !1, this.overviewRuler = e.overviewRuler ? new Yle(e.overviewRuler) : null, this.minimap = e.minimap ? new Xle(e.minimap) : null, this.glyphMarginClassName = e.glyphMarginClassName ? Sc(e.glyphMarginClassName) : null, this.linesDecorationsClassName = e.linesDecorationsClassName ? Sc(e.linesDecorationsClassName) : null, this.firstLineDecorationClassName = e.firstLineDecorationClassName ? Sc(e.firstLineDecorationClassName) : null, this.marginClassName = e.marginClassName ? Sc(e.marginClassName) : null, this.inlineClassName = e.inlineClassName ? Sc(e.inlineClassName) : null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.beforeContentClassName = e.beforeContentClassName ? Sc(e.beforeContentClassName) : null, this.afterContentClassName = e.afterContentClassName ? Sc(e.afterContentClassName) : null;
  }
  static register(e) {
    return new Mn(e);
  }
  static createDynamic(e) {
    return new Mn(e);
  }
}
Mn.EMPTY = Mn.register({ description: "empty" });
const Qk = [
  Mn.register({
    description: "tracked-range-always-grows-when-typing-at-edges",
    stickiness: 0
    /* AlwaysGrowsWhenTypingAtEdges */
  }),
  Mn.register({
    description: "tracked-range-never-grows-when-typing-at-edges",
    stickiness: 1
    /* NeverGrowsWhenTypingAtEdges */
  }),
  Mn.register({
    description: "tracked-range-grows-only-when-typing-before",
    stickiness: 2
    /* GrowsOnlyWhenTypingBefore */
  }),
  Mn.register({
    description: "tracked-range-grows-only-when-typing-after",
    stickiness: 3
    /* GrowsOnlyWhenTypingAfter */
  })
];
function Jk(n) {
  return n instanceof Mn ? n : Mn.createDynamic(n);
}
class Zle extends ge {
  constructor() {
    super(), this._actual = this._register(new j()), this.event = this._actual.event, this._deferredCnt = 0, this._shouldFire = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit() {
    if (this._deferredCnt--, this._deferredCnt === 0 && this._shouldFire) {
      const e = {
        affectsMinimap: this._affectsMinimap,
        affectsOverviewRuler: this._affectsOverviewRuler
      };
      this._shouldFire = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._actual.fire(e);
    }
  }
  checkAffectedAndFire(e) {
    this._affectsMinimap || (this._affectsMinimap = !!(e.minimap && e.minimap.position)), this._affectsOverviewRuler || (this._affectsOverviewRuler = !!(e.overviewRuler && e.overviewRuler.color)), this._shouldFire = !0;
  }
  fire() {
    this._affectsMinimap = !0, this._affectsOverviewRuler = !0, this._shouldFire = !0;
  }
}
class Qle extends ge {
  constructor() {
    super(), this._fastEmitter = this._register(new j()), this.fastEvent = this._fastEmitter.event, this._slowEmitter = this._register(new j()), this.slowEvent = this._slowEmitter.event, this._deferredCnt = 0, this._deferredEvent = null;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit(e = null) {
    if (this._deferredCnt--, this._deferredCnt === 0 && this._deferredEvent !== null) {
      this._deferredEvent.rawContentChangedEvent.resultingSelection = e;
      const t = this._deferredEvent;
      this._deferredEvent = null, this._fastEmitter.fire(t), this._slowEmitter.fire(t);
    }
  }
  fire(e) {
    if (this._deferredCnt > 0) {
      this._deferredEvent ? this._deferredEvent = this._deferredEvent.merge(e) : this._deferredEvent = e;
      return;
    }
    this._fastEmitter.fire(e), this._slowEmitter.fire(e);
  }
}
const Jle = () => !0, e2 = () => !1, eue = (n) => n === " " || n === "	";
class na {
  constructor(e, t, i) {
    this._languageIdentifier = e;
    const r = i.options, o = r.get(
      128
      /* layoutInfo */
    );
    this.readOnly = r.get(
      78
      /* readOnly */
    ), this.tabSize = t.tabSize, this.indentSize = t.indentSize, this.insertSpaces = t.insertSpaces, this.stickyTabStops = r.get(
      102
      /* stickyTabStops */
    ), this.lineHeight = r.get(
      56
      /* lineHeight */
    ), this.pageSize = Math.max(1, Math.floor(o.height / this.lineHeight) - 2), this.useTabStops = r.get(
      113
      /* useTabStops */
    ), this.wordSeparators = r.get(
      114
      /* wordSeparators */
    ), this.emptySelectionClipboard = r.get(
      30
      /* emptySelectionClipboard */
    ), this.copyWithSyntaxHighlighting = r.get(
      19
      /* copyWithSyntaxHighlighting */
    ), this.multiCursorMergeOverlapping = r.get(
      66
      /* multiCursorMergeOverlapping */
    ), this.multiCursorPaste = r.get(
      68
      /* multiCursorPaste */
    ), this.autoClosingBrackets = r.get(
      5
      /* autoClosingBrackets */
    ), this.autoClosingQuotes = r.get(
      8
      /* autoClosingQuotes */
    ), this.autoClosingDelete = r.get(
      6
      /* autoClosingDelete */
    ), this.autoClosingOvertype = r.get(
      7
      /* autoClosingOvertype */
    ), this.autoSurround = r.get(
      11
      /* autoSurround */
    ), this.autoIndent = r.get(
      9
      /* autoIndent */
    ), this.surroundingPairs = {}, this._electricChars = null, this.shouldAutoCloseBefore = {
      quote: na._getShouldAutoClose(e, this.autoClosingQuotes),
      bracket: na._getShouldAutoClose(e, this.autoClosingBrackets)
    }, this.autoClosingPairs = ui.getAutoClosingPairs(e.id);
    let s = na._getSurroundingPairs(e);
    if (s)
      for (const a of s)
        this.surroundingPairs[a.open] = a.close;
  }
  static shouldRecreate(e) {
    return e.hasChanged(
      128
      /* layoutInfo */
    ) || e.hasChanged(
      114
      /* wordSeparators */
    ) || e.hasChanged(
      30
      /* emptySelectionClipboard */
    ) || e.hasChanged(
      66
      /* multiCursorMergeOverlapping */
    ) || e.hasChanged(
      68
      /* multiCursorPaste */
    ) || e.hasChanged(
      5
      /* autoClosingBrackets */
    ) || e.hasChanged(
      8
      /* autoClosingQuotes */
    ) || e.hasChanged(
      6
      /* autoClosingDelete */
    ) || e.hasChanged(
      7
      /* autoClosingOvertype */
    ) || e.hasChanged(
      11
      /* autoSurround */
    ) || e.hasChanged(
      113
      /* useTabStops */
    ) || e.hasChanged(
      56
      /* lineHeight */
    ) || e.hasChanged(
      78
      /* readOnly */
    );
  }
  get electricChars() {
    if (!this._electricChars) {
      this._electricChars = {};
      let e = na._getElectricCharacters(this._languageIdentifier);
      if (e)
        for (const t of e)
          this._electricChars[t] = !0;
    }
    return this._electricChars;
  }
  normalizeIndentation(e) {
    return Kr.normalizeIndentation(e, this.indentSize, this.insertSpaces);
  }
  static _getElectricCharacters(e) {
    try {
      return ui.getElectricCharacters(e.id);
    } catch (t) {
      return Ni(t), null;
    }
  }
  static _getShouldAutoClose(e, t) {
    switch (t) {
      case "beforeWhitespace":
        return eue;
      case "languageDefined":
        return na._getLanguageDefinedShouldAutoClose(e);
      case "always":
        return Jle;
      case "never":
        return e2;
    }
  }
  static _getLanguageDefinedShouldAutoClose(e) {
    try {
      const t = ui.getAutoCloseBeforeSet(e.id);
      return (i) => t.indexOf(i) !== -1;
    } catch (t) {
      return Ni(t), e2;
    }
  }
  static _getSurroundingPairs(e) {
    try {
      return ui.getSurroundingPairs(e.id);
    } catch (t) {
      return Ni(t), null;
    }
  }
}
class $n {
  constructor(e, t, i, r) {
    this.selectionStart = e, this.selectionStartLeftoverVisibleColumns = t, this.position = i, this.leftoverVisibleColumns = r, this.selection = $n._computeSelection(this.selectionStart, this.position);
  }
  equals(e) {
    return this.selectionStartLeftoverVisibleColumns === e.selectionStartLeftoverVisibleColumns && this.leftoverVisibleColumns === e.leftoverVisibleColumns && this.position.equals(e.position) && this.selectionStart.equalsRange(e.selectionStart);
  }
  hasSelection() {
    return !this.selection.isEmpty() || !this.selectionStart.isEmpty();
  }
  move(e, t, i, r) {
    return e ? new $n(this.selectionStart, this.selectionStartLeftoverVisibleColumns, new J(t, i), r) : new $n(new V(t, i, t, i), r, new J(t, i), r);
  }
  static _computeSelection(e, t) {
    let i, r, o, s;
    return e.isEmpty() ? (i = e.startLineNumber, r = e.startColumn, o = t.lineNumber, s = t.column) : t.isBeforeOrEqual(e.getStartPosition()) ? (i = e.endLineNumber, r = e.endColumn, o = t.lineNumber, s = t.column) : (i = e.startLineNumber, r = e.startColumn, o = t.lineNumber, s = t.column), new Ut(i, r, o, s);
  }
}
class t2 {
  constructor(e, t, i) {
    this.model = e, this.coordinatesConverter = t, this.cursorConfig = i;
  }
}
class tue {
  constructor(e) {
    this.modelState = e, this.viewState = null;
  }
}
class iue {
  constructor(e) {
    this.modelState = null, this.viewState = e;
  }
}
class st {
  constructor(e, t) {
    this.modelState = e, this.viewState = t;
  }
  static fromModelState(e) {
    return new tue(e);
  }
  static fromViewState(e) {
    return new iue(e);
  }
  static fromModelSelection(e) {
    const t = e.selectionStartLineNumber, i = e.selectionStartColumn, r = e.positionLineNumber, o = e.positionColumn, s = new $n(new V(t, i, t, i), 0, new J(r, o), 0);
    return st.fromModelState(s);
  }
  static fromModelSelections(e) {
    let t = [];
    for (let i = 0, r = e.length; i < r; i++)
      t[i] = this.fromModelSelection(e[i]);
    return t;
  }
  equals(e) {
    return this.viewState.equals(e.viewState) && this.modelState.equals(e.modelState);
  }
}
class po {
  constructor(e, t, i) {
    this.type = e, this.commands = t, this.shouldPushStackElementBefore = i.shouldPushStackElementBefore, this.shouldPushStackElementAfter = i.shouldPushStackElementAfter;
  }
}
class Kt {
  static visibleColumnFromColumn(e, t, i) {
    const r = e.length, o = t - 1 < r ? t - 1 : r;
    let s = 0, a = 0;
    for (; a < o; ) {
      const l = Lu(e, o, a);
      if (a += l >= 65536 ? 2 : 1, l === 9)
        s = Kt.nextRenderTabStop(s, i);
      else {
        let u = Sf(l);
        for (; a < o; ) {
          const c = Lu(e, o, a), h = Sf(c);
          if (rv(u, h))
            break;
          a += c >= 65536 ? 2 : 1, u = h;
        }
        Xa(l) || nv(l) ? s = s + 2 : s = s + 1;
      }
    }
    return s;
  }
  /**
   * Returns an array that maps one based columns to one based visible columns. The entry at position 0 is -1.
  */
  static visibleColumnsByColumns(e, t) {
    const i = e.length;
    let r = new Array();
    r.push(-1);
    let o = 0, s = 0;
    for (; s < i; ) {
      const a = Lu(e, i, s);
      if (s += a >= 65536 ? 2 : 1, r.push(o), a >= 65536 && r.push(o), a === 9)
        o = Kt.nextRenderTabStop(o, t);
      else {
        let l = Sf(a);
        for (; s < i; ) {
          const u = Lu(e, i, s), c = Sf(u);
          if (rv(l, c))
            break;
          s += u >= 65536 ? 2 : 1, r.push(o), a >= 65536 && r.push(o), l = c;
        }
        Xa(a) || nv(a) ? o = o + 2 : o = o + 1;
      }
    }
    return r.push(o), r;
  }
  static visibleColumnFromColumn2(e, t, i) {
    return this.visibleColumnFromColumn(t.getLineContent(i.lineNumber), i.column, e.tabSize);
  }
  static columnFromVisibleColumn(e, t, i) {
    if (t <= 0)
      return 1;
    const r = e.length;
    let o = 0, s = 1, a = 0;
    for (; a < r; ) {
      const l = Lu(e, r, a);
      a += l >= 65536 ? 2 : 1;
      let u;
      if (l === 9)
        u = Kt.nextRenderTabStop(o, i);
      else {
        let h = Sf(l);
        for (; a < r; ) {
          const d = Lu(e, r, a), f = Sf(d);
          if (rv(h, f))
            break;
          a += d >= 65536 ? 2 : 1, h = f;
        }
        Xa(l) || nv(l) ? u = o + 2 : u = o + 1;
      }
      const c = a + 1;
      if (u >= t) {
        const h = t - o;
        return u - t < h ? c : s;
      }
      o = u, s = c;
    }
    return r + 1;
  }
  static columnFromVisibleColumn2(e, t, i, r) {
    let o = this.columnFromVisibleColumn(t.getLineContent(i), r, e.tabSize), s = t.getLineMinColumn(i);
    if (o < s)
      return s;
    let a = t.getLineMaxColumn(i);
    return o > a ? a : o;
  }
  /**
   * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
   */
  static nextRenderTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
   */
  static nextIndentTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   */
  static prevRenderTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   */
  static prevIndentTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
}
function kf(n) {
  return n === "'" || n === '"' || n === "`";
}
class Qv {
  /**
   * Get the visible column at the position. If we get to a non-whitespace character first
   * or past the end of string then return -1.
   *
   * **Note** `position` and the return value are 0-based.
   */
  static whitespaceVisibleColumn(e, t, i) {
    const r = e.length;
    let o = 0, s = -1, a = -1;
    for (let l = 0; l < r; l++) {
      if (l === t)
        return [s, a, o];
      switch (o % i === 0 && (s = l, a = o), e.charCodeAt(l)) {
        case 32:
          o += 1;
          break;
        case 9:
          o = Kt.nextRenderTabStop(o, i);
          break;
        default:
          return [-1, -1, -1];
      }
    }
    return t === r ? [s, a, o] : [-1, -1, -1];
  }
  /**
   * Return the position that should result from a move left, right or to the
   * nearest tab, if atomic tabs are enabled. Left and right are used for the
   * arrow key movements, nearest is used for mouse selection. It returns
   * -1 if atomic tabs are not relevant and you should fall back to normal
   * behaviour.
   *
   * **Note**: `position` and the return value are 0-based.
   */
  static atomicPosition(e, t, i, r) {
    const o = e.length, [s, a, l] = Qv.whitespaceVisibleColumn(e, t, i);
    if (l === -1)
      return -1;
    let u;
    switch (r) {
      case 0:
        u = !0;
        break;
      case 1:
        u = !1;
        break;
      case 2:
        if (l % i === 0)
          return t;
        u = l % i <= i / 2;
        break;
    }
    if (u) {
      if (s === -1)
        return -1;
      let d = a;
      for (let f = s; f < o; ++f) {
        if (d === a + i)
          return s;
        switch (e.charCodeAt(f)) {
          case 32:
            d += 1;
            break;
          case 9:
            d = Kt.nextRenderTabStop(d, i);
            break;
          default:
            return -1;
        }
      }
      return d === a + i ? s : -1;
    }
    const c = Kt.nextRenderTabStop(l, i);
    let h = l;
    for (let d = t; d < o; d++) {
      if (h === c)
        return d;
      switch (e.charCodeAt(d)) {
        case 32:
          h += 1;
          break;
        case 9:
          h = Kt.nextRenderTabStop(h, i);
          break;
        default:
          return -1;
      }
    }
    return h === c ? o : -1;
  }
}
class Oc {
  constructor(e = null) {
    this.hitTarget = e, this.type = 0;
  }
}
class o3 {
  constructor(e, t) {
    this.position = e, this.spanNode = t, this.type = 1;
  }
}
var Kh;
(function(n) {
  function e(t, i, r) {
    const o = t.getPositionFromDOMInfo(i, r);
    return o ? new o3(o, i) : new Oc(i);
  }
  n.createFromDOMInfo = e;
})(Kh || (Kh = {}));
class nue {
  constructor(e, t) {
    this.lastViewCursorsRenderData = e, this.lastTextareaPosition = t;
  }
}
class Ma {
  constructor(e, t, i = 0, r = null, o = null, s = null) {
    this.element = e, this.type = t, this.mouseColumn = i, this.position = r, !o && r && (o = new V(r.lineNumber, r.column, r.lineNumber, r.column)), this.range = o, this.detail = s;
  }
  static _typeToString(e) {
    return e === 1 ? "TEXTAREA" : e === 2 ? "GUTTER_GLYPH_MARGIN" : e === 3 ? "GUTTER_LINE_NUMBERS" : e === 4 ? "GUTTER_LINE_DECORATIONS" : e === 5 ? "GUTTER_VIEW_ZONE" : e === 6 ? "CONTENT_TEXT" : e === 7 ? "CONTENT_EMPTY" : e === 8 ? "CONTENT_VIEW_ZONE" : e === 9 ? "CONTENT_WIDGET" : e === 10 ? "OVERVIEW_RULER" : e === 11 ? "SCROLLBAR" : e === 12 ? "OVERLAY_WIDGET" : "UNKNOWN";
  }
  static toString(e) {
    return this._typeToString(e.type) + ": " + e.position + " - " + e.range + " - " + e.detail;
  }
  toString() {
    return Ma.toString(this);
  }
}
class Ys {
  static isTextArea(e) {
    return e.length === 2 && e[0] === 3 && e[1] === 6;
  }
  static isChildOfViewLines(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 7;
  }
  static isStrictChildOfViewLines(e) {
    return e.length > 4 && e[0] === 3 && e[3] === 7;
  }
  static isChildOfScrollableElement(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 5;
  }
  static isChildOfMinimap(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 8;
  }
  static isChildOfContentWidgets(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 1;
  }
  static isChildOfOverflowingContentWidgets(e) {
    return e.length >= 1 && e[0] === 2;
  }
  static isChildOfOverlayWidgets(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 4;
  }
}
class $p {
  constructor(e, t, i) {
    this.model = e.model;
    const r = e.configuration.options;
    this.layoutInfo = r.get(
      128
      /* layoutInfo */
    ), this.viewDomNode = t.viewDomNode, this.lineHeight = r.get(
      56
      /* lineHeight */
    ), this.stickyTabStops = r.get(
      102
      /* stickyTabStops */
    ), this.typicalHalfwidthCharacterWidth = r.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, this.lastRenderData = i, this._context = e, this._viewHelper = t;
  }
  getZoneAtCoord(e) {
    return $p.getZoneAtCoord(this._context, e);
  }
  static getZoneAtCoord(e, t) {
    const i = e.viewLayout.getWhitespaceAtVerticalOffset(t);
    if (i) {
      const r = i.verticalOffset + i.height / 2, o = e.model.getLineCount();
      let s = null, a, l = null;
      return i.afterLineNumber !== o && (l = new J(i.afterLineNumber + 1, 1)), i.afterLineNumber > 0 && (s = new J(i.afterLineNumber, e.model.getLineMaxColumn(i.afterLineNumber))), l === null ? a = s : s === null ? a = l : t < r ? a = s : a = l, {
        viewZoneId: i.id,
        afterLineNumber: i.afterLineNumber,
        positionBefore: s,
        positionAfter: l,
        position: a
      };
    }
    return null;
  }
  getFullLineRangeAtCoord(e) {
    if (this._context.viewLayout.isAfterLines(e)) {
      const r = this._context.model.getLineCount(), o = this._context.model.getLineMaxColumn(r);
      return {
        range: new V(r, o, r, o),
        isAfterLines: !0
      };
    }
    const t = this._context.viewLayout.getLineNumberAtVerticalOffset(e), i = this._context.model.getLineMaxColumn(t);
    return {
      range: new V(t, 1, t, i),
      isAfterLines: !1
    };
  }
  getLineNumberAtVerticalOffset(e) {
    return this._context.viewLayout.getLineNumberAtVerticalOffset(e);
  }
  isAfterLines(e) {
    return this._context.viewLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._context.viewLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._context.viewLayout.isInBottomPadding(e);
  }
  getVerticalOffsetForLineNumber(e) {
    return this._context.viewLayout.getVerticalOffsetForLineNumber(e);
  }
  findAttribute(e, t) {
    return $p._findAttribute(e, t, this._viewHelper.viewDomNode);
  }
  static _findAttribute(e, t, i) {
    for (; e && e !== document.body; ) {
      if (e.hasAttribute && e.hasAttribute(t))
        return e.getAttribute(t);
      if (e === i)
        return null;
      e = e.parentNode;
    }
    return null;
  }
  getLineWidth(e) {
    return this._viewHelper.getLineWidth(e);
  }
  visibleRangeForPosition(e, t) {
    return this._viewHelper.visibleRangeForPosition(e, t);
  }
  getPositionFromDOMInfo(e, t) {
    return this._viewHelper.getPositionFromDOMInfo(e, t);
  }
  getCurrentScrollTop() {
    return this._context.viewLayout.getCurrentScrollTop();
  }
  getCurrentScrollLeft() {
    return this._context.viewLayout.getCurrentScrollLeft();
  }
}
class rue {
  constructor(e, t, i) {
    this.editorPos = t, this.pos = i, this.mouseVerticalOffset = Math.max(0, e.getCurrentScrollTop() + i.y - t.y), this.mouseContentHorizontalOffset = e.getCurrentScrollLeft() + i.x - t.x - e.layoutInfo.contentLeft, this.isInMarginArea = i.x - t.x < e.layoutInfo.contentLeft && i.x - t.x >= e.layoutInfo.glyphMarginLeft, this.isInContentArea = !this.isInMarginArea, this.mouseColumn = Math.max(0, ar._getMouseColumn(this.mouseContentHorizontalOffset, e.typicalHalfwidthCharacterWidth));
  }
}
class QN extends rue {
  constructor(e, t, i, r) {
    super(e, t, i), this._ctx = e, r ? (this.target = r, this.targetPath = jl.collect(r, e.viewDomNode)) : (this.target = null, this.targetPath = new Uint8Array(0));
  }
  toString() {
    return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}
	target: ${this.target ? this.target.outerHTML : null}`;
  }
  // public fulfill(type: MouseTargetType.OVERVIEW_RULER, position?: Position | null, range?: EditorRange | null, detail?: any): MouseTarget;
  // public fulfill(type: MouseTargetType.OUTSIDE_EDITOR, position?: Position | null, range?: EditorRange | null, detail?: any): MouseTarget;
  fulfill(e, t = null, i = null, r = null) {
    let o = this.mouseColumn;
    return t && t.column < this._ctx.model.getLineMaxColumn(t.lineNumber) && (o = Kt.visibleColumnFromColumn(this._ctx.model.getLineContent(t.lineNumber), t.column, this._ctx.model.getTextModelOptions().tabSize) + 1), new Ma(this.target, e, o, t, i, r);
  }
  withTarget(e) {
    return new QN(this._ctx, this.editorPos, this.pos, e);
  }
}
const i2 = { isAfterLines: !0 };
function yD(n) {
  return {
    isAfterLines: !1,
    horizontalDistanceToText: n
  };
}
class ar {
  constructor(e, t) {
    this._context = e, this._viewHelper = t;
  }
  mouseTargetIsWidget(e) {
    const t = e.target, i = jl.collect(t, this._viewHelper.viewDomNode);
    return !!(Ys.isChildOfContentWidgets(i) || Ys.isChildOfOverflowingContentWidgets(i) || Ys.isChildOfOverlayWidgets(i));
  }
  createMouseTarget(e, t, i, r) {
    const o = new $p(this._context, this._viewHelper, e), s = new QN(o, t, i, r);
    try {
      return ar._createMouseTarget(o, s, !1);
    } catch {
      return s.fulfill(
        0
        /* UNKNOWN */
      );
    }
  }
  static _createMouseTarget(e, t, i) {
    if (t.target === null) {
      if (i)
        return t.fulfill(
          0
          /* UNKNOWN */
        );
      const s = ar._doHitTest(e, t);
      return s.type === 1 ? ar.createMouseTargetFromHitTestPosition(e, t, s.spanNode, s.position) : this._createMouseTarget(e, t.withTarget(s.hitTarget), !0);
    }
    const r = t;
    let o = null;
    return o = o || ar._hitTestContentWidget(e, r), o = o || ar._hitTestOverlayWidget(e, r), o = o || ar._hitTestMinimap(e, r), o = o || ar._hitTestScrollbarSlider(e, r), o = o || ar._hitTestViewZone(e, r), o = o || ar._hitTestMargin(e, r), o = o || ar._hitTestViewCursor(e, r), o = o || ar._hitTestTextArea(e, r), o = o || ar._hitTestViewLines(e, r, i), o = o || ar._hitTestScrollbar(e, r), o || t.fulfill(
      0
      /* UNKNOWN */
    );
  }
  static _hitTestContentWidget(e, t) {
    if (Ys.isChildOfContentWidgets(t.targetPath) || Ys.isChildOfOverflowingContentWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfill(9, null, null, i) : t.fulfill(
        0
        /* UNKNOWN */
      );
    }
    return null;
  }
  static _hitTestOverlayWidget(e, t) {
    if (Ys.isChildOfOverlayWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfill(12, null, null, i) : t.fulfill(
        0
        /* UNKNOWN */
      );
    }
    return null;
  }
  static _hitTestViewCursor(e, t) {
    if (t.target) {
      const i = e.lastRenderData.lastViewCursorsRenderData;
      for (const r of i)
        if (t.target === r.domNode)
          return t.fulfill(6, r.position, null, { mightBeForeignElement: !1 });
    }
    if (t.isInContentArea) {
      const i = e.lastRenderData.lastViewCursorsRenderData, r = t.mouseContentHorizontalOffset, o = t.mouseVerticalOffset;
      for (const s of i) {
        if (r < s.contentLeft || r > s.contentLeft + s.width)
          continue;
        const a = e.getVerticalOffsetForLineNumber(s.position.lineNumber);
        if (a <= o && o <= a + s.height)
          return t.fulfill(6, s.position, null, { mightBeForeignElement: !1 });
      }
    }
    return null;
  }
  static _hitTestViewZone(e, t) {
    const i = e.getZoneAtCoord(t.mouseVerticalOffset);
    if (i) {
      const r = t.isInContentArea ? 8 : 5;
      return t.fulfill(r, i.position, null, i);
    }
    return null;
  }
  static _hitTestTextArea(e, t) {
    return Ys.isTextArea(t.targetPath) ? e.lastRenderData.lastTextareaPosition ? t.fulfill(6, e.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: !1 }) : t.fulfill(1, e.lastRenderData.lastTextareaPosition) : null;
  }
  static _hitTestMargin(e, t) {
    if (t.isInMarginArea) {
      const i = e.getFullLineRangeAtCoord(t.mouseVerticalOffset), r = i.range.getStartPosition();
      let o = Math.abs(t.pos.x - t.editorPos.x);
      const s = {
        isAfterLines: i.isAfterLines,
        glyphMarginLeft: e.layoutInfo.glyphMarginLeft,
        glyphMarginWidth: e.layoutInfo.glyphMarginWidth,
        lineNumbersWidth: e.layoutInfo.lineNumbersWidth,
        offsetX: o
      };
      return o -= e.layoutInfo.glyphMarginLeft, o <= e.layoutInfo.glyphMarginWidth ? t.fulfill(2, r, i.range, s) : (o -= e.layoutInfo.glyphMarginWidth, o <= e.layoutInfo.lineNumbersWidth ? t.fulfill(3, r, i.range, s) : (o -= e.layoutInfo.lineNumbersWidth, t.fulfill(4, r, i.range, s)));
    }
    return null;
  }
  static _hitTestViewLines(e, t, i) {
    if (!Ys.isChildOfViewLines(t.targetPath))
      return null;
    if (e.isInTopPadding(t.mouseVerticalOffset))
      return t.fulfill(7, new J(1, 1), null, i2);
    if (e.isAfterLines(t.mouseVerticalOffset) || e.isInBottomPadding(t.mouseVerticalOffset)) {
      const o = e.model.getLineCount(), s = e.model.getLineMaxColumn(o);
      return t.fulfill(7, new J(o, s), null, i2);
    }
    if (i) {
      if (Ys.isStrictChildOfViewLines(t.targetPath)) {
        const o = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset);
        if (e.model.getLineLength(o) === 0) {
          const a = e.getLineWidth(o), l = yD(t.mouseContentHorizontalOffset - a);
          return t.fulfill(7, new J(o, 1), null, l);
        }
        const s = e.getLineWidth(o);
        if (t.mouseContentHorizontalOffset >= s) {
          const a = yD(t.mouseContentHorizontalOffset - s), l = new J(o, e.model.getLineMaxColumn(o));
          return t.fulfill(7, l, null, a);
        }
      }
      return t.fulfill(
        0
        /* UNKNOWN */
      );
    }
    const r = ar._doHitTest(e, t);
    return r.type === 1 ? ar.createMouseTargetFromHitTestPosition(e, t, r.spanNode, r.position) : this._createMouseTarget(e, t.withTarget(r.hitTarget), !0);
  }
  static _hitTestMinimap(e, t) {
    if (Ys.isChildOfMinimap(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), r = e.model.getLineMaxColumn(i);
      return t.fulfill(11, new J(i, r));
    }
    return null;
  }
  static _hitTestScrollbarSlider(e, t) {
    if (Ys.isChildOfScrollableElement(t.targetPath) && t.target && t.target.nodeType === 1) {
      const i = t.target.className;
      if (i && /\b(slider|scrollbar)\b/.test(i)) {
        const r = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), o = e.model.getLineMaxColumn(r);
        return t.fulfill(11, new J(r, o));
      }
    }
    return null;
  }
  static _hitTestScrollbar(e, t) {
    if (Ys.isChildOfScrollableElement(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), r = e.model.getLineMaxColumn(i);
      return t.fulfill(11, new J(i, r));
    }
    return null;
  }
  getMouseColumn(e, t) {
    const i = this._context.configuration.options, r = i.get(
      128
      /* layoutInfo */
    ), o = this._context.viewLayout.getCurrentScrollLeft() + t.x - e.x - r.contentLeft;
    return ar._getMouseColumn(o, i.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth);
  }
  static _getMouseColumn(e, t) {
    return e < 0 ? 1 : Math.round(e / t) + 1;
  }
  static createMouseTargetFromHitTestPosition(e, t, i, r) {
    const o = r.lineNumber, s = r.column, a = e.getLineWidth(o);
    if (t.mouseContentHorizontalOffset > a) {
      const g = yD(t.mouseContentHorizontalOffset - a);
      return t.fulfill(7, r, null, g);
    }
    const l = e.visibleRangeForPosition(o, s);
    if (!l)
      return t.fulfill(0, r);
    const u = l.left;
    if (t.mouseContentHorizontalOffset === u)
      return t.fulfill(6, r, null, { mightBeForeignElement: !1 });
    const c = [];
    if (c.push({ offset: l.left, column: s }), s > 1) {
      const g = e.visibleRangeForPosition(o, s - 1);
      g && c.push({ offset: g.left, column: s - 1 });
    }
    const h = e.model.getLineMaxColumn(o);
    if (s < h) {
      const g = e.visibleRangeForPosition(o, s + 1);
      g && c.push({ offset: g.left, column: s + 1 });
    }
    c.sort((g, _) => g.offset - _.offset);
    const d = t.pos.toClientCoordinates(), f = i.getBoundingClientRect(), p = f.left <= d.clientX && d.clientX <= f.right;
    for (let g = 1; g < c.length; g++) {
      const _ = c[g - 1], m = c[g];
      if (_.offset <= t.mouseContentHorizontalOffset && t.mouseContentHorizontalOffset <= m.offset) {
        const v = new V(o, _.column, o, m.column);
        return t.fulfill(6, r, v, { mightBeForeignElement: !p });
      }
    }
    return t.fulfill(6, r, null, { mightBeForeignElement: !p });
  }
  /**
   * Most probably WebKit browsers and Edge
   */
  static _doHitTestWithCaretRangeFromPoint(e, t) {
    const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), o = e.getVerticalOffsetForLineNumber(i) + Math.floor(e.lineHeight / 2);
    let s = t.pos.y + (o - t.mouseVerticalOffset);
    s <= t.editorPos.y && (s = t.editorPos.y + 1), s >= t.editorPos.y + e.layoutInfo.height && (s = t.editorPos.y + e.layoutInfo.height - 1);
    const a = new jN(t.pos.x, s), l = this._actualDoHitTestWithCaretRangeFromPoint(e, a.toClientCoordinates());
    return l.type === 1 ? l : this._actualDoHitTestWithCaretRangeFromPoint(e, t.pos.toClientCoordinates());
  }
  static _actualDoHitTestWithCaretRangeFromPoint(e, t) {
    const i = k_(e.viewDomNode);
    let r;
    if (i ? typeof i.caretRangeFromPoint > "u" ? r = oue(i, t.clientX, t.clientY) : r = i.caretRangeFromPoint(t.clientX, t.clientY) : r = document.caretRangeFromPoint(t.clientX, t.clientY), !r || !r.startContainer)
      return new Oc();
    const o = r.startContainer;
    if (o.nodeType === o.TEXT_NODE) {
      const s = o.parentNode, a = s ? s.parentNode : null, l = a ? a.parentNode : null;
      return (l && l.nodeType === l.ELEMENT_NODE ? l.className : null) === Il.CLASS_NAME ? Kh.createFromDOMInfo(e, s, r.startOffset) : new Oc(o.parentNode);
    } else if (o.nodeType === o.ELEMENT_NODE) {
      const s = o.parentNode, a = s ? s.parentNode : null;
      return (a && a.nodeType === a.ELEMENT_NODE ? a.className : null) === Il.CLASS_NAME ? Kh.createFromDOMInfo(e, o, o.textContent.length) : new Oc(o);
    }
    return new Oc();
  }
  /**
   * Most probably Gecko
   */
  static _doHitTestWithCaretPositionFromPoint(e, t) {
    const i = document.caretPositionFromPoint(t.clientX, t.clientY);
    if (i.offsetNode.nodeType === i.offsetNode.TEXT_NODE) {
      const r = i.offsetNode.parentNode, o = r ? r.parentNode : null, s = o ? o.parentNode : null;
      return (s && s.nodeType === s.ELEMENT_NODE ? s.className : null) === Il.CLASS_NAME ? Kh.createFromDOMInfo(e, i.offsetNode.parentNode, i.offset) : new Oc(i.offsetNode.parentNode);
    }
    if (i.offsetNode.nodeType === i.offsetNode.ELEMENT_NODE) {
      const r = i.offsetNode.parentNode, o = r && r.nodeType === r.ELEMENT_NODE ? r.className : null, s = r ? r.parentNode : null, a = s && s.nodeType === s.ELEMENT_NODE ? s.className : null;
      if (o === Il.CLASS_NAME) {
        const l = i.offsetNode.childNodes[Math.min(i.offset, i.offsetNode.childNodes.length - 1)];
        if (l)
          return Kh.createFromDOMInfo(e, l, 0);
      } else if (a === Il.CLASS_NAME)
        return Kh.createFromDOMInfo(e, i.offsetNode, 0);
    }
    return new Oc(i.offsetNode);
  }
  static _snapToSoftTabBoundary(e, t) {
    const i = t.getLineContent(e.lineNumber), { tabSize: r } = t.getTextModelOptions(), o = Qv.atomicPosition(
      i,
      e.column - 1,
      r,
      2
      /* Nearest */
    );
    return o !== -1 ? new J(e.lineNumber, o + 1) : e;
  }
  static _doHitTest(e, t) {
    let i = new Oc();
    return typeof document.caretRangeFromPoint == "function" ? i = this._doHitTestWithCaretRangeFromPoint(e, t) : document.caretPositionFromPoint && (i = this._doHitTestWithCaretPositionFromPoint(e, t.pos.toClientCoordinates())), i.type === 1 && e.stickyTabStops && (i = new o3(this._snapToSoftTabBoundary(i.position, e.model), i.spanNode)), i;
  }
}
function oue(n, e, t) {
  const i = document.createRange();
  let r = n.elementFromPoint(e, t);
  if (r !== null) {
    for (; r && r.firstChild && r.firstChild.nodeType !== r.firstChild.TEXT_NODE && r.lastChild && r.lastChild.firstChild; )
      r = r.lastChild;
    const o = r.getBoundingClientRect(), s = window.getComputedStyle(r, null).getPropertyValue("font"), a = r.innerText;
    let l = o.left, u = 0, c;
    if (e > o.left + o.width)
      u = a.length;
    else {
      const h = td.getInstance();
      for (let d = 0; d < a.length + 1; d++) {
        if (c = h.getCharWidth(a.charAt(d), s) / 2, l += c, e < l) {
          u = d;
          break;
        }
        l += c;
      }
    }
    i.setStart(r.firstChild, u), i.setEnd(r.firstChild, u);
  }
  return i;
}
class td {
  constructor() {
    this._cache = {}, this._canvas = document.createElement("canvas");
  }
  static getInstance() {
    return td._INSTANCE || (td._INSTANCE = new td()), td._INSTANCE;
  }
  getCharWidth(e, t) {
    const i = e + t;
    if (this._cache[i])
      return this._cache[i];
    const r = this._canvas.getContext("2d");
    r.font = t;
    const s = r.measureText(e).width;
    return this._cache[i] = s, s;
  }
}
td._INSTANCE = null;
function Pb(n) {
  return function(e, t) {
    let i = !1;
    return n && (i = n.mouseTargetIsWidget(t)), i || t.preventDefault(), t;
  };
}
class Md extends z_ {
  constructor(e, t, i) {
    super(), this._context = e, this.viewController = t, this.viewHelper = i, this.mouseTargetFactory = new ar(this._context, i), this._mouseDownOperation = this._register(new sue(this._context, this.viewController, this.viewHelper, (s, a) => this._createMouseTarget(s, a), (s) => this._getMouseColumn(s))), this.lastMouseLeaveTime = -1, this._height = this._context.configuration.options.get(
      128
      /* layoutInfo */
    ).height;
    const r = new jae(this.viewHelper.viewDomNode);
    this._register(r.onContextMenu(this.viewHelper.viewDomNode, (s) => this._onContextMenu(s, !0))), this._register(r.onMouseMoveThrottled(this.viewHelper.viewDomNode, (s) => this._onMouseMove(s), Pb(this.mouseTargetFactory), Md.MOUSE_MOVE_MINIMUM_TIME)), this._register(r.onMouseUp(this.viewHelper.viewDomNode, (s) => this._onMouseUp(s))), this._register(r.onMouseLeave(this.viewHelper.viewDomNode, (s) => this._onMouseLeave(s))), this._register(r.onMouseDown(this.viewHelper.viewDomNode, (s) => this._onMouseDown(s)));
    const o = (s) => {
      if (this.viewController.emitMouseWheel(s), !this._context.configuration.options.get(
        65
        /* mouseWheelZoom */
      ))
        return;
      const a = new Vp(s);
      if (Ft ? (s.metaKey || s.ctrlKey) && !s.shiftKey && !s.altKey : s.ctrlKey && !s.metaKey && !s.shiftKey && !s.altKey) {
        const u = ub.getZoomLevel(), c = a.deltaY > 0 ? 1 : -1;
        ub.setZoomLevel(u + c), a.preventDefault(), a.stopPropagation();
      }
    };
    this._register(ye(this.viewHelper.viewDomNode, Be.MOUSE_WHEEL, o, { capture: !0, passive: !1 })), this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      128
      /* layoutInfo */
    )) {
      const t = this._context.configuration.options.get(
        128
        /* layoutInfo */
      ).height;
      this._height !== t && (this._height = t, this._mouseDownOperation.onHeightChanged());
    }
    return !1;
  }
  onCursorStateChanged(e) {
    return this._mouseDownOperation.onCursorStateChanged(e), !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  onScrollChanged(e) {
    return this._mouseDownOperation.onScrollChanged(), !1;
  }
  // --- end event handlers
  getTargetAtClientPoint(e, t) {
    const r = new q5(e, t).toPageCoordinates(), o = Y5(this.viewHelper.viewDomNode);
    return r.y < o.y || r.y > o.y + o.height || r.x < o.x || r.x > o.x + o.width ? null : this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), o, r, null);
  }
  _createMouseTarget(e, t) {
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, t ? e.target : null);
  }
  _getMouseColumn(e) {
    return this.mouseTargetFactory.getMouseColumn(e.editorPos, e.pos);
  }
  _onContextMenu(e, t) {
    this.viewController.emitContextMenu({
      event: e,
      target: this._createMouseTarget(e, t)
    });
  }
  _onMouseMove(e) {
    this._mouseDownOperation.isActive() || e.timestamp < this.lastMouseLeaveTime || this.viewController.emitMouseMove({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseLeave(e) {
    this.lastMouseLeaveTime = (/* @__PURE__ */ new Date()).getTime(), this.viewController.emitMouseLeave({
      event: e,
      target: null
    });
  }
  _onMouseUp(e) {
    this.viewController.emitMouseUp({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseDown(e) {
    const t = this._createMouseTarget(e, !0), i = t.type === 6 || t.type === 7, r = t.type === 2 || t.type === 3 || t.type === 4, o = t.type === 3, s = this._context.configuration.options.get(
      96
      /* selectOnLineNumbers */
    ), a = t.type === 8 || t.type === 5, l = t.type === 9;
    let u = e.leftButton || e.middleButton;
    Ft && e.leftButton && e.ctrlKey && (u = !1);
    const c = () => {
      e.preventDefault(), this.viewHelper.focusTextArea();
    };
    if (u && (i || o && s))
      c(), this._mouseDownOperation.start(t.type, e);
    else if (r)
      e.preventDefault();
    else if (a) {
      const h = t.detail;
      this.viewHelper.shouldSuppressMouseDownOnViewZone(h.viewZoneId) && (c(), this._mouseDownOperation.start(t.type, e), e.preventDefault());
    } else
      l && this.viewHelper.shouldSuppressMouseDownOnWidget(t.detail) && (c(), e.preventDefault());
    this.viewController.emitMouseDown({
      event: e,
      target: t
    });
  }
}
Md.MOUSE_MOVE_MINIMUM_TIME = 100;
class sue extends ge {
  constructor(e, t, i, r, o) {
    super(), this._context = e, this._viewController = t, this._viewHelper = i, this._createMouseTarget = r, this._getMouseColumn = o, this._mouseMoveMonitor = this._register(new Kae(this._viewHelper.viewDomNode)), this._onScrollTimeout = this._register(new ec()), this._mouseState = new v0(), this._currentSelection = new Ut(1, 1, 1, 1), this._isActive = !1, this._lastMouseEvent = null;
  }
  dispose() {
    super.dispose();
  }
  isActive() {
    return this._isActive;
  }
  _onMouseDownThenMove(e) {
    this._lastMouseEvent = e, this._mouseState.setModifiers(e);
    const t = this._findMousePosition(e, !0);
    t && (this._mouseState.isDragAndDrop ? this._viewController.emitMouseDrag({
      event: e,
      target: t
    }) : this._dispatchMouse(t, !0));
  }
  start(e, t) {
    this._lastMouseEvent = t, this._mouseState.setStartedOnLineNumbers(
      e === 3
      /* GUTTER_LINE_NUMBERS */
    ), this._mouseState.setStartButtons(t), this._mouseState.setModifiers(t);
    const i = this._findMousePosition(t, !0);
    if (!i || !i.position)
      return;
    this._mouseState.trySetCount(t.detail, i.position), t.detail = this._mouseState.count;
    const r = this._context.configuration.options;
    if (!r.get(
      78
      /* readOnly */
    ) && r.get(
      29
      /* dragAndDrop */
    ) && !r.get(
      16
      /* columnSelection */
    ) && !this._mouseState.altKey && t.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && i.type === 6 && i.position && this._currentSelection.containsPosition(i.position)) {
      this._mouseState.isDragAndDrop = !0, this._isActive = !0, this._mouseMoveMonitor.startMonitoring(t.target, t.buttons, Pb(null), (o) => this._onMouseDownThenMove(o), (o) => {
        const s = this._findMousePosition(this._lastMouseEvent, !0);
        o && o instanceof KeyboardEvent ? this._viewController.emitMouseDropCanceled() : this._viewController.emitMouseDrop({
          event: this._lastMouseEvent,
          target: s ? this._createMouseTarget(this._lastMouseEvent, !0) : null
          // Ignoring because position is unknown, e.g., Content View Zone
        }), this._stop();
      });
      return;
    }
    this._mouseState.isDragAndDrop = !1, this._dispatchMouse(i, t.shiftKey), this._isActive || (this._isActive = !0, this._mouseMoveMonitor.startMonitoring(t.target, t.buttons, Pb(null), (o) => this._onMouseDownThenMove(o), () => this._stop()));
  }
  _stop() {
    this._isActive = !1, this._onScrollTimeout.cancel();
  }
  onHeightChanged() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onScrollChanged() {
    this._isActive && this._onScrollTimeout.setIfNotSet(() => {
      if (!this._lastMouseEvent)
        return;
      const e = this._findMousePosition(this._lastMouseEvent, !1);
      e && (this._mouseState.isDragAndDrop || this._dispatchMouse(e, !0));
    }, 10);
  }
  onCursorStateChanged(e) {
    this._currentSelection = e.selections[0];
  }
  _getPositionOutsideEditor(e) {
    const t = e.editorPos, i = this._context.model, r = this._context.viewLayout, o = this._getMouseColumn(e);
    if (e.posy < t.y) {
      const a = Math.max(r.getCurrentScrollTop() - (t.y - e.posy), 0), l = $p.getZoneAtCoord(this._context, a);
      if (l) {
        const c = this._helpPositionJumpOverViewZone(l);
        if (c)
          return new Ma(null, 13, o, c);
      }
      const u = r.getLineNumberAtVerticalOffset(a);
      return new Ma(null, 13, o, new J(u, 1));
    }
    if (e.posy > t.y + t.height) {
      const a = r.getCurrentScrollTop() + (e.posy - t.y), l = $p.getZoneAtCoord(this._context, a);
      if (l) {
        const c = this._helpPositionJumpOverViewZone(l);
        if (c)
          return new Ma(null, 13, o, c);
      }
      const u = r.getLineNumberAtVerticalOffset(a);
      return new Ma(null, 13, o, new J(u, i.getLineMaxColumn(u)));
    }
    const s = r.getLineNumberAtVerticalOffset(r.getCurrentScrollTop() + (e.posy - t.y));
    return e.posx < t.x ? new Ma(null, 13, o, new J(s, 1)) : e.posx > t.x + t.width ? new Ma(null, 13, o, new J(s, i.getLineMaxColumn(s))) : null;
  }
  _findMousePosition(e, t) {
    const i = this._getPositionOutsideEditor(e);
    if (i)
      return i;
    const r = this._createMouseTarget(e, t);
    if (!r.position)
      return null;
    if (r.type === 8 || r.type === 5) {
      const s = this._helpPositionJumpOverViewZone(r.detail);
      if (s)
        return new Ma(r.element, r.type, r.mouseColumn, s, null, r.detail);
    }
    return r;
  }
  _helpPositionJumpOverViewZone(e) {
    const t = new J(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn), i = e.positionBefore, r = e.positionAfter;
    return i && r ? i.isBefore(t) ? i : r : null;
  }
  _dispatchMouse(e, t) {
    e.position && this._viewController.dispatchMouse({
      position: e.position,
      mouseColumn: e.mouseColumn,
      startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
      inSelectionMode: t,
      mouseDownCount: this._mouseState.count,
      altKey: this._mouseState.altKey,
      ctrlKey: this._mouseState.ctrlKey,
      metaKey: this._mouseState.metaKey,
      shiftKey: this._mouseState.shiftKey,
      leftButton: this._mouseState.leftButton,
      middleButton: this._mouseState.middleButton
    });
  }
}
class v0 {
  constructor() {
    this._altKey = !1, this._ctrlKey = !1, this._metaKey = !1, this._shiftKey = !1, this._leftButton = !1, this._middleButton = !1, this._startedOnLineNumbers = !1, this._lastMouseDownPosition = null, this._lastMouseDownPositionEqualCount = 0, this._lastMouseDownCount = 0, this._lastSetMouseDownCountTime = 0, this.isDragAndDrop = !1;
  }
  get altKey() {
    return this._altKey;
  }
  get ctrlKey() {
    return this._ctrlKey;
  }
  get metaKey() {
    return this._metaKey;
  }
  get shiftKey() {
    return this._shiftKey;
  }
  get leftButton() {
    return this._leftButton;
  }
  get middleButton() {
    return this._middleButton;
  }
  get startedOnLineNumbers() {
    return this._startedOnLineNumbers;
  }
  get count() {
    return this._lastMouseDownCount;
  }
  setModifiers(e) {
    this._altKey = e.altKey, this._ctrlKey = e.ctrlKey, this._metaKey = e.metaKey, this._shiftKey = e.shiftKey;
  }
  setStartButtons(e) {
    this._leftButton = e.leftButton, this._middleButton = e.middleButton;
  }
  setStartedOnLineNumbers(e) {
    this._startedOnLineNumbers = e;
  }
  trySetCount(e, t) {
    const i = (/* @__PURE__ */ new Date()).getTime();
    i - this._lastSetMouseDownCountTime > v0.CLEAR_MOUSE_DOWN_COUNT_TIME && (e = 1), this._lastSetMouseDownCountTime = i, e > this._lastMouseDownCount + 1 && (e = this._lastMouseDownCount + 1), this._lastMouseDownPosition && this._lastMouseDownPosition.equals(t) ? this._lastMouseDownPositionEqualCount++ : this._lastMouseDownPositionEqualCount = 1, this._lastMouseDownPosition = t, this._lastMouseDownCount = Math.min(e, this._lastMouseDownPositionEqualCount);
  }
}
v0.CLEAR_MOUSE_DOWN_COUNT_TIME = 400;
class Rn {
  constructor(e, t, i, r, o) {
    this.value = e, this.selectionStart = t, this.selectionEnd = i, this.selectionStartPosition = r, this.selectionEndPosition = o;
  }
  toString() {
    return "[ <" + this.value + ">, selectionStart: " + this.selectionStart + ", selectionEnd: " + this.selectionEnd + "]";
  }
  static readFromTextArea(e) {
    return new Rn(e.getValue(), e.getSelectionStart(), e.getSelectionEnd(), null, null);
  }
  collapseSelection() {
    return new Rn(this.value, this.value.length, this.value.length, null, null);
  }
  writeToTextArea(e, t, i) {
    t.setValue(e, this.value), i && t.setSelectionRange(e, this.selectionStart, this.selectionEnd);
  }
  deduceEditorPosition(e) {
    if (e <= this.selectionStart) {
      const r = this.value.substring(e, this.selectionStart);
      return this._finishDeduceEditorPosition(this.selectionStartPosition, r, -1);
    }
    if (e >= this.selectionEnd) {
      const r = this.value.substring(this.selectionEnd, e);
      return this._finishDeduceEditorPosition(this.selectionEndPosition, r, 1);
    }
    const t = this.value.substring(this.selectionStart, e);
    if (t.indexOf(String.fromCharCode(8230)) === -1)
      return this._finishDeduceEditorPosition(this.selectionStartPosition, t, 1);
    const i = this.value.substring(e, this.selectionEnd);
    return this._finishDeduceEditorPosition(this.selectionEndPosition, i, -1);
  }
  _finishDeduceEditorPosition(e, t, i) {
    let r = 0, o = -1;
    for (; (o = t.indexOf(`
`, o + 1)) !== -1; )
      r++;
    return [e, i * t.length, r];
  }
  static selectedText(e) {
    return new Rn(e, 0, e.length, null, null);
  }
  static deduceInput(e, t, i) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    let r = e.value, o = e.selectionStart, s = e.selectionEnd, a = t.value, l = t.selectionStart, u = t.selectionEnd;
    const c = r.substring(s), h = a.substring(u), d = OF(c, h);
    a = a.substring(0, a.length - d), r = r.substring(0, r.length - d);
    const f = r.substring(0, o), p = a.substring(0, l), g = TF(f, p);
    if (a = a.substring(g), r = r.substring(g), l -= g, o -= g, u -= g, s -= g, i && l === u && r.length > 0) {
      let m = null;
      if (l === a.length ? a.startsWith(r) && (m = a.substring(r.length)) : a.endsWith(r) && (m = a.substring(0, a.length - r.length)), m !== null && m.length > 0 && (/\uFE0F/.test(m) || ore(m)))
        return {
          text: m,
          replacePrevCharCnt: 0,
          replaceNextCharCnt: 0,
          positionDelta: 0
        };
    }
    if (l === u) {
      if (r === a && o === 0 && s === r.length && l === a.length && a.indexOf(`
`) === -1 && are(a))
        return {
          text: "",
          replacePrevCharCnt: 0,
          replaceNextCharCnt: 0,
          positionDelta: 0
        };
      const m = f.length - g;
      return {
        text: a,
        replacePrevCharCnt: m,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    }
    const _ = s - o;
    return {
      text: a,
      replacePrevCharCnt: _,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
  }
  static deduceAndroidCompositionInput(e, t) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    if (e.value === t.value)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: t.selectionEnd - e.selectionEnd
      };
    const i = Math.min(TF(e.value, t.value), e.selectionEnd), r = Math.min(OF(e.value, t.value), e.value.length - e.selectionEnd), o = e.value.substring(i, e.value.length - r), s = t.value.substring(i, t.value.length - r);
    e.selectionStart - i;
    const a = e.selectionEnd - i;
    t.selectionStart - i;
    const l = t.selectionEnd - i;
    return {
      text: s,
      replacePrevCharCnt: a,
      replaceNextCharCnt: o.length - a,
      positionDelta: l - s.length
    };
  }
}
Rn.EMPTY = new Rn("", 0, 0, null, null);
class Xf {
  static _getPageOfLine(e, t) {
    return Math.floor((e - 1) / t);
  }
  static _getRangeForPage(e, t) {
    const i = e * t, r = i + 1, o = i + t;
    return new V(r, 1, o + 1, 1);
  }
  static fromEditorSelection(e, t, i, r, o) {
    const s = Xf._getPageOfLine(i.startLineNumber, r), a = Xf._getRangeForPage(s, r), l = Xf._getPageOfLine(i.endLineNumber, r), u = Xf._getRangeForPage(l, r), c = a.intersectRanges(new V(1, 1, i.startLineNumber, i.startColumn));
    let h = t.getValueInRange(
      c,
      1
      /* LF */
    );
    const d = t.getLineCount(), f = t.getLineMaxColumn(d), p = u.intersectRanges(new V(i.endLineNumber, i.endColumn, d, f));
    let g = t.getValueInRange(
      p,
      1
      /* LF */
    ), _;
    if (s === l || s + 1 === l)
      _ = t.getValueInRange(
        i,
        1
        /* LF */
      );
    else {
      const m = a.intersectRanges(i), v = u.intersectRanges(i);
      _ = t.getValueInRange(
        m,
        1
        /* LF */
      ) + String.fromCharCode(8230) + t.getValueInRange(
        v,
        1
        /* LF */
      );
    }
    return o && (h.length > 500 && (h = h.substring(h.length - 500, h.length)), g.length > 500 && (g = g.substring(0, 500)), _.length > 2 * 500 && (_ = _.substring(0, 500) + String.fromCharCode(8230) + _.substring(_.length - 500, _.length))), new Rn(h + _ + g, h.length, h.length + _.length, new J(i.startLineNumber, i.startColumn), new J(i.endLineNumber, i.endColumn));
  }
}
var Ab;
(function(n) {
  n.Tap = "-monaco-textarea-synthetic-tap";
})(Ab || (Ab = {}));
const aue = {
  forceCopyWithSyntaxHighlighting: !1
};
class Mb {
  constructor() {
    this._lastState = null;
  }
  set(e, t) {
    this._lastState = { lastCopiedValue: e, data: t };
  }
  get(e) {
    return this._lastState && this._lastState.lastCopiedValue === e ? this._lastState.data : (this._lastState = null, null);
  }
}
Mb.INSTANCE = new Mb();
class lue extends ge {
  constructor(e, t) {
    super(), this.textArea = t, this._onFocus = this._register(new j()), this.onFocus = this._onFocus.event, this._onBlur = this._register(new j()), this.onBlur = this._onBlur.event, this._onKeyDown = this._register(new j()), this.onKeyDown = this._onKeyDown.event, this._onKeyUp = this._register(new j()), this.onKeyUp = this._onKeyUp.event, this._onCut = this._register(new j()), this.onCut = this._onCut.event, this._onPaste = this._register(new j()), this.onPaste = this._onPaste.event, this._onType = this._register(new j()), this.onType = this._onType.event, this._onCompositionStart = this._register(new j()), this.onCompositionStart = this._onCompositionStart.event, this._onCompositionUpdate = this._register(new j()), this.onCompositionUpdate = this._onCompositionUpdate.event, this._onCompositionEnd = this._register(new j()), this.onCompositionEnd = this._onCompositionEnd.event, this._onSelectionChangeRequest = this._register(new j()), this.onSelectionChangeRequest = this._onSelectionChangeRequest.event, this._host = e, this._textArea = this._register(new uue(t)), this._asyncTriggerCut = this._register(new to(() => this._onCut.fire(), 0)), this._asyncFocusGainWriteScreenReaderContent = this._register(new to(() => this.writeScreenReaderContent("asyncFocusGain"), 0)), this._textAreaState = Rn.EMPTY, this._selectionChangeListener = null, this.writeScreenReaderContent("ctor"), this._hasFocus = !1, this._isDoingComposition = !1, this._nextCommand = 0;
    let i = null;
    this._register(Jr(t.domNode, "keydown", (a) => {
      (a.keyCode === 109 || this._isDoingComposition && a.keyCode === 1) && a.stopPropagation(), a.equals(
        9
        /* Escape */
      ) && a.preventDefault(), i = a, this._onKeyDown.fire(a);
    })), this._register(Jr(t.domNode, "keyup", (a) => {
      this._onKeyUp.fire(a);
    })), this._register(ye(t.domNode, "compositionstart", (a) => {
      if (!this._isDoingComposition) {
        if (this._isDoingComposition = !0, Ft && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === a.data && (i && i.equals(
          109
          /* KEY_IN_COMPOSITION */
        ) && (i.code === "ArrowRight" || i.code === "ArrowLeft") || Qr)) {
          this._textAreaState = new Rn(this._textAreaState.value, this._textAreaState.selectionStart - 1, this._textAreaState.selectionEnd, this._textAreaState.selectionStartPosition ? new J(this._textAreaState.selectionStartPosition.lineNumber, this._textAreaState.selectionStartPosition.column - 1) : null, this._textAreaState.selectionEndPosition), this._onCompositionStart.fire({ revealDeltaColumns: -1 });
          return;
        }
        if (Bm) {
          this._onCompositionStart.fire({ revealDeltaColumns: -this._textAreaState.selectionStart });
          return;
        }
        this._setAndWriteTextAreaState("compositionstart", Rn.EMPTY), this._onCompositionStart.fire({ revealDeltaColumns: 0 });
      }
    }));
    const r = (a) => {
      const l = this._textAreaState, u = Rn.readFromTextArea(this._textArea);
      return [u, Rn.deduceInput(l, u, a)];
    }, o = () => {
      const a = this._textAreaState, l = Rn.readFromTextArea(this._textArea);
      return [l, Rn.deduceAndroidCompositionInput(a, l)];
    }, s = (a) => {
      const l = this._textAreaState, u = Rn.selectedText(a), c = {
        text: u.value,
        replacePrevCharCnt: l.selectionEnd - l.selectionStart,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
      return [u, c];
    };
    this._register(ye(t.domNode, "compositionupdate", (a) => {
      if (Bm) {
        const [c, h] = o();
        this._textAreaState = c, this._onType.fire(h), this._onCompositionUpdate.fire(a);
        return;
      }
      const [l, u] = s(a.data || "");
      this._textAreaState = l, this._onType.fire(u), this._onCompositionUpdate.fire(a);
    })), this._register(ye(t.domNode, "compositionend", (a) => {
      if (!this._isDoingComposition)
        return;
      if (this._isDoingComposition = !1, Bm) {
        const [c, h] = o();
        this._textAreaState = c, this._onType.fire(h), this._onCompositionEnd.fire();
        return;
      }
      const [l, u] = s(a.data || "");
      this._textAreaState = l, this._onType.fire(u), (rb || Qr) && (this._textAreaState = Rn.readFromTextArea(this._textArea)), this._onCompositionEnd.fire();
    })), this._register(ye(t.domNode, "input", () => {
      if (this._textArea.setIgnoreSelectionChangeTime("received input event"), this._isDoingComposition)
        return;
      const [a, l] = r(
        /*couldBeEmojiInput*/
        Ft
      );
      l.replacePrevCharCnt === 0 && l.text.length === 1 && jn(l.text.charCodeAt(0)) || (this._textAreaState = a, this._nextCommand === 0 ? (l.text !== "" || l.replacePrevCharCnt !== 0) && this._onType.fire(l) : ((l.text !== "" || l.replacePrevCharCnt !== 0) && this._firePaste(l.text, null), this._nextCommand = 0));
    })), this._register(ye(t.domNode, "cut", (a) => {
      this._textArea.setIgnoreSelectionChangeTime("received cut event"), this._ensureClipboardGetsEditorSelection(a), this._asyncTriggerCut.schedule();
    })), this._register(ye(t.domNode, "copy", (a) => {
      this._ensureClipboardGetsEditorSelection(a);
    })), this._register(ye(t.domNode, "paste", (a) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received paste event"), Om.canUseTextData(a)) {
        const [l, u] = Om.getTextData(a);
        l !== "" && this._firePaste(l, u);
      } else
        this._textArea.getSelectionStart() !== this._textArea.getSelectionEnd() && this._setAndWriteTextAreaState("paste", Rn.EMPTY), this._nextCommand = 1;
    })), this._register(ye(t.domNode, "focus", () => {
      const a = this._hasFocus;
      this._setHasFocus(!0), Td && !a && this._hasFocus && this._asyncFocusGainWriteScreenReaderContent.schedule();
    })), this._register(ye(t.domNode, "blur", () => {
      this._isDoingComposition && (this._isDoingComposition = !1, this.writeScreenReaderContent("blurWithoutCompositionEnd"), this._onCompositionEnd.fire()), this._setHasFocus(!1);
    })), this._register(ye(t.domNode, Ab.Tap, () => {
      Bm && this._isDoingComposition && (this._isDoingComposition = !1, this.writeScreenReaderContent("tapWithoutCompositionEnd"), this._onCompositionEnd.fire());
    }));
  }
  _installSelectionChangeListener() {
    let e = 0;
    return ye(document, "selectionchange", (t) => {
      if (!this._hasFocus || this._isDoingComposition || !rb)
        return;
      const i = Date.now(), r = i - e;
      if (e = i, r < 5)
        return;
      const o = i - this._textArea.getIgnoreSelectionChangeTime();
      if (this._textArea.resetSelectionChangeTime(), o < 100 || !this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition)
        return;
      const s = this._textArea.getValue();
      if (this._textAreaState.value !== s)
        return;
      const a = this._textArea.getSelectionStart(), l = this._textArea.getSelectionEnd();
      if (this._textAreaState.selectionStart === a && this._textAreaState.selectionEnd === l)
        return;
      const u = this._textAreaState.deduceEditorPosition(a), c = this._host.deduceModelPosition(u[0], u[1], u[2]), h = this._textAreaState.deduceEditorPosition(l), d = this._host.deduceModelPosition(h[0], h[1], h[2]), f = new Ut(c.lineNumber, c.column, d.lineNumber, d.column);
      this._onSelectionChangeRequest.fire(f);
    });
  }
  dispose() {
    super.dispose(), this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null);
  }
  focusTextArea() {
    this._setHasFocus(!0), this.refreshFocusState();
  }
  isFocused() {
    return this._hasFocus;
  }
  refreshFocusState() {
    const e = k_(this.textArea.domNode);
    e ? this._setHasFocus(e.activeElement === this.textArea.domNode) : CG(this.textArea.domNode) ? this._setHasFocus(document.activeElement === this.textArea.domNode) : this._setHasFocus(!1);
  }
  _setHasFocus(e) {
    this._hasFocus !== e && (this._hasFocus = e, this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null), this._hasFocus && (this._selectionChangeListener = this._installSelectionChangeListener()), this._hasFocus && this.writeScreenReaderContent("focusgain"), this._hasFocus ? this._onFocus.fire() : this._onBlur.fire());
  }
  _setAndWriteTextAreaState(e, t) {
    this._hasFocus || (t = t.collapseSelection()), t.writeToTextArea(e, this._textArea, this._hasFocus), this._textAreaState = t;
  }
  writeScreenReaderContent(e) {
    this._isDoingComposition || this._setAndWriteTextAreaState(e, this._host.getScreenReaderContent(this._textAreaState));
  }
  _ensureClipboardGetsEditorSelection(e) {
    const t = this._host.getDataToCopy(Om.canUseTextData(e)), i = {
      version: 1,
      isFromEmptySelection: t.isFromEmptySelection,
      multicursorText: t.multicursorText,
      mode: t.mode
    };
    if (Mb.INSTANCE.set(
      // When writing "LINE\r\n" to the clipboard and then pasting,
      // Firefox pastes "LINE\n", so let's work around this quirk
      Qr ? t.text.replace(/\r\n/g, `
`) : t.text,
      i
    ), !Om.canUseTextData(e)) {
      this._setAndWriteTextAreaState("copy or cut", Rn.selectedText(t.text));
      return;
    }
    Om.setTextData(e, t.text, t.html, i);
  }
  _firePaste(e, t) {
    t || (t = Mb.INSTANCE.get(e)), this._onPaste.fire({
      text: e,
      metadata: t
    });
  }
}
class Om {
  static canUseTextData(e) {
    return !!(e.clipboardData || window.clipboardData);
  }
  static getTextData(e) {
    if (e.clipboardData) {
      e.preventDefault();
      const t = e.clipboardData.getData("text/plain");
      let i = null;
      const r = e.clipboardData.getData("vscode-editor-data");
      if (typeof r == "string")
        try {
          i = JSON.parse(r), i.version !== 1 && (i = null);
        } catch {
        }
      return [t, i];
    }
    if (window.clipboardData)
      return e.preventDefault(), [window.clipboardData.getData("Text"), null];
    throw new Error("ClipboardEventUtils.getTextData: Cannot use text data!");
  }
  static setTextData(e, t, i, r) {
    if (e.clipboardData) {
      e.clipboardData.setData("text/plain", t), typeof i == "string" && e.clipboardData.setData("text/html", i), e.clipboardData.setData("vscode-editor-data", JSON.stringify(r)), e.preventDefault();
      return;
    }
    if (window.clipboardData) {
      window.clipboardData.setData("Text", t), e.preventDefault();
      return;
    }
    throw new Error("ClipboardEventUtils.setTextData: Cannot use text data!");
  }
}
class uue extends ge {
  constructor(e) {
    super(), this._actual = e, this._ignoreSelectionChangeTime = 0;
  }
  setIgnoreSelectionChangeTime(e) {
    this._ignoreSelectionChangeTime = Date.now();
  }
  getIgnoreSelectionChangeTime() {
    return this._ignoreSelectionChangeTime;
  }
  resetSelectionChangeTime() {
    this._ignoreSelectionChangeTime = 0;
  }
  getValue() {
    return this._actual.domNode.value;
  }
  setValue(e, t) {
    const i = this._actual.domNode;
    i.value !== t && (this.setIgnoreSelectionChangeTime("setValue"), i.value = t);
  }
  getSelectionStart() {
    return this._actual.domNode.selectionDirection === "backward" ? this._actual.domNode.selectionEnd : this._actual.domNode.selectionStart;
  }
  getSelectionEnd() {
    return this._actual.domNode.selectionDirection === "backward" ? this._actual.domNode.selectionStart : this._actual.domNode.selectionEnd;
  }
  setSelectionRange(e, t, i) {
    const r = this._actual.domNode;
    let o = null;
    const s = k_(r);
    s ? o = s.activeElement : o = document.activeElement;
    const a = o === r, l = r.selectionStart, u = r.selectionEnd;
    if (a && l === t && u === i) {
      Qr && window.parent !== window && r.focus();
      return;
    }
    if (a) {
      this.setIgnoreSelectionChangeTime("setSelectionRange"), r.setSelectionRange(t, i), Qr && window.parent !== window && r.focus();
      return;
    }
    try {
      const c = jne(r);
      this.setIgnoreSelectionChangeTime("setSelectionRange"), r.focus(), r.setSelectionRange(t, i), $ne(r, c);
    } catch {
    }
  }
}
class cue extends Md {
  constructor(e, t, i) {
    super(e, t, i), this._register(ri.addTarget(this.viewHelper.linesContentDomNode)), this._register(ye(this.viewHelper.linesContentDomNode, Li.Tap, (o) => this.onTap(o))), this._register(ye(this.viewHelper.linesContentDomNode, Li.Change, (o) => this.onChange(o))), this._register(ye(this.viewHelper.linesContentDomNode, Li.Contextmenu, (o) => this._onContextMenu(new Ad(o, this.viewHelper.viewDomNode), !1))), this._lastPointerType = "mouse", this._register(ye(this.viewHelper.linesContentDomNode, "pointerdown", (o) => {
      const s = o.pointerType;
      if (s === "mouse") {
        this._lastPointerType = "mouse";
        return;
      } else
        s === "touch" ? this._lastPointerType = "touch" : this._lastPointerType = "pen";
    }));
    const r = new $ae(this.viewHelper.viewDomNode);
    this._register(r.onPointerMoveThrottled(this.viewHelper.viewDomNode, (o) => this._onMouseMove(o), Pb(this.mouseTargetFactory), Md.MOUSE_MOVE_MINIMUM_TIME)), this._register(r.onPointerUp(this.viewHelper.viewDomNode, (o) => this._onMouseUp(o))), this._register(r.onPointerLeave(this.viewHelper.viewDomNode, (o) => this._onMouseLeave(o))), this._register(r.onPointerDown(this.viewHelper.viewDomNode, (o) => this._onMouseDown(o)));
  }
  onTap(e) {
    if (!e.initialTarget || !this.viewHelper.linesContentDomNode.contains(e.initialTarget))
      return;
    e.preventDefault(), this.viewHelper.focusTextArea();
    const t = this._createMouseTarget(new Ad(e, this.viewHelper.viewDomNode), !1);
    t.position && this.viewController.dispatchMouse({
      position: t.position,
      mouseColumn: t.position.column,
      startedOnLineNumbers: !1,
      mouseDownCount: e.tapCount,
      inSelectionMode: !1,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      shiftKey: !1,
      leftButton: !1,
      middleButton: !1
    });
  }
  onChange(e) {
    this._lastPointerType === "touch" && this._context.model.deltaScrollNow(-e.translationX, -e.translationY);
  }
  _onMouseDown(e) {
    e.browserEvent.pointerType !== "touch" && super._onMouseDown(e);
  }
}
class hue extends Md {
  constructor(e, t, i) {
    super(e, t, i), this._register(ri.addTarget(this.viewHelper.linesContentDomNode)), this._register(ye(this.viewHelper.linesContentDomNode, Li.Tap, (r) => this.onTap(r))), this._register(ye(this.viewHelper.linesContentDomNode, Li.Change, (r) => this.onChange(r))), this._register(ye(this.viewHelper.linesContentDomNode, Li.Contextmenu, (r) => this._onContextMenu(new Ad(r, this.viewHelper.viewDomNode), !1)));
  }
  onTap(e) {
    e.preventDefault(), this.viewHelper.focusTextArea();
    const t = this._createMouseTarget(new Ad(e, this.viewHelper.viewDomNode), !1);
    if (t.position) {
      const i = document.createEvent("CustomEvent");
      i.initEvent(Ab.Tap, !1, !0), this.viewHelper.dispatchTextAreaEvent(i), this.viewController.moveTo(t.position);
    }
  }
  onChange(e) {
    this._context.model.deltaScrollNow(-e.translationX, -e.translationY);
  }
}
class due extends ge {
  constructor(e, t, i) {
    super(), _g && jS.pointerEvents ? this.handler = this._register(new cue(e, t, i)) : window.TouchEvent ? this.handler = this._register(new hue(e, t, i)) : this.handler = this._register(new Md(e, t, i));
  }
  getTargetAtClientPoint(e, t) {
    return this.handler.getTargetAtClientPoint(e, t);
  }
}
class Dg extends z_ {
}
const s3 = {
  ColorContribution: "base.contributions.colors"
};
class fue {
  constructor() {
    this._onDidChangeSchema = new j(), this.onDidChangeSchema = this._onDidChangeSchema.event, this.colorSchema = { type: "object", properties: {} }, this.colorReferenceSchema = { type: "string", enum: [], enumDescriptions: [] }, this.colorsById = {};
  }
  registerColor(e, t, i, r = !1, o) {
    let s = { id: e, description: i, defaults: t, needsTransparency: r, deprecationMessage: o };
    this.colorsById[e] = s;
    let a = { type: "string", description: i, format: "color-hex", defaultSnippets: [{ body: "${1:#ff0000}" }] };
    return o && (a.deprecationMessage = o), this.colorSchema.properties[e] = a, this.colorReferenceSchema.enum.push(e), this.colorReferenceSchema.enumDescriptions.push(i), this._onDidChangeSchema.fire(), e;
  }
  resolveDefaultColor(e, t) {
    const i = this.colorsById[e];
    if (i && i.defaults) {
      const r = i.defaults[t.type];
      return Ic(r, t);
    }
  }
  getColorSchema() {
    return this.colorSchema;
  }
  toString() {
    let e = (t, i) => {
      let r = t.indexOf(".") === -1 ? 0 : 1, o = i.indexOf(".") === -1 ? 0 : 1;
      return r !== o ? r - o : t.localeCompare(i);
    };
    return Object.keys(this.colorsById).sort(e).map((t) => `- \`${t}\`: ${this.colorsById[t].description}`).join(`
`);
  }
}
const _0 = new fue();
Zn.add(s3.ColorContribution, _0);
function Q(n, e, t, i, r) {
  return _0.registerColor(n, e, t, i, r);
}
const fd = Q("foreground", { dark: "#CCCCCC", light: "#616161", hc: "#FFFFFF" }, w("foreground", "Overall foreground color. This color is only used if not overridden by a component.")), jCe = Q("errorForeground", { dark: "#F48771", light: "#A1260D", hc: "#F48771" }, w("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component.")), $Ce = Q("icon.foreground", { dark: "#C5C5C5", light: "#424242", hc: "#FFFFFF" }, w("iconForeground", "The default color for icons in the workbench.")), Kp = Q("focusBorder", { dark: "#007FD4", light: "#0090F1", hc: "#F38518" }, w("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component.")), dr = Q("contrastBorder", { light: null, dark: null, hc: "#6FC3DF" }, w("contrastBorder", "An extra border around elements to separate them from others for greater contrast.")), xs = Q("contrastActiveBorder", { light: null, dark: null, hc: Kp }, w("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast.")), KCe = Q("textLink.foreground", { light: "#006AB1", dark: "#3794FF", hc: "#3794FF" }, w("textLinkForeground", "Foreground color for links in text.")), qCe = Q("textCodeBlock.background", { light: "#dcdcdc66", dark: "#0a0a0a66", hc: ee.black }, w("textCodeBlockBackground", "Background color for code blocks in text.")), Fb = Q("widget.shadow", { dark: fr(ee.black, 0.36), light: fr(ee.black, 0.16), hc: null }, w("widgetShadow", "Shadow color of widgets such as find/replace inside the editor.")), pue = Q("input.background", { dark: "#3C3C3C", light: ee.white, hc: ee.black }, w("inputBoxBackground", "Input box background.")), gue = Q("input.foreground", { dark: fd, light: fd, hc: fd }, w("inputBoxForeground", "Input box foreground.")), mue = Q("input.border", { dark: null, light: null, hc: dr }, w("inputBoxBorder", "Input box border.")), YCe = Q("inputOption.activeBorder", { dark: "#007ACC00", light: "#007ACC00", hc: dr }, w("inputBoxActiveOptionBorder", "Border color of activated options in input fields.")), XCe = Q("inputOption.activeBackground", { dark: fr(Kp, 0.4), light: fr(Kp, 0.2), hc: ee.transparent }, w("inputOption.activeBackground", "Background color of activated options in input fields.")), ZCe = Q("inputOption.activeForeground", { dark: ee.white, light: ee.black, hc: null }, w("inputOption.activeForeground", "Foreground color of activated options in input fields.")), vue = Q("inputValidation.infoBackground", { dark: "#063B49", light: "#D6ECF2", hc: ee.black }, w("inputValidationInfoBackground", "Input validation background color for information severity.")), _ue = Q("inputValidation.infoForeground", { dark: null, light: null, hc: null }, w("inputValidationInfoForeground", "Input validation foreground color for information severity.")), Cue = Q("inputValidation.infoBorder", { dark: "#007acc", light: "#007acc", hc: dr }, w("inputValidationInfoBorder", "Input validation border color for information severity.")), yue = Q("inputValidation.warningBackground", { dark: "#352A05", light: "#F6F5D2", hc: ee.black }, w("inputValidationWarningBackground", "Input validation background color for warning severity.")), wue = Q("inputValidation.warningForeground", { dark: null, light: null, hc: null }, w("inputValidationWarningForeground", "Input validation foreground color for warning severity.")), bue = Q("inputValidation.warningBorder", { dark: "#B89500", light: "#B89500", hc: dr }, w("inputValidationWarningBorder", "Input validation border color for warning severity.")), Sue = Q("inputValidation.errorBackground", { dark: "#5A1D1D", light: "#F2DEDE", hc: ee.black }, w("inputValidationErrorBackground", "Input validation background color for error severity.")), Eue = Q("inputValidation.errorForeground", { dark: null, light: null, hc: null }, w("inputValidationErrorForeground", "Input validation foreground color for error severity.")), Lue = Q("inputValidation.errorBorder", { dark: "#BE1100", light: "#BE1100", hc: dr }, w("inputValidationErrorBorder", "Input validation border color for error severity.")), wD = Q("dropdown.background", { dark: "#3C3C3C", light: ee.white, hc: ee.black }, w("dropdownBackground", "Dropdown background.")), n2 = Q("dropdown.foreground", { dark: "#F0F0F0", light: null, hc: ee.white }, w("dropdownForeground", "Dropdown foreground.")), Due = Q("button.foreground", { dark: ee.white, light: ee.white, hc: ee.white }, w("buttonForeground", "Button foreground color.")), AT = Q("button.background", { dark: "#0E639C", light: "#007ACC", hc: null }, w("buttonBackground", "Button background color.")), Rue = Q("button.hoverBackground", { dark: g3(AT, 0.2), light: p3(AT, 0.2), hc: null }, w("buttonHoverBackground", "Button background color when hovering.")), a3 = Q("badge.background", { dark: "#4D4D4D", light: "#C4C4C4", hc: ee.black }, w("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count.")), l3 = Q("badge.foreground", { dark: ee.white, light: "#333", hc: ee.white }, w("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count.")), C0 = Q("scrollbar.shadow", { dark: "#000000", light: "#DDDDDD", hc: null }, w("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled.")), sw = Q("scrollbarSlider.background", { dark: ee.fromHex("#797979").transparent(0.4), light: ee.fromHex("#646464").transparent(0.4), hc: fr(dr, 0.6) }, w("scrollbarSliderBackground", "Scrollbar slider background color.")), aw = Q("scrollbarSlider.hoverBackground", { dark: ee.fromHex("#646464").transparent(0.7), light: ee.fromHex("#646464").transparent(0.7), hc: fr(dr, 0.8) }, w("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering.")), lw = Q("scrollbarSlider.activeBackground", { dark: ee.fromHex("#BFBFBF").transparent(0.4), light: ee.fromHex("#000000").transparent(0.6), hc: dr }, w("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on.")), Tue = Q("progressBar.background", { dark: ee.fromHex("#0E70C0"), light: ee.fromHex("#0E70C0"), hc: dr }, w("progressBarBackground", "Background color of the progress bar that can show for long running operations.")), Oue = Q("editorError.background", { dark: null, light: null, hc: null }, w("editorError.background", "Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), uw = Q("editorError.foreground", { dark: "#F48771", light: "#E51400", hc: null }, w("editorError.foreground", "Foreground color of error squigglies in the editor.")), xue = Q("editorError.border", { dark: null, light: null, hc: ee.fromHex("#E47777").transparent(0.8) }, w("errorBorder", "Border color of error boxes in the editor.")), Nue = Q("editorWarning.background", { dark: null, light: null, hc: null }, w("editorWarning.background", "Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), Zc = Q("editorWarning.foreground", { dark: "#CCA700", light: "#BF8803", hc: null }, w("editorWarning.foreground", "Foreground color of warning squigglies in the editor.")), JN = Q("editorWarning.border", { dark: null, light: null, hc: ee.fromHex("#FFCC00").transparent(0.8) }, w("warningBorder", "Border color of warning boxes in the editor.")), Iue = Q("editorInfo.background", { dark: null, light: null, hc: null }, w("editorInfo.background", "Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), bp = Q("editorInfo.foreground", { dark: "#75BEFF", light: "#75BEFF", hc: null }, w("editorInfo.foreground", "Foreground color of info squigglies in the editor.")), u3 = Q("editorInfo.border", { dark: null, light: null, hc: ee.fromHex("#75BEFF").transparent(0.8) }, w("infoBorder", "Border color of info boxes in the editor.")), Pue = Q("editorHint.foreground", { dark: ee.fromHex("#eeeeee").transparent(0.7), light: "#6c6c6c", hc: null }, w("editorHint.foreground", "Foreground color of hint squigglies in the editor.")), Aue = Q("editorHint.border", { dark: null, light: null, hc: ee.fromHex("#eeeeee").transparent(0.8) }, w("hintBorder", "Border color of hint boxes in the editor.")), Uu = Q("editor.background", { light: "#fffffe", dark: "#1E1E1E", hc: ee.black }, w("editorBackground", "Editor background color.")), j_ = Q("editor.foreground", { light: "#333333", dark: "#BBBBBB", hc: ee.white }, w("editorForeground", "Editor default foreground color.")), Bl = Q("editorWidget.background", { dark: "#252526", light: "#F3F3F3", hc: "#0C141F" }, w("editorWidgetBackground", "Background color of editor widgets, such as find/replace.")), zu = Q("editorWidget.foreground", { dark: fd, light: fd, hc: fd }, w("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace.")), bD = Q("editorWidget.border", { dark: "#454545", light: "#C8C8C8", hc: dr }, w("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget.")), QCe = Q("editorWidget.resizeBorder", { light: null, dark: null, hc: null }, w("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget.")), r2 = Q("quickInput.background", { dark: Bl, light: Bl, hc: Bl }, w("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette.")), Mue = Q("quickInput.foreground", { dark: zu, light: zu, hc: zu }, w("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.")), Fue = Q("quickInputTitle.background", { dark: new ee(new xt(255, 255, 255, 0.105)), light: new ee(new xt(0, 0, 0, 0.06)), hc: "#000000" }, w("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette.")), kue = Q("pickerGroup.foreground", { dark: "#3794FF", light: "#0066BF", hc: ee.white }, w("pickerGroupForeground", "Quick picker color for grouping labels.")), Wue = Q("pickerGroup.border", { dark: "#3F3F46", light: "#CCCEDB", hc: ee.white }, w("pickerGroupBorder", "Quick picker color for grouping borders.")), Vue = Q("keybindingLabel.background", { dark: new ee(new xt(128, 128, 128, 0.17)), light: new ee(new xt(221, 221, 221, 0.4)), hc: ee.transparent }, w("keybindingLabelBackground", "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.")), Bue = Q("keybindingLabel.foreground", { dark: ee.fromHex("#CCCCCC"), light: ee.fromHex("#555555"), hc: ee.white }, w("keybindingLabelForeground", "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.")), Hue = Q("keybindingLabel.border", { dark: new ee(new xt(51, 51, 51, 0.6)), light: new ee(new xt(204, 204, 204, 0.4)), hc: new ee(new xt(111, 195, 223)) }, w("keybindingLabelBorder", "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.")), Gue = Q("keybindingLabel.bottomBorder", { dark: new ee(new xt(68, 68, 68, 0.6)), light: new ee(new xt(187, 187, 187, 0.4)), hc: new ee(new xt(111, 195, 223)) }, w("keybindingLabelBottomBorder", "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.")), Sp = Q("editor.selectionBackground", { light: "#ADD6FF", dark: "#264F78", hc: "#f3f518" }, w("editorSelectionBackground", "Color of the editor selection.")), Uue = Q("editor.selectionForeground", { light: null, dark: null, hc: "#000000" }, w("editorSelectionForeground", "Color of the selected text for high contrast.")), eI = Q("editor.inactiveSelectionBackground", { light: fr(Sp, 0.5), dark: fr(Sp, 0.5), hc: fr(Sp, 0.5) }, w("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), !0), c3 = Q("editor.selectionHighlightBackground", { light: c2(Sp, Uu, 0.3, 0.6), dark: c2(Sp, Uu, 0.3, 0.6), hc: null }, w("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), !0), JCe = Q("editor.selectionHighlightBorder", { light: null, dark: null, hc: xs }, w("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection.")), eye = Q("editor.findMatchBackground", { light: "#A8AC94", dark: "#515C6A", hc: null }, w("editorFindMatch", "Color of the current search match.")), o2 = Q("editor.findMatchHighlightBackground", { light: "#EA5C0055", dark: "#EA5C0055", hc: null }, w("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), !0), tye = Q("editor.findRangeHighlightBackground", { dark: "#3a3d4166", light: "#b4b4b44d", hc: null }, w("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0), iye = Q("editor.findMatchBorder", { light: null, dark: null, hc: xs }, w("editorFindMatchBorder", "Border color of the current search match.")), nye = Q("editor.findMatchHighlightBorder", { light: null, dark: null, hc: xs }, w("findMatchHighlightBorder", "Border color of the other search matches.")), rye = Q("editor.findRangeHighlightBorder", { dark: null, light: null, hc: fr(xs, 0.4) }, w("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0), oye = Q("editor.hoverHighlightBackground", { light: "#ADD6FF26", dark: "#264f7840", hc: "#ADD6FF26" }, w("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), !0), s2 = Q("editorHoverWidget.background", { light: Bl, dark: Bl, hc: Bl }, w("hoverBackground", "Background color of the editor hover.")), sye = Q("editorHoverWidget.foreground", { light: zu, dark: zu, hc: zu }, w("hoverForeground", "Foreground color of the editor hover.")), aye = Q("editorHoverWidget.border", { light: bD, dark: bD, hc: bD }, w("hoverBorder", "Border color of the editor hover.")), lye = Q("editorHoverWidget.statusBarBackground", { dark: g3(s2, 0.2), light: p3(s2, 0.05), hc: Bl }, w("statusBarBackground", "Background color of the editor hover status bar.")), uye = Q("editorLink.activeForeground", { dark: "#4E94CE", light: ee.blue, hc: ee.cyan }, w("activeLinkForeground", "Color of active links.")), cye = Q("editorInlayHint.foreground", { dark: Bl, light: zu, hc: Bl }, w("editorInlayHintForeground", "Foreground color of inline hints")), hye = Q("editorInlayHint.background", { dark: zu, light: Bl, hc: zu }, w("editorInlayHintBackground", "Background color of inline hints")), dye = Q("editorLightBulb.foreground", { dark: "#FFCC00", light: "#DDB100", hc: "#FFCC00" }, w("editorLightBulbForeground", "The color used for the lightbulb actions icon.")), fye = Q("editorLightBulbAutoFix.foreground", { dark: "#75BEFF", light: "#007ACC", hc: "#75BEFF" }, w("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon.")), MT = new ee(new xt(155, 185, 85, 0.2)), FT = new ee(new xt(255, 0, 0, 0.2)), h3 = Q("diffEditor.insertedTextBackground", { dark: MT, light: MT, hc: null }, w("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0), d3 = Q("diffEditor.removedTextBackground", { dark: FT, light: FT, hc: null }, w("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), !0), zue = Q("diffEditor.insertedTextBorder", { dark: null, light: null, hc: "#33ff2eff" }, w("diffEditorInsertedOutline", "Outline color for the text that got inserted.")), jue = Q("diffEditor.removedTextBorder", { dark: null, light: null, hc: "#FF008F" }, w("diffEditorRemovedOutline", "Outline color for text that got removed.")), $ue = Q("diffEditor.border", { dark: null, light: null, hc: dr }, w("diffEditorBorder", "Border color between the two text editors.")), Kue = Q("diffEditor.diagonalFill", { dark: "#cccccc33", light: "#22222233", hc: null }, w("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views.")), que = Q("list.focusBackground", { dark: null, light: null, hc: null }, w("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), Yue = Q("list.focusForeground", { dark: null, light: null, hc: null }, w("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), Xue = Q("list.focusOutline", { dark: Kp, light: Kp, hc: xs }, w("listFocusOutline", "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), pd = Q("list.activeSelectionBackground", { dark: "#094771", light: "#0060C0", hc: null }, w("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), Qc = Q("list.activeSelectionForeground", { dark: ee.white, light: ee.white, hc: null }, w("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), Zue = Q("list.inactiveSelectionBackground", { dark: "#37373D", light: "#E4E6F1", hc: null }, w("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), Que = Q("list.inactiveSelectionForeground", { dark: null, light: null, hc: null }, w("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), Jue = Q("list.inactiveFocusBackground", { dark: null, light: null, hc: null }, w("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), ece = Q("list.inactiveFocusOutline", { dark: null, light: null, hc: null }, w("listInactiveFocusOutline", "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), tce = Q("list.hoverBackground", { dark: "#2A2D2E", light: "#F0F0F0", hc: null }, w("listHoverBackground", "List/Tree background when hovering over items using the mouse.")), ice = Q("list.hoverForeground", { dark: null, light: null, hc: null }, w("listHoverForeground", "List/Tree foreground when hovering over items using the mouse.")), nce = Q("list.dropBackground", { dark: "#062F4A", light: "#D6EBFF", hc: null }, w("listDropBackground", "List/Tree drag and drop background when moving items around using the mouse.")), SD = Q("list.highlightForeground", { dark: "#18A3FF", light: "#0066BF", hc: Kp }, w("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree.")), rce = Q("list.focusHighlightForeground", { dark: SD, light: SD, hc: SD }, w("listFocusHighlightForeground", "List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree.")), oce = Q("listFilterWidget.background", { light: "#efc1ad", dark: "#653723", hc: ee.black }, w("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees.")), sce = Q("listFilterWidget.outline", { dark: ee.transparent, light: ee.transparent, hc: "#f38518" }, w("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees.")), ace = Q("listFilterWidget.noMatchesOutline", { dark: "#BE1100", light: "#BE1100", hc: dr }, w("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches.")), lce = Q("tree.indentGuidesStroke", { dark: "#585858", light: "#a9a9a9", hc: "#a9a9a9" }, w("treeIndentGuidesStroke", "Tree stroke color for the indentation guides.")), uce = Q("tree.tableColumnsBorder", { dark: "#CCCCCC20", light: "#61616120", hc: null }, w("treeIndentGuidesStroke", "Tree stroke color for the indentation guides.")), a2 = Q("quickInput.list.focusBackground", { dark: null, light: null, hc: null }, "", void 0, w("quickInput.list.focusBackground deprecation", "Please use quickInputList.focusBackground instead")), cce = Q("quickInputList.focusForeground", { dark: Qc, light: Qc, hc: Qc }, w("quickInput.listFocusForeground", "Quick picker foreground color for the focused item.")), hce = Q("quickInputList.focusBackground", { dark: u2(a2, pd, "#062F4A"), light: u2(a2, pd, "#D6EBFF"), hc: null }, w("quickInput.listFocusBackground", "Quick picker background color for the focused item.")), dce = Q("menu.border", { dark: null, light: null, hc: dr }, w("menuBorder", "Border color of menus.")), fce = Q("menu.foreground", { dark: n2, light: fd, hc: n2 }, w("menuForeground", "Foreground color of menu items.")), pce = Q("menu.background", { dark: wD, light: wD, hc: wD }, w("menuBackground", "Background color of menu items.")), gce = Q("menu.selectionForeground", { dark: Qc, light: Qc, hc: Qc }, w("menuSelectionForeground", "Foreground color of the selected menu item in menus.")), mce = Q("menu.selectionBackground", { dark: pd, light: pd, hc: pd }, w("menuSelectionBackground", "Background color of the selected menu item in menus.")), vce = Q("menu.selectionBorder", { dark: null, light: null, hc: xs }, w("menuSelectionBorder", "Border color of the selected menu item in menus.")), _ce = Q("menu.separatorBackground", { dark: "#BBBBBB", light: "#888888", hc: dr }, w("menuSeparatorBackground", "Color of a separator menu item in menus.")), pye = Q("editor.snippetTabstopHighlightBackground", { dark: new ee(new xt(124, 124, 124, 0.3)), light: new ee(new xt(10, 50, 100, 0.2)), hc: new ee(new xt(124, 124, 124, 0.3)) }, w("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop.")), gye = Q("editor.snippetTabstopHighlightBorder", { dark: null, light: null, hc: null }, w("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop.")), mye = Q("editor.snippetFinalTabstopHighlightBackground", { dark: null, light: null, hc: null }, w("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet.")), vye = Q("editor.snippetFinalTabstopHighlightBorder", { dark: "#525252", light: new ee(new xt(10, 50, 100, 0.5)), hc: "#525252" }, w("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet.")), _ye = Q("editorOverviewRuler.findMatchForeground", { dark: "#d186167e", light: "#d186167e", hc: "#AB5A00" }, w("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), !0), Cye = Q("editorOverviewRuler.selectionHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hc: "#A0A0A0CC" }, w("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), !0), yye = Q("minimap.findMatchHighlight", { light: "#d18616", dark: "#d18616", hc: "#AB5A00" }, w("minimapFindMatchHighlight", "Minimap marker color for find matches."), !0), l2 = Q("minimap.selectionHighlight", { light: "#ADD6FF", dark: "#264F78", hc: "#ffffff" }, w("minimapSelectionHighlight", "Minimap marker color for the editor selection."), !0), Cce = Q("minimap.errorHighlight", { dark: new ee(new xt(255, 18, 18, 0.7)), light: new ee(new xt(255, 18, 18, 0.7)), hc: new ee(new xt(255, 50, 50, 1)) }, w("minimapError", "Minimap marker color for errors.")), yce = Q("minimap.warningHighlight", { dark: Zc, light: Zc, hc: JN }, w("overviewRuleWarning", "Minimap marker color for warnings.")), f3 = Q("minimap.background", { dark: null, light: null, hc: null }, w("minimapBackground", "Minimap background color.")), wce = Q("minimapSlider.background", { light: fr(sw, 0.5), dark: fr(sw, 0.5), hc: fr(sw, 0.5) }, w("minimapSliderBackground", "Minimap slider background color.")), bce = Q("minimapSlider.hoverBackground", { light: fr(aw, 0.5), dark: fr(aw, 0.5), hc: fr(aw, 0.5) }, w("minimapSliderHoverBackground", "Minimap slider background color when hovering.")), Sce = Q("minimapSlider.activeBackground", { light: fr(lw, 0.5), dark: fr(lw, 0.5), hc: fr(lw, 0.5) }, w("minimapSliderActiveBackground", "Minimap slider background color when clicked on.")), wye = Q("problemsErrorIcon.foreground", { dark: uw, light: uw, hc: uw }, w("problemsErrorIconForeground", "The color used for the problems error icon.")), bye = Q("problemsWarningIcon.foreground", { dark: Zc, light: Zc, hc: Zc }, w("problemsWarningIconForeground", "The color used for the problems warning icon.")), Sye = Q("problemsInfoIcon.foreground", { dark: bp, light: bp, hc: bp }, w("problemsInfoIconForeground", "The color used for the problems info icon."));
function Ece(n, e) {
  var t, i, r;
  switch (n.op) {
    case 0:
      return (t = Ic(n.value, e)) === null || t === void 0 ? void 0 : t.darken(n.factor);
    case 1:
      return (i = Ic(n.value, e)) === null || i === void 0 ? void 0 : i.lighten(n.factor);
    case 2:
      return (r = Ic(n.value, e)) === null || r === void 0 ? void 0 : r.transparent(n.factor);
    case 3:
      for (const a of n.values) {
        const l = Ic(a, e);
        if (l)
          return l;
      }
      return;
    case 4:
      const o = Ic(n.value, e);
      if (!o)
        return;
      const s = Ic(n.background, e);
      return s ? o.isDarkerThan(s) ? ee.getLighterColor(o, s, n.factor).transparent(n.transparency) : ee.getDarkerColor(o, s, n.factor).transparent(n.transparency) : o.transparent(n.factor * n.transparency);
    default:
      throw Ire();
  }
}
function p3(n, e) {
  return { op: 0, value: n, factor: e };
}
function g3(n, e) {
  return { op: 1, value: n, factor: e };
}
function fr(n, e) {
  return { op: 2, value: n, factor: e };
}
function u2(...n) {
  return { op: 3, values: n };
}
function c2(n, e, t, i) {
  return { op: 4, value: n, background: e, factor: t, transparency: i };
}
function Ic(n, e) {
  if (n !== null) {
    if (typeof n == "string")
      return n[0] === "#" ? ee.fromHex(n) : e.getColor(n);
    if (n instanceof ee)
      return n;
    if (typeof n == "object")
      return Ece(n, e);
  }
}
const m3 = "vscode://schemas/workbench-colors";
let v3 = Zn.as(i0.JSONContribution);
v3.registerSchema(m3, _0.getColorSchema());
const h2 = new to(() => v3.notifySchemaChanged(m3), 200);
_0.onDidChangeSchema(() => {
  h2.isScheduled() || h2.schedule();
});
const Lce = Q("editor.lineHighlightBackground", { dark: null, light: null, hc: null }, w("lineHighlight", "Background color for the highlight of line at the cursor position.")), d2 = Q("editor.lineHighlightBorder", { dark: "#282828", light: "#eeeeee", hc: "#f38518" }, w("lineHighlightBorderBox", "Background color for the border around the line at the cursor position.")), Dce = Q("editor.rangeHighlightBackground", { dark: "#ffffff0b", light: "#fdff0033", hc: null }, w("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), !0), Rce = Q("editor.rangeHighlightBorder", { dark: null, light: null, hc: xs }, w("rangeHighlightBorder", "Background color of the border around highlighted ranges."), !0), Tce = Q("editor.symbolHighlightBackground", { dark: o2, light: o2, hc: null }, w("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), !0), Oce = Q("editor.symbolHighlightBorder", { dark: null, light: null, hc: xs }, w("symbolHighlightBorder", "Background color of the border around highlighted symbols."), !0), _3 = Q("editorCursor.foreground", { dark: "#AEAFAD", light: ee.black, hc: ee.white }, w("caret", "Color of the editor cursor.")), xce = Q("editorCursor.background", null, w("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.")), gd = Q("editorWhitespace.foreground", { dark: "#e3e4e229", light: "#33333333", hc: "#e3e4e229" }, w("editorWhitespaces", "Color of whitespace characters in the editor.")), y0 = Q("editorIndentGuide.background", { dark: gd, light: gd, hc: gd }, w("editorIndentGuides", "Color of the editor indentation guides.")), w0 = Q("editorIndentGuide.activeBackground", { dark: gd, light: gd, hc: gd }, w("editorActiveIndentGuide", "Color of the active editor indentation guides.")), C3 = Q("editorLineNumber.foreground", { dark: "#858585", light: "#237893", hc: ee.white }, w("editorLineNumbers", "Color of editor line numbers.")), ED = Q("editorActiveLineNumber.foreground", { dark: "#c6c6c6", light: "#0B216F", hc: xs }, w("editorActiveLineNumber", "Color of editor active line number"), !1, w("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead.")), Nce = Q("editorLineNumber.activeForeground", { dark: ED, light: ED, hc: ED }, w("editorActiveLineNumber", "Color of editor active line number")), Ice = Q("editorRuler.foreground", { dark: "#5A5A5A", light: ee.lightgrey, hc: ee.white }, w("editorRuler", "Color of the editor rulers.")), Eye = Q("editorCodeLens.foreground", { dark: "#999999", light: "#999999", hc: "#999999" }, w("editorCodeLensForeground", "Foreground color of editor CodeLens")), Lye = Q("editorBracketMatch.background", { dark: "#0064001a", light: "#0064001a", hc: "#0064001a" }, w("editorBracketMatchBackground", "Background color behind matching brackets")), Dye = Q("editorBracketMatch.border", { dark: "#888", light: "#B9B9B9", hc: dr }, w("editorBracketMatchBorder", "Color for matching brackets boxes")), Pce = Q("editorOverviewRuler.border", { dark: "#7f7f7f4d", light: "#7f7f7f4d", hc: "#7f7f7f4d" }, w("editorOverviewRulerBorder", "Color of the overview ruler border.")), Ace = Q("editorOverviewRuler.background", null, w("editorOverviewRulerBackground", "Background color of the editor overview ruler. Only used when the minimap is enabled and placed on the right side of the editor.")), Mce = Q("editorGutter.background", { dark: Uu, light: Uu, hc: Uu }, w("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.")), Fce = Q("editorUnnecessaryCode.border", { dark: null, light: null, hc: ee.fromHex("#fff").transparent(0.8) }, w("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor.")), kce = Q("editorUnnecessaryCode.opacity", { dark: ee.fromHex("#000a"), light: ee.fromHex("#0007"), hc: null }, w("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`)), Rye = Q("editorGhostText.border", { dark: null, light: null, hc: ee.fromHex("#fff").transparent(0.8) }, w("editorGhostTextBorder", "Border color of ghost text in the editor.")), Tye = Q("editorGhostText.foreground", { dark: ee.fromHex("#ffffff56"), light: ee.fromHex("#0007"), hc: null }, w("editorGhostTextForeground", "Foreground color of the ghost text in the editor.")), LD = new ee(new xt(0, 122, 204, 0.6)), Oye = Q("editorOverviewRuler.rangeHighlightForeground", { dark: LD, light: LD, hc: LD }, w("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), !0), Wce = Q("editorOverviewRuler.errorForeground", { dark: new ee(new xt(255, 18, 18, 0.7)), light: new ee(new xt(255, 18, 18, 0.7)), hc: new ee(new xt(255, 50, 50, 1)) }, w("overviewRuleError", "Overview ruler marker color for errors.")), Vce = Q("editorOverviewRuler.warningForeground", { dark: Zc, light: Zc, hc: JN }, w("overviewRuleWarning", "Overview ruler marker color for warnings.")), Bce = Q("editorOverviewRuler.infoForeground", { dark: bp, light: bp, hc: u3 }, w("overviewRuleInfo", "Overview ruler marker color for infos."));
_a((n, e) => {
  const t = n.getColor(Uu);
  t && e.addRule(`.monaco-editor, .monaco-editor-background, .monaco-editor .inputarea.ime-input { background-color: ${t}; }`);
  const i = n.getColor(j_);
  i && e.addRule(`.monaco-editor, .monaco-editor .inputarea.ime-input { color: ${i}; }`);
  const r = n.getColor(Mce);
  r && e.addRule(`.monaco-editor .margin { background-color: ${r}; }`);
  const o = n.getColor(Dce);
  o && e.addRule(`.monaco-editor .rangeHighlight { background-color: ${o}; }`);
  const s = n.getColor(Rce);
  s && e.addRule(`.monaco-editor .rangeHighlight { border: 1px ${n.type === "hc" ? "dotted" : "solid"} ${s}; }`);
  const a = n.getColor(Tce);
  a && e.addRule(`.monaco-editor .symbolHighlight { background-color: ${a}; }`);
  const l = n.getColor(Oce);
  l && e.addRule(`.monaco-editor .symbolHighlight { border: 1px ${n.type === "hc" ? "dotted" : "solid"} ${l}; }`);
  const u = n.getColor(gd);
  u && (e.addRule(`.monaco-editor .mtkw { color: ${u} !important; }`), e.addRule(`.monaco-editor .mtkz { color: ${u} !important; }`));
});
class qp extends Dg {
  constructor(e) {
    super(), this._context = e, this._readConfig(), this._lastCursorModelPosition = new J(1, 1), this._renderResult = null, this._activeLineNumber = 1, this._context.addEventHandler(this);
  }
  _readConfig() {
    const e = this._context.configuration.options;
    this._lineHeight = e.get(
      56
      /* lineHeight */
    );
    const t = e.get(
      57
      /* lineNumbers */
    );
    this._renderLineNumbers = t.renderType, this._renderCustomLineNumbers = t.renderFn, this._renderFinalNewline = e.get(
      82
      /* renderFinalNewline */
    );
    const i = e.get(
      128
      /* layoutInfo */
    );
    this._lineNumbersLeft = i.lineNumbersLeft, this._lineNumbersWidth = i.lineNumbersWidth;
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return this._readConfig(), !0;
  }
  onCursorStateChanged(e) {
    const t = e.selections[0].getPosition();
    this._lastCursorModelPosition = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(t);
    let i = !1;
    return this._activeLineNumber !== t.lineNumber && (this._activeLineNumber = t.lineNumber, i = !0), (this._renderLineNumbers === 2 || this._renderLineNumbers === 3) && (i = !0), i;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getLineRenderLineNumber(e) {
    const t = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new J(e, 1));
    if (t.column !== 1)
      return "";
    const i = t.lineNumber;
    if (this._renderCustomLineNumbers)
      return this._renderCustomLineNumbers(i);
    if (this._renderLineNumbers === 2) {
      const r = Math.abs(this._lastCursorModelPosition.lineNumber - i);
      return r === 0 ? '<span class="relative-current-line-number">' + i + "</span>" : String(r);
    }
    return this._renderLineNumbers === 3 ? this._lastCursorModelPosition.lineNumber === i || i % 10 === 0 ? String(i) : "" : String(i);
  }
  prepareRender(e) {
    if (this._renderLineNumbers === 0) {
      this._renderResult = null;
      return;
    }
    const t = Rs ? this._lineHeight % 2 === 0 ? " lh-even" : " lh-odd" : "", i = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber, o = '<div class="' + qp.CLASS_NAME + t + '" style="left:' + this._lineNumbersLeft + "px;width:" + this._lineNumbersWidth + 'px;">', s = this._context.model.getLineCount(), a = [];
    for (let l = i; l <= r; l++) {
      const u = l - i;
      if (!this._renderFinalNewline && l === s && this._context.model.getLineLength(l) === 0) {
        a[u] = "";
        continue;
      }
      const c = this._getLineRenderLineNumber(l);
      c ? l === this._activeLineNumber ? a[u] = '<div class="active-line-number ' + qp.CLASS_NAME + t + '" style="left:' + this._lineNumbersLeft + "px;width:" + this._lineNumbersWidth + 'px;">' + c + "</div>" : a[u] = o + c + "</div>" : a[u] = "";
    }
    this._renderResult = a;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
qp.CLASS_NAME = "line-numbers";
_a((n, e) => {
  const t = n.getColor(C3);
  t && e.addRule(`.monaco-editor .line-numbers { color: ${t}; }`);
  const i = n.getColor(Nce);
  i && e.addRule(`.monaco-editor .line-numbers.active-line-number { color: ${i}; }`);
});
class Fd extends Ns {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    this._canUseLayerHinting = !t.get(
      26
      /* disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._domNode = bt(document.createElement("div")), this._domNode.setClassName(Fd.OUTER_CLASS_NAME), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._glyphMarginBackgroundDomNode = bt(document.createElement("div")), this._glyphMarginBackgroundDomNode.setClassName(Fd.CLASS_NAME), this._domNode.appendChild(this._glyphMarginBackgroundDomNode);
  }
  dispose() {
    super.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    return this._canUseLayerHinting = !t.get(
      26
      /* disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollTopChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setLayerHinting(this._canUseLayerHinting), this._domNode.setContain("strict");
    const t = e.scrollTop - e.bigNumbersDelta;
    this._domNode.setTop(-t);
    const i = Math.min(e.scrollHeight, 1e6);
    this._domNode.setHeight(i), this._domNode.setWidth(this._contentLeft), this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft), this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth), this._glyphMarginBackgroundDomNode.setHeight(i);
  }
}
Fd.CLASS_NAME = "glyph-margin";
Fd.OUTER_CLASS_NAME = "margin";
const md = "monaco-mouse-cursor-text";
class tI {
  constructor(e, t, i) {
    this.top = e, this.left = t, this.width = i;
  }
  setWidth(e) {
    return new tI(this.top, this.left, e);
  }
}
const xm = Qr;
class Hce extends Ns {
  constructor(e, t, i) {
    super(e), this._primaryCursorPosition = new J(1, 1), this._primaryCursorVisibleRange = null, this._viewController = t, this._viewHelper = i, this._scrollLeft = 0, this._scrollTop = 0;
    const r = this._context.configuration.options, o = r.get(
      128
      /* layoutInfo */
    );
    this._setAccessibilityOptions(r), this._contentLeft = o.contentLeft, this._contentWidth = o.contentWidth, this._contentHeight = o.height, this._fontInfo = r.get(
      40
      /* fontInfo */
    ), this._lineHeight = r.get(
      56
      /* lineHeight */
    ), this._emptySelectionClipboard = r.get(
      30
      /* emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = r.get(
      19
      /* copyWithSyntaxHighlighting */
    ), this._visibleTextArea = null, this._selections = [new Ut(1, 1, 1, 1)], this._modelSelections = [new Ut(1, 1, 1, 1)], this._lastRenderPosition = null, this.textArea = bt(document.createElement("textarea")), jl.write(
      this.textArea,
      6
      /* TextArea */
    ), this.textArea.setClassName(`inputarea ${md}`), this.textArea.setAttribute("wrap", "off"), this.textArea.setAttribute("autocorrect", "off"), this.textArea.setAttribute("autocapitalize", "off"), this.textArea.setAttribute("autocomplete", "off"), this.textArea.setAttribute("spellcheck", "false"), this.textArea.setAttribute("aria-label", this._getAriaLabel(r)), this.textArea.setAttribute("tabindex", String(r.get(
      110
      /* tabIndex */
    ))), this.textArea.setAttribute("role", "textbox"), this.textArea.setAttribute("aria-roledescription", w("editor", "editor")), this.textArea.setAttribute("aria-multiline", "true"), this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), r.get(
      28
      /* domReadOnly */
    ) && r.get(
      78
      /* readOnly */
    ) && this.textArea.setAttribute("readonly", "true"), this.textAreaCover = bt(document.createElement("div")), this.textAreaCover.setPosition("absolute");
    const s = {
      getLineCount: () => this._context.model.getLineCount(),
      getLineMaxColumn: (l) => this._context.model.getLineMaxColumn(l),
      getValueInRange: (l, u) => this._context.model.getValueInRange(l, u)
    }, a = {
      getDataToCopy: (l) => {
        const u = this._context.model.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, Eo), c = this._context.model.getEOL(), h = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty(), d = Array.isArray(u) ? u : null, f = Array.isArray(u) ? u.join(c) : u;
        let p, g = null;
        if (l && (aue.forceCopyWithSyntaxHighlighting || this._copyWithSyntaxHighlighting && f.length < 65536)) {
          const _ = this._context.model.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);
          _ && (p = _.html, g = _.mode);
        }
        return {
          isFromEmptySelection: h,
          multicursorText: d,
          text: f,
          html: p,
          mode: g
        };
      },
      getScreenReaderContent: (l) => {
        if (this._accessibilitySupport === 1) {
          if (Ft) {
            const u = this._selections[0];
            if (u.isEmpty()) {
              const c = u.getStartPosition();
              let h = this._getWordBeforePosition(c);
              if (h.length === 0 && (h = this._getCharacterBeforePosition(c)), h.length > 0)
                return new Rn(h, h.length, h.length, c, c);
            }
          }
          return Rn.EMPTY;
        }
        if (Bm) {
          const u = this._selections[0];
          if (u.isEmpty()) {
            const c = u.getStartPosition(), [h, d] = this._getAndroidWordAtPosition(c);
            if (h.length > 0)
              return new Rn(h, d, d, c, c);
          }
          return Rn.EMPTY;
        }
        return Xf.fromEditorSelection(
          l,
          s,
          this._selections[0],
          this._accessibilityPageSize,
          this._accessibilitySupport === 0
          /* Unknown */
        );
      },
      deduceModelPosition: (l, u, c) => this._context.model.deduceModelPositionRelativeToViewPosition(l, u, c)
    };
    this._textAreaInput = this._register(new lue(a, this.textArea)), this._register(this._textAreaInput.onKeyDown((l) => {
      this._viewController.emitKeyDown(l);
    })), this._register(this._textAreaInput.onKeyUp((l) => {
      this._viewController.emitKeyUp(l);
    })), this._register(this._textAreaInput.onPaste((l) => {
      let u = !1, c = null, h = null;
      l.metadata && (u = this._emptySelectionClipboard && !!l.metadata.isFromEmptySelection, c = typeof l.metadata.multicursorText < "u" ? l.metadata.multicursorText : null, h = l.metadata.mode), this._viewController.paste(l.text, u, c, h);
    })), this._register(this._textAreaInput.onCut(() => {
      this._viewController.cut();
    })), this._register(this._textAreaInput.onType((l) => {
      l.replacePrevCharCnt || l.replaceNextCharCnt || l.positionDelta ? this._viewController.compositionType(l.text, l.replacePrevCharCnt, l.replaceNextCharCnt, l.positionDelta) : this._viewController.type(l.text);
    })), this._register(this._textAreaInput.onSelectionChangeRequest((l) => {
      this._viewController.setSelection(l);
    })), this._register(this._textAreaInput.onCompositionStart((l) => {
      const u = this._selections[0].startLineNumber, c = this._selections[0].startColumn + l.revealDeltaColumns;
      this._context.model.revealRange(
        "keyboard",
        !0,
        new V(u, c, u, c),
        0,
        1
        /* Immediate */
      );
      const h = this._viewHelper.visibleRangeForPositionRelativeToEditor(u, c);
      h && (this._visibleTextArea = new tI(this._context.viewLayout.getVerticalOffsetForLineNumber(u), h.left, xm ? 0 : 1), this._render()), this.textArea.setClassName(`inputarea ${md} ime-input`), this._viewController.compositionStart(), this._context.model.onCompositionStart();
    })), this._register(this._textAreaInput.onCompositionUpdate((l) => {
      this._visibleTextArea && (this._visibleTextArea = this._visibleTextArea.setWidth(Gce(l.data, this._fontInfo)), this._render());
    })), this._register(this._textAreaInput.onCompositionEnd(() => {
      this._visibleTextArea = null, this._render(), this.textArea.setClassName(`inputarea ${md}`), this._viewController.compositionEnd(), this._context.model.onCompositionEnd();
    })), this._register(this._textAreaInput.onFocus(() => {
      this._context.model.setHasFocus(!0);
    })), this._register(this._textAreaInput.onBlur(() => {
      this._context.model.setHasFocus(!1);
    }));
  }
  dispose() {
    super.dispose();
  }
  _getAndroidWordAtPosition(e) {
    const t = '`~!@#$%^&*()-=+[{]}\\|;:",.<>/?', i = this._context.model.getLineContent(e.lineNumber), r = jp(t);
    let o = !0, s = e.column, a = !0, l = e.column, u = 0;
    for (; u < 50 && (o || a); ) {
      if (o && s <= 1 && (o = !1), o) {
        const c = i.charCodeAt(s - 2);
        r.get(c) !== 0 ? o = !1 : s--;
      }
      if (a && l > i.length && (a = !1), a) {
        const c = i.charCodeAt(l - 1);
        r.get(c) !== 0 ? a = !1 : l++;
      }
      u++;
    }
    return [i.substring(s - 1, l - 1), e.column - s];
  }
  _getWordBeforePosition(e) {
    const t = this._context.model.getLineContent(e.lineNumber), i = jp(this._context.configuration.options.get(
      114
      /* wordSeparators */
    ));
    let r = e.column, o = 0;
    for (; r > 1; ) {
      const s = t.charCodeAt(r - 2);
      if (i.get(s) !== 0 || o > 50)
        return t.substring(r - 1, e.column - 1);
      o++, r--;
    }
    return t.substring(0, e.column - 1);
  }
  _getCharacterBeforePosition(e) {
    if (e.column > 1) {
      const i = this._context.model.getLineContent(e.lineNumber).charAt(e.column - 2);
      if (!jn(i.charCodeAt(0)))
        return i;
    }
    return "";
  }
  _getAriaLabel(e) {
    return e.get(
      2
      /* accessibilitySupport */
    ) === 1 ? w("accessibilityOffAriaLabel", "The editor is not accessible at this time. Press {0} for options.", Rs ? "Shift+Alt+F1" : "Alt+F1") : e.get(
      4
      /* ariaLabel */
    );
  }
  _setAccessibilityOptions(e) {
    this._accessibilitySupport = e.get(
      2
      /* accessibilitySupport */
    );
    const t = e.get(
      3
      /* accessibilityPageSize */
    );
    this._accessibilitySupport === 2 && t === Kd.accessibilityPageSize.defaultValue ? this._accessibilityPageSize = 500 : this._accessibilityPageSize = t;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    return this._setAccessibilityOptions(t), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._contentHeight = i.height, this._fontInfo = t.get(
      40
      /* fontInfo */
    ), this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._emptySelectionClipboard = t.get(
      30
      /* emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = t.get(
      19
      /* copyWithSyntaxHighlighting */
    ), this.textArea.setAttribute("aria-label", this._getAriaLabel(t)), this.textArea.setAttribute("tabindex", String(t.get(
      110
      /* tabIndex */
    ))), (e.hasChanged(
      28
      /* domReadOnly */
    ) || e.hasChanged(
      78
      /* readOnly */
    )) && (t.get(
      28
      /* domReadOnly */
    ) && t.get(
      78
      /* readOnly */
    ) ? this.textArea.setAttribute("readonly", "true") : this.textArea.removeAttribute("readonly")), e.hasChanged(
      2
      /* accessibilitySupport */
    ) && this._textAreaInput.writeScreenReaderContent("strategy changed"), !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), this._modelSelections = e.modelSelections.slice(0), this._textAreaInput.writeScreenReaderContent("selection changed"), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return this._scrollLeft = e.scrollLeft, this._scrollTop = e.scrollTop, !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // --- begin view API
  isFocused() {
    return this._textAreaInput.isFocused();
  }
  focusTextArea() {
    this._textAreaInput.focusTextArea();
  }
  getLastRenderData() {
    return this._lastRenderPosition;
  }
  setAriaOptions(e) {
    e.activeDescendant ? (this.textArea.setAttribute("aria-haspopup", "true"), this.textArea.setAttribute("aria-autocomplete", "list"), this.textArea.setAttribute("aria-activedescendant", e.activeDescendant)) : (this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), this.textArea.removeAttribute("aria-activedescendant")), e.role && this.textArea.setAttribute("role", e.role);
  }
  prepareRender(e) {
    this._primaryCursorPosition = new J(this._selections[0].positionLineNumber, this._selections[0].positionColumn), this._primaryCursorVisibleRange = e.visibleRangeForPosition(this._primaryCursorPosition);
  }
  render(e) {
    this._textAreaInput.writeScreenReaderContent("render"), this._render();
  }
  _render() {
    if (this._visibleTextArea) {
      this._renderInsideEditor(null, this._visibleTextArea.top - this._scrollTop, this._contentLeft + this._visibleTextArea.left - this._scrollLeft, this._visibleTextArea.width, this._lineHeight);
      return;
    }
    if (!this._primaryCursorVisibleRange) {
      this._renderAtTopLeft();
      return;
    }
    const e = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
    if (e < this._contentLeft || e > this._contentLeft + this._contentWidth) {
      this._renderAtTopLeft();
      return;
    }
    const t = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;
    if (t < 0 || t > this._contentHeight) {
      this._renderAtTopLeft();
      return;
    }
    if (Ft) {
      this._renderInsideEditor(this._primaryCursorPosition, t, e, xm ? 0 : 1, this._lineHeight);
      return;
    }
    this._renderInsideEditor(this._primaryCursorPosition, t, e, xm ? 0 : 1, xm ? 0 : 1);
  }
  _renderInsideEditor(e, t, i, r, o) {
    this._lastRenderPosition = e;
    const s = this.textArea, a = this.textAreaCover;
    io.applyFontInfo(s, this._fontInfo), s.setTop(t), s.setLeft(i), s.setWidth(r), s.setHeight(o), a.setTop(0), a.setLeft(0), a.setWidth(0), a.setHeight(0);
  }
  _renderAtTopLeft() {
    this._lastRenderPosition = null;
    const e = this.textArea, t = this.textAreaCover;
    if (io.applyFontInfo(e, this._fontInfo), e.setTop(0), e.setLeft(0), t.setTop(0), t.setLeft(0), xm) {
      e.setWidth(0), e.setHeight(0), t.setWidth(0), t.setHeight(0);
      return;
    }
    e.setWidth(1), e.setHeight(1), t.setWidth(1), t.setHeight(1);
    const i = this._context.configuration.options;
    i.get(
      46
      /* glyphMargin */
    ) ? t.setClassName("monaco-editor-background textAreaCover " + Fd.OUTER_CLASS_NAME) : i.get(
      57
      /* lineNumbers */
    ).renderType !== 0 ? t.setClassName("monaco-editor-background textAreaCover " + qp.CLASS_NAME) : t.setClassName("monaco-editor-background textAreaCover");
  }
}
function Gce(n, e) {
  const i = document.createElement("canvas").getContext("2d");
  i.font = Uce(e);
  const r = i.measureText(n);
  return Qr ? r.width + 2 : r.width;
}
function Uce(n) {
  return zce("normal", n.fontWeight, n.fontSize, n.lineHeight, n.fontFamily);
}
function zce(n, e, t, i, r) {
  return `${n} normal ${e} ${t}px / ${i}px ${r}`;
}
class qh {
  static columnSelect(e, t, i, r, o, s) {
    let a = Math.abs(o - i) + 1, l = i > o, u = r > s, c = r < s, h = [];
    for (let d = 0; d < a; d++) {
      let f = i + (l ? -d : d), p = Kt.columnFromVisibleColumn2(e, t, f, r), g = Kt.columnFromVisibleColumn2(e, t, f, s), _ = Kt.visibleColumnFromColumn2(e, t, new J(f, p)), m = Kt.visibleColumnFromColumn2(e, t, new J(f, g));
      c && (_ > s || m < r) || u && (m > r || _ < s) || h.push(new $n(new V(f, p, f, p), 0, new J(f, g), 0));
    }
    if (h.length === 0)
      for (let d = 0; d < a; d++) {
        const f = i + (l ? -d : d), p = t.getLineMaxColumn(f);
        h.push(new $n(new V(f, p, f, p), 0, new J(f, p), 0));
      }
    return {
      viewStates: h,
      reversed: l,
      fromLineNumber: i,
      fromVisualColumn: r,
      toLineNumber: o,
      toVisualColumn: s
    };
  }
  static columnSelectLeft(e, t, i) {
    let r = i.toViewVisualColumn;
    return r > 0 && r--, qh.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, r);
  }
  static columnSelectRight(e, t, i) {
    let r = 0;
    const o = Math.min(i.fromViewLineNumber, i.toViewLineNumber), s = Math.max(i.fromViewLineNumber, i.toViewLineNumber);
    for (let l = o; l <= s; l++) {
      const u = t.getLineMaxColumn(l), c = Kt.visibleColumnFromColumn2(e, t, new J(l, u));
      r = Math.max(r, c);
    }
    let a = i.toViewVisualColumn;
    return a < r && a++, this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, a);
  }
  static columnSelectUp(e, t, i, r) {
    const o = r ? e.pageSize : 1, s = Math.max(1, i.toViewLineNumber - o);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, s, i.toViewVisualColumn);
  }
  static columnSelectDown(e, t, i, r) {
    const o = r ? e.pageSize : 1, s = Math.min(t.getLineCount(), i.toViewLineNumber + o);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, s, i.toViewVisualColumn);
  }
}
class go {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    let r = t.getInverseEditOperations()[0].range;
    return new Ut(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn);
  }
}
class xye {
  constructor(e, t) {
    this._range = e, this._text = t;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const r = t.getInverseEditOperations()[0].range;
    return new Ut(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn);
  }
}
class yy {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    let r = t.getInverseEditOperations()[0].range;
    return new Ut(r.startLineNumber, r.startColumn, r.startLineNumber, r.startColumn);
  }
}
class cw {
  constructor(e, t, i, r, o = !1) {
    this._range = e, this._text = t, this._columnDeltaOffset = r, this._lineNumberDeltaOffset = i, this.insertsAutoWhitespace = o;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    let r = t.getInverseEditOperations()[0].range;
    return new Ut(r.endLineNumber + this._lineNumberDeltaOffset, r.endColumn + this._columnDeltaOffset, r.endLineNumber + this._lineNumberDeltaOffset, r.endColumn + this._columnDeltaOffset);
  }
}
class jce {
  constructor(e, t, i, r = !1) {
    this._range = e, this._text = t, this._initialSelection = i, this._forceMoveMarkers = r, this._selectionId = null;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers), this._selectionId = t.trackSelection(this._initialSelection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._selectionId);
  }
}
class wy {
  constructor(e, t, i) {
    this.lineNumber = e, this.column = t, this.leftoverVisibleColumns = i;
  }
}
class At {
  static leftPosition(e, t) {
    if (t.column > e.getLineMinColumn(t.lineNumber))
      return t.delta(void 0, -tre(e.getLineContent(t.lineNumber), t.column - 1));
    if (t.lineNumber > 1) {
      const i = t.lineNumber - 1;
      return new J(i, e.getLineMaxColumn(i));
    } else
      return t;
  }
  static leftPositionAtomicSoftTabs(e, t, i) {
    if (t.column <= e.getLineIndentColumn(t.lineNumber)) {
      const r = e.getLineMinColumn(t.lineNumber), o = e.getLineContent(t.lineNumber), s = Qv.atomicPosition(
        o,
        t.column - 1,
        i,
        0
        /* Left */
      );
      if (s !== -1 && s + 1 >= r)
        return new J(t.lineNumber, s + 1);
    }
    return this.leftPosition(e, t);
  }
  static left(e, t, i) {
    const r = e.stickyTabStops ? At.leftPositionAtomicSoftTabs(t, i, e.tabSize) : At.leftPosition(t, i);
    return new wy(r.lineNumber, r.column, 0);
  }
  /**
   * @param noOfColumns Must be either `1`
   * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).
  */
  static moveLeft(e, t, i, r, o) {
    let s, a;
    if (i.hasSelection() && !r)
      s = i.selection.startLineNumber, a = i.selection.startColumn;
    else {
      const l = i.position.delta(void 0, -(o - 1)), u = t.normalizePosition(
        At.clipPositionColumn(l, t),
        0
        /* Left */
      ), c = At.left(e, t, u);
      s = c.lineNumber, a = c.column;
    }
    return i.move(r, s, a, 0);
  }
  /**
   * Adjusts the column so that it is within min/max of the line.
  */
  static clipPositionColumn(e, t) {
    return new J(e.lineNumber, At.clipRange(e.column, t.getLineMinColumn(e.lineNumber), t.getLineMaxColumn(e.lineNumber)));
  }
  static clipRange(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static rightPosition(e, t, i) {
    return i < e.getLineMaxColumn(t) ? i = i + ob(e.getLineContent(t), i - 1) : t < e.getLineCount() && (t = t + 1, i = e.getLineMinColumn(t)), new J(t, i);
  }
  static rightPositionAtomicSoftTabs(e, t, i, r, o) {
    if (i < e.getLineIndentColumn(t)) {
      const s = e.getLineContent(t), a = Qv.atomicPosition(
        s,
        i - 1,
        r,
        1
        /* Right */
      );
      if (a !== -1)
        return new J(t, a + 1);
    }
    return this.rightPosition(e, t, i);
  }
  static right(e, t, i) {
    const r = e.stickyTabStops ? At.rightPositionAtomicSoftTabs(t, i.lineNumber, i.column, e.tabSize, e.indentSize) : At.rightPosition(t, i.lineNumber, i.column);
    return new wy(r.lineNumber, r.column, 0);
  }
  static moveRight(e, t, i, r, o) {
    let s, a;
    if (i.hasSelection() && !r)
      s = i.selection.endLineNumber, a = i.selection.endColumn;
    else {
      const l = i.position.delta(void 0, o - 1), u = t.normalizePosition(
        At.clipPositionColumn(l, t),
        1
        /* Right */
      ), c = At.right(e, t, u);
      s = c.lineNumber, a = c.column;
    }
    return i.move(r, s, a, 0);
  }
  static down(e, t, i, r, o, s, a) {
    const l = Kt.visibleColumnFromColumn(t.getLineContent(i), r, e.tabSize) + o, u = t.getLineCount(), c = i === u && r === t.getLineMaxColumn(i);
    return i = i + s, i > u ? (i = u, a ? r = t.getLineMaxColumn(i) : r = Math.min(t.getLineMaxColumn(i), r)) : r = Kt.columnFromVisibleColumn2(e, t, i, l), c ? o = 0 : o = l - Kt.visibleColumnFromColumn(t.getLineContent(i), r, e.tabSize), new wy(i, r, o);
  }
  static moveDown(e, t, i, r, o) {
    let s, a;
    i.hasSelection() && !r ? (s = i.selection.endLineNumber, a = i.selection.endColumn) : (s = i.position.lineNumber, a = i.position.column);
    let l = At.down(e, t, s, a, i.leftoverVisibleColumns, o, !0);
    return i.move(r, l.lineNumber, l.column, l.leftoverVisibleColumns);
  }
  static translateDown(e, t, i) {
    let r = i.selection, o = At.down(e, t, r.selectionStartLineNumber, r.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), s = At.down(e, t, r.positionLineNumber, r.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new $n(new V(o.lineNumber, o.column, o.lineNumber, o.column), o.leftoverVisibleColumns, new J(s.lineNumber, s.column), s.leftoverVisibleColumns);
  }
  static up(e, t, i, r, o, s, a) {
    const l = Kt.visibleColumnFromColumn(t.getLineContent(i), r, e.tabSize) + o, u = i === 1 && r === 1;
    return i = i - s, i < 1 ? (i = 1, a ? r = t.getLineMinColumn(i) : r = Math.min(t.getLineMaxColumn(i), r)) : r = Kt.columnFromVisibleColumn2(e, t, i, l), u ? o = 0 : o = l - Kt.visibleColumnFromColumn(t.getLineContent(i), r, e.tabSize), new wy(i, r, o);
  }
  static moveUp(e, t, i, r, o) {
    let s, a;
    i.hasSelection() && !r ? (s = i.selection.startLineNumber, a = i.selection.startColumn) : (s = i.position.lineNumber, a = i.position.column);
    let l = At.up(e, t, s, a, i.leftoverVisibleColumns, o, !0);
    return i.move(r, l.lineNumber, l.column, l.leftoverVisibleColumns);
  }
  static translateUp(e, t, i) {
    let r = i.selection, o = At.up(e, t, r.selectionStartLineNumber, r.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), s = At.up(e, t, r.positionLineNumber, r.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new $n(new V(o.lineNumber, o.column, o.lineNumber, o.column), o.leftoverVisibleColumns, new J(s.lineNumber, s.column), s.leftoverVisibleColumns);
  }
  static _isBlankLine(e, t) {
    return e.getLineFirstNonWhitespaceColumn(t) === 0;
  }
  static moveToPrevBlankLine(e, t, i, r) {
    let o = i.position.lineNumber;
    for (; o > 1 && this._isBlankLine(t, o); )
      o--;
    for (; o > 1 && !this._isBlankLine(t, o); )
      o--;
    return i.move(r, o, t.getLineMinColumn(o), 0);
  }
  static moveToNextBlankLine(e, t, i, r) {
    const o = t.getLineCount();
    let s = i.position.lineNumber;
    for (; s < o && this._isBlankLine(t, s); )
      s++;
    for (; s < o && !this._isBlankLine(t, s); )
      s++;
    return i.move(r, s, t.getLineMinColumn(s), 0);
  }
  static moveToBeginningOfLine(e, t, i, r) {
    let o = i.position.lineNumber, s = t.getLineMinColumn(o), a = t.getLineFirstNonWhitespaceColumn(o) || s, l;
    return i.position.column === a ? l = s : l = a, i.move(r, o, l, 0);
  }
  static moveToEndOfLine(e, t, i, r, o) {
    let s = i.position.lineNumber, a = t.getLineMaxColumn(s);
    return i.move(r, s, a, o ? 1073741824 - a : 0);
  }
  static moveToBeginningOfBuffer(e, t, i, r) {
    return i.move(r, 1, 1, 0);
  }
  static moveToEndOfBuffer(e, t, i, r) {
    let o = t.getLineCount(), s = t.getLineMaxColumn(o);
    return i.move(r, o, s, 0);
  }
}
class kd {
  static deleteRight(e, t, i, r) {
    let o = [], s = e !== 3;
    for (let a = 0, l = r.length; a < l; a++) {
      const u = r[a];
      let c = u;
      if (c.isEmpty()) {
        let h = u.getPosition(), d = At.right(t, i, h);
        c = new V(d.lineNumber, d.column, h.lineNumber, h.column);
      }
      if (c.isEmpty()) {
        o[a] = null;
        continue;
      }
      c.startLineNumber !== c.endLineNumber && (s = !0), o[a] = new go(c, "");
    }
    return [s, o];
  }
  static isAutoClosingPairDelete(e, t, i, r, o, s, a) {
    if (t === "never" && i === "never" || e === "never")
      return !1;
    for (let l = 0, u = s.length; l < u; l++) {
      const c = s[l], h = c.getPosition();
      if (!c.isEmpty())
        return !1;
      const d = o.getLineContent(h.lineNumber);
      if (h.column < 2 || h.column >= d.length + 1)
        return !1;
      const f = d.charAt(h.column - 2), p = r.get(f);
      if (!p)
        return !1;
      if (kf(f)) {
        if (i === "never")
          return !1;
      } else if (t === "never")
        return !1;
      const g = d.charAt(h.column - 1);
      let _ = !1;
      for (const m of p)
        m.open === f && m.close === g && (_ = !0);
      if (!_)
        return !1;
      if (e === "auto") {
        let m = !1;
        for (let v = 0, C = a.length; v < C; v++) {
          const y = a[v];
          if (h.lineNumber === y.startLineNumber && h.column === y.startColumn) {
            m = !0;
            break;
          }
        }
        if (!m)
          return !1;
      }
    }
    return !0;
  }
  static _runAutoClosingPairDelete(e, t, i) {
    let r = [];
    for (let o = 0, s = i.length; o < s; o++) {
      const a = i[o].getPosition(), l = new V(a.lineNumber, a.column - 1, a.lineNumber, a.column + 1);
      r[o] = new go(l, "");
    }
    return [!0, r];
  }
  static deleteLeft(e, t, i, r, o) {
    if (this.isAutoClosingPairDelete(t.autoClosingDelete, t.autoClosingBrackets, t.autoClosingQuotes, t.autoClosingPairs.autoClosingPairsOpenByEnd, i, r, o))
      return this._runAutoClosingPairDelete(t, i, r);
    const s = [];
    let a = e !== 2;
    for (let l = 0, u = r.length; l < u; l++) {
      let c = kd.getDeleteRange(r[l], i, t);
      if (c.isEmpty()) {
        s[l] = null;
        continue;
      }
      c.startLineNumber !== c.endLineNumber && (a = !0), s[l] = new go(c, "");
    }
    return [a, s];
  }
  static getDeleteRange(e, t, i) {
    if (!e.isEmpty())
      return e;
    const r = e.getPosition();
    if (i.useTabStops && r.column > 1) {
      const o = t.getLineContent(r.lineNumber), s = Es(o), a = s === -1 ? (
        /* entire string is whitespace */
        o.length + 1
      ) : s + 1;
      if (r.column <= a) {
        const l = Kt.visibleColumnFromColumn2(i, t, r), u = Kt.prevIndentTabStop(l, i.indentSize), c = Kt.columnFromVisibleColumn2(i, t, r.lineNumber, u);
        return new V(r.lineNumber, c, r.lineNumber, r.column);
      }
    }
    return V.fromPositions(kd.getPositionAfterDeleteLeft(r, t), r);
  }
  static getPositionAfterDeleteLeft(e, t) {
    if (e.column > 1) {
      const i = cre(e.column - 1, t.getLineContent(e.lineNumber));
      return e.with(void 0, i + 1);
    } else if (e.lineNumber > 1) {
      const i = e.lineNumber - 1;
      return new J(i, t.getLineMaxColumn(i));
    } else
      return e;
  }
  static cut(e, t, i) {
    let r = [];
    for (let o = 0, s = i.length; o < s; o++) {
      const a = i[o];
      if (a.isEmpty())
        if (e.emptySelectionClipboard) {
          let l = a.getPosition(), u, c, h, d;
          l.lineNumber < t.getLineCount() ? (u = l.lineNumber, c = 1, h = l.lineNumber + 1, d = 1) : l.lineNumber > 1 ? (u = l.lineNumber - 1, c = t.getLineMaxColumn(l.lineNumber - 1), h = l.lineNumber, d = t.getLineMaxColumn(l.lineNumber)) : (u = l.lineNumber, c = 1, h = l.lineNumber, d = t.getLineMaxColumn(l.lineNumber));
          let f = new V(u, c, h, d);
          f.isEmpty() ? r[o] = null : r[o] = new go(f, "");
        } else
          r[o] = null;
      else
        r[o] = new go(a, "");
    }
    return new po(0, r, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
}
class Ot {
  static _createWord(e, t, i, r, o) {
    return { start: r, end: o, wordType: t, nextCharClass: i };
  }
  static _findPreviousWordOnLine(e, t, i) {
    let r = t.getLineContent(i.lineNumber);
    return this._doFindPreviousWordOnLine(r, e, i);
  }
  static _doFindPreviousWordOnLine(e, t, i) {
    let r = 0;
    for (let o = i.column - 2; o >= 0; o--) {
      let s = e.charCodeAt(o), a = t.get(s);
      if (a === 0) {
        if (r === 2)
          return this._createWord(e, r, a, o + 1, this._findEndOfWord(e, t, r, o + 1));
        r = 1;
      } else if (a === 2) {
        if (r === 1)
          return this._createWord(e, r, a, o + 1, this._findEndOfWord(e, t, r, o + 1));
        r = 2;
      } else if (a === 1 && r !== 0)
        return this._createWord(e, r, a, o + 1, this._findEndOfWord(e, t, r, o + 1));
    }
    return r !== 0 ? this._createWord(e, r, 1, 0, this._findEndOfWord(e, t, r, 0)) : null;
  }
  static _findEndOfWord(e, t, i, r) {
    let o = e.length;
    for (let s = r; s < o; s++) {
      let a = e.charCodeAt(s), l = t.get(a);
      if (l === 1 || i === 1 && l === 2 || i === 2 && l === 0)
        return s;
    }
    return o;
  }
  static _findNextWordOnLine(e, t, i) {
    let r = t.getLineContent(i.lineNumber);
    return this._doFindNextWordOnLine(r, e, i);
  }
  static _doFindNextWordOnLine(e, t, i) {
    let r = 0, o = e.length;
    for (let s = i.column - 1; s < o; s++) {
      let a = e.charCodeAt(s), l = t.get(a);
      if (l === 0) {
        if (r === 2)
          return this._createWord(e, r, l, this._findStartOfWord(e, t, r, s - 1), s);
        r = 1;
      } else if (l === 2) {
        if (r === 1)
          return this._createWord(e, r, l, this._findStartOfWord(e, t, r, s - 1), s);
        r = 2;
      } else if (l === 1 && r !== 0)
        return this._createWord(e, r, l, this._findStartOfWord(e, t, r, s - 1), s);
    }
    return r !== 0 ? this._createWord(e, r, 1, this._findStartOfWord(e, t, r, o - 1), o) : null;
  }
  static _findStartOfWord(e, t, i, r) {
    for (let o = r; o >= 0; o--) {
      let s = e.charCodeAt(o), a = t.get(s);
      if (a === 1 || i === 1 && a === 2 || i === 2 && a === 0)
        return o + 1;
    }
    return 0;
  }
  static moveWordLeft(e, t, i, r) {
    let o = i.lineNumber, s = i.column;
    s === 1 && o > 1 && (o = o - 1, s = t.getLineMaxColumn(o));
    let a = Ot._findPreviousWordOnLine(e, t, new J(o, s));
    if (r === 0)
      return new J(o, a ? a.start + 1 : 1);
    if (r === 1)
      return a && a.wordType === 2 && a.end - a.start === 1 && a.nextCharClass === 0 && (a = Ot._findPreviousWordOnLine(e, t, new J(o, a.start + 1))), new J(o, a ? a.start + 1 : 1);
    if (r === 3) {
      for (; a && a.wordType === 2; )
        a = Ot._findPreviousWordOnLine(e, t, new J(o, a.start + 1));
      return new J(o, a ? a.start + 1 : 1);
    }
    return a && s <= a.end + 1 && (a = Ot._findPreviousWordOnLine(e, t, new J(o, a.start + 1))), new J(o, a ? a.end + 1 : 1);
  }
  static _moveWordPartLeft(e, t) {
    const i = t.lineNumber, r = e.getLineMaxColumn(i);
    if (t.column === 1)
      return i > 1 ? new J(i - 1, e.getLineMaxColumn(i - 1)) : t;
    const o = e.getLineContent(i);
    for (let s = t.column - 1; s > 1; s--) {
      const a = o.charCodeAt(s - 2), l = o.charCodeAt(s - 1);
      if (a === 95 && l !== 95)
        return new J(i, s);
      if (Jh(a) && Eu(l))
        return new J(i, s);
      if (Eu(a) && Eu(l) && s + 1 < r) {
        const u = o.charCodeAt(s);
        if (Jh(u))
          return new J(i, s);
      }
    }
    return new J(i, 1);
  }
  static moveWordRight(e, t, i, r) {
    let o = i.lineNumber, s = i.column, a = !1;
    s === t.getLineMaxColumn(o) && o < t.getLineCount() && (a = !0, o = o + 1, s = 1);
    let l = Ot._findNextWordOnLine(e, t, new J(o, s));
    if (r === 2)
      l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = Ot._findNextWordOnLine(e, t, new J(o, l.end + 1))), l ? s = l.end + 1 : s = t.getLineMaxColumn(o);
    else if (r === 3) {
      for (a && (s = 0); l && (l.wordType === 2 || l.start + 1 <= s); )
        l = Ot._findNextWordOnLine(e, t, new J(o, l.end + 1));
      l ? s = l.start + 1 : s = t.getLineMaxColumn(o);
    } else
      l && !a && s >= l.start + 1 && (l = Ot._findNextWordOnLine(e, t, new J(o, l.end + 1))), l ? s = l.start + 1 : s = t.getLineMaxColumn(o);
    return new J(o, s);
  }
  static _moveWordPartRight(e, t) {
    const i = t.lineNumber, r = e.getLineMaxColumn(i);
    if (t.column === r)
      return i < e.getLineCount() ? new J(i + 1, 1) : t;
    const o = e.getLineContent(i);
    for (let s = t.column + 1; s < r; s++) {
      const a = o.charCodeAt(s - 2), l = o.charCodeAt(s - 1);
      if (a !== 95 && l === 95)
        return new J(i, s);
      if (Jh(a) && Eu(l))
        return new J(i, s);
      if (Eu(a) && Eu(l) && s + 1 < r) {
        const u = o.charCodeAt(s);
        if (Jh(u))
          return new J(i, s);
      }
    }
    return new J(i, r);
  }
  static _deleteWordLeftWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), r = t.column - 2, o = wg(i, r);
    return o + 1 < r ? new V(t.lineNumber, o + 2, t.lineNumber, t.column) : null;
  }
  static deleteWordLeft(e, t) {
    const i = e.wordSeparators, r = e.model, o = e.selection, s = e.whitespaceHeuristics;
    if (!o.isEmpty())
      return o;
    if (kd.isAutoClosingPairDelete(e.autoClosingDelete, e.autoClosingBrackets, e.autoClosingQuotes, e.autoClosingPairs.autoClosingPairsOpenByEnd, e.model, [e.selection], e.autoClosedCharacters)) {
      const h = e.selection.getPosition();
      return new V(h.lineNumber, h.column - 1, h.lineNumber, h.column + 1);
    }
    const a = new J(o.positionLineNumber, o.positionColumn);
    let l = a.lineNumber, u = a.column;
    if (l === 1 && u === 1)
      return null;
    if (s) {
      let h = this._deleteWordLeftWhitespace(r, a);
      if (h)
        return h;
    }
    let c = Ot._findPreviousWordOnLine(i, r, a);
    return t === 0 ? c ? u = c.start + 1 : u > 1 ? u = 1 : (l--, u = r.getLineMaxColumn(l)) : (c && u <= c.end + 1 && (c = Ot._findPreviousWordOnLine(i, r, new J(l, c.start + 1))), c ? u = c.end + 1 : u > 1 ? u = 1 : (l--, u = r.getLineMaxColumn(l))), new V(l, u, a.lineNumber, a.column);
  }
  static deleteInsideWord(e, t, i) {
    if (!i.isEmpty())
      return i;
    const r = new J(i.positionLineNumber, i.positionColumn);
    let o = this._deleteInsideWordWhitespace(t, r);
    return o || this._deleteInsideWordDetermineDeleteRange(e, t, r);
  }
  static _charAtIsWhitespace(e, t) {
    const i = e.charCodeAt(t);
    return i === 32 || i === 9;
  }
  static _deleteInsideWordWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), r = i.length;
    if (r === 0)
      return null;
    let o = Math.max(t.column - 2, 0);
    if (!this._charAtIsWhitespace(i, o))
      return null;
    let s = Math.min(t.column - 1, r - 1);
    if (!this._charAtIsWhitespace(i, s))
      return null;
    for (; o > 0 && this._charAtIsWhitespace(i, o - 1); )
      o--;
    for (; s + 1 < r && this._charAtIsWhitespace(i, s + 1); )
      s++;
    return new V(t.lineNumber, o + 1, t.lineNumber, s + 2);
  }
  static _deleteInsideWordDetermineDeleteRange(e, t, i) {
    const r = t.getLineContent(i.lineNumber), o = r.length;
    if (o === 0)
      return i.lineNumber > 1 ? new V(i.lineNumber - 1, t.getLineMaxColumn(i.lineNumber - 1), i.lineNumber, 1) : i.lineNumber < t.getLineCount() ? new V(i.lineNumber, 1, i.lineNumber + 1, 1) : new V(i.lineNumber, 1, i.lineNumber, 1);
    const s = (h) => h.start + 1 <= i.column && i.column <= h.end + 1, a = (h, d) => (h = Math.min(h, i.column), d = Math.max(d, i.column), new V(i.lineNumber, h, i.lineNumber, d)), l = (h) => {
      let d = h.start + 1, f = h.end + 1, p = !1;
      for (; f - 1 < o && this._charAtIsWhitespace(r, f - 1); )
        p = !0, f++;
      if (!p)
        for (; d > 1 && this._charAtIsWhitespace(r, d - 2); )
          d--;
      return a(d, f);
    }, u = Ot._findPreviousWordOnLine(e, t, i);
    if (u && s(u))
      return l(u);
    const c = Ot._findNextWordOnLine(e, t, i);
    return c && s(c) ? l(c) : u && c ? a(u.end + 1, c.start + 1) : u ? a(u.start + 1, u.end + 1) : c ? a(c.start + 1, c.end + 1) : a(1, o + 1);
  }
  static _deleteWordPartLeft(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), r = Ot._moveWordPartLeft(e, i);
    return new V(i.lineNumber, i.column, r.lineNumber, r.column);
  }
  static _findFirstNonWhitespaceChar(e, t) {
    let i = e.length;
    for (let r = t; r < i; r++) {
      let o = e.charAt(r);
      if (o !== " " && o !== "	")
        return r;
    }
    return i;
  }
  static _deleteWordRightWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), r = t.column - 1, o = this._findFirstNonWhitespaceChar(i, r);
    return r + 1 < o ? new V(t.lineNumber, t.column, t.lineNumber, o + 1) : null;
  }
  static deleteWordRight(e, t) {
    const i = e.wordSeparators, r = e.model, o = e.selection, s = e.whitespaceHeuristics;
    if (!o.isEmpty())
      return o;
    const a = new J(o.positionLineNumber, o.positionColumn);
    let l = a.lineNumber, u = a.column;
    const c = r.getLineCount(), h = r.getLineMaxColumn(l);
    if (l === c && u === h)
      return null;
    if (s) {
      let f = this._deleteWordRightWhitespace(r, a);
      if (f)
        return f;
    }
    let d = Ot._findNextWordOnLine(i, r, a);
    return t === 2 ? d ? u = d.end + 1 : u < h || l === c ? u = h : (l++, d = Ot._findNextWordOnLine(i, r, new J(l, 1)), d ? u = d.start + 1 : u = r.getLineMaxColumn(l)) : (d && u >= d.start + 1 && (d = Ot._findNextWordOnLine(i, r, new J(l, d.end + 1))), d ? u = d.start + 1 : u < h || l === c ? u = h : (l++, d = Ot._findNextWordOnLine(i, r, new J(l, 1)), d ? u = d.start + 1 : u = r.getLineMaxColumn(l))), new V(l, u, a.lineNumber, a.column);
  }
  static _deleteWordPartRight(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), r = Ot._moveWordPartRight(e, i);
    return new V(i.lineNumber, i.column, r.lineNumber, r.column);
  }
  static _createWordAtPosition(e, t, i) {
    const r = new V(t, i.start + 1, t, i.end + 1);
    return {
      word: e.getValueInRange(r),
      startColumn: r.startColumn,
      endColumn: r.endColumn
    };
  }
  static getWordAtPosition(e, t, i) {
    const r = jp(t), o = Ot._findPreviousWordOnLine(r, e, i);
    if (o && o.wordType === 1 && o.start <= i.column - 1 && i.column - 1 <= o.end)
      return Ot._createWordAtPosition(e, i.lineNumber, o);
    const s = Ot._findNextWordOnLine(r, e, i);
    return s && s.wordType === 1 && s.start <= i.column - 1 && i.column - 1 <= s.end ? Ot._createWordAtPosition(e, i.lineNumber, s) : null;
  }
  static word(e, t, i, r, o) {
    const s = jp(e.wordSeparators);
    let a = Ot._findPreviousWordOnLine(s, t, o), l = Ot._findNextWordOnLine(s, t, o);
    if (!r) {
      let f, p;
      return a && a.wordType === 1 && a.start <= o.column - 1 && o.column - 1 <= a.end ? (f = a.start + 1, p = a.end + 1) : l && l.wordType === 1 && l.start <= o.column - 1 && o.column - 1 <= l.end ? (f = l.start + 1, p = l.end + 1) : (a ? f = a.end + 1 : f = 1, l ? p = l.start + 1 : p = t.getLineMaxColumn(o.lineNumber)), new $n(new V(o.lineNumber, f, o.lineNumber, p), 0, new J(o.lineNumber, p), 0);
    }
    let u, c;
    a && a.wordType === 1 && a.start < o.column - 1 && o.column - 1 < a.end ? (u = a.start + 1, c = a.end + 1) : l && l.wordType === 1 && l.start < o.column - 1 && o.column - 1 < l.end ? (u = l.start + 1, c = l.end + 1) : (u = o.column, c = o.column);
    let h = o.lineNumber, d;
    if (i.selectionStart.containsPosition(o))
      d = i.selectionStart.endColumn;
    else if (o.isBeforeOrEqual(i.selectionStart.getStartPosition())) {
      d = u;
      let f = new J(h, d);
      i.selectionStart.containsPosition(f) && (d = i.selectionStart.endColumn);
    } else {
      d = c;
      let f = new J(h, d);
      i.selectionStart.containsPosition(f) && (d = i.selectionStart.startColumn);
    }
    return i.move(!0, h, d, 0);
  }
}
class Nye extends Ot {
  static deleteWordPartLeft(e) {
    const t = by([
      Ot.deleteWordLeft(
        e,
        0
        /* WordStart */
      ),
      Ot.deleteWordLeft(
        e,
        2
        /* WordEnd */
      ),
      Ot._deleteWordPartLeft(e.model, e.selection)
    ]);
    return t.sort(V.compareRangesUsingEnds), t[2];
  }
  static deleteWordPartRight(e) {
    const t = by([
      Ot.deleteWordRight(
        e,
        0
        /* WordStart */
      ),
      Ot.deleteWordRight(
        e,
        2
        /* WordEnd */
      ),
      Ot._deleteWordPartRight(e.model, e.selection)
    ]);
    return t.sort(V.compareRangesUsingStarts), t[0];
  }
  static moveWordPartLeft(e, t, i) {
    const r = by([
      Ot.moveWordLeft(
        e,
        t,
        i,
        0
        /* WordStart */
      ),
      Ot.moveWordLeft(
        e,
        t,
        i,
        2
        /* WordEnd */
      ),
      Ot._moveWordPartLeft(t, i)
    ]);
    return r.sort(J.compare), r[2];
  }
  static moveWordPartRight(e, t, i) {
    const r = by([
      Ot.moveWordRight(
        e,
        t,
        i,
        0
        /* WordStart */
      ),
      Ot.moveWordRight(
        e,
        t,
        i,
        2
        /* WordEnd */
      ),
      Ot._moveWordPartRight(t, i)
    ]);
    return r.sort(J.compare), r[0];
  }
}
function by(n) {
  return n.filter((e) => !!e);
}
class rr {
  static addCursorDown(e, t, i) {
    let r = [], o = 0;
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      r[o++] = new st(l.modelState, l.viewState), i ? r[o++] = st.fromModelState(At.translateDown(e.cursorConfig, e.model, l.modelState)) : r[o++] = st.fromViewState(At.translateDown(e.cursorConfig, e, l.viewState));
    }
    return r;
  }
  static addCursorUp(e, t, i) {
    let r = [], o = 0;
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      r[o++] = new st(l.modelState, l.viewState), i ? r[o++] = st.fromModelState(At.translateUp(e.cursorConfig, e.model, l.modelState)) : r[o++] = st.fromViewState(At.translateUp(e.cursorConfig, e, l.viewState));
    }
    return r;
  }
  static moveToBeginningOfLine(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o];
      r[o] = this._moveToLineStart(e, a, i);
    }
    return r;
  }
  static _moveToLineStart(e, t, i) {
    const r = t.viewState.position.column, o = t.modelState.position.column, s = r === o, a = t.viewState.position.lineNumber, l = e.getLineFirstNonWhitespaceColumn(a);
    return !s && !(r === l) ? this._moveToLineStartByView(e, t, i) : this._moveToLineStartByModel(e, t, i);
  }
  static _moveToLineStartByView(e, t, i) {
    return st.fromViewState(At.moveToBeginningOfLine(e.cursorConfig, e, t.viewState, i));
  }
  static _moveToLineStartByModel(e, t, i) {
    return st.fromModelState(At.moveToBeginningOfLine(e.cursorConfig, e.model, t.modelState, i));
  }
  static moveToEndOfLine(e, t, i, r) {
    let o = [];
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      o[s] = this._moveToLineEnd(e, l, i, r);
    }
    return o;
  }
  static _moveToLineEnd(e, t, i, r) {
    const o = t.viewState.position, s = e.getLineMaxColumn(o.lineNumber), a = o.column === s, l = t.modelState.position, u = e.model.getLineMaxColumn(l.lineNumber), c = s - o.column === u - l.column;
    return a || c ? this._moveToLineEndByModel(e, t, i, r) : this._moveToLineEndByView(e, t, i, r);
  }
  static _moveToLineEndByView(e, t, i, r) {
    return st.fromViewState(At.moveToEndOfLine(e.cursorConfig, e, t.viewState, i, r));
  }
  static _moveToLineEndByModel(e, t, i, r) {
    return st.fromModelState(At.moveToEndOfLine(e.cursorConfig, e.model, t.modelState, i, r));
  }
  static expandLineSelection(e, t) {
    let i = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const s = t[r], a = s.modelState.selection.startLineNumber, l = e.model.getLineCount();
      let u = s.modelState.selection.endLineNumber, c;
      u === l ? c = e.model.getLineMaxColumn(l) : (u++, c = 1), i[r] = st.fromModelState(new $n(new V(a, 1, a, 1), 0, new J(u, c), 0));
    }
    return i;
  }
  static moveToBeginningOfBuffer(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o];
      r[o] = st.fromModelState(At.moveToBeginningOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return r;
  }
  static moveToEndOfBuffer(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o];
      r[o] = st.fromModelState(At.moveToEndOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return r;
  }
  static selectAll(e, t) {
    const i = e.model.getLineCount(), r = e.model.getLineMaxColumn(i);
    return st.fromModelState(new $n(new V(1, 1, 1, 1), 0, new J(i, r), 0));
  }
  static line(e, t, i, r, o) {
    const s = e.model.validatePosition(r), a = o ? e.coordinatesConverter.validateViewPosition(new J(o.lineNumber, o.column), s) : e.coordinatesConverter.convertModelPositionToViewPosition(s);
    if (!i || !t.modelState.hasSelection()) {
      const u = e.model.getLineCount();
      let c = s.lineNumber + 1, h = 1;
      return c > u && (c = u, h = e.model.getLineMaxColumn(c)), st.fromModelState(new $n(new V(s.lineNumber, 1, c, h), 0, new J(c, h), 0));
    }
    const l = t.modelState.selectionStart.getStartPosition().lineNumber;
    if (s.lineNumber < l)
      return st.fromViewState(t.viewState.move(t.modelState.hasSelection(), a.lineNumber, 1, 0));
    if (s.lineNumber > l) {
      const u = e.getLineCount();
      let c = a.lineNumber + 1, h = 1;
      return c > u && (c = u, h = e.getLineMaxColumn(c)), st.fromViewState(t.viewState.move(t.modelState.hasSelection(), c, h, 0));
    } else {
      const u = t.modelState.selectionStart.getEndPosition();
      return st.fromModelState(t.modelState.move(t.modelState.hasSelection(), u.lineNumber, u.column, 0));
    }
  }
  static word(e, t, i, r) {
    const o = e.model.validatePosition(r);
    return st.fromModelState(Ot.word(e.cursorConfig, e.model, t.modelState, i, o));
  }
  static cancelSelection(e, t) {
    if (!t.modelState.hasSelection())
      return new st(t.modelState, t.viewState);
    const i = t.viewState.position.lineNumber, r = t.viewState.position.column;
    return st.fromViewState(new $n(new V(i, r, i, r), 0, new J(i, r), 0));
  }
  static moveTo(e, t, i, r, o) {
    const s = e.model.validatePosition(r), a = o ? e.coordinatesConverter.validateViewPosition(new J(o.lineNumber, o.column), s) : e.coordinatesConverter.convertModelPositionToViewPosition(s);
    return st.fromViewState(t.viewState.move(i, a.lineNumber, a.column, 0));
  }
  static simpleMove(e, t, i, r, o, s) {
    switch (i) {
      case 0:
        return s === 4 ? this._moveHalfLineLeft(e, t, r) : this._moveLeft(e, t, r, o);
      case 1:
        return s === 4 ? this._moveHalfLineRight(e, t, r) : this._moveRight(e, t, r, o);
      case 2:
        return s === 2 ? this._moveUpByViewLines(e, t, r, o) : this._moveUpByModelLines(e, t, r, o);
      case 3:
        return s === 2 ? this._moveDownByViewLines(e, t, r, o) : this._moveDownByModelLines(e, t, r, o);
      case 4:
        return s === 2 ? t.map((a) => st.fromViewState(At.moveToPrevBlankLine(e.cursorConfig, e, a.viewState, r))) : t.map((a) => st.fromModelState(At.moveToPrevBlankLine(e.cursorConfig, e.model, a.modelState, r)));
      case 5:
        return s === 2 ? t.map((a) => st.fromViewState(At.moveToNextBlankLine(e.cursorConfig, e, a.viewState, r))) : t.map((a) => st.fromModelState(At.moveToNextBlankLine(e.cursorConfig, e.model, a.modelState, r)));
      case 6:
        return this._moveToViewMinColumn(e, t, r);
      case 7:
        return this._moveToViewFirstNonWhitespaceColumn(e, t, r);
      case 8:
        return this._moveToViewCenterColumn(e, t, r);
      case 9:
        return this._moveToViewMaxColumn(e, t, r);
      case 10:
        return this._moveToViewLastNonWhitespaceColumn(e, t, r);
      default:
        return null;
    }
  }
  static viewportMove(e, t, i, r, o) {
    const s = e.getCompletelyVisibleViewRange(), a = e.coordinatesConverter.convertViewRangeToModelRange(s);
    switch (i) {
      case 11: {
        const l = this._firstLineNumberInRange(e.model, a, o), u = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], r, l, u)];
      }
      case 13: {
        const l = this._lastLineNumberInRange(e.model, a, o), u = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], r, l, u)];
      }
      case 12: {
        const l = Math.round((a.startLineNumber + a.endLineNumber) / 2), u = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], r, l, u)];
      }
      case 14: {
        let l = [];
        for (let u = 0, c = t.length; u < c; u++) {
          const h = t[u];
          l[u] = this.findPositionInViewportIfOutside(e, h, s, r);
        }
        return l;
      }
      default:
        return null;
    }
  }
  static findPositionInViewportIfOutside(e, t, i, r) {
    let o = t.viewState.position.lineNumber;
    if (i.startLineNumber <= o && o <= i.endLineNumber - 1)
      return new st(t.modelState, t.viewState);
    {
      o > i.endLineNumber - 1 && (o = i.endLineNumber - 1), o < i.startLineNumber && (o = i.startLineNumber);
      const s = e.getLineFirstNonWhitespaceColumn(o);
      return this._moveToViewPosition(e, t, r, o, s);
    }
  }
  /**
   * Find the nth line start included in the range (from the start).
   */
  static _firstLineNumberInRange(e, t, i) {
    let r = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(r) && r++, Math.min(t.endLineNumber, r + i - 1);
  }
  /**
   * Find the nth line start included in the range (from the end).
   */
  static _lastLineNumberInRange(e, t, i) {
    let r = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(r) && r++, Math.max(r, t.endLineNumber - i + 1);
  }
  static _moveLeft(e, t, i, r) {
    return t.map((o) => st.fromViewState(At.moveLeft(e.cursorConfig, e, o.viewState, i, r)));
  }
  static _moveHalfLineLeft(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = Math.round(e.getLineContent(l).length / 2);
      r[o] = st.fromViewState(At.moveLeft(e.cursorConfig, e, a.viewState, i, u));
    }
    return r;
  }
  static _moveRight(e, t, i, r) {
    return t.map((o) => st.fromViewState(At.moveRight(e.cursorConfig, e, o.viewState, i, r)));
  }
  static _moveHalfLineRight(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = Math.round(e.getLineContent(l).length / 2);
      r[o] = st.fromViewState(At.moveRight(e.cursorConfig, e, a.viewState, i, u));
    }
    return r;
  }
  static _moveDownByViewLines(e, t, i, r) {
    let o = [];
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      o[s] = st.fromViewState(At.moveDown(e.cursorConfig, e, l.viewState, i, r));
    }
    return o;
  }
  static _moveDownByModelLines(e, t, i, r) {
    let o = [];
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      o[s] = st.fromModelState(At.moveDown(e.cursorConfig, e.model, l.modelState, i, r));
    }
    return o;
  }
  static _moveUpByViewLines(e, t, i, r) {
    let o = [];
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      o[s] = st.fromViewState(At.moveUp(e.cursorConfig, e, l.viewState, i, r));
    }
    return o;
  }
  static _moveUpByModelLines(e, t, i, r) {
    let o = [];
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      o[s] = st.fromModelState(At.moveUp(e.cursorConfig, e.model, l.modelState, i, r));
    }
    return o;
  }
  static _moveToViewPosition(e, t, i, r, o) {
    return st.fromViewState(t.viewState.move(i, r, o, 0));
  }
  static _moveToModelPosition(e, t, i, r, o) {
    return st.fromModelState(t.modelState.move(i, r, o, 0));
  }
  static _moveToViewMinColumn(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineMinColumn(l);
      r[o] = this._moveToViewPosition(e, a, i, l, u);
    }
    return r;
  }
  static _moveToViewFirstNonWhitespaceColumn(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineFirstNonWhitespaceColumn(l);
      r[o] = this._moveToViewPosition(e, a, i, l, u);
    }
    return r;
  }
  static _moveToViewCenterColumn(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = Math.round((e.getLineMaxColumn(l) + e.getLineMinColumn(l)) / 2);
      r[o] = this._moveToViewPosition(e, a, i, l, u);
    }
    return r;
  }
  static _moveToViewMaxColumn(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineMaxColumn(l);
      r[o] = this._moveToViewPosition(e, a, i, l, u);
    }
    return r;
  }
  static _moveToViewLastNonWhitespaceColumn(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineLastNonWhitespaceColumn(l);
      r[o] = this._moveToViewPosition(e, a, i, l, u);
    }
    return r;
  }
}
var kb;
(function(n) {
  const e = function(i) {
    if (!Bo(i))
      return !1;
    let r = i;
    return !(!Za(r.to) || !Ls(r.select) && !GG(r.select) || !Ls(r.by) && !Za(r.by) || !Ls(r.value) && !V_(r.value));
  };
  n.description = {
    description: "Move cursor to a logical position in the view",
    args: [
      {
        name: "Cursor move argument object",
        description: `Property-value pairs that can be passed through this argument:
					* 'to': A mandatory logical position value providing where to move the cursor.
						\`\`\`
						'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',
						'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
						'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
						'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'character', 'halfLine'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'select': If 'true' makes the selection. Default is 'false'.
				`,
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["left", "right", "up", "down", "prevBlankLine", "nextBlankLine", "wrappedLineStart", "wrappedLineEnd", "wrappedLineColumnCenter", "wrappedLineFirstNonWhitespaceCharacter", "wrappedLineLastNonWhitespaceCharacter", "viewPortTop", "viewPortCenter", "viewPortBottom", "viewPortIfOutside"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "character", "halfLine"]
            },
            value: {
              type: "number",
              default: 1
            },
            select: {
              type: "boolean",
              default: !1
            }
          }
        }
      }
    ]
  }, n.RawDirection = {
    Left: "left",
    Right: "right",
    Up: "up",
    Down: "down",
    PrevBlankLine: "prevBlankLine",
    NextBlankLine: "nextBlankLine",
    WrappedLineStart: "wrappedLineStart",
    WrappedLineFirstNonWhitespaceCharacter: "wrappedLineFirstNonWhitespaceCharacter",
    WrappedLineColumnCenter: "wrappedLineColumnCenter",
    WrappedLineEnd: "wrappedLineEnd",
    WrappedLineLastNonWhitespaceCharacter: "wrappedLineLastNonWhitespaceCharacter",
    ViewPortTop: "viewPortTop",
    ViewPortCenter: "viewPortCenter",
    ViewPortBottom: "viewPortBottom",
    ViewPortIfOutside: "viewPortIfOutside"
  }, n.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Character: "character",
    HalfLine: "halfLine"
  };
  function t(i) {
    if (!i.to)
      return null;
    let r;
    switch (i.to) {
      case n.RawDirection.Left:
        r = 0;
        break;
      case n.RawDirection.Right:
        r = 1;
        break;
      case n.RawDirection.Up:
        r = 2;
        break;
      case n.RawDirection.Down:
        r = 3;
        break;
      case n.RawDirection.PrevBlankLine:
        r = 4;
        break;
      case n.RawDirection.NextBlankLine:
        r = 5;
        break;
      case n.RawDirection.WrappedLineStart:
        r = 6;
        break;
      case n.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
        r = 7;
        break;
      case n.RawDirection.WrappedLineColumnCenter:
        r = 8;
        break;
      case n.RawDirection.WrappedLineEnd:
        r = 9;
        break;
      case n.RawDirection.WrappedLineLastNonWhitespaceCharacter:
        r = 10;
        break;
      case n.RawDirection.ViewPortTop:
        r = 11;
        break;
      case n.RawDirection.ViewPortBottom:
        r = 13;
        break;
      case n.RawDirection.ViewPortCenter:
        r = 12;
        break;
      case n.RawDirection.ViewPortIfOutside:
        r = 14;
        break;
      default:
        return null;
    }
    let o = 0;
    switch (i.by) {
      case n.RawUnit.Line:
        o = 1;
        break;
      case n.RawUnit.WrappedLine:
        o = 2;
        break;
      case n.RawUnit.Character:
        o = 3;
        break;
      case n.RawUnit.HalfLine:
        o = 4;
        break;
    }
    return {
      direction: r,
      unit: o,
      select: !!i.select,
      value: i.value || 1
    };
  }
  n.parse = t;
})(kb || (kb = {}));
const DD = /* @__PURE__ */ Object.create(null);
function Ph(n, e) {
  if (e <= 0)
    return "";
  DD[n] || (DD[n] = ["", n]);
  const t = DD[n];
  for (let i = t.length; i <= e; i++)
    t[i] = t[i - 1] + n;
  return t[e];
}
class Fc {
  constructor(e, t) {
    this._opts = t, this._selection = e, this._selectionId = null, this._useLastEditRangeForCursorEndPosition = !1, this._selectionStartColumnStaysPut = !1;
  }
  static unshiftIndent(e, t, i, r, o) {
    const s = Kt.visibleColumnFromColumn(e, t, i);
    if (o) {
      const a = Ph(" ", r), u = Kt.prevIndentTabStop(s, r) / r;
      return Ph(a, u);
    } else {
      const a = "	", u = Kt.prevRenderTabStop(s, i) / i;
      return Ph(a, u);
    }
  }
  static shiftIndent(e, t, i, r, o) {
    const s = Kt.visibleColumnFromColumn(e, t, i);
    if (o) {
      const a = Ph(" ", r), u = Kt.nextIndentTabStop(s, r) / r;
      return Ph(a, u);
    } else {
      const a = "	", u = Kt.nextRenderTabStop(s, i) / i;
      return Ph(a, u);
    }
  }
  _addEditOperation(e, t, i) {
    this._useLastEditRangeForCursorEndPosition ? e.addTrackedEditOperation(t, i) : e.addEditOperation(t, i);
  }
  getEditOperations(e, t) {
    const i = this._selection.startLineNumber;
    let r = this._selection.endLineNumber;
    this._selection.endColumn === 1 && i !== r && (r = r - 1);
    const { tabSize: o, indentSize: s, insertSpaces: a } = this._opts, l = i === r;
    if (this._opts.useTabStops) {
      this._selection.isEmpty() && /^\s*$/.test(e.getLineContent(i)) && (this._useLastEditRangeForCursorEndPosition = !0);
      let u = 0, c = 0;
      for (let h = i; h <= r; h++, u = c) {
        c = 0;
        let d = e.getLineContent(h), f = Es(d);
        if (this._opts.isUnshift && (d.length === 0 || f === 0) || !l && !this._opts.isUnshift && d.length === 0)
          continue;
        if (f === -1 && (f = d.length), h > 1 && Kt.visibleColumnFromColumn(d, f + 1, o) % s !== 0 && e.isCheapToTokenize(h - 1)) {
          let _ = ui.getEnterAction(this._opts.autoIndent, e, new V(h - 1, e.getLineMaxColumn(h - 1), h - 1, e.getLineMaxColumn(h - 1)));
          if (_) {
            if (c = u, _.appendText)
              for (let m = 0, v = _.appendText.length; m < v && c < s && _.appendText.charCodeAt(m) === 32; m++)
                c++;
            _.removeText && (c = Math.max(0, c - _.removeText));
            for (let m = 0; m < c && !(f === 0 || d.charCodeAt(f - 1) !== 32); m++)
              f--;
          }
        }
        if (this._opts.isUnshift && f === 0)
          continue;
        let p;
        this._opts.isUnshift ? p = Fc.unshiftIndent(d, f + 1, o, s, a) : p = Fc.shiftIndent(d, f + 1, o, s, a), this._addEditOperation(t, new V(h, 1, h, f + 1), p), h === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn <= f + 1);
      }
    } else {
      !this._opts.isUnshift && this._selection.isEmpty() && e.getLineLength(i) === 0 && (this._useLastEditRangeForCursorEndPosition = !0);
      const u = a ? Ph(" ", s) : "	";
      for (let c = i; c <= r; c++) {
        const h = e.getLineContent(c);
        let d = Es(h);
        if (!(this._opts.isUnshift && (h.length === 0 || d === 0)) && !(!l && !this._opts.isUnshift && h.length === 0) && (d === -1 && (d = h.length), !(this._opts.isUnshift && d === 0)))
          if (this._opts.isUnshift) {
            d = Math.min(d, s);
            for (let f = 0; f < d; f++)
              if (h.charCodeAt(f) === 9) {
                d = f + 1;
                break;
              }
            this._addEditOperation(t, new V(c, 1, c, d + 1), "");
          } else
            this._addEditOperation(t, new V(c, 1, c, 1), u), c === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn === 1);
      }
    }
    this._selectionId = t.trackSelection(this._selection);
  }
  computeCursorState(e, t) {
    if (this._useLastEditRangeForCursorEndPosition) {
      let r = t.getInverseEditOperations()[0];
      return new Ut(r.range.endLineNumber, r.range.endColumn, r.range.endLineNumber, r.range.endColumn);
    }
    const i = t.getTrackedSelection(this._selectionId);
    if (this._selectionStartColumnStaysPut) {
      let r = this._selection.startColumn;
      return i.startColumn <= r ? i : i.getDirection() === 0 ? new Ut(i.startLineNumber, r, i.endLineNumber, i.endColumn) : new Ut(i.endLineNumber, i.endColumn, i.startLineNumber, r);
    }
    return i;
  }
}
class $ce {
  constructor(e, t, i) {
    this._range = e, this._charBeforeSelection = t, this._charAfterSelection = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new V(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection), t.addTrackedEditOperation(new V(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
  }
  computeCursorState(e, t) {
    let i = t.getInverseEditOperations(), r = i[0].range, o = i[1].range;
    return new Ut(r.endLineNumber, r.endColumn, o.endLineNumber, o.endColumn - this._charAfterSelection.length);
  }
}
class ki {
  static indent(e, t, i) {
    if (t === null || i === null)
      return [];
    let r = [];
    for (let o = 0, s = i.length; o < s; o++)
      r[o] = new Fc(i[o], {
        isUnshift: !1,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      });
    return r;
  }
  static outdent(e, t, i) {
    let r = [];
    for (let o = 0, s = i.length; o < s; o++)
      r[o] = new Fc(i[o], {
        isUnshift: !0,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      });
    return r;
  }
  static shiftIndent(e, t, i) {
    return i = i || 1, Fc.shiftIndent(t, t.length + i, e.tabSize, e.indentSize, e.insertSpaces);
  }
  static unshiftIndent(e, t, i) {
    return i = i || 1, Fc.unshiftIndent(t, t.length + i, e.tabSize, e.indentSize, e.insertSpaces);
  }
  static _distributedPaste(e, t, i, r) {
    let o = [];
    for (let s = 0, a = i.length; s < a; s++)
      o[s] = new go(i[s], r[s]);
    return new po(0, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _simplePaste(e, t, i, r, o) {
    let s = [];
    for (let a = 0, l = i.length; a < l; a++) {
      const u = i[a];
      let c = u.getPosition();
      if (o && !u.isEmpty() && (o = !1), o && r.indexOf(`
`) !== r.length - 1 && (o = !1), o) {
        let h = new V(c.lineNumber, 1, c.lineNumber, 1);
        s[a] = new jce(h, r, u, !0);
      } else
        s[a] = new go(u, r);
    }
    return new po(0, s, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _distributePasteToCursors(e, t, i, r, o) {
    if (r || t.length === 1)
      return null;
    if (o && o.length === t.length)
      return o;
    if (e.multiCursorPaste === "spread") {
      i.charCodeAt(i.length - 1) === 10 && (i = i.substr(0, i.length - 1)), i.charCodeAt(i.length - 1) === 13 && (i = i.substr(0, i.length - 1));
      let s = W_(i);
      if (s.length === t.length)
        return s;
    }
    return null;
  }
  static paste(e, t, i, r, o, s) {
    const a = this._distributePasteToCursors(e, i, r, o, s);
    return a ? (i = i.sort(V.compareRangesUsingStarts), this._distributedPaste(e, t, i, a)) : this._simplePaste(e, t, i, r, o);
  }
  static _goodIndentForLine(e, t, i) {
    let r = null, o = "";
    const s = ui.getInheritIndentForLine(e.autoIndent, t, i, !1);
    if (s)
      r = s.action, o = s.indentation;
    else if (i > 1) {
      let a;
      for (a = i - 1; a >= 1; a--) {
        const c = t.getLineContent(a);
        if (wg(c) >= 0)
          break;
      }
      if (a < 1)
        return null;
      const l = t.getLineMaxColumn(a), u = ui.getEnterAction(e.autoIndent, t, new V(a, l, a, l));
      u && (o = u.indentation + u.appendText);
    }
    return r && (r === Ln.Indent && (o = ki.shiftIndent(e, o)), r === Ln.Outdent && (o = ki.unshiftIndent(e, o)), o = e.normalizeIndentation(o)), o || null;
  }
  static _replaceJumpToNextIndent(e, t, i, r) {
    let o = "", s = i.getStartPosition();
    if (e.insertSpaces) {
      let a = Kt.visibleColumnFromColumn2(e, t, s), l = e.indentSize, u = l - a % l;
      for (let c = 0; c < u; c++)
        o += " ";
    } else
      o = "	";
    return new go(i, o, r);
  }
  static tab(e, t, i) {
    let r = [];
    for (let o = 0, s = i.length; o < s; o++) {
      const a = i[o];
      if (a.isEmpty()) {
        let l = t.getLineContent(a.startLineNumber);
        if (/^\s*$/.test(l) && t.isCheapToTokenize(a.startLineNumber)) {
          let u = this._goodIndentForLine(e, t, a.startLineNumber);
          u = u || "	";
          let c = e.normalizeIndentation(u);
          if (!l.startsWith(c)) {
            r[o] = new go(new V(a.startLineNumber, 1, a.startLineNumber, l.length + 1), c, !0);
            continue;
          }
        }
        r[o] = this._replaceJumpToNextIndent(e, t, a, !0);
      } else {
        if (a.startLineNumber === a.endLineNumber) {
          let l = t.getLineMaxColumn(a.startLineNumber);
          if (a.startColumn !== 1 || a.endColumn !== l) {
            r[o] = this._replaceJumpToNextIndent(e, t, a, !1);
            continue;
          }
        }
        r[o] = new Fc(a, {
          isUnshift: !1,
          tabSize: e.tabSize,
          indentSize: e.indentSize,
          insertSpaces: e.insertSpaces,
          useTabStops: e.useTabStops,
          autoIndent: e.autoIndent
        });
      }
    }
    return r;
  }
  static compositionType(e, t, i, r, o, s, a, l) {
    const u = r.map((c) => this._compositionType(i, c, o, s, a, l));
    return new po(4, u, {
      shouldPushStackElementBefore: Sy(
        e,
        4
        /* TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
  static _compositionType(e, t, i, r, o, s) {
    if (!t.isEmpty())
      return null;
    const a = t.getPosition(), l = Math.max(1, a.column - r), u = Math.min(e.getLineMaxColumn(a.lineNumber), a.column + o), c = new V(a.lineNumber, l, a.lineNumber, u);
    return e.getValueInRange(c) === i && s === 0 ? null : new cw(c, i, 0, s);
  }
  static _typeCommand(e, t, i) {
    return i ? new yy(e, t, !0) : new go(e, t, !0);
  }
  static _enter(e, t, i, r) {
    if (e.autoIndent === 0)
      return ki._typeCommand(r, `
`, i);
    if (!t.isCheapToTokenize(r.getStartPosition().lineNumber) || e.autoIndent === 1) {
      let l = t.getLineContent(r.startLineNumber), u = Pr(l).substring(0, r.startColumn - 1);
      return ki._typeCommand(r, `
` + e.normalizeIndentation(u), i);
    }
    const o = ui.getEnterAction(e.autoIndent, t, r);
    if (o) {
      if (o.indentAction === Ln.None)
        return ki._typeCommand(r, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
      if (o.indentAction === Ln.Indent)
        return ki._typeCommand(r, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
      if (o.indentAction === Ln.IndentOutdent) {
        const l = e.normalizeIndentation(o.indentation), u = e.normalizeIndentation(o.indentation + o.appendText), c = `
` + u + `
` + l;
        return i ? new yy(r, c, !0) : new cw(r, c, -1, u.length - l.length, !0);
      } else if (o.indentAction === Ln.Outdent) {
        const l = ki.unshiftIndent(e, o.indentation);
        return ki._typeCommand(r, `
` + e.normalizeIndentation(l + o.appendText), i);
      }
    }
    const s = t.getLineContent(r.startLineNumber), a = Pr(s).substring(0, r.startColumn - 1);
    if (e.autoIndent >= 4) {
      const l = ui.getIndentForEnter(e.autoIndent, t, r, {
        unshiftIndent: (u) => ki.unshiftIndent(e, u),
        shiftIndent: (u) => ki.shiftIndent(e, u),
        normalizeIndentation: (u) => e.normalizeIndentation(u)
      });
      if (l) {
        let u = Kt.visibleColumnFromColumn2(e, t, r.getEndPosition());
        const c = r.endColumn, h = t.getLineContent(r.endLineNumber), d = Es(h);
        if (d >= 0 ? r = r.setEndPosition(r.endLineNumber, Math.max(r.endColumn, d + 1)) : r = r.setEndPosition(r.endLineNumber, t.getLineMaxColumn(r.endLineNumber)), i)
          return new yy(r, `
` + e.normalizeIndentation(l.afterEnter), !0);
        {
          let f = 0;
          return c <= d + 1 && (e.insertSpaces || (u = Math.ceil(u / e.indentSize)), f = Math.min(u + 1 - e.normalizeIndentation(l.afterEnter).length - 1, 0)), new cw(r, `
` + e.normalizeIndentation(l.afterEnter), 0, f, !0);
        }
      }
    }
    return ki._typeCommand(r, `
` + e.normalizeIndentation(a), i);
  }
  static _isAutoIndentType(e, t, i) {
    if (e.autoIndent < 4)
      return !1;
    for (let r = 0, o = i.length; r < o; r++)
      if (!t.isCheapToTokenize(i[r].getEndPosition().lineNumber))
        return !1;
    return !0;
  }
  static _runAutoIndentType(e, t, i, r) {
    const o = ui.getIndentationAtPosition(t, i.startLineNumber, i.startColumn), s = ui.getIndentActionForType(e.autoIndent, t, i, r, {
      shiftIndent: (a) => ki.shiftIndent(e, a),
      unshiftIndent: (a) => ki.unshiftIndent(e, a)
    });
    if (s === null)
      return null;
    if (s !== e.normalizeIndentation(o)) {
      const a = t.getLineFirstNonWhitespaceColumn(i.startLineNumber);
      return a === 0 ? ki._typeCommand(new V(i.startLineNumber, 1, i.endLineNumber, i.endColumn), e.normalizeIndentation(s) + r, !1) : ki._typeCommand(new V(i.startLineNumber, 1, i.endLineNumber, i.endColumn), e.normalizeIndentation(s) + t.getLineContent(i.startLineNumber).substring(a - 1, i.startColumn - 1) + r, !1);
    }
    return null;
  }
  static _isAutoClosingOvertype(e, t, i, r, o) {
    if (e.autoClosingOvertype === "never" || !e.autoClosingPairs.autoClosingPairsCloseSingleChar.has(o))
      return !1;
    for (let s = 0, a = i.length; s < a; s++) {
      const l = i[s];
      if (!l.isEmpty())
        return !1;
      const u = l.getPosition(), c = t.getLineContent(u.lineNumber);
      if (c.charAt(u.column - 1) !== o)
        return !1;
      const d = kf(o);
      if ((u.column > 2 ? c.charCodeAt(u.column - 2) : 0) === 92 && d)
        return !1;
      if (e.autoClosingOvertype === "auto") {
        let p = !1;
        for (let g = 0, _ = r.length; g < _; g++) {
          const m = r[g];
          if (u.lineNumber === m.startLineNumber && u.column === m.startColumn) {
            p = !0;
            break;
          }
        }
        if (!p)
          return !1;
      }
    }
    return !0;
  }
  static _runAutoClosingOvertype(e, t, i, r, o) {
    let s = [];
    for (let a = 0, l = r.length; a < l; a++) {
      const c = r[a].getPosition(), h = new V(c.lineNumber, c.column, c.lineNumber, c.column + 1);
      s[a] = new go(h, o);
    }
    return new po(4, s, {
      shouldPushStackElementBefore: Sy(
        e,
        4
        /* TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
  static _isBeforeClosingBrace(e, t) {
    const i = t.charAt(0), r = e.autoClosingPairs.autoClosingPairsOpenByStart.get(i) || [], o = e.autoClosingPairs.autoClosingPairsCloseByStart.get(i) || [], s = r.some((l) => t.startsWith(l.open)), a = o.some((l) => t.startsWith(l.close));
    return !s && a;
  }
  static _findAutoClosingPairOpen(e, t, i, r) {
    const o = e.autoClosingPairs.autoClosingPairsOpenByEnd.get(r);
    if (!o)
      return null;
    let s = null;
    for (const a of o)
      if (s === null || a.open.length > s.open.length) {
        let l = !0;
        for (const u of i)
          if (t.getValueInRange(new V(u.lineNumber, u.column - a.open.length + 1, u.lineNumber, u.column)) + r !== a.open) {
            l = !1;
            break;
          }
        l && (s = a);
      }
    return s;
  }
  static _findSubAutoClosingPairClose(e, t) {
    if (t.open.length <= 1)
      return "";
    const i = t.close.charAt(t.close.length - 1), r = e.autoClosingPairs.autoClosingPairsCloseByEnd.get(i) || [];
    let o = null;
    for (const s of r)
      s.open !== t.open && t.open.includes(s.open) && t.close.endsWith(s.close) && (!o || s.open.length > o.open.length) && (o = s);
    return o ? o.close : "";
  }
  static _getAutoClosingPairClose(e, t, i, r, o) {
    const s = kf(r), a = s ? e.autoClosingQuotes : e.autoClosingBrackets;
    if (a === "never")
      return null;
    const l = this._findAutoClosingPairOpen(e, t, i.map((d) => d.getPosition()), r);
    if (!l)
      return null;
    const u = this._findSubAutoClosingPairClose(e, l);
    let c = !0;
    const h = s ? e.shouldAutoCloseBefore.quote : e.shouldAutoCloseBefore.bracket;
    for (let d = 0, f = i.length; d < f; d++) {
      const p = i[d];
      if (!p.isEmpty())
        return null;
      const g = p.getPosition(), _ = t.getLineContent(g.lineNumber), m = _.substring(g.column - 1);
      if (m.startsWith(u) || (c = !1), _.length > g.column - 1) {
        const y = _.charAt(g.column - 1);
        if (!ki._isBeforeClosingBrace(e, m) && !h(y))
          return null;
      }
      if (!t.isCheapToTokenize(g.lineNumber))
        return null;
      if (l.open.length === 1 && s && a !== "always") {
        const y = jp(e.wordSeparators);
        if (o && g.column > 1 && y.get(_.charCodeAt(g.column - 2)) === 0 || !o && g.column > 2 && y.get(_.charCodeAt(g.column - 3)) === 0)
          return null;
      }
      t.forceTokenization(g.lineNumber);
      const v = t.getLineTokens(g.lineNumber);
      let C = !1;
      try {
        C = ui.shouldAutoClosePair(l, v, o ? g.column : g.column - 1);
      } catch (y) {
        Ni(y);
      }
      if (!C)
        return null;
    }
    return c ? l.close.substring(0, l.close.length - u.length) : l.close;
  }
  static _runAutoClosingOpenCharType(e, t, i, r, o, s, a) {
    let l = [];
    for (let u = 0, c = r.length; u < c; u++) {
      const h = r[u];
      l[u] = new y3(h, o, s, a);
    }
    return new po(4, l, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !1
    });
  }
  static _shouldSurroundChar(e, t) {
    return kf(t) ? e.autoSurround === "quotes" || e.autoSurround === "languageDefined" : e.autoSurround === "brackets" || e.autoSurround === "languageDefined";
  }
  static _isSurroundSelectionType(e, t, i, r) {
    if (!ki._shouldSurroundChar(e, r) || !e.surroundingPairs.hasOwnProperty(r))
      return !1;
    const o = kf(r);
    for (let s = 0, a = i.length; s < a; s++) {
      const l = i[s];
      if (l.isEmpty())
        return !1;
      let u = !0;
      for (let c = l.startLineNumber; c <= l.endLineNumber; c++) {
        const h = t.getLineContent(c), d = c === l.startLineNumber ? l.startColumn - 1 : 0, f = c === l.endLineNumber ? l.endColumn - 1 : h.length, p = h.substring(d, f);
        if (/[^ \t]/.test(p)) {
          u = !1;
          break;
        }
      }
      if (u)
        return !1;
      if (o && l.startLineNumber === l.endLineNumber && l.startColumn + 1 === l.endColumn) {
        const c = t.getValueInRange(l);
        if (kf(c))
          return !1;
      }
    }
    return !0;
  }
  static _runSurroundSelectionType(e, t, i, r, o) {
    let s = [];
    for (let a = 0, l = r.length; a < l; a++) {
      const u = r[a], c = t.surroundingPairs[o];
      s[a] = new $ce(u, o, c);
    }
    return new po(0, s, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _isTypeInterceptorElectricChar(e, t, i) {
    return !!(i.length === 1 && t.isCheapToTokenize(i[0].getEndPosition().lineNumber));
  }
  static _typeInterceptorElectricChar(e, t, i, r, o) {
    if (!t.electricChars.hasOwnProperty(o) || !r.isEmpty())
      return null;
    let s = r.getPosition();
    i.forceTokenization(s.lineNumber);
    let a = i.getLineTokens(s.lineNumber), l;
    try {
      l = ui.onElectricCharacter(o, a, s.column);
    } catch (u) {
      return Ni(u), null;
    }
    if (!l)
      return null;
    if (l.matchOpenBracket) {
      let u = (a.getLineContent() + o).lastIndexOf(l.matchOpenBracket) + 1, c = i.findMatchingBracketUp(l.matchOpenBracket, {
        lineNumber: s.lineNumber,
        column: u
      });
      if (c) {
        if (c.startLineNumber === s.lineNumber)
          return null;
        let h = i.getLineContent(c.startLineNumber), d = Pr(h), f = t.normalizeIndentation(d), p = i.getLineContent(s.lineNumber), g = i.getLineFirstNonWhitespaceColumn(s.lineNumber) || s.column, _ = p.substring(g - 1, s.column - 1), m = f + _ + o, v = new V(s.lineNumber, 1, s.lineNumber, s.column);
        const C = new go(v, m);
        return new po(RD(m, e), [C], {
          shouldPushStackElementBefore: !1,
          shouldPushStackElementAfter: !0
        });
      }
    }
    return null;
  }
  /**
   * This is very similar with typing, but the character is already in the text buffer!
   */
  static compositionEndWithInterceptors(e, t, i, r, o, s) {
    if (!r || Ut.selectionsArrEqual(r, o))
      return null;
    let a = null;
    for (const u of o) {
      if (!u.isEmpty())
        return null;
      const c = u.getPosition(), h = i.getValueInRange(new V(c.lineNumber, c.column - 1, c.lineNumber, c.column));
      if (a === null)
        a = h;
      else if (a !== h)
        return null;
    }
    if (!a)
      return null;
    if (this._isAutoClosingOvertype(t, i, o, s, a)) {
      const u = o.map((c) => new go(new V(c.positionLineNumber, c.positionColumn, c.positionLineNumber, c.positionColumn + 1), "", !1));
      return new po(4, u, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    const l = this._getAutoClosingPairClose(t, i, o, a, !1);
    return l !== null ? this._runAutoClosingOpenCharType(e, t, i, o, a, !1, l) : null;
  }
  static typeWithInterceptors(e, t, i, r, o, s, a) {
    if (!e && a === `
`) {
      let c = [];
      for (let h = 0, d = o.length; h < d; h++)
        c[h] = ki._enter(i, r, !1, o[h]);
      return new po(4, c, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    if (!e && this._isAutoIndentType(i, r, o)) {
      let c = [], h = !1;
      for (let d = 0, f = o.length; d < f; d++)
        if (c[d] = this._runAutoIndentType(i, r, o[d], a), !c[d]) {
          h = !0;
          break;
        }
      if (!h)
        return new po(4, c, {
          shouldPushStackElementBefore: !0,
          shouldPushStackElementAfter: !1
        });
    }
    if (!e && this._isAutoClosingOvertype(i, r, o, s, a))
      return this._runAutoClosingOvertype(t, i, r, o, a);
    if (!e) {
      const c = this._getAutoClosingPairClose(i, r, o, a, !0);
      if (c)
        return this._runAutoClosingOpenCharType(t, i, r, o, a, !0, c);
    }
    if (this._isSurroundSelectionType(i, r, o, a))
      return this._runSurroundSelectionType(t, i, r, o, a);
    if (!e && this._isTypeInterceptorElectricChar(i, r, o)) {
      const c = this._typeInterceptorElectricChar(t, i, r, o[0], a);
      if (c)
        return c;
    }
    let l = [];
    for (let c = 0, h = o.length; c < h; c++)
      l[c] = new go(o[c], a);
    const u = RD(a, t);
    return new po(u, l, {
      shouldPushStackElementBefore: Sy(t, u),
      shouldPushStackElementAfter: !1
    });
  }
  static typeWithoutInterceptors(e, t, i, r, o) {
    let s = [];
    for (let l = 0, u = r.length; l < u; l++)
      s[l] = new go(r[l], o);
    const a = RD(o, e);
    return new po(a, s, {
      shouldPushStackElementBefore: Sy(e, a),
      shouldPushStackElementAfter: !1
    });
  }
  static lineInsertBefore(e, t, i) {
    if (t === null || i === null)
      return [];
    let r = [];
    for (let o = 0, s = i.length; o < s; o++) {
      let a = i[o].positionLineNumber;
      if (a === 1)
        r[o] = new yy(new V(1, 1, 1, 1), `
`);
      else {
        a--;
        let l = t.getLineMaxColumn(a);
        r[o] = this._enter(e, t, !1, new V(a, l, a, l));
      }
    }
    return r;
  }
  static lineInsertAfter(e, t, i) {
    if (t === null || i === null)
      return [];
    let r = [];
    for (let o = 0, s = i.length; o < s; o++) {
      const a = i[o].positionLineNumber;
      let l = t.getLineMaxColumn(a);
      r[o] = this._enter(e, t, !1, new V(a, l, a, l));
    }
    return r;
  }
  static lineBreakInsert(e, t, i) {
    let r = [];
    for (let o = 0, s = i.length; o < s; o++)
      r[o] = this._enter(e, t, !0, i[o]);
    return r;
  }
}
class y3 extends cw {
  constructor(e, t, i, r) {
    super(e, (i ? t : "") + r, 0, -r.length), this._openCharacter = t, this._closeCharacter = r, this.closeCharacterRange = null, this.enclosingRange = null;
  }
  computeCursorState(e, t) {
    let r = t.getInverseEditOperations()[0].range;
    return this.closeCharacterRange = new V(r.startLineNumber, r.endColumn - this._closeCharacter.length, r.endLineNumber, r.endColumn), this.enclosingRange = new V(r.startLineNumber, r.endColumn - this._openCharacter.length - this._closeCharacter.length, r.endLineNumber, r.endColumn), super.computeCursorState(e, t);
  }
}
function RD(n, e) {
  return n === " " ? e === 5 || e === 6 ? 6 : 5 : 4;
}
function Sy(n, e) {
  return p2(n) && !p2(e) ? !0 : n === 5 ? !1 : f2(n) !== f2(e);
}
function f2(n) {
  return n === 6 || n === 5 ? "space" : n;
}
function p2(n) {
  return n === 4 || n === 5 || n === 6;
}
var Le;
(function(n) {
  n.editorSimpleInput = new it("editorSimpleInput", !1, !0), n.editorTextFocus = new it("editorTextFocus", !1, w("editorTextFocus", "Whether the editor text has focus (cursor is blinking)")), n.focus = new it("editorFocus", !1, w("editorFocus", "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)")), n.textInputFocus = new it("textInputFocus", !1, w("textInputFocus", "Whether an editor or a rich text input has focus (cursor is blinking)")), n.readOnly = new it("editorReadonly", !1, w("editorReadonly", "Whether the editor is read only")), n.inDiffEditor = new it("inDiffEditor", !1, w("inDiffEditor", "Whether the context is a diff editor")), n.columnSelection = new it("editorColumnSelection", !1, w("editorColumnSelection", "Whether `editor.columnSelection` is enabled")), n.writable = n.readOnly.toNegated(), n.hasNonEmptySelection = new it("editorHasSelection", !1, w("editorHasSelection", "Whether the editor has text selected")), n.hasOnlyEmptySelection = n.hasNonEmptySelection.toNegated(), n.hasMultipleSelections = new it("editorHasMultipleSelections", !1, w("editorHasMultipleSelections", "Whether the editor has multiple selections")), n.hasSingleSelection = n.hasMultipleSelections.toNegated(), n.tabMovesFocus = new it("editorTabMovesFocus", !1, w("editorTabMovesFocus", "Whether `Tab` will move focus out of the editor")), n.tabDoesNotMoveFocus = n.tabMovesFocus.toNegated(), n.isInWalkThroughSnippet = new it("isInEmbeddedEditor", !1, !0), n.canUndo = new it("canUndo", !1, !0), n.canRedo = new it("canRedo", !1, !0), n.hoverVisible = new it("editorHoverVisible", !1, w("editorHoverVisible", "Whether the editor hover is visible")), n.inCompositeEditor = new it("inCompositeEditor", void 0, w("inCompositeEditor", "Whether the editor is part of a larger editor (e.g. notebooks)")), n.notInCompositeEditor = n.inCompositeEditor.toNegated(), n.languageId = new it("editorLangId", "", w("editorLangId", "The language identifier of the editor")), n.hasCompletionItemProvider = new it("editorHasCompletionItemProvider", !1, w("editorHasCompletionItemProvider", "Whether the editor has a completion item provider")), n.hasCodeActionsProvider = new it("editorHasCodeActionsProvider", !1, w("editorHasCodeActionsProvider", "Whether the editor has a code actions provider")), n.hasCodeLensProvider = new it("editorHasCodeLensProvider", !1, w("editorHasCodeLensProvider", "Whether the editor has a code lens provider")), n.hasDefinitionProvider = new it("editorHasDefinitionProvider", !1, w("editorHasDefinitionProvider", "Whether the editor has a definition provider")), n.hasDeclarationProvider = new it("editorHasDeclarationProvider", !1, w("editorHasDeclarationProvider", "Whether the editor has a declaration provider")), n.hasImplementationProvider = new it("editorHasImplementationProvider", !1, w("editorHasImplementationProvider", "Whether the editor has an implementation provider")), n.hasTypeDefinitionProvider = new it("editorHasTypeDefinitionProvider", !1, w("editorHasTypeDefinitionProvider", "Whether the editor has a type definition provider")), n.hasHoverProvider = new it("editorHasHoverProvider", !1, w("editorHasHoverProvider", "Whether the editor has a hover provider")), n.hasDocumentHighlightProvider = new it("editorHasDocumentHighlightProvider", !1, w("editorHasDocumentHighlightProvider", "Whether the editor has a document highlight provider")), n.hasDocumentSymbolProvider = new it("editorHasDocumentSymbolProvider", !1, w("editorHasDocumentSymbolProvider", "Whether the editor has a document symbol provider")), n.hasReferenceProvider = new it("editorHasReferenceProvider", !1, w("editorHasReferenceProvider", "Whether the editor has a reference provider")), n.hasRenameProvider = new it("editorHasRenameProvider", !1, w("editorHasRenameProvider", "Whether the editor has a rename provider")), n.hasSignatureHelpProvider = new it("editorHasSignatureHelpProvider", !1, w("editorHasSignatureHelpProvider", "Whether the editor has a signature help provider")), n.hasInlayHintsProvider = new it("editorHasInlayHintsProvider", !1, w("editorHasInlayHintsProvider", "Whether the editor has an inline hints provider")), n.hasDocumentFormattingProvider = new it("editorHasDocumentFormattingProvider", !1, w("editorHasDocumentFormattingProvider", "Whether the editor has a document formatting provider")), n.hasDocumentSelectionFormattingProvider = new it("editorHasDocumentSelectionFormattingProvider", !1, w("editorHasDocumentSelectionFormattingProvider", "Whether the editor has a document selection formatting provider")), n.hasMultipleDocumentFormattingProvider = new it("editorHasMultipleDocumentFormattingProvider", !1, w("editorHasMultipleDocumentFormattingProvider", "Whether the editor has multiple document formatting providers")), n.hasMultipleDocumentSelectionFormattingProvider = new it("editorHasMultipleDocumentSelectionFormattingProvider", !1, w("editorHasMultipleDocumentSelectionFormattingProvider", "Whether the editor has multiple document selection formatting providers"));
})(Le || (Le = {}));
const Ct = 0;
class Ui extends Lg {
  runEditorCommand(e, t, i) {
    const r = t._getViewModel();
    r && this.runCoreEditorCommand(r, i || {});
  }
}
var Wb;
(function(n) {
  const e = function(i) {
    if (!Bo(i))
      return !1;
    const r = i;
    return !(!Za(r.to) || !Ls(r.by) && !Za(r.by) || !Ls(r.value) && !V_(r.value) || !Ls(r.revealCursor) && !GG(r.revealCursor));
  };
  n.description = {
    description: "Scroll editor in the given direction",
    args: [
      {
        name: "Editor scroll argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'to': A mandatory direction value.\n						```\n						'up', 'down'\n						```\n					* 'by': Unit to move. Default is computed based on 'to' value.\n						```\n						'line', 'wrappedLine', 'page', 'halfPage'\n						```\n					* 'value': Number of units to move. Default is '1'.\n					* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["up", "down"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "page", "halfPage"]
            },
            value: {
              type: "number",
              default: 1
            },
            revealCursor: {
              type: "boolean"
            }
          }
        }
      }
    ]
  }, n.RawDirection = {
    Up: "up",
    Down: "down"
  }, n.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Page: "page",
    HalfPage: "halfPage"
  };
  function t(i) {
    let r;
    switch (i.to) {
      case n.RawDirection.Up:
        r = 1;
        break;
      case n.RawDirection.Down:
        r = 2;
        break;
      default:
        return null;
    }
    let o;
    switch (i.by) {
      case n.RawUnit.Line:
        o = 1;
        break;
      case n.RawUnit.WrappedLine:
        o = 2;
        break;
      case n.RawUnit.Page:
        o = 3;
        break;
      case n.RawUnit.HalfPage:
        o = 4;
        break;
      default:
        o = 2;
    }
    const s = Math.floor(i.value || 1), a = !!i.revealCursor;
    return {
      direction: r,
      unit: o,
      value: s,
      revealCursor: a,
      select: !!i.select
    };
  }
  n.parse = t;
})(Wb || (Wb = {}));
var Zf;
(function(n) {
  const e = function(t) {
    if (!Bo(t))
      return !1;
    const i = t;
    return !(!V_(i.lineNumber) && !Za(i.lineNumber) || !Ls(i.at) && !Za(i.at));
  };
  n.description = {
    description: "Reveal the given line at the given logical position",
    args: [
      {
        name: "Reveal line argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'lineNumber': A mandatory line number value.\n					* 'at': Logical position at which line has to be revealed.\n						```\n						'top', 'center', 'bottom'\n						```\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["lineNumber"],
          properties: {
            lineNumber: {
              type: ["number", "string"]
            },
            at: {
              type: "string",
              enum: ["top", "center", "bottom"]
            }
          }
        }
      }
    ]
  }, n.RawAtArgument = {
    Top: "top",
    Center: "center",
    Bottom: "bottom"
  };
})(Zf || (Zf = {}));
class kT {
  constructor(e) {
    e.addImplementation(1e4, "code-editor", (t, i) => {
      const r = t.get(pr).getFocusedCodeEditor();
      return r && r.hasTextFocus() ? this._runEditorCommand(t, r, i) : !1;
    }), e.addImplementation(1e3, "generic-dom-input-textarea", (t, i) => {
      const r = document.activeElement;
      return r && ["input", "textarea"].indexOf(r.tagName.toLowerCase()) >= 0 ? (this.runDOMCommand(), !0) : !1;
    }), e.addImplementation(0, "generic-dom", (t, i) => {
      const r = t.get(pr).getActiveCodeEditor();
      return r ? (r.focus(), this._runEditorCommand(t, r, i)) : !1;
    });
  }
  _runEditorCommand(e, t, i) {
    const r = this.runEditorCommand(e, t, i);
    return r || !0;
  }
}
var Sn;
(function(n) {
  class e extends Ui {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, [
        rr.moveTo(v, v.getPrimaryCursorState(), this._inSelectionMode, C.position, C.viewPosition)
      ]), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.MoveTo = Ze(new e({
    id: "_moveTo",
    inSelectionMode: !1,
    precondition: void 0
  })), n.MoveToSelect = Ze(new e({
    id: "_moveToSelect",
    inSelectionMode: !0,
    precondition: void 0
  }));
  class t extends Ui {
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement();
      const y = this._getColumnSelectResult(v, v.getPrimaryCursorState(), v.getCursorColumnSelectData(), C);
      v.setCursorStates(C.source, 3, y.viewStates.map((b) => st.fromViewState(b))), v.setCursorColumnSelectData({
        isReal: !0,
        fromViewLineNumber: y.fromLineNumber,
        fromViewVisualColumn: y.fromVisualColumn,
        toViewLineNumber: y.toLineNumber,
        toViewVisualColumn: y.toVisualColumn
      }), y.reversed ? v.revealTopMostCursor(C.source) : v.revealBottomMostCursor(C.source);
    }
  }
  n.ColumnSelect = Ze(new class extends t {
    constructor() {
      super({
        id: "columnSelect",
        precondition: void 0
      });
    }
    _getColumnSelectResult(m, v, C, y) {
      const b = m.model.validatePosition(y.position), L = m.coordinatesConverter.validateViewPosition(new J(y.viewPosition.lineNumber, y.viewPosition.column), b);
      let S = y.doColumnSelect ? C.fromViewLineNumber : L.lineNumber, E = y.doColumnSelect ? C.fromViewVisualColumn : y.mouseColumn - 1;
      return qh.columnSelect(m.cursorConfig, m, S, E, L.lineNumber, y.mouseColumn - 1);
    }
  }()), n.CursorColumnSelectLeft = Ze(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectLeft",
        precondition: void 0,
        kbOpts: {
          weight: Ct,
          kbExpr: Le.textInputFocus,
          primary: 3599,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(m, v, C, y) {
      return qh.columnSelectLeft(m.cursorConfig, m, C);
    }
  }()), n.CursorColumnSelectRight = Ze(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectRight",
        precondition: void 0,
        kbOpts: {
          weight: Ct,
          kbExpr: Le.textInputFocus,
          primary: 3601,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(m, v, C, y) {
      return qh.columnSelectRight(m.cursorConfig, m, C);
    }
  }());
  class i extends t {
    constructor(v) {
      super(v), this._isPaged = v.isPaged;
    }
    _getColumnSelectResult(v, C, y, b) {
      return qh.columnSelectUp(v.cursorConfig, v, y, this._isPaged);
    }
  }
  n.CursorColumnSelectUp = Ze(new i({
    isPaged: !1,
    id: "cursorColumnSelectUp",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 3600,
      linux: { primary: 0 }
    }
  })), n.CursorColumnSelectPageUp = Ze(new i({
    isPaged: !0,
    id: "cursorColumnSelectPageUp",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 3595,
      linux: { primary: 0 }
    }
  }));
  class r extends t {
    constructor(v) {
      super(v), this._isPaged = v.isPaged;
    }
    _getColumnSelectResult(v, C, y, b) {
      return qh.columnSelectDown(v.cursorConfig, v, y, this._isPaged);
    }
  }
  n.CursorColumnSelectDown = Ze(new r({
    isPaged: !1,
    id: "cursorColumnSelectDown",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 3602,
      linux: { primary: 0 }
    }
  })), n.CursorColumnSelectPageDown = Ze(new r({
    isPaged: !0,
    id: "cursorColumnSelectPageDown",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 3596,
      linux: { primary: 0 }
    }
  }));
  class o extends Ui {
    constructor() {
      super({
        id: "cursorMove",
        precondition: void 0,
        description: kb.description
      });
    }
    runCoreEditorCommand(v, C) {
      const y = kb.parse(C);
      y && this._runCursorMove(v, C.source, y);
    }
    _runCursorMove(v, C, y) {
      v.model.pushStackElement(), v.setCursorStates(C, 3, o._move(v, v.getCursorStates(), y)), v.revealPrimaryCursor(C, !0);
    }
    static _move(v, C, y) {
      const b = y.select, L = y.value;
      switch (y.direction) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
          return rr.simpleMove(v, C, y.direction, b, L, y.unit);
        case 11:
        case 13:
        case 12:
        case 14:
          return rr.viewportMove(v, C, y.direction, b, L);
        default:
          return null;
      }
    }
  }
  n.CursorMoveImpl = o, n.CursorMove = Ze(new o());
  class s extends Ui {
    constructor(v) {
      super(v), this._staticArgs = v.args;
    }
    runCoreEditorCommand(v, C) {
      let y = this._staticArgs;
      this._staticArgs.value === -1 && (y = {
        direction: this._staticArgs.direction,
        unit: this._staticArgs.unit,
        select: this._staticArgs.select,
        value: v.cursorConfig.pageSize
      }), v.model.pushStackElement(), v.setCursorStates(C.source, 3, rr.simpleMove(v, v.getCursorStates(), y.direction, y.select, y.value, y.unit)), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.CursorLeft = Ze(new s({
    args: {
      direction: 0,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorLeft",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 15,
      mac: { primary: 15, secondary: [
        288
        /* KEY_B */
      ] }
    }
  })), n.CursorLeftSelect = Ze(new s({
    args: {
      direction: 0,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorLeftSelect",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 1039
      /* LeftArrow */
    }
  })), n.CursorRight = Ze(new s({
    args: {
      direction: 1,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorRight",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 17,
      mac: { primary: 17, secondary: [
        292
        /* KEY_F */
      ] }
    }
  })), n.CursorRightSelect = Ze(new s({
    args: {
      direction: 1,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorRightSelect",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 1041
      /* RightArrow */
    }
  })), n.CursorUp = Ze(new s({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorUp",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 16,
      mac: { primary: 16, secondary: [
        302
        /* KEY_P */
      ] }
    }
  })), n.CursorUpSelect = Ze(new s({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 1040,
      secondary: [
        3088
        /* UpArrow */
      ],
      mac: {
        primary: 1040
        /* UpArrow */
      },
      linux: {
        primary: 1040
        /* UpArrow */
      }
    }
  })), n.CursorPageUp = Ze(new s({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: -1
      /* PAGE_SIZE_MARKER */
    },
    id: "cursorPageUp",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 11
      /* PageUp */
    }
  })), n.CursorPageUpSelect = Ze(new s({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: -1
      /* PAGE_SIZE_MARKER */
    },
    id: "cursorPageUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 1035
      /* PageUp */
    }
  })), n.CursorDown = Ze(new s({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorDown",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 18,
      mac: { primary: 18, secondary: [
        300
        /* KEY_N */
      ] }
    }
  })), n.CursorDownSelect = Ze(new s({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 1042,
      secondary: [
        3090
        /* DownArrow */
      ],
      mac: {
        primary: 1042
        /* DownArrow */
      },
      linux: {
        primary: 1042
        /* DownArrow */
      }
    }
  })), n.CursorPageDown = Ze(new s({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: -1
      /* PAGE_SIZE_MARKER */
    },
    id: "cursorPageDown",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 12
      /* PageDown */
    }
  })), n.CursorPageDownSelect = Ze(new s({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: -1
      /* PAGE_SIZE_MARKER */
    },
    id: "cursorPageDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 1036
      /* PageDown */
    }
  })), n.CreateCursor = Ze(new class extends Ui {
    constructor() {
      super({
        id: "createCursor",
        precondition: void 0
      });
    }
    runCoreEditorCommand(m, v) {
      let C;
      v.wholeLine ? C = rr.line(m, m.getPrimaryCursorState(), !1, v.position, v.viewPosition) : C = rr.moveTo(m, m.getPrimaryCursorState(), !1, v.position, v.viewPosition);
      const y = m.getCursorStates();
      if (y.length > 1) {
        const b = C.modelState ? C.modelState.position : null, L = C.viewState ? C.viewState.position : null;
        for (let S = 0, E = y.length; S < E; S++) {
          const D = y[S];
          if (!(b && !D.modelState.selection.containsPosition(b)) && !(L && !D.viewState.selection.containsPosition(L))) {
            y.splice(S, 1), m.model.pushStackElement(), m.setCursorStates(v.source, 3, y);
            return;
          }
        }
      }
      y.push(C), m.model.pushStackElement(), m.setCursorStates(v.source, 3, y);
    }
  }()), n.LastCursorMoveToSelect = Ze(new class extends Ui {
    constructor() {
      super({
        id: "_lastCursorMoveToSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(m, v) {
      const C = m.getLastAddedCursorIndex(), y = m.getCursorStates(), b = y.slice(0);
      b[C] = rr.moveTo(m, y[C], !0, v.position, v.viewPosition), m.model.pushStackElement(), m.setCursorStates(v.source, 3, b);
    }
  }());
  class a extends Ui {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, rr.moveToBeginningOfLine(v, v.getCursorStates(), this._inSelectionMode)), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.CursorHome = Ze(new a({
    inSelectionMode: !1,
    id: "cursorHome",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 14,
      mac: { primary: 14, secondary: [
        2063
        /* LeftArrow */
      ] }
    }
  })), n.CursorHomeSelect = Ze(new a({
    inSelectionMode: !0,
    id: "cursorHomeSelect",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 1038,
      mac: { primary: 1038, secondary: [
        3087
        /* LeftArrow */
      ] }
    }
  }));
  class l extends Ui {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, this._exec(v.getCursorStates())), v.revealPrimaryCursor(C.source, !0);
    }
    _exec(v) {
      const C = [];
      for (let y = 0, b = v.length; y < b; y++) {
        const L = v[y], S = L.modelState.position.lineNumber;
        C[y] = st.fromModelState(L.modelState.move(this._inSelectionMode, S, 1, 0));
      }
      return C;
    }
  }
  n.CursorLineStart = Ze(new l({
    inSelectionMode: !1,
    id: "cursorLineStart",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 0,
      mac: {
        primary: 287
        /* KEY_A */
      }
    }
  })), n.CursorLineStartSelect = Ze(new l({
    inSelectionMode: !0,
    id: "cursorLineStartSelect",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 0,
      mac: {
        primary: 1311
        /* KEY_A */
      }
    }
  }));
  class u extends Ui {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, rr.moveToEndOfLine(v, v.getCursorStates(), this._inSelectionMode, C.sticky || !1)), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.CursorEnd = Ze(new u({
    inSelectionMode: !1,
    id: "cursorEnd",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 13,
      mac: { primary: 13, secondary: [
        2065
        /* RightArrow */
      ] }
    },
    description: {
      description: "Go to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: w("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  })), n.CursorEndSelect = Ze(new u({
    inSelectionMode: !0,
    id: "cursorEndSelect",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 1037,
      mac: { primary: 1037, secondary: [
        3089
        /* RightArrow */
      ] }
    },
    description: {
      description: "Select to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: w("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  }));
  class c extends Ui {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, this._exec(v, v.getCursorStates())), v.revealPrimaryCursor(C.source, !0);
    }
    _exec(v, C) {
      const y = [];
      for (let b = 0, L = C.length; b < L; b++) {
        const S = C[b], E = S.modelState.position.lineNumber, D = v.model.getLineMaxColumn(E);
        y[b] = st.fromModelState(S.modelState.move(this._inSelectionMode, E, D, 0));
      }
      return y;
    }
  }
  n.CursorLineEnd = Ze(new c({
    inSelectionMode: !1,
    id: "cursorLineEnd",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 0,
      mac: {
        primary: 291
        /* KEY_E */
      }
    }
  })), n.CursorLineEndSelect = Ze(new c({
    inSelectionMode: !0,
    id: "cursorLineEndSelect",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 0,
      mac: {
        primary: 1315
        /* KEY_E */
      }
    }
  }));
  class h extends Ui {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, rr.moveToBeginningOfBuffer(v, v.getCursorStates(), this._inSelectionMode)), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.CursorTop = Ze(new h({
    inSelectionMode: !1,
    id: "cursorTop",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 2062,
      mac: {
        primary: 2064
        /* UpArrow */
      }
    }
  })), n.CursorTopSelect = Ze(new h({
    inSelectionMode: !0,
    id: "cursorTopSelect",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 3086,
      mac: {
        primary: 3088
        /* UpArrow */
      }
    }
  }));
  class d extends Ui {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, rr.moveToEndOfBuffer(v, v.getCursorStates(), this._inSelectionMode)), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.CursorBottom = Ze(new d({
    inSelectionMode: !1,
    id: "cursorBottom",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 2061,
      mac: {
        primary: 2066
        /* DownArrow */
      }
    }
  })), n.CursorBottomSelect = Ze(new d({
    inSelectionMode: !0,
    id: "cursorBottomSelect",
    precondition: void 0,
    kbOpts: {
      weight: Ct,
      kbExpr: Le.textInputFocus,
      primary: 3085,
      mac: {
        primary: 3090
        /* DownArrow */
      }
    }
  }));
  class f extends Ui {
    constructor() {
      super({
        id: "editorScroll",
        precondition: void 0,
        description: Wb.description
      });
    }
    runCoreEditorCommand(v, C) {
      const y = Wb.parse(C);
      y && this._runEditorScroll(v, C.source, y);
    }
    _runEditorScroll(v, C, y) {
      const b = this._computeDesiredScrollTop(v, y);
      if (y.revealCursor) {
        const L = v.getCompletelyVisibleViewRangeAtScrollTop(b);
        v.setCursorStates(C, 3, [
          rr.findPositionInViewportIfOutside(v, v.getPrimaryCursorState(), L, y.select)
        ]);
      }
      v.setScrollTop(
        b,
        0
        /* Smooth */
      );
    }
    _computeDesiredScrollTop(v, C) {
      if (C.unit === 1) {
        const L = v.getCompletelyVisibleViewRange(), S = v.coordinatesConverter.convertViewRangeToModelRange(L);
        let E;
        C.direction === 1 ? E = Math.max(1, S.startLineNumber - C.value) : E = Math.min(v.model.getLineCount(), S.startLineNumber + C.value);
        const D = v.coordinatesConverter.convertModelPositionToViewPosition(new J(E, 1));
        return v.getVerticalOffsetForLineNumber(D.lineNumber);
      }
      let y;
      C.unit === 3 ? y = v.cursorConfig.pageSize * C.value : C.unit === 4 ? y = Math.round(v.cursorConfig.pageSize / 2) * C.value : y = C.value;
      const b = (C.direction === 1 ? -1 : 1) * y;
      return v.getScrollTop() + b * v.cursorConfig.lineHeight;
    }
  }
  n.EditorScrollImpl = f, n.EditorScroll = Ze(new f()), n.ScrollLineUp = Ze(new class extends Ui {
    constructor() {
      super({
        id: "scrollLineUp",
        precondition: void 0,
        kbOpts: {
          weight: Ct,
          kbExpr: Le.textInputFocus,
          primary: 2064,
          mac: {
            primary: 267
            /* PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(m, v) {
      n.EditorScroll._runEditorScroll(m, v.source, {
        direction: 1,
        unit: 2,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }()), n.ScrollPageUp = Ze(new class extends Ui {
    constructor() {
      super({
        id: "scrollPageUp",
        precondition: void 0,
        kbOpts: {
          weight: Ct,
          kbExpr: Le.textInputFocus,
          primary: 2059,
          win: {
            primary: 523
            /* PageUp */
          },
          linux: {
            primary: 523
            /* PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(m, v) {
      n.EditorScroll._runEditorScroll(m, v.source, {
        direction: 1,
        unit: 3,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }()), n.ScrollLineDown = Ze(new class extends Ui {
    constructor() {
      super({
        id: "scrollLineDown",
        precondition: void 0,
        kbOpts: {
          weight: Ct,
          kbExpr: Le.textInputFocus,
          primary: 2066,
          mac: {
            primary: 268
            /* PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(m, v) {
      n.EditorScroll._runEditorScroll(m, v.source, {
        direction: 2,
        unit: 2,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }()), n.ScrollPageDown = Ze(new class extends Ui {
    constructor() {
      super({
        id: "scrollPageDown",
        precondition: void 0,
        kbOpts: {
          weight: Ct,
          kbExpr: Le.textInputFocus,
          primary: 2060,
          win: {
            primary: 524
            /* PageDown */
          },
          linux: {
            primary: 524
            /* PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(m, v) {
      n.EditorScroll._runEditorScroll(m, v.source, {
        direction: 2,
        unit: 3,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }());
  class p extends Ui {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, [
        rr.word(v, v.getPrimaryCursorState(), this._inSelectionMode, C.position)
      ]), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.WordSelect = Ze(new p({
    inSelectionMode: !1,
    id: "_wordSelect",
    precondition: void 0
  })), n.WordSelectDrag = Ze(new p({
    inSelectionMode: !0,
    id: "_wordSelectDrag",
    precondition: void 0
  })), n.LastCursorWordSelect = Ze(new class extends Ui {
    constructor() {
      super({
        id: "lastCursorWordSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(m, v) {
      const C = m.getLastAddedCursorIndex(), y = m.getCursorStates(), b = y.slice(0), L = y[C];
      b[C] = rr.word(m, L, L.modelState.hasSelection(), v.position), m.model.pushStackElement(), m.setCursorStates(v.source, 3, b);
    }
  }());
  class g extends Ui {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, [
        rr.line(v, v.getPrimaryCursorState(), this._inSelectionMode, C.position, C.viewPosition)
      ]), v.revealPrimaryCursor(C.source, !1);
    }
  }
  n.LineSelect = Ze(new g({
    inSelectionMode: !1,
    id: "_lineSelect",
    precondition: void 0
  })), n.LineSelectDrag = Ze(new g({
    inSelectionMode: !0,
    id: "_lineSelectDrag",
    precondition: void 0
  }));
  class _ extends Ui {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      const y = v.getLastAddedCursorIndex(), b = v.getCursorStates(), L = b.slice(0);
      L[y] = rr.line(v, b[y], this._inSelectionMode, C.position, C.viewPosition), v.model.pushStackElement(), v.setCursorStates(C.source, 3, L);
    }
  }
  n.LastCursorLineSelect = Ze(new _({
    inSelectionMode: !1,
    id: "lastCursorLineSelect",
    precondition: void 0
  })), n.LastCursorLineSelectDrag = Ze(new _({
    inSelectionMode: !0,
    id: "lastCursorLineSelectDrag",
    precondition: void 0
  })), n.ExpandLineSelection = Ze(new class extends Ui {
    constructor() {
      super({
        id: "expandLineSelection",
        precondition: void 0,
        kbOpts: {
          weight: Ct,
          kbExpr: Le.textInputFocus,
          primary: 2090
          /* KEY_L */
        }
      });
    }
    runCoreEditorCommand(m, v) {
      m.model.pushStackElement(), m.setCursorStates(v.source, 3, rr.expandLineSelection(m, m.getCursorStates())), m.revealPrimaryCursor(v.source, !0);
    }
  }()), n.CancelSelection = Ze(new class extends Ui {
    constructor() {
      super({
        id: "cancelSelection",
        precondition: Le.hasNonEmptySelection,
        kbOpts: {
          weight: Ct,
          kbExpr: Le.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(m, v) {
      m.model.pushStackElement(), m.setCursorStates(v.source, 3, [
        rr.cancelSelection(m, m.getPrimaryCursorState())
      ]), m.revealPrimaryCursor(v.source, !0);
    }
  }()), n.RemoveSecondaryCursors = Ze(new class extends Ui {
    constructor() {
      super({
        id: "removeSecondaryCursors",
        precondition: Le.hasMultipleSelections,
        kbOpts: {
          weight: Ct + 1,
          kbExpr: Le.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(m, v) {
      m.model.pushStackElement(), m.setCursorStates(v.source, 3, [
        m.getPrimaryCursorState()
      ]), m.revealPrimaryCursor(v.source, !0), OT(w("removedCursor", "Removed secondary cursors"));
    }
  }()), n.RevealLine = Ze(new class extends Ui {
    constructor() {
      super({
        id: "revealLine",
        precondition: void 0,
        description: Zf.description
      });
    }
    runCoreEditorCommand(m, v) {
      const C = v, y = C.lineNumber || 0;
      let b = typeof y == "number" ? y + 1 : parseInt(y) + 1;
      b < 1 && (b = 1);
      const L = m.model.getLineCount();
      b > L && (b = L);
      const S = new V(b, 1, b, m.model.getLineMaxColumn(b));
      let E = 0;
      if (C.at)
        switch (C.at) {
          case Zf.RawAtArgument.Top:
            E = 3;
            break;
          case Zf.RawAtArgument.Center:
            E = 1;
            break;
          case Zf.RawAtArgument.Bottom:
            E = 4;
            break;
        }
      const D = m.coordinatesConverter.convertModelRangeToViewRange(S);
      m.revealRange(
        v.source,
        !1,
        D,
        E,
        0
        /* Smooth */
      );
    }
  }()), n.SelectAll = new class extends kT {
    constructor() {
      super(kae);
    }
    runDOMCommand() {
      Qr && (document.activeElement.focus(), document.activeElement.select()), document.execCommand("selectAll");
    }
    runEditorCommand(m, v, C) {
      const y = v._getViewModel();
      y && this.runCoreEditorCommand(y, C);
    }
    runCoreEditorCommand(m, v) {
      m.model.pushStackElement(), m.setCursorStates("keyboard", 3, [
        rr.selectAll(m, m.getPrimaryCursorState())
      ]);
    }
  }(), n.SetSelection = Ze(new class extends Ui {
    constructor() {
      super({
        id: "setSelection",
        precondition: void 0
      });
    }
    runCoreEditorCommand(m, v) {
      m.model.pushStackElement(), m.setCursorStates(v.source, 3, [
        st.fromModelSelection(v.selection)
      ]);
    }
  }());
})(Sn || (Sn = {}));
const Kce = hr.and(Le.textInputFocus, Le.columnSelection);
function Rg(n, e) {
  n0.registerKeybindingRule({
    id: n,
    primary: e,
    when: Kce,
    weight: Ct + 1
  });
}
Rg(
  Sn.CursorColumnSelectLeft.id,
  1039
  /* LeftArrow */
);
Rg(
  Sn.CursorColumnSelectRight.id,
  1041
  /* RightArrow */
);
Rg(
  Sn.CursorColumnSelectUp.id,
  1040
  /* UpArrow */
);
Rg(
  Sn.CursorColumnSelectPageUp.id,
  1035
  /* PageUp */
);
Rg(
  Sn.CursorColumnSelectDown.id,
  1042
  /* DownArrow */
);
Rg(
  Sn.CursorColumnSelectPageDown.id,
  1036
  /* PageDown */
);
function g2(n) {
  return n.register(), n;
}
var m2;
(function(n) {
  class e extends Lg {
    runEditorCommand(i, r, o) {
      const s = r._getViewModel();
      s && this.runCoreEditingCommand(r, s, o || {});
    }
  }
  n.CoreEditingCommand = e, n.LineBreakInsert = Ze(new class extends e {
    constructor() {
      super({
        id: "lineBreakInsert",
        precondition: Le.writable,
        kbOpts: {
          weight: Ct,
          kbExpr: Le.textInputFocus,
          primary: 0,
          mac: {
            primary: 301
            /* KEY_O */
          }
        }
      });
    }
    runCoreEditingCommand(t, i, r) {
      t.pushUndoStop(), t.executeCommands(this.id, ki.lineBreakInsert(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection)));
    }
  }()), n.Outdent = Ze(new class extends e {
    constructor() {
      super({
        id: "outdent",
        precondition: Le.writable,
        kbOpts: {
          weight: Ct,
          kbExpr: hr.and(Le.editorTextFocus, Le.tabDoesNotMoveFocus),
          primary: 1026
          /* Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, r) {
      t.pushUndoStop(), t.executeCommands(this.id, ki.outdent(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
    }
  }()), n.Tab = Ze(new class extends e {
    constructor() {
      super({
        id: "tab",
        precondition: Le.writable,
        kbOpts: {
          weight: Ct,
          kbExpr: hr.and(Le.editorTextFocus, Le.tabDoesNotMoveFocus),
          primary: 2
          /* Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, r) {
      t.pushUndoStop(), t.executeCommands(this.id, ki.tab(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
    }
  }()), n.DeleteLeft = Ze(new class extends e {
    constructor() {
      super({
        id: "deleteLeft",
        precondition: void 0,
        kbOpts: {
          weight: Ct,
          kbExpr: Le.textInputFocus,
          primary: 1,
          secondary: [
            1025
            /* Backspace */
          ],
          mac: { primary: 1, secondary: [
            1025,
            294,
            257
            /* Backspace */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, r) {
      const [o, s] = kd.deleteLeft(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection), i.getCursorAutoClosedCharacters());
      o && t.pushUndoStop(), t.executeCommands(this.id, s), i.setPrevEditOperationType(
        2
        /* DeletingLeft */
      );
    }
  }()), n.DeleteRight = Ze(new class extends e {
    constructor() {
      super({
        id: "deleteRight",
        precondition: void 0,
        kbOpts: {
          weight: Ct,
          kbExpr: Le.textInputFocus,
          primary: 20,
          mac: { primary: 20, secondary: [
            290,
            276
            /* Delete */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, r) {
      const [o, s] = kd.deleteRight(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection));
      o && t.pushUndoStop(), t.executeCommands(this.id, s), i.setPrevEditOperationType(
        3
        /* DeletingRight */
      );
    }
  }()), n.Undo = new class extends kT {
    constructor() {
      super(z5);
    }
    runDOMCommand() {
      document.execCommand("undo");
    }
    runEditorCommand(t, i, r) {
      if (!(!i.hasModel() || i.getOption(
        78
        /* readOnly */
      ) === !0))
        return i.getModel().undo();
    }
  }(), n.Redo = new class extends kT {
    constructor() {
      super(j5);
    }
    runDOMCommand() {
      document.execCommand("redo");
    }
    runEditorCommand(t, i, r) {
      if (!(!i.hasModel() || i.getOption(
        78
        /* readOnly */
      ) === !0))
        return i.getModel().redo();
    }
  }();
})(m2 || (m2 = {}));
class v2 extends g0 {
  constructor(e, t, i) {
    super({
      id: e,
      precondition: void 0,
      description: i
    }), this._handlerId = t;
  }
  runCommand(e, t) {
    const i = e.get(pr).getFocusedCodeEditor();
    i && i.trigger("keyboard", this._handlerId, t);
  }
}
function Zd(n, e) {
  g2(new v2("default:" + n, n)), g2(new v2(n, n, e));
}
Zd("type", {
  description: "Type",
  args: [{
    name: "args",
    schema: {
      type: "object",
      required: ["text"],
      properties: {
        text: {
          type: "string"
        }
      }
    }
  }]
});
Zd(
  "replacePreviousChar"
  /* ReplacePreviousChar */
);
Zd(
  "compositionType"
  /* CompositionType */
);
Zd(
  "compositionStart"
  /* CompositionStart */
);
Zd(
  "compositionEnd"
  /* CompositionEnd */
);
Zd(
  "paste"
  /* Paste */
);
Zd(
  "cut"
  /* Cut */
);
class qce {
  constructor(e, t, i, r) {
    this.configuration = e, this.viewModel = t, this.userInputEvents = i, this.commandDelegate = r;
  }
  paste(e, t, i, r) {
    this.commandDelegate.paste(e, t, i, r);
  }
  type(e) {
    this.commandDelegate.type(e);
  }
  compositionType(e, t, i, r) {
    this.commandDelegate.compositionType(e, t, i, r);
  }
  compositionStart() {
    this.commandDelegate.startComposition();
  }
  compositionEnd() {
    this.commandDelegate.endComposition();
  }
  cut() {
    this.commandDelegate.cut();
  }
  setSelection(e) {
    Sn.SetSelection.runCoreEditorCommand(this.viewModel, {
      source: "keyboard",
      selection: e
    });
  }
  _validateViewColumn(e) {
    const t = this.viewModel.getLineMinColumn(e.lineNumber);
    return e.column < t ? new J(e.lineNumber, t) : e;
  }
  _hasMulticursorModifier(e) {
    switch (this.configuration.options.get(
      67
      /* multiCursorModifier */
    )) {
      case "altKey":
        return e.altKey;
      case "ctrlKey":
        return e.ctrlKey;
      case "metaKey":
        return e.metaKey;
      default:
        return !1;
    }
  }
  _hasNonMulticursorModifier(e) {
    switch (this.configuration.options.get(
      67
      /* multiCursorModifier */
    )) {
      case "altKey":
        return e.ctrlKey || e.metaKey;
      case "ctrlKey":
        return e.altKey || e.metaKey;
      case "metaKey":
        return e.ctrlKey || e.altKey;
      default:
        return !1;
    }
  }
  dispatchMouse(e) {
    const t = this.configuration.options, i = Rs && t.get(
      94
      /* selectionClipboard */
    ), r = t.get(
      16
      /* columnSelection */
    );
    e.middleButton && !i ? this._columnSelect(e.position, e.mouseColumn, e.inSelectionMode) : e.startedOnLineNumbers ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelect(e.position) : this._createCursor(e.position, !0) : e.inSelectionMode ? this._lineSelectDrag(e.position) : this._lineSelect(e.position) : e.mouseDownCount >= 4 ? this._selectAll() : e.mouseDownCount === 3 ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelectDrag(e.position) : this._lastCursorLineSelect(e.position) : e.inSelectionMode ? this._lineSelectDrag(e.position) : this._lineSelect(e.position) : e.mouseDownCount === 2 ? this._hasMulticursorModifier(e) ? this._lastCursorWordSelect(e.position) : e.inSelectionMode ? this._wordSelectDrag(e.position) : this._wordSelect(e.position) : this._hasMulticursorModifier(e) ? this._hasNonMulticursorModifier(e) || (e.shiftKey ? this._columnSelect(e.position, e.mouseColumn, !0) : e.inSelectionMode ? this._lastCursorMoveToSelect(e.position) : this._createCursor(e.position, !1)) : e.inSelectionMode ? e.altKey ? this._columnSelect(e.position, e.mouseColumn, !0) : r ? this._columnSelect(e.position, e.mouseColumn, !0) : this._moveToSelect(e.position) : this.moveTo(e.position);
  }
  _usualArgs(e) {
    return e = this._validateViewColumn(e), {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e
    };
  }
  moveTo(e) {
    Sn.MoveTo.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _moveToSelect(e) {
    Sn.MoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _columnSelect(e, t, i) {
    e = this._validateViewColumn(e), Sn.ColumnSelect.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      mouseColumn: t,
      doColumnSelect: i
    });
  }
  _createCursor(e, t) {
    e = this._validateViewColumn(e), Sn.CreateCursor.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      wholeLine: t
    });
  }
  _lastCursorMoveToSelect(e) {
    Sn.LastCursorMoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _wordSelect(e) {
    Sn.WordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _wordSelectDrag(e) {
    Sn.WordSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lastCursorWordSelect(e) {
    Sn.LastCursorWordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lineSelect(e) {
    Sn.LineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lineSelectDrag(e) {
    Sn.LineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lastCursorLineSelect(e) {
    Sn.LastCursorLineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lastCursorLineSelectDrag(e) {
    Sn.LastCursorLineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _selectAll() {
    Sn.SelectAll.runCoreEditorCommand(this.viewModel, { source: "mouse" });
  }
  // ----------------------
  _convertViewToModelPosition(e) {
    return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(e);
  }
  emitKeyDown(e) {
    this.userInputEvents.emitKeyDown(e);
  }
  emitKeyUp(e) {
    this.userInputEvents.emitKeyUp(e);
  }
  emitContextMenu(e) {
    this.userInputEvents.emitContextMenu(e);
  }
  emitMouseMove(e) {
    this.userInputEvents.emitMouseMove(e);
  }
  emitMouseLeave(e) {
    this.userInputEvents.emitMouseLeave(e);
  }
  emitMouseUp(e) {
    this.userInputEvents.emitMouseUp(e);
  }
  emitMouseDown(e) {
    this.userInputEvents.emitMouseDown(e);
  }
  emitMouseDrag(e) {
    this.userInputEvents.emitMouseDrag(e);
  }
  emitMouseDrop(e) {
    this.userInputEvents.emitMouseDrop(e);
  }
  emitMouseDropCanceled() {
    this.userInputEvents.emitMouseDropCanceled();
  }
  emitMouseWheel(e) {
    this.userInputEvents.emitMouseWheel(e);
  }
}
class b0 {
  constructor(e) {
    this.onKeyDown = null, this.onKeyUp = null, this.onContextMenu = null, this.onMouseMove = null, this.onMouseLeave = null, this.onMouseDown = null, this.onMouseUp = null, this.onMouseDrag = null, this.onMouseDrop = null, this.onMouseDropCanceled = null, this.onMouseWheel = null, this._coordinatesConverter = e;
  }
  emitKeyDown(e) {
    this.onKeyDown && this.onKeyDown(e);
  }
  emitKeyUp(e) {
    this.onKeyUp && this.onKeyUp(e);
  }
  emitContextMenu(e) {
    this.onContextMenu && this.onContextMenu(this._convertViewToModelMouseEvent(e));
  }
  emitMouseMove(e) {
    this.onMouseMove && this.onMouseMove(this._convertViewToModelMouseEvent(e));
  }
  emitMouseLeave(e) {
    this.onMouseLeave && this.onMouseLeave(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDown(e) {
    this.onMouseDown && this.onMouseDown(this._convertViewToModelMouseEvent(e));
  }
  emitMouseUp(e) {
    this.onMouseUp && this.onMouseUp(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrag(e) {
    this.onMouseDrag && this.onMouseDrag(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrop(e) {
    this.onMouseDrop && this.onMouseDrop(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDropCanceled() {
    this.onMouseDropCanceled && this.onMouseDropCanceled();
  }
  emitMouseWheel(e) {
    this.onMouseWheel && this.onMouseWheel(e);
  }
  _convertViewToModelMouseEvent(e) {
    return e.target ? {
      event: e.event,
      target: this._convertViewToModelMouseTarget(e.target)
    } : e;
  }
  _convertViewToModelMouseTarget(e) {
    return b0.convertViewToModelMouseTarget(e, this._coordinatesConverter);
  }
  static convertViewToModelMouseTarget(e, t) {
    return new Yce(e.element, e.type, e.mouseColumn, e.position ? t.convertViewPositionToModelPosition(e.position) : null, e.range ? t.convertViewRangeToModelRange(e.range) : null, e.detail);
  }
}
class Yce {
  constructor(e, t, i, r, o, s) {
    this.element = e, this.type = t, this.mouseColumn = i, this.position = r, this.range = o, this.detail = s;
  }
  toString() {
    return Ma.toString(this);
  }
}
var TD;
class w3 {
  constructor(e) {
    this._createLine = e, this._set(1, []);
  }
  flush() {
    this._set(1, []);
  }
  _set(e, t) {
    this._lines = t, this._rendLineNumberStart = e;
  }
  _get() {
    return {
      rendLineNumberStart: this._rendLineNumberStart,
      lines: this._lines
    };
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getStartLineNumber() {
    return this._rendLineNumberStart;
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getEndLineNumber() {
    return this._rendLineNumberStart + this._lines.length - 1;
  }
  getCount() {
    return this._lines.length;
  }
  getLine(e) {
    const t = e - this._rendLineNumberStart;
    if (t < 0 || t >= this._lines.length)
      throw new Error("Illegal value for lineNumber");
    return this._lines[t];
  }
  /**
   * @returns Lines that were removed from this collection
   */
  onLinesDeleted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = this.getStartLineNumber(), r = this.getEndLineNumber();
    if (t < i) {
      const l = t - e + 1;
      return this._rendLineNumberStart -= l, null;
    }
    if (e > r)
      return null;
    let o = 0, s = 0;
    for (let l = i; l <= r; l++) {
      const u = l - this._rendLineNumberStart;
      e <= l && l <= t && (s === 0 ? (o = u, s = 1) : s++);
    }
    if (e < i) {
      let l = 0;
      t < i ? l = t - e + 1 : l = i - e, this._rendLineNumberStart -= l;
    }
    return this._lines.splice(o, s);
  }
  onLinesChanged(e, t) {
    if (this.getCount() === 0)
      return !1;
    const i = this.getStartLineNumber(), r = this.getEndLineNumber();
    let o = !1;
    for (let s = e; s <= t; s++)
      s >= i && s <= r && (this._lines[s - this._rendLineNumberStart].onContentChanged(), o = !0);
    return o;
  }
  onLinesInserted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = t - e + 1, r = this.getStartLineNumber(), o = this.getEndLineNumber();
    if (e <= r)
      return this._rendLineNumberStart += i, null;
    if (e > o)
      return null;
    if (i + e > o)
      return this._lines.splice(e - this._rendLineNumberStart, o - e + 1);
    const s = [];
    for (let h = 0; h < i; h++)
      s[h] = this._createLine();
    const a = e - this._rendLineNumberStart, l = this._lines.slice(0, a), u = this._lines.slice(a, this._lines.length - i), c = this._lines.slice(this._lines.length - i, this._lines.length);
    return this._lines = l.concat(s).concat(u), c;
  }
  onTokensChanged(e) {
    if (this.getCount() === 0)
      return !1;
    const t = this.getStartLineNumber(), i = this.getEndLineNumber();
    let r = !1;
    for (let o = 0, s = e.length; o < s; o++) {
      const a = e[o];
      if (a.toLineNumber < t || a.fromLineNumber > i)
        continue;
      const l = Math.max(t, a.fromLineNumber), u = Math.min(i, a.toLineNumber);
      for (let c = l; c <= u; c++) {
        const h = c - this._rendLineNumberStart;
        this._lines[h].onTokensChanged(), r = !0;
      }
    }
    return r;
  }
}
class b3 {
  constructor(e) {
    this._host = e, this.domNode = this._createDomNode(), this._linesCollection = new w3(() => this._host.createVisibleLine());
  }
  _createDomNode() {
    const e = bt(document.createElement("div"));
    return e.setClassName("view-layer"), e.setPosition("absolute"), e.domNode.setAttribute("role", "presentation"), e.domNode.setAttribute("aria-hidden", "true"), e;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return !!e.hasChanged(
      128
      /* layoutInfo */
    );
  }
  onFlushed(e) {
    return this._linesCollection.flush(), !0;
  }
  onLinesChanged(e) {
    return this._linesCollection.onLinesChanged(e.fromLineNumber, e.toLineNumber);
  }
  onLinesDeleted(e) {
    const t = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, r = t.length; i < r; i++) {
        const o = t[i].getDomNode();
        o && this.domNode.domNode.removeChild(o);
      }
    return !0;
  }
  onLinesInserted(e) {
    const t = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, r = t.length; i < r; i++) {
        const o = t[i].getDomNode();
        o && this.domNode.domNode.removeChild(o);
      }
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onTokensChanged(e) {
    return this._linesCollection.onTokensChanged(e.ranges);
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  getStartLineNumber() {
    return this._linesCollection.getStartLineNumber();
  }
  getEndLineNumber() {
    return this._linesCollection.getEndLineNumber();
  }
  getVisibleLine(e) {
    return this._linesCollection.getLine(e);
  }
  renderLines(e) {
    const t = this._linesCollection._get(), i = new Mu(this.domNode.domNode, this._host, e), r = {
      rendLineNumberStart: t.rendLineNumberStart,
      lines: t.lines,
      linesLength: t.lines.length
    }, o = i.render(r, e.startLineNumber, e.endLineNumber, e.relativeVerticalOffset);
    this._linesCollection._set(o.rendLineNumberStart, o.lines);
  }
}
class Mu {
  constructor(e, t, i) {
    this.domNode = e, this.host = t, this.viewportData = i;
  }
  render(e, t, i, r) {
    const o = {
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines.slice(0),
      linesLength: e.linesLength
    };
    if (o.rendLineNumberStart + o.linesLength - 1 < t || i < o.rendLineNumberStart) {
      o.rendLineNumberStart = t, o.linesLength = i - t + 1, o.lines = [];
      for (let s = t; s <= i; s++)
        o.lines[s - t] = this.host.createVisibleLine();
      return this._finishRendering(o, !0, r), o;
    }
    if (this._renderUntouchedLines(o, Math.max(t - o.rendLineNumberStart, 0), Math.min(i - o.rendLineNumberStart, o.linesLength - 1), r, t), o.rendLineNumberStart > t) {
      const s = t, a = Math.min(i, o.rendLineNumberStart - 1);
      s <= a && (this._insertLinesBefore(o, s, a, r, t), o.linesLength += a - s + 1);
    } else if (o.rendLineNumberStart < t) {
      const s = Math.min(o.linesLength, t - o.rendLineNumberStart);
      s > 0 && (this._removeLinesBefore(o, s), o.linesLength -= s);
    }
    if (o.rendLineNumberStart = t, o.rendLineNumberStart + o.linesLength - 1 < i) {
      const s = o.rendLineNumberStart + o.linesLength, a = i;
      s <= a && (this._insertLinesAfter(o, s, a, r, t), o.linesLength += a - s + 1);
    } else if (o.rendLineNumberStart + o.linesLength - 1 > i) {
      const s = Math.max(0, i - o.rendLineNumberStart + 1), l = o.linesLength - 1 - s + 1;
      l > 0 && (this._removeLinesAfter(o, l), o.linesLength -= l);
    }
    return this._finishRendering(o, !1, r), o;
  }
  _renderUntouchedLines(e, t, i, r, o) {
    const s = e.rendLineNumberStart, a = e.lines;
    for (let l = t; l <= i; l++) {
      const u = s + l;
      a[l].layoutLine(u, r[u - o]);
    }
  }
  _insertLinesBefore(e, t, i, r, o) {
    const s = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      s[a++] = this.host.createVisibleLine();
    e.lines = s.concat(e.lines);
  }
  _removeLinesBefore(e, t) {
    for (let i = 0; i < t; i++) {
      const r = e.lines[i].getDomNode();
      r && this.domNode.removeChild(r);
    }
    e.lines.splice(0, t);
  }
  _insertLinesAfter(e, t, i, r, o) {
    const s = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      s[a++] = this.host.createVisibleLine();
    e.lines = e.lines.concat(s);
  }
  _removeLinesAfter(e, t) {
    const i = e.linesLength - t;
    for (let r = 0; r < t; r++) {
      const o = e.lines[i + r].getDomNode();
      o && this.domNode.removeChild(o);
    }
    e.lines.splice(i, t);
  }
  _finishRenderingNewLines(e, t, i, r) {
    Mu._ttPolicy && (i = Mu._ttPolicy.createHTML(i));
    const o = this.domNode.lastChild;
    t || !o ? this.domNode.innerHTML = i : o.insertAdjacentHTML("afterend", i);
    let s = this.domNode.lastChild;
    for (let a = e.linesLength - 1; a >= 0; a--) {
      const l = e.lines[a];
      r[a] && (l.setDomNode(s), s = s.previousSibling);
    }
  }
  _finishRenderingInvalidLines(e, t, i) {
    const r = document.createElement("div");
    Mu._ttPolicy && (t = Mu._ttPolicy.createHTML(t)), r.innerHTML = t;
    for (let o = 0; o < e.linesLength; o++) {
      const s = e.lines[o];
      if (i[o]) {
        const a = r.firstChild, l = s.getDomNode();
        l.parentNode.replaceChild(a, l), s.setDomNode(a);
      }
    }
  }
  _finishRendering(e, t, i) {
    const r = Mu._sb, o = e.linesLength, s = e.lines, a = e.rendLineNumberStart, l = [];
    {
      r.reset();
      let u = !1;
      for (let c = 0; c < o; c++) {
        const h = s[c];
        l[c] = !1, !(h.getDomNode() || !h.renderLine(c + a, i[c], this.viewportData, r)) && (l[c] = !0, u = !0);
      }
      u && this._finishRenderingNewLines(e, t, r.build(), l);
    }
    {
      r.reset();
      let u = !1;
      const c = [];
      for (let h = 0; h < o; h++) {
        const d = s[h];
        c[h] = !1, !(l[h] || !d.renderLine(h + a, i[h], this.viewportData, r)) && (c[h] = !0, u = !0);
      }
      u && this._finishRenderingInvalidLines(e, r.build(), c);
    }
  }
}
Mu._ttPolicy = (TD = window.trustedTypes) === null || TD === void 0 ? void 0 : TD.createPolicy("editorViewLayer", { createHTML: (n) => n });
Mu._sb = zp(1e5);
class S3 extends Ns {
  constructor(e) {
    super(e), this._visibleLines = new b3(this), this.domNode = this._visibleLines.domNode, this._dynamicOverlays = [], this._isFocused = !1, this.domNode.setClassName("view-overlays");
  }
  shouldRender() {
    if (super.shouldRender())
      return !0;
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      if (this._dynamicOverlays[e].shouldRender())
        return !0;
    return !1;
  }
  dispose() {
    super.dispose();
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      this._dynamicOverlays[e].dispose();
    this._dynamicOverlays = [];
  }
  getDomNode() {
    return this.domNode;
  }
  // ---- begin IVisibleLinesHost
  createVisibleLine() {
    return new Xce(this._context.configuration, this._dynamicOverlays);
  }
  // ---- end IVisibleLinesHost
  addDynamicOverlay(e) {
    this._dynamicOverlays.push(e);
  }
  // ----- event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e);
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    for (let r = t; r <= i; r++)
      this._visibleLines.getVisibleLine(r).onConfigurationChanged(e);
    return !0;
  }
  onFlushed(e) {
    return this._visibleLines.onFlushed(e);
  }
  onFocusChanged(e) {
    return this._isFocused = e.isFocused, !0;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onScrollChanged(e) {
    return this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._visibleLines.onZonesChanged(e);
  }
  // ----- end event handlers
  prepareRender(e) {
    const t = this._dynamicOverlays.filter((i) => i.shouldRender());
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      o.prepareRender(e), o.onDidRender();
    }
  }
  render(e) {
    this._viewOverlaysRender(e), this.domNode.toggleClassName("focused", this._isFocused);
  }
  _viewOverlaysRender(e) {
    this._visibleLines.renderLines(e.viewportData);
  }
}
class Xce {
  constructor(e, t) {
    this._configuration = e, this._lineHeight = this._configuration.options.get(
      56
      /* lineHeight */
    ), this._dynamicOverlays = t, this._domNode = null, this._renderedContent = null;
  }
  getDomNode() {
    return this._domNode ? this._domNode.domNode : null;
  }
  setDomNode(e) {
    this._domNode = bt(e);
  }
  onContentChanged() {
  }
  onTokensChanged() {
  }
  onConfigurationChanged(e) {
    this._lineHeight = this._configuration.options.get(
      56
      /* lineHeight */
    );
  }
  renderLine(e, t, i, r) {
    let o = "";
    for (let s = 0, a = this._dynamicOverlays.length; s < a; s++) {
      const l = this._dynamicOverlays[s];
      o += l.render(i.startLineNumber, e);
    }
    return this._renderedContent === o ? !1 : (this._renderedContent = o, r.appendASCIIString('<div style="position:absolute;top:'), r.appendASCIIString(String(t)), r.appendASCIIString("px;width:100%;height:"), r.appendASCIIString(String(this._lineHeight)), r.appendASCIIString('px;">'), r.appendASCIIString(o), r.appendASCIIString("</div>"), !0);
  }
  layoutLine(e, t) {
    this._domNode && (this._domNode.setTop(t), this._domNode.setHeight(this._lineHeight));
  }
}
class Zce extends S3 {
  constructor(e) {
    super(e);
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    this._contentWidth = i.contentWidth, this.domNode.setHeight(0);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    return this._contentWidth = i.contentWidth, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollWidthChanged;
  }
  // --- end event handlers
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e), this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth));
  }
}
class Qce extends S3 {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    this._contentLeft = i.contentLeft, this.domNode.setClassName("margin-view-overlays"), this.domNode.setWidth(1), io.applyFontInfo(this.domNode, t.get(
      40
      /* fontInfo */
    ));
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    io.applyFontInfo(this.domNode, t.get(
      40
      /* fontInfo */
    ));
    const i = t.get(
      128
      /* layoutInfo */
    );
    return this._contentLeft = i.contentLeft, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollHeightChanged;
  }
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e);
    const t = Math.min(e.scrollHeight, 1e6);
    this.domNode.setHeight(t), this.domNode.setWidth(this._contentLeft);
  }
}
class Nm {
  constructor(e, t) {
    this.top = e, this.left = t;
  }
}
class Jce extends Ns {
  constructor(e, t) {
    super(e), this._viewDomNode = t, this._widgets = {}, this.domNode = bt(document.createElement("div")), jl.write(
      this.domNode,
      1
      /* ContentWidgets */
    ), this.domNode.setClassName("contentWidgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this.overflowingContentWidgetsDomNode = bt(document.createElement("div")), jl.write(
      this.overflowingContentWidgetsDomNode,
      2
      /* OverflowingContentWidgets */
    ), this.overflowingContentWidgetsDomNode.setClassName("overflowingContentWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onConfigurationChanged(e);
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLineMappingChanged(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onLineMappingChanged(e);
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  addWidget(e) {
    const t = new ehe(this._context, this._viewDomNode, e);
    this._widgets[t.id] = t, t.allowEditorOverflow ? this.overflowingContentWidgetsDomNode.appendChild(t.domNode) : this.domNode.appendChild(t.domNode), this.setShouldRender();
  }
  setWidgetPosition(e, t, i) {
    this._widgets[e.getId()].setPosition(t, i), this.setShouldRender();
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const i = this._widgets[t];
      delete this._widgets[t];
      const r = i.domNode.domNode;
      r.parentNode.removeChild(r), r.removeAttribute("monaco-visible-content-widget"), this.setShouldRender();
    }
  }
  shouldSuppressMouseDownOnWidget(e) {
    return this._widgets.hasOwnProperty(e) ? this._widgets[e].suppressMouseDown : !1;
  }
  onBeforeRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onBeforeRender(e);
  }
  prepareRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].prepareRender(e);
  }
  render(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].render(e);
  }
}
let ehe = class {
  constructor(e, t, i) {
    this._context = e, this._viewDomNode = t, this._actual = i, this.domNode = bt(this._actual.getDomNode()), this.id = this._actual.getId(), this.allowEditorOverflow = this._actual.allowEditorOverflow || !1, this.suppressMouseDown = this._actual.suppressMouseDown || !1;
    const r = this._context.configuration.options, o = r.get(
      128
      /* layoutInfo */
    );
    this._fixedOverflowWidgets = r.get(
      34
      /* fixedOverflowWidgets */
    ), this._contentWidth = o.contentWidth, this._contentLeft = o.contentLeft, this._lineHeight = r.get(
      56
      /* lineHeight */
    ), this._range = null, this._viewRange = null, this._preference = [], this._cachedDomNodeClientWidth = -1, this._cachedDomNodeClientHeight = -1, this._maxWidth = this._getMaxWidth(), this._isVisible = !1, this._renderData = null, this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute"), this.domNode.setVisibility("hidden"), this.domNode.setAttribute("widgetId", this.id), this.domNode.setMaxWidth(this._maxWidth);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    if (this._lineHeight = t.get(
      56
      /* lineHeight */
    ), e.hasChanged(
      128
      /* layoutInfo */
    )) {
      const i = t.get(
        128
        /* layoutInfo */
      );
      this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._maxWidth = this._getMaxWidth();
    }
  }
  onLineMappingChanged(e) {
    this._setPosition(this._range);
  }
  _setPosition(e) {
    if (this._range = e, this._viewRange = null, this._range) {
      const t = this._context.model.validateModelRange(this._range);
      (this._context.model.coordinatesConverter.modelPositionIsVisible(t.getStartPosition()) || this._context.model.coordinatesConverter.modelPositionIsVisible(t.getEndPosition())) && (this._viewRange = this._context.model.coordinatesConverter.convertModelRangeToViewRange(t));
    }
  }
  _getMaxWidth() {
    return this.allowEditorOverflow ? window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth : this._contentWidth;
  }
  setPosition(e, t) {
    this._setPosition(e), this._preference = t, this._cachedDomNodeClientWidth = -1, this._cachedDomNodeClientHeight = -1;
  }
  _layoutBoxInViewport(e, t, i, r, o) {
    const s = e.top, a = s, l = t.top + this._lineHeight, u = o.viewportHeight - l, c = s - r, h = a >= r, d = l, f = u >= r;
    let p = e.left, g = t.left;
    return p + i > o.scrollLeft + o.viewportWidth && (p = o.scrollLeft + o.viewportWidth - i), g + i > o.scrollLeft + o.viewportWidth && (g = o.scrollLeft + o.viewportWidth - i), p < o.scrollLeft && (p = o.scrollLeft), g < o.scrollLeft && (g = o.scrollLeft), {
      fitsAbove: h,
      aboveTop: c,
      aboveLeft: p,
      fitsBelow: f,
      belowTop: d,
      belowLeft: g
    };
  }
  _layoutHorizontalSegmentInPage(e, t, i, r) {
    const o = Math.max(0, t.left - r), s = Math.min(t.left + t.width + r, e.width);
    let a = t.left + i - Bu.scrollX;
    if (a + r > s) {
      const l = a - (s - r);
      a -= l, i -= l;
    }
    if (a < o) {
      const l = a - o;
      a -= l, i -= l;
    }
    return [i, a];
  }
  _layoutBoxInPage(e, t, i, r, o) {
    const s = e.top - r, a = t.top + this._lineHeight, l = ja(this._viewDomNode.domNode), u = l.top + s - Bu.scrollY, c = l.top + a - Bu.scrollY, h = EG(document.body), [d, f] = this._layoutHorizontalSegmentInPage(h, l, e.left - o.scrollLeft + this._contentLeft, i), [p, g] = this._layoutHorizontalSegmentInPage(h, l, t.left - o.scrollLeft + this._contentLeft, i), _ = 22, m = 22, v = u >= _, C = c + r <= h.height - m;
    return this._fixedOverflowWidgets ? {
      fitsAbove: v,
      aboveTop: Math.max(u, _),
      aboveLeft: f,
      fitsBelow: C,
      belowTop: c,
      belowLeft: g
    } : {
      fitsAbove: v,
      aboveTop: s,
      aboveLeft: d,
      fitsBelow: C,
      belowTop: a,
      belowLeft: p
    };
  }
  _prepareRenderWidgetAtExactPositionOverflowing(e) {
    return new Nm(e.top, e.left + this._contentLeft);
  }
  /**
   * Compute `this._topLeft`
   */
  _getTopAndBottomLeft(e) {
    if (!this._viewRange)
      return [null, null];
    const t = e.linesVisibleRangesForRange(this._viewRange, !1);
    if (!t || t.length === 0)
      return [null, null];
    let i = t[0], r = t[0];
    for (const h of t)
      h.lineNumber < i.lineNumber && (i = h), h.lineNumber > r.lineNumber && (r = h);
    let o = 1073741824;
    for (const h of i.ranges)
      h.left < o && (o = h.left);
    let s = 1073741824;
    for (const h of r.ranges)
      h.left < s && (s = h.left);
    const a = e.getVerticalOffsetForLineNumber(i.lineNumber) - e.scrollTop, l = new Nm(a, o), u = e.getVerticalOffsetForLineNumber(r.lineNumber) - e.scrollTop, c = new Nm(u, s);
    return [l, c];
  }
  _prepareRenderWidget(e) {
    const [t, i] = this._getTopAndBottomLeft(e);
    if (!t || !i)
      return null;
    if (this._cachedDomNodeClientWidth === -1 || this._cachedDomNodeClientHeight === -1) {
      let o = null;
      if (typeof this._actual.beforeRender == "function" && (o = OD(this._actual.beforeRender, this._actual)), o)
        this._cachedDomNodeClientWidth = o.width, this._cachedDomNodeClientHeight = o.height;
      else {
        const s = this.domNode.domNode;
        this._cachedDomNodeClientWidth = s.clientWidth, this._cachedDomNodeClientHeight = s.clientHeight;
      }
    }
    let r;
    if (this.allowEditorOverflow ? r = this._layoutBoxInPage(t, i, this._cachedDomNodeClientWidth, this._cachedDomNodeClientHeight, e) : r = this._layoutBoxInViewport(t, i, this._cachedDomNodeClientWidth, this._cachedDomNodeClientHeight, e), this._preference)
      for (let o = 1; o <= 2; o++)
        for (const s of this._preference)
          if (s === 1) {
            if (!r)
              return null;
            if (o === 2 || r.fitsAbove)
              return {
                coordinate: new Nm(r.aboveTop, r.aboveLeft),
                position: 1
                /* ABOVE */
              };
          } else if (s === 2) {
            if (!r)
              return null;
            if (o === 2 || r.fitsBelow)
              return {
                coordinate: new Nm(r.belowTop, r.belowLeft),
                position: 2
                /* BELOW */
              };
          } else
            return this.allowEditorOverflow ? {
              coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(t),
              position: 0
              /* EXACT */
            } : {
              coordinate: t,
              position: 0
              /* EXACT */
            };
    return null;
  }
  /**
   * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.
   */
  onBeforeRender(e) {
    !this._viewRange || !this._preference || this._viewRange.endLineNumber < e.startLineNumber || this._viewRange.startLineNumber > e.endLineNumber || this.domNode.setMaxWidth(this._maxWidth);
  }
  prepareRender(e) {
    this._renderData = this._prepareRenderWidget(e);
  }
  render(e) {
    if (!this._renderData) {
      this._isVisible && (this.domNode.removeAttribute("monaco-visible-content-widget"), this._isVisible = !1, this.domNode.setVisibility("hidden")), typeof this._actual.afterRender == "function" && OD(this._actual.afterRender, this._actual, null);
      return;
    }
    this.allowEditorOverflow ? (this.domNode.setTop(this._renderData.coordinate.top), this.domNode.setLeft(this._renderData.coordinate.left)) : (this.domNode.setTop(this._renderData.coordinate.top + e.scrollTop - e.bigNumbersDelta), this.domNode.setLeft(this._renderData.coordinate.left)), this._isVisible || (this.domNode.setVisibility("inherit"), this.domNode.setAttribute("monaco-visible-content-widget", "true"), this._isVisible = !0), typeof this._actual.afterRender == "function" && OD(this._actual.afterRender, this._actual, this._renderData.position);
  }
};
function OD(n, e, ...t) {
  try {
    return n.call(e, ...t);
  } catch {
    return null;
  }
}
let WT = !0;
class E3 extends Dg {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._renderLineHighlight = t.get(
      83
      /* renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      84
      /* renderLineHighlightOnlyWhenFocus */
    ), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._selectionIsEmpty = !0, this._focused = !1, this._cursorLineNumbers = [1], this._selections = [new Ut(1, 1, 1, 1)], this._renderData = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  _readFromSelections() {
    let e = !1;
    const t = WT ? this._selections.slice(0, 1) : this._selections, i = t.map((o) => o.positionLineNumber);
    i.sort((o, s) => o - s), Gu(this._cursorLineNumbers, i) || (this._cursorLineNumbers = i, e = !0);
    const r = t.every((o) => o.isEmpty());
    return this._selectionIsEmpty !== r && (this._selectionIsEmpty = r, e = !0), e;
  }
  // --- begin event handlers
  onThemeChanged(e) {
    return this._readFromSelections();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._renderLineHighlight = t.get(
      83
      /* renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      84
      /* renderLineHighlightOnlyWhenFocus */
    ), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._readFromSelections();
  }
  onFlushed(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollWidthChanged || e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._renderLineHighlightOnlyWhenFocus ? (this._focused = e.isFocused, !0) : !1;
  }
  // --- end event handlers
  prepareRender(e) {
    if (!this._shouldRenderThis()) {
      this._renderData = null;
      return;
    }
    const t = this._renderOne(e), i = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber, o = this._cursorLineNumbers.length;
    let s = 0;
    const a = [];
    for (let l = i; l <= r; l++) {
      const u = l - i;
      for (; s < o && this._cursorLineNumbers[s] < l; )
        s++;
      s < o && this._cursorLineNumbers[s] === l ? a[u] = t : a[u] = "";
    }
    this._renderData = a;
  }
  render(e, t) {
    if (!this._renderData)
      return "";
    const i = t - e;
    return i >= this._renderData.length ? "" : this._renderData[i];
  }
}
class the extends E3 {
  _renderOne(e) {
    return `<div class="${"current-line" + (this._shouldRenderOther() ? " current-line-both" : "")}" style="width:${Math.max(e.scrollWidth, this._contentWidth)}px; height:${this._lineHeight}px;"></div>`;
  }
  _shouldRenderThis() {
    return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
  _shouldRenderOther() {
    return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
}
class ihe extends E3 {
  _renderOne(e) {
    return `<div class="${"current-line" + (this._shouldRenderMargin() ? " current-line-margin" : "") + (this._shouldRenderOther() ? " current-line-margin-both" : "")}" style="width:${this._contentLeft}px; height:${this._lineHeight}px;"></div>`;
  }
  _shouldRenderMargin() {
    return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
  _shouldRenderThis() {
    return !0;
  }
  _shouldRenderOther() {
    return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
}
_a((n, e) => {
  WT = !1;
  const t = n.getColor(Lce);
  if (t && (e.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${t}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${t}; border: none; }`)), !t || t.isTransparent() || n.defines(d2)) {
    const i = n.getColor(d2);
    i && (WT = !0, e.addRule(`.monaco-editor .view-overlays .current-line { border: 2px solid ${i}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { border: 2px solid ${i}; }`), n.type === "hc" && (e.addRule(".monaco-editor .view-overlays .current-line { border-width: 1px; }"), e.addRule(".monaco-editor .margin-view-overlays .current-line-margin { border-width: 1px; }")));
  }
});
class nhe extends Dg {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options;
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    const t = e.getDecorationsInViewport();
    let i = [], r = 0;
    for (let l = 0, u = t.length; l < u; l++) {
      const c = t[l];
      c.options.className && (i[r++] = c);
    }
    i = i.sort((l, u) => {
      if (l.options.zIndex < u.options.zIndex)
        return -1;
      if (l.options.zIndex > u.options.zIndex)
        return 1;
      const c = l.options.className, h = u.options.className;
      return c < h ? -1 : c > h ? 1 : V.compareRangesUsingStarts(l.range, u.range);
    });
    const o = e.visibleRange.startLineNumber, s = e.visibleRange.endLineNumber, a = [];
    for (let l = o; l <= s; l++) {
      const u = l - o;
      a[u] = "";
    }
    this._renderWholeLineDecorations(e, i, a), this._renderNormalDecorations(e, i, a), this._renderResult = a;
  }
  _renderWholeLineDecorations(e, t, i) {
    const r = String(this._lineHeight), o = e.visibleRange.startLineNumber, s = e.visibleRange.endLineNumber;
    for (let a = 0, l = t.length; a < l; a++) {
      const u = t[a];
      if (!u.options.isWholeLine)
        continue;
      const c = '<div class="cdr ' + u.options.className + '" style="left:0;width:100%;height:' + r + 'px;"></div>', h = Math.max(u.range.startLineNumber, o), d = Math.min(u.range.endLineNumber, s);
      for (let f = h; f <= d; f++) {
        const p = f - o;
        i[p] += c;
      }
    }
  }
  _renderNormalDecorations(e, t, i) {
    const r = String(this._lineHeight), o = e.visibleRange.startLineNumber;
    let s = null, a = !1, l = null;
    for (let u = 0, c = t.length; u < c; u++) {
      const h = t[u];
      if (h.options.isWholeLine)
        continue;
      const d = h.options.className, f = !!h.options.showIfCollapsed;
      let p = h.range;
      if (f && p.endColumn === 1 && p.endLineNumber !== p.startLineNumber && (p = new V(p.startLineNumber, p.startColumn, p.endLineNumber - 1, this._context.model.getLineMaxColumn(p.endLineNumber - 1))), s === d && a === f && V.areIntersectingOrTouching(l, p)) {
        l = V.plusRange(l, p);
        continue;
      }
      s !== null && this._renderNormalDecoration(e, l, s, a, r, o, i), s = d, a = f, l = p;
    }
    s !== null && this._renderNormalDecoration(e, l, s, a, r, o, i);
  }
  _renderNormalDecoration(e, t, i, r, o, s, a) {
    const l = e.linesVisibleRangesForRange(
      t,
      /*TODO@Alex*/
      i === "findMatch"
    );
    if (l)
      for (let u = 0, c = l.length; u < c; u++) {
        const h = l[u];
        if (h.outsideRenderedLine)
          continue;
        const d = h.lineNumber - s;
        if (r && h.ranges.length === 1) {
          const f = h.ranges[0];
          f.width === 0 && (h.ranges[0] = new Yc(f.left, this._typicalHalfwidthCharacterWidth));
        }
        for (let f = 0, p = h.ranges.length; f < p; f++) {
          const g = h.ranges[f], _ = '<div class="cdr ' + i + '" style="left:' + String(g.left) + "px;width:" + String(g.width) + "px;height:" + o + 'px;"></div>';
          a[d] += _;
        }
      }
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class S0 extends ge {
  onclick(e, t) {
    this._register(ye(e, Be.CLICK, (i) => t(new ca(i))));
  }
  onmousedown(e, t) {
    this._register(ye(e, Be.MOUSE_DOWN, (i) => t(new ca(i))));
  }
  onmouseover(e, t) {
    this._register(ye(e, Be.MOUSE_OVER, (i) => t(new ca(i))));
  }
  onnonbubblingmouseout(e, t) {
    this._register(wG(e, (i) => t(new ca(i))));
  }
  onkeydown(e, t) {
    this._register(ye(e, Be.KEY_DOWN, (i) => t(new Ki(i))));
  }
  onkeyup(e, t) {
    this._register(ye(e, Be.KEY_UP, (i) => t(new Ki(i))));
  }
  oninput(e, t) {
    this._register(ye(e, Be.INPUT, t));
  }
  onblur(e, t) {
    this._register(ye(e, Be.BLUR, t));
  }
  onfocus(e, t) {
    this._register(ye(e, Be.FOCUS, t));
  }
  ignoreGesture(e) {
    ri.ignoreTarget(e);
  }
}
const Yp = 11;
class rhe extends S0 {
  constructor(e) {
    super(), this._onActivate = e.onActivate, this.bgDomNode = document.createElement("div"), this.bgDomNode.className = "arrow-background", this.bgDomNode.style.position = "absolute", this.bgDomNode.style.width = e.bgWidth + "px", this.bgDomNode.style.height = e.bgHeight + "px", typeof e.top < "u" && (this.bgDomNode.style.top = "0px"), typeof e.left < "u" && (this.bgDomNode.style.left = "0px"), typeof e.bottom < "u" && (this.bgDomNode.style.bottom = "0px"), typeof e.right < "u" && (this.bgDomNode.style.right = "0px"), this.domNode = document.createElement("div"), this.domNode.className = e.className, this.domNode.classList.add(...e.icon.classNamesArray), this.domNode.style.position = "absolute", this.domNode.style.width = Yp + "px", this.domNode.style.height = Yp + "px", typeof e.top < "u" && (this.domNode.style.top = e.top + "px"), typeof e.left < "u" && (this.domNode.style.left = e.left + "px"), typeof e.bottom < "u" && (this.domNode.style.bottom = e.bottom + "px"), typeof e.right < "u" && (this.domNode.style.right = e.right + "px"), this._mouseMoveMonitor = this._register(new m0()), this.onmousedown(this.bgDomNode, (t) => this._arrowMouseDown(t)), this.onmousedown(this.domNode, (t) => this._arrowMouseDown(t)), this._mousedownRepeatTimer = this._register(new F_()), this._mousedownScheduleRepeatTimer = this._register(new ec());
  }
  _arrowMouseDown(e) {
    const t = () => {
      this._mousedownRepeatTimer.cancelAndSet(() => this._onActivate(), 41.666666666666664);
    };
    this._onActivate(), this._mousedownRepeatTimer.cancel(), this._mousedownScheduleRepeatTimer.cancelAndSet(t, 200), this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, zN, (i) => {
    }, () => {
      this._mousedownRepeatTimer.cancel(), this._mousedownScheduleRepeatTimer.cancel();
    }), e.preventDefault();
  }
}
class ohe extends ge {
  constructor(e, t, i) {
    super(), this._visibility = e, this._visibleClassName = t, this._invisibleClassName = i, this._domNode = null, this._isVisible = !1, this._isNeeded = !1, this._shouldBeVisible = !1, this._revealTimer = this._register(new ec());
  }
  // ----------------- Hide / Reveal
  applyVisibilitySetting(e) {
    return this._visibility === 2 ? !1 : this._visibility === 3 ? !0 : e;
  }
  setShouldBeVisible(e) {
    const t = this.applyVisibilitySetting(e);
    this._shouldBeVisible !== t && (this._shouldBeVisible = t, this.ensureVisibility());
  }
  setIsNeeded(e) {
    this._isNeeded !== e && (this._isNeeded = e, this.ensureVisibility());
  }
  setDomNode(e) {
    this._domNode = e, this._domNode.setClassName(this._invisibleClassName), this.setShouldBeVisible(!1);
  }
  ensureVisibility() {
    if (!this._isNeeded) {
      this._hide(!1);
      return;
    }
    this._shouldBeVisible ? this._reveal() : this._hide(!0);
  }
  _reveal() {
    this._isVisible || (this._isVisible = !0, this._revealTimer.setIfNotSet(() => {
      this._domNode && this._domNode.setClassName(this._visibleClassName);
    }, 0));
  }
  _hide(e) {
    this._revealTimer.cancel(), this._isVisible && (this._isVisible = !1, this._domNode && this._domNode.setClassName(this._invisibleClassName + (e ? " fade" : "")));
  }
}
const she = 140;
class L3 extends S0 {
  constructor(e) {
    super(), this._lazyRender = e.lazyRender, this._host = e.host, this._scrollable = e.scrollable, this._scrollByPage = e.scrollByPage, this._scrollbarState = e.scrollbarState, this._visibilityController = this._register(new ohe(e.visibility, "visible scrollbar " + e.extraScrollbarClassName, "invisible scrollbar " + e.extraScrollbarClassName)), this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._mouseMoveMonitor = this._register(new m0()), this._shouldRender = !0, this.domNode = bt(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this._visibilityController.setDomNode(this.domNode), this.domNode.setPosition("absolute"), this.onmousedown(this.domNode.domNode, (t) => this._domNodeMouseDown(t));
  }
  // ----------------- creation
  /**
   * Creates the dom node for an arrow & adds it to the container
   */
  _createArrow(e) {
    const t = this._register(new rhe(e));
    this.domNode.domNode.appendChild(t.bgDomNode), this.domNode.domNode.appendChild(t.domNode);
  }
  /**
   * Creates the slider dom node, adds it to the container & hooks up the events
   */
  _createSlider(e, t, i, r) {
    this.slider = bt(document.createElement("div")), this.slider.setClassName("slider"), this.slider.setPosition("absolute"), this.slider.setTop(e), this.slider.setLeft(t), typeof i == "number" && this.slider.setWidth(i), typeof r == "number" && this.slider.setHeight(r), this.slider.setLayerHinting(!0), this.slider.setContain("strict"), this.domNode.domNode.appendChild(this.slider.domNode), this.onmousedown(this.slider.domNode, (o) => {
      o.leftButton && (o.preventDefault(), this._sliderMouseDown(o, () => {
      }));
    }), this.onclick(this.slider.domNode, (o) => {
      o.leftButton && o.stopPropagation();
    });
  }
  // ----------------- Update state
  _onElementSize(e) {
    return this._scrollbarState.setVisibleSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollSize(e) {
    return this._scrollbarState.setScrollSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollPosition(e) {
    return this._scrollbarState.setScrollPosition(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  // ----------------- rendering
  beginReveal() {
    this._visibilityController.setShouldBeVisible(!0);
  }
  beginHide() {
    this._visibilityController.setShouldBeVisible(!1);
  }
  render() {
    this._shouldRender && (this._shouldRender = !1, this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize()), this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition()));
  }
  // ----------------- DOM events
  _domNodeMouseDown(e) {
    e.target === this.domNode.domNode && this._onMouseDown(e);
  }
  delegateMouseDown(e) {
    const t = this.domNode.domNode.getClientRects()[0].top, i = t + this._scrollbarState.getSliderPosition(), r = t + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize(), o = this._sliderMousePosition(e);
    i <= o && o <= r ? e.leftButton && (e.preventDefault(), this._sliderMouseDown(e, () => {
    })) : this._onMouseDown(e);
  }
  _onMouseDown(e) {
    let t, i;
    if (e.target === this.domNode.domNode && typeof e.browserEvent.offsetX == "number" && typeof e.browserEvent.offsetY == "number")
      t = e.browserEvent.offsetX, i = e.browserEvent.offsetY;
    else {
      const o = ja(this.domNode.domNode);
      t = e.posx - o.left, i = e.posy - o.top;
    }
    const r = this._mouseDownRelativePosition(t, i);
    this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(r) : this._scrollbarState.getDesiredScrollPositionFromOffset(r)), e.leftButton && (e.preventDefault(), this._sliderMouseDown(e, () => {
    }));
  }
  _sliderMouseDown(e, t) {
    const i = this._sliderMousePosition(e), r = this._sliderOrthogonalMousePosition(e), o = this._scrollbarState.clone();
    this.slider.toggleClassName("active", !0), this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, zN, (s) => {
      const a = this._sliderOrthogonalMousePosition(s), l = Math.abs(a - r);
      if (Eo && l > she) {
        this._setDesiredScrollPositionNow(o.getScrollPosition());
        return;
      }
      const c = this._sliderMousePosition(s) - i;
      this._setDesiredScrollPositionNow(o.getDesiredScrollPositionFromDelta(c));
    }, () => {
      this.slider.toggleClassName("active", !1), this._host.onDragEnd(), t();
    }), this._host.onDragStart();
  }
  _setDesiredScrollPositionNow(e) {
    const t = {};
    this.writeScrollPosition(t, e), this._scrollable.setScrollPositionNow(t);
  }
  updateScrollbarSize(e) {
    this._updateScrollbarSize(e), this._scrollbarState.setScrollbarSize(e), this._shouldRender = !0, this._lazyRender || this.render();
  }
  isNeeded() {
    return this._scrollbarState.isNeeded();
  }
}
const ahe = 20;
class Jv {
  constructor(e, t, i, r, o, s) {
    this._scrollbarSize = Math.round(t), this._oppositeScrollbarSize = Math.round(i), this._arrowSize = Math.round(e), this._visibleSize = r, this._scrollSize = o, this._scrollPosition = s, this._computedAvailableSize = 0, this._computedIsNeeded = !1, this._computedSliderSize = 0, this._computedSliderRatio = 0, this._computedSliderPosition = 0, this._refreshComputedValues();
  }
  clone() {
    return new Jv(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
  }
  setVisibleSize(e) {
    const t = Math.round(e);
    return this._visibleSize !== t ? (this._visibleSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollSize(e) {
    const t = Math.round(e);
    return this._scrollSize !== t ? (this._scrollSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollPosition(e) {
    const t = Math.round(e);
    return this._scrollPosition !== t ? (this._scrollPosition = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollbarSize(e) {
    this._scrollbarSize = e;
  }
  static _computeValues(e, t, i, r, o) {
    const s = Math.max(0, i - e), a = Math.max(0, s - 2 * t), l = r > 0 && r > i;
    if (!l)
      return {
        computedAvailableSize: Math.round(s),
        computedIsNeeded: l,
        computedSliderSize: Math.round(a),
        computedSliderRatio: 0,
        computedSliderPosition: 0
      };
    const u = Math.round(Math.max(ahe, Math.floor(i * a / r))), c = (a - u) / (r - i), h = o * c;
    return {
      computedAvailableSize: Math.round(s),
      computedIsNeeded: l,
      computedSliderSize: Math.round(u),
      computedSliderRatio: c,
      computedSliderPosition: Math.round(h)
    };
  }
  _refreshComputedValues() {
    const e = Jv._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    this._computedAvailableSize = e.computedAvailableSize, this._computedIsNeeded = e.computedIsNeeded, this._computedSliderSize = e.computedSliderSize, this._computedSliderRatio = e.computedSliderRatio, this._computedSliderPosition = e.computedSliderPosition;
  }
  getArrowSize() {
    return this._arrowSize;
  }
  getScrollPosition() {
    return this._scrollPosition;
  }
  getRectangleLargeSize() {
    return this._computedAvailableSize;
  }
  getRectangleSmallSize() {
    return this._scrollbarSize;
  }
  isNeeded() {
    return this._computedIsNeeded;
  }
  getSliderSize() {
    return this._computedSliderSize;
  }
  getSliderPosition() {
    return this._computedSliderPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.
   * `offset` is based on the same coordinate system as the `sliderPosition`.
   */
  getDesiredScrollPositionFromOffset(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize - this._computedSliderSize / 2;
    return Math.round(t / this._computedSliderRatio);
  }
  /**
   * Compute a desired `scrollPosition` from if offset is before or after the slider position.
   * If offset is before slider, treat as a page up (or left).  If after, page down (or right).
   * `offset` and `_computedSliderPosition` are based on the same coordinate system.
   * `_visibleSize` corresponds to a "page" of lines in the returned coordinate system.
   */
  getDesiredScrollPositionFromOffsetPaged(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize;
    let i = this._scrollPosition;
    return t < this._computedSliderPosition ? i -= this._visibleSize : i += this._visibleSize, i;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollPositionFromDelta(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = this._computedSliderPosition + e;
    return Math.round(t / this._computedSliderRatio);
  }
}
const lhe = va("scrollbar-button-left", Vi.triangleLeft), uhe = va("scrollbar-button-right", Vi.triangleRight);
class che extends L3 {
  constructor(e, t, i) {
    const r = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new Jv(t.horizontalHasArrows ? t.arrowSize : 0, t.horizontal === 2 ? 0 : t.horizontalScrollbarSize, t.vertical === 2 ? 0 : t.verticalScrollbarSize, r.width, r.scrollWidth, o.scrollLeft),
      visibility: t.horizontal,
      extraScrollbarClassName: "horizontal",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.horizontalHasArrows) {
      const s = (t.arrowSize - Yp) / 2, a = (t.horizontalScrollbarSize - Yp) / 2;
      this._createArrow({
        className: "scra",
        icon: lhe,
        top: a,
        left: s,
        bottom: void 0,
        right: void 0,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new Vp(null, 1, 0))
      }), this._createArrow({
        className: "scra",
        icon: uhe,
        top: a,
        left: void 0,
        bottom: void 0,
        right: s,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new Vp(null, -1, 0))
      });
    }
    this._createSlider(Math.floor((t.horizontalScrollbarSize - t.horizontalSliderSize) / 2), 0, void 0, t.horizontalSliderSize);
  }
  _updateSlider(e, t) {
    this.slider.setWidth(e), this.slider.setLeft(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(e), this.domNode.setHeight(t), this.domNode.setLeft(0), this.domNode.setBottom(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender, this._shouldRender = this._onElementSize(e.width) || this._shouldRender, this._shouldRender;
  }
  _mouseDownRelativePosition(e, t) {
    return e;
  }
  _sliderMousePosition(e) {
    return e.posx;
  }
  _sliderOrthogonalMousePosition(e) {
    return e.posy;
  }
  _updateScrollbarSize(e) {
    this.slider.setHeight(e);
  }
  writeScrollPosition(e, t) {
    e.scrollLeft = t;
  }
}
const hhe = va("scrollbar-button-up", Vi.triangleUp), dhe = va("scrollbar-button-down", Vi.triangleDown);
class fhe extends L3 {
  constructor(e, t, i) {
    const r = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new Jv(
        t.verticalHasArrows ? t.arrowSize : 0,
        t.vertical === 2 ? 0 : t.verticalScrollbarSize,
        // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
        0,
        r.height,
        r.scrollHeight,
        o.scrollTop
      ),
      visibility: t.vertical,
      extraScrollbarClassName: "vertical",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.verticalHasArrows) {
      const s = (t.arrowSize - Yp) / 2, a = (t.verticalScrollbarSize - Yp) / 2;
      this._createArrow({
        className: "scra",
        icon: hhe,
        top: s,
        left: a,
        bottom: void 0,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new Vp(null, 0, 1))
      }), this._createArrow({
        className: "scra",
        icon: dhe,
        top: void 0,
        left: a,
        bottom: s,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new Vp(null, 0, -1))
      });
    }
    this._createSlider(0, Math.floor((t.verticalScrollbarSize - t.verticalSliderSize) / 2), t.verticalSliderSize, void 0);
  }
  _updateSlider(e, t) {
    this.slider.setHeight(e), this.slider.setTop(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(t), this.domNode.setHeight(e), this.domNode.setRight(0), this.domNode.setTop(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender, this._shouldRender = this._onElementSize(e.height) || this._shouldRender, this._shouldRender;
  }
  _mouseDownRelativePosition(e, t) {
    return t;
  }
  _sliderMousePosition(e) {
    return e.posy;
  }
  _sliderOrthogonalMousePosition(e) {
    return e.posx;
  }
  _updateScrollbarSize(e) {
    this.slider.setWidth(e);
  }
  writeScrollPosition(e, t) {
    e.scrollTop = t;
  }
}
class Vb {
  constructor(e, t, i, r, o, s) {
    e = e | 0, t = t | 0, i = i | 0, r = r | 0, o = o | 0, s = s | 0, this.rawScrollLeft = i, this.rawScrollTop = s, e < 0 && (e = 0), i + e > t && (i = t - e), i < 0 && (i = 0), r < 0 && (r = 0), s + r > o && (s = o - r), s < 0 && (s = 0), this.width = e, this.scrollWidth = t, this.scrollLeft = i, this.height = r, this.scrollHeight = o, this.scrollTop = s;
  }
  equals(e) {
    return this.rawScrollLeft === e.rawScrollLeft && this.rawScrollTop === e.rawScrollTop && this.width === e.width && this.scrollWidth === e.scrollWidth && this.scrollLeft === e.scrollLeft && this.height === e.height && this.scrollHeight === e.scrollHeight && this.scrollTop === e.scrollTop;
  }
  withScrollDimensions(e, t) {
    return new Vb(typeof e.width < "u" ? e.width : this.width, typeof e.scrollWidth < "u" ? e.scrollWidth : this.scrollWidth, t ? this.rawScrollLeft : this.scrollLeft, typeof e.height < "u" ? e.height : this.height, typeof e.scrollHeight < "u" ? e.scrollHeight : this.scrollHeight, t ? this.rawScrollTop : this.scrollTop);
  }
  withScrollPosition(e) {
    return new Vb(this.width, this.scrollWidth, typeof e.scrollLeft < "u" ? e.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof e.scrollTop < "u" ? e.scrollTop : this.rawScrollTop);
  }
  createScrollEvent(e, t) {
    const i = this.width !== e.width, r = this.scrollWidth !== e.scrollWidth, o = this.scrollLeft !== e.scrollLeft, s = this.height !== e.height, a = this.scrollHeight !== e.scrollHeight, l = this.scrollTop !== e.scrollTop;
    return {
      inSmoothScrolling: t,
      oldWidth: e.width,
      oldScrollWidth: e.scrollWidth,
      oldScrollLeft: e.scrollLeft,
      width: this.width,
      scrollWidth: this.scrollWidth,
      scrollLeft: this.scrollLeft,
      oldHeight: e.height,
      oldScrollHeight: e.scrollHeight,
      oldScrollTop: e.scrollTop,
      height: this.height,
      scrollHeight: this.scrollHeight,
      scrollTop: this.scrollTop,
      widthChanged: i,
      scrollWidthChanged: r,
      scrollLeftChanged: o,
      heightChanged: s,
      scrollHeightChanged: a,
      scrollTopChanged: l
    };
  }
}
class E0 extends ge {
  constructor(e, t) {
    super(), this._onScroll = this._register(new j()), this.onScroll = this._onScroll.event, this._smoothScrollDuration = e, this._scheduleAtNextAnimationFrame = t, this._state = new Vb(0, 0, 0, 0, 0, 0), this._smoothScrolling = null;
  }
  dispose() {
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), super.dispose();
  }
  setSmoothScrollDuration(e) {
    this._smoothScrollDuration = e;
  }
  validateScrollPosition(e) {
    return this._state.withScrollPosition(e);
  }
  getScrollDimensions() {
    return this._state;
  }
  setScrollDimensions(e, t) {
    const i = this._state.withScrollDimensions(e, t);
    this._setState(i, !!this._smoothScrolling), this._smoothScrolling && this._smoothScrolling.acceptScrollDimensions(this._state);
  }
  /**
   * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
   * If no scroll animation is occurring, it will return the current scroll position instead.
   */
  getFutureScrollPosition() {
    return this._smoothScrolling ? this._smoothScrolling.to : this._state;
  }
  /**
   * Returns the current scroll position.
   * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
   */
  getCurrentScrollPosition() {
    return this._state;
  }
  setScrollPositionNow(e) {
    const t = this._state.withScrollPosition(e);
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), this._setState(t, !1);
  }
  setScrollPositionSmooth(e, t) {
    if (this._smoothScrollDuration === 0)
      return this.setScrollPositionNow(e);
    if (this._smoothScrolling) {
      e = {
        scrollLeft: typeof e.scrollLeft > "u" ? this._smoothScrolling.to.scrollLeft : e.scrollLeft,
        scrollTop: typeof e.scrollTop > "u" ? this._smoothScrolling.to.scrollTop : e.scrollTop
      };
      const i = this._state.withScrollPosition(e);
      if (this._smoothScrolling.to.scrollLeft === i.scrollLeft && this._smoothScrolling.to.scrollTop === i.scrollTop)
        return;
      let r;
      t ? r = new e_(this._smoothScrolling.from, i, this._smoothScrolling.startTime, this._smoothScrolling.duration) : r = this._smoothScrolling.combine(this._state, i, this._smoothScrollDuration), this._smoothScrolling.dispose(), this._smoothScrolling = r;
    } else {
      const i = this._state.withScrollPosition(e);
      this._smoothScrolling = e_.start(this._state, i, this._smoothScrollDuration);
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
    });
  }
  _performSmoothScrolling() {
    if (!this._smoothScrolling)
      return;
    const e = this._smoothScrolling.tick(), t = this._state.withScrollPosition(e);
    if (this._setState(t, !0), !!this._smoothScrolling) {
      if (e.isDone) {
        this._smoothScrolling.dispose(), this._smoothScrolling = null;
        return;
      }
      this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
        this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
      });
    }
  }
  _setState(e, t) {
    const i = this._state;
    i.equals(e) || (this._state = e, this._onScroll.fire(this._state.createScrollEvent(i, t)));
  }
}
class _2 {
  constructor(e, t, i) {
    this.scrollLeft = e, this.scrollTop = t, this.isDone = i;
  }
}
function xD(n, e) {
  const t = e - n;
  return function(i) {
    return n + t * mhe(i);
  };
}
function phe(n, e, t) {
  return function(i) {
    return i < t ? n(i / t) : e((i - t) / (1 - t));
  };
}
class e_ {
  constructor(e, t, i, r) {
    this.from = e, this.to = t, this.duration = r, this.startTime = i, this.animationFrameDisposable = null, this._initAnimations();
  }
  _initAnimations() {
    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width), this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
  }
  _initAnimation(e, t, i) {
    if (Math.abs(e - t) > 2.5 * i) {
      let o, s;
      return e < t ? (o = e + 0.75 * i, s = t - 0.75 * i) : (o = e - 0.75 * i, s = t + 0.75 * i), phe(xD(e, o), xD(s, t), 0.33);
    }
    return xD(e, t);
  }
  dispose() {
    this.animationFrameDisposable !== null && (this.animationFrameDisposable.dispose(), this.animationFrameDisposable = null);
  }
  acceptScrollDimensions(e) {
    this.to = e.withScrollPosition(this.to), this._initAnimations();
  }
  tick() {
    return this._tick(Date.now());
  }
  _tick(e) {
    const t = (e - this.startTime) / this.duration;
    if (t < 1) {
      const i = this.scrollLeft(t), r = this.scrollTop(t);
      return new _2(i, r, !1);
    }
    return new _2(this.to.scrollLeft, this.to.scrollTop, !0);
  }
  combine(e, t, i) {
    return e_.start(e, t, i);
  }
  static start(e, t, i) {
    i = i + 10;
    const r = Date.now() - 10;
    return new e_(e, t, r, i);
  }
}
function ghe(n) {
  return Math.pow(n, 3);
}
function mhe(n) {
  return 1 - ghe(1 - n);
}
const vhe = 500, C2 = 50;
class _he {
  constructor(e, t, i) {
    this.timestamp = e, this.deltaX = t, this.deltaY = i, this.score = 0;
  }
}
class VT {
  constructor() {
    this._capacity = 5, this._memory = [], this._front = -1, this._rear = -1;
  }
  isPhysicalMouseWheel() {
    if (this._front === -1 && this._rear === -1)
      return !1;
    let e = 1, t = 0, i = 1, r = this._rear;
    do {
      const o = r === this._front ? e : Math.pow(2, -i);
      if (e -= o, t += this._memory[r].score * o, r === this._front)
        break;
      r = (this._capacity + r - 1) % this._capacity, i++;
    } while (!0);
    return t <= 0.5;
  }
  accept(e, t, i) {
    const r = new _he(e, t, i);
    r.score = this._computeScore(r), this._front === -1 && this._rear === -1 ? (this._memory[0] = r, this._front = 0, this._rear = 0) : (this._rear = (this._rear + 1) % this._capacity, this._rear === this._front && (this._front = (this._front + 1) % this._capacity), this._memory[this._rear] = r);
  }
  /**
   * A score between 0 and 1 for `item`.
   *  - a score towards 0 indicates that the source appears to be a physical mouse wheel
   *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.
   */
  _computeScore(e) {
    if (Math.abs(e.deltaX) > 0 && Math.abs(e.deltaY) > 0)
      return 1;
    let t = 0.5;
    return this._front === -1 && this._rear === -1 || this._memory[this._rear], (!this._isAlmostInt(e.deltaX) || !this._isAlmostInt(e.deltaY)) && (t += 0.25), Math.min(Math.max(t, 0), 1);
  }
  _isAlmostInt(e) {
    return Math.abs(Math.round(e) - e) < 0.01;
  }
}
VT.INSTANCE = new VT();
class D3 extends S0 {
  constructor(e, t, i) {
    super(), this._onScroll = this._register(new j()), this.onScroll = this._onScroll.event, this._onWillScroll = this._register(new j()), e.style.overflow = "hidden", this._options = Che(t), this._scrollable = i, this._register(this._scrollable.onScroll((o) => {
      this._onWillScroll.fire(o), this._onDidScroll(o), this._onScroll.fire(o);
    }));
    const r = {
      onMouseWheel: (o) => this._onMouseWheel(o),
      onDragStart: () => this._onDragStart(),
      onDragEnd: () => this._onDragEnd()
    };
    this._verticalScrollbar = this._register(new fhe(this._scrollable, this._options, r)), this._horizontalScrollbar = this._register(new che(this._scrollable, this._options, r)), this._domNode = document.createElement("div"), this._domNode.className = "monaco-scrollable-element " + this._options.className, this._domNode.setAttribute("role", "presentation"), this._domNode.style.position = "relative", this._domNode.style.overflow = "hidden", this._domNode.appendChild(e), this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode), this._domNode.appendChild(this._verticalScrollbar.domNode.domNode), this._options.useShadows ? (this._leftShadowDomNode = bt(document.createElement("div")), this._leftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._leftShadowDomNode.domNode), this._topShadowDomNode = bt(document.createElement("div")), this._topShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topShadowDomNode.domNode), this._topLeftShadowDomNode = bt(document.createElement("div")), this._topLeftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topLeftShadowDomNode.domNode)) : (this._leftShadowDomNode = null, this._topShadowDomNode = null, this._topLeftShadowDomNode = null), this._listenOnDomNode = this._options.listenOnDomNode || this._domNode, this._mouseWheelToDispose = [], this._setListeningToMouseWheel(this._options.handleMouseWheel), this.onmouseover(this._listenOnDomNode, (o) => this._onMouseOver(o)), this.onnonbubblingmouseout(this._listenOnDomNode, (o) => this._onMouseOut(o)), this._hideTimeout = this._register(new ec()), this._isDragging = !1, this._mouseIsOver = !1, this._shouldRender = !0, this._revealOnScroll = !0;
  }
  dispose() {
    this._mouseWheelToDispose = yi(this._mouseWheelToDispose), super.dispose();
  }
  /**
   * Get the generated 'scrollable' dom node
   */
  getDomNode() {
    return this._domNode;
  }
  getOverviewRulerLayoutInfo() {
    return {
      parent: this._domNode,
      insertBefore: this._verticalScrollbar.domNode.domNode
    };
  }
  /**
   * Delegate a mouse down event to the vertical scrollbar.
   * This is to help with clicking somewhere else and having the scrollbar react.
   */
  delegateVerticalScrollbarMouseDown(e) {
    this._verticalScrollbar.delegateMouseDown(e);
  }
  getScrollDimensions() {
    return this._scrollable.getScrollDimensions();
  }
  setScrollDimensions(e) {
    this._scrollable.setScrollDimensions(e, !1);
  }
  /**
   * Update the class name of the scrollable element.
   */
  updateClassName(e) {
    this._options.className = e, Ft && (this._options.className += " mac"), this._domNode.className = "monaco-scrollable-element " + this._options.className;
  }
  /**
   * Update configuration options for the scrollbar.
   * Really this is Editor.IEditorScrollbarOptions, but base shouldn't
   * depend on Editor.
   */
  updateOptions(e) {
    typeof e.handleMouseWheel < "u" && (this._options.handleMouseWheel = e.handleMouseWheel, this._setListeningToMouseWheel(this._options.handleMouseWheel)), typeof e.mouseWheelScrollSensitivity < "u" && (this._options.mouseWheelScrollSensitivity = e.mouseWheelScrollSensitivity), typeof e.fastScrollSensitivity < "u" && (this._options.fastScrollSensitivity = e.fastScrollSensitivity), typeof e.scrollPredominantAxis < "u" && (this._options.scrollPredominantAxis = e.scrollPredominantAxis), typeof e.horizontalScrollbarSize < "u" && this._horizontalScrollbar.updateScrollbarSize(e.horizontalScrollbarSize), this._options.lazyRender || this._render();
  }
  // -------------------- mouse wheel scrolling --------------------
  _setListeningToMouseWheel(e) {
    if (this._mouseWheelToDispose.length > 0 !== e && (this._mouseWheelToDispose = yi(this._mouseWheelToDispose), e)) {
      const i = (r) => {
        this._onMouseWheel(new Vp(r));
      };
      this._mouseWheelToDispose.push(ye(this._listenOnDomNode, Be.MOUSE_WHEEL, i, { passive: !1 }));
    }
  }
  _onMouseWheel(e) {
    const t = VT.INSTANCE;
    {
      const o = window.devicePixelRatio / Cne();
      Eo || Rs ? t.accept(Date.now(), e.deltaX / o, e.deltaY / o) : t.accept(Date.now(), e.deltaX, e.deltaY);
    }
    let i = !1;
    if (e.deltaY || e.deltaX) {
      let o = e.deltaY * this._options.mouseWheelScrollSensitivity, s = e.deltaX * this._options.mouseWheelScrollSensitivity;
      this._options.scrollPredominantAxis && (Math.abs(o) >= Math.abs(s) ? s = 0 : o = 0), this._options.flipAxes && ([o, s] = [s, o]);
      const a = !Ft && e.browserEvent && e.browserEvent.shiftKey;
      (this._options.scrollYToX || a) && !s && (s = o, o = 0), e.browserEvent && e.browserEvent.altKey && (s = s * this._options.fastScrollSensitivity, o = o * this._options.fastScrollSensitivity);
      const l = this._scrollable.getFutureScrollPosition();
      let u = {};
      if (o) {
        const c = l.scrollTop - C2 * o;
        this._verticalScrollbar.writeScrollPosition(u, c);
      }
      if (s) {
        const c = l.scrollLeft - C2 * s;
        this._horizontalScrollbar.writeScrollPosition(u, c);
      }
      u = this._scrollable.validateScrollPosition(u), (l.scrollLeft !== u.scrollLeft || l.scrollTop !== u.scrollTop) && (this._options.mouseWheelSmoothScroll && t.isPhysicalMouseWheel() ? this._scrollable.setScrollPositionSmooth(u) : this._scrollable.setScrollPositionNow(u), i = !0);
    }
    let r = i;
    !r && this._options.alwaysConsumeMouseWheel && (r = !0), !r && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded()) && (r = !0), r && (e.preventDefault(), e.stopPropagation());
  }
  _onDidScroll(e) {
    this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender, this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender, this._options.useShadows && (this._shouldRender = !0), this._revealOnScroll && this._reveal(), this._options.lazyRender || this._render();
  }
  /**
   * Render / mutate the DOM now.
   * Should be used together with the ctor option `lazyRender`.
   */
  renderNow() {
    if (!this._options.lazyRender)
      throw new Error("Please use `lazyRender` together with `renderNow`!");
    this._render();
  }
  _render() {
    if (this._shouldRender && (this._shouldRender = !1, this._horizontalScrollbar.render(), this._verticalScrollbar.render(), this._options.useShadows)) {
      const e = this._scrollable.getCurrentScrollPosition(), t = e.scrollTop > 0, i = e.scrollLeft > 0, r = i ? " left" : "", o = t ? " top" : "", s = i || t ? " top-left-corner" : "";
      this._leftShadowDomNode.setClassName(`shadow${r}`), this._topShadowDomNode.setClassName(`shadow${o}`), this._topLeftShadowDomNode.setClassName(`shadow${s}${o}${r}`);
    }
  }
  // -------------------- fade in / fade out --------------------
  _onDragStart() {
    this._isDragging = !0, this._reveal();
  }
  _onDragEnd() {
    this._isDragging = !1, this._hide();
  }
  _onMouseOut(e) {
    this._mouseIsOver = !1, this._hide();
  }
  _onMouseOver(e) {
    this._mouseIsOver = !0, this._reveal();
  }
  _reveal() {
    this._verticalScrollbar.beginReveal(), this._horizontalScrollbar.beginReveal(), this._scheduleHide();
  }
  _hide() {
    !this._mouseIsOver && !this._isDragging && (this._verticalScrollbar.beginHide(), this._horizontalScrollbar.beginHide());
  }
  _scheduleHide() {
    !this._mouseIsOver && !this._isDragging && this._hideTimeout.cancelAndSet(() => this._hide(), vhe);
  }
}
class R3 extends D3 {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new E0(0, (r) => zl(r));
    super(e, t, i), this._register(i);
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
}
class iI extends D3 {
  constructor(e, t, i) {
    super(e, t, i);
  }
  setScrollPosition(e) {
    e.reuseAnimation ? this._scrollable.setScrollPositionSmooth(e, e.reuseAnimation) : this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
}
class T3 extends R3 {
  constructor(e, t) {
    super(e, t), this._element = e, this.onScroll((i) => {
      i.scrollTopChanged && (this._element.scrollTop = i.scrollTop), i.scrollLeftChanged && (this._element.scrollLeft = i.scrollLeft);
    }), this.scanDomNode();
  }
  scanDomNode() {
    this.setScrollDimensions({
      width: this._element.clientWidth,
      scrollWidth: this._element.scrollWidth,
      height: this._element.clientHeight,
      scrollHeight: this._element.scrollHeight
    }), this.setScrollPosition({
      scrollLeft: this._element.scrollLeft,
      scrollTop: this._element.scrollTop
    });
  }
}
function Che(n) {
  const e = {
    lazyRender: typeof n.lazyRender < "u" ? n.lazyRender : !1,
    className: typeof n.className < "u" ? n.className : "",
    useShadows: typeof n.useShadows < "u" ? n.useShadows : !0,
    handleMouseWheel: typeof n.handleMouseWheel < "u" ? n.handleMouseWheel : !0,
    flipAxes: typeof n.flipAxes < "u" ? n.flipAxes : !1,
    consumeMouseWheelIfScrollbarIsNeeded: typeof n.consumeMouseWheelIfScrollbarIsNeeded < "u" ? n.consumeMouseWheelIfScrollbarIsNeeded : !1,
    alwaysConsumeMouseWheel: typeof n.alwaysConsumeMouseWheel < "u" ? n.alwaysConsumeMouseWheel : !1,
    scrollYToX: typeof n.scrollYToX < "u" ? n.scrollYToX : !1,
    mouseWheelScrollSensitivity: typeof n.mouseWheelScrollSensitivity < "u" ? n.mouseWheelScrollSensitivity : 1,
    fastScrollSensitivity: typeof n.fastScrollSensitivity < "u" ? n.fastScrollSensitivity : 5,
    scrollPredominantAxis: typeof n.scrollPredominantAxis < "u" ? n.scrollPredominantAxis : !0,
    mouseWheelSmoothScroll: typeof n.mouseWheelSmoothScroll < "u" ? n.mouseWheelSmoothScroll : !0,
    arrowSize: typeof n.arrowSize < "u" ? n.arrowSize : 11,
    listenOnDomNode: typeof n.listenOnDomNode < "u" ? n.listenOnDomNode : null,
    horizontal: typeof n.horizontal < "u" ? n.horizontal : 1,
    horizontalScrollbarSize: typeof n.horizontalScrollbarSize < "u" ? n.horizontalScrollbarSize : 10,
    horizontalSliderSize: typeof n.horizontalSliderSize < "u" ? n.horizontalSliderSize : 0,
    horizontalHasArrows: typeof n.horizontalHasArrows < "u" ? n.horizontalHasArrows : !1,
    vertical: typeof n.vertical < "u" ? n.vertical : 1,
    verticalScrollbarSize: typeof n.verticalScrollbarSize < "u" ? n.verticalScrollbarSize : 10,
    verticalHasArrows: typeof n.verticalHasArrows < "u" ? n.verticalHasArrows : !1,
    verticalSliderSize: typeof n.verticalSliderSize < "u" ? n.verticalSliderSize : 0,
    scrollByPage: typeof n.scrollByPage < "u" ? n.scrollByPage : !1
  };
  return e.horizontalSliderSize = typeof n.horizontalSliderSize < "u" ? n.horizontalSliderSize : e.horizontalScrollbarSize, e.verticalSliderSize = typeof n.verticalSliderSize < "u" ? n.verticalSliderSize : e.verticalScrollbarSize, Ft && (e.className += " mac"), e;
}
class yhe extends Ns {
  constructor(e, t, i, r) {
    super(e);
    const o = this._context.configuration.options, s = o.get(
      90
      /* scrollbar */
    ), a = o.get(
      64
      /* mouseWheelScrollSensitivity */
    ), l = o.get(
      32
      /* fastScrollSensitivity */
    ), u = o.get(
      93
      /* scrollPredominantAxis */
    ), c = {
      listenOnDomNode: i.domNode,
      className: "editor-scrollable " + Ob(e.theme.type),
      useShadows: !1,
      lazyRender: !0,
      vertical: s.vertical,
      horizontal: s.horizontal,
      verticalHasArrows: s.verticalHasArrows,
      horizontalHasArrows: s.horizontalHasArrows,
      verticalScrollbarSize: s.verticalScrollbarSize,
      verticalSliderSize: s.verticalSliderSize,
      horizontalScrollbarSize: s.horizontalScrollbarSize,
      horizontalSliderSize: s.horizontalSliderSize,
      handleMouseWheel: s.handleMouseWheel,
      alwaysConsumeMouseWheel: s.alwaysConsumeMouseWheel,
      arrowSize: s.arrowSize,
      mouseWheelScrollSensitivity: a,
      fastScrollSensitivity: l,
      scrollPredominantAxis: u,
      scrollByPage: s.scrollByPage
    };
    this.scrollbar = this._register(new iI(t.domNode, c, this._context.viewLayout.getScrollable())), jl.write(
      this.scrollbar.getDomNode(),
      5
      /* ScrollableElement */
    ), this.scrollbarDomNode = bt(this.scrollbar.getDomNode()), this.scrollbarDomNode.setPosition("absolute"), this._setLayout();
    const h = (d, f, p) => {
      const g = {};
      if (f) {
        const _ = d.scrollTop;
        _ && (g.scrollTop = this._context.viewLayout.getCurrentScrollTop() + _, d.scrollTop = 0);
      }
      if (p) {
        const _ = d.scrollLeft;
        _ && (g.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + _, d.scrollLeft = 0);
      }
      this._context.model.setScrollPosition(
        g,
        1
        /* Immediate */
      );
    };
    this._register(ye(i.domNode, "scroll", (d) => h(i.domNode, !0, !0))), this._register(ye(t.domNode, "scroll", (d) => h(t.domNode, !0, !1))), this._register(ye(r.domNode, "scroll", (d) => h(r.domNode, !0, !1))), this._register(ye(this.scrollbarDomNode.domNode, "scroll", (d) => h(this.scrollbarDomNode.domNode, !0, !1)));
  }
  dispose() {
    super.dispose();
  }
  _setLayout() {
    const e = this._context.configuration.options, t = e.get(
      128
      /* layoutInfo */
    );
    this.scrollbarDomNode.setLeft(t.contentLeft), e.get(
      62
      /* minimap */
    ).side === "right" ? this.scrollbarDomNode.setWidth(t.contentWidth + t.minimap.minimapWidth) : this.scrollbarDomNode.setWidth(t.contentWidth), this.scrollbarDomNode.setHeight(t.height);
  }
  getOverviewRulerLayoutInfo() {
    return this.scrollbar.getOverviewRulerLayoutInfo();
  }
  getDomNode() {
    return this.scrollbarDomNode;
  }
  delegateVerticalScrollbarMouseDown(e) {
    this.scrollbar.delegateVerticalScrollbarMouseDown(e);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      90
      /* scrollbar */
    ) || e.hasChanged(
      64
      /* mouseWheelScrollSensitivity */
    ) || e.hasChanged(
      32
      /* fastScrollSensitivity */
    )) {
      const t = this._context.configuration.options, i = t.get(
        90
        /* scrollbar */
      ), r = t.get(
        64
        /* mouseWheelScrollSensitivity */
      ), o = t.get(
        32
        /* fastScrollSensitivity */
      ), s = t.get(
        93
        /* scrollPredominantAxis */
      ), a = {
        handleMouseWheel: i.handleMouseWheel,
        mouseWheelScrollSensitivity: r,
        fastScrollSensitivity: o,
        scrollPredominantAxis: s
      };
      this.scrollbar.updateOptions(a);
    }
    return e.hasChanged(
      128
      /* layoutInfo */
    ) && this._setLayout(), !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onThemeChanged(e) {
    return this.scrollbar.updateClassName("editor-scrollable " + Ob(this._context.theme.type)), !0;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this.scrollbar.renderNow();
  }
}
class Bb {
  constructor(e, t, i) {
    this.startLineNumber = +e, this.endLineNumber = +t, this.className = String(i);
  }
}
class nI extends Dg {
  _render(e, t, i) {
    const r = [];
    for (let a = e; a <= t; a++) {
      const l = a - e;
      r[l] = [];
    }
    if (i.length === 0)
      return r;
    i.sort((a, l) => a.className === l.className ? a.startLineNumber === l.startLineNumber ? a.endLineNumber - l.endLineNumber : a.startLineNumber - l.startLineNumber : a.className < l.className ? -1 : 1);
    let o = null, s = 0;
    for (let a = 0, l = i.length; a < l; a++) {
      const u = i[a], c = u.className;
      let h = Math.max(u.startLineNumber, e) - e;
      const d = Math.min(u.endLineNumber, t) - e;
      o === c ? (h = Math.max(s + 1, h), s = Math.max(s, d)) : (o = c, s = d);
      for (let f = h; f <= s; f++)
        r[f].push(o);
    }
    return r;
  }
}
class whe extends nI {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._glyphMargin = t.get(
      46
      /* glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._glyphMargin = t.get(
      46
      /* glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport();
    let i = [], r = 0;
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.options.glyphMarginClassName;
      l && (i[r++] = new Bb(a.range.startLineNumber, a.range.endLineNumber, l));
    }
    return i;
  }
  prepareRender(e) {
    if (!this._glyphMargin) {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, r = this._render(t, i, this._getDecorations(e)), o = this._lineHeight.toString(), s = this._glyphMarginLeft.toString(), a = this._glyphMarginWidth.toString(), l = '" style="left:' + s + "px;width:" + a + "px;height:" + o + 'px;"></div>', u = [];
    for (let c = t; c <= i; c++) {
      const h = c - t, d = r[h];
      d.length === 0 ? u[h] = "" : u[h] = '<div class="cgmr codicon ' + d.join(" ") + l;
    }
    this._renderResult = u;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class bhe extends Dg {
  constructor(e) {
    super(), this._context = e, this._primaryLineNumber = 0;
    const t = this._context.configuration.options, i = t.get(
      129
      /* wrappingInfo */
    ), r = t.get(
      40
      /* fontInfo */
    );
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._spaceWidth = r.spaceWidth, this._enabled = t.get(
      81
      /* renderIndentGuides */
    ), this._activeIndentEnabled = t.get(
      49
      /* highlightActiveIndentGuide */
    ), this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * r.typicalHalfwidthCharacterWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      129
      /* wrappingInfo */
    ), r = t.get(
      40
      /* fontInfo */
    );
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._spaceWidth = r.spaceWidth, this._enabled = t.get(
      81
      /* renderIndentGuides */
    ), this._activeIndentEnabled = t.get(
      49
      /* highlightActiveIndentGuide */
    ), this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * r.typicalHalfwidthCharacterWidth, !0;
  }
  onCursorStateChanged(e) {
    const t = e.selections[0], i = t.isEmpty() ? t.positionLineNumber : 0;
    return this._primaryLineNumber !== i ? (this._primaryLineNumber = i, !0) : !1;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLanguageConfigurationChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    if (!this._enabled) {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, { indentSize: r } = this._context.model.getTextModelOptions(), o = r * this._spaceWidth, s = e.scrollWidth, a = this._lineHeight, l = this._context.model.getLinesIndentGuides(t, i);
    let u = 0, c = 0, h = 0;
    if (this._activeIndentEnabled && this._primaryLineNumber) {
      const f = this._context.model.getActiveIndentGuide(this._primaryLineNumber, t, i);
      u = f.startLineNumber, c = f.endLineNumber, h = f.indent;
    }
    const d = [];
    for (let f = t; f <= i; f++) {
      const p = u <= f && f <= c, g = f - t, _ = l[g];
      let m = "";
      if (_ >= 1) {
        const v = e.visibleRangeForPosition(new J(f, 1));
        let C = v ? v.left : 0;
        for (let y = 1; y <= _ && (m += `<div class="${p && y === h ? "cigra" : "cigr"}" style="left:${C}px;height:${a}px;width:${o}px"></div>`, C += o, !(C > s || this._maxIndentLeft > 0 && C > this._maxIndentLeft)); y++)
          ;
      }
      d[g] = m;
    }
    this._renderResult = d;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
_a((n, e) => {
  const t = n.getColor(y0);
  t && e.addRule(`.monaco-editor .lines-content .cigr { box-shadow: 1px 0 0 0 ${t} inset; }`);
  const i = n.getColor(w0) || t;
  i && e.addRule(`.monaco-editor .lines-content .cigra { box-shadow: 1px 0 0 0 ${i} inset; }`);
});
class She {
  constructor() {
    this._currentVisibleRange = new V(1, 1, 1, 1);
  }
  getCurrentVisibleRange() {
    return this._currentVisibleRange;
  }
  setCurrentVisibleRange(e) {
    this._currentVisibleRange = e;
  }
}
class Ehe {
  constructor(e, t, i, r, o, s) {
    this.lineNumber = e, this.startColumn = t, this.endColumn = i, this.startScrollTop = r, this.stopScrollTop = o, this.scrollType = s, this.type = "range", this.minLineNumber = e, this.maxLineNumber = e;
  }
}
class Lhe {
  constructor(e, t, i, r) {
    this.selections = e, this.startScrollTop = t, this.stopScrollTop = i, this.scrollType = r, this.type = "selections";
    let o = e[0].startLineNumber, s = e[0].endLineNumber;
    for (let a = 1, l = e.length; a < l; a++) {
      const u = e[a];
      o = Math.min(o, u.startLineNumber), s = Math.max(s, u.endLineNumber);
    }
    this.minLineNumber = o, this.maxLineNumber = s;
  }
}
class L0 extends Ns {
  constructor(e, t) {
    super(e), this._linesContent = t, this._textRangeRestingSpot = document.createElement("div"), this._visibleLines = new b3(this), this.domNode = this._visibleLines.domNode;
    const i = this._context.configuration, r = this._context.configuration.options, o = r.get(
      40
      /* fontInfo */
    ), s = r.get(
      129
      /* wrappingInfo */
    );
    this._lineHeight = r.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = o.typicalHalfwidthCharacterWidth, this._isViewportWrapping = s.isViewportWrapping, this._revealHorizontalRightPadding = r.get(
      87
      /* revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = r.get(
      23
      /* cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = r.get(
      24
      /* cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !r.get(
      26
      /* disableLayerHinting */
    ), this._viewLineOptions = new kk(i, this._context.theme.type), jl.write(
      this.domNode,
      7
      /* ViewLines */
    ), this.domNode.setClassName(`view-lines ${md}`), io.applyFontInfo(this.domNode, o), this._maxLineWidth = 0, this._asyncUpdateLineWidths = new to(() => {
      this._updateLineWidthsSlow();
    }, 200), this._asyncCheckMonospaceFontAssumptions = new to(() => {
      this._checkMonospaceFontAssumptions();
    }, 2e3), this._lastRenderedData = new She(), this._horizontalRevealRequest = null;
  }
  dispose() {
    this._asyncUpdateLineWidths.dispose(), this._asyncCheckMonospaceFontAssumptions.dispose(), super.dispose();
  }
  getDomNode() {
    return this.domNode;
  }
  // ---- begin IVisibleLinesHost
  createVisibleLine() {
    return new Il(this._viewLineOptions);
  }
  // ---- end IVisibleLinesHost
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e), e.hasChanged(
      129
      /* wrappingInfo */
    ) && (this._maxLineWidth = 0);
    const t = this._context.configuration.options, i = t.get(
      40
      /* fontInfo */
    ), r = t.get(
      129
      /* wrappingInfo */
    );
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._isViewportWrapping = r.isViewportWrapping, this._revealHorizontalRightPadding = t.get(
      87
      /* revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = t.get(
      23
      /* cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = t.get(
      24
      /* cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !t.get(
      26
      /* disableLayerHinting */
    ), io.applyFontInfo(this.domNode, i), this._onOptionsMaybeChanged(), e.hasChanged(
      128
      /* layoutInfo */
    ) && (this._maxLineWidth = 0), !0;
  }
  _onOptionsMaybeChanged() {
    const e = this._context.configuration, t = new kk(e, this._context.theme.type);
    if (!this._viewLineOptions.equals(t)) {
      this._viewLineOptions = t;
      const i = this._visibleLines.getStartLineNumber(), r = this._visibleLines.getEndLineNumber();
      for (let o = i; o <= r; o++)
        this._visibleLines.getVisibleLine(o).onOptionsChanged(this._viewLineOptions);
      return !0;
    }
    return !1;
  }
  onCursorStateChanged(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let r = !1;
    for (let o = t; o <= i; o++)
      r = this._visibleLines.getVisibleLine(o).onSelectionChanged() || r;
    return r;
  }
  onDecorationsChanged(e) {
    {
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      for (let r = t; r <= i; r++)
        this._visibleLines.getVisibleLine(r).onDecorationsChanged();
    }
    return !0;
  }
  onFlushed(e) {
    const t = this._visibleLines.onFlushed(e);
    return this._maxLineWidth = 0, t;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onRevealRangeRequest(e) {
    const t = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.selections, e.verticalType);
    if (t === -1)
      return !1;
    let i = this._context.viewLayout.validateScrollPosition({ scrollTop: t });
    e.revealHorizontal ? e.range && e.range.startLineNumber !== e.range.endLineNumber ? i = {
      scrollTop: i.scrollTop,
      scrollLeft: 0
    } : e.range ? this._horizontalRevealRequest = new Ehe(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType) : e.selections && e.selections.length > 0 && (this._horizontalRevealRequest = new Lhe(e.selections, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType)) : this._horizontalRevealRequest = null;
    const o = Math.abs(this._context.viewLayout.getCurrentScrollTop() - i.scrollTop) <= this._lineHeight ? 1 : e.scrollType;
    return this._context.model.setScrollPosition(i, o), !0;
  }
  onScrollChanged(e) {
    if (this._horizontalRevealRequest && e.scrollLeftChanged && (this._horizontalRevealRequest = null), this._horizontalRevealRequest && e.scrollTopChanged) {
      const t = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop), i = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
      (e.scrollTop < t || e.scrollTop > i) && (this._horizontalRevealRequest = null);
    }
    return this.domNode.setWidth(e.scrollWidth), this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._context.model.setMaxLineWidth(this._maxLineWidth), this._visibleLines.onZonesChanged(e);
  }
  onThemeChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  // ---- end view event handlers
  // ----------- HELPERS FOR OTHERS
  getPositionFromDOMInfo(e, t) {
    const i = this._getViewLineDomNode(e);
    if (i === null)
      return null;
    const r = this._getLineNumberFor(i);
    if (r === -1 || r < 1 || r > this._context.model.getLineCount())
      return null;
    if (this._context.model.getLineMaxColumn(r) === 1)
      return new J(r, 1);
    const o = this._visibleLines.getStartLineNumber(), s = this._visibleLines.getEndLineNumber();
    if (r < o || r > s)
      return null;
    let a = this._visibleLines.getVisibleLine(r).getColumnOfNodeOffset(r, e, t);
    const l = this._context.model.getLineMinColumn(r);
    return a < l && (a = l), new J(r, a);
  }
  _getViewLineDomNode(e) {
    for (; e && e.nodeType === 1; ) {
      if (e.className === Il.CLASS_NAME)
        return e;
      e = e.parentElement;
    }
    return null;
  }
  /**
   * @returns the line number of this view line dom node.
   */
  _getLineNumberFor(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    for (let r = t; r <= i; r++) {
      const o = this._visibleLines.getVisibleLine(r);
      if (e === o.getDomNode())
        return r;
    }
    return -1;
  }
  getLineWidth(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    return e < t || e > i ? -1 : this._visibleLines.getVisibleLine(e).getWidth();
  }
  linesVisibleRangesForRange(e, t) {
    if (this.shouldRender())
      return null;
    const i = e.endLineNumber, r = V.intersectRanges(e, this._lastRenderedData.getCurrentVisibleRange());
    if (!r)
      return null;
    let o = [], s = 0;
    const a = new Fk(this.domNode.domNode, this._textRangeRestingSpot);
    let l = 0;
    t && (l = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new J(r.startLineNumber, 1)).lineNumber);
    const u = this._visibleLines.getStartLineNumber(), c = this._visibleLines.getEndLineNumber();
    for (let h = r.startLineNumber; h <= r.endLineNumber; h++) {
      if (h < u || h > c)
        continue;
      const d = h === r.startLineNumber ? r.startColumn : 1, f = h === r.endLineNumber ? r.endColumn : this._context.model.getLineMaxColumn(h), p = this._visibleLines.getVisibleLine(h).getVisibleRangesForRange(d, f, a);
      if (p) {
        if (t && h < i) {
          const g = l;
          l = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new J(h + 1, 1)).lineNumber, g !== l && (p.ranges[p.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth);
        }
        o[s++] = new Xae(p.outsideRenderedLine, h, p.ranges);
      }
    }
    return s === 0 ? null : o;
  }
  _visibleRangesForLineRange(e, t, i) {
    return this.shouldRender() || e < this._visibleLines.getStartLineNumber() || e > this._visibleLines.getEndLineNumber() ? null : this._visibleLines.getVisibleLine(e).getVisibleRangesForRange(t, i, new Fk(this.domNode.domNode, this._textRangeRestingSpot));
  }
  visibleRangeForPosition(e) {
    const t = this._visibleRangesForLineRange(e.lineNumber, e.column, e.column);
    return t ? new Zae(t.outsideRenderedLine, t.ranges[0].left) : null;
  }
  // --- implementation
  updateLineWidths() {
    this._updateLineWidths(!1);
  }
  /**
   * Updates the max line width if it is fast to compute.
   * Returns true if all lines were taken into account.
   * Returns false if some lines need to be reevaluated (in a slow fashion).
   */
  _updateLineWidthsFast() {
    return this._updateLineWidths(!0);
  }
  _updateLineWidthsSlow() {
    this._updateLineWidths(!1);
  }
  _updateLineWidths(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let r = 1, o = !0;
    for (let s = t; s <= i; s++) {
      const a = this._visibleLines.getVisibleLine(s);
      if (e && !a.getWidthIsFast()) {
        o = !1;
        continue;
      }
      r = Math.max(r, a.getWidth());
    }
    return o && t === 1 && i === this._context.model.getLineCount() && (this._maxLineWidth = 0), this._ensureMaxLineWidth(r), o;
  }
  _checkMonospaceFontAssumptions() {
    let e = -1, t = -1;
    const i = this._visibleLines.getStartLineNumber(), r = this._visibleLines.getEndLineNumber();
    for (let o = i; o <= r; o++) {
      const s = this._visibleLines.getVisibleLine(o);
      if (s.needsMonospaceFontCheck()) {
        const a = s.getWidth();
        a > t && (t = a, e = o);
      }
    }
    if (e !== -1 && !this._visibleLines.getVisibleLine(e).monospaceAssumptionsAreValid())
      for (let o = i; o <= r; o++)
        this._visibleLines.getVisibleLine(o).onMonospaceAssumptionsInvalidated();
  }
  prepareRender() {
    throw new Error("Not supported");
  }
  render() {
    throw new Error("Not supported");
  }
  renderText(e) {
    if (this._visibleLines.renderLines(e), this._lastRenderedData.setCurrentVisibleRange(e.visibleRange), this.domNode.setWidth(this._context.viewLayout.getScrollWidth()), this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1e6)), this._horizontalRevealRequest) {
      const i = this._horizontalRevealRequest;
      if (e.startLineNumber <= i.minLineNumber && i.maxLineNumber <= e.endLineNumber) {
        this._horizontalRevealRequest = null, this.onDidRender();
        const r = this._computeScrollLeftToReveal(i);
        r && (this._isViewportWrapping || this._ensureMaxLineWidth(r.maxHorizontalOffset), this._context.model.setScrollPosition({
          scrollLeft: r.scrollLeft
        }, i.scrollType));
      }
    }
    if (this._updateLineWidthsFast() || this._asyncUpdateLineWidths.schedule(), Rs && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {
      const i = this._visibleLines.getStartLineNumber(), r = this._visibleLines.getEndLineNumber();
      for (let o = i; o <= r; o++)
        if (this._visibleLines.getVisibleLine(o).needsMonospaceFontCheck()) {
          this._asyncCheckMonospaceFontAssumptions.schedule();
          break;
        }
    }
    this._linesContent.setLayerHinting(this._canUseLayerHinting), this._linesContent.setContain("strict");
    const t = this._context.viewLayout.getCurrentScrollTop() - e.bigNumbersDelta;
    this._linesContent.setTop(-t), this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
  }
  // --- width
  _ensureMaxLineWidth(e) {
    const t = Math.ceil(e);
    this._maxLineWidth < t && (this._maxLineWidth = t, this._context.model.setMaxLineWidth(this._maxLineWidth));
  }
  _computeScrollTopToRevealRange(e, t, i, r, o) {
    const s = e.top, a = e.height, l = s + a;
    let u, c, h;
    if (r && r.length > 0) {
      let p = r[0].startLineNumber, g = r[0].endLineNumber;
      for (let _ = 1, m = r.length; _ < m; _++) {
        const v = r[_];
        p = Math.min(p, v.startLineNumber), g = Math.max(g, v.endLineNumber);
      }
      u = !1, c = this._context.viewLayout.getVerticalOffsetForLineNumber(p), h = this._context.viewLayout.getVerticalOffsetForLineNumber(g) + this._lineHeight;
    } else if (i)
      u = !0, c = this._context.viewLayout.getVerticalOffsetForLineNumber(i.startLineNumber), h = this._context.viewLayout.getVerticalOffsetForLineNumber(i.endLineNumber) + this._lineHeight;
    else
      return -1;
    if (!(t === "mouse" && this._cursorSurroundingLinesStyle === "default")) {
      const p = Math.min(a / this._lineHeight / 2, this._cursorSurroundingLines);
      c -= p * this._lineHeight, h += Math.max(0, p - 1) * this._lineHeight;
    }
    (o === 0 || o === 4) && (h += this._lineHeight);
    let f;
    if (h - c > a) {
      if (!u)
        return -1;
      f = c;
    } else if (o === 5 || o === 6)
      if (o === 6 && s <= c && h <= l)
        f = s;
      else {
        const p = Math.max(5 * this._lineHeight, a * 0.2), g = c - p, _ = h - a;
        f = Math.max(_, g);
      }
    else if (o === 1 || o === 2)
      if (o === 2 && s <= c && h <= l)
        f = s;
      else {
        const p = (c + h) / 2;
        f = Math.max(0, p - a / 2);
      }
    else
      f = this._computeMinimumScrolling(
        s,
        l,
        c,
        h,
        o === 3,
        o === 4
        /* Bottom */
      );
    return f;
  }
  _computeScrollLeftToReveal(e) {
    const t = this._context.viewLayout.getCurrentViewport(), i = t.left, r = i + t.width;
    let o = 1073741824, s = 0;
    if (e.type === "range") {
      const l = this._visibleRangesForLineRange(e.lineNumber, e.startColumn, e.endColumn);
      if (!l)
        return null;
      for (const u of l.ranges)
        o = Math.min(o, u.left), s = Math.max(s, u.left + u.width);
    } else
      for (const l of e.selections) {
        if (l.startLineNumber !== l.endLineNumber)
          return null;
        const u = this._visibleRangesForLineRange(l.startLineNumber, l.startColumn, l.endColumn);
        if (!u)
          return null;
        for (const c of u.ranges)
          o = Math.min(o, c.left), s = Math.max(s, c.left + c.width);
      }
    return o = Math.max(0, o - L0.HORIZONTAL_EXTRA_PX), s += this._revealHorizontalRightPadding, e.type === "selections" && s - o > t.width ? null : {
      scrollLeft: this._computeMinimumScrolling(i, r, o, s),
      maxHorizontalOffset: s
    };
  }
  _computeMinimumScrolling(e, t, i, r, o, s) {
    e = e | 0, t = t | 0, i = i | 0, r = r | 0, o = !!o, s = !!s;
    const a = t - e;
    if (r - i < a) {
      if (o)
        return i;
      if (s)
        return Math.max(0, r - a);
      if (i < e)
        return i;
      if (r > t)
        return Math.max(0, r - a);
    } else
      return i;
    return e;
  }
}
L0.HORIZONTAL_EXTRA_PX = 30;
class Dhe extends nI {
  constructor(e) {
    super(), this._context = e;
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    return this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport();
    let i = [], r = 0;
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.options.linesDecorationsClassName;
      l && (i[r++] = new Bb(a.range.startLineNumber, a.range.endLineNumber, l));
      const u = a.options.firstLineDecorationClassName;
      u && (i[r++] = new Bb(a.range.startLineNumber, a.range.startLineNumber, u));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, r = this._render(t, i, this._getDecorations(e)), o = this._decorationsLeft.toString(), s = this._decorationsWidth.toString(), a = '" style="left:' + o + "px;width:" + s + 'px;"></div>', l = [];
    for (let u = t; u <= i; u++) {
      const c = u - t, h = r[c];
      let d = "";
      for (let f = 0, p = h.length; f < p; f++)
        d += '<div class="cldr ' + h[f] + a;
      l[c] = d;
    }
    this._renderResult = l;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
class Rhe extends nI {
  constructor(e) {
    super(), this._context = e, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport();
    let i = [], r = 0;
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.options.marginClassName;
      l && (i[r++] = new Bb(a.range.startLineNumber, a.range.endLineNumber, l));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, r = this._render(t, i, this._getDecorations(e)), o = [];
    for (let s = t; s <= i; s++) {
      const a = s - t, l = r[a];
      let u = "";
      for (let c = 0, h = l.length; c < h; c++)
        u += '<div class="cmdr ' + l[c] + '" style=""></div>';
      o[a] = u;
    }
    this._renderResult = o;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
class Ka {
  constructor(e, t, i, r) {
    this.r = Ka._clamp(e), this.g = Ka._clamp(t), this.b = Ka._clamp(i), this.a = Ka._clamp(r);
  }
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  static _clamp(e) {
    return e < 0 ? 0 : e > 255 ? 255 : e | 0;
  }
}
Ka.Empty = new Ka(0, 0, 0, 0);
class $_ {
  constructor() {
    this._onDidChange = new j(), this.onDidChange = this._onDidChange.event, this._updateColorMap(), ln.onDidChange((e) => {
      e.changedColorMap && this._updateColorMap();
    });
  }
  static getInstance() {
    return this._INSTANCE || (this._INSTANCE = new $_()), this._INSTANCE;
  }
  _updateColorMap() {
    const e = ln.getColorMap();
    if (!e) {
      this._colors = [Ka.Empty], this._backgroundIsLight = !0;
      return;
    }
    this._colors = [Ka.Empty];
    for (let i = 1; i < e.length; i++) {
      const r = e[i].rgba;
      this._colors[i] = new Ka(r.r, r.g, r.b, Math.round(r.a * 255));
    }
    let t = e[
      2
      /* DefaultBackground */
    ].getRelativeLuminance();
    this._backgroundIsLight = t >= 0.5, this._onDidChange.fire(void 0);
  }
  getColor(e) {
    return (e < 1 || e >= this._colors.length) && (e = 2), this._colors[e];
  }
  backgroundIsLight() {
    return this._backgroundIsLight;
  }
}
$_._INSTANCE = null;
const The = (() => {
  const n = [];
  for (let e = 32; e <= 126; e++)
    n.push(e);
  return n.push(
    65533
    /* UNKNOWN_CODE */
  ), n;
})(), Ohe = (n, e) => (n -= 32, n < 0 || n > 96 ? e <= 2 ? (n + 96) % 96 : 96 - 1 : n);
class t_ {
  constructor(e, t) {
    this.scale = t, this.charDataNormal = t_.soften(e, 12 / 15), this.charDataLight = t_.soften(e, 50 / 60);
  }
  static soften(e, t) {
    let i = new Uint8ClampedArray(e.length);
    for (let r = 0, o = e.length; r < o; r++)
      i[r] = mb(e[r] * t);
    return i;
  }
  renderChar(e, t, i, r, o, s, a, l, u) {
    const c = 1 * this.scale, h = 2 * this.scale, d = u ? 1 : h;
    if (t + c > e.width || i + d > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const f = l ? this.charDataLight : this.charDataNormal, p = Ohe(r, a), g = e.width * 4, _ = s.r, m = s.g, v = s.b, C = o.r - _, y = o.g - m, b = o.b - v, L = e.data;
    let S = p * c * h, E = i * g + t * 4;
    for (let D = 0; D < d; D++) {
      let O = E;
      for (let T = 0; T < c; T++) {
        const A = f[S++] / 255;
        L[O++] = _ + C * A, L[O++] = m + y * A, L[O++] = v + b * A, O++;
      }
      E += g;
    }
  }
  blockRenderChar(e, t, i, r, o, s, a) {
    const l = 1 * this.scale, u = 2 * this.scale, c = a ? 1 : u;
    if (t + l > e.width || i + c > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const h = e.width * 4, d = 0.5, f = o.r, p = o.g, g = o.b, _ = r.r - f, m = r.g - p, v = r.b - g, C = f + _ * d, y = p + m * d, b = g + v * d, L = e.data;
    let S = i * h + t * 4;
    for (let E = 0; E < c; E++) {
      let D = S;
      for (let O = 0; O < l; O++)
        L[D++] = C, L[D++] = y, L[D++] = b, D++;
      S += h;
    }
  }
}
function Xp(n) {
  const e = this;
  let t = !1, i;
  return function() {
    return t || (t = !0, i = n.apply(e, arguments)), i;
  };
}
const y2 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}, w2 = (n) => {
  const e = new Uint8ClampedArray(n.length / 2);
  for (let t = 0; t < n.length; t += 2)
    e[t >> 1] = y2[n[t]] << 4 | y2[n[t + 1]] & 15;
  return e;
}, b2 = {
  1: Xp(() => w2("0000511D6300CF609C709645A78432005642574171487021003C451900274D35D762755E8B629C5BA856AF57BA649530C167D1512A272A3F6038604460398526BCA2A968DB6F8957C768BE5FBE2FB467CF5D8D5B795DC7625B5DFF50DE64C466DB2FC47CD860A65E9A2EB96CB54CE06DA763AB2EA26860524D3763536601005116008177A8705E53AB738E6A982F88BAA35B5F5B626D9C636B449B737E5B7B678598869A662F6B5B8542706C704C80736A607578685B70594A49715A4522E792")),
  2: Xp(() => w2("000000000000000055394F383D2800008B8B1F210002000081B1CBCBCC820000847AAF6B9AAF2119BE08B8881AD60000A44FD07DCCF107015338130C00000000385972265F390B406E2437634B4B48031B12B8A0847000001E15B29A402F0000000000004B33460B00007A752C2A0000000000004D3900000084394B82013400ABA5CFC7AD9C0302A45A3E5A98AB000089A43382D97900008BA54AA087A70A0248A6A7AE6DBE0000BF6F94987EA40A01A06DCFA7A7A9030496C32F77891D0000A99FB1A0AFA80603B29AB9CA75930D010C0948354D3900000C0948354F37460D0028BE673D8400000000AF9D7B6E00002B007AA8933400007AA642675C2700007984CFB9C3985B768772A8A6B7B20000CAAECAAFC4B700009F94A6009F840009D09F9BA4CA9C0000CC8FC76DC87F0000C991C472A2000000A894A48CA7B501079BA2C9C69BA20000B19A5D3FA89000005CA6009DA2960901B0A7F0669FB200009D009E00B7890000DAD0F5D092820000D294D4C48BD10000B5A7A4A3B1A50402CAB6CBA6A2000000B5A7A4A3B1A8044FCDADD19D9CB00000B7778F7B8AAE0803C9AB5D3F5D3F00009EA09EA0BAB006039EA0989A8C7900009B9EF4D6B7C00000A9A7816CACA80000ABAC84705D3F000096DA635CDC8C00006F486F266F263D4784006124097B00374F6D2D6D2D6D4A3A95872322000000030000000000008D8939130000000000002E22A5C9CBC70600AB25C0B5C9B400061A2DB04CA67001082AA6BEBEBFC606002321DACBC19E03087AA08B6768380000282FBAC0B8CA7A88AD25BBA5A29900004C396C5894A6000040485A6E356E9442A32CD17EADA70000B4237923628600003E2DE9C1D7B500002F25BBA5A2990000231DB6AFB4A804023025C0B5CAB588062B2CBDBEC0C706882435A75CA20000002326BD6A82A908048B4B9A5A668000002423A09CB4BB060025259C9D8A7900001C1FCAB2C7C700002A2A9387ABA200002626A4A47D6E9D14333163A0C87500004B6F9C2D643A257049364936493647358A34438355497F1A0000A24C1D590000D38DFFBDD4CD3126"))
};
class vv {
  /**
   * Creates a new character renderer factory with the given scale.
   */
  static create(e, t) {
    if (this.lastCreated && e === this.lastCreated.scale && t === this.lastFontFamily)
      return this.lastCreated;
    let i;
    return b2[e] ? i = new t_(b2[e](), e) : i = vv.createFromSampleData(vv.createSampleData(t).data, e), this.lastFontFamily = t, this.lastCreated = i, i;
  }
  /**
   * Creates the font sample data, writing to a canvas.
   */
  static createSampleData(e) {
    const t = document.createElement("canvas"), i = t.getContext("2d");
    t.style.height = "16px", t.height = 16, t.width = 96 * 10, t.style.width = 96 * 10 + "px", i.fillStyle = "#ffffff", i.font = `bold 16px ${e}`, i.textBaseline = "middle";
    let r = 0;
    for (const o of The)
      i.fillText(String.fromCharCode(o), r, 16 / 2), r += 10;
    return i.getImageData(
      0,
      0,
      96 * 10,
      16
      /* SAMPLED_CHAR_HEIGHT */
    );
  }
  /**
   * Creates a character renderer from the canvas sample data.
   */
  static createFromSampleData(e, t) {
    if (e.length !== 61440)
      throw new Error("Unexpected source in MinimapCharRenderer");
    let r = vv._downsample(e, t);
    return new t_(r, t);
  }
  static _downsampleChar(e, t, i, r, o) {
    const s = 1 * o, a = 2 * o;
    let l = r, u = 0;
    for (let c = 0; c < a; c++) {
      const h = c / a * 16, d = (c + 1) / a * 16;
      for (let f = 0; f < s; f++) {
        const p = f / s * 10, g = (f + 1) / s * 10;
        let _ = 0, m = 0;
        for (let C = h; C < d; C++) {
          const y = t + Math.floor(C) * 3840, b = 1 - (C - Math.floor(C));
          for (let L = p; L < g; L++) {
            const S = 1 - (L - Math.floor(L)), E = y + Math.floor(L) * 4, D = S * b;
            m += D, _ += e[E] * e[E + 3] / 255 * D;
          }
        }
        const v = _ / m;
        u = Math.max(u, v), i[l++] = mb(v);
      }
    }
    return u;
  }
  static _downsample(e, t) {
    const i = 2 * t * 1 * t, r = i * 96, o = new Uint8ClampedArray(r);
    let s = 0, a = 0, l = 0;
    for (let u = 0; u < 96; u++)
      l = Math.max(l, this._downsampleChar(e, a, o, s, t)), s += i, a += 10 * 4;
    if (l > 0) {
      const u = 255 / l;
      for (let c = 0; c < r; c++)
        o[c] *= u;
    }
    return o;
  }
}
const xhe = 140, Nhe = 2;
class Hb {
  constructor(e, t, i) {
    const r = e.options, o = r.get(
      126
      /* pixelRatio */
    ), s = r.get(
      128
      /* layoutInfo */
    ), a = s.minimap, l = r.get(
      40
      /* fontInfo */
    ), u = r.get(
      62
      /* minimap */
    );
    this.renderMinimap = a.renderMinimap, this.size = u.size, this.minimapHeightIsEditorHeight = a.minimapHeightIsEditorHeight, this.scrollBeyondLastLine = r.get(
      92
      /* scrollBeyondLastLine */
    ), this.showSlider = u.showSlider, this.pixelRatio = o, this.typicalHalfwidthCharacterWidth = l.typicalHalfwidthCharacterWidth, this.lineHeight = r.get(
      56
      /* lineHeight */
    ), this.minimapLeft = a.minimapLeft, this.minimapWidth = a.minimapWidth, this.minimapHeight = s.height, this.canvasInnerWidth = a.minimapCanvasInnerWidth, this.canvasInnerHeight = a.minimapCanvasInnerHeight, this.canvasOuterWidth = a.minimapCanvasOuterWidth, this.canvasOuterHeight = a.minimapCanvasOuterHeight, this.isSampling = a.minimapIsSampling, this.editorHeight = s.height, this.fontScale = a.minimapScale, this.minimapLineHeight = a.minimapLineHeight, this.minimapCharWidth = 1 * this.fontScale, this.charRenderer = Xp(() => vv.create(this.fontScale, l.fontFamily)), this.backgroundColor = Hb._getMinimapBackground(t, i);
  }
  static _getMinimapBackground(e, t) {
    const i = e.getColor(f3);
    return i ? new Ka(i.rgba.r, i.rgba.g, i.rgba.b, i.rgba.a) : t.getColor(
      2
      /* DefaultBackground */
    );
  }
  equals(e) {
    return this.renderMinimap === e.renderMinimap && this.size === e.size && this.minimapHeightIsEditorHeight === e.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === e.scrollBeyondLastLine && this.showSlider === e.showSlider && this.pixelRatio === e.pixelRatio && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.lineHeight === e.lineHeight && this.minimapLeft === e.minimapLeft && this.minimapWidth === e.minimapWidth && this.minimapHeight === e.minimapHeight && this.canvasInnerWidth === e.canvasInnerWidth && this.canvasInnerHeight === e.canvasInnerHeight && this.canvasOuterWidth === e.canvasOuterWidth && this.canvasOuterHeight === e.canvasOuterHeight && this.isSampling === e.isSampling && this.editorHeight === e.editorHeight && this.fontScale === e.fontScale && this.minimapLineHeight === e.minimapLineHeight && this.minimapCharWidth === e.minimapCharWidth && this.backgroundColor && this.backgroundColor.equals(e.backgroundColor);
  }
}
class _v {
  constructor(e, t, i, r, o, s, a, l) {
    this.scrollTop = e, this.scrollHeight = t, this.sliderNeeded = i, this._computedSliderRatio = r, this.sliderTop = o, this.sliderHeight = s, this.startLineNumber = a, this.endLineNumber = l;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollTopFromDelta(e) {
    return Math.round(this.scrollTop + e / this._computedSliderRatio);
  }
  getDesiredScrollTopFromTouchLocation(e) {
    return Math.round((e - this.sliderHeight / 2) / this._computedSliderRatio);
  }
  static create(e, t, i, r, o, s, a, l, u, c, h) {
    const d = e.pixelRatio, f = e.minimapLineHeight, p = Math.floor(e.canvasInnerHeight / f), g = e.lineHeight;
    if (e.minimapHeightIsEditorHeight) {
      const b = l * e.lineHeight + (e.scrollBeyondLastLine ? o - e.lineHeight : 0), L = Math.max(1, Math.floor(o * o / b)), S = Math.max(0, e.minimapHeight - L), E = S / (c - o), D = u * E, O = S > 0, T = Math.floor(e.canvasInnerHeight / e.minimapLineHeight);
      return new _v(u, c, O, E, D, L, 1, Math.min(a, T));
    }
    let _;
    if (s && i !== a) {
      const b = i - t + 1;
      _ = Math.floor(b * f / d);
    } else {
      const b = o / g;
      _ = Math.floor(b * f / d);
    }
    let m;
    e.scrollBeyondLastLine ? m = (a - 1) * f / d : m = Math.max(0, a * f / d - _), m = Math.min(e.minimapHeight - _, m);
    const v = m / (c - o), C = u * v;
    let y = 0;
    if (e.scrollBeyondLastLine && (y = o / g - 1), p >= a + y) {
      const L = a, S = m > 0;
      return new _v(u, c, S, v, C, _, 1, L);
    } else {
      let b = Math.max(1, Math.floor(t - C * d / f));
      h && h.scrollHeight === c && (h.scrollTop > u && (b = Math.min(b, h.startLineNumber)), h.scrollTop < u && (b = Math.max(b, h.startLineNumber)));
      const L = Math.min(a, b + p - 1), S = (u - r) / g, E = (t - b + S) * f / d;
      return new _v(u, c, !0, v, E, _, b, L);
    }
  }
}
class Gb {
  constructor(e) {
    this.dy = e;
  }
  onContentChanged() {
    this.dy = -1;
  }
  onTokensChanged() {
    this.dy = -1;
  }
}
Gb.INVALID = new Gb(-1);
class S2 {
  constructor(e, t, i) {
    this.renderedLayout = e, this._imageData = t, this._renderedLines = new w3(() => Gb.INVALID), this._renderedLines._set(e.startLineNumber, i);
  }
  /**
   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.
   */
  linesEquals(e) {
    if (!this.scrollEquals(e))
      return !1;
    const i = this._renderedLines._get().lines;
    for (let r = 0, o = i.length; r < o; r++)
      if (i[r].dy === -1)
        return !1;
    return !0;
  }
  /**
   * Check if the current RenderData matches the new layout's scroll position
   */
  scrollEquals(e) {
    return this.renderedLayout.startLineNumber === e.startLineNumber && this.renderedLayout.endLineNumber === e.endLineNumber;
  }
  _get() {
    const e = this._renderedLines._get();
    return {
      imageData: this._imageData,
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines
    };
  }
  onLinesChanged(e, t) {
    return this._renderedLines.onLinesChanged(e, t);
  }
  onLinesDeleted(e, t) {
    this._renderedLines.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._renderedLines.onLinesInserted(e, t);
  }
  onTokensChanged(e) {
    return this._renderedLines.onTokensChanged(e);
  }
}
class rI {
  constructor(e, t, i, r) {
    this._backgroundFillData = rI._createBackgroundFillData(t, i, r), this._buffers = [
      e.createImageData(t, i),
      e.createImageData(t, i)
    ], this._lastUsedBuffer = 0;
  }
  getBuffer() {
    this._lastUsedBuffer = 1 - this._lastUsedBuffer;
    const e = this._buffers[this._lastUsedBuffer];
    return e.data.set(this._backgroundFillData), e;
  }
  static _createBackgroundFillData(e, t, i) {
    const r = i.r, o = i.g, s = i.b, a = new Uint8ClampedArray(e * t * 4);
    let l = 0;
    for (let u = 0; u < t; u++)
      for (let c = 0; c < e; c++)
        a[l] = r, a[l + 1] = o, a[l + 2] = s, a[l + 3] = 255, l += 4;
    return a;
  }
}
class i_ {
  constructor(e, t) {
    this.samplingRatio = e, this.minimapLines = t;
  }
  static compute(e, t, i) {
    if (e.renderMinimap === 0 || !e.isSampling)
      return [null, []];
    const r = e.pixelRatio, o = e.lineHeight, s = e.scrollBeyondLastLine, { minimapLineCount: a } = up.computeContainedMinimapLineCount({
      viewLineCount: t,
      scrollBeyondLastLine: s,
      height: e.editorHeight,
      lineHeight: o,
      pixelRatio: r
    }), l = t / a, u = l / 2;
    if (!i || i.minimapLines.length === 0) {
      let C = [];
      if (C[0] = 1, a > 1) {
        for (let y = 0, b = a - 1; y < b; y++)
          C[y] = Math.round(y * l + u);
        C[a - 1] = t;
      }
      return [new i_(l, C), []];
    }
    const c = i.minimapLines, h = c.length;
    let d = [], f = 0, p = 0, g = 1;
    const _ = 10;
    let m = [], v = null;
    for (let C = 0; C < a; C++) {
      const y = Math.max(g, Math.round(C * l)), b = Math.max(y, Math.round((C + 1) * l));
      for (; f < h && c[f] < y; ) {
        if (m.length < _) {
          const S = f + 1 + p;
          v && v.type === "deleted" && v._oldIndex === f - 1 ? v.deleteToLineNumber++ : (v = { type: "deleted", _oldIndex: f, deleteFromLineNumber: S, deleteToLineNumber: S }, m.push(v)), p--;
        }
        f++;
      }
      let L;
      if (f < h && c[f] <= b)
        L = c[f], f++;
      else if (C === 0 ? L = 1 : C + 1 === a ? L = t : L = Math.round(C * l + u), m.length < _) {
        const S = f + 1 + p;
        v && v.type === "inserted" && v._i === C - 1 ? v.insertToLineNumber++ : (v = { type: "inserted", _i: C, insertFromLineNumber: S, insertToLineNumber: S }, m.push(v)), p++;
      }
      d[C] = L, g = L;
    }
    if (m.length < _)
      for (; f < h; ) {
        const C = f + 1 + p;
        v && v.type === "deleted" && v._oldIndex === f - 1 ? v.deleteToLineNumber++ : (v = { type: "deleted", _oldIndex: f, deleteFromLineNumber: C, deleteToLineNumber: C }, m.push(v)), p--, f++;
      }
    else
      m = [{ type: "flush" }];
    return [new i_(l, d), m];
  }
  modelLineToMinimapLine(e) {
    return Math.min(this.minimapLines.length, Math.max(1, Math.round(e / this.samplingRatio)));
  }
  /**
   * Will return null if the model line ranges are not intersecting with a sampled model line.
   */
  modelLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e) - 1;
    for (; i > 0 && this.minimapLines[i - 1] >= e; )
      i--;
    let r = this.modelLineToMinimapLine(t) - 1;
    for (; r + 1 < this.minimapLines.length && this.minimapLines[r + 1] <= t; )
      r++;
    if (i === r) {
      const o = this.minimapLines[i];
      if (o < e || o > t)
        return null;
    }
    return [i + 1, r + 1];
  }
  /**
   * Will always return a range, even if it is not intersecting with a sampled model line.
   */
  decorationLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e), r = this.modelLineToMinimapLine(t);
    return e !== t && r === i && (r === this.minimapLines.length ? i > 1 && i-- : r++), [i, r];
  }
  onLinesDeleted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    let i = this.minimapLines.length, r = 0;
    for (let o = this.minimapLines.length - 1; o >= 0 && !(this.minimapLines[o] < e.fromLineNumber); o--)
      this.minimapLines[o] <= e.toLineNumber ? (this.minimapLines[o] = Math.max(1, e.fromLineNumber - 1), i = Math.min(i, o), r = Math.max(r, o)) : this.minimapLines[o] -= t;
    return [i, r];
  }
  onLinesInserted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    for (let i = this.minimapLines.length - 1; i >= 0 && !(this.minimapLines[i] < e.fromLineNumber); i--)
      this.minimapLines[i] += t;
  }
}
class Ihe extends Ns {
  constructor(e) {
    super(e), this.tokensColorTracker = $_.getInstance(), this._selections = [], this._minimapSelections = null, this.options = new Hb(this._context.configuration, this._context.theme, this.tokensColorTracker);
    const [t] = i_.compute(this.options, this._context.model.getLineCount(), null);
    this._samplingState = t, this._shouldCheckSampling = !1, this._actual = new Ub(e.theme, this);
  }
  dispose() {
    this._actual.dispose(), super.dispose();
  }
  getDomNode() {
    return this._actual.getDomNode();
  }
  _onOptionsMaybeChanged() {
    const e = new Hb(this._context.configuration, this._context.theme, this.tokensColorTracker);
    return this.options.equals(e) ? !1 : (this.options = e, this._recreateLineSampling(), this._actual.onDidChangeOptions(), !0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._minimapSelections = null, this._actual.onSelectionChanged();
  }
  onDecorationsChanged(e) {
    return e.affectsMinimap ? this._actual.onDecorationsChanged() : !1;
  }
  onFlushed(e) {
    return this._samplingState && (this._shouldCheckSampling = !0), this._actual.onFlushed();
  }
  onLinesChanged(e) {
    if (this._samplingState) {
      const t = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.toLineNumber);
      return t ? this._actual.onLinesChanged(t[0], t[1]) : !1;
    } else
      return this._actual.onLinesChanged(e.fromLineNumber, e.toLineNumber);
  }
  onLinesDeleted(e) {
    if (this._samplingState) {
      const [t, i] = this._samplingState.onLinesDeleted(e);
      return t <= i && this._actual.onLinesChanged(t + 1, i + 1), this._shouldCheckSampling = !0, !0;
    } else
      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
  }
  onLinesInserted(e) {
    return this._samplingState ? (this._samplingState.onLinesInserted(e), this._shouldCheckSampling = !0, !0) : this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);
  }
  onScrollChanged(e) {
    return this._actual.onScrollChanged();
  }
  onThemeChanged(e) {
    return this._context.model.invalidateMinimapColorCache(), this._actual.onThemeChanged(), this._onOptionsMaybeChanged(), !0;
  }
  onTokensChanged(e) {
    if (this._samplingState) {
      let t = [];
      for (const i of e.ranges) {
        const r = this._samplingState.modelLineRangeToMinimapLineRange(i.fromLineNumber, i.toLineNumber);
        r && t.push({ fromLineNumber: r[0], toLineNumber: r[1] });
      }
      return t.length ? this._actual.onTokensChanged(t) : !1;
    } else
      return this._actual.onTokensChanged(e.ranges);
  }
  onTokensColorsChanged(e) {
    return this._onOptionsMaybeChanged(), this._actual.onTokensColorsChanged();
  }
  onZonesChanged(e) {
    return this._actual.onZonesChanged();
  }
  // --- end event handlers
  prepareRender(e) {
    this._shouldCheckSampling && (this._shouldCheckSampling = !1, this._recreateLineSampling());
  }
  render(e) {
    let t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber;
    this._samplingState && (t = this._samplingState.modelLineToMinimapLine(t), i = this._samplingState.modelLineToMinimapLine(i));
    const r = {
      viewportContainsWhitespaceGaps: e.viewportData.whitespaceViewportData.length > 0,
      scrollWidth: e.scrollWidth,
      scrollHeight: e.scrollHeight,
      viewportStartLineNumber: t,
      viewportEndLineNumber: i,
      viewportStartLineNumberVerticalOffset: e.getVerticalOffsetForLineNumber(t),
      scrollTop: e.scrollTop,
      scrollLeft: e.scrollLeft,
      viewportWidth: e.viewportWidth,
      viewportHeight: e.viewportHeight
    };
    this._actual.render(r);
  }
  //#region IMinimapModel
  _recreateLineSampling() {
    this._minimapSelections = null;
    const e = !!this._samplingState, [t, i] = i_.compute(this.options, this._context.model.getLineCount(), this._samplingState);
    if (this._samplingState = t, e && this._samplingState)
      for (const r of i)
        switch (r.type) {
          case "deleted":
            this._actual.onLinesDeleted(r.deleteFromLineNumber, r.deleteToLineNumber);
            break;
          case "inserted":
            this._actual.onLinesInserted(r.insertFromLineNumber, r.insertToLineNumber);
            break;
          case "flush":
            this._actual.onFlushed();
            break;
        }
  }
  getLineCount() {
    return this._samplingState ? this._samplingState.minimapLines.length : this._context.model.getLineCount();
  }
  getRealLineCount() {
    return this._context.model.getLineCount();
  }
  getLineContent(e) {
    return this._samplingState ? this._context.model.getLineContent(this._samplingState.minimapLines[e - 1]) : this._context.model.getLineContent(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    if (this._samplingState) {
      let r = [];
      for (let o = 0, s = t - e + 1; o < s; o++)
        i[o] ? r[o] = this._context.model.getViewLineData(this._samplingState.minimapLines[e + o - 1]) : r[o] = null;
      return r;
    }
    return this._context.model.getMinimapLinesRenderingData(e, t, i).data;
  }
  getSelections() {
    if (this._minimapSelections === null)
      if (this._samplingState) {
        this._minimapSelections = [];
        for (const e of this._selections) {
          const [t, i] = this._samplingState.decorationLineRangeToMinimapLineRange(e.startLineNumber, e.endLineNumber);
          this._minimapSelections.push(new Ut(t, e.startColumn, i, e.endColumn));
        }
      } else
        this._minimapSelections = this._selections;
    return this._minimapSelections;
  }
  getMinimapDecorationsInViewport(e, t) {
    let i;
    if (this._samplingState) {
      const o = this._samplingState.minimapLines[e - 1], s = this._samplingState.minimapLines[t - 1];
      i = new V(o, 1, s, this._context.model.getLineMaxColumn(s));
    } else
      i = new V(e, 1, t, this._context.model.getLineMaxColumn(t));
    const r = this._context.model.getDecorationsInViewport(i);
    if (this._samplingState) {
      let o = [];
      for (const s of r) {
        if (!s.options.minimap)
          continue;
        const a = s.range, l = this._samplingState.modelLineToMinimapLine(a.startLineNumber), u = this._samplingState.modelLineToMinimapLine(a.endLineNumber);
        o.push(new g5(new V(l, a.startColumn, u, a.endColumn), s.options));
      }
      return o;
    }
    return r;
  }
  getOptions() {
    return this._context.model.getTextModelOptions();
  }
  revealLineNumber(e) {
    this._samplingState && (e = this._samplingState.minimapLines[e - 1]), this._context.model.revealRange(
      "mouse",
      !1,
      new V(e, 1, e, 1),
      1,
      0
      /* Smooth */
    );
  }
  setScrollTop(e) {
    this._context.model.setScrollPosition(
      {
        scrollTop: e
      },
      1
      /* Immediate */
    );
  }
}
class Ub extends ge {
  constructor(e, t) {
    super(), this._renderDecorations = !1, this._gestureInProgress = !1, this._theme = e, this._model = t, this._lastRenderData = null, this._buffers = null, this._selectionColor = this._theme.getColor(l2), this._domNode = bt(document.createElement("div")), jl.write(
      this._domNode,
      8
      /* Minimap */
    ), this._domNode.setClassName(this._getMinimapDomNodeClassName()), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._shadow = bt(document.createElement("div")), this._shadow.setClassName("minimap-shadow-hidden"), this._domNode.appendChild(this._shadow), this._canvas = bt(document.createElement("canvas")), this._canvas.setPosition("absolute"), this._canvas.setLeft(0), this._domNode.appendChild(this._canvas), this._decorationsCanvas = bt(document.createElement("canvas")), this._decorationsCanvas.setPosition("absolute"), this._decorationsCanvas.setClassName("minimap-decorations-layer"), this._decorationsCanvas.setLeft(0), this._domNode.appendChild(this._decorationsCanvas), this._slider = bt(document.createElement("div")), this._slider.setPosition("absolute"), this._slider.setClassName("minimap-slider"), this._slider.setLayerHinting(!0), this._slider.setContain("strict"), this._domNode.appendChild(this._slider), this._sliderHorizontal = bt(document.createElement("div")), this._sliderHorizontal.setPosition("absolute"), this._sliderHorizontal.setClassName("minimap-slider-horizontal"), this._slider.appendChild(this._sliderHorizontal), this._applyLayout(), this._mouseDownListener = Jr(this._domNode.domNode, "mousedown", (i) => {
      if (i.preventDefault(), this._model.options.renderMinimap === 0 || !this._lastRenderData)
        return;
      if (this._model.options.size !== "proportional") {
        if (i.leftButton && this._lastRenderData) {
          const u = ja(this._slider.domNode), c = u.top + u.height / 2;
          this._startSliderDragging(i.buttons, i.posx, c, i.posy, this._lastRenderData.renderedLayout);
        }
        return;
      }
      const o = this._model.options.minimapLineHeight, s = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * i.browserEvent.offsetY;
      let l = Math.floor(s / o) + this._lastRenderData.renderedLayout.startLineNumber;
      l = Math.min(l, this._model.getLineCount()), this._model.revealLineNumber(l);
    }), this._sliderMouseMoveMonitor = new m0(), this._sliderMouseDownListener = Jr(this._slider.domNode, "mousedown", (i) => {
      i.preventDefault(), i.stopPropagation(), i.leftButton && this._lastRenderData && this._startSliderDragging(i.buttons, i.posx, i.posy, i.posy, this._lastRenderData.renderedLayout);
    }), this._gestureDisposable = ri.addTarget(this._domNode.domNode), this._sliderTouchStartListener = ye(this._domNode.domNode, Li.Start, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && (this._slider.toggleClassName("active", !0), this._gestureInProgress = !0, this.scrollDueToTouchEvent(i));
    }, { passive: !1 }), this._sliderTouchMoveListener = ye(this._domNode.domNode, Li.Change, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && this._gestureInProgress && this.scrollDueToTouchEvent(i);
    }, { passive: !1 }), this._sliderTouchEndListener = Jr(this._domNode.domNode, Li.End, (i) => {
      i.preventDefault(), i.stopPropagation(), this._gestureInProgress = !1, this._slider.toggleClassName("active", !1);
    });
  }
  _startSliderDragging(e, t, i, r, o) {
    this._slider.toggleClassName("active", !0);
    const s = (a, l) => {
      const u = Math.abs(l - t);
      if (Eo && u > xhe) {
        this._model.setScrollTop(o.scrollTop);
        return;
      }
      const c = a - i;
      this._model.setScrollTop(o.getDesiredScrollTopFromDelta(c));
    };
    r !== i && s(r, t), this._sliderMouseMoveMonitor.startMonitoring(this._slider.domNode, e, zN, (a) => s(a.posy, a.posx), () => {
      this._slider.toggleClassName("active", !1);
    });
  }
  scrollDueToTouchEvent(e) {
    const t = this._domNode.domNode.getBoundingClientRect().top, i = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(e.pageY - t);
    this._model.setScrollTop(i);
  }
  dispose() {
    this._mouseDownListener.dispose(), this._sliderMouseMoveMonitor.dispose(), this._sliderMouseDownListener.dispose(), this._gestureDisposable.dispose(), this._sliderTouchStartListener.dispose(), this._sliderTouchMoveListener.dispose(), this._sliderTouchEndListener.dispose(), super.dispose();
  }
  _getMinimapDomNodeClassName() {
    return this._model.options.showSlider === "always" ? "minimap slider-always" : "minimap slider-mouseover";
  }
  getDomNode() {
    return this._domNode;
  }
  _applyLayout() {
    this._domNode.setLeft(this._model.options.minimapLeft), this._domNode.setWidth(this._model.options.minimapWidth), this._domNode.setHeight(this._model.options.minimapHeight), this._shadow.setHeight(this._model.options.minimapHeight), this._canvas.setWidth(this._model.options.canvasOuterWidth), this._canvas.setHeight(this._model.options.canvasOuterHeight), this._canvas.domNode.width = this._model.options.canvasInnerWidth, this._canvas.domNode.height = this._model.options.canvasInnerHeight, this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth), this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight), this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth, this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight, this._slider.setWidth(this._model.options.minimapWidth);
  }
  _getBuffer() {
    return this._buffers || this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0 && (this._buffers = new rI(this._canvas.domNode.getContext("2d"), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor)), this._buffers ? this._buffers.getBuffer() : null;
  }
  // ---- begin view event handlers
  onDidChangeOptions() {
    this._lastRenderData = null, this._buffers = null, this._applyLayout(), this._domNode.setClassName(this._getMinimapDomNodeClassName());
  }
  onSelectionChanged() {
    return this._renderDecorations = !0, !0;
  }
  onDecorationsChanged() {
    return this._renderDecorations = !0, !0;
  }
  onFlushed() {
    return this._lastRenderData = null, !0;
  }
  onLinesChanged(e, t) {
    return this._lastRenderData ? this._lastRenderData.onLinesChanged(e, t) : !1;
  }
  onLinesDeleted(e, t) {
    return this._lastRenderData && this._lastRenderData.onLinesDeleted(e, t), !0;
  }
  onLinesInserted(e, t) {
    return this._lastRenderData && this._lastRenderData.onLinesInserted(e, t), !0;
  }
  onScrollChanged() {
    return this._renderDecorations = !0, !0;
  }
  onThemeChanged() {
    return this._selectionColor = this._theme.getColor(l2), this._renderDecorations = !0, !0;
  }
  onTokensChanged(e) {
    return this._lastRenderData ? this._lastRenderData.onTokensChanged(e) : !1;
  }
  onTokensColorsChanged() {
    return this._lastRenderData = null, this._buffers = null, !0;
  }
  onZonesChanged() {
    return this._lastRenderData = null, !0;
  }
  // --- end event handlers
  render(e) {
    if (this._model.options.renderMinimap === 0) {
      this._shadow.setClassName("minimap-shadow-hidden"), this._sliderHorizontal.setWidth(0), this._sliderHorizontal.setHeight(0);
      return;
    }
    e.scrollLeft + e.viewportWidth >= e.scrollWidth ? this._shadow.setClassName("minimap-shadow-hidden") : this._shadow.setClassName("minimap-shadow-visible");
    const i = _v.create(this._model.options, e.viewportStartLineNumber, e.viewportEndLineNumber, e.viewportStartLineNumberVerticalOffset, e.viewportHeight, e.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), e.scrollTop, e.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);
    this._slider.setDisplay(i.sliderNeeded ? "block" : "none"), this._slider.setTop(i.sliderTop), this._slider.setHeight(i.sliderHeight);
    const r = e.scrollLeft / this._model.options.typicalHalfwidthCharacterWidth, o = Math.min(this._model.options.minimapWidth, Math.round(r * this._model.options.minimapCharWidth / this._model.options.pixelRatio));
    this._sliderHorizontal.setLeft(o), this._sliderHorizontal.setWidth(this._model.options.minimapWidth - o), this._sliderHorizontal.setTop(0), this._sliderHorizontal.setHeight(i.sliderHeight), this.renderDecorations(i), this._lastRenderData = this.renderLines(i);
  }
  renderDecorations(e) {
    if (this._renderDecorations) {
      this._renderDecorations = !1;
      const t = this._model.getSelections(), i = this._model.getMinimapDecorationsInViewport(e.startLineNumber, e.endLineNumber), { canvasInnerWidth: r, canvasInnerHeight: o } = this._model.options, s = this._model.options.minimapLineHeight, a = this._model.options.minimapCharWidth, l = this._model.getOptions().tabSize, u = this._decorationsCanvas.domNode.getContext("2d");
      u.clearRect(0, 0, r, o);
      const c = /* @__PURE__ */ new Map();
      for (let h = 0; h < t.length; h++) {
        const d = t[h];
        for (let f = d.startLineNumber; f <= d.endLineNumber; f++)
          this.renderDecorationOnLine(u, c, d, this._selectionColor, e, f, s, s, l, a);
      }
      for (let h = 0; h < i.length; h++) {
        const d = i[h];
        if (!d.options.minimap)
          continue;
        const f = d.options.minimap.getColor(this._theme);
        for (let p = d.range.startLineNumber; p <= d.range.endLineNumber; p++)
          switch (d.options.minimap.position) {
            case Gp.Inline:
              this.renderDecorationOnLine(u, c, d.range, f, e, p, s, s, l, a);
              continue;
            case Gp.Gutter:
              const g = (p - e.startLineNumber) * s, _ = 2;
              this.renderDecoration(u, f, _, g, Nhe, s);
              continue;
          }
      }
    }
  }
  renderDecorationOnLine(e, t, i, r, o, s, a, l, u, c) {
    const h = (s - o.startLineNumber) * l;
    if (h + a < 0 || h > this._model.options.canvasInnerHeight)
      return;
    let d = t.get(s);
    const f = !d;
    if (!d) {
      const y = this._model.getLineContent(s);
      d = [Vm];
      for (let b = 1; b < y.length + 1; b++) {
        const L = y.charCodeAt(b - 1), S = L === 9 ? u * c : Xa(L) ? 2 * c : c;
        d[b] = d[b - 1] + S;
      }
      t.set(s, d);
    }
    const { startColumn: p, endColumn: g, startLineNumber: _, endLineNumber: m } = i, v = _ === s ? d[p - 1] : Vm, C = m > s ? d.length - 1 : g - 1;
    if (C > 0) {
      const y = d[C] - v || 2;
      this.renderDecoration(e, r, v, h, y, a);
    }
    f && this.renderLineHighlight(e, r, h, a);
  }
  renderLineHighlight(e, t, i, r) {
    e.fillStyle = t && t.transparent(0.5).toString() || "", e.fillRect(Vm, i, e.canvas.width, r);
  }
  renderDecoration(e, t, i, r, o, s) {
    e.fillStyle = t && t.toString() || "", e.fillRect(i, r, o, s);
  }
  renderLines(e) {
    const t = e.startLineNumber, i = e.endLineNumber, r = this._model.options.minimapLineHeight;
    if (this._lastRenderData && this._lastRenderData.linesEquals(e)) {
      const T = this._lastRenderData._get();
      return new S2(e, T.imageData, T.lines);
    }
    const o = this._getBuffer();
    if (!o)
      return null;
    let [s, a, l] = Ub._renderUntouchedLines(o, t, i, r, this._lastRenderData);
    const u = this._model.getMinimapLinesRenderingData(t, i, l), c = this._model.getOptions().tabSize, h = this._model.options.backgroundColor, d = this._model.tokensColorTracker, f = d.backgroundIsLight(), p = this._model.options.renderMinimap, g = this._model.options.charRenderer(), _ = this._model.options.fontScale, m = this._model.options.minimapCharWidth, C = (p === 1 ? 2 : 2 + 1) * _, y = r > C ? Math.floor((r - C) / 2) : 0;
    let b = 0;
    const L = [];
    for (let T = 0, A = i - t + 1; T < A; T++)
      l[T] && Ub._renderLine(o, h, f, p, m, d, g, b, y, c, u[T], _, r), L[T] = new Gb(b), b += r;
    const S = s === -1 ? 0 : s, D = (a === -1 ? o.height : a) - S;
    return this._canvas.domNode.getContext("2d").putImageData(o, 0, 0, 0, S, o.width, D), new S2(e, o, L);
  }
  static _renderUntouchedLines(e, t, i, r, o) {
    const s = [];
    if (!o) {
      for (let E = 0, D = i - t + 1; E < D; E++)
        s[E] = !0;
      return [-1, -1, s];
    }
    const a = o._get(), l = a.imageData.data, u = a.rendLineNumberStart, c = a.lines, h = c.length, d = e.width, f = e.data, p = (i - t + 1) * r * d * 4;
    let g = -1, _ = -1, m = -1, v = -1, C = -1, y = -1, b = 0;
    for (let E = t; E <= i; E++) {
      const D = E - t, O = E - u, T = O >= 0 && O < h ? c[O].dy : -1;
      if (T === -1) {
        s[D] = !0, b += r;
        continue;
      }
      const A = T * d * 4, P = (T + r) * d * 4, G = b * d * 4, U = (b + r) * d * 4;
      v === A && y === G ? (v = P, y = U) : (m !== -1 && (f.set(l.subarray(m, v), C), g === -1 && m === 0 && m === C && (g = v), _ === -1 && v === p && m === C && (_ = m)), m = A, v = P, C = G, y = U), s[D] = !1, b += r;
    }
    m !== -1 && (f.set(l.subarray(m, v), C), g === -1 && m === 0 && m === C && (g = v), _ === -1 && v === p && m === C && (_ = m));
    const L = g === -1 ? -1 : g / (d * 4), S = _ === -1 ? -1 : _ / (d * 4);
    return [L, S, s];
  }
  static _renderLine(e, t, i, r, o, s, a, l, u, c, h, d, f) {
    const p = h.content, g = h.tokens, _ = e.width - o, m = f === 1;
    let v = Vm, C = 0, y = 0;
    for (let b = 0, L = g.getCount(); b < L; b++) {
      const S = g.getEndOffset(b), E = g.getForeground(b), D = s.getColor(E);
      for (; C < S; C++) {
        if (v > _)
          return;
        const O = p.charCodeAt(C);
        if (O === 9) {
          const T = c - (C + y) % c;
          y += T - 1, v += T * o;
        } else if (O === 32)
          v += o;
        else {
          const T = Xa(O) ? 2 : 1;
          for (let A = 0; A < T; A++)
            if (r === 2 ? a.blockRenderChar(e, v, l + u, D, t, i, m) : a.renderChar(e, v, l + u, O, D, t, d, i, m), v += o, v > _)
              return;
        }
      }
    }
  }
}
_a((n, e) => {
  const t = n.getColor(f3);
  t && e.addRule(`.monaco-editor .minimap > canvas { opacity: ${t.rgba.a}; will-change: opacity; }`);
  const i = n.getColor(wce);
  i && e.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${i}; }`);
  const r = n.getColor(bce);
  r && e.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${r}; }`);
  const o = n.getColor(Sce);
  o && e.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${o}; }`);
  const s = n.getColor(C0);
  s && e.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${s} -6px 0 6px -6px inset; }`);
});
class Phe extends Ns {
  constructor(e) {
    super(e);
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    this._widgets = {}, this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, this._domNode = bt(document.createElement("div")), jl.write(
      this._domNode,
      4
      /* OverlayWidgets */
    ), this._domNode.setClassName("overlayWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  getDomNode() {
    return this._domNode;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    return this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, !0;
  }
  // ---- end view event handlers
  addWidget(e) {
    const t = bt(e.getDomNode());
    this._widgets[e.getId()] = {
      widget: e,
      preference: null,
      domNode: t
    }, t.setPosition("absolute"), t.setAttribute("widgetId", e.getId()), this._domNode.appendChild(t), this.setShouldRender();
  }
  setWidgetPosition(e, t) {
    const i = this._widgets[e.getId()];
    return i.preference === t ? !1 : (i.preference = t, this.setShouldRender(), !0);
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const r = this._widgets[t].domNode.domNode;
      delete this._widgets[t], r.parentNode.removeChild(r), this.setShouldRender();
    }
  }
  _renderWidget(e) {
    const t = e.domNode;
    if (e.preference === null) {
      t.unsetTop();
      return;
    }
    if (e.preference === 0)
      t.setTop(0), t.setRight(2 * this._verticalScrollbarWidth + this._minimapWidth);
    else if (e.preference === 1) {
      const i = t.domNode.clientHeight;
      t.setTop(this._editorHeight - i - 2 * this._horizontalScrollbarHeight), t.setRight(2 * this._verticalScrollbarWidth + this._minimapWidth);
    } else
      e.preference === 2 && (t.setTop(0), t.domNode.style.right = "50%");
  }
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setWidth(this._editorWidth);
    const t = Object.keys(this._widgets);
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      this._renderWidget(this._widgets[o]);
    }
  }
}
class Ahe {
  constructor(e, t) {
    const i = e.options;
    this.lineHeight = i.get(
      56
      /* lineHeight */
    ), this.pixelRatio = i.get(
      126
      /* pixelRatio */
    ), this.overviewRulerLanes = i.get(
      71
      /* overviewRulerLanes */
    ), this.renderBorder = i.get(
      70
      /* overviewRulerBorder */
    );
    const r = t.getColor(Pce);
    this.borderColor = r ? r.toString() : null, this.hideCursor = i.get(
      48
      /* hideCursorInOverviewRuler */
    );
    const o = t.getColor(_3);
    this.cursorColor = o ? o.transparent(0.7).toString() : null, this.themeType = t.type;
    const s = i.get(
      62
      /* minimap */
    ), a = s.enabled, l = s.side, u = a ? t.getColor(Ace) || ln.getDefaultBackground() : null;
    u === null || l === "left" ? this.backgroundColor = null : this.backgroundColor = ee.Format.CSS.formatHex(u);
    const h = i.get(
      128
      /* layoutInfo */
    ).overviewRuler;
    this.top = h.top, this.right = h.right, this.domWidth = h.width, this.domHeight = h.height, this.overviewRulerLanes === 0 ? (this.canvasWidth = 0, this.canvasHeight = 0) : (this.canvasWidth = this.domWidth * this.pixelRatio | 0, this.canvasHeight = this.domHeight * this.pixelRatio | 0);
    const [d, f] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);
    this.x = d, this.w = f;
  }
  _initLanes(e, t, i) {
    const r = t - e;
    if (i >= 3) {
      const o = Math.floor(r / 3), s = Math.floor(r / 3), a = r - o - s, l = e, u = l + o, c = l + o + a;
      return [
        [
          0,
          l,
          u,
          l,
          c,
          l,
          u,
          l
          // Left | Center | Right
        ],
        [
          0,
          o,
          a,
          o + a,
          s,
          o + a + s,
          a + s,
          o + a + s
          // Left | Center | Right
        ]
      ];
    } else if (i === 2) {
      const o = Math.floor(r / 2), s = r - o, a = e, l = a + o;
      return [
        [
          0,
          a,
          a,
          a,
          l,
          a,
          a,
          a
          // Left | Center | Right
        ],
        [
          0,
          o,
          o,
          o,
          s,
          o + s,
          o + s,
          o + s
          // Left | Center | Right
        ]
      ];
    } else {
      const o = e, s = r;
      return [
        [
          0,
          o,
          o,
          o,
          o,
          o,
          o,
          o
          // Left | Center | Right
        ],
        [
          0,
          s,
          s,
          s,
          s,
          s,
          s,
          s
          // Left | Center | Right
        ]
      ];
    }
  }
  equals(e) {
    return this.lineHeight === e.lineHeight && this.pixelRatio === e.pixelRatio && this.overviewRulerLanes === e.overviewRulerLanes && this.renderBorder === e.renderBorder && this.borderColor === e.borderColor && this.hideCursor === e.hideCursor && this.cursorColor === e.cursorColor && this.themeType === e.themeType && this.backgroundColor === e.backgroundColor && this.top === e.top && this.right === e.right && this.domWidth === e.domWidth && this.domHeight === e.domHeight && this.canvasWidth === e.canvasWidth && this.canvasHeight === e.canvasHeight;
  }
}
class Mhe extends Ns {
  constructor(e) {
    super(e), this._domNode = bt(document.createElement("canvas")), this._domNode.setClassName("decorationsOverviewRuler"), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._domNode.setAttribute("aria-hidden", "true"), this._updateSettings(!1), this._tokensColorTrackerListener = ln.onDidChange((t) => {
      t.changedColorMap && this._updateSettings(!0);
    }), this._cursorPositions = [];
  }
  dispose() {
    super.dispose(), this._tokensColorTrackerListener.dispose();
  }
  _updateSettings(e) {
    const t = new Ahe(this._context.configuration, this._context.theme);
    return this._settings && this._settings.equals(t) ? !1 : (this._settings = t, this._domNode.setTop(this._settings.top), this._domNode.setRight(this._settings.right), this._domNode.setWidth(this._settings.domWidth), this._domNode.setHeight(this._settings.domHeight), this._domNode.domNode.width = this._settings.canvasWidth, this._domNode.domNode.height = this._settings.canvasHeight, e && this._render(), !0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return this._updateSettings(!1);
  }
  onCursorStateChanged(e) {
    this._cursorPositions = [];
    for (let t = 0, i = e.selections.length; t < i; t++)
      this._cursorPositions[t] = e.selections[t].getPosition();
    return this._cursorPositions.sort(J.compare), !0;
  }
  onDecorationsChanged(e) {
    return !!e.affectsOverviewRuler;
  }
  onFlushed(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onThemeChanged(e) {
    return this._context.model.invalidateOverviewRulerColorCache(), this._updateSettings(!1);
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  prepareRender(e) {
  }
  render(e) {
    this._render();
  }
  _render() {
    if (this._settings.overviewRulerLanes === 0) {
      this._domNode.setBackgroundColor(this._settings.backgroundColor ? this._settings.backgroundColor : "");
      return;
    }
    const e = this._settings.canvasWidth, t = this._settings.canvasHeight, i = this._settings.lineHeight, r = this._context.viewLayout, o = this._context.viewLayout.getScrollHeight(), s = t / o, a = this._context.model.getAllOverviewRulerDecorations(this._context.theme), l = 6 * this._settings.pixelRatio | 0, u = l / 2 | 0, c = this._domNode.domNode.getContext("2d");
    this._settings.backgroundColor === null ? c.clearRect(0, 0, e, t) : (c.fillStyle = this._settings.backgroundColor, c.fillRect(0, 0, e, t));
    const h = this._settings.x, d = this._settings.w, f = Object.keys(a);
    f.sort();
    for (let p = 0, g = f.length; p < g; p++) {
      const _ = f[p], m = a[_];
      c.fillStyle = _;
      let v = 0, C = 0, y = 0;
      for (let b = 0, L = m.length; b < L; b++) {
        const S = m[3 * b], E = m[3 * b + 1], D = m[3 * b + 2];
        let O = r.getVerticalOffsetForLineNumber(E) * s | 0, T = (r.getVerticalOffsetForLineNumber(D) + i) * s | 0;
        if (T - O < l) {
          let P = (O + T) / 2 | 0;
          P < u ? P = u : P + u > t && (P = t - u), O = P - u, T = P + u;
        }
        O > y + 1 || S !== v ? (b !== 0 && c.fillRect(h[v], C, d[v], y - C), v = S, C = O, y = T) : T > y && (y = T);
      }
      c.fillRect(h[v], C, d[v], y - C);
    }
    if (!this._settings.hideCursor && this._settings.cursorColor) {
      const p = 2 * this._settings.pixelRatio | 0, g = p / 2 | 0, _ = this._settings.x[
        7
        /* Full */
      ], m = this._settings.w[
        7
        /* Full */
      ];
      c.fillStyle = this._settings.cursorColor;
      let v = -100, C = -100;
      for (let y = 0, b = this._cursorPositions.length; y < b; y++) {
        const L = this._cursorPositions[y];
        let S = r.getVerticalOffsetForLineNumber(L.lineNumber) * s | 0;
        S < g ? S = g : S + g > t && (S = t - g);
        const E = S - g, D = E + p;
        E > C + 1 ? (y !== 0 && c.fillRect(_, v, m, C - v), v = E, C = D) : D > C && (C = D);
      }
      c.fillRect(_, v, m, C - v);
    }
    this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0 && (c.beginPath(), c.lineWidth = 1, c.strokeStyle = this._settings.borderColor, c.moveTo(0, 0), c.lineTo(0, t), c.stroke(), c.moveTo(0, 0), c.lineTo(e, 0), c.stroke());
  }
}
class E2 {
  constructor(e, t, i) {
    this.from = e | 0, this.to = t | 0, this.colorId = i | 0;
  }
  static compare(e, t) {
    return e.colorId === t.colorId ? e.from === t.from ? e.to - t.to : e.from - t.from : e.colorId - t.colorId;
  }
}
class n_ {
  constructor(e, t, i) {
    this.startLineNumber = e, this.endLineNumber = t, this.color = i, this._colorZone = null;
  }
  static compare(e, t) {
    return e.color === t.color ? e.startLineNumber === t.startLineNumber ? e.endLineNumber - t.endLineNumber : e.startLineNumber - t.startLineNumber : e.color < t.color ? -1 : 1;
  }
  setColorZone(e) {
    this._colorZone = e;
  }
  getColorZones() {
    return this._colorZone;
  }
}
class Fhe {
  constructor(e) {
    this._getVerticalOffsetForLine = e, this._zones = [], this._colorZonesInvalid = !1, this._lineHeight = 0, this._domWidth = 0, this._domHeight = 0, this._outerHeight = 0, this._pixelRatio = 1, this._lastAssignedId = 0, this._color2Id = /* @__PURE__ */ Object.create(null), this._id2Color = [];
  }
  getId2Color() {
    return this._id2Color;
  }
  setZones(e) {
    this._zones = e, this._zones.sort(n_.compare);
  }
  setLineHeight(e) {
    return this._lineHeight === e ? !1 : (this._lineHeight = e, this._colorZonesInvalid = !0, !0);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this._colorZonesInvalid = !0;
  }
  getDOMWidth() {
    return this._domWidth;
  }
  getCanvasWidth() {
    return this._domWidth * this._pixelRatio;
  }
  setDOMWidth(e) {
    return this._domWidth === e ? !1 : (this._domWidth = e, this._colorZonesInvalid = !0, !0);
  }
  getDOMHeight() {
    return this._domHeight;
  }
  getCanvasHeight() {
    return this._domHeight * this._pixelRatio;
  }
  setDOMHeight(e) {
    return this._domHeight === e ? !1 : (this._domHeight = e, this._colorZonesInvalid = !0, !0);
  }
  getOuterHeight() {
    return this._outerHeight;
  }
  setOuterHeight(e) {
    return this._outerHeight === e ? !1 : (this._outerHeight = e, this._colorZonesInvalid = !0, !0);
  }
  resolveColorZones() {
    const e = this._colorZonesInvalid, t = Math.floor(this._lineHeight), i = Math.floor(this.getCanvasHeight()), r = Math.floor(this._outerHeight), o = i / r, s = Math.floor(4 * this._pixelRatio / 2);
    let a = [];
    for (let l = 0, u = this._zones.length; l < u; l++) {
      const c = this._zones[l];
      if (!e) {
        const v = c.getColorZones();
        if (v) {
          a.push(v);
          continue;
        }
      }
      const h = Math.floor(o * this._getVerticalOffsetForLine(c.startLineNumber)), d = Math.floor(o * (this._getVerticalOffsetForLine(c.endLineNumber) + t));
      let f = Math.floor((h + d) / 2), p = d - f;
      p < s && (p = s), f - p < 0 && (f = p), f + p > i && (f = i - p);
      const g = c.color;
      let _ = this._color2Id[g];
      _ || (_ = ++this._lastAssignedId, this._color2Id[g] = _, this._id2Color[_] = g);
      const m = new E2(f - p, f + p, _);
      c.setColorZone(m), a.push(m);
    }
    return this._colorZonesInvalid = !1, a.sort(E2.compare), a;
  }
}
class khe extends z_ {
  constructor(e, t) {
    super(), this._context = e;
    const i = this._context.configuration.options;
    this._domNode = bt(document.createElement("canvas")), this._domNode.setClassName(t), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._zoneManager = new Fhe((r) => this._context.viewLayout.getVerticalOffsetForLineNumber(r)), this._zoneManager.setDOMWidth(0), this._zoneManager.setDOMHeight(0), this._zoneManager.setOuterHeight(this._context.viewLayout.getScrollHeight()), this._zoneManager.setLineHeight(i.get(
      56
      /* lineHeight */
    )), this._zoneManager.setPixelRatio(i.get(
      126
      /* pixelRatio */
    )), this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return e.hasChanged(
      56
      /* lineHeight */
    ) && (this._zoneManager.setLineHeight(t.get(
      56
      /* lineHeight */
    )), this._render()), e.hasChanged(
      126
      /* pixelRatio */
    ) && (this._zoneManager.setPixelRatio(t.get(
      126
      /* pixelRatio */
    )), this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render()), !0;
  }
  onFlushed(e) {
    return this._render(), !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged && (this._zoneManager.setOuterHeight(e.scrollHeight), this._render()), !0;
  }
  onZonesChanged(e) {
    return this._render(), !0;
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  setLayout(e) {
    this._domNode.setTop(e.top), this._domNode.setRight(e.right);
    let t = !1;
    t = this._zoneManager.setDOMWidth(e.width) || t, t = this._zoneManager.setDOMHeight(e.height) || t, t && (this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render());
  }
  setZones(e) {
    this._zoneManager.setZones(e), this._render();
  }
  _render() {
    if (this._zoneManager.getOuterHeight() === 0)
      return !1;
    const e = this._zoneManager.getCanvasWidth(), t = this._zoneManager.getCanvasHeight(), i = this._zoneManager.resolveColorZones(), r = this._zoneManager.getId2Color(), o = this._domNode.domNode.getContext("2d");
    return o.clearRect(0, 0, e, t), i.length > 0 && this._renderOneLane(o, i, r, e), !0;
  }
  _renderOneLane(e, t, i, r) {
    let o = 0, s = 0, a = 0;
    for (const l of t) {
      const u = l.colorId, c = l.from, h = l.to;
      u !== o ? (e.fillRect(0, s, r, a - s), o = u, e.fillStyle = i[o], s = c, a = h) : a >= c ? a = Math.max(a, h) : (e.fillRect(0, s, r, a - s), s = c, a = h);
    }
    e.fillRect(0, s, r, a - s);
  }
}
class Whe extends Ns {
  constructor(e) {
    super(e), this.domNode = bt(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("view-rulers"), this._renderedRulers = [];
    const t = this._context.configuration.options;
    this._rulers = t.get(
      89
      /* rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth;
  }
  dispose() {
    super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._rulers = t.get(
      89
      /* rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  _ensureRulersCount() {
    const e = this._renderedRulers.length, t = this._rulers.length;
    if (e === t)
      return;
    if (e < t) {
      const { tabSize: r } = this._context.model.getTextModelOptions(), o = r;
      let s = t - e;
      for (; s > 0; ) {
        const a = bt(document.createElement("div"));
        a.setClassName("view-ruler"), a.setWidth(o), this.domNode.appendChild(a), this._renderedRulers.push(a), s--;
      }
      return;
    }
    let i = e - t;
    for (; i > 0; ) {
      const r = this._renderedRulers.pop();
      this.domNode.removeChild(r), i--;
    }
  }
  render(e) {
    this._ensureRulersCount();
    for (let t = 0, i = this._rulers.length; t < i; t++) {
      const r = this._renderedRulers[t], o = this._rulers[t];
      r.setBoxShadow(o.color ? `1px 0 0 0 ${o.color} inset` : ""), r.setHeight(Math.min(e.scrollHeight, 1e6)), r.setLeft(o.column * this._typicalHalfwidthCharacterWidth);
    }
  }
}
_a((n, e) => {
  const t = n.getColor(Ice);
  t && e.addRule(`.monaco-editor .view-ruler { box-shadow: 1px 0 0 0 ${t} inset; }`);
});
class Vhe extends Ns {
  constructor(e) {
    super(e), this._scrollTop = 0, this._width = 0, this._updateWidth(), this._shouldShow = !1;
    const i = this._context.configuration.options.get(
      90
      /* scrollbar */
    );
    this._useShadows = i.useShadows, this._domNode = bt(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
  }
  dispose() {
    super.dispose();
  }
  _updateShouldShow() {
    const e = this._useShadows && this._scrollTop > 0;
    return this._shouldShow !== e ? (this._shouldShow = e, !0) : !1;
  }
  getDomNode() {
    return this._domNode;
  }
  _updateWidth() {
    const t = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    t.minimap.renderMinimap === 0 || t.minimap.minimapWidth > 0 && t.minimap.minimapLeft === 0 ? this._width = t.width : this._width = t.width - t.minimap.minimapWidth - t.verticalScrollbarWidth;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      90
      /* scrollbar */
    );
    return this._useShadows = i.useShadows, this._updateWidth(), this._updateShouldShow(), !0;
  }
  onScrollChanged(e) {
    return this._scrollTop = e.scrollTop, this._updateShouldShow();
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setWidth(this._width), this._domNode.setClassName(this._shouldShow ? "scroll-decoration" : "");
  }
}
_a((n, e) => {
  const t = n.getColor(C0);
  t && e.addRule(`.monaco-editor .scroll-decoration { box-shadow: ${t} 0 6px 6px -6px inset; }`);
});
class Bhe {
  constructor(e) {
    this.left = e.left, this.width = e.width, this.startStyle = null, this.endStyle = null;
  }
}
class Hhe {
  constructor(e, t) {
    this.lineNumber = e, this.ranges = t;
  }
}
function Ghe(n) {
  return new Bhe(n);
}
function Uhe(n) {
  return new Hhe(n.lineNumber, n.ranges.map(Ghe));
}
class Oi extends Dg {
  constructor(e) {
    super(), this._previousFrameVisibleRangesWithStyle = [], this._context = e;
    const t = this._context.configuration.options;
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._roundedSelection = t.get(
      88
      /* roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, this._selections = [], this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._roundedSelection = t.get(
      88
      /* roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _visibleRangesHaveGaps(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t].ranges.length > 1)
        return !0;
    return !1;
  }
  _enrichVisibleRangesWithStyle(e, t, i) {
    const r = this._typicalHalfwidthCharacterWidth / 4;
    let o = null, s = null;
    if (i && i.length > 0 && t.length > 0) {
      const a = t[0].lineNumber;
      if (a === e.startLineNumber)
        for (let u = 0; !o && u < i.length; u++)
          i[u].lineNumber === a && (o = i[u].ranges[0]);
      const l = t[t.length - 1].lineNumber;
      if (l === e.endLineNumber)
        for (let u = i.length - 1; !s && u >= 0; u--)
          i[u].lineNumber === l && (s = i[u].ranges[0]);
      o && !o.startStyle && (o = null), s && !s.startStyle && (s = null);
    }
    for (let a = 0, l = t.length; a < l; a++) {
      const u = t[a].ranges[0], c = u.left, h = u.left + u.width, d = {
        top: 0,
        bottom: 0
        /* EXTERN */
      }, f = {
        top: 0,
        bottom: 0
        /* EXTERN */
      };
      if (a > 0) {
        const p = t[a - 1].ranges[0].left, g = t[a - 1].ranges[0].left + t[a - 1].ranges[0].width;
        Ey(c - p) < r ? d.top = 2 : c > p && (d.top = 1), Ey(h - g) < r ? f.top = 2 : p < h && h < g && (f.top = 1);
      } else
        o && (d.top = o.startStyle.top, f.top = o.endStyle.top);
      if (a + 1 < l) {
        const p = t[a + 1].ranges[0].left, g = t[a + 1].ranges[0].left + t[a + 1].ranges[0].width;
        Ey(c - p) < r ? d.bottom = 2 : p < c && c < g && (d.bottom = 1), Ey(h - g) < r ? f.bottom = 2 : h < g && (f.bottom = 1);
      } else
        s && (d.bottom = s.startStyle.bottom, f.bottom = s.endStyle.bottom);
      u.startStyle = d, u.endStyle = f;
    }
  }
  _getVisibleRangesWithStyle(e, t, i) {
    const o = (t.linesVisibleRangesForRange(e, !0) || []).map(Uhe);
    return !this._visibleRangesHaveGaps(o) && this._roundedSelection && this._enrichVisibleRangesWithStyle(t.visibleRange, o, i), o;
  }
  _createSelectionPiece(e, t, i, r, o) {
    return '<div class="cslr ' + i + '" style="top:' + e.toString() + "px;left:" + r.toString() + "px;width:" + o.toString() + "px;height:" + t + 'px;"></div>';
  }
  _actualRenderOneSelection(e, t, i, r) {
    if (r.length === 0)
      return;
    const o = !!r[0].ranges[0].startStyle, s = this._lineHeight.toString(), a = (this._lineHeight - 1).toString(), l = r[0].lineNumber, u = r[r.length - 1].lineNumber;
    for (let c = 0, h = r.length; c < h; c++) {
      const d = r[c], f = d.lineNumber, p = f - t, g = i && (f === u || f === l) ? a : s, _ = i && f === l ? 1 : 0;
      let m = "", v = "";
      for (let C = 0, y = d.ranges.length; C < y; C++) {
        const b = d.ranges[C];
        if (o) {
          const S = b.startStyle, E = b.endStyle;
          if (S.top === 1 || S.bottom === 1) {
            m += this._createSelectionPiece(_, g, Oi.SELECTION_CLASS_NAME, b.left - Oi.ROUNDED_PIECE_WIDTH, Oi.ROUNDED_PIECE_WIDTH);
            let D = Oi.EDITOR_BACKGROUND_CLASS_NAME;
            S.top === 1 && (D += " " + Oi.SELECTION_TOP_RIGHT), S.bottom === 1 && (D += " " + Oi.SELECTION_BOTTOM_RIGHT), m += this._createSelectionPiece(_, g, D, b.left - Oi.ROUNDED_PIECE_WIDTH, Oi.ROUNDED_PIECE_WIDTH);
          }
          if (E.top === 1 || E.bottom === 1) {
            m += this._createSelectionPiece(_, g, Oi.SELECTION_CLASS_NAME, b.left + b.width, Oi.ROUNDED_PIECE_WIDTH);
            let D = Oi.EDITOR_BACKGROUND_CLASS_NAME;
            E.top === 1 && (D += " " + Oi.SELECTION_TOP_LEFT), E.bottom === 1 && (D += " " + Oi.SELECTION_BOTTOM_LEFT), m += this._createSelectionPiece(_, g, D, b.left + b.width, Oi.ROUNDED_PIECE_WIDTH);
          }
        }
        let L = Oi.SELECTION_CLASS_NAME;
        if (o) {
          const S = b.startStyle, E = b.endStyle;
          S.top === 0 && (L += " " + Oi.SELECTION_TOP_LEFT), S.bottom === 0 && (L += " " + Oi.SELECTION_BOTTOM_LEFT), E.top === 0 && (L += " " + Oi.SELECTION_TOP_RIGHT), E.bottom === 0 && (L += " " + Oi.SELECTION_BOTTOM_RIGHT);
        }
        v += this._createSelectionPiece(_, g, L, b.left, b.width);
      }
      e[p][0] += m, e[p][1] += v;
    }
  }
  prepareRender(e) {
    const t = [], i = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber;
    for (let s = i; s <= r; s++) {
      const a = s - i;
      t[a] = ["", ""];
    }
    const o = [];
    for (let s = 0, a = this._selections.length; s < a; s++) {
      const l = this._selections[s];
      if (l.isEmpty()) {
        o[s] = null;
        continue;
      }
      const u = this._getVisibleRangesWithStyle(l, e, this._previousFrameVisibleRangesWithStyle[s]);
      o[s] = u, this._actualRenderOneSelection(t, i, this._selections.length > 1, u);
    }
    this._previousFrameVisibleRangesWithStyle = o, this._renderResult = t.map(([s, a]) => s + a);
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
Oi.SELECTION_CLASS_NAME = "selected-text";
Oi.SELECTION_TOP_LEFT = "top-left-radius";
Oi.SELECTION_BOTTOM_LEFT = "bottom-left-radius";
Oi.SELECTION_TOP_RIGHT = "top-right-radius";
Oi.SELECTION_BOTTOM_RIGHT = "bottom-right-radius";
Oi.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background";
Oi.ROUNDED_PIECE_WIDTH = 10;
_a((n, e) => {
  const t = n.getColor(Sp);
  t && e.addRule(`.monaco-editor .focused .selected-text { background-color: ${t}; }`);
  const i = n.getColor(eI);
  i && e.addRule(`.monaco-editor .selected-text { background-color: ${i}; }`);
  const r = n.getColor(Uue);
  r && !r.isTransparent() && e.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${r}; }`);
});
function Ey(n) {
  return n < 0 ? -n : n;
}
class L2 {
  constructor(e, t, i, r, o, s) {
    this.top = e, this.left = t, this.width = i, this.height = r, this.textContent = o, this.textContentClassName = s;
  }
}
class D2 {
  constructor(e) {
    this._context = e;
    const t = this._context.configuration.options, i = t.get(
      40
      /* fontInfo */
    );
    this._cursorStyle = t.get(
      22
      /* cursorStyle */
    ), this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(
      25
      /* cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), this._isVisible = !0, this._domNode = bt(document.createElement("div")), this._domNode.setClassName(`cursor ${md}`), this._domNode.setHeight(this._lineHeight), this._domNode.setTop(0), this._domNode.setLeft(0), io.applyFontInfo(this._domNode, i), this._domNode.setDisplay("none"), this._position = new J(1, 1), this._lastRenderedContent = "", this._renderData = null;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._position;
  }
  show() {
    this._isVisible || (this._domNode.setVisibility("inherit"), this._isVisible = !0);
  }
  hide() {
    this._isVisible && (this._domNode.setVisibility("hidden"), this._isVisible = !1);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      40
      /* fontInfo */
    );
    return this._cursorStyle = t.get(
      22
      /* cursorStyle */
    ), this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(
      25
      /* cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), io.applyFontInfo(this._domNode, i), !0;
  }
  onCursorPositionChanged(e) {
    return this._position = e, !0;
  }
  _prepareRender(e) {
    let t = "";
    if (this._cursorStyle === kn.Line || this._cursorStyle === kn.LineThin) {
      const d = e.visibleRangeForPosition(this._position);
      if (!d || d.outsideRenderedLine)
        return null;
      let f;
      if (this._cursorStyle === kn.Line) {
        if (f = EF(this._lineCursorWidth > 0 ? this._lineCursorWidth : 2), f > 2) {
          const _ = this._context.model.getLineContent(this._position.lineNumber), m = ob(_, this._position.column - 1);
          t = _.substr(this._position.column - 1, m);
        }
      } else
        f = EF(1);
      let p = d.left;
      f >= 2 && p >= 1 && (p -= 1);
      const g = e.getVerticalOffsetForLineNumber(this._position.lineNumber) - e.bigNumbersDelta;
      return new L2(g, p, f, this._lineHeight, t, "");
    }
    const i = this._context.model.getLineContent(this._position.lineNumber), r = ob(i, this._position.column - 1), o = e.linesVisibleRangesForRange(new V(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column + r), !1);
    if (!o || o.length === 0)
      return null;
    const s = o[0];
    if (s.outsideRenderedLine || s.ranges.length === 0)
      return null;
    const a = s.ranges[0], l = a.width < 1 ? this._typicalHalfwidthCharacterWidth : a.width;
    let u = "";
    if (this._cursorStyle === kn.Block) {
      const d = this._context.model.getViewLineData(this._position.lineNumber);
      t = i.substr(this._position.column - 1, r);
      const f = d.tokens.findTokenIndexAtOffset(this._position.column - 1);
      u = d.tokens.getClassName(f);
    }
    let c = e.getVerticalOffsetForLineNumber(this._position.lineNumber) - e.bigNumbersDelta, h = this._lineHeight;
    return (this._cursorStyle === kn.Underline || this._cursorStyle === kn.UnderlineThin) && (c += this._lineHeight - 2, h = 2), new L2(c, a.left, l, h, t, u);
  }
  prepareRender(e) {
    this._renderData = this._prepareRender(e);
  }
  render(e) {
    return this._renderData ? (this._lastRenderedContent !== this._renderData.textContent && (this._lastRenderedContent = this._renderData.textContent, this._domNode.domNode.textContent = this._lastRenderedContent), this._domNode.setClassName(`cursor ${md} ${this._renderData.textContentClassName}`), this._domNode.setDisplay("block"), this._domNode.setTop(this._renderData.top), this._domNode.setLeft(this._renderData.left), this._domNode.setWidth(this._renderData.width), this._domNode.setLineHeight(this._renderData.height), this._domNode.setHeight(this._renderData.height), {
      domNode: this._domNode.domNode,
      position: this._position,
      contentLeft: this._renderData.left,
      height: this._renderData.height,
      width: 2
    }) : (this._domNode.setDisplay("none"), null);
  }
}
class r_ extends Ns {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      78
      /* readOnly */
    ), this._cursorBlinking = t.get(
      20
      /* cursorBlinking */
    ), this._cursorStyle = t.get(
      22
      /* cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      21
      /* cursorSmoothCaretAnimation */
    ), this._selectionIsEmpty = !0, this._isComposingInput = !1, this._isVisible = !1, this._primaryCursor = new D2(this._context), this._secondaryCursors = [], this._renderData = [], this._domNode = bt(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._updateDomClassName(), this._domNode.appendChild(this._primaryCursor.getDomNode()), this._startCursorBlinkAnimation = new ec(), this._cursorFlatBlinkInterval = new F_(), this._blinkingEnabled = !1, this._editorHasFocus = !1, this._updateBlinking();
  }
  dispose() {
    super.dispose(), this._startCursorBlinkAnimation.dispose(), this._cursorFlatBlinkInterval.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return this._isComposingInput = !0, this._updateBlinking(), !0;
  }
  onCompositionEnd(e) {
    return this._isComposingInput = !1, this._updateBlinking(), !0;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      78
      /* readOnly */
    ), this._cursorBlinking = t.get(
      20
      /* cursorBlinking */
    ), this._cursorStyle = t.get(
      22
      /* cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      21
      /* cursorSmoothCaretAnimation */
    ), this._updateBlinking(), this._updateDomClassName(), this._primaryCursor.onConfigurationChanged(e);
    for (let i = 0, r = this._secondaryCursors.length; i < r; i++)
      this._secondaryCursors[i].onConfigurationChanged(e);
    return !0;
  }
  _onCursorPositionChanged(e, t) {
    if (this._primaryCursor.onCursorPositionChanged(e), this._updateBlinking(), this._secondaryCursors.length < t.length) {
      const i = t.length - this._secondaryCursors.length;
      for (let r = 0; r < i; r++) {
        const o = new D2(this._context);
        this._domNode.domNode.insertBefore(o.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling), this._secondaryCursors.push(o);
      }
    } else if (this._secondaryCursors.length > t.length) {
      const i = this._secondaryCursors.length - t.length;
      for (let r = 0; r < i; r++)
        this._domNode.removeChild(this._secondaryCursors[0].getDomNode()), this._secondaryCursors.splice(0, 1);
    }
    for (let i = 0; i < t.length; i++)
      this._secondaryCursors[i].onCursorPositionChanged(t[i]);
  }
  onCursorStateChanged(e) {
    const t = [];
    for (let r = 0, o = e.selections.length; r < o; r++)
      t[r] = e.selections[r].getPosition();
    this._onCursorPositionChanged(t[0], t.slice(1));
    const i = e.selections[0].isEmpty();
    return this._selectionIsEmpty !== i && (this._selectionIsEmpty = i, this._updateDomClassName()), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._editorHasFocus = e.isFocused, this._updateBlinking(), !1;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onTokensChanged(e) {
    const t = (i) => {
      for (let r = 0, o = e.ranges.length; r < o; r++)
        if (e.ranges[r].fromLineNumber <= i.lineNumber && i.lineNumber <= e.ranges[r].toLineNumber)
          return !0;
      return !1;
    };
    if (t(this._primaryCursor.getPosition()))
      return !0;
    for (const i of this._secondaryCursors)
      if (t(i.getPosition()))
        return !0;
    return !1;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // ---- blinking logic
  _getCursorBlinking() {
    return this._isComposingInput || !this._editorHasFocus ? 0 : this._readOnly ? 5 : this._cursorBlinking;
  }
  _updateBlinking() {
    this._startCursorBlinkAnimation.cancel(), this._cursorFlatBlinkInterval.cancel();
    const e = this._getCursorBlinking(), t = e === 0, i = e === 5;
    t ? this._hide() : this._show(), this._blinkingEnabled = !1, this._updateDomClassName(), !t && !i && (e === 1 ? this._cursorFlatBlinkInterval.cancelAndSet(() => {
      this._isVisible ? this._hide() : this._show();
    }, r_.BLINK_INTERVAL) : this._startCursorBlinkAnimation.setIfNotSet(() => {
      this._blinkingEnabled = !0, this._updateDomClassName();
    }, r_.BLINK_INTERVAL));
  }
  // --- end blinking logic
  _updateDomClassName() {
    this._domNode.setClassName(this._getClassName());
  }
  _getClassName() {
    let e = "cursors-layer";
    switch (this._selectionIsEmpty || (e += " has-selection"), this._cursorStyle) {
      case kn.Line:
        e += " cursor-line-style";
        break;
      case kn.Block:
        e += " cursor-block-style";
        break;
      case kn.Underline:
        e += " cursor-underline-style";
        break;
      case kn.LineThin:
        e += " cursor-line-thin-style";
        break;
      case kn.BlockOutline:
        e += " cursor-block-outline-style";
        break;
      case kn.UnderlineThin:
        e += " cursor-underline-thin-style";
        break;
      default:
        e += " cursor-line-style";
    }
    if (this._blinkingEnabled)
      switch (this._getCursorBlinking()) {
        case 1:
          e += " cursor-blink";
          break;
        case 2:
          e += " cursor-smooth";
          break;
        case 3:
          e += " cursor-phase";
          break;
        case 4:
          e += " cursor-expand";
          break;
        case 5:
          e += " cursor-solid";
          break;
        default:
          e += " cursor-solid";
      }
    else
      e += " cursor-solid";
    return this._cursorSmoothCaretAnimation && (e += " cursor-smooth-caret-animation"), e;
  }
  _show() {
    this._primaryCursor.show();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].show();
    this._isVisible = !0;
  }
  _hide() {
    this._primaryCursor.hide();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].hide();
    this._isVisible = !1;
  }
  // ---- IViewPart implementation
  prepareRender(e) {
    this._primaryCursor.prepareRender(e);
    for (let t = 0, i = this._secondaryCursors.length; t < i; t++)
      this._secondaryCursors[t].prepareRender(e);
  }
  render(e) {
    let t = [], i = 0;
    const r = this._primaryCursor.render(e);
    r && (t[i++] = r);
    for (let o = 0, s = this._secondaryCursors.length; o < s; o++) {
      const a = this._secondaryCursors[o].render(e);
      a && (t[i++] = a);
    }
    this._renderData = t;
  }
  getLastRenderData() {
    return this._renderData;
  }
}
r_.BLINK_INTERVAL = 500;
_a((n, e) => {
  const t = n.getColor(_3);
  if (t) {
    let i = n.getColor(xce);
    i || (i = t.opposite()), e.addRule(`.monaco-editor .cursors-layer .cursor { background-color: ${t}; border-color: ${t}; color: ${i}; }`), n.type === "hc" && e.addRule(`.monaco-editor .cursors-layer.has-selection .cursor { border-left: 1px solid ${i}; border-right: 1px solid ${i}; }`);
  }
});
const ND = () => {
  throw new Error("Invalid change accessor");
};
class zhe extends Ns {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, this.domNode = bt(document.createElement("div")), this.domNode.setClassName("view-zones"), this.domNode.setPosition("absolute"), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.marginDomNode = bt(document.createElement("div")), this.marginDomNode.setClassName("margin-view-zones"), this.marginDomNode.setPosition("absolute"), this.marginDomNode.setAttribute("role", "presentation"), this.marginDomNode.setAttribute("aria-hidden", "true"), this._zones = {};
  }
  dispose() {
    super.dispose(), this._zones = {};
  }
  // ---- begin view event handlers
  _recomputeWhitespacesProps() {
    const e = this._context.viewLayout.getWhitespaces(), t = /* @__PURE__ */ new Map();
    for (const r of e)
      t.set(r.id, r);
    let i = !1;
    return this._context.model.changeWhitespace((r) => {
      const o = Object.keys(this._zones);
      for (let s = 0, a = o.length; s < a; s++) {
        const l = o[s], u = this._zones[l], c = this._computeWhitespaceProps(u.delegate), h = t.get(l);
        h && (h.afterLineNumber !== c.afterViewLineNumber || h.height !== c.heightInPx) && (r.changeOneWhitespace(l, c.afterViewLineNumber, c.heightInPx), this._safeCallOnComputedHeight(u.delegate, c.heightInPx), i = !0);
      }
    }), i;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, e.hasChanged(
      56
      /* lineHeight */
    ) && this._recomputeWhitespacesProps(), !0;
  }
  onLineMappingChanged(e) {
    return this._recomputeWhitespacesProps();
  }
  onLinesDeleted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  // ---- end view event handlers
  _getZoneOrdinal(e) {
    return typeof e.afterColumn < "u" ? e.afterColumn : 1e4;
  }
  _computeWhitespaceProps(e) {
    if (e.afterLineNumber === 0)
      return {
        afterViewLineNumber: 0,
        heightInPx: this._heightInPixels(e),
        minWidthInPx: this._minWidthInPixels(e)
      };
    let t;
    if (typeof e.afterColumn < "u")
      t = this._context.model.validateModelPosition({
        lineNumber: e.afterLineNumber,
        column: e.afterColumn
      });
    else {
      const s = this._context.model.validateModelPosition({
        lineNumber: e.afterLineNumber,
        column: 1
      }).lineNumber;
      t = new J(s, this._context.model.getModelLineMaxColumn(s));
    }
    let i;
    t.column === this._context.model.getModelLineMaxColumn(t.lineNumber) ? i = this._context.model.validateModelPosition({
      lineNumber: t.lineNumber + 1,
      column: 1
    }) : i = this._context.model.validateModelPosition({
      lineNumber: t.lineNumber,
      column: t.column + 1
    });
    const r = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(t), o = this._context.model.coordinatesConverter.modelPositionIsVisible(i);
    return {
      afterViewLineNumber: r.lineNumber,
      heightInPx: o ? this._heightInPixels(e) : 0,
      minWidthInPx: this._minWidthInPixels(e)
    };
  }
  changeViewZones(e) {
    let t = !1;
    return this._context.model.changeWhitespace((i) => {
      const r = {
        addZone: (o) => (t = !0, this._addZone(i, o)),
        removeZone: (o) => {
          o && (t = this._removeZone(i, o) || t);
        },
        layoutZone: (o) => {
          o && (t = this._layoutZone(i, o) || t);
        }
      };
      jhe(e, r), r.addZone = ND, r.removeZone = ND, r.layoutZone = ND;
    }), t;
  }
  _addZone(e, t) {
    const i = this._computeWhitespaceProps(t), o = {
      whitespaceId: e.insertWhitespace(i.afterViewLineNumber, this._getZoneOrdinal(t), i.heightInPx, i.minWidthInPx),
      delegate: t,
      isVisible: !1,
      domNode: bt(t.domNode),
      marginDomNode: t.marginDomNode ? bt(t.marginDomNode) : null
    };
    return this._safeCallOnComputedHeight(o.delegate, i.heightInPx), o.domNode.setPosition("absolute"), o.domNode.domNode.style.width = "100%", o.domNode.setDisplay("none"), o.domNode.setAttribute("monaco-view-zone", o.whitespaceId), this.domNode.appendChild(o.domNode), o.marginDomNode && (o.marginDomNode.setPosition("absolute"), o.marginDomNode.domNode.style.width = "100%", o.marginDomNode.setDisplay("none"), o.marginDomNode.setAttribute("monaco-view-zone", o.whitespaceId), this.marginDomNode.appendChild(o.marginDomNode)), this._zones[o.whitespaceId] = o, this.setShouldRender(), o.whitespaceId;
  }
  _removeZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t];
      return delete this._zones[t], e.removeWhitespace(i.whitespaceId), i.domNode.removeAttribute("monaco-visible-view-zone"), i.domNode.removeAttribute("monaco-view-zone"), i.domNode.domNode.parentNode.removeChild(i.domNode.domNode), i.marginDomNode && (i.marginDomNode.removeAttribute("monaco-visible-view-zone"), i.marginDomNode.removeAttribute("monaco-view-zone"), i.marginDomNode.domNode.parentNode.removeChild(i.marginDomNode.domNode)), this.setShouldRender(), !0;
    }
    return !1;
  }
  _layoutZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t], r = this._computeWhitespaceProps(i.delegate);
      return e.changeOneWhitespace(i.whitespaceId, r.afterViewLineNumber, r.heightInPx), this._safeCallOnComputedHeight(i.delegate, r.heightInPx), this.setShouldRender(), !0;
    }
    return !1;
  }
  shouldSuppressMouseDownOnViewZone(e) {
    return this._zones.hasOwnProperty(e) ? !!this._zones[e].delegate.suppressMouseDown : !1;
  }
  _heightInPixels(e) {
    return typeof e.heightInPx == "number" ? e.heightInPx : typeof e.heightInLines == "number" ? this._lineHeight * e.heightInLines : this._lineHeight;
  }
  _minWidthInPixels(e) {
    return typeof e.minWidthInPx == "number" ? e.minWidthInPx : 0;
  }
  _safeCallOnComputedHeight(e, t) {
    if (typeof e.onComputedHeight == "function")
      try {
        e.onComputedHeight(t);
      } catch (i) {
        Ni(i);
      }
  }
  _safeCallOnDomNodeTop(e, t) {
    if (typeof e.onDomNodeTop == "function")
      try {
        e.onDomNodeTop(t);
      } catch (i) {
        Ni(i);
      }
  }
  prepareRender(e) {
  }
  render(e) {
    const t = e.viewportData.whitespaceViewportData, i = {};
    let r = !1;
    for (let s = 0, a = t.length; s < a; s++)
      i[t[s].id] = t[s], r = !0;
    const o = Object.keys(this._zones);
    for (let s = 0, a = o.length; s < a; s++) {
      const l = o[s], u = this._zones[l];
      let c = 0, h = 0, d = "none";
      i.hasOwnProperty(l) ? (c = i[l].verticalOffset - e.bigNumbersDelta, h = i[l].height, d = "block", u.isVisible || (u.domNode.setAttribute("monaco-visible-view-zone", "true"), u.isVisible = !0), this._safeCallOnDomNodeTop(u.delegate, e.getScrolledTopFromAbsoluteTop(i[l].verticalOffset))) : (u.isVisible && (u.domNode.removeAttribute("monaco-visible-view-zone"), u.isVisible = !1), this._safeCallOnDomNodeTop(u.delegate, e.getScrolledTopFromAbsoluteTop(-1e6))), u.domNode.setTop(c), u.domNode.setHeight(h), u.domNode.setDisplay(d), u.marginDomNode && (u.marginDomNode.setTop(c), u.marginDomNode.setHeight(h), u.marginDomNode.setDisplay(d));
    }
    r && (this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth)), this.marginDomNode.setWidth(this._contentLeft));
  }
}
function jhe(n, e) {
  try {
    return n(e);
  } catch (t) {
    Ni(t);
  }
}
class $he {
  constructor(e) {
    this._theme = e;
  }
  get type() {
    return this._theme.type;
  }
  update(e) {
    this._theme = e;
  }
  getColor(e) {
    return this._theme.getColor(e);
  }
}
class Khe {
  constructor(e, t, i) {
    this.configuration = e, this.theme = new $he(t), this.model = i, this.viewLayout = i.viewLayout;
  }
  addEventHandler(e) {
    this.model.addViewEventHandler(e);
  }
  removeEventHandler(e) {
    this.model.removeViewEventHandler(e);
  }
}
class qhe {
  constructor(e, t, i, r) {
    this.selections = e, this.startLineNumber = t.startLineNumber | 0, this.endLineNumber = t.endLineNumber | 0, this.relativeVerticalOffset = t.relativeVerticalOffset, this.bigNumbersDelta = t.bigNumbersDelta | 0, this.whitespaceViewportData = i, this._model = r, this.visibleRange = new V(t.startLineNumber, this._model.getLineMinColumn(t.startLineNumber), t.endLineNumber, this._model.getLineMaxColumn(t.endLineNumber));
  }
  getViewLineRenderingData(e) {
    return this._model.getViewLineRenderingData(this.visibleRange, e);
  }
  getDecorationsInViewport() {
    return this._model.getDecorationsInViewport(this.visibleRange);
  }
}
class Yhe extends z_ {
  constructor(e, t, i, r, o, s) {
    super(), this._selections = [new Ut(1, 1, 1, 1)], this._renderAnimationFrame = null;
    const a = new qce(t, r, o, e);
    this._context = new Khe(t, i.getColorTheme(), r), this._configPixelRatio = this._context.configuration.options.get(
      126
      /* pixelRatio */
    ), this._context.addEventHandler(this), this._register(i.onDidColorThemeChange((g) => {
      this._context.theme.update(g), this._context.model.onDidColorThemeChange(), this.render(!0, !1);
    })), this._viewParts = [], this._textAreaHandler = new Hce(this._context, a, this._createTextAreaHandlerHelper()), this._viewParts.push(this._textAreaHandler), this._linesContent = bt(document.createElement("div")), this._linesContent.setClassName("lines-content monaco-editor-background"), this._linesContent.setPosition("absolute"), this.domNode = bt(document.createElement("div")), this.domNode.setClassName(this._getEditorClassName()), this.domNode.setAttribute("role", "code"), this._overflowGuardContainer = bt(document.createElement("div")), jl.write(
      this._overflowGuardContainer,
      3
      /* OverflowGuard */
    ), this._overflowGuardContainer.setClassName("overflow-guard"), this._scrollbar = new yhe(this._context, this._linesContent, this.domNode, this._overflowGuardContainer), this._viewParts.push(this._scrollbar), this._viewLines = new L0(this._context, this._linesContent), this._viewZones = new zhe(this._context), this._viewParts.push(this._viewZones);
    const l = new Mhe(this._context);
    this._viewParts.push(l);
    const u = new Vhe(this._context);
    this._viewParts.push(u);
    const c = new Zce(this._context);
    this._viewParts.push(c), c.addDynamicOverlay(new the(this._context)), c.addDynamicOverlay(new Oi(this._context)), c.addDynamicOverlay(new bhe(this._context)), c.addDynamicOverlay(new nhe(this._context));
    const h = new Qce(this._context);
    this._viewParts.push(h), h.addDynamicOverlay(new ihe(this._context)), h.addDynamicOverlay(new whe(this._context)), h.addDynamicOverlay(new Rhe(this._context)), h.addDynamicOverlay(new Dhe(this._context)), h.addDynamicOverlay(new qp(this._context));
    const d = new Fd(this._context);
    d.getDomNode().appendChild(this._viewZones.marginDomNode), d.getDomNode().appendChild(h.getDomNode()), this._viewParts.push(d), this._contentWidgets = new Jce(this._context, this.domNode), this._viewParts.push(this._contentWidgets), this._viewCursors = new r_(this._context), this._viewParts.push(this._viewCursors), this._overlayWidgets = new Phe(this._context), this._viewParts.push(this._overlayWidgets);
    const f = new Whe(this._context);
    this._viewParts.push(f);
    const p = new Ihe(this._context);
    if (this._viewParts.push(p), l) {
      const g = this._scrollbar.getOverviewRulerLayoutInfo();
      g.parent.insertBefore(l.getDomNode(), g.insertBefore);
    }
    this._linesContent.appendChild(c.getDomNode()), this._linesContent.appendChild(f.domNode), this._linesContent.appendChild(this._viewZones.domNode), this._linesContent.appendChild(this._viewLines.getDomNode()), this._linesContent.appendChild(this._contentWidgets.domNode), this._linesContent.appendChild(this._viewCursors.getDomNode()), this._overflowGuardContainer.appendChild(d.getDomNode()), this._overflowGuardContainer.appendChild(this._scrollbar.getDomNode()), this._overflowGuardContainer.appendChild(u.getDomNode()), this._overflowGuardContainer.appendChild(this._textAreaHandler.textArea), this._overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover), this._overflowGuardContainer.appendChild(this._overlayWidgets.getDomNode()), this._overflowGuardContainer.appendChild(p.getDomNode()), this.domNode.appendChild(this._overflowGuardContainer), s ? s.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode.domNode) : this.domNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode), this._applyLayout(), this._pointerHandler = this._register(new due(this._context, a, this._createPointerHandlerHelper()));
  }
  _flushAccumulatedAndRenderNow() {
    this._renderNow();
  }
  _createPointerHandlerHelper() {
    return {
      viewDomNode: this.domNode.domNode,
      linesContentDomNode: this._linesContent.domNode,
      focusTextArea: () => {
        this.focus();
      },
      dispatchTextAreaEvent: (e) => {
        this._textAreaHandler.textArea.domNode.dispatchEvent(e);
      },
      getLastRenderData: () => {
        const e = this._viewCursors.getLastRenderData() || [], t = this._textAreaHandler.getLastRenderData();
        return new nue(e, t);
      },
      shouldSuppressMouseDownOnViewZone: (e) => this._viewZones.shouldSuppressMouseDownOnViewZone(e),
      shouldSuppressMouseDownOnWidget: (e) => this._contentWidgets.shouldSuppressMouseDownOnWidget(e),
      getPositionFromDOMInfo: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getPositionFromDOMInfo(e, t)),
      visibleRangeForPosition: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(new J(e, t))),
      getLineWidth: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getLineWidth(e))
    };
  }
  _createTextAreaHandlerHelper() {
    return {
      visibleRangeForPositionRelativeToEditor: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(new J(e, t)))
    };
  }
  _applyLayout() {
    const t = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    this.domNode.setWidth(t.width), this.domNode.setHeight(t.height), this._overflowGuardContainer.setWidth(t.width), this._overflowGuardContainer.setHeight(t.height), this._linesContent.setWidth(1e6), this._linesContent.setHeight(1e6);
  }
  _getEditorClassName() {
    const e = this._textAreaHandler.isFocused() ? " focused" : "";
    return this._context.configuration.options.get(
      125
      /* editorClassName */
    ) + " " + Ob(this._context.theme.type) + e;
  }
  // --- begin event handlers
  handleEvents(e) {
    super.handleEvents(e), this._scheduleRender();
  }
  onConfigurationChanged(e) {
    return this._configPixelRatio = this._context.configuration.options.get(
      126
      /* pixelRatio */
    ), this.domNode.setClassName(this._getEditorClassName()), this._applyLayout(), !1;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, !1;
  }
  onFocusChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  onThemeChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  // --- end event handlers
  dispose() {
    this._renderAnimationFrame !== null && (this._renderAnimationFrame.dispose(), this._renderAnimationFrame = null), this._contentWidgets.overflowingContentWidgetsDomNode.domNode.remove(), this._context.removeEventHandler(this), this._viewLines.dispose();
    for (const e of this._viewParts)
      e.dispose();
    super.dispose();
  }
  _scheduleRender() {
    this._renderAnimationFrame === null && (this._renderAnimationFrame = bG(this._onRenderScheduled.bind(this), 100));
  }
  _onRenderScheduled() {
    this._renderAnimationFrame = null, this._flushAccumulatedAndRenderNow();
  }
  _renderNow() {
    Xhe(() => this._actualRender());
  }
  _getViewPartsToRender() {
    let e = [], t = 0;
    for (const i of this._viewParts)
      i.shouldRender() && (e[t++] = i);
    return e;
  }
  _actualRender() {
    if (!CG(this.domNode.domNode))
      return;
    let e = this._getViewPartsToRender();
    if (!this._viewLines.shouldRender() && e.length === 0)
      return;
    const t = this._context.viewLayout.getLinesViewportData();
    this._context.model.setViewport(t.startLineNumber, t.endLineNumber, t.centeredLineNumber);
    const i = new qhe(this._selections, t, this._context.viewLayout.getWhitespaceViewportData(), this._context.model);
    this._contentWidgets.shouldRender() && this._contentWidgets.onBeforeRender(i), this._viewLines.shouldRender() && (this._viewLines.renderText(i), this._viewLines.onDidRender(), e = this._getViewPartsToRender());
    const r = new Yae(this._context.viewLayout, i, this._viewLines);
    for (const o of e)
      o.prepareRender(r);
    for (const o of e)
      o.render(r), o.onDidRender();
    Math.abs(nb() - this._configPixelRatio) > 1e-3 && this._context.configuration.updatePixelRatio();
  }
  // --- BEGIN CodeEditor helpers
  delegateVerticalScrollbarMouseDown(e) {
    this._scrollbar.delegateVerticalScrollbarMouseDown(e);
  }
  restoreState(e) {
    this._context.model.setScrollPosition(
      { scrollTop: e.scrollTop },
      1
      /* Immediate */
    ), this._context.model.tokenizeViewport(), this._renderNow(), this._viewLines.updateLineWidths(), this._context.model.setScrollPosition(
      { scrollLeft: e.scrollLeft },
      1
      /* Immediate */
    );
  }
  getOffsetForColumn(e, t) {
    const i = this._context.model.validateModelPosition({
      lineNumber: e,
      column: t
    }), r = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(i);
    this._flushAccumulatedAndRenderNow();
    const o = this._viewLines.visibleRangeForPosition(new J(r.lineNumber, r.column));
    return o ? o.left : -1;
  }
  getTargetAtClientPoint(e, t) {
    const i = this._pointerHandler.getTargetAtClientPoint(e, t);
    return i ? b0.convertViewToModelMouseTarget(i, this._context.model.coordinatesConverter) : null;
  }
  createOverviewRuler(e) {
    return new khe(this._context, e);
  }
  change(e) {
    this._viewZones.changeViewZones(e), this._scheduleRender();
  }
  render(e, t) {
    if (t) {
      this._viewLines.forceShouldRender();
      for (const i of this._viewParts)
        i.forceShouldRender();
    }
    e ? this._flushAccumulatedAndRenderNow() : this._scheduleRender();
  }
  focus() {
    this._textAreaHandler.focusTextArea();
  }
  isFocused() {
    return this._textAreaHandler.isFocused();
  }
  setAriaOptions(e) {
    this._textAreaHandler.setAriaOptions(e);
  }
  addContentWidget(e) {
    this._contentWidgets.addWidget(e.widget), this.layoutContentWidget(e), this._scheduleRender();
  }
  layoutContentWidget(e) {
    let t = e.position && e.position.range || null;
    if (t === null) {
      const r = e.position ? e.position.position : null;
      r !== null && (t = new V(r.lineNumber, r.column, r.lineNumber, r.column));
    }
    const i = e.position ? e.position.preference : null;
    this._contentWidgets.setWidgetPosition(e.widget, t, i), this._scheduleRender();
  }
  removeContentWidget(e) {
    this._contentWidgets.removeWidget(e.widget), this._scheduleRender();
  }
  addOverlayWidget(e) {
    this._overlayWidgets.addWidget(e.widget), this.layoutOverlayWidget(e), this._scheduleRender();
  }
  layoutOverlayWidget(e) {
    const t = e.position ? e.position.preference : null;
    this._overlayWidgets.setWidgetPosition(e.widget, t) && this._scheduleRender();
  }
  removeOverlayWidget(e) {
    this._overlayWidgets.removeWidget(e.widget), this._scheduleRender();
  }
}
function Xhe(n) {
  try {
    return n();
  } catch (e) {
    Ni(e);
  }
}
class R2 {
  constructor(e) {
    this._selTrackedRange = null, this._trackSelection = !0, this._setState(e, new $n(new V(1, 1, 1, 1), 0, new J(1, 1), 0), new $n(new V(1, 1, 1, 1), 0, new J(1, 1), 0));
  }
  dispose(e) {
    this._removeTrackedRange(e);
  }
  startTrackingSelection(e) {
    this._trackSelection = !0, this._updateTrackedRange(e);
  }
  stopTrackingSelection(e) {
    this._trackSelection = !1, this._removeTrackedRange(e);
  }
  _updateTrackedRange(e) {
    this._trackSelection && (this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      this.modelState.selection,
      0
      /* AlwaysGrowsWhenTypingAtEdges */
    ));
  }
  _removeTrackedRange(e) {
    this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      null,
      0
      /* AlwaysGrowsWhenTypingAtEdges */
    );
  }
  asCursorState() {
    return new st(this.modelState, this.viewState);
  }
  readSelectionFromMarkers(e) {
    const t = e.model._getTrackedRange(this._selTrackedRange);
    return this.modelState.selection.getDirection() === 0 ? new Ut(t.startLineNumber, t.startColumn, t.endLineNumber, t.endColumn) : new Ut(t.endLineNumber, t.endColumn, t.startLineNumber, t.startColumn);
  }
  ensureValidState(e) {
    this._setState(e, this.modelState, this.viewState);
  }
  setState(e, t, i) {
    this._setState(e, t, i);
  }
  _setState(e, t, i) {
    if (t) {
      const r = e.model.validateRange(t.selectionStart), o = t.selectionStart.equalsRange(r) ? t.selectionStartLeftoverVisibleColumns : 0, s = e.model.validatePosition(t.position), a = t.position.equals(s) ? t.leftoverVisibleColumns : 0;
      t = new $n(r, o, s, a);
    } else {
      if (!i)
        return;
      const r = e.model.validateRange(e.coordinatesConverter.convertViewRangeToModelRange(i.selectionStart)), o = e.model.validatePosition(e.coordinatesConverter.convertViewPositionToModelPosition(i.position));
      t = new $n(r, i.selectionStartLeftoverVisibleColumns, o, i.leftoverVisibleColumns);
    }
    if (i) {
      const r = e.coordinatesConverter.validateViewRange(i.selectionStart, t.selectionStart), o = e.coordinatesConverter.validateViewPosition(i.position, t.position);
      i = new $n(r, t.selectionStartLeftoverVisibleColumns, o, t.leftoverVisibleColumns);
    } else {
      const r = e.coordinatesConverter.convertModelPositionToViewPosition(new J(t.selectionStart.startLineNumber, t.selectionStart.startColumn)), o = e.coordinatesConverter.convertModelPositionToViewPosition(new J(t.selectionStart.endLineNumber, t.selectionStart.endColumn)), s = new V(r.lineNumber, r.column, o.lineNumber, o.column), a = e.coordinatesConverter.convertModelPositionToViewPosition(t.position);
      i = new $n(s, t.selectionStartLeftoverVisibleColumns, a, t.leftoverVisibleColumns);
    }
    this.modelState = t, this.viewState = i, this._updateTrackedRange(e);
  }
}
class T2 {
  constructor(e) {
    this.context = e, this.primaryCursor = new R2(e), this.secondaryCursors = [], this.lastAddedCursorIndex = 0;
  }
  dispose() {
    this.primaryCursor.dispose(this.context), this.killSecondaryCursors();
  }
  startTrackingSelections() {
    this.primaryCursor.startTrackingSelection(this.context);
    for (let e = 0, t = this.secondaryCursors.length; e < t; e++)
      this.secondaryCursors[e].startTrackingSelection(this.context);
  }
  stopTrackingSelections() {
    this.primaryCursor.stopTrackingSelection(this.context);
    for (let e = 0, t = this.secondaryCursors.length; e < t; e++)
      this.secondaryCursors[e].stopTrackingSelection(this.context);
  }
  updateContext(e) {
    this.context = e;
  }
  ensureValidState() {
    this.primaryCursor.ensureValidState(this.context);
    for (let e = 0, t = this.secondaryCursors.length; e < t; e++)
      this.secondaryCursors[e].ensureValidState(this.context);
  }
  readSelectionFromMarkers() {
    let e = [];
    e[0] = this.primaryCursor.readSelectionFromMarkers(this.context);
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t].readSelectionFromMarkers(this.context);
    return e;
  }
  getAll() {
    let e = [];
    e[0] = this.primaryCursor.asCursorState();
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t].asCursorState();
    return e;
  }
  getViewPositions() {
    let e = [];
    e[0] = this.primaryCursor.viewState.position;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t].viewState.position;
    return e;
  }
  getTopMostViewPosition() {
    let e = this.primaryCursor.viewState.position;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++) {
      const r = this.secondaryCursors[t].viewState.position;
      r.isBefore(e) && (e = r);
    }
    return e;
  }
  getBottomMostViewPosition() {
    let e = this.primaryCursor.viewState.position;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++) {
      const r = this.secondaryCursors[t].viewState.position;
      e.isBeforeOrEqual(r) && (e = r);
    }
    return e;
  }
  getSelections() {
    let e = [];
    e[0] = this.primaryCursor.modelState.selection;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t].modelState.selection;
    return e;
  }
  getViewSelections() {
    let e = [];
    e[0] = this.primaryCursor.viewState.selection;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t].viewState.selection;
    return e;
  }
  setSelections(e) {
    this.setStates(st.fromModelSelections(e));
  }
  getPrimaryCursor() {
    return this.primaryCursor.asCursorState();
  }
  setStates(e) {
    e !== null && (this.primaryCursor.setState(this.context, e[0].modelState, e[0].viewState), this._setSecondaryStates(e.slice(1)));
  }
  /**
   * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.
   */
  _setSecondaryStates(e) {
    const t = this.secondaryCursors.length, i = e.length;
    if (t < i) {
      let r = i - t;
      for (let o = 0; o < r; o++)
        this._addSecondaryCursor();
    } else if (t > i) {
      let r = t - i;
      for (let o = 0; o < r; o++)
        this._removeSecondaryCursor(this.secondaryCursors.length - 1);
    }
    for (let r = 0; r < i; r++)
      this.secondaryCursors[r].setState(this.context, e[r].modelState, e[r].viewState);
  }
  killSecondaryCursors() {
    this._setSecondaryStates([]);
  }
  _addSecondaryCursor() {
    this.secondaryCursors.push(new R2(this.context)), this.lastAddedCursorIndex = this.secondaryCursors.length;
  }
  getLastAddedCursorIndex() {
    return this.secondaryCursors.length === 0 || this.lastAddedCursorIndex === 0 ? 0 : this.lastAddedCursorIndex;
  }
  _removeSecondaryCursor(e) {
    this.lastAddedCursorIndex >= e + 1 && this.lastAddedCursorIndex--, this.secondaryCursors[e].dispose(this.context), this.secondaryCursors.splice(e, 1);
  }
  _getAll() {
    let e = [];
    e[0] = this.primaryCursor;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t];
    return e;
  }
  normalize() {
    if (this.secondaryCursors.length === 0)
      return;
    let e = this._getAll(), t = [];
    for (let i = 0, r = e.length; i < r; i++)
      t.push({
        index: i,
        selection: e[i].modelState.selection
      });
    t.sort((i, r) => i.selection.startLineNumber === r.selection.startLineNumber ? i.selection.startColumn - r.selection.startColumn : i.selection.startLineNumber - r.selection.startLineNumber);
    for (let i = 0; i < t.length - 1; i++) {
      const r = t[i], o = t[i + 1], s = r.selection, a = o.selection;
      if (!this.context.cursorConfig.multiCursorMergeOverlapping)
        continue;
      let l;
      if (a.isEmpty() || s.isEmpty() ? l = a.getStartPosition().isBeforeOrEqual(s.getEndPosition()) : l = a.getStartPosition().isBefore(s.getEndPosition()), l) {
        const u = r.index < o.index ? i : i + 1, c = r.index < o.index ? i + 1 : i, h = t[c].index, d = t[u].index, f = t[c].selection, p = t[u].selection;
        if (!f.equalsSelection(p)) {
          const g = f.plusRange(p), _ = f.selectionStartLineNumber === f.startLineNumber && f.selectionStartColumn === f.startColumn, m = p.selectionStartLineNumber === p.startLineNumber && p.selectionStartColumn === p.startColumn;
          let v;
          h === this.lastAddedCursorIndex ? (v = _, this.lastAddedCursorIndex = d) : v = m;
          let C;
          v ? C = new Ut(g.startLineNumber, g.startColumn, g.endLineNumber, g.endColumn) : C = new Ut(g.endLineNumber, g.endColumn, g.startLineNumber, g.startColumn), t[u].selection = C;
          const y = st.fromModelSelection(C);
          e[d].setState(this.context, y.modelState, y.viewState);
        }
        for (const g of t)
          g.index > h && g.index--;
        e.splice(h, 1), t.splice(c, 1), this._removeSecondaryCursor(h - 1), i--;
      }
    }
  }
}
class Zhe {
  constructor() {
    this.type = 0;
  }
}
class Qhe {
  constructor() {
    this.type = 1;
  }
}
class Jhe {
  constructor(e) {
    this.type = 2, this._source = e;
  }
  hasChanged(e) {
    return this._source.hasChanged(e);
  }
}
class ede {
  constructor(e, t) {
    this.type = 3, this.selections = e, this.modelSelections = t;
  }
}
class Nf {
  constructor(e) {
    this.type = 4, e ? (this.affectsMinimap = e.affectsMinimap, this.affectsOverviewRuler = e.affectsOverviewRuler) : (this.affectsMinimap = !0, this.affectsOverviewRuler = !0);
  }
}
class Ly {
  constructor() {
    this.type = 5;
  }
}
class tde {
  constructor(e) {
    this.type = 6, this.isFocused = e;
  }
}
class ide {
  constructor() {
    this.type = 7;
  }
}
class Dy {
  constructor() {
    this.type = 8;
  }
}
class O3 {
  constructor(e, t) {
    this.type = 9, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class BT {
  constructor(e, t) {
    this.type = 10, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class HT {
  constructor(e, t) {
    this.type = 11, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class hw {
  constructor(e, t, i, r, o, s) {
    this.type = 12, this.source = e, this.range = t, this.selections = i, this.verticalType = r, this.revealHorizontal = o, this.scrollType = s;
  }
}
class nde {
  constructor(e) {
    this.type = 13, this.scrollWidth = e.scrollWidth, this.scrollLeft = e.scrollLeft, this.scrollHeight = e.scrollHeight, this.scrollTop = e.scrollTop, this.scrollWidthChanged = e.scrollWidthChanged, this.scrollLeftChanged = e.scrollLeftChanged, this.scrollHeightChanged = e.scrollHeightChanged, this.scrollTopChanged = e.scrollTopChanged;
  }
}
class rde {
  constructor() {
    this.type = 14;
  }
}
class ode {
  constructor(e) {
    this.type = 15, this.ranges = e;
  }
}
class sde {
  constructor() {
    this.type = 16;
  }
}
let ade = class {
  constructor() {
    this.type = 17;
  }
};
class lde extends ge {
  constructor() {
    super(), this._onEvent = this._register(new j()), this.onEvent = this._onEvent.event, this._eventHandlers = [], this._viewEventQueue = null, this._isConsumingViewEventQueue = !1, this._collector = null, this._collectorCnt = 0, this._outgoingEvents = [];
  }
  emitOutgoingEvent(e) {
    this._addOutgoingEvent(e), this._emitOugoingEvents();
  }
  _addOutgoingEvent(e) {
    for (let t = 0, i = this._outgoingEvents.length; t < i; t++)
      if (this._outgoingEvents[t].kind === e.kind) {
        this._outgoingEvents[t] = this._outgoingEvents[t].merge(e);
        return;
      }
    this._outgoingEvents.push(e);
  }
  _emitOugoingEvents() {
    for (; this._outgoingEvents.length > 0; ) {
      if (this._collector || this._isConsumingViewEventQueue)
        return;
      const e = this._outgoingEvents.shift();
      e.isNoOp() || this._onEvent.fire(e);
    }
  }
  addViewEventHandler(e) {
    for (let t = 0, i = this._eventHandlers.length; t < i; t++)
      this._eventHandlers[t] === e && console.warn("Detected duplicate listener in ViewEventDispatcher", e);
    this._eventHandlers.push(e);
  }
  removeViewEventHandler(e) {
    for (let t = 0; t < this._eventHandlers.length; t++)
      if (this._eventHandlers[t] === e) {
        this._eventHandlers.splice(t, 1);
        break;
      }
  }
  beginEmitViewEvents() {
    return this._collectorCnt++, this._collectorCnt === 1 && (this._collector = new ude()), this._collector;
  }
  endEmitViewEvents() {
    if (this._collectorCnt--, this._collectorCnt === 0) {
      const e = this._collector.outgoingEvents, t = this._collector.viewEvents;
      this._collector = null;
      for (const i of e)
        this._addOutgoingEvent(i);
      t.length > 0 && this._emitMany(t);
    }
    this._emitOugoingEvents();
  }
  emitSingleViewEvent(e) {
    try {
      this.beginEmitViewEvents().emitViewEvent(e);
    } finally {
      this.endEmitViewEvents();
    }
  }
  _emitMany(e) {
    this._viewEventQueue ? this._viewEventQueue = this._viewEventQueue.concat(e) : this._viewEventQueue = e, this._isConsumingViewEventQueue || this._consumeViewEventQueue();
  }
  _consumeViewEventQueue() {
    try {
      this._isConsumingViewEventQueue = !0, this._doConsumeQueue();
    } finally {
      this._isConsumingViewEventQueue = !1;
    }
  }
  _doConsumeQueue() {
    for (; this._viewEventQueue; ) {
      const e = this._viewEventQueue;
      this._viewEventQueue = null;
      const t = this._eventHandlers.slice(0);
      for (const i of t)
        i.handleEvents(e);
    }
  }
}
class ude {
  constructor() {
    this.viewEvents = [], this.outgoingEvents = [];
  }
  emitViewEvent(e) {
    this.viewEvents.push(e);
  }
  emitOutgoingEvent(e) {
    this.outgoingEvents.push(e);
  }
}
class oI {
  constructor(e, t, i, r) {
    this.kind = 0, this._oldContentWidth = e, this._oldContentHeight = t, this.contentWidth = i, this.contentHeight = r, this.contentWidthChanged = this._oldContentWidth !== this.contentWidth, this.contentHeightChanged = this._oldContentHeight !== this.contentHeight;
  }
  isNoOp() {
    return !this.contentWidthChanged && !this.contentHeightChanged;
  }
  merge(e) {
    return e.kind !== 0 ? this : new oI(this._oldContentWidth, this._oldContentHeight, e.contentWidth, e.contentHeight);
  }
}
class sI {
  constructor(e, t) {
    this.kind = 1, this.oldHasFocus = e, this.hasFocus = t;
  }
  isNoOp() {
    return this.oldHasFocus === this.hasFocus;
  }
  merge(e) {
    return e.kind !== 1 ? this : new sI(this.oldHasFocus, e.hasFocus);
  }
}
class aI {
  constructor(e, t, i, r, o, s, a, l) {
    this.kind = 2, this._oldScrollWidth = e, this._oldScrollLeft = t, this._oldScrollHeight = i, this._oldScrollTop = r, this.scrollWidth = o, this.scrollLeft = s, this.scrollHeight = a, this.scrollTop = l, this.scrollWidthChanged = this._oldScrollWidth !== this.scrollWidth, this.scrollLeftChanged = this._oldScrollLeft !== this.scrollLeft, this.scrollHeightChanged = this._oldScrollHeight !== this.scrollHeight, this.scrollTopChanged = this._oldScrollTop !== this.scrollTop;
  }
  isNoOp() {
    return !this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged;
  }
  merge(e) {
    return e.kind !== 2 ? this : new aI(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop);
  }
}
class cde {
  constructor() {
    this.kind = 3;
  }
  isNoOp() {
    return !1;
  }
  merge(e) {
    return this;
  }
}
class zb {
  constructor(e, t, i, r, o, s, a) {
    this.kind = 5, this.oldSelections = e, this.selections = t, this.oldModelVersionId = i, this.modelVersionId = r, this.source = o, this.reason = s, this.reachedMaxCursorCount = a;
  }
  static _selectionsAreEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e || !t)
      return !1;
    const i = e.length, r = t.length;
    if (i !== r)
      return !1;
    for (let o = 0; o < i; o++)
      if (!e[o].equalsSelection(t[o]))
        return !1;
    return !0;
  }
  isNoOp() {
    return zb._selectionsAreEqual(this.oldSelections, this.selections) && this.oldModelVersionId === this.modelVersionId;
  }
  merge(e) {
    return e.kind !== 5 ? this : new zb(this.oldSelections, e.selections, this.oldModelVersionId, e.modelVersionId, e.source, e.reason, this.reachedMaxCursorCount || e.reachedMaxCursorCount);
  }
}
class hde {
  constructor() {
    this.kind = 4;
  }
  isNoOp() {
    return !1;
  }
  merge(e) {
    return this;
  }
}
class ID {
  constructor(e, t) {
    this.modelVersionId = e.getVersionId(), this.cursorState = t.getCursorStates();
  }
  equals(e) {
    if (!e || this.modelVersionId !== e.modelVersionId || this.cursorState.length !== e.cursorState.length)
      return !1;
    for (let t = 0, i = this.cursorState.length; t < i; t++)
      if (!this.cursorState[t].equals(e.cursorState[t]))
        return !1;
    return !0;
  }
}
class O2 {
  constructor(e, t, i) {
    this._model = e, this._autoClosedCharactersDecorations = t, this._autoClosedEnclosingDecorations = i;
  }
  static getAllAutoClosedCharacters(e) {
    let t = [];
    for (const i of e)
      t = t.concat(i.getAutoClosedCharactersRanges());
    return t;
  }
  dispose() {
    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []), this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);
  }
  getAutoClosedCharactersRanges() {
    let e = [];
    for (let t = 0; t < this._autoClosedCharactersDecorations.length; t++) {
      const i = this._model.getDecorationRange(this._autoClosedCharactersDecorations[t]);
      i && e.push(i);
    }
    return e;
  }
  isValid(e) {
    let t = [];
    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {
      const r = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);
      if (r && (t.push(r), r.startLineNumber !== r.endLineNumber))
        return !1;
    }
    t.sort(V.compareRangesUsingStarts), e.sort(V.compareRangesUsingStarts);
    for (let i = 0; i < e.length; i++)
      if (i >= t.length || !t[i].strictContainsRange(e[i]))
        return !1;
    return !0;
  }
}
class Zp extends ge {
  constructor(e, t, i, r) {
    super(), this._model = e, this._knownModelVersionId = this._model.getVersionId(), this._viewModel = t, this._coordinatesConverter = i, this.context = new t2(this._model, this._coordinatesConverter, r), this._cursors = new T2(this.context), this._hasFocus = !1, this._isHandling = !1, this._isDoingComposition = !1, this._selectionsWhenCompositionStarted = null, this._columnSelectData = null, this._autoClosedActions = [], this._prevEditOperationType = 0;
  }
  dispose() {
    this._cursors.dispose(), this._autoClosedActions = yi(this._autoClosedActions), super.dispose();
  }
  updateConfiguration(e) {
    this.context = new t2(this._model, this._coordinatesConverter, e), this._cursors.updateContext(this.context);
  }
  onLineMappingChanged(e) {
    this._knownModelVersionId === this._model.getVersionId() && this.setStates(e, "viewModel", 0, this.getCursorStates());
  }
  setHasFocus(e) {
    this._hasFocus = e;
  }
  _validateAutoClosedActions() {
    if (this._autoClosedActions.length > 0) {
      let e = this._cursors.getSelections();
      for (let t = 0; t < this._autoClosedActions.length; t++) {
        const i = this._autoClosedActions[t];
        i.isValid(e) || (i.dispose(), this._autoClosedActions.splice(t, 1), t--);
      }
    }
  }
  // ------ some getters/setters
  getPrimaryCursorState() {
    return this._cursors.getPrimaryCursor();
  }
  getLastAddedCursorIndex() {
    return this._cursors.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursors.getAll();
  }
  setStates(e, t, i, r) {
    let o = !1;
    r !== null && r.length > Zp.MAX_CURSOR_COUNT && (r = r.slice(0, Zp.MAX_CURSOR_COUNT), o = !0);
    const s = new ID(this._model, this);
    return this._cursors.setStates(r), this._cursors.normalize(), this._columnSelectData = null, this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, t, i, s, o);
  }
  setCursorColumnSelectData(e) {
    this._columnSelectData = e;
  }
  revealPrimary(e, t, i, r) {
    const o = this._cursors.getViewPositions();
    if (o.length > 1) {
      this._emitCursorRevealRange(e, t, null, this._cursors.getViewSelections(), 0, i, r);
      return;
    } else {
      const s = o[0], a = new V(s.lineNumber, s.column, s.lineNumber, s.column);
      this._emitCursorRevealRange(e, t, a, null, 0, i, r);
    }
  }
  _revealPrimaryCursor(e, t, i, r, o) {
    const s = this._cursors.getViewPositions();
    if (s.length > 1)
      this._emitCursorRevealRange(e, t, null, this._cursors.getViewSelections(), i, r, o);
    else {
      const a = s[0], l = new V(a.lineNumber, a.column, a.lineNumber, a.column);
      this._emitCursorRevealRange(e, t, l, null, i, r, o);
    }
  }
  _emitCursorRevealRange(e, t, i, r, o, s, a) {
    e.emitViewEvent(new hw(t, i, r, o, s, a));
  }
  saveState() {
    let e = [];
    const t = this._cursors.getSelections();
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      e.push({
        inSelectionMode: !o.isEmpty(),
        selectionStart: {
          lineNumber: o.selectionStartLineNumber,
          column: o.selectionStartColumn
        },
        position: {
          lineNumber: o.positionLineNumber,
          column: o.positionColumn
        }
      });
    }
    return e;
  }
  restoreState(e, t) {
    let i = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const s = t[r];
      let a = 1, l = 1;
      s.position && s.position.lineNumber && (a = s.position.lineNumber), s.position && s.position.column && (l = s.position.column);
      let u = a, c = l;
      s.selectionStart && s.selectionStart.lineNumber && (u = s.selectionStart.lineNumber), s.selectionStart && s.selectionStart.column && (c = s.selectionStart.column), i.push({
        selectionStartLineNumber: u,
        selectionStartColumn: c,
        positionLineNumber: a,
        positionColumn: l
      });
    }
    this.setStates(e, "restoreState", 0, st.fromModelSelections(i)), this.revealPrimary(
      e,
      "restoreState",
      !0,
      1
      /* Immediate */
    );
  }
  onModelContentChanged(e, t) {
    if (this._knownModelVersionId = t.versionId, this._isHandling)
      return;
    const i = t.containsEvent(
      1
      /* Flush */
    );
    if (this._prevEditOperationType = 0, i)
      this._cursors.dispose(), this._cursors = new T2(this.context), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, "model", 1, null, !1);
    else if (this._hasFocus && t.resultingSelection && t.resultingSelection.length > 0) {
      const r = st.fromModelSelections(t.resultingSelection);
      this.setStates(e, "modelChange", t.isUndoing ? 5 : t.isRedoing ? 6 : 2, r) && this._revealPrimaryCursor(
        e,
        "modelChange",
        0,
        !0,
        0
        /* Smooth */
      );
    } else {
      const r = this._cursors.readSelectionFromMarkers();
      this.setStates(e, "modelChange", 2, st.fromModelSelections(r));
    }
  }
  getSelection() {
    return this._cursors.getPrimaryCursor().modelState.selection;
  }
  getTopMostViewPosition() {
    return this._cursors.getTopMostViewPosition();
  }
  getBottomMostViewPosition() {
    return this._cursors.getBottomMostViewPosition();
  }
  getCursorColumnSelectData() {
    if (this._columnSelectData)
      return this._columnSelectData;
    const e = this._cursors.getPrimaryCursor(), t = e.viewState.selectionStart.getStartPosition(), i = e.viewState.position;
    return {
      isReal: !1,
      fromViewLineNumber: t.lineNumber,
      fromViewVisualColumn: Kt.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, t),
      toViewLineNumber: i.lineNumber,
      toViewVisualColumn: Kt.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, i)
    };
  }
  getSelections() {
    return this._cursors.getSelections();
  }
  setSelections(e, t, i, r) {
    this.setStates(e, t, r, st.fromModelSelections(i));
  }
  getPrevEditOperationType() {
    return this._prevEditOperationType;
  }
  setPrevEditOperationType(e) {
    this._prevEditOperationType = e;
  }
  // ------ auxiliary handling logic
  _pushAutoClosedAction(e, t) {
    let i = [], r = [];
    for (let a = 0, l = e.length; a < l; a++)
      i.push({
        range: e[a],
        options: {
          description: "auto-closed-character",
          inlineClassName: "auto-closed-character",
          stickiness: 1
          /* NeverGrowsWhenTypingAtEdges */
        }
      }), r.push({
        range: t[a],
        options: {
          description: "auto-closed-enclosing",
          stickiness: 1
          /* NeverGrowsWhenTypingAtEdges */
        }
      });
    const o = this._model.deltaDecorations([], i), s = this._model.deltaDecorations([], r);
    this._autoClosedActions.push(new O2(this._model, o, s));
  }
  _executeEditOperation(e) {
    if (!e)
      return;
    e.shouldPushStackElementBefore && this._model.pushStackElement();
    const t = dde.executeCommands(this._model, this._cursors.getSelections(), e.commands);
    if (t) {
      this._interpretCommandResult(t);
      let i = [], r = [];
      for (let o = 0; o < e.commands.length; o++) {
        const s = e.commands[o];
        s instanceof y3 && s.enclosingRange && s.closeCharacterRange && (i.push(s.closeCharacterRange), r.push(s.enclosingRange));
      }
      i.length > 0 && this._pushAutoClosedAction(i, r), this._prevEditOperationType = e.type;
    }
    e.shouldPushStackElementAfter && this._model.pushStackElement();
  }
  _interpretCommandResult(e) {
    (!e || e.length === 0) && (e = this._cursors.readSelectionFromMarkers()), this._columnSelectData = null, this._cursors.setSelections(e), this._cursors.normalize();
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- emitting events
  _emitStateChangedIfNecessary(e, t, i, r, o) {
    const s = new ID(this._model, this);
    if (s.equals(r))
      return !1;
    const a = this._cursors.getSelections(), l = this._cursors.getViewSelections();
    if (e.emitViewEvent(new ede(l, a)), !r || r.cursorState.length !== s.cursorState.length || s.cursorState.some((u, c) => !u.modelState.equals(r.cursorState[c].modelState))) {
      const u = r ? r.cursorState.map((h) => h.modelState.selection) : null, c = r ? r.modelVersionId : 0;
      e.emitOutgoingEvent(new zb(u, a, c, s.modelVersionId, t || "keyboard", i, o));
    }
    return !0;
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- handlers beyond this point
  _findAutoClosingPairs(e) {
    if (!e.length)
      return null;
    let t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i];
      if (!o.text || o.text.indexOf(`
`) >= 0)
        return null;
      const s = o.text.match(/([)\]}>'"`])([^)\]}>'"`]*)$/);
      if (!s)
        return null;
      const a = s[1], l = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(a);
      if (!l || l.length !== 1)
        return null;
      const u = l[0].open, c = o.text.length - s[2].length - 1, h = o.text.lastIndexOf(u, c - 1);
      if (h === -1)
        return null;
      t.push([h, c]);
    }
    return t;
  }
  executeEdits(e, t, i, r) {
    let o = null;
    t === "snippet" && (o = this._findAutoClosingPairs(i)), o && (i[0]._isTracked = !0);
    let s = [], a = [];
    const l = this._model.pushEditOperations(this.getSelections(), i, (u) => {
      if (o)
        for (let h = 0, d = o.length; h < d; h++) {
          const [f, p] = o[h], g = u[h], _ = g.range.startLineNumber, m = g.range.startColumn - 1 + f, v = g.range.startColumn - 1 + p;
          s.push(new V(_, v + 1, _, v + 2)), a.push(new V(_, m + 1, _, v + 2));
        }
      const c = r(u);
      return c && (this._isHandling = !0), c;
    });
    l && (this._isHandling = !1, this.setSelections(
      e,
      t,
      l,
      0
      /* NotSet */
    )), s.length > 0 && this._pushAutoClosedAction(s, a);
  }
  _executeEdit(e, t, i, r = 0) {
    if (this.context.cursorConfig.readOnly)
      return;
    const o = new ID(this._model, this);
    this._cursors.stopTrackingSelections(), this._isHandling = !0;
    try {
      this._cursors.ensureValidState(), e();
    } catch (s) {
      Ni(s);
    }
    this._isHandling = !1, this._cursors.startTrackingSelections(), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(t, i, r, o, !1) && this._revealPrimaryCursor(
      t,
      i,
      0,
      !0,
      0
      /* Smooth */
    );
  }
  setIsDoingComposition(e) {
    this._isDoingComposition = e;
  }
  getAutoClosedCharacters() {
    return O2.getAllAutoClosedCharacters(this._autoClosedActions);
  }
  startComposition(e) {
    this._selectionsWhenCompositionStarted = this.getSelections().slice(0);
  }
  endComposition(e, t) {
    this._executeEdit(() => {
      t === "keyboard" && (this._executeEditOperation(ki.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), this.getAutoClosedCharacters())), this._selectionsWhenCompositionStarted = null);
    }, e, t);
  }
  type(e, t, i) {
    this._executeEdit(() => {
      if (i === "keyboard") {
        const r = t.length;
        let o = 0;
        for (; o < r; ) {
          const s = ob(t, o), a = t.substr(o, s);
          this._executeEditOperation(ki.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), a)), o += s;
        }
      } else
        this._executeEditOperation(ki.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t));
    }, e, i);
  }
  compositionType(e, t, i, r, o, s) {
    if (t.length === 0 && i === 0 && r === 0) {
      if (o !== 0) {
        const a = this.getSelections().map((l) => {
          const u = l.getPosition();
          return new Ut(u.lineNumber, u.column + o, u.lineNumber, u.column + o);
        });
        this.setSelections(
          e,
          s,
          a,
          0
          /* NotSet */
        );
      }
      return;
    }
    this._executeEdit(() => {
      this._executeEditOperation(ki.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t, i, r, o));
    }, e, s);
  }
  paste(e, t, i, r, o) {
    this._executeEdit(
      () => {
        this._executeEditOperation(ki.paste(this.context.cursorConfig, this._model, this.getSelections(), t, i, r || []));
      },
      e,
      o,
      4
      /* Paste */
    );
  }
  cut(e, t) {
    this._executeEdit(() => {
      this._executeEditOperation(kd.cut(this.context.cursorConfig, this._model, this.getSelections()));
    }, e, t);
  }
  executeCommand(e, t, i) {
    this._executeEdit(() => {
      this._cursors.killSecondaryCursors(), this._executeEditOperation(new po(0, [t], {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
  executeCommands(e, t, i) {
    this._executeEdit(() => {
      this._executeEditOperation(new po(0, t, {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
}
Zp.MAX_CURSOR_COUNT = 1e4;
class dde {
  static executeCommands(e, t, i) {
    const r = {
      model: e,
      selectionsBefore: t,
      trackedRanges: [],
      trackedRangesDirection: []
    }, o = this._innerExecuteCommands(r, i);
    for (let s = 0, a = r.trackedRanges.length; s < a; s++)
      r.model._setTrackedRange(
        r.trackedRanges[s],
        null,
        0
        /* AlwaysGrowsWhenTypingAtEdges */
      );
    return o;
  }
  static _innerExecuteCommands(e, t) {
    if (this._arrayIsEmpty(t))
      return null;
    const i = this._getEditOperations(e, t);
    if (i.operations.length === 0)
      return null;
    const r = i.operations, o = this._getLoserCursorMap(r);
    if (o.hasOwnProperty("0"))
      return console.warn("Ignoring commands"), null;
    let s = [];
    for (let u = 0, c = r.length; u < c; u++)
      o.hasOwnProperty(r[u].identifier.major.toString()) || s.push(r[u]);
    i.hadTrackedEditOperation && s.length > 0 && (s[0]._isTracked = !0);
    let a = e.model.pushEditOperations(e.selectionsBefore, s, (u) => {
      let c = [];
      for (let f = 0; f < e.selectionsBefore.length; f++)
        c[f] = [];
      for (const f of u)
        f.identifier && c[f.identifier.major].push(f);
      const h = (f, p) => f.identifier.minor - p.identifier.minor;
      let d = [];
      for (let f = 0; f < e.selectionsBefore.length; f++)
        c[f].length > 0 ? (c[f].sort(h), d[f] = t[f].computeCursorState(e.model, {
          getInverseEditOperations: () => c[f],
          getTrackedSelection: (p) => {
            const g = parseInt(p, 10), _ = e.model._getTrackedRange(e.trackedRanges[g]);
            return e.trackedRangesDirection[g] === 0 ? new Ut(_.startLineNumber, _.startColumn, _.endLineNumber, _.endColumn) : new Ut(_.endLineNumber, _.endColumn, _.startLineNumber, _.startColumn);
          }
        })) : d[f] = e.selectionsBefore[f];
      return d;
    });
    a || (a = e.selectionsBefore);
    let l = [];
    for (let u in o)
      o.hasOwnProperty(u) && l.push(parseInt(u, 10));
    l.sort((u, c) => c - u);
    for (const u of l)
      a.splice(u, 1);
    return a;
  }
  static _arrayIsEmpty(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t])
        return !1;
    return !0;
  }
  static _getEditOperations(e, t) {
    let i = [], r = !1;
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o];
      if (a) {
        const l = this._getEditOperationsFromCommand(e, o, a);
        i = i.concat(l.operations), r = r || l.hadTrackedEditOperation;
      }
    }
    return {
      operations: i,
      hadTrackedEditOperation: r
    };
  }
  static _getEditOperationsFromCommand(e, t, i) {
    let r = [], o = 0;
    const s = (h, d, f = !1) => {
      V.isEmpty(h) && d === "" || r.push({
        identifier: {
          major: t,
          minor: o++
        },
        range: h,
        text: d,
        forceMoveMarkers: f,
        isAutoWhitespaceEdit: i.insertsAutoWhitespace
      });
    };
    let a = !1;
    const c = {
      addEditOperation: s,
      addTrackedEditOperation: (h, d, f) => {
        a = !0, s(h, d, f);
      },
      trackSelection: (h, d) => {
        const f = Ut.liftSelection(h);
        let p;
        if (f.isEmpty())
          if (typeof d == "boolean")
            d ? p = 2 : p = 3;
          else {
            const m = e.model.getLineMaxColumn(f.startLineNumber);
            f.startColumn === m ? p = 2 : p = 3;
          }
        else
          p = 1;
        const g = e.trackedRanges.length, _ = e.model._setTrackedRange(null, f, p);
        return e.trackedRanges[g] = _, e.trackedRangesDirection[g] = f.getDirection(), g.toString();
      }
    };
    try {
      i.getEditOperations(e.model, c);
    } catch (h) {
      return Ni(h), {
        operations: [],
        hadTrackedEditOperation: !1
      };
    }
    return {
      operations: r,
      hadTrackedEditOperation: a
    };
  }
  static _getLoserCursorMap(e) {
    e = e.slice(0), e.sort((i, r) => -V.compareRangesUsingEnds(i.range, r.range));
    let t = {};
    for (let i = 1; i < e.length; i++) {
      const r = e[i - 1], o = e[i];
      if (V.getStartPosition(r.range).isBefore(V.getEndPosition(o.range))) {
        let s;
        r.identifier.major > o.identifier.major ? s = r.identifier.major : s = o.identifier.major, t[s.toString()] = !0;
        for (let a = 0; a < e.length; a++)
          e[a].identifier.major === s && (e.splice(a, 1), a < i && i--, a--);
        i > 0 && i--;
      }
    }
    return t;
  }
}
class x3 {
  constructor(e, t, i, r, o, s) {
    this.id = e, this.label = t, this.alias = i, this._precondition = r, this._run = o, this._contextKeyService = s;
  }
  isSupported() {
    return this._contextKeyService.contextMatchesRules(this._precondition);
  }
  run() {
    return this.isSupported() ? this._run() : Promise.resolve(void 0);
  }
}
const x2 = {
  getInitialState: () => XS,
  tokenize2: (n, e, t, i) => e5(0, n, t, i)
};
function Aye(n, e = x2) {
  return pde(n, e || x2);
}
function fde(n, e, t, i, r, o, s) {
  let a = "<div>", l = i, u = 0;
  for (let c = 0, h = e.getCount(); c < h; c++) {
    const d = e.getEndOffset(c);
    if (d <= i)
      continue;
    let f = "";
    for (; l < d && l < r; l++) {
      const p = n.charCodeAt(l);
      switch (p) {
        case 9:
          let g = o - (l + u) % o;
          for (u += g - 1; g > 0; )
            f += s ? "&#160;" : " ", g--;
          break;
        case 60:
          f += "&lt;";
          break;
        case 62:
          f += "&gt;";
          break;
        case 38:
          f += "&amp;";
          break;
        case 0:
          f += "&#00;";
          break;
        case 65279:
        case 8232:
        case 8233:
        case 133:
          f += "";
          break;
        case 13:
          f += "&#8203";
          break;
        case 32:
          f += s ? "&#160;" : " ";
          break;
        default:
          f += String.fromCharCode(p);
      }
    }
    if (a += `<span style="${e.getInlineStyle(c, t)}">${f}</span>`, d > r || l >= r)
      break;
  }
  return a += "</div>", a;
}
function pde(n, e) {
  let t = '<div class="monaco-tokenized-source">', i = W_(n), r = e.getInitialState();
  for (let o = 0, s = i.length; o < s; o++) {
    let a = i[o];
    o > 0 && (t += "<br/>");
    let l = e.tokenize2(a, !0, r, 0);
    Zr.convertToEndOffset(l.tokens, a.length);
    let c = new Zr(l.tokens, a).inflate(), h = 0;
    for (let d = 0, f = c.getCount(); d < f; d++) {
      const p = c.getClassName(d), g = c.getEndOffset(d);
      t += `<span class="${p}">${PG(a.substring(h, g))}</span>`, h = g;
    }
    r = l.endState;
  }
  return t += "</div>", t;
}
class gde {
  constructor() {
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [];
  }
  insert(e) {
    this._hasPending = !0, this._inserts.push(e);
  }
  change(e) {
    this._hasPending = !0, this._changes.push(e);
  }
  remove(e) {
    this._hasPending = !0, this._removes.push(e);
  }
  mustCommit() {
    return this._hasPending;
  }
  commit(e) {
    if (!this._hasPending)
      return;
    const t = this._inserts, i = this._changes, r = this._removes;
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [], e._commitPendingChanges(t, i, r);
  }
}
class mde {
  constructor(e, t, i, r, o) {
    this.id = e, this.afterLineNumber = t, this.ordinal = i, this.height = r, this.minWidth = o, this.prefixSum = 0;
  }
}
class o_ {
  constructor(e, t, i, r) {
    this._instanceId = BG(++o_.INSTANCE_COUNT), this._pendingChanges = new gde(), this._lastWhitespaceId = 0, this._arr = [], this._prefixSumValidIndex = -1, this._minWidth = -1, this._lineCount = e, this._lineHeight = t, this._paddingTop = i, this._paddingBottom = r;
  }
  /**
   * Find the insertion index for a new value inside a sorted array of values.
   * If the value is already present in the sorted array, the insertion index will be after the already existing value.
   */
  static findInsertionIndex(e, t, i) {
    let r = 0, o = e.length;
    for (; r < o; ) {
      const s = r + o >>> 1;
      t === e[s].afterLineNumber ? i < e[s].ordinal ? o = s : r = s + 1 : t < e[s].afterLineNumber ? o = s : r = s + 1;
    }
    return r;
  }
  /**
   * Change the height of a line in pixels.
   */
  setLineHeight(e) {
    this._checkPendingChanges(), this._lineHeight = e;
  }
  /**
   * Changes the padding used to calculate vertical offsets.
   */
  setPadding(e, t) {
    this._paddingTop = e, this._paddingBottom = t;
  }
  /**
   * Set the number of lines.
   *
   * @param lineCount New number of lines.
   */
  onFlushed(e) {
    this._checkPendingChanges(), this._lineCount = e;
  }
  changeWhitespace(e) {
    let t = !1;
    try {
      e({
        insertWhitespace: (r, o, s, a) => {
          t = !0, r = r | 0, o = o | 0, s = s | 0, a = a | 0;
          const l = this._instanceId + ++this._lastWhitespaceId;
          return this._pendingChanges.insert(new mde(l, r, o, s, a)), l;
        },
        changeOneWhitespace: (r, o, s) => {
          t = !0, o = o | 0, s = s | 0, this._pendingChanges.change({ id: r, newAfterLineNumber: o, newHeight: s });
        },
        removeWhitespace: (r) => {
          t = !0, this._pendingChanges.remove({ id: r });
        }
      });
    } finally {
      this._pendingChanges.commit(this);
    }
    return t;
  }
  _commitPendingChanges(e, t, i) {
    if ((e.length > 0 || i.length > 0) && (this._minWidth = -1), e.length + t.length + i.length <= 1) {
      for (const l of e)
        this._insertWhitespace(l);
      for (const l of t)
        this._changeOneWhitespace(l.id, l.newAfterLineNumber, l.newHeight);
      for (const l of i) {
        const u = this._findWhitespaceIndex(l.id);
        u !== -1 && this._removeWhitespace(u);
      }
      return;
    }
    const r = /* @__PURE__ */ new Set();
    for (const l of i)
      r.add(l.id);
    const o = /* @__PURE__ */ new Map();
    for (const l of t)
      o.set(l.id, l);
    const s = (l) => {
      let u = [];
      for (const c of l)
        if (!r.has(c.id)) {
          if (o.has(c.id)) {
            const h = o.get(c.id);
            c.afterLineNumber = h.newAfterLineNumber, c.height = h.newHeight;
          }
          u.push(c);
        }
      return u;
    }, a = s(this._arr).concat(s(e));
    a.sort((l, u) => l.afterLineNumber === u.afterLineNumber ? l.ordinal - u.ordinal : l.afterLineNumber - u.afterLineNumber), this._arr = a, this._prefixSumValidIndex = -1;
  }
  _checkPendingChanges() {
    this._pendingChanges.mustCommit() && this._pendingChanges.commit(this);
  }
  _insertWhitespace(e) {
    const t = o_.findInsertionIndex(this._arr, e.afterLineNumber, e.ordinal);
    this._arr.splice(t, 0, e), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, t - 1);
  }
  _findWhitespaceIndex(e) {
    const t = this._arr;
    for (let i = 0, r = t.length; i < r; i++)
      if (t[i].id === e)
        return i;
    return -1;
  }
  _changeOneWhitespace(e, t, i) {
    const r = this._findWhitespaceIndex(e);
    if (r !== -1 && (this._arr[r].height !== i && (this._arr[r].height = i, this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, r - 1)), this._arr[r].afterLineNumber !== t)) {
      const o = this._arr[r];
      this._removeWhitespace(r), o.afterLineNumber = t, this._insertWhitespace(o);
    }
  }
  _removeWhitespace(e) {
    this._arr.splice(e, 1), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, e - 1);
  }
  /**
   * Notify the layouter that lines have been deleted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the deletion started, inclusive
   * @param toLineNumber The line number at which the deletion ended, inclusive
   */
  onLinesDeleted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount -= t - e + 1;
    for (let i = 0, r = this._arr.length; i < r; i++) {
      const o = this._arr[i].afterLineNumber;
      e <= o && o <= t ? this._arr[i].afterLineNumber = e - 1 : o > t && (this._arr[i].afterLineNumber -= t - e + 1);
    }
  }
  /**
   * Notify the layouter that lines have been inserted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the insertion started, inclusive
   * @param toLineNumber The line number at which the insertion ended, inclusive.
   */
  onLinesInserted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount += t - e + 1;
    for (let i = 0, r = this._arr.length; i < r; i++) {
      const o = this._arr[i].afterLineNumber;
      e <= o && (this._arr[i].afterLineNumber += t - e + 1);
    }
  }
  /**
   * Get the sum of all the whitespaces.
   */
  getWhitespacesTotalHeight() {
    return this._checkPendingChanges(), this._arr.length === 0 ? 0 : this.getWhitespacesAccumulatedHeight(this._arr.length - 1);
  }
  /**
   * Return the sum of the heights of the whitespaces at [0..index].
   * This includes the whitespace at `index`.
   *
   * @param index The index of the whitespace.
   * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.
   */
  getWhitespacesAccumulatedHeight(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = Math.max(0, this._prefixSumValidIndex + 1);
    t === 0 && (this._arr[0].prefixSum = this._arr[0].height, t++);
    for (let i = t; i <= e; i++)
      this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;
    return this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, e), this._arr[e].prefixSum;
  }
  /**
   * Get the sum of heights for all objects.
   *
   * @return The sum of heights for all objects.
   */
  getLinesTotalHeight() {
    this._checkPendingChanges();
    const e = this._lineHeight * this._lineCount, t = this.getWhitespacesTotalHeight();
    return e + t + this._paddingTop + this._paddingBottom;
  }
  /**
   * Returns the accumulated height of whitespaces before the given line number.
   *
   * @param lineNumber The line number
   */
  getWhitespaceAccumulatedHeightBeforeLineNumber(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this._findLastWhitespaceBeforeLineNumber(e);
    return t === -1 ? 0 : this.getWhitespacesAccumulatedHeight(t);
  }
  _findLastWhitespaceBeforeLineNumber(e) {
    e = e | 0;
    const t = this._arr;
    let i = 0, r = t.length - 1;
    for (; i <= r; ) {
      const s = (r - i | 0) / 2 | 0, a = i + s | 0;
      if (t[a].afterLineNumber < e) {
        if (a + 1 >= t.length || t[a + 1].afterLineNumber >= e)
          return a;
        i = a + 1 | 0;
      } else
        r = a - 1 | 0;
    }
    return -1;
  }
  _findFirstWhitespaceAfterLineNumber(e) {
    e = e | 0;
    const i = this._findLastWhitespaceBeforeLineNumber(e) + 1;
    return i < this._arr.length ? i : -1;
  }
  /**
   * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.
   * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.
   */
  getFirstWhitespaceIndexAfterLineNumber(e) {
    return this._checkPendingChanges(), e = e | 0, this._findFirstWhitespaceAfterLineNumber(e);
  }
  /**
   * Get the vertical offset (the sum of heights for all objects above) a certain line number.
   *
   * @param lineNumber The line number
   * @return The sum of heights for all objects above `lineNumber`.
   */
  getVerticalOffsetForLineNumber(e) {
    this._checkPendingChanges(), e = e | 0;
    let t;
    e > 1 ? t = this._lineHeight * (e - 1) : t = 0;
    const i = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e);
    return t + i + this._paddingTop;
  }
  /**
   * The maximum min width for all whitespaces.
   */
  getWhitespaceMinWidth() {
    if (this._checkPendingChanges(), this._minWidth === -1) {
      let e = 0;
      for (let t = 0, i = this._arr.length; t < i; t++)
        e = Math.max(e, this._arr[t].minWidth);
      this._minWidth = e;
    }
    return this._minWidth;
  }
  /**
   * Check if `verticalOffset` is below all lines.
   */
  isAfterLines(e) {
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e > t;
  }
  isInTopPadding(e) {
    return this._paddingTop === 0 ? !1 : (this._checkPendingChanges(), e < this._paddingTop);
  }
  isInBottomPadding(e) {
    if (this._paddingBottom === 0)
      return !1;
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e >= t - this._paddingBottom;
  }
  /**
   * Find the first line number that is at or after vertical offset `verticalOffset`.
   * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then
   * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.
   *
   * @param verticalOffset The vertical offset to search at.
   * @return The line number at or after vertical offset `verticalOffset`.
   */
  getLineNumberAtOrAfterVerticalOffset(e) {
    if (this._checkPendingChanges(), e = e | 0, e < 0)
      return 1;
    const t = this._lineCount | 0, i = this._lineHeight;
    let r = 1, o = t;
    for (; r < o; ) {
      const s = (r + o) / 2 | 0, a = this.getVerticalOffsetForLineNumber(s) | 0;
      if (e >= a + i)
        r = s + 1;
      else {
        if (e >= a)
          return s;
        o = s;
      }
    }
    return r > t ? t : r;
  }
  /**
   * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.
   */
  getLinesViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this._lineHeight, r = this.getLineNumberAtOrAfterVerticalOffset(e) | 0, o = this.getVerticalOffsetForLineNumber(r) | 0;
    let s = this._lineCount | 0, a = this.getFirstWhitespaceIndexAfterLineNumber(r) | 0;
    const l = this.getWhitespacesCount() | 0;
    let u, c;
    a === -1 ? (a = l, c = s + 1, u = 0) : (c = this.getAfterLineNumberForWhitespaceIndex(a) | 0, u = this.getHeightForWhitespaceIndex(a) | 0);
    let h = o, d = h;
    const f = 5e5;
    let p = 0;
    o >= f && (p = Math.floor(o / f) * f, p = Math.floor(p / i) * i, d -= p);
    const g = [], _ = e + (t - e) / 2;
    let m = -1;
    for (let b = r; b <= s; b++) {
      if (m === -1) {
        const L = h, S = h + i;
        (L <= _ && _ < S || L > _) && (m = b);
      }
      for (h += i, g[b - r] = d, d += i; c === b; )
        d += u, h += u, a++, a >= l ? c = s + 1 : (c = this.getAfterLineNumberForWhitespaceIndex(a) | 0, u = this.getHeightForWhitespaceIndex(a) | 0);
      if (h >= t) {
        s = b;
        break;
      }
    }
    m === -1 && (m = s);
    const v = this.getVerticalOffsetForLineNumber(s) | 0;
    let C = r, y = s;
    return C < y && o < e && C++, C < y && v + i > t && y--, {
      bigNumbersDelta: p,
      startLineNumber: r,
      endLineNumber: s,
      relativeVerticalOffset: g,
      centeredLineNumber: m,
      completelyVisibleStartLineNumber: C,
      completelyVisibleEndLineNumber: y
    };
  }
  getVerticalOffsetForWhitespaceIndex(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getAfterLineNumberForWhitespaceIndex(e);
    let i;
    t >= 1 ? i = this._lineHeight * t : i = 0;
    let r;
    return e > 0 ? r = this.getWhitespacesAccumulatedHeight(e - 1) : r = 0, i + r + this._paddingTop;
  }
  getWhitespaceIndexAtOrAfterVerticallOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = 0, i = this.getWhitespacesCount() - 1;
    if (i < 0)
      return -1;
    const r = this.getVerticalOffsetForWhitespaceIndex(i), o = this.getHeightForWhitespaceIndex(i);
    if (e >= r + o)
      return -1;
    for (; t < i; ) {
      const s = Math.floor((t + i) / 2), a = this.getVerticalOffsetForWhitespaceIndex(s), l = this.getHeightForWhitespaceIndex(s);
      if (e >= a + l)
        t = s + 1;
      else {
        if (e >= a)
          return s;
        i = s;
      }
    }
    return t;
  }
  /**
   * Get exactly the whitespace that is layouted at `verticalOffset`.
   *
   * @param verticalOffset The vertical offset.
   * @return Precisely the whitespace that is layouted at `verticaloffset` or null.
   */
  getWhitespaceAtVerticalOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getWhitespaceIndexAtOrAfterVerticallOffset(e);
    if (t < 0 || t >= this.getWhitespacesCount())
      return null;
    const i = this.getVerticalOffsetForWhitespaceIndex(t);
    if (i > e)
      return null;
    const r = this.getHeightForWhitespaceIndex(t), o = this.getIdForWhitespaceIndex(t), s = this.getAfterLineNumberForWhitespaceIndex(t);
    return {
      id: o,
      afterLineNumber: s,
      verticalOffset: i,
      height: r
    };
  }
  /**
   * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.
   */
  getWhitespaceViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this.getWhitespaceIndexAtOrAfterVerticallOffset(e), r = this.getWhitespacesCount() - 1;
    if (i < 0)
      return [];
    let o = [];
    for (let s = i; s <= r; s++) {
      const a = this.getVerticalOffsetForWhitespaceIndex(s), l = this.getHeightForWhitespaceIndex(s);
      if (a >= t)
        break;
      o.push({
        id: this.getIdForWhitespaceIndex(s),
        afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(s),
        verticalOffset: a,
        height: l
      });
    }
    return o;
  }
  /**
   * Get all whitespaces.
   */
  getWhitespaces() {
    return this._checkPendingChanges(), this._arr.slice(0);
  }
  /**
   * The number of whitespaces.
   */
  getWhitespacesCount() {
    return this._checkPendingChanges(), this._arr.length;
  }
  /**
   * Get the `id` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `id` of whitespace at `index`.
   */
  getIdForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].id;
  }
  /**
   * Get the `afterLineNumber` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `afterLineNumber` of whitespace at `index`.
   */
  getAfterLineNumberForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].afterLineNumber;
  }
  /**
   * Get the `height` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `height` of whitespace at `index`.
   */
  getHeightForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].height;
  }
}
o_.INSTANCE_COUNT = 0;
const vde = 125;
class jm {
  constructor(e, t, i, r) {
    e = e | 0, t = t | 0, i = i | 0, r = r | 0, e < 0 && (e = 0), t < 0 && (t = 0), i < 0 && (i = 0), r < 0 && (r = 0), this.width = e, this.contentWidth = t, this.scrollWidth = Math.max(e, t), this.height = i, this.contentHeight = r, this.scrollHeight = Math.max(i, r);
  }
  equals(e) {
    return this.width === e.width && this.contentWidth === e.contentWidth && this.height === e.height && this.contentHeight === e.contentHeight;
  }
}
class _de extends ge {
  constructor(e, t) {
    super(), this._onDidContentSizeChange = this._register(new j()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._dimensions = new jm(0, 0, 0, 0), this._scrollable = this._register(new E0(e, t)), this.onDidScroll = this._scrollable.onScroll;
  }
  getScrollable() {
    return this._scrollable;
  }
  setSmoothScrollDuration(e) {
    this._scrollable.setSmoothScrollDuration(e);
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  getScrollDimensions() {
    return this._dimensions;
  }
  setScrollDimensions(e) {
    if (this._dimensions.equals(e))
      return;
    const t = this._dimensions;
    this._dimensions = e, this._scrollable.setScrollDimensions({
      width: e.width,
      scrollWidth: e.scrollWidth,
      height: e.height,
      scrollHeight: e.scrollHeight
    }, !0);
    const i = t.contentWidth !== e.contentWidth, r = t.contentHeight !== e.contentHeight;
    (i || r) && this._onDidContentSizeChange.fire(new oI(t.contentWidth, t.contentHeight, e.contentWidth, e.contentHeight));
  }
  getFutureScrollPosition() {
    return this._scrollable.getFutureScrollPosition();
  }
  getCurrentScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  setScrollPositionNow(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  setScrollPositionSmooth(e) {
    this._scrollable.setScrollPositionSmooth(e);
  }
}
class Cde extends ge {
  constructor(e, t, i) {
    super(), this._configuration = e;
    const r = this._configuration.options, o = r.get(
      128
      /* layoutInfo */
    ), s = r.get(
      72
      /* padding */
    );
    this._linesLayout = new o_(t, r.get(
      56
      /* lineHeight */
    ), s.top, s.bottom), this._scrollable = this._register(new _de(0, i)), this._configureSmoothScrollDuration(), this._scrollable.setScrollDimensions(new jm(o.contentWidth, 0, o.height, 0)), this.onDidScroll = this._scrollable.onDidScroll, this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange, this._updateHeight();
  }
  dispose() {
    super.dispose();
  }
  getScrollable() {
    return this._scrollable.getScrollable();
  }
  onHeightMaybeChanged() {
    this._updateHeight();
  }
  _configureSmoothScrollDuration() {
    this._scrollable.setSmoothScrollDuration(this._configuration.options.get(
      101
      /* smoothScrolling */
    ) ? vde : 0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._configuration.options;
    if (e.hasChanged(
      56
      /* lineHeight */
    ) && this._linesLayout.setLineHeight(t.get(
      56
      /* lineHeight */
    )), e.hasChanged(
      72
      /* padding */
    )) {
      const i = t.get(
        72
        /* padding */
      );
      this._linesLayout.setPadding(i.top, i.bottom);
    }
    if (e.hasChanged(
      128
      /* layoutInfo */
    )) {
      const i = t.get(
        128
        /* layoutInfo */
      ), r = i.contentWidth, o = i.height, s = this._scrollable.getScrollDimensions(), a = s.contentWidth;
      this._scrollable.setScrollDimensions(new jm(r, s.contentWidth, o, this._getContentHeight(r, o, a)));
    } else
      this._updateHeight();
    e.hasChanged(
      101
      /* smoothScrolling */
    ) && this._configureSmoothScrollDuration();
  }
  onFlushed(e) {
    this._linesLayout.onFlushed(e);
  }
  onLinesDeleted(e, t) {
    this._linesLayout.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._linesLayout.onLinesInserted(e, t);
  }
  // ---- end view event handlers
  _getHorizontalScrollbarHeight(e, t) {
    const r = this._configuration.options.get(
      90
      /* scrollbar */
    );
    return r.horizontal === 2 || e >= t ? 0 : r.horizontalScrollbarSize;
  }
  _getContentHeight(e, t, i) {
    const r = this._configuration.options;
    let o = this._linesLayout.getLinesTotalHeight();
    return r.get(
      92
      /* scrollBeyondLastLine */
    ) ? o += Math.max(0, t - r.get(
      56
      /* lineHeight */
    ) - r.get(
      72
      /* padding */
    ).bottom) : o += this._getHorizontalScrollbarHeight(e, i), o;
  }
  _updateHeight() {
    const e = this._scrollable.getScrollDimensions(), t = e.width, i = e.height, r = e.contentWidth;
    this._scrollable.setScrollDimensions(new jm(t, e.contentWidth, i, this._getContentHeight(t, i, r)));
  }
  // ---- Layouting logic
  getCurrentViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getCurrentScrollPosition();
    return new fk(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  getFutureViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getFutureScrollPosition();
    return new fk(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  _computeContentWidth(e) {
    const t = this._configuration.options, i = t.get(
      129
      /* wrappingInfo */
    ), r = t.get(
      40
      /* fontInfo */
    );
    if (i.isViewportWrapping) {
      const o = t.get(
        128
        /* layoutInfo */
      ), s = t.get(
        62
        /* minimap */
      );
      return e > o.contentWidth + r.typicalHalfwidthCharacterWidth && s.enabled && s.side === "right" ? e + o.verticalScrollbarWidth : e;
    } else {
      const o = t.get(
        91
        /* scrollBeyondLastColumn */
      ) * r.typicalHalfwidthCharacterWidth, s = this._linesLayout.getWhitespaceMinWidth();
      return Math.max(e + o, s);
    }
  }
  setMaxLineWidth(e) {
    const t = this._scrollable.getScrollDimensions();
    this._scrollable.setScrollDimensions(new jm(t.width, this._computeContentWidth(e), t.height, t.contentHeight)), this._updateHeight();
  }
  // ---- view state
  saveState() {
    const e = this._scrollable.getFutureScrollPosition();
    let t = e.scrollTop, i = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(t), r = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(i);
    return {
      scrollTop: t,
      scrollTopWithoutViewZones: t - r,
      scrollLeft: e.scrollLeft
    };
  }
  // ---- IVerticalLayoutProvider
  changeWhitespace(e) {
    const t = this._linesLayout.changeWhitespace(e);
    return t && this.onHeightMaybeChanged(), t;
  }
  getVerticalOffsetForLineNumber(e) {
    return this._linesLayout.getVerticalOffsetForLineNumber(e);
  }
  isAfterLines(e) {
    return this._linesLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._linesLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._linesLayout.isInBottomPadding(e);
  }
  getLineNumberAtVerticalOffset(e) {
    return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(e);
  }
  getWhitespaceAtVerticalOffset(e) {
    return this._linesLayout.getWhitespaceAtVerticalOffset(e);
  }
  getLinesViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getLinesViewportData(e.top, e.top + e.height);
  }
  getLinesViewportDataAtScrollTop(e) {
    const t = this._scrollable.getScrollDimensions();
    return e + t.height > t.scrollHeight && (e = t.scrollHeight - t.height), e < 0 && (e = 0), this._linesLayout.getLinesViewportData(e, e + t.height);
  }
  getWhitespaceViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getWhitespaceViewportData(e.top, e.top + e.height);
  }
  getWhitespaces() {
    return this._linesLayout.getWhitespaces();
  }
  // ---- IScrollingProvider
  getContentWidth() {
    return this._scrollable.getScrollDimensions().contentWidth;
  }
  getScrollWidth() {
    return this._scrollable.getScrollDimensions().scrollWidth;
  }
  getContentHeight() {
    return this._scrollable.getScrollDimensions().contentHeight;
  }
  getScrollHeight() {
    return this._scrollable.getScrollDimensions().scrollHeight;
  }
  getCurrentScrollLeft() {
    return this._scrollable.getCurrentScrollPosition().scrollLeft;
  }
  getCurrentScrollTop() {
    return this._scrollable.getCurrentScrollPosition().scrollTop;
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  setScrollPosition(e, t) {
    t === 1 ? this._scrollable.setScrollPositionNow(e) : this._scrollable.setScrollPositionSmooth(e);
  }
  deltaScrollNow(e, t) {
    const i = this._scrollable.getCurrentScrollPosition();
    this._scrollable.setScrollPositionNow({
      scrollLeft: i.scrollLeft + e,
      scrollTop: i.scrollTop + t
    });
  }
}
class yde {
  constructor(e) {
    this._lines = e;
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._lines.convertViewPositionToModelPosition(e.lineNumber, e.column);
  }
  convertViewRangeToModelRange(e) {
    return this._lines.convertViewRangeToModelRange(e);
  }
  validateViewPosition(e, t) {
    return this._lines.validateViewPosition(e.lineNumber, e.column, t);
  }
  validateViewRange(e, t) {
    return this._lines.validateViewRange(e, t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e) {
    return this._lines.convertModelPositionToViewPosition(e.lineNumber, e.column);
  }
  convertModelRangeToViewRange(e) {
    return this._lines.convertModelRangeToViewRange(e);
  }
  modelPositionIsVisible(e) {
    return this._lines.modelPositionIsVisible(e.lineNumber, e.column);
  }
  getModelLineViewLineCount(e) {
    return this._lines.getModelLineViewLineCount(e);
  }
}
class wde {
  constructor(e) {
    this._counts = e, this._isValid = !1, this._validEndIndex = -1, this._modelToView = [], this._viewToModel = [];
  }
  _invalidate(e) {
    this._isValid = !1, this._validEndIndex = Math.min(this._validEndIndex, e - 1);
  }
  _ensureValid() {
    if (!this._isValid) {
      for (let e = this._validEndIndex + 1, t = this._counts.length; e < t; e++) {
        const i = this._counts[e], r = e > 0 ? this._modelToView[e - 1] : 0;
        this._modelToView[e] = r + i;
        for (let o = 0; o < i; o++)
          this._viewToModel[r + o] = e;
      }
      this._modelToView.length = this._counts.length, this._viewToModel.length = this._modelToView[this._modelToView.length - 1], this._isValid = !0, this._validEndIndex = this._counts.length - 1;
    }
  }
  changeValue(e, t) {
    this._counts[e] !== t && (this._counts[e] = t, this._invalidate(e));
  }
  removeValues(e, t) {
    this._counts.splice(e, t), this._invalidate(e);
  }
  insertValues(e, t) {
    this._counts = $v(this._counts, e, t), this._invalidate(e);
  }
  getTotalValue() {
    return this._ensureValid(), this._viewToModel.length;
  }
  getAccumulatedValue(e) {
    return this._ensureValid(), this._modelToView[e];
  }
  getIndexOf(e) {
    this._ensureValid();
    const t = this._viewToModel[e], i = t > 0 ? this._modelToView[t - 1] : 0;
    return new l5(t, e - i);
  }
}
class bde {
  constructor(e, t, i, r, o, s, a, l) {
    this.model = e, this._validModelVersionId = -1, this._domLineBreaksComputerFactory = t, this._monospaceLineBreaksComputerFactory = i, this.fontInfo = r, this.tabSize = o, this.wrappingStrategy = s, this.wrappingColumn = a, this.wrappingIndent = l, this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  dispose() {
    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);
  }
  createCoordinatesConverter() {
    return new yde(this);
  }
  _constructLines(e, t) {
    this.lines = [], e && (this.hiddenAreasIds = []);
    let i = this.model.getLinesContent();
    const r = i.length, o = this.createLineBreaksComputer();
    for (let f = 0; f < r; f++)
      o.addRequest(i[f], t ? t[f] : null);
    const s = o.finalize();
    let a = [], l = this.hiddenAreasIds.map((f) => this.model.getDecorationRange(f)).sort(V.compareRangesUsingStarts), u = 1, c = 0, h = -1, d = h + 1 < l.length ? c + 1 : r + 2;
    for (let f = 0; f < r; f++) {
      let p = f + 1;
      p === d && (h++, u = l[h].startLineNumber, c = l[h].endLineNumber, d = h + 1 < l.length ? c + 1 : r + 2);
      let g = p >= u && p <= c, _ = AD(s[f], !g);
      a[f] = _.getViewLineCount(), this.lines[f] = _;
    }
    this._validModelVersionId = this.model.getVersionId(), this.prefixSumComputer = new wde(a);
  }
  getHiddenAreas() {
    return this.hiddenAreasIds.map((e) => this.model.getDecorationRange(e));
  }
  _reduceRanges(e) {
    if (e.length === 0)
      return [];
    let t = e.map((s) => this.model.validateRange(s)).sort(V.compareRangesUsingStarts), i = [], r = t[0].startLineNumber, o = t[0].endLineNumber;
    for (let s = 1, a = t.length; s < a; s++) {
      let l = t[s];
      l.startLineNumber > o + 1 ? (i.push(new V(r, 1, o, 1)), r = l.startLineNumber, o = l.endLineNumber) : l.endLineNumber > o && (o = l.endLineNumber);
    }
    return i.push(new V(r, 1, o, 1)), i;
  }
  setHiddenAreas(e) {
    let t = this._reduceRanges(e), i = this.hiddenAreasIds.map((h) => this.model.getDecorationRange(h)).sort(V.compareRangesUsingStarts);
    if (t.length === i.length) {
      let h = !1;
      for (let d = 0; d < t.length; d++)
        if (!t[d].equalsRange(i[d])) {
          h = !0;
          break;
        }
      if (!h)
        return !1;
    }
    let r = [];
    for (const h of t)
      r.push({
        range: h,
        options: Mn.EMPTY
      });
    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, r);
    let o = t, s = 1, a = 0, l = -1, u = l + 1 < o.length ? a + 1 : this.lines.length + 2, c = !1;
    for (let h = 0; h < this.lines.length; h++) {
      let d = h + 1;
      d === u && (l++, s = o[l].startLineNumber, a = o[l].endLineNumber, u = l + 1 < o.length ? a + 1 : this.lines.length + 2);
      let f = !1;
      if (d >= s && d <= a ? this.lines[h].isVisible() && (this.lines[h] = this.lines[h].setVisible(!1), f = !0) : (c = !0, this.lines[h].isVisible() || (this.lines[h] = this.lines[h].setVisible(!0), f = !0)), f) {
        let p = this.lines[h].getViewLineCount();
        this.prefixSumComputer.changeValue(h, p);
      }
    }
    return c || this.setHiddenAreas([]), !0;
  }
  modelPositionIsVisible(e, t) {
    return e < 1 || e > this.lines.length ? !1 : this.lines[e - 1].isVisible();
  }
  getModelLineViewLineCount(e) {
    return e < 1 || e > this.lines.length ? 1 : this.lines[e - 1].getViewLineCount();
  }
  setTabSize(e) {
    return this.tabSize === e ? !1 : (this.tabSize = e, this._constructLines(
      /*resetHiddenAreas*/
      !1,
      null
    ), !0);
  }
  setWrappingSettings(e, t, i, r) {
    const o = this.fontInfo.equals(e), s = this.wrappingStrategy === t, a = this.wrappingColumn === i, l = this.wrappingIndent === r;
    if (o && s && a && l)
      return !1;
    const u = o && s && !a && l;
    this.fontInfo = e, this.wrappingStrategy = t, this.wrappingColumn = i, this.wrappingIndent = r;
    let c = null;
    if (u) {
      c = [];
      for (let h = 0, d = this.lines.length; h < d; h++)
        c[h] = this.lines[h].getLineBreakData();
    }
    return this._constructLines(
      /*resetHiddenAreas*/
      !1,
      c
    ), !0;
  }
  createLineBreaksComputer() {
    return (this.wrappingStrategy === "advanced" ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory).createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);
  }
  onModelFlushed() {
    this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  onModelLinesDeleted(e, t, i) {
    if (e <= this._validModelVersionId)
      return null;
    let r = t === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(t - 2) + 1, o = this.prefixSumComputer.getAccumulatedValue(i - 1);
    return this.lines.splice(t - 1, i - t + 1), this.prefixSumComputer.removeValues(t - 1, i - t + 1), new BT(r, o);
  }
  onModelLinesInserted(e, t, i, r) {
    if (e <= this._validModelVersionId)
      return null;
    const o = t > 2 && !this.lines[t - 2].isVisible();
    let s = t === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(t - 2) + 1, a = 0, l = [], u = [];
    for (let c = 0, h = r.length; c < h; c++) {
      let d = AD(r[c], !o);
      l.push(d);
      let f = d.getViewLineCount();
      a += f, u[c] = f;
    }
    return this.lines = this.lines.slice(0, t - 1).concat(l).concat(this.lines.slice(t - 1)), this.prefixSumComputer.insertValues(t - 1, u), new HT(s, s + a - 1);
  }
  onModelLineChanged(e, t, i) {
    if (e <= this._validModelVersionId)
      return [!1, null, null, null];
    let r = t - 1, o = this.lines[r].getViewLineCount(), s = this.lines[r].isVisible(), a = AD(i, s);
    this.lines[r] = a;
    let l = this.lines[r].getViewLineCount(), u = !1, c = 0, h = -1, d = 0, f = -1, p = 0, g = -1;
    o > l ? (c = t === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(t - 2) + 1, h = c + l - 1, p = h + 1, g = p + (o - l) - 1, u = !0) : o < l ? (c = t === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(t - 2) + 1, h = c + o - 1, d = h + 1, f = d + (l - o) - 1, u = !0) : (c = t === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(t - 2) + 1, h = c + l - 1), this.prefixSumComputer.changeValue(r, l);
    const _ = c <= h ? new O3(c, h) : null, m = d <= f ? new HT(d, f) : null, v = p <= g ? new BT(p, g) : null;
    return [u, _, m, v];
  }
  acceptVersionId(e) {
    this._validModelVersionId = e, this.lines.length === 1 && !this.lines[0].isVisible() && this.setHiddenAreas([]);
  }
  getViewLineCount() {
    return this.prefixSumComputer.getTotalValue();
  }
  _toValidViewLineNumber(e) {
    if (e < 1)
      return 1;
    const t = this.getViewLineCount();
    return e > t ? t : e | 0;
  }
  getActiveIndentGuide(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t), i = this._toValidViewLineNumber(i);
    const r = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), o = this.convertViewPositionToModelPosition(t, this.getViewLineMinColumn(t)), s = this.convertViewPositionToModelPosition(i, this.getViewLineMinColumn(i)), a = this.model.getActiveIndentGuide(r.lineNumber, o.lineNumber, s.lineNumber), l = this.convertModelPositionToViewPosition(a.startLineNumber, 1), u = this.convertModelPositionToViewPosition(a.endLineNumber, this.model.getLineMaxColumn(a.endLineNumber));
    return {
      startLineNumber: l.lineNumber,
      endLineNumber: u.lineNumber,
      indent: a.indent
    };
  }
  getViewLinesIndentGuides(e, t) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const i = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), r = this.convertViewPositionToModelPosition(t, this.getViewLineMaxColumn(t));
    let o = [], s = [], a = [];
    const l = i.lineNumber - 1, u = r.lineNumber - 1;
    let c = null;
    for (let p = l; p <= u; p++) {
      const g = this.lines[p];
      if (g.isVisible()) {
        let _ = g.getViewLineNumberOfModelPosition(0, p === l ? i.column : 1), m = g.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(p + 1)), v = m - _ + 1, C = 0;
        v > 1 && g.getViewLineMinColumn(this.model, p + 1, m) === 1 && (C = _ === 0 ? 1 : 2), s.push(v), a.push(C), c === null && (c = new J(p + 1, 0));
      } else
        c !== null && (o = o.concat(this.model.getLinesIndentGuides(c.lineNumber, p)), c = null);
    }
    c !== null && (o = o.concat(this.model.getLinesIndentGuides(c.lineNumber, r.lineNumber)), c = null);
    const h = t - e + 1;
    let d = new Array(h), f = 0;
    for (let p = 0, g = o.length; p < g; p++) {
      let _ = o[p], m = Math.min(h - f, s[p]), v = a[p], C;
      v === 2 ? C = 0 : v === 1 ? C = 1 : C = m;
      for (let y = 0; y < m; y++)
        y === C && (_ = 0), d[f++] = _;
    }
    return d;
  }
  getViewLineContent(e) {
    e = this._toValidViewLineNumber(e);
    let t = this.prefixSumComputer.getIndexOf(e - 1), i = t.index, r = t.remainder;
    return this.lines[i].getViewLineContent(this.model, i + 1, r);
  }
  getViewLineLength(e) {
    e = this._toValidViewLineNumber(e);
    let t = this.prefixSumComputer.getIndexOf(e - 1), i = t.index, r = t.remainder;
    return this.lines[i].getViewLineLength(this.model, i + 1, r);
  }
  getViewLineMinColumn(e) {
    e = this._toValidViewLineNumber(e);
    let t = this.prefixSumComputer.getIndexOf(e - 1), i = t.index, r = t.remainder;
    return this.lines[i].getViewLineMinColumn(this.model, i + 1, r);
  }
  getViewLineMaxColumn(e) {
    e = this._toValidViewLineNumber(e);
    let t = this.prefixSumComputer.getIndexOf(e - 1), i = t.index, r = t.remainder;
    return this.lines[i].getViewLineMaxColumn(this.model, i + 1, r);
  }
  getViewLineData(e) {
    e = this._toValidViewLineNumber(e);
    let t = this.prefixSumComputer.getIndexOf(e - 1), i = t.index, r = t.remainder;
    return this.lines[i].getViewLineData(this.model, i + 1, r);
  }
  getViewLinesData(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    let r = this.prefixSumComputer.getIndexOf(e - 1), o = e, s = r.index, a = r.remainder, l = [];
    for (let u = s, c = this.model.getLineCount(); u < c; u++) {
      let h = this.lines[u];
      if (!h.isVisible())
        continue;
      let d = u === s ? a : 0, f = h.getViewLineCount() - d, p = !1;
      o + f > t && (p = !0, f = t - o + 1);
      let g = d + f;
      if (h.getViewLinesData(this.model, u + 1, d, g, o - e, i, l), o += f, p)
        break;
    }
    return l;
  }
  validateViewPosition(e, t, i) {
    e = this._toValidViewLineNumber(e);
    let r = this.prefixSumComputer.getIndexOf(e - 1), o = r.index, s = r.remainder, a = this.lines[o], l = a.getViewLineMinColumn(this.model, o + 1, s), u = a.getViewLineMaxColumn(this.model, o + 1, s);
    t < l && (t = l), t > u && (t = u);
    let c = a.getModelColumnOfViewPosition(s, t);
    return this.model.validatePosition(new J(o + 1, c)).equals(i) ? new J(e, t) : this.convertModelPositionToViewPosition(i.lineNumber, i.column);
  }
  validateViewRange(e, t) {
    const i = this.validateViewPosition(e.startLineNumber, e.startColumn, t.getStartPosition()), r = this.validateViewPosition(e.endLineNumber, e.endColumn, t.getEndPosition());
    return new V(i.lineNumber, i.column, r.lineNumber, r.column);
  }
  convertViewPositionToModelPosition(e, t) {
    e = this._toValidViewLineNumber(e);
    let i = this.prefixSumComputer.getIndexOf(e - 1), r = i.index, o = i.remainder, s = this.lines[r].getModelColumnOfViewPosition(o, t);
    return this.model.validatePosition(new J(r + 1, s));
  }
  convertViewRangeToModelRange(e) {
    const t = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), i = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    return new V(t.lineNumber, t.column, i.lineNumber, i.column);
  }
  convertModelPositionToViewPosition(e, t) {
    const i = this.model.validatePosition(new J(e, t)), r = i.lineNumber, o = i.column;
    let s = r - 1, a = !1;
    for (; s > 0 && !this.lines[s].isVisible(); )
      s--, a = !0;
    if (s === 0 && !this.lines[s].isVisible())
      return new J(1, 1);
    const l = 1 + (s === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(s - 1));
    let u;
    return a ? u = this.lines[s].getViewPositionOfModelPosition(l, this.model.getLineMaxColumn(s + 1)) : u = this.lines[r - 1].getViewPositionOfModelPosition(l, o), u;
  }
  convertModelRangeToViewRange(e) {
    let t = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn), i = this.convertModelPositionToViewPosition(e.endLineNumber, e.endColumn);
    return e.startLineNumber === e.endLineNumber && t.lineNumber !== i.lineNumber && i.column === this.getViewLineMinColumn(i.lineNumber) ? new V(t.lineNumber, t.column, i.lineNumber - 1, this.getViewLineMaxColumn(i.lineNumber - 1)) : new V(t.lineNumber, t.column, i.lineNumber, i.column);
  }
  _getViewLineNumberForModelPosition(e, t) {
    let i = e - 1;
    if (this.lines[i].isVisible()) {
      const o = 1 + (i === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(i - 1));
      return this.lines[i].getViewLineNumberOfModelPosition(o, t);
    }
    for (; i > 0 && !this.lines[i].isVisible(); )
      i--;
    if (i === 0 && !this.lines[i].isVisible())
      return 1;
    const r = 1 + (i === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(i - 1));
    return this.lines[i].getViewLineNumberOfModelPosition(r, this.model.getLineMaxColumn(i + 1));
  }
  getAllOverviewRulerDecorations(e, t, i) {
    const r = this.model.getOverviewRulerDecorations(e, t), o = new N3();
    for (const s of r) {
      const a = s.options.overviewRuler, l = a ? a.position : 0;
      if (l === 0)
        continue;
      const u = a.getColor(i), c = this._getViewLineNumberForModelPosition(s.range.startLineNumber, s.range.startColumn), h = this._getViewLineNumberForModelPosition(s.range.endLineNumber, s.range.endColumn);
      o.accept(u, c, h, l);
    }
    return o.result;
  }
  getDecorationsInRange(e, t, i) {
    const r = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), o = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    if (o.lineNumber - r.lineNumber <= e.endLineNumber - e.startLineNumber)
      return this.model.getDecorationsInRange(new V(r.lineNumber, 1, o.lineNumber, o.column), t, i);
    let s = [];
    const a = r.lineNumber - 1, l = o.lineNumber - 1;
    let u = null;
    for (let f = a; f <= l; f++)
      if (this.lines[f].isVisible())
        u === null && (u = new J(f + 1, f === a ? r.column : 1));
      else if (u !== null) {
        const g = this.model.getLineMaxColumn(f);
        s = s.concat(this.model.getDecorationsInRange(new V(u.lineNumber, u.column, f, g), t, i)), u = null;
      }
    u !== null && (s = s.concat(this.model.getDecorationsInRange(new V(u.lineNumber, u.column, o.lineNumber, o.column), t, i)), u = null), s.sort((f, p) => {
      const g = V.compareRangesUsingStarts(f.range, p.range);
      return g === 0 ? f.id < p.id ? -1 : f.id > p.id ? 1 : 0 : g;
    });
    let c = [], h = 0, d = null;
    for (const f of s) {
      const p = f.id;
      d !== p && (d = p, c[h++] = f);
    }
    return c;
  }
  normalizePosition(e, t) {
    const i = this._toValidViewLineNumber(e.lineNumber), r = this.prefixSumComputer.getIndexOf(i - 1), o = r.index, s = r.remainder;
    return this.lines[o].normalizePosition(this.model, o + 1, s, e, t);
  }
  getLineIndentColumn(e) {
    const t = this._toValidViewLineNumber(e), i = this.prefixSumComputer.getIndexOf(t - 1), r = i.index;
    return i.remainder === 0 ? this.model.getLineIndentColumn(r + 1) : 0;
  }
}
class jb {
  constructor() {
  }
  isVisible() {
    return !0;
  }
  setVisible(e) {
    return e ? this : $b.INSTANCE;
  }
  getLineBreakData() {
    return null;
  }
  getViewLineCount() {
    return 1;
  }
  getViewLineContent(e, t, i) {
    return e.getLineContent(t);
  }
  getViewLineLength(e, t, i) {
    return e.getLineLength(t);
  }
  getViewLineMinColumn(e, t, i) {
    return e.getLineMinColumn(t);
  }
  getViewLineMaxColumn(e, t, i) {
    return e.getLineMaxColumn(t);
  }
  getViewLineData(e, t, i) {
    let r = e.getLineTokens(t), o = r.getLineContent();
    return new AN(o, !1, 1, o.length + 1, 0, r.inflate());
  }
  getViewLinesData(e, t, i, r, o, s, a) {
    if (!s[o]) {
      a[o] = null;
      return;
    }
    a[o] = this.getViewLineData(e, t, 0);
  }
  getModelColumnOfViewPosition(e, t) {
    return t;
  }
  getViewPositionOfModelPosition(e, t) {
    return new J(e, t);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
  normalizePosition(e, t, i, r, o) {
    return r;
  }
}
jb.INSTANCE = new jb();
class $b {
  constructor() {
  }
  isVisible() {
    return !1;
  }
  setVisible(e) {
    return e ? jb.INSTANCE : this;
  }
  getLineBreakData() {
    return null;
  }
  getViewLineCount() {
    return 0;
  }
  getViewLineContent(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineLength(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMinColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMaxColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineData(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLinesData(e, t, i, r, o, s, a) {
    throw new Error("Not supported");
  }
  getModelColumnOfViewPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewPositionOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewLineNumberOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  normalizePosition(e, t, i, r, o) {
    throw new Error("Not supported");
  }
}
$b.INSTANCE = new $b();
class Sde {
  constructor(e, t) {
    this._lineBreakData = e, this._isVisible = t;
  }
  isVisible() {
    return this._isVisible;
  }
  setVisible(e) {
    return this._isVisible = e, this;
  }
  getLineBreakData() {
    return this._lineBreakData;
  }
  getViewLineCount() {
    return this._isVisible ? this._lineBreakData.breakOffsets.length : 0;
  }
  getInputStartOffsetOfOutputLineIndex(e) {
    return Uh.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, e, 0);
  }
  getInputEndOffsetOfOutputLineIndex(e, t, i) {
    return i + 1 === this._lineBreakData.breakOffsets.length ? e.getLineMaxColumn(t) - 1 : Uh.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, i + 1, 0);
  }
  getViewLineContent(e, t, i) {
    if (!this._isVisible)
      throw new Error("Not supported");
    let r = this.getInputStartOffsetOfOutputLineIndex(i), o = this.getInputEndOffsetOfOutputLineIndex(e, t, i), s = e.getValueInRange({
      startLineNumber: t,
      startColumn: r + 1,
      endLineNumber: t,
      endColumn: o + 1
    });
    return i > 0 && (s = N2(this._lineBreakData.wrappedTextIndentLength) + s), s;
  }
  getViewLineLength(e, t, i) {
    if (!this._isVisible)
      throw new Error("Not supported");
    let r = this.getInputStartOffsetOfOutputLineIndex(i), s = this.getInputEndOffsetOfOutputLineIndex(e, t, i) - r;
    return i > 0 && (s = this._lineBreakData.wrappedTextIndentLength + s), s;
  }
  getViewLineMinColumn(e, t, i) {
    if (!this._isVisible)
      throw new Error("Not supported");
    return this._getViewLineMinColumn(i);
  }
  _getViewLineMinColumn(e) {
    return e > 0 ? this._lineBreakData.wrappedTextIndentLength + 1 : 1;
  }
  getViewLineMaxColumn(e, t, i) {
    if (!this._isVisible)
      throw new Error("Not supported");
    return this.getViewLineLength(e, t, i) + 1;
  }
  getViewLineData(e, t, i) {
    if (!this._isVisible)
      throw new Error("Not supported");
    let r = this.getInputStartOffsetOfOutputLineIndex(i), o = this.getInputEndOffsetOfOutputLineIndex(e, t, i), s = e.getValueInRange({
      startLineNumber: t,
      startColumn: r + 1,
      endLineNumber: t,
      endColumn: o + 1
    });
    i > 0 && (s = N2(this._lineBreakData.wrappedTextIndentLength) + s);
    let a = i > 0 ? this._lineBreakData.wrappedTextIndentLength + 1 : 1, l = s.length + 1, u = i + 1 < this.getViewLineCount(), c = 0;
    i > 0 && (c = this._lineBreakData.wrappedTextIndentLength);
    let h = e.getLineTokens(t);
    const d = i === 0 ? 0 : this._lineBreakData.breakOffsetsVisibleColumn[i - 1];
    return new AN(s, u, a, l, d, h.sliceAndInflate(r, o, c));
  }
  getViewLinesData(e, t, i, r, o, s, a) {
    if (!this._isVisible)
      throw new Error("Not supported");
    for (let l = i; l < r; l++) {
      let u = o + l - i;
      if (!s[u]) {
        a[u] = null;
        continue;
      }
      a[u] = this.getViewLineData(e, t, l);
    }
  }
  getModelColumnOfViewPosition(e, t) {
    if (!this._isVisible)
      throw new Error("Not supported");
    let i = t - 1;
    return e > 0 && (i < this._lineBreakData.wrappedTextIndentLength ? i = 0 : i -= this._lineBreakData.wrappedTextIndentLength), Uh.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, e, i) + 1;
  }
  getViewPositionOfModelPosition(e, t) {
    if (!this._isVisible)
      throw new Error("Not supported");
    let i = Uh.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, t - 1), r = i.outputLineIndex, o = i.outputOffset + 1;
    return r > 0 && (o += this._lineBreakData.wrappedTextIndentLength), new J(e + r, o);
  }
  getViewLineNumberOfModelPosition(e, t) {
    if (!this._isVisible)
      throw new Error("Not supported");
    const i = Uh.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, t - 1);
    return e + i.outputLineIndex;
  }
  normalizePosition(e, t, i, r, o) {
    if (o === 0) {
      if (i > 0 && r.column === this._getViewLineMinColumn(i))
        return new J(r.lineNumber - 1, this.getViewLineMaxColumn(e, t, i - 1));
    } else if (o === 1) {
      const s = this.getViewLineCount() - 1;
      if (i < s && r.column === this.getViewLineMaxColumn(e, t, i))
        return new J(r.lineNumber + 1, this._getViewLineMinColumn(i + 1));
    }
    return r;
  }
}
let PD = [""];
function N2(n) {
  if (n >= PD.length)
    for (let e = 1; e <= n; e++)
      PD[e] = Ede(e);
  return PD[n];
}
function Ede(n) {
  return new Array(n + 1).join(" ");
}
function AD(n, e) {
  return n === null ? e ? jb.INSTANCE : $b.INSTANCE : new Sde(n, e);
}
class Lde {
  constructor(e) {
    this._lines = e;
  }
  _validPosition(e) {
    return this._lines.model.validatePosition(e);
  }
  _validRange(e) {
    return this._lines.model.validateRange(e);
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._validPosition(e);
  }
  convertViewRangeToModelRange(e) {
    return this._validRange(e);
  }
  validateViewPosition(e, t) {
    return this._validPosition(t);
  }
  validateViewRange(e, t) {
    return this._validRange(t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e) {
    return this._validPosition(e);
  }
  convertModelRangeToViewRange(e) {
    return this._validRange(e);
  }
  modelPositionIsVisible(e) {
    const t = this._lines.model.getLineCount();
    return !(e.lineNumber < 1 || e.lineNumber > t);
  }
  getModelLineViewLineCount(e) {
    return 1;
  }
}
class Dde {
  constructor(e) {
    this.model = e;
  }
  dispose() {
  }
  createCoordinatesConverter() {
    return new Lde(this);
  }
  getHiddenAreas() {
    return [];
  }
  setHiddenAreas(e) {
    return !1;
  }
  setTabSize(e) {
    return !1;
  }
  setWrappingSettings(e, t, i, r) {
    return !1;
  }
  createLineBreaksComputer() {
    let e = [];
    return {
      addRequest: (t, i) => {
        e.push(null);
      },
      finalize: () => e
    };
  }
  onModelFlushed() {
  }
  onModelLinesDeleted(e, t, i) {
    return new BT(t, i);
  }
  onModelLinesInserted(e, t, i, r) {
    return new HT(t, i);
  }
  onModelLineChanged(e, t, i) {
    return [!1, new O3(t, t), null, null];
  }
  acceptVersionId(e) {
  }
  getViewLineCount() {
    return this.model.getLineCount();
  }
  getActiveIndentGuide(e, t, i) {
    return {
      startLineNumber: e,
      endLineNumber: e,
      indent: 0
    };
  }
  getViewLinesIndentGuides(e, t) {
    const i = t - e + 1;
    let r = new Array(i);
    for (let o = 0; o < i; o++)
      r[o] = 0;
    return r;
  }
  getViewLineContent(e) {
    return this.model.getLineContent(e);
  }
  getViewLineLength(e) {
    return this.model.getLineLength(e);
  }
  getViewLineMinColumn(e) {
    return this.model.getLineMinColumn(e);
  }
  getViewLineMaxColumn(e) {
    return this.model.getLineMaxColumn(e);
  }
  getViewLineData(e) {
    let t = this.model.getLineTokens(e), i = t.getLineContent();
    return new AN(i, !1, 1, i.length + 1, 0, t.inflate());
  }
  getViewLinesData(e, t, i) {
    const r = this.model.getLineCount();
    e = Math.min(Math.max(1, e), r), t = Math.min(Math.max(1, t), r);
    let o = [];
    for (let s = e; s <= t; s++) {
      let a = s - e;
      i[a] || (o[a] = null), o[a] = this.getViewLineData(s);
    }
    return o;
  }
  getAllOverviewRulerDecorations(e, t, i) {
    const r = this.model.getOverviewRulerDecorations(e, t), o = new N3();
    for (const s of r) {
      const a = s.options.overviewRuler, l = a ? a.position : 0;
      if (l === 0)
        continue;
      const u = a.getColor(i), c = s.range.startLineNumber, h = s.range.endLineNumber;
      o.accept(u, c, h, l);
    }
    return o.result;
  }
  getDecorationsInRange(e, t, i) {
    return this.model.getDecorationsInRange(e, t, i);
  }
  normalizePosition(e, t) {
    return this.model.normalizePosition(e, t);
  }
  getLineIndentColumn(e) {
    return this.model.getLineIndentColumn(e);
  }
}
class N3 {
  constructor() {
    this.result = /* @__PURE__ */ Object.create(null);
  }
  accept(e, t, i, r) {
    let o = this.result[e];
    if (o) {
      const s = o[o.length - 3], a = o[o.length - 1];
      if (s === r && a + 1 >= t) {
        i > a && (o[o.length - 1] = i);
        return;
      }
      o.push(r, t, i);
    } else
      this.result[e] = [r, t, i];
  }
}
class Rde {
  constructor(e, t, i, r, o) {
    this.editorId = e, this.model = t, this.configuration = i, this._linesCollection = r, this._coordinatesConverter = o, this._decorationsCache = /* @__PURE__ */ Object.create(null), this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  _clearCachedModelDecorationsResolver() {
    this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  dispose() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  reset() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onModelDecorationsChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onLineMappingChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  _getOrCreateViewModelDecoration(e) {
    const t = e.id;
    let i = this._decorationsCache[t];
    if (!i) {
      const r = e.range, o = e.options;
      let s;
      if (o.isWholeLine) {
        const a = this._coordinatesConverter.convertModelPositionToViewPosition(new J(r.startLineNumber, 1)), l = this._coordinatesConverter.convertModelPositionToViewPosition(new J(r.endLineNumber, this.model.getLineMaxColumn(r.endLineNumber)));
        s = new V(a.lineNumber, a.column, l.lineNumber, l.column);
      } else
        s = this._coordinatesConverter.convertModelRangeToViewRange(r);
      i = new g5(s, o), this._decorationsCache[t] = i;
    }
    return i;
  }
  getDecorationsViewportData(e) {
    let t = this._cachedModelDecorationsResolver !== null;
    return t = t && e.equalsRange(this._cachedModelDecorationsResolverViewRange), t || (this._cachedModelDecorationsResolver = this._getDecorationsViewportData(e), this._cachedModelDecorationsResolverViewRange = e), this._cachedModelDecorationsResolver;
  }
  _getDecorationsViewportData(e) {
    const t = this._linesCollection.getDecorationsInRange(e, this.editorId, rN(this.configuration.options)), i = e.startLineNumber, r = e.endLineNumber;
    let o = [], s = 0, a = [];
    for (let l = i; l <= r; l++)
      a[l - i] = [];
    for (let l = 0, u = t.length; l < u; l++) {
      let c = t[l], h = c.options, d = this._getOrCreateViewModelDecoration(c), f = d.range;
      if (o[s++] = d, h.inlineClassName) {
        let p = new nw(
          f,
          h.inlineClassName,
          h.inlineClassNameAffectsLetterSpacing ? 3 : 0
          /* Regular */
        ), g = Math.max(i, f.startLineNumber), _ = Math.min(r, f.endLineNumber);
        for (let m = g; m <= _; m++)
          a[m - i].push(p);
      }
      if (h.beforeContentClassName && i <= f.startLineNumber && f.startLineNumber <= r) {
        let p = new nw(
          new V(f.startLineNumber, f.startColumn, f.startLineNumber, f.startColumn),
          h.beforeContentClassName,
          1
          /* Before */
        );
        a[f.startLineNumber - i].push(p);
      }
      if (h.afterContentClassName && i <= f.endLineNumber && f.endLineNumber <= r) {
        let p = new nw(
          new V(f.endLineNumber, f.endColumn, f.endLineNumber, f.endColumn),
          h.afterContentClassName,
          2
          /* After */
        );
        a[f.endLineNumber - i].push(p);
      }
    }
    return {
      decorations: o,
      inlineDecorations: a
    };
  }
}
class Tde extends ge {
  constructor(e, t, i, r, o, s) {
    if (super(), this._editorId = e, this._configuration = t, this.model = i, this._eventDispatcher = new lde(), this.onEvent = this._eventDispatcher.onEvent, this.cursorConfig = new na(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration), this._tokenizeViewportSoon = this._register(new to(() => this.tokenizeViewport(), 50)), this._updateConfigurationViewLineCount = this._register(new to(() => this._updateConfigurationViewLineCountNow(), 0)), this._hasFocus = !1, this._viewportStartLine = -1, this._viewportStartLineTrackedRange = null, this._viewportStartLineDelta = 0, this.model.isTooLargeForTokenization())
      this._lines = new Dde(this.model);
    else {
      const a = this._configuration.options, l = a.get(
        40
        /* fontInfo */
      ), u = a.get(
        122
        /* wrappingStrategy */
      ), c = a.get(
        129
        /* wrappingInfo */
      ), h = a.get(
        121
        /* wrappingIndent */
      );
      this._lines = new bde(this.model, r, o, l, this.model.getOptions().tabSize, u, c.wrappingColumn, h);
    }
    this.coordinatesConverter = this._lines.createCoordinatesConverter(), this._cursor = this._register(new Zp(i, this, this.coordinatesConverter, this.cursorConfig)), this.viewLayout = this._register(new Cde(this._configuration, this.getLineCount(), s)), this._register(this.viewLayout.onDidScroll((a) => {
      a.scrollTopChanged && this._tokenizeViewportSoon.schedule(), this._eventDispatcher.emitSingleViewEvent(new nde(a)), this._eventDispatcher.emitOutgoingEvent(new aI(a.oldScrollWidth, a.oldScrollLeft, a.oldScrollHeight, a.oldScrollTop, a.scrollWidth, a.scrollLeft, a.scrollHeight, a.scrollTop));
    })), this._register(this.viewLayout.onDidContentSizeChange((a) => {
      this._eventDispatcher.emitOutgoingEvent(a);
    })), this._decorations = new Rde(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter), this._registerModelEvents(), this._register(this._configuration.onDidChangeFast((a) => {
      try {
        const l = this._eventDispatcher.beginEmitViewEvents();
        this._onConfigurationChanged(l, a);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    })), this._register($_.getInstance().onDidChange(() => {
      this._eventDispatcher.emitSingleViewEvent(new sde());
    })), this._updateConfigurationViewLineCountNow();
  }
  dispose() {
    super.dispose(), this._decorations.dispose(), this._lines.dispose(), this.invalidateMinimapColorCache(), this._viewportStartLineTrackedRange = this.model._setTrackedRange(
      this._viewportStartLineTrackedRange,
      null,
      1
      /* NeverGrowsWhenTypingAtEdges */
    ), this._eventDispatcher.dispose();
  }
  createLineBreaksComputer() {
    return this._lines.createLineBreaksComputer();
  }
  addViewEventHandler(e) {
    this._eventDispatcher.addViewEventHandler(e);
  }
  removeViewEventHandler(e) {
    this._eventDispatcher.removeViewEventHandler(e);
  }
  _updateConfigurationViewLineCountNow() {
    this._configuration.setViewLineCount(this._lines.getViewLineCount());
  }
  tokenizeViewport() {
    const e = this.viewLayout.getLinesViewportData(), t = this.coordinatesConverter.convertViewPositionToModelPosition(new J(e.startLineNumber, 1)), i = this.coordinatesConverter.convertViewPositionToModelPosition(new J(e.endLineNumber, 1));
    this.model.tokenizeViewport(t.lineNumber, i.lineNumber);
  }
  setHasFocus(e) {
    this._hasFocus = e, this._cursor.setHasFocus(e), this._eventDispatcher.emitSingleViewEvent(new tde(e)), this._eventDispatcher.emitOutgoingEvent(new sI(!e, e));
  }
  onCompositionStart() {
    this._eventDispatcher.emitSingleViewEvent(new Zhe());
  }
  onCompositionEnd() {
    this._eventDispatcher.emitSingleViewEvent(new Qhe());
  }
  onDidColorThemeChange() {
    this._eventDispatcher.emitSingleViewEvent(new rde());
  }
  _onConfigurationChanged(e, t) {
    let i = null;
    if (this._viewportStartLine !== -1) {
      let c = new J(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));
      i = this.coordinatesConverter.convertViewPositionToModelPosition(c);
    }
    let r = !1;
    const o = this._configuration.options, s = o.get(
      40
      /* fontInfo */
    ), a = o.get(
      122
      /* wrappingStrategy */
    ), l = o.get(
      129
      /* wrappingInfo */
    ), u = o.get(
      121
      /* wrappingIndent */
    );
    if (this._lines.setWrappingSettings(s, a, l.wrappingColumn, u) && (e.emitViewEvent(new Ly()), e.emitViewEvent(new Dy()), e.emitViewEvent(new Nf(null)), this._cursor.onLineMappingChanged(e), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.getCurrentScrollTop() !== 0 && (r = !0), this._updateConfigurationViewLineCount.schedule()), t.hasChanged(
      78
      /* readOnly */
    ) && (this._decorations.reset(), e.emitViewEvent(new Nf(null))), e.emitViewEvent(new Jhe(t)), this.viewLayout.onConfigurationChanged(t), r && i) {
      const c = this.coordinatesConverter.convertModelPositionToViewPosition(i), h = this.viewLayout.getVerticalOffsetForLineNumber(c.lineNumber);
      this.viewLayout.setScrollPosition(
        { scrollTop: h + this._viewportStartLineDelta },
        1
        /* Immediate */
      );
    }
    na.shouldRecreate(t) && (this.cursorConfig = new na(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration), this._cursor.updateConfiguration(this.cursorConfig));
  }
  _registerModelEvents() {
    this._register(this.model.onDidChangeRawContentFast((e) => {
      try {
        const t = this._eventDispatcher.beginEmitViewEvents();
        let i = !1, r = !1;
        const o = e.changes, s = e.versionId, a = this._lines.createLineBreaksComputer();
        for (const c of o)
          switch (c.changeType) {
            case 4: {
              for (const h of c.detail)
                a.addRequest(h, null);
              break;
            }
            case 2: {
              a.addRequest(c.detail, null);
              break;
            }
          }
        const l = a.finalize();
        let u = 0;
        for (const c of o)
          switch (c.changeType) {
            case 1: {
              this._lines.onModelFlushed(), t.emitViewEvent(new Ly()), this._decorations.reset(), this.viewLayout.onFlushed(this.getLineCount()), i = !0;
              break;
            }
            case 3: {
              const h = this._lines.onModelLinesDeleted(s, c.fromLineNumber, c.toLineNumber);
              h !== null && (t.emitViewEvent(h), this.viewLayout.onLinesDeleted(h.fromLineNumber, h.toLineNumber)), i = !0;
              break;
            }
            case 4: {
              const h = l.slice(u, u + c.detail.length);
              u += c.detail.length;
              const d = this._lines.onModelLinesInserted(s, c.fromLineNumber, c.toLineNumber, h);
              d !== null && (t.emitViewEvent(d), this.viewLayout.onLinesInserted(d.fromLineNumber, d.toLineNumber)), i = !0;
              break;
            }
            case 2: {
              const h = l[u];
              u++;
              const [d, f, p, g] = this._lines.onModelLineChanged(s, c.lineNumber, h);
              r = d, f && t.emitViewEvent(f), p && (t.emitViewEvent(p), this.viewLayout.onLinesInserted(p.fromLineNumber, p.toLineNumber)), g && (t.emitViewEvent(g), this.viewLayout.onLinesDeleted(g.fromLineNumber, g.toLineNumber));
              break;
            }
            case 5:
              break;
          }
        this._lines.acceptVersionId(s), this.viewLayout.onHeightMaybeChanged(), !i && r && (t.emitViewEvent(new Dy()), t.emitViewEvent(new Nf(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged());
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      if (this._viewportStartLine = -1, this._configuration.setMaxLineNumber(this.model.getLineCount()), this._updateConfigurationViewLineCountNow(), !this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {
        const t = this.model._getTrackedRange(this._viewportStartLineTrackedRange);
        if (t) {
          const i = this.coordinatesConverter.convertModelPositionToViewPosition(t.getStartPosition()), r = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber);
          this.viewLayout.setScrollPosition(
            { scrollTop: r + this._viewportStartLineDelta },
            1
            /* Immediate */
          );
        }
      }
      try {
        const t = this._eventDispatcher.beginEmitViewEvents();
        this._cursor.onModelContentChanged(t, e);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    })), this._register(this.model.onDidChangeTokens((e) => {
      let t = [];
      for (let i = 0, r = e.ranges.length; i < r; i++) {
        const o = e.ranges[i], s = this.coordinatesConverter.convertModelPositionToViewPosition(new J(o.fromLineNumber, 1)).lineNumber, a = this.coordinatesConverter.convertModelPositionToViewPosition(new J(o.toLineNumber, this.model.getLineMaxColumn(o.toLineNumber))).lineNumber;
        t[i] = {
          fromLineNumber: s,
          toLineNumber: a
        };
      }
      this._eventDispatcher.emitSingleViewEvent(new ode(t)), e.tokenizationSupportChanged && this._tokenizeViewportSoon.schedule();
    })), this._register(this.model.onDidChangeLanguageConfiguration((e) => {
      this._eventDispatcher.emitSingleViewEvent(new ide()), this.cursorConfig = new na(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration), this._cursor.updateConfiguration(this.cursorConfig);
    })), this._register(this.model.onDidChangeLanguage((e) => {
      this.cursorConfig = new na(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration), this._cursor.updateConfiguration(this.cursorConfig);
    })), this._register(this.model.onDidChangeOptions((e) => {
      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {
        try {
          const t = this._eventDispatcher.beginEmitViewEvents();
          t.emitViewEvent(new Ly()), t.emitViewEvent(new Dy()), t.emitViewEvent(new Nf(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount());
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        this._updateConfigurationViewLineCount.schedule();
      }
      this.cursorConfig = new na(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration), this._cursor.updateConfiguration(this.cursorConfig);
    })), this._register(this.model.onDidChangeDecorations((e) => {
      this._decorations.onModelDecorationsChanged(), this._eventDispatcher.emitSingleViewEvent(new Nf(e));
    }));
  }
  setHiddenAreas(e) {
    try {
      const t = this._eventDispatcher.beginEmitViewEvents();
      this._lines.setHiddenAreas(e) && (t.emitViewEvent(new Ly()), t.emitViewEvent(new Dy()), t.emitViewEvent(new Nf(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.onHeightMaybeChanged());
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
    this._updateConfigurationViewLineCount.schedule();
  }
  getVisibleRangesPlusViewportAboveBelow() {
    const e = this._configuration.options.get(
      128
      /* layoutInfo */
    ), t = this._configuration.options.get(
      56
      /* lineHeight */
    ), i = Math.max(20, Math.round(e.height / t)), r = this.viewLayout.getLinesViewportData(), o = Math.max(1, r.completelyVisibleStartLineNumber - i), s = Math.min(this.getLineCount(), r.completelyVisibleEndLineNumber + i);
    return this._toModelVisibleRanges(new V(o, this.getLineMinColumn(o), s, this.getLineMaxColumn(s)));
  }
  getVisibleRanges() {
    const e = this.getCompletelyVisibleViewRange();
    return this._toModelVisibleRanges(e);
  }
  _toModelVisibleRanges(e) {
    const t = this.coordinatesConverter.convertViewRangeToModelRange(e), i = this._lines.getHiddenAreas();
    if (i.length === 0)
      return [t];
    let r = [], o = 0, s = t.startLineNumber, a = t.startColumn, l = t.endLineNumber, u = t.endColumn;
    for (let c = 0, h = i.length; c < h; c++) {
      const d = i[c].startLineNumber, f = i[c].endLineNumber;
      f < s || d > l || (s < d && (r[o++] = new V(s, a, d - 1, this.model.getLineMaxColumn(d - 1))), s = f + 1, a = 1);
    }
    return (s < l || s === l && a < u) && (r[o++] = new V(s, a, l, u)), r;
  }
  getCompletelyVisibleViewRange() {
    const e = this.viewLayout.getLinesViewportData(), t = e.completelyVisibleStartLineNumber, i = e.completelyVisibleEndLineNumber;
    return new V(t, this.getLineMinColumn(t), i, this.getLineMaxColumn(i));
  }
  getCompletelyVisibleViewRangeAtScrollTop(e) {
    const t = this.viewLayout.getLinesViewportDataAtScrollTop(e), i = t.completelyVisibleStartLineNumber, r = t.completelyVisibleEndLineNumber;
    return new V(i, this.getLineMinColumn(i), r, this.getLineMaxColumn(r));
  }
  saveState() {
    const e = this.viewLayout.saveState(), t = e.scrollTop, i = this.viewLayout.getLineNumberAtVerticalOffset(t), r = this.coordinatesConverter.convertViewPositionToModelPosition(new J(i, this.getLineMinColumn(i))), o = this.viewLayout.getVerticalOffsetForLineNumber(i) - t;
    return {
      scrollLeft: e.scrollLeft,
      firstPosition: r,
      firstPositionDeltaTop: o
    };
  }
  reduceRestoreState(e) {
    if (typeof e.firstPosition > "u")
      return this._reduceRestoreStateCompatibility(e);
    const t = this.model.validatePosition(e.firstPosition), i = this.coordinatesConverter.convertModelPositionToViewPosition(t), r = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber) - e.firstPositionDeltaTop;
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: r
    };
  }
  _reduceRestoreStateCompatibility(e) {
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTopWithoutViewZones
    };
  }
  getTabSize() {
    return this.model.getOptions().tabSize;
  }
  getTextModelOptions() {
    return this.model.getOptions();
  }
  getLineCount() {
    return this._lines.getViewLineCount();
  }
  /**
   * Gives a hint that a lot of requests are about to come in for these line numbers.
   */
  setViewport(e, t, i) {
    this._viewportStartLine = e;
    let r = this.coordinatesConverter.convertViewPositionToModelPosition(new J(e, this.getLineMinColumn(e)));
    this._viewportStartLineTrackedRange = this.model._setTrackedRange(
      this._viewportStartLineTrackedRange,
      new V(r.lineNumber, r.column, r.lineNumber, r.column),
      1
      /* NeverGrowsWhenTypingAtEdges */
    );
    const o = this.viewLayout.getVerticalOffsetForLineNumber(e), s = this.viewLayout.getCurrentScrollTop();
    this._viewportStartLineDelta = s - o;
  }
  getActiveIndentGuide(e, t, i) {
    return this._lines.getActiveIndentGuide(e, t, i);
  }
  getLinesIndentGuides(e, t) {
    return this._lines.getViewLinesIndentGuides(e, t);
  }
  getLineContent(e) {
    return this._lines.getViewLineContent(e);
  }
  getLineLength(e) {
    return this._lines.getViewLineLength(e);
  }
  getLineMinColumn(e) {
    return this._lines.getViewLineMinColumn(e);
  }
  getLineMaxColumn(e) {
    return this._lines.getViewLineMaxColumn(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = Es(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = wg(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  getDecorationsInViewport(e) {
    return this._decorations.getDecorationsViewportData(e).decorations;
  }
  getViewLineRenderingData(e, t) {
    let i = this.model.mightContainRTL(), r = this.model.mightContainNonBasicASCII(), o = this.getTabSize(), s = this._lines.getViewLineData(t), l = this._decorations.getDecorationsViewportData(e).inlineDecorations[t - e.startLineNumber];
    return new $o(s.minColumn, s.maxColumn, s.content, s.continuesWithWrappedLine, i, r, s.tokens, l, o, s.startVisibleColumn);
  }
  getViewLineData(e) {
    return this._lines.getViewLineData(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    let r = this._lines.getViewLinesData(e, t, i);
    return new Lse(this.getTabSize(), r);
  }
  getAllOverviewRulerDecorations(e) {
    return this._lines.getAllOverviewRulerDecorations(this._editorId, rN(this._configuration.options), e);
  }
  invalidateOverviewRulerColorCache() {
    const e = this.model.getOverviewRulerDecorations();
    for (const t of e) {
      const i = t.options.overviewRuler;
      i && i.invalidateCachedColor();
    }
  }
  invalidateMinimapColorCache() {
    const e = this.model.getAllDecorations();
    for (const t of e) {
      const i = t.options.minimap;
      i && i.invalidateCachedColor();
    }
  }
  getValueInRange(e, t) {
    const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
    return this.model.getValueInRange(i, t);
  }
  getModelLineMaxColumn(e) {
    return this.model.getLineMaxColumn(e);
  }
  validateModelPosition(e) {
    return this.model.validatePosition(e);
  }
  validateModelRange(e) {
    return this.model.validateRange(e);
  }
  deduceModelPositionRelativeToViewPosition(e, t, i) {
    const r = this.coordinatesConverter.convertViewPositionToModelPosition(e);
    this.model.getEOL().length === 2 && (t < 0 ? t -= i : t += i);
    const s = this.model.getOffsetAt(r) + t;
    return this.model.getPositionAt(s);
  }
  getEOL() {
    return this.model.getEOL();
  }
  getPlainTextToCopy(e, t, i) {
    const r = i ? `\r
` : this.model.getEOL();
    e = e.slice(0), e.sort(V.compareRangesUsingStarts);
    let o = !1, s = !1;
    for (const l of e)
      l.isEmpty() ? o = !0 : s = !0;
    if (!s) {
      if (!t)
        return "";
      const l = e.map((c) => c.startLineNumber);
      let u = "";
      for (let c = 0; c < l.length; c++)
        c > 0 && l[c - 1] === l[c] || (u += this.model.getLineContent(l[c]) + r);
      return u;
    }
    if (o && t) {
      let l = [], u = 0;
      for (const c of e) {
        const h = c.startLineNumber;
        c.isEmpty() ? h !== u && l.push(this.model.getLineContent(h)) : l.push(this.model.getValueInRange(
          c,
          i ? 2 : 0
          /* TextDefined */
        )), u = h;
      }
      return l.length === 1 ? l[0] : l;
    }
    let a = [];
    for (const l of e)
      l.isEmpty() || a.push(this.model.getValueInRange(
        l,
        i ? 2 : 0
        /* TextDefined */
      ));
    return a.length === 1 ? a[0] : a;
  }
  getRichTextToCopy(e, t) {
    const i = this.model.getLanguageIdentifier();
    if (i.id === 1 || e.length !== 1)
      return null;
    let r = e[0];
    if (r.isEmpty()) {
      if (!t)
        return null;
      const c = r.startLineNumber;
      r = new V(c, this.model.getLineMinColumn(c), c, this.model.getLineMaxColumn(c));
    }
    const o = this._configuration.options.get(
      40
      /* fontInfo */
    ), s = this._getColorMap(), l = /[:;\\\/<>]/.test(o.fontFamily) || o.fontFamily === Ss.fontFamily;
    let u;
    return l ? u = Ss.fontFamily : (u = o.fontFamily, u = u.replace(/"/g, "'"), /[,']/.test(u) || /[+ ]/.test(u) && (u = `'${u}'`), u = `${u}, ${Ss.fontFamily}`), {
      mode: i.language,
      html: `<div style="color: ${s[
        1
        /* DefaultForeground */
      ]};background-color: ${s[
        2
        /* DefaultBackground */
      ]};font-family: ${u};font-weight: ${o.fontWeight};font-size: ${o.fontSize}px;line-height: ${o.lineHeight}px;white-space: pre;">` + this._getHTMLToCopy(r, s) + "</div>"
    };
  }
  _getHTMLToCopy(e, t) {
    const i = e.startLineNumber, r = e.startColumn, o = e.endLineNumber, s = e.endColumn, a = this.getTabSize();
    let l = "";
    for (let u = i; u <= o; u++) {
      const c = this.model.getLineTokens(u), h = c.getLineContent(), d = u === i ? r - 1 : 0, f = u === o ? s - 1 : h.length;
      h === "" ? l += "<br>" : l += fde(h, c.inflate(), t, d, f, a, Eo);
    }
    return l;
  }
  _getColorMap() {
    let e = ln.getColorMap(), t = ["#000000"];
    if (e)
      for (let i = 1, r = e.length; i < r; i++)
        t[i] = ee.Format.CSS.formatHex(e[i]);
    return t;
  }
  //#region model
  pushStackElement() {
    this.model.pushStackElement();
  }
  //#endregion
  //#region cursor operations
  getPrimaryCursorState() {
    return this._cursor.getPrimaryCursorState();
  }
  getLastAddedCursorIndex() {
    return this._cursor.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursor.getCursorStates();
  }
  setCursorStates(e, t, i) {
    this._withViewEventsCollector((r) => this._cursor.setStates(r, e, t, i));
  }
  getCursorColumnSelectData() {
    return this._cursor.getCursorColumnSelectData();
  }
  getCursorAutoClosedCharacters() {
    return this._cursor.getAutoClosedCharacters();
  }
  setCursorColumnSelectData(e) {
    this._cursor.setCursorColumnSelectData(e);
  }
  getPrevEditOperationType() {
    return this._cursor.getPrevEditOperationType();
  }
  setPrevEditOperationType(e) {
    this._cursor.setPrevEditOperationType(e);
  }
  getSelection() {
    return this._cursor.getSelection();
  }
  getSelections() {
    return this._cursor.getSelections();
  }
  getPosition() {
    return this._cursor.getPrimaryCursorState().modelState.position;
  }
  setSelections(e, t, i = 0) {
    this._withViewEventsCollector((r) => this._cursor.setSelections(r, e, t, i));
  }
  saveCursorState() {
    return this._cursor.saveState();
  }
  restoreCursorState(e) {
    this._withViewEventsCollector((t) => this._cursor.restoreState(t, e));
  }
  _executeCursorEdit(e) {
    if (this._cursor.context.cursorConfig.readOnly) {
      this._eventDispatcher.emitOutgoingEvent(new hde());
      return;
    }
    this._withViewEventsCollector(e);
  }
  executeEdits(e, t, i) {
    this._executeCursorEdit((r) => this._cursor.executeEdits(r, e, t, i));
  }
  startComposition() {
    this._cursor.setIsDoingComposition(!0), this._executeCursorEdit((e) => this._cursor.startComposition(e));
  }
  endComposition(e) {
    this._cursor.setIsDoingComposition(!1), this._executeCursorEdit((t) => this._cursor.endComposition(t, e));
  }
  type(e, t) {
    this._executeCursorEdit((i) => this._cursor.type(i, e, t));
  }
  compositionType(e, t, i, r, o) {
    this._executeCursorEdit((s) => this._cursor.compositionType(s, e, t, i, r, o));
  }
  paste(e, t, i, r) {
    this._executeCursorEdit((o) => this._cursor.paste(o, e, t, i, r));
  }
  cut(e) {
    this._executeCursorEdit((t) => this._cursor.cut(t, e));
  }
  executeCommand(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommand(i, e, t));
  }
  executeCommands(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommands(i, e, t));
  }
  revealPrimaryCursor(e, t) {
    this._withViewEventsCollector((i) => this._cursor.revealPrimary(
      i,
      e,
      t,
      0
      /* Smooth */
    ));
  }
  revealTopMostCursor(e) {
    const t = this._cursor.getTopMostViewPosition(), i = new V(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((r) => r.emitViewEvent(new hw(
      e,
      i,
      null,
      0,
      !0,
      0
      /* Smooth */
    )));
  }
  revealBottomMostCursor(e) {
    const t = this._cursor.getBottomMostViewPosition(), i = new V(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((r) => r.emitViewEvent(new hw(
      e,
      i,
      null,
      0,
      !0,
      0
      /* Smooth */
    )));
  }
  revealRange(e, t, i, r, o) {
    this._withViewEventsCollector((s) => s.emitViewEvent(new hw(e, i, null, r, t, o)));
  }
  //#endregion
  //#region viewLayout
  getVerticalOffsetForLineNumber(e) {
    return this.viewLayout.getVerticalOffsetForLineNumber(e);
  }
  getScrollTop() {
    return this.viewLayout.getCurrentScrollTop();
  }
  setScrollTop(e, t) {
    this.viewLayout.setScrollPosition({ scrollTop: e }, t);
  }
  setScrollPosition(e, t) {
    this.viewLayout.setScrollPosition(e, t);
  }
  deltaScrollNow(e, t) {
    this.viewLayout.deltaScrollNow(e, t);
  }
  changeWhitespace(e) {
    this.viewLayout.changeWhitespace(e) && (this._eventDispatcher.emitSingleViewEvent(new ade()), this._eventDispatcher.emitOutgoingEvent(new cde()));
  }
  setMaxLineWidth(e) {
    this.viewLayout.setMaxLineWidth(e);
  }
  //#endregion
  _withViewEventsCollector(e) {
    try {
      const t = this._eventDispatcher.beginEmitViewEvents();
      e(t);
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
  }
  normalizePosition(e, t) {
    return this._lines.normalizePosition(e, t);
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return this._lines.getLineIndentColumn(e);
  }
}
class s_ {
  constructor(...e) {
    this._entries = /* @__PURE__ */ new Map();
    for (let [t, i] of e)
      this.set(t, i);
  }
  set(e, t) {
    const i = this._entries.get(e);
    return this._entries.set(e, t), i;
  }
  has(e) {
    return this._entries.has(e);
  }
  get(e) {
    return this._entries.get(e);
  }
}
const Is = Vt("accessibilityService"), Ode = new it("accessibilityModeEnabled", !1);
class xde extends bg {
  constructor(e, t) {
    super(
      0
      /* NONE */
    );
    for (let i = 0; i < e.length; i++)
      this.set(
        e.charCodeAt(i),
        1
        /* BREAK_BEFORE */
      );
    for (let i = 0; i < t.length; i++)
      this.set(
        t.charCodeAt(i),
        2
        /* BREAK_AFTER */
      );
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : e >= 12352 && e <= 12543 || e >= 13312 && e <= 19903 || e >= 19968 && e <= 40959 ? 3 : this._map.get(e) || this._defaultValue;
  }
}
let GT = [], UT = [];
class lI {
  constructor(e, t) {
    this.classifier = new xde(e, t);
  }
  static create(e) {
    return new lI(e.get(
      117
      /* wordWrapBreakBeforeCharacters */
    ), e.get(
      116
      /* wordWrapBreakAfterCharacters */
    ));
  }
  createLineBreaksComputer(e, t, i, r) {
    t = t | 0, i = +i;
    let o = [], s = [];
    return {
      addRequest: (a, l) => {
        o.push(a), s.push(l);
      },
      finalize: () => {
        const a = e.typicalFullwidthCharacterWidth / e.typicalHalfwidthCharacterWidth;
        let l = [];
        for (let u = 0, c = o.length; u < c; u++) {
          const h = s[u];
          h ? l[u] = Nde(this.classifier, h, o[u], t, i, a, r) : l[u] = Ide(this.classifier, o[u], t, i, a, r);
        }
        return GT.length = 0, UT.length = 0, l;
      }
    };
  }
}
function Nde(n, e, t, i, r, o, s) {
  if (r === -1)
    return null;
  const a = t.length;
  if (a <= 1)
    return null;
  const l = e.breakOffsets, u = e.breakOffsetsVisibleColumn, c = I3(t, i, r, o, s), h = r - c;
  let d = GT, f = UT, p = 0, g = 0, _ = 0, m = r;
  const v = l.length;
  let C = 0;
  if (C >= 0) {
    let y = Math.abs(u[C] - m);
    for (; C + 1 < v; ) {
      const b = Math.abs(u[C + 1] - m);
      if (b >= y)
        break;
      y = b, C++;
    }
  }
  for (; C < v; ) {
    let y = C < 0 ? 0 : l[C], b = C < 0 ? 0 : u[C];
    g > y && (y = g, b = _);
    let L = 0, S = 0, E = 0, D = 0;
    if (b <= m) {
      let T = b, A = y === 0 ? 0 : t.charCodeAt(y - 1), P = y === 0 ? 0 : n.get(A), G = !0;
      for (let U = y; U < a; U++) {
        const $ = U, k = t.charCodeAt(U);
        let se, ne;
        if (jn(k) ? (U++, se = 0, ne = 2) : (se = n.get(k), ne = Cv(k, T, i, o)), $ > g && zT(A, P, k, se) && (L = $, S = T), T += ne, T > m) {
          $ > g ? (E = $, D = T - ne) : (E = U + 1, D = T), T - S > h && (L = 0), G = !1;
          break;
        }
        A = k, P = se;
      }
      if (G) {
        p > 0 && (d[p] = l[l.length - 1], f[p] = u[l.length - 1], p++);
        break;
      }
    }
    if (L === 0) {
      let T = b, A = t.charCodeAt(y), P = n.get(A), G = !1;
      for (let U = y - 1; U >= g; U--) {
        const $ = U + 1, k = t.charCodeAt(U);
        if (k === 9) {
          G = !0;
          break;
        }
        let se, ne;
        if (Gv(k) ? (U--, se = 0, ne = 2) : (se = n.get(k), ne = Xa(k) ? o : 1), T <= m) {
          if (E === 0 && (E = $, D = T), T <= m - h)
            break;
          if (zT(k, se, A, P)) {
            L = $, S = T;
            break;
          }
        }
        T -= ne, A = k, P = se;
      }
      if (L !== 0) {
        const U = h - (D - S);
        if (U <= i) {
          const $ = t.charCodeAt(E);
          let k;
          jn($) ? k = 2 : k = Cv($, D, i, o), U - k < 0 && (L = 0);
        }
      }
      if (G) {
        C--;
        continue;
      }
    }
    if (L === 0 && (L = E, S = D), L <= g) {
      const T = t.charCodeAt(g);
      jn(T) ? (L = g + 2, S = _ + 2) : (L = g + 1, S = _ + Cv(T, _, i, o));
    }
    for (g = L, d[p] = L, _ = S, f[p] = S, p++, m = S + h; C < 0 || C < v && u[C] < S; )
      C++;
    let O = Math.abs(u[C] - m);
    for (; C + 1 < v; ) {
      const T = Math.abs(u[C + 1] - m);
      if (T >= O)
        break;
      O = T, C++;
    }
  }
  return p === 0 ? null : (d.length = p, f.length = p, GT = e.breakOffsets, UT = e.breakOffsetsVisibleColumn, e.breakOffsets = d, e.breakOffsetsVisibleColumn = f, e.wrappedTextIndentLength = c, e);
}
function Ide(n, e, t, i, r, o) {
  if (i === -1)
    return null;
  const s = e.length;
  if (s <= 1)
    return null;
  const a = I3(e, t, i, r, o), l = i - a;
  let u = [], c = [], h = 0, d = 0, f = 0, p = i, g = e.charCodeAt(0), _ = n.get(g), m = Cv(g, 0, t, r), v = 1;
  jn(g) && (m += 1, g = e.charCodeAt(1), _ = n.get(g), v++);
  for (let C = v; C < s; C++) {
    const y = C, b = e.charCodeAt(C);
    let L, S;
    jn(b) ? (C++, L = 0, S = 2) : (L = n.get(b), S = Cv(b, m, t, r)), zT(g, _, b, L) && (d = y, f = m), m += S, m > p && ((d === 0 || m - f > l) && (d = y, f = m - S), u[h] = d, c[h] = f, h++, p = f + l, d = 0), g = b, _ = L;
  }
  return h === 0 ? null : (u[h] = s, c[h] = m, new Uh(u, c, a));
}
function Cv(n, e, t, i) {
  return n === 9 ? t - e % t : Xa(n) || n < 32 ? i : 1;
}
function I2(n, e) {
  return e - n % e;
}
function zT(n, e, t, i) {
  return t !== 32 && (e === 2 || e === 3 && i !== 2 || i === 1 || i === 3 && e !== 1);
}
function I3(n, e, t, i, r) {
  let o = 0;
  if (r !== 0) {
    const s = Es(n);
    if (s !== -1) {
      for (let l = 0; l < s; l++) {
        const u = n.charCodeAt(l) === 9 ? I2(o, e) : 1;
        o += u;
      }
      const a = r === 3 ? 2 : r === 2 ? 1 : 0;
      for (let l = 0; l < a; l++) {
        const u = I2(o, e);
        o += u;
      }
      o + i > t && (o = 0);
    }
  }
  return o;
}
var MD;
const FD = (MD = window.trustedTypes) === null || MD === void 0 ? void 0 : MD.createPolicy("domLineBreaksComputer", { createHTML: (n) => n });
class uI {
  static create() {
    return new uI();
  }
  constructor() {
  }
  createLineBreaksComputer(e, t, i, r) {
    t = t | 0, i = +i;
    let o = [];
    return {
      addRequest: (s, a) => {
        o.push(s);
      },
      finalize: () => Pde(o, e, t, i, r)
    };
  }
}
function Pde(n, e, t, i, r) {
  var o;
  if (i === -1) {
    const C = [];
    for (let y = 0, b = n.length; y < b; y++)
      C[y] = null;
    return C;
  }
  const s = Math.round(i * e.typicalHalfwidthCharacterWidth);
  (r === 2 || r === 3) && (r = 1);
  const a = document.createElement("div");
  io.applyFontInfoSlow(a, e);
  const l = zp(1e4), u = [], c = [], h = [], d = [], f = [];
  for (let C = 0; C < n.length; C++) {
    const y = n[C];
    let b = 0, L = 0, S = s;
    if (r !== 0)
      if (b = Es(y), b === -1)
        b = 0;
      else {
        for (let T = 0; T < b; T++) {
          const A = y.charCodeAt(T) === 9 ? t - L % t : 1;
          L += A;
        }
        const O = Math.ceil(e.spaceWidth * L);
        O + e.typicalFullwidthCharacterWidth > s ? (b = 0, L = 0) : S = s - O;
      }
    const E = y.substr(b), D = Ade(E, L, t, S, l);
    u[C] = b, c[C] = L, h[C] = E, d[C] = D[0], f[C] = D[1];
  }
  const p = l.build(), g = (o = FD == null ? void 0 : FD.createHTML(p)) !== null && o !== void 0 ? o : p;
  a.innerHTML = g, a.style.position = "absolute", a.style.top = "10000", a.style.wordWrap = "break-word", document.body.appendChild(a);
  let _ = document.createRange();
  const m = Array.prototype.slice.call(a.children, 0);
  let v = [];
  for (let C = 0; C < n.length; C++) {
    const y = m[C], b = Mde(_, y, h[C], d[C]);
    if (b === null) {
      v[C] = null;
      continue;
    }
    const L = u[C], S = c[C], E = f[C], D = [];
    for (let O = 0, T = b.length; O < T; O++)
      D[O] = E[b[O]];
    if (L !== 0)
      for (let O = 0, T = b.length; O < T; O++)
        b[O] += L;
    v[C] = new Uh(b, D, S);
  }
  return document.body.removeChild(a), v;
}
function Ade(n, e, t, i, r) {
  r.appendASCIIString('<div style="width:'), r.appendASCIIString(String(i)), r.appendASCIIString('px;">');
  const o = n.length;
  let s = e, a = 0, l = [], u = [], c = 0 < o ? n.charCodeAt(0) : 0;
  r.appendASCIIString("<span>");
  for (let h = 0; h < o; h++) {
    h !== 0 && h % 16384 === 0 && r.appendASCIIString("</span><span>"), l[h] = a, u[h] = s;
    const d = c;
    c = h + 1 < o ? n.charCodeAt(h + 1) : 0;
    let f = 1, p = 1;
    switch (d) {
      case 9:
        f = t - s % t, p = f;
        for (let g = 1; g <= f; g++)
          g < f ? r.write1(160) : r.appendASCII(
            32
            /* Space */
          );
        break;
      case 32:
        c === 32 ? r.write1(160) : r.appendASCII(
          32
          /* Space */
        );
        break;
      case 60:
        r.appendASCIIString("&lt;");
        break;
      case 62:
        r.appendASCIIString("&gt;");
        break;
      case 38:
        r.appendASCIIString("&amp;");
        break;
      case 0:
        r.appendASCIIString("&#00;");
        break;
      case 65279:
      case 8232:
      case 8233:
      case 133:
        r.write1(65533);
        break;
      default:
        Xa(d) && p++, d < 32 ? r.write1(9216 + d) : r.write1(d);
    }
    a += f, s += p;
  }
  return r.appendASCIIString("</span>"), l[n.length] = a, u[n.length] = s, r.appendASCIIString("</div>"), [l, u];
}
function Mde(n, e, t, i) {
  if (t.length <= 1)
    return null;
  const r = Array.prototype.slice.call(e.children, 0), o = [];
  try {
    jT(n, r, i, 0, null, t.length - 1, null, o);
  } catch (s) {
    return console.log(s), null;
  }
  return o.length === 0 ? null : (o.push(t.length), o);
}
function jT(n, e, t, i, r, o, s, a) {
  if (i === o || (r = r || kD(n, e, t[i], t[i + 1]), s = s || kD(n, e, t[o], t[o + 1]), Math.abs(r[0].top - s[0].top) <= 0.1))
    return;
  if (i + 1 === o) {
    a.push(o);
    return;
  }
  const l = i + (o - i) / 2 | 0, u = kD(n, e, t[l], t[l + 1]);
  jT(n, e, t, i, r, l, u, a), jT(n, e, t, l, u, o, s, a);
}
function kD(n, e, t, i) {
  return n.setStart(
    e[t / 16384 | 0].firstChild,
    t % 16384
    /* SPAN_MODULO_LIMIT */
  ), n.setEnd(
    e[i / 16384 | 0].firstChild,
    i % 16384
    /* SPAN_MODULO_LIMIT */
  ), n.getClientRects();
}
var Fde = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Ah = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let kde = 0, Wde = class {
  constructor(e, t, i, r, o) {
    this.model = e, this.viewModel = t, this.view = i, this.hasRealView = r, this.listenersToRemove = o;
  }
  dispose() {
    yi(this.listenersToRemove), this.model.onBeforeDetached(), this.hasRealView && this.view.dispose(), this.viewModel.dispose();
  }
}, Kb = class dw extends ge {
  constructor(e, t, i, r, o, s, a, l, u, c) {
    super(), this._onDidDispose = this._register(new j()), this.onDidDispose = this._onDidDispose.event, this._onDidChangeModelContent = this._register(new j()), this.onDidChangeModelContent = this._onDidChangeModelContent.event, this._onDidChangeModelLanguage = this._register(new j()), this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event, this._onDidChangeModelLanguageConfiguration = this._register(new j()), this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event, this._onDidChangeModelOptions = this._register(new j()), this.onDidChangeModelOptions = this._onDidChangeModelOptions.event, this._onDidChangeModelDecorations = this._register(new j()), this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event, this._onDidChangeConfiguration = this._register(new j()), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._onDidChangeModel = this._register(new j()), this.onDidChangeModel = this._onDidChangeModel.event, this._onDidChangeCursorPosition = this._register(new j()), this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event, this._onDidChangeCursorSelection = this._register(new j()), this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event, this._onDidAttemptReadOnlyEdit = this._register(new j()), this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event, this._onDidLayoutChange = this._register(new j()), this.onDidLayoutChange = this._onDidLayoutChange.event, this._editorTextFocus = this._register(new P2()), this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue, this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse, this._editorWidgetFocus = this._register(new P2()), this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue, this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse, this._onWillType = this._register(new j()), this.onWillType = this._onWillType.event, this._onDidType = this._register(new j()), this.onDidType = this._onDidType.event, this._onDidCompositionStart = this._register(new j()), this.onDidCompositionStart = this._onDidCompositionStart.event, this._onDidCompositionEnd = this._register(new j()), this.onDidCompositionEnd = this._onDidCompositionEnd.event, this._onDidPaste = this._register(new j()), this.onDidPaste = this._onDidPaste.event, this._onMouseUp = this._register(new j()), this.onMouseUp = this._onMouseUp.event, this._onMouseDown = this._register(new j()), this.onMouseDown = this._onMouseDown.event, this._onMouseDrag = this._register(new j()), this.onMouseDrag = this._onMouseDrag.event, this._onMouseDrop = this._register(new j()), this.onMouseDrop = this._onMouseDrop.event, this._onMouseDropCanceled = this._register(new j()), this.onMouseDropCanceled = this._onMouseDropCanceled.event, this._onContextMenu = this._register(new j()), this.onContextMenu = this._onContextMenu.event, this._onMouseMove = this._register(new j()), this.onMouseMove = this._onMouseMove.event, this._onMouseLeave = this._register(new j()), this.onMouseLeave = this._onMouseLeave.event, this._onMouseWheel = this._register(new j()), this.onMouseWheel = this._onMouseWheel.event, this._onKeyUp = this._register(new j()), this.onKeyUp = this._onKeyUp.event, this._onKeyDown = this._register(new j()), this.onKeyDown = this._onKeyDown.event, this._onDidContentSizeChange = this._register(new j()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._onDidScrollChange = this._register(new j()), this.onDidScrollChange = this._onDidScrollChange.event, this._onDidChangeViewZones = this._register(new j()), this.onDidChangeViewZones = this._onDidChangeViewZones.event;
    const h = Object.assign({}, t);
    this._domElement = e, this._overflowWidgetsDomNode = h.overflowWidgetsDomNode, delete h.overflowWidgetsDomNode, this._id = ++kde, this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes = {}, this.isSimpleWidget = i.isSimpleWidget || !1, this._telemetryData = i.telemetryData, this._configuration = this._register(this._createConfiguration(h, c)), this._register(this._configuration.onDidChange((f) => {
      this._onDidChangeConfiguration.fire(f);
      const p = this._configuration.options;
      if (f.hasChanged(
        128
        /* layoutInfo */
      )) {
        const g = p.get(
          128
          /* layoutInfo */
        );
        this._onDidLayoutChange.fire(g);
      }
    })), this._contextKeyService = this._register(a.createScoped(this._domElement)), this._notificationService = u, this._codeEditorService = o, this._commandService = s, this._themeService = l, this._register(new Vde(this, this._contextKeyService)), this._register(new Bde(this, this._contextKeyService)), this._instantiationService = r.createChild(new s_([Ti, this._contextKeyService])), this._modelData = null, this._contributions = {}, this._actions = {}, this._focusTracker = new Hde(e), this._focusTracker.onChange(() => {
      this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());
    }), this._contentWidgets = {}, this._overlayWidgets = {};
    let d;
    Array.isArray(i.contributions) ? d = i.contributions : d = _p.getEditorContributions();
    for (const f of d) {
      if (this._contributions[f.id]) {
        Ni(new Error(`Cannot have two contributions with the same id ${f.id}`));
        continue;
      }
      try {
        const p = this._instantiationService.createInstance(f.ctor, this);
        this._contributions[f.id] = p;
      } catch (p) {
        Ni(p);
      }
    }
    _p.getEditorActions().forEach((f) => {
      if (this._actions[f.id]) {
        Ni(new Error(`Cannot have two actions with the same id ${f.id}`));
        return;
      }
      const p = new x3(f.id, f.label, f.alias, Kf(f.precondition), () => this._instantiationService.invokeFunction((g) => Promise.resolve(f.runEditorCommand(g, this, null))), this._contextKeyService);
      this._actions[p.id] = p;
    }), this._codeEditorService.addCodeEditor(this);
  }
  _createConfiguration(e, t) {
    return new io(this.isSimpleWidget, e, this._domElement, t);
  }
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return B_.ICodeEditor;
  }
  dispose() {
    this._codeEditorService.removeCodeEditor(this), this._focusTracker.dispose();
    const e = Object.keys(this._contributions);
    for (let t = 0, i = e.length; t < i; t++) {
      const r = e[t];
      this._contributions[r].dispose();
    }
    this._contributions = {}, this._actions = {}, this._contentWidgets = {}, this._overlayWidgets = {}, this._removeDecorationTypes(), this._postDetachModelCleanup(this._detachModel()), this._onDidDispose.fire(), super.dispose();
  }
  invokeWithinContext(e) {
    return this._instantiationService.invokeFunction(e);
  }
  updateOptions(e) {
    this._configuration.updateOptions(e);
  }
  getOptions() {
    return this._configuration.options;
  }
  getOption(e) {
    return this._configuration.options.get(e);
  }
  getRawOptions() {
    return this._configuration.getRawOptions();
  }
  getOverflowWidgetsDomNode() {
    return this._overflowWidgetsDomNode;
  }
  getConfiguredWordAtPosition(e) {
    return this._modelData ? Ot.getWordAtPosition(this._modelData.model, this._configuration.options.get(
      114
      /* wordSeparators */
    ), e) : null;
  }
  getValue(e = null) {
    if (!this._modelData)
      return "";
    const t = !!(e && e.preserveBOM);
    let i = 0;
    return e && e.lineEnding && e.lineEnding === `
` ? i = 1 : e && e.lineEnding && e.lineEnding === `\r
` && (i = 2), this._modelData.model.getValue(i, t);
  }
  setValue(e) {
    this._modelData && this._modelData.model.setValue(e);
  }
  getModel() {
    return this._modelData ? this._modelData.model : null;
  }
  setModel(e = null) {
    const t = e;
    if (this._modelData === null && t === null || this._modelData && this._modelData.model === t)
      return;
    const i = this.hasTextFocus(), r = this._detachModel();
    this._attachModel(t), i && this.hasModel() && this.focus();
    const o = {
      oldModelUrl: r ? r.uri : null,
      newModelUrl: t ? t.uri : null
    };
    this._removeDecorationTypes(), this._onDidChangeModel.fire(o), this._postDetachModelCleanup(r);
  }
  _removeDecorationTypes() {
    if (this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes) {
      for (let e in this._decorationTypeSubtypes) {
        const t = this._decorationTypeSubtypes[e];
        for (let i in t)
          this._removeDecorationType(e + "-" + i);
      }
      this._decorationTypeSubtypes = {};
    }
  }
  getVisibleRanges() {
    return this._modelData ? this._modelData.viewModel.getVisibleRanges() : [];
  }
  getVisibleRangesPlusViewportAboveBelow() {
    return this._modelData ? this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow() : [];
  }
  getWhitespaces() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getWhitespaces() : [];
  }
  static _getVerticalOffsetForPosition(e, t, i) {
    const r = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), o = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(r);
    return e.viewModel.viewLayout.getVerticalOffsetForLineNumber(o.lineNumber);
  }
  getTopForLineNumber(e) {
    return this._modelData ? dw._getVerticalOffsetForPosition(this._modelData, e, 1) : -1;
  }
  getTopForPosition(e, t) {
    return this._modelData ? dw._getVerticalOffsetForPosition(this._modelData, e, t) : -1;
  }
  setHiddenAreas(e) {
    this._modelData && this._modelData.viewModel.setHiddenAreas(e.map((t) => V.lift(t)));
  }
  getVisibleColumnFromPosition(e) {
    if (!this._modelData)
      return e.column;
    const t = this._modelData.model.validatePosition(e), i = this._modelData.model.getOptions().tabSize;
    return Kt.visibleColumnFromColumn(this._modelData.model.getLineContent(t.lineNumber), t.column, i) + 1;
  }
  getPosition() {
    return this._modelData ? this._modelData.viewModel.getPosition() : null;
  }
  setPosition(e) {
    if (this._modelData) {
      if (!J.isIPosition(e))
        throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections("api", [{
        selectionStartLineNumber: e.lineNumber,
        selectionStartColumn: e.column,
        positionLineNumber: e.lineNumber,
        positionColumn: e.column
      }]);
    }
  }
  _sendRevealRange(e, t, i, r) {
    if (!this._modelData)
      return;
    if (!V.isIRange(e))
      throw new Error("Invalid arguments");
    const o = this._modelData.model.validateRange(e), s = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(o);
    this._modelData.viewModel.revealRange("api", i, s, t, r);
  }
  revealLine(e, t = 0) {
    this._revealLine(e, 0, t);
  }
  revealLineInCenter(e, t = 0) {
    this._revealLine(e, 1, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._revealLine(e, 2, t);
  }
  revealLineNearTop(e, t = 0) {
    this._revealLine(e, 5, t);
  }
  _revealLine(e, t, i) {
    if (typeof e != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new V(e, 1, e, 1), t, !1, i);
  }
  revealPosition(e, t = 0) {
    this._revealPosition(e, 0, !0, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._revealPosition(e, 1, !0, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._revealPosition(e, 2, !0, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._revealPosition(e, 5, !0, t);
  }
  _revealPosition(e, t, i, r) {
    if (!J.isIPosition(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(new V(e.lineNumber, e.column, e.lineNumber, e.column), t, i, r);
  }
  getSelection() {
    return this._modelData ? this._modelData.viewModel.getSelection() : null;
  }
  getSelections() {
    return this._modelData ? this._modelData.viewModel.getSelections() : null;
  }
  setSelection(e) {
    const t = Ut.isISelection(e), i = V.isIRange(e);
    if (!t && !i)
      throw new Error("Invalid arguments");
    if (t)
      this._setSelectionImpl(e);
    else if (i) {
      const r = {
        selectionStartLineNumber: e.startLineNumber,
        selectionStartColumn: e.startColumn,
        positionLineNumber: e.endLineNumber,
        positionColumn: e.endColumn
      };
      this._setSelectionImpl(r);
    }
  }
  _setSelectionImpl(e) {
    if (!this._modelData)
      return;
    const t = new Ut(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
    this._modelData.viewModel.setSelections("api", [t]);
  }
  revealLines(e, t, i = 0) {
    this._revealLines(e, t, 0, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._revealLines(e, t, 1, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._revealLines(e, t, 2, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._revealLines(e, t, 5, i);
  }
  _revealLines(e, t, i, r) {
    if (typeof e != "number" || typeof t != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new V(e, 1, t, 1), i, !1, r);
  }
  revealRange(e, t = 0, i = !1, r = !0) {
    this._revealRange(e, i ? 1 : 0, r, t);
  }
  revealRangeInCenter(e, t = 0) {
    this._revealRange(e, 1, !0, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 2, !0, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._revealRange(e, 5, !0, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 6, !0, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._revealRange(e, 3, !0, t);
  }
  _revealRange(e, t, i, r) {
    if (!V.isIRange(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(V.lift(e), t, i, r);
  }
  setSelections(e, t = "api", i = 0) {
    if (this._modelData) {
      if (!e || e.length === 0)
        throw new Error("Invalid arguments");
      for (let r = 0, o = e.length; r < o; r++)
        if (!Ut.isISelection(e[r]))
          throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, e, i);
    }
  }
  getContentWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentWidth() : -1;
  }
  getScrollWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollWidth() : -1;
  }
  getScrollLeft() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollLeft() : -1;
  }
  getContentHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentHeight() : -1;
  }
  getScrollHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollHeight() : -1;
  }
  getScrollTop() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollTop() : -1;
  }
  setScrollLeft(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.setScrollPosition({
        scrollLeft: e
      }, t);
    }
  }
  setScrollTop(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.setScrollPosition({
        scrollTop: e
      }, t);
    }
  }
  setScrollPosition(e, t = 1) {
    this._modelData && this._modelData.viewModel.setScrollPosition(e, t);
  }
  saveViewState() {
    if (!this._modelData)
      return null;
    const e = {}, t = Object.keys(this._contributions);
    for (const o of t) {
      const s = this._contributions[o];
      typeof s.saveViewState == "function" && (e[o] = s.saveViewState());
    }
    const i = this._modelData.viewModel.saveCursorState(), r = this._modelData.viewModel.saveState();
    return {
      cursorState: i,
      viewState: r,
      contributionsState: e
    };
  }
  restoreViewState(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return;
    const t = e;
    if (t && t.cursorState && t.viewState) {
      const i = t.cursorState;
      Array.isArray(i) ? this._modelData.viewModel.restoreCursorState(i) : this._modelData.viewModel.restoreCursorState([i]);
      const r = t.contributionsState || {}, o = Object.keys(this._contributions);
      for (let a = 0, l = o.length; a < l; a++) {
        const u = o[a], c = this._contributions[u];
        typeof c.restoreViewState == "function" && c.restoreViewState(r[u]);
      }
      const s = this._modelData.viewModel.reduceRestoreState(t.viewState);
      this._modelData.view.restoreState(s);
    }
  }
  getContribution(e) {
    return this._contributions[e] || null;
  }
  getActions() {
    const e = [], t = Object.keys(this._actions);
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      e.push(this._actions[o]);
    }
    return e;
  }
  getSupportedActions() {
    let e = this.getActions();
    return e = e.filter((t) => t.isSupported()), e;
  }
  getAction(e) {
    return this._actions[e] || null;
  }
  trigger(e, t, i) {
    switch (i = i || {}, t) {
      case "compositionStart":
        this._startComposition();
        return;
      case "compositionEnd":
        this._endComposition(e);
        return;
      case "type": {
        const o = i;
        this._type(e, o.text || "");
        return;
      }
      case "replacePreviousChar": {
        const o = i;
        this._compositionType(e, o.text || "", o.replaceCharCnt || 0, 0, 0);
        return;
      }
      case "compositionType": {
        const o = i;
        this._compositionType(e, o.text || "", o.replacePrevCharCnt || 0, o.replaceNextCharCnt || 0, o.positionDelta || 0);
        return;
      }
      case "paste": {
        const o = i;
        this._paste(e, o.text || "", o.pasteOnNewLine || !1, o.multicursorText || null, o.mode || null);
        return;
      }
      case "cut":
        this._cut(e);
        return;
    }
    const r = this.getAction(t);
    if (r) {
      Promise.resolve(r.run()).then(void 0, Ni);
      return;
    }
    this._modelData && (this._triggerEditorCommand(e, t, i) || this._triggerCommand(t, i));
  }
  _triggerCommand(e, t) {
    this._commandService.executeCommand(e, t);
  }
  _startComposition() {
    this._modelData && (this._modelData.viewModel.startComposition(), this._onDidCompositionStart.fire());
  }
  _endComposition(e) {
    this._modelData && (this._modelData.viewModel.endComposition(e), this._onDidCompositionEnd.fire());
  }
  _type(e, t) {
    !this._modelData || t.length === 0 || (e === "keyboard" && this._onWillType.fire(t), this._modelData.viewModel.type(t, e), e === "keyboard" && this._onDidType.fire(t));
  }
  _compositionType(e, t, i, r, o) {
    this._modelData && this._modelData.viewModel.compositionType(t, i, r, o, e);
  }
  _paste(e, t, i, r, o) {
    if (!this._modelData || t.length === 0)
      return;
    const s = this._modelData.viewModel.getSelection().getStartPosition();
    this._modelData.viewModel.paste(t, i, r, e);
    const a = this._modelData.viewModel.getSelection().getStartPosition();
    e === "keyboard" && this._onDidPaste.fire({
      range: new V(s.lineNumber, s.column, a.lineNumber, a.column),
      mode: o
    });
  }
  _cut(e) {
    this._modelData && this._modelData.viewModel.cut(e);
  }
  _triggerEditorCommand(e, t, i) {
    const r = _p.getEditorCommand(t);
    return r ? (i = i || {}, i.source = e, this._instantiationService.invokeFunction((o) => {
      Promise.resolve(r.runEditorCommand(o, this, i)).then(void 0, Ni);
    }), !0) : !1;
  }
  _getViewModel() {
    return this._modelData ? this._modelData.viewModel : null;
  }
  pushUndoStop() {
    return !this._modelData || this._configuration.options.get(
      78
      /* readOnly */
    ) ? !1 : (this._modelData.model.pushStackElement(), !0);
  }
  popUndoStop() {
    return !this._modelData || this._configuration.options.get(
      78
      /* readOnly */
    ) ? !1 : (this._modelData.model.popStackElement(), !0);
  }
  executeEdits(e, t, i) {
    if (!this._modelData || this._configuration.options.get(
      78
      /* readOnly */
    ))
      return !1;
    let r;
    return i ? Array.isArray(i) ? r = () => i : r = i : r = () => null, this._modelData.viewModel.executeEdits(e, t, r), !0;
  }
  executeCommand(e, t) {
    this._modelData && this._modelData.viewModel.executeCommand(t, e);
  }
  executeCommands(e, t) {
    this._modelData && this._modelData.viewModel.executeCommands(t, e);
  }
  changeDecorations(e) {
    return this._modelData ? this._modelData.model.changeDecorations(e, this._id) : null;
  }
  getLineDecorations(e) {
    return this._modelData ? this._modelData.model.getLineDecorations(e, this._id, rN(this._configuration.options)) : null;
  }
  deltaDecorations(e, t) {
    return this._modelData ? e.length === 0 && t.length === 0 ? e : this._modelData.model.deltaDecorations(e, t, this._id) : [];
  }
  removeDecorations(e) {
    const t = this._decorationTypeKeysToIds[e];
    t && this.deltaDecorations(t, []), this._decorationTypeKeysToIds.hasOwnProperty(e) && delete this._decorationTypeKeysToIds[e], this._decorationTypeSubtypes.hasOwnProperty(e) && delete this._decorationTypeSubtypes[e];
  }
  getLayoutInfo() {
    return this._configuration.options.get(
      128
      /* layoutInfo */
    );
  }
  createOverviewRuler(e) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.createOverviewRuler(e);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getDomNode() {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.domNode.domNode;
  }
  delegateVerticalScrollbarMouseDown(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateVerticalScrollbarMouseDown(e);
  }
  layout(e) {
    this._configuration.observeReferenceElement(e), this.render();
  }
  focus() {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.focus();
  }
  hasTextFocus() {
    return !this._modelData || !this._modelData.hasRealView ? !1 : this._modelData.view.isFocused();
  }
  hasWidgetFocus() {
    return this._focusTracker && this._focusTracker.hasFocus();
  }
  addContentWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._contentWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a content widget with the same id."), this._contentWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addContentWidget(t);
  }
  layoutContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutContentWidget(i);
    }
  }
  removeContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      delete this._contentWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeContentWidget(i);
    }
  }
  addOverlayWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._overlayWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting an overlay widget with the same id."), this._overlayWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addOverlayWidget(t);
  }
  layoutOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutOverlayWidget(i);
    }
  }
  removeOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      delete this._overlayWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeOverlayWidget(i);
    }
  }
  changeViewZones(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.change(e);
  }
  getTargetAtClientPoint(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.getTargetAtClientPoint(e, t);
  }
  getScrolledVisiblePosition(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return null;
    const t = this._modelData.model.validatePosition(e), i = this._configuration.options, r = i.get(
      128
      /* layoutInfo */
    ), o = dw._getVerticalOffsetForPosition(this._modelData, t.lineNumber, t.column) - this.getScrollTop(), s = this._modelData.view.getOffsetForColumn(t.lineNumber, t.column) + r.glyphMarginWidth + r.lineNumbersWidth + r.decorationsWidth - this.getScrollLeft();
    return {
      top: o,
      left: s,
      height: i.get(
        56
        /* lineHeight */
      )
    };
  }
  getOffsetForColumn(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? -1 : this._modelData.view.getOffsetForColumn(e, t);
  }
  render(e = !1) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.render(!0, e);
  }
  setAriaOptions(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.setAriaOptions(e);
  }
  applyFontInfo(e) {
    io.applyFontInfoSlow(e, this._configuration.options.get(
      40
      /* fontInfo */
    ));
  }
  _attachModel(e) {
    if (!e) {
      this._modelData = null;
      return;
    }
    const t = [];
    this._domElement.setAttribute("data-mode-id", e.getLanguageIdentifier().language), this._configuration.setIsDominatedByLongLines(e.isDominatedByLongLines()), this._configuration.setMaxLineNumber(e.getLineCount()), e.onBeforeAttached();
    const i = new Tde(this._id, this._configuration, e, uI.create(), lI.create(this._configuration.options), (s) => zl(s));
    t.push(e.onDidChangeDecorations((s) => this._onDidChangeModelDecorations.fire(s))), t.push(e.onDidChangeLanguage((s) => {
      this._domElement.setAttribute("data-mode-id", e.getLanguageIdentifier().language), this._onDidChangeModelLanguage.fire(s);
    })), t.push(e.onDidChangeLanguageConfiguration((s) => this._onDidChangeModelLanguageConfiguration.fire(s))), t.push(e.onDidChangeContent((s) => this._onDidChangeModelContent.fire(s))), t.push(e.onDidChangeOptions((s) => this._onDidChangeModelOptions.fire(s))), t.push(e.onWillDispose(() => this.setModel(null))), t.push(i.onEvent((s) => {
      switch (s.kind) {
        case 0:
          this._onDidContentSizeChange.fire(s);
          break;
        case 1:
          this._editorTextFocus.setValue(s.hasFocus);
          break;
        case 2:
          this._onDidScrollChange.fire(s);
          break;
        case 3:
          this._onDidChangeViewZones.fire();
          break;
        case 4:
          this._onDidAttemptReadOnlyEdit.fire();
          break;
        case 5: {
          s.reachedMaxCursorCount && this._notificationService.warn(w("cursors.maximum", "The number of cursors has been limited to {0}.", Zp.MAX_CURSOR_COUNT));
          const a = [];
          for (let c = 0, h = s.selections.length; c < h; c++)
            a[c] = s.selections[c].getPosition();
          const l = {
            position: a[0],
            secondaryPositions: a.slice(1),
            reason: s.reason,
            source: s.source
          };
          this._onDidChangeCursorPosition.fire(l);
          const u = {
            selection: s.selections[0],
            secondarySelections: s.selections.slice(1),
            modelVersionId: s.modelVersionId,
            oldSelections: s.oldSelections,
            oldModelVersionId: s.oldModelVersionId,
            source: s.source,
            reason: s.reason
          };
          this._onDidChangeCursorSelection.fire(u);
          break;
        }
      }
    }));
    const [r, o] = this._createView(i);
    if (o) {
      this._domElement.appendChild(r.domNode.domNode);
      let s = Object.keys(this._contentWidgets);
      for (let a = 0, l = s.length; a < l; a++) {
        const u = s[a];
        r.addContentWidget(this._contentWidgets[u]);
      }
      s = Object.keys(this._overlayWidgets);
      for (let a = 0, l = s.length; a < l; a++) {
        const u = s[a];
        r.addOverlayWidget(this._overlayWidgets[u]);
      }
      r.render(!1, !0), r.domNode.domNode.setAttribute("data-uri", e.uri.toString());
    }
    this._modelData = new Wde(e, i, r, o, t);
  }
  _createView(e) {
    let t;
    this.isSimpleWidget ? t = {
      paste: (o, s, a, l) => {
        this._paste("keyboard", o, s, a, l);
      },
      type: (o) => {
        this._type("keyboard", o);
      },
      compositionType: (o, s, a, l) => {
        this._compositionType("keyboard", o, s, a, l);
      },
      startComposition: () => {
        this._startComposition();
      },
      endComposition: () => {
        this._endComposition("keyboard");
      },
      cut: () => {
        this._cut("keyboard");
      }
    } : t = {
      paste: (o, s, a, l) => {
        const u = { text: o, pasteOnNewLine: s, multicursorText: a, mode: l };
        this._commandService.executeCommand("paste", u);
      },
      type: (o) => {
        const s = { text: o };
        this._commandService.executeCommand("type", s);
      },
      compositionType: (o, s, a, l) => {
        if (a || l) {
          const u = { text: o, replacePrevCharCnt: s, replaceNextCharCnt: a, positionDelta: l };
          this._commandService.executeCommand("compositionType", u);
        } else {
          const u = { text: o, replaceCharCnt: s };
          this._commandService.executeCommand("replacePreviousChar", u);
        }
      },
      startComposition: () => {
        this._commandService.executeCommand("compositionStart", {});
      },
      endComposition: () => {
        this._commandService.executeCommand("compositionEnd", {});
      },
      cut: () => {
        this._commandService.executeCommand("cut", {});
      }
    };
    const i = new b0(e.coordinatesConverter);
    return i.onKeyDown = (o) => this._onKeyDown.fire(o), i.onKeyUp = (o) => this._onKeyUp.fire(o), i.onContextMenu = (o) => this._onContextMenu.fire(o), i.onMouseMove = (o) => this._onMouseMove.fire(o), i.onMouseLeave = (o) => this._onMouseLeave.fire(o), i.onMouseDown = (o) => this._onMouseDown.fire(o), i.onMouseUp = (o) => this._onMouseUp.fire(o), i.onMouseDrag = (o) => this._onMouseDrag.fire(o), i.onMouseDrop = (o) => this._onMouseDrop.fire(o), i.onMouseDropCanceled = (o) => this._onMouseDropCanceled.fire(o), i.onMouseWheel = (o) => this._onMouseWheel.fire(o), [new Yhe(t, this._configuration, this._themeService, e, i, this._overflowWidgetsDomNode), !0];
  }
  _postDetachModelCleanup(e) {
    e && e.removeAllDecorationsWithOwnerId(this._id);
  }
  _detachModel() {
    if (!this._modelData)
      return null;
    const e = this._modelData.model, t = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;
    return this._modelData.dispose(), this._modelData = null, this._domElement.removeAttribute("data-mode-id"), t && this._domElement.contains(t) && this._domElement.removeChild(t), e;
  }
  _removeDecorationType(e) {
    this._codeEditorService.removeDecorationType(e);
  }
  hasModel() {
    return this._modelData !== null;
  }
};
Kb = Fde([
  Ah(3, eo),
  Ah(4, pr),
  Ah(5, Ko),
  Ah(6, Ti),
  Ah(7, Qn),
  Ah(8, tl),
  Ah(9, Is)
], Kb);
class P2 extends ge {
  constructor() {
    super(), this._onDidChangeToTrue = this._register(new j()), this.onDidChangeToTrue = this._onDidChangeToTrue.event, this._onDidChangeToFalse = this._register(new j()), this.onDidChangeToFalse = this._onDidChangeToFalse.event, this._value = 0;
  }
  setValue(e) {
    const t = e ? 2 : 1;
    this._value !== t && (this._value = t, this._value === 2 ? this._onDidChangeToTrue.fire() : this._value === 1 && this._onDidChangeToFalse.fire());
  }
}
class Vde extends ge {
  constructor(e, t) {
    super(), this._editor = e, t.createKey("editorId", e.getId()), this._editorSimpleInput = Le.editorSimpleInput.bindTo(t), this._editorFocus = Le.focus.bindTo(t), this._textInputFocus = Le.textInputFocus.bindTo(t), this._editorTextFocus = Le.editorTextFocus.bindTo(t), this._editorTabMovesFocus = Le.tabMovesFocus.bindTo(t), this._editorReadonly = Le.readOnly.bindTo(t), this._inDiffEditor = Le.inDiffEditor.bindTo(t), this._editorColumnSelection = Le.columnSelection.bindTo(t), this._hasMultipleSelections = Le.hasMultipleSelections.bindTo(t), this._hasNonEmptySelection = Le.hasNonEmptySelection.bindTo(t), this._canUndo = Le.canUndo.bindTo(t), this._canRedo = Le.canRedo.bindTo(t), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig())), this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection())), this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidChangeModel(() => this._updateFromModel())), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel())), this._updateFromConfig(), this._updateFromSelection(), this._updateFromFocus(), this._updateFromModel(), this._editorSimpleInput.set(this._editor.isSimpleWidget);
  }
  _updateFromConfig() {
    const e = this._editor.getOptions();
    this._editorTabMovesFocus.set(e.get(
      127
      /* tabFocusMode */
    )), this._editorReadonly.set(e.get(
      78
      /* readOnly */
    )), this._inDiffEditor.set(e.get(
      51
      /* inDiffEditor */
    )), this._editorColumnSelection.set(e.get(
      16
      /* columnSelection */
    ));
  }
  _updateFromSelection() {
    const e = this._editor.getSelections();
    e ? (this._hasMultipleSelections.set(e.length > 1), this._hasNonEmptySelection.set(e.some((t) => !t.isEmpty()))) : (this._hasMultipleSelections.reset(), this._hasNonEmptySelection.reset());
  }
  _updateFromFocus() {
    this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget), this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget), this._textInputFocus.set(this._editor.hasTextFocus());
  }
  _updateFromModel() {
    const e = this._editor.getModel();
    this._canUndo.set(!!(e && e.canUndo())), this._canRedo.set(!!(e && e.canRedo()));
  }
}
class Bde extends ge {
  constructor(e, t) {
    super(), this._editor = e, this._contextKeyService = t, this._langId = Le.languageId.bindTo(t), this._hasCompletionItemProvider = Le.hasCompletionItemProvider.bindTo(t), this._hasCodeActionsProvider = Le.hasCodeActionsProvider.bindTo(t), this._hasCodeLensProvider = Le.hasCodeLensProvider.bindTo(t), this._hasDefinitionProvider = Le.hasDefinitionProvider.bindTo(t), this._hasDeclarationProvider = Le.hasDeclarationProvider.bindTo(t), this._hasImplementationProvider = Le.hasImplementationProvider.bindTo(t), this._hasTypeDefinitionProvider = Le.hasTypeDefinitionProvider.bindTo(t), this._hasHoverProvider = Le.hasHoverProvider.bindTo(t), this._hasDocumentHighlightProvider = Le.hasDocumentHighlightProvider.bindTo(t), this._hasDocumentSymbolProvider = Le.hasDocumentSymbolProvider.bindTo(t), this._hasReferenceProvider = Le.hasReferenceProvider.bindTo(t), this._hasRenameProvider = Le.hasRenameProvider.bindTo(t), this._hasSignatureHelpProvider = Le.hasSignatureHelpProvider.bindTo(t), this._hasInlayHintsProvider = Le.hasInlayHintsProvider.bindTo(t), this._hasDocumentFormattingProvider = Le.hasDocumentFormattingProvider.bindTo(t), this._hasDocumentSelectionFormattingProvider = Le.hasDocumentSelectionFormattingProvider.bindTo(t), this._hasMultipleDocumentFormattingProvider = Le.hasMultipleDocumentFormattingProvider.bindTo(t), this._hasMultipleDocumentSelectionFormattingProvider = Le.hasMultipleDocumentSelectionFormattingProvider.bindTo(t), this._isInWalkThrough = Le.isInWalkThroughSnippet.bindTo(t);
    const i = () => this._update();
    this._register(e.onDidChangeModel(i)), this._register(e.onDidChangeModelLanguage(i)), this._register(hb.onDidChange(i)), this._register(pT.onDidChange(i)), this._register(fT.onDidChange(i)), this._register(uT.onDidChange(i)), this._register(cT.onDidChange(i)), this._register(hT.onDidChange(i)), this._register(dT.onDidChange(i)), this._register(sT.onDidChange(i)), this._register(lT.onDidChange(i)), this._register(aT.onDidChange(i)), this._register(nT.onDidChange(i)), this._register(rT.onDidChange(i)), this._register(av.onDidChange(i)), this._register(Au.onDidChange(i)), this._register(oT.onDidChange(i)), this._register(QF.onDidChange(i)), i();
  }
  dispose() {
    super.dispose();
  }
  reset() {
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.reset(), this._hasCompletionItemProvider.reset(), this._hasCodeActionsProvider.reset(), this._hasCodeLensProvider.reset(), this._hasDefinitionProvider.reset(), this._hasDeclarationProvider.reset(), this._hasImplementationProvider.reset(), this._hasTypeDefinitionProvider.reset(), this._hasHoverProvider.reset(), this._hasDocumentHighlightProvider.reset(), this._hasDocumentSymbolProvider.reset(), this._hasReferenceProvider.reset(), this._hasRenameProvider.reset(), this._hasDocumentFormattingProvider.reset(), this._hasDocumentSelectionFormattingProvider.reset(), this._hasSignatureHelpProvider.reset(), this._isInWalkThrough.reset();
    });
  }
  _update() {
    const e = this._editor.getModel();
    if (!e) {
      this.reset();
      return;
    }
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.set(e.getLanguageIdentifier().language), this._hasCompletionItemProvider.set(hb.has(e)), this._hasCodeActionsProvider.set(pT.has(e)), this._hasCodeLensProvider.set(fT.has(e)), this._hasDefinitionProvider.set(uT.has(e)), this._hasDeclarationProvider.set(cT.has(e)), this._hasImplementationProvider.set(hT.has(e)), this._hasTypeDefinitionProvider.set(dT.has(e)), this._hasHoverProvider.set(sT.has(e)), this._hasDocumentHighlightProvider.set(lT.has(e)), this._hasDocumentSymbolProvider.set(aT.has(e)), this._hasReferenceProvider.set(nT.has(e)), this._hasRenameProvider.set(rT.has(e)), this._hasSignatureHelpProvider.set(oT.has(e)), this._hasInlayHintsProvider.set(QF.has(e)), this._hasDocumentFormattingProvider.set(av.has(e) || Au.has(e)), this._hasDocumentSelectionFormattingProvider.set(Au.has(e)), this._hasMultipleDocumentFormattingProvider.set(av.all(e).length + Au.all(e).length > 1), this._hasMultipleDocumentSelectionFormattingProvider.set(Au.all(e).length > 1), this._isInWalkThrough.set(e.uri.scheme === vi.walkThroughSnippet);
    });
  }
}
class Hde extends ge {
  constructor(e) {
    super(), this._onChange = this._register(new j()), this.onChange = this._onChange.event, this._hasFocus = !1, this._domFocusTracker = this._register($S(e)), this._register(this._domFocusTracker.onDidFocus(() => {
      this._hasFocus = !0, this._onChange.fire(void 0);
    })), this._register(this._domFocusTracker.onDidBlur(() => {
      this._hasFocus = !1, this._onChange.fire(void 0);
    }));
  }
  hasFocus() {
    return this._hasFocus;
  }
}
const Gde = encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='"), Ude = encodeURIComponent("'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>");
function WD(n) {
  return Gde + encodeURIComponent(n.toString()) + Ude;
}
const zde = encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" height="3" width="12"><g fill="'), jde = encodeURIComponent('"><circle cx="1" cy="1" r="1"/><circle cx="5" cy="1" r="1"/><circle cx="9" cy="1" r="1"/></g></svg>');
function $de(n) {
  return zde + encodeURIComponent(n.toString()) + jde;
}
_a((n, e) => {
  const t = n.getColor(xue);
  t && e.addRule(`.monaco-editor .squiggly-error { border-bottom: 4px double ${t}; }`);
  const i = n.getColor(uw);
  i && e.addRule(`.monaco-editor .squiggly-error { background: url("data:image/svg+xml,${WD(i)}") repeat-x bottom left; }`);
  const r = n.getColor(Oue);
  r && e.addRule(`.monaco-editor .squiggly-error::before { display: block; content: ''; width: 100%; height: 100%; background: ${r}; }`);
  const o = n.getColor(JN);
  o && e.addRule(`.monaco-editor .squiggly-warning { border-bottom: 4px double ${o}; }`);
  const s = n.getColor(Zc);
  s && e.addRule(`.monaco-editor .squiggly-warning { background: url("data:image/svg+xml,${WD(s)}") repeat-x bottom left; }`);
  const a = n.getColor(Nue);
  a && e.addRule(`.monaco-editor .squiggly-warning::before { display: block; content: ''; width: 100%; height: 100%; background: ${a}; }`);
  const l = n.getColor(u3);
  l && e.addRule(`.monaco-editor .squiggly-info { border-bottom: 4px double ${l}; }`);
  const u = n.getColor(bp);
  u && e.addRule(`.monaco-editor .squiggly-info { background: url("data:image/svg+xml,${WD(u)}") repeat-x bottom left; }`);
  const c = n.getColor(Iue);
  c && e.addRule(`.monaco-editor .squiggly-info::before { display: block; content: ''; width: 100%; height: 100%; background: ${c}; }`);
  const h = n.getColor(Aue);
  h && e.addRule(`.monaco-editor .squiggly-hint { border-bottom: 2px dotted ${h}; }`);
  const d = n.getColor(Pue);
  d && e.addRule(`.monaco-editor .squiggly-hint { background: url("data:image/svg+xml,${$de(d)}") no-repeat bottom left; }`);
  const f = n.getColor(kce);
  f && e.addRule(`.monaco-editor.showUnused .squiggly-inline-unnecessary { opacity: ${f.rgba.a}; }`);
  const p = n.getColor(Fce);
  p && e.addRule(`.monaco-editor.showUnused .squiggly-unnecessary { border-bottom: 2px dashed ${p}; }`);
  const g = n.getColor(j_) || "inherit";
  e.addRule(`.monaco-editor.showDeprecated .squiggly-inline-deprecated { text-decoration: line-through; text-decoration-color: ${g}}`);
});
var Tg = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
};
let Kde = !1;
var A2;
(function(n) {
  n.North = "north", n.South = "south", n.East = "east", n.West = "west";
})(A2 || (A2 = {}));
let qde = 4;
const Yde = new j();
let Xde = 300;
const Zde = new j();
class cI {
  constructor() {
    this.disposables = new ht();
  }
  get onPointerMove() {
    return this.disposables.add(new Er(window, "mousemove")).event;
  }
  get onPointerUp() {
    return this.disposables.add(new Er(window, "mouseup")).event;
  }
  dispose() {
    this.disposables.dispose();
  }
}
Tg([
  Wn
], cI.prototype, "onPointerMove", null);
Tg([
  Wn
], cI.prototype, "onPointerUp", null);
class hI {
  constructor(e) {
    this.el = e, this.disposables = new ht();
  }
  get onPointerMove() {
    return this.disposables.add(new Er(this.el, Li.Change)).event;
  }
  get onPointerUp() {
    return this.disposables.add(new Er(this.el, Li.End)).event;
  }
  dispose() {
    this.disposables.dispose();
  }
}
Tg([
  Wn
], hI.prototype, "onPointerMove", null);
Tg([
  Wn
], hI.prototype, "onPointerUp", null);
class qb {
  constructor(e) {
    this.factory = e;
  }
  get onPointerMove() {
    return this.factory.onPointerMove;
  }
  get onPointerUp() {
    return this.factory.onPointerUp;
  }
  dispose() {
  }
}
Tg([
  Wn
], qb.prototype, "onPointerMove", null);
Tg([
  Wn
], qb.prototype, "onPointerUp", null);
class us extends ge {
  constructor(e, t, i) {
    super(), this.hoverDelay = Xde, this.hoverDelayer = this._register(new cN(this.hoverDelay)), this._state = 3, this._onDidEnablementChange = this._register(new j()), this.onDidEnablementChange = this._onDidEnablementChange.event, this._onDidStart = this._register(new j()), this.onDidStart = this._onDidStart.event, this._onDidChange = this._register(new j()), this.onDidChange = this._onDidChange.event, this._onDidReset = this._register(new j()), this.onDidReset = this._onDidReset.event, this._onDidEnd = this._register(new j()), this.onDidEnd = this._onDidEnd.event, this.linkedSash = void 0, this.orthogonalStartSashDisposables = this._register(new ht()), this.orthogonalStartDragHandleDisposables = this._register(new ht()), this.orthogonalEndSashDisposables = this._register(new ht()), this.orthogonalEndDragHandleDisposables = this._register(new ht()), this.el = Ie(e, Xe(".monaco-sash")), i.orthogonalEdge && this.el.classList.add(`orthogonal-edge-${i.orthogonalEdge}`), Ft && this.el.classList.add("mac");
    const r = this._register(new Er(this.el, "mousedown")).event;
    this._register(r((h) => this.onPointerStart(h, new cI()), this));
    const o = this._register(new Er(this.el, "dblclick")).event;
    this._register(o(this.onPointerDoublePress, this));
    const s = this._register(new Er(this.el, "mouseenter")).event;
    this._register(s(() => us.onMouseEnter(this)));
    const a = this._register(new Er(this.el, "mouseleave")).event;
    this._register(a(() => us.onMouseLeave(this))), this._register(ri.addTarget(this.el));
    const l = Ae.map(this._register(new Er(this.el, Li.Start)).event, (h) => {
      var d;
      return Object.assign(Object.assign({}, h), { target: (d = h.initialTarget) !== null && d !== void 0 ? d : null });
    });
    this._register(l((h) => this.onPointerStart(h, new hI(this.el)), this));
    const u = this._register(new Er(this.el, Li.Tap)).event, c = Ae.map(Ae.filter(Ae.debounce(u, (h, d) => {
      var f;
      return { event: d, count: ((f = h == null ? void 0 : h.count) !== null && f !== void 0 ? f : 0) + 1 };
    }, 250), ({ count: h }) => h === 2), ({ event: h }) => {
      var d;
      return Object.assign(Object.assign({}, h), { target: (d = h.initialTarget) !== null && d !== void 0 ? d : null });
    });
    this._register(c(this.onPointerDoublePress, this)), typeof i.size == "number" ? (this.size = i.size, i.orientation === 0 ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = qde, this._register(Yde.event((h) => {
      this.size = h, this.layout();
    }))), this._register(Zde.event((h) => this.hoverDelay = h)), this.hidden = !1, this.layoutProvider = t, this.orthogonalStartSash = i.orthogonalStartSash, this.orthogonalEndSash = i.orthogonalEndSash, this.orientation = i.orientation || 0, this.orientation === 1 ? (this.el.classList.add("horizontal"), this.el.classList.remove("vertical")) : (this.el.classList.remove("horizontal"), this.el.classList.add("vertical")), this.el.classList.toggle("debug", Kde), this.layout();
  }
  get state() {
    return this._state;
  }
  set state(e) {
    this._state !== e && (this.el.classList.toggle(
      "disabled",
      e === 0
      /* Disabled */
    ), this.el.classList.toggle(
      "minimum",
      e === 1
      /* Minimum */
    ), this.el.classList.toggle(
      "maximum",
      e === 2
      /* Maximum */
    ), this._state = e, this._onDidEnablementChange.fire(e));
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  set orthogonalStartSash(e) {
    if (this.orthogonalStartDragHandleDisposables.clear(), this.orthogonalStartSashDisposables.clear(), e) {
      const t = (i) => {
        this.orthogonalStartDragHandleDisposables.clear(), i !== 0 && (this._orthogonalStartDragHandle = Ie(this.el, Xe(".orthogonal-drag-handle.start")), this.orthogonalStartDragHandleDisposables.add(Ri(() => this._orthogonalStartDragHandle.remove())), this.orthogonalEndDragHandleDisposables.add(new Er(this._orthogonalStartDragHandle, "mouseenter")).event(() => us.onMouseEnter(e), void 0, this.orthogonalStartDragHandleDisposables), this.orthogonalEndDragHandleDisposables.add(new Er(this._orthogonalStartDragHandle, "mouseleave")).event(() => us.onMouseLeave(e), void 0, this.orthogonalStartDragHandleDisposables));
      };
      this.orthogonalStartSashDisposables.add(e.onDidEnablementChange(t, this)), t(e.state);
    }
    this._orthogonalStartSash = e;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  set orthogonalEndSash(e) {
    if (this.orthogonalEndDragHandleDisposables.clear(), this.orthogonalEndSashDisposables.clear(), e) {
      const t = (i) => {
        this.orthogonalEndDragHandleDisposables.clear(), i !== 0 && (this._orthogonalEndDragHandle = Ie(this.el, Xe(".orthogonal-drag-handle.end")), this.orthogonalEndDragHandleDisposables.add(Ri(() => this._orthogonalEndDragHandle.remove())), this.orthogonalEndDragHandleDisposables.add(new Er(this._orthogonalEndDragHandle, "mouseenter")).event(() => us.onMouseEnter(e), void 0, this.orthogonalEndDragHandleDisposables), this.orthogonalEndDragHandleDisposables.add(new Er(this._orthogonalEndDragHandle, "mouseleave")).event(() => us.onMouseLeave(e), void 0, this.orthogonalEndDragHandleDisposables));
      };
      this.orthogonalEndSashDisposables.add(e.onDidEnablementChange(t, this)), t(e.state);
    }
    this._orthogonalEndSash = e;
  }
  onPointerStart(e, t) {
    gi.stop(e);
    let i = !1;
    if (!e.__orthogonalSashEvent) {
      const p = this.getOrthogonalSash(e);
      p && (i = !0, e.__orthogonalSashEvent = !0, p.onPointerStart(e, new qb(t)));
    }
    if (this.linkedSash && !e.__linkedSashEvent && (e.__linkedSashEvent = !0, this.linkedSash.onPointerStart(e, new qb(t))), !this.state)
      return;
    const r = [
      ...SF("iframe"),
      ...SF("webview")
    ];
    for (const p of r)
      p.style.pointerEvents = "none";
    const o = e.pageX, s = e.pageY, a = e.altKey, l = { startX: o, currentX: o, startY: s, currentY: s, altKey: a };
    this.el.classList.add("active"), this._onDidStart.fire(l);
    const u = Os(this.el), c = () => {
      let p = "";
      i ? p = "all-scroll" : this.orientation === 1 ? this.state === 1 ? p = "s-resize" : this.state === 2 ? p = "n-resize" : p = Ft ? "row-resize" : "ns-resize" : this.state === 1 ? p = "e-resize" : this.state === 2 ? p = "w-resize" : p = Ft ? "col-resize" : "ew-resize", u.textContent = `* { cursor: ${p} !important; }`;
    }, h = new ht();
    c(), i || this.onDidEnablementChange(c, null, h);
    const d = (p) => {
      gi.stop(p, !1);
      const g = { startX: o, currentX: p.pageX, startY: s, currentY: p.pageY, altKey: a };
      this._onDidChange.fire(g);
    }, f = (p) => {
      gi.stop(p, !1), this.el.removeChild(u), this.el.classList.remove("active"), this._onDidEnd.fire(), h.dispose();
      for (const g of r)
        g.style.pointerEvents = "auto";
    };
    t.onPointerMove(d, null, h), t.onPointerUp(f, null, h), h.add(t);
  }
  onPointerDoublePress(e) {
    const t = this.getOrthogonalSash(e);
    t && t._onDidReset.fire(), this.linkedSash && this.linkedSash._onDidReset.fire(), this._onDidReset.fire();
  }
  static onMouseEnter(e, t = !1) {
    e.el.classList.contains("active") ? (e.hoverDelayer.cancel(), e.el.classList.add("hover")) : e.hoverDelayer.trigger(() => e.el.classList.add("hover"), e.hoverDelay).then(void 0, () => {
    }), !t && e.linkedSash && us.onMouseEnter(e.linkedSash, !0);
  }
  static onMouseLeave(e, t = !1) {
    e.hoverDelayer.cancel(), e.el.classList.remove("hover"), !t && e.linkedSash && us.onMouseLeave(e.linkedSash, !0);
  }
  clearSashHoverState() {
    us.onMouseLeave(this);
  }
  layout() {
    if (this.orientation === 0) {
      const e = this.layoutProvider;
      this.el.style.left = e.getVerticalSashLeft(this) - this.size / 2 + "px", e.getVerticalSashTop && (this.el.style.top = e.getVerticalSashTop(this) + "px"), e.getVerticalSashHeight && (this.el.style.height = e.getVerticalSashHeight(this) + "px");
    } else {
      const e = this.layoutProvider;
      this.el.style.top = e.getHorizontalSashTop(this) - this.size / 2 + "px", e.getHorizontalSashLeft && (this.el.style.left = e.getHorizontalSashLeft(this) + "px"), e.getHorizontalSashWidth && (this.el.style.width = e.getHorizontalSashWidth(this) + "px");
    }
  }
  hide() {
    this.hidden = !0, this.el.style.display = "none", this.el.setAttribute("aria-hidden", "true");
  }
  getOrthogonalSash(e) {
    if (!(!e.target || !(e.target instanceof HTMLElement)) && e.target.classList.contains("orthogonal-drag-handle"))
      return e.target.classList.contains("start") ? this.orthogonalStartSash : this.orthogonalEndSash;
  }
  dispose() {
    super.dispose(), this.el.remove();
  }
}
class Pc {
  constructor(e, t = [], i = !1) {
    this.ctor = e, this.staticArguments = t, this.supportsDelayedInstantiation = i;
  }
}
const P3 = [];
function A3(n, e, t) {
  e instanceof Pc || (e = new Pc(e, [], t)), P3.push([n, e]);
}
function Qde() {
  return P3;
}
const dI = Vt("IEditorCancelService"), M3 = new it("cancellableOperation", !1, w("cancellableOperation", "Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));
A3(dI, class {
  constructor() {
    this._tokens = /* @__PURE__ */ new WeakMap();
  }
  add(n, e) {
    let t = this._tokens.get(n);
    t || (t = n.invokeWithinContext((r) => {
      const o = M3.bindTo(r.get(Ti)), s = new ua();
      return { key: o, tokens: s };
    }), this._tokens.set(n, t));
    let i;
    return t.key.set(!0), i = t.tokens.push(e), () => {
      i && (i(), t.key.set(!t.tokens.isEmpty()), i = void 0);
    };
  }
  cancel(n) {
    const e = this._tokens.get(n);
    if (!e)
      return;
    const t = e.tokens.pop();
    t && (t.cancel(), e.key.set(!e.tokens.isEmpty()));
  }
}, !0);
class Jde extends uh {
  constructor(e, t) {
    super(t), this.editor = e, this._unregister = e.invokeWithinContext((i) => i.get(dI).add(e, this));
  }
  dispose() {
    this._unregister(), super.dispose();
  }
}
Ze(new class extends Lg {
  constructor() {
    super({
      id: "editor.cancelOperation",
      kbOpts: {
        weight: 100,
        primary: 9
        /* Escape */
      },
      precondition: M3
    });
  }
  runEditorCommand(n, e) {
    n.get(dI).cancel(e);
  }
}());
class $T {
  constructor(e, t) {
    if (this.flags = t, this.flags & 1) {
      const i = e.getModel();
      this.modelVersionId = i ? xl("{0}#{1}", i.uri.toString(), i.getVersionId()) : null;
    } else
      this.modelVersionId = null;
    this.flags & 4 ? this.position = e.getPosition() : this.position = null, this.flags & 2 ? this.selection = e.getSelection() : this.selection = null, this.flags & 8 ? (this.scrollLeft = e.getScrollLeft(), this.scrollTop = e.getScrollTop()) : (this.scrollLeft = -1, this.scrollTop = -1);
  }
  _equals(e) {
    if (!(e instanceof $T))
      return !1;
    const t = e;
    return !(this.modelVersionId !== t.modelVersionId || this.scrollLeft !== t.scrollLeft || this.scrollTop !== t.scrollTop || !this.position && t.position || this.position && !t.position || this.position && t.position && !this.position.equals(t.position) || !this.selection && t.selection || this.selection && !t.selection || this.selection && t.selection && !this.selection.equalsRange(t.selection));
  }
  validate(e) {
    return this._equals(new $T(e, this.flags));
  }
}
class F3 extends Jde {
  constructor(e, t, i, r) {
    super(e, r), this._listener = new ht(), t & 4 && this._listener.add(e.onDidChangeCursorPosition((o) => {
      (!i || !V.containsPosition(i, o.position)) && this.cancel();
    })), t & 2 && this._listener.add(e.onDidChangeCursorSelection((o) => {
      (!i || !V.containsRange(i, o.selection)) && this.cancel();
    })), t & 8 && this._listener.add(e.onDidScrollChange((o) => this.cancel())), t & 1 && (this._listener.add(e.onDidChangeModel((o) => this.cancel())), this._listener.add(e.onDidChangeModelContent((o) => this.cancel())));
  }
  dispose() {
    this._listener.dispose(), super.dispose();
  }
}
class k3 extends uh {
  constructor(e, t) {
    super(t), this._listener = e.onDidChangeContent(() => this.cancel());
  }
  dispose() {
    this._listener.dispose(), super.dispose();
  }
}
class fI {
  constructor(e, t, i) {
    this._visiblePosition = e, this._visiblePositionScrollDelta = t, this._cursorPosition = i;
  }
  static capture(e) {
    let t = null, i = 0;
    if (e.getScrollTop() !== 0) {
      const r = e.getVisibleRanges();
      if (r.length > 0) {
        t = r[0].getStartPosition();
        const o = e.getTopForPosition(t.lineNumber, t.column);
        i = e.getScrollTop() - o;
      }
    }
    return new fI(t, i, e.getPosition());
  }
  restore(e) {
    if (this._visiblePosition) {
      const t = e.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
      e.setScrollTop(t + this._visiblePositionScrollDelta);
    }
  }
  restoreRelativeVerticalPositionOfCursor(e) {
    const t = e.getPosition();
    if (!this._cursorPosition || !t)
      return;
    const i = e.getTopForLineNumber(t.lineNumber) - e.getTopForLineNumber(this._cursorPosition.lineNumber);
    e.setScrollTop(e.getScrollTop() + i);
  }
}
const W3 = {
  /**
   * Application specific resource transfer type
   */
  RESOURCES: "ResourceURLs",
  /**
   * Browser specific transfer type to download
   */
  DOWNLOAD_URL: "DownloadURL",
  /**
   * Browser specific transfer type for files
   */
  FILES: "Files",
  /**
   * Typically transfer type for copy/paste transfers.
   */
  TEXT: "text/plain"
};
class efe {
  constructor(e) {
    this.data = e;
  }
  update() {
  }
  getData() {
    return this.data;
  }
}
const bu = {
  CurrentDragAndDropData: void 0
};
class yv extends ge {
  constructor(e, t, i = {}) {
    super(), this.options = i, this._context = e || this, this._action = t, t instanceof Wl && this._register(t.onDidChange((r) => {
      this.element && this.handleActionChangeEvent(r);
    }));
  }
  handleActionChangeEvent(e) {
    e.enabled !== void 0 && this.updateEnabled(), e.checked !== void 0 && this.updateChecked(), e.class !== void 0 && this.updateClass(), e.label !== void 0 && (this.updateLabel(), this.updateTooltip()), e.tooltip !== void 0 && this.updateTooltip();
  }
  get actionRunner() {
    return this._actionRunner || (this._actionRunner = this._register(new WN())), this._actionRunner;
  }
  set actionRunner(e) {
    this._actionRunner = e;
  }
  getAction() {
    return this._action;
  }
  isEnabled() {
    return this._action.enabled;
  }
  setActionContext(e) {
    this._context = e;
  }
  render(e) {
    const t = this.element = e;
    this._register(ri.addTarget(e));
    const i = this.options && this.options.draggable;
    i && (e.draggable = !0, Qr && this._register(ye(e, Be.DRAG_START, (r) => {
      var o;
      return (o = r.dataTransfer) === null || o === void 0 ? void 0 : o.setData(W3.TEXT, this._action.label);
    }))), this._register(ye(t, Li.Tap, (r) => this.onClick(r))), this._register(ye(t, Be.MOUSE_DOWN, (r) => {
      i || gi.stop(r, !0), this._action.enabled && r.button === 0 && t.classList.add("active");
    })), Ft && this._register(ye(t, Be.CONTEXT_MENU, (r) => {
      r.button === 0 && r.ctrlKey === !0 && this.onClick(r);
    })), this._register(ye(t, Be.CLICK, (r) => {
      gi.stop(r, !0), this.options && this.options.isMenu || Jw(() => this.onClick(r));
    })), this._register(ye(t, Be.DBLCLICK, (r) => {
      gi.stop(r, !0);
    })), [Be.MOUSE_UP, Be.MOUSE_OUT].forEach((r) => {
      this._register(ye(t, r, (o) => {
        gi.stop(o), t.classList.remove("active");
      }));
    });
  }
  onClick(e) {
    var t;
    gi.stop(e, !0);
    const i = ps(this._context) ? !((t = this.options) === null || t === void 0) && t.useEventAsContext ? e : void 0 : this._context;
    this.actionRunner.run(this._action, i);
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.element && (this.element.tabIndex = 0, this.element.focus(), this.element.classList.add("focused"));
  }
  blur() {
    this.element && (this.element.blur(), this.element.tabIndex = -1, this.element.classList.remove("focused"));
  }
  setFocusable(e) {
    this.element && (this.element.tabIndex = e ? 0 : -1);
  }
  get trapsArrowNavigation() {
    return !1;
  }
  updateEnabled() {
  }
  updateLabel() {
  }
  updateTooltip() {
  }
  updateClass() {
  }
  updateChecked() {
  }
  dispose() {
    this.element && (this.element.remove(), this.element = void 0), super.dispose();
  }
}
class V3 extends yv {
  constructor(e, t, i = {}) {
    super(e, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "";
  }
  render(e) {
    super.render(e), this.element && (this.label = Ie(this.element, Xe("a.action-label"))), this.label && (this._action.id === Yd.ID ? this.label.setAttribute("role", "presentation") : this.options.isMenu ? this.label.setAttribute("role", "menuitem") : this.label.setAttribute("role", "button")), this.options.label && this.options.keybinding && this.element && (Ie(this.element, Xe("span.keybinding")).textContent = this.options.keybinding), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked();
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.label && (this.label.tabIndex = 0, this.label.focus());
  }
  blur() {
    this.label && (this.label.tabIndex = -1);
  }
  setFocusable(e) {
    this.label && (this.label.tabIndex = e ? 0 : -1);
  }
  updateLabel() {
    this.options.label && this.label && (this.label.textContent = this.getAction().label);
  }
  updateTooltip() {
    let e = null;
    this.getAction().tooltip ? e = this.getAction().tooltip : !this.options.label && this.getAction().label && this.options.icon && (e = this.getAction().label, this.options.keybinding && (e = w({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", e, this.options.keybinding))), e && this.label && (this.label.title = e);
  }
  updateClass() {
    this.cssClass && this.label && this.label.classList.remove(...this.cssClass.split(" ")), this.options.icon ? (this.cssClass = this.getAction().class, this.label && (this.label.classList.add("codicon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" "))), this.updateEnabled()) : this.label && this.label.classList.remove("codicon");
  }
  updateEnabled() {
    this.getAction().enabled ? (this.label && (this.label.removeAttribute("aria-disabled"), this.label.classList.remove("disabled")), this.element && this.element.classList.remove("disabled")) : (this.label && (this.label.setAttribute("aria-disabled", "true"), this.label.classList.add("disabled")), this.element && this.element.classList.add("disabled"));
  }
  updateChecked() {
    this.label && (this.getAction().checked ? this.label.classList.add("checked") : this.label.classList.remove("checked"));
  }
}
var tfe = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class Qp extends ge {
  constructor(e, t = {}) {
    var i, r, o, s, a, l;
    super(), this.triggerKeyDown = !1, this.focusable = !0, this._onDidBlur = this._register(new j()), this.onDidBlur = this._onDidBlur.event, this._onDidCancel = this._register(new j({ onFirstListenerAdd: () => this.cancelHasListener = !0 })), this.onDidCancel = this._onDidCancel.event, this.cancelHasListener = !1, this._onDidRun = this._register(new j()), this.onDidRun = this._onDidRun.event, this._onBeforeRun = this._register(new j()), this.onBeforeRun = this._onBeforeRun.event, this.options = t, this._context = (i = t.context) !== null && i !== void 0 ? i : null, this._orientation = (r = this.options.orientation) !== null && r !== void 0 ? r : 0, this._triggerKeys = {
      keyDown: (s = (o = this.options.triggerKeys) === null || o === void 0 ? void 0 : o.keyDown) !== null && s !== void 0 ? s : !1,
      keys: (l = (a = this.options.triggerKeys) === null || a === void 0 ? void 0 : a.keys) !== null && l !== void 0 ? l : [
        3,
        10
        /* Space */
      ]
    }, this.options.actionRunner ? this._actionRunner = this.options.actionRunner : (this._actionRunner = new WN(), this._register(this._actionRunner)), this._register(this._actionRunner.onDidRun((h) => this._onDidRun.fire(h))), this._register(this._actionRunner.onBeforeRun((h) => this._onBeforeRun.fire(h))), this._actionIds = [], this.viewItems = [], this.focusedItem = void 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-action-bar", t.animated !== !1 && this.domNode.classList.add("animated");
    let u, c;
    switch (this._orientation) {
      case 0:
        u = [
          15
          /* LeftArrow */
        ], c = [
          17
          /* RightArrow */
        ];
        break;
      case 1:
        u = [
          16
          /* UpArrow */
        ], c = [
          18
          /* DownArrow */
        ], this.domNode.className += " vertical";
        break;
    }
    this._register(ye(this.domNode, Be.KEY_DOWN, (h) => {
      const d = new Ki(h);
      let f = !0;
      const p = typeof this.focusedItem == "number" ? this.viewItems[this.focusedItem] : void 0;
      u && (d.equals(u[0]) || d.equals(u[1])) ? f = this.focusPrevious() : c && (d.equals(c[0]) || d.equals(c[1])) ? f = this.focusNext() : d.equals(
        9
        /* Escape */
      ) && this.cancelHasListener ? this._onDidCancel.fire() : d.equals(
        14
        /* Home */
      ) ? f = this.focusFirst() : d.equals(
        13
        /* End */
      ) ? f = this.focusLast() : d.equals(
        2
        /* Tab */
      ) && p instanceof yv && p.trapsArrowNavigation ? f = this.focusNext() : this.isTriggerKeyEvent(d) ? this._triggerKeys.keyDown ? this.doTrigger(d) : this.triggerKeyDown = !0 : f = !1, f && (d.preventDefault(), d.stopPropagation());
    })), this._register(ye(this.domNode, Be.KEY_UP, (h) => {
      const d = new Ki(h);
      this.isTriggerKeyEvent(d) ? (!this._triggerKeys.keyDown && this.triggerKeyDown && (this.triggerKeyDown = !1, this.doTrigger(d)), d.preventDefault(), d.stopPropagation()) : (d.equals(
        2
        /* Tab */
      ) || d.equals(
        1026
        /* Tab */
      )) && this.updateFocusedItem();
    })), this.focusTracker = this._register($S(this.domNode)), this._register(this.focusTracker.onDidBlur(() => {
      (fp() === this.domNode || !Ku(fp(), this.domNode)) && (this._onDidBlur.fire(), this.focusedItem = void 0, this.triggerKeyDown = !1);
    })), this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem())), this.actionsList = document.createElement("ul"), this.actionsList.className = "actions-container", this.actionsList.setAttribute("role", "toolbar"), this.options.ariaLabel && this.actionsList.setAttribute("aria-label", this.options.ariaLabel), this.domNode.appendChild(this.actionsList), e.appendChild(this.domNode);
  }
  isTriggerKeyEvent(e) {
    let t = !1;
    return this._triggerKeys.keys.forEach((i) => {
      t = t || e.equals(i);
    }), t;
  }
  updateFocusedItem() {
    for (let e = 0; e < this.actionsList.children.length; e++) {
      const t = this.actionsList.children[e];
      if (Ku(fp(), t)) {
        this.focusedItem = e;
        break;
      }
    }
  }
  get context() {
    return this._context;
  }
  set context(e) {
    this._context = e, this.viewItems.forEach((t) => t.setActionContext(e));
  }
  get actionRunner() {
    return this._actionRunner;
  }
  set actionRunner(e) {
    e && (this._actionRunner = e, this.viewItems.forEach((t) => t.actionRunner = e));
  }
  getContainer() {
    return this.domNode;
  }
  push(e, t = {}) {
    const i = Array.isArray(e) ? e : [e];
    let r = V_(t.index) ? t.index : null;
    i.forEach((o) => {
      const s = document.createElement("li");
      s.className = "action-item", s.setAttribute("role", "presentation"), this.options.allowContextMenu || this._register(ye(s, Be.CONTEXT_MENU, (l) => {
        gi.stop(l, !0);
      }));
      let a;
      this.options.actionViewItemProvider && (a = this.options.actionViewItemProvider(o)), a || (a = new V3(this.context, o, t)), a.actionRunner = this._actionRunner, a.setActionContext(this.context), a.render(s), this.focusable && a instanceof yv && this.viewItems.length === 0 && a.setFocusable(!0), r === null || r < 0 || r >= this.actionsList.children.length ? (this.actionsList.appendChild(s), this.viewItems.push(a), this._actionIds.push(o.id)) : (this.actionsList.insertBefore(s, this.actionsList.children[r]), this.viewItems.splice(r, 0, a), this._actionIds.splice(r, 0, o.id), r++);
    }), typeof this.focusedItem == "number" && this.focus(this.focusedItem);
  }
  clear() {
    yi(this.viewItems), this.viewItems = [], this._actionIds = [], Ts(this.actionsList);
  }
  length() {
    return this.viewItems.length;
  }
  focus(e) {
    let t = !1, i;
    if (e === void 0 ? t = !0 : typeof e == "number" ? i = e : typeof e == "boolean" && (t = e), t && typeof this.focusedItem > "u") {
      const r = this.viewItems.findIndex((o) => o.isEnabled());
      this.focusedItem = r === -1 ? void 0 : r, this.updateFocus();
    } else
      i !== void 0 && (this.focusedItem = i), this.updateFocus();
  }
  focusFirst() {
    return this.focusedItem = this.length() > 1 ? 1 : 0, this.focusPrevious();
  }
  focusLast() {
    return this.focusedItem = this.length() < 2 ? 0 : this.length() - 2, this.focusNext();
  }
  focusNext() {
    if (typeof this.focusedItem > "u")
      this.focusedItem = this.viewItems.length - 1;
    else if (this.viewItems.length <= 1)
      return !1;
    const e = this.focusedItem;
    let t;
    do {
      if (this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length)
        return this.focusedItem = e, !1;
      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length, t = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== e && this.options.focusOnlyEnabledItems && !t.isEnabled());
    return this.updateFocus(), !0;
  }
  focusPrevious() {
    if (typeof this.focusedItem > "u")
      this.focusedItem = 0;
    else if (this.viewItems.length <= 1)
      return !1;
    const e = this.focusedItem;
    let t;
    do {
      if (this.focusedItem = this.focusedItem - 1, this.focusedItem < 0) {
        if (this.options.preventLoopNavigation)
          return this.focusedItem = e, !1;
        this.focusedItem = this.viewItems.length - 1;
      }
      t = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== e && this.options.focusOnlyEnabledItems && !t.isEnabled());
    return this.updateFocus(!0), !0;
  }
  updateFocus(e, t) {
    typeof this.focusedItem > "u" && this.actionsList.focus({ preventScroll: t });
    for (let i = 0; i < this.viewItems.length; i++) {
      const r = this.viewItems[i], o = r;
      if (i === this.focusedItem) {
        let s = !0;
        sv(o.focus) || (s = !1), this.options.focusOnlyEnabledItems && sv(r.isEnabled) && !r.isEnabled() && (s = !1), s ? o.focus(e) : this.actionsList.focus({ preventScroll: t });
      } else
        sv(o.blur) && o.blur();
    }
  }
  doTrigger(e) {
    if (typeof this.focusedItem > "u")
      return;
    const t = this.viewItems[this.focusedItem];
    if (t instanceof yv) {
      const i = t._context === null || t._context === void 0 ? e : t._context;
      this.run(t._action, i);
    }
  }
  run(e, t) {
    return tfe(this, void 0, void 0, function* () {
      yield this._actionRunner.run(e, t);
    });
  }
  dispose() {
    yi(this.viewItems), this.viewItems = [], this._actionIds = [], this.getContainer().remove(), super.dispose();
  }
}
const ife = {
  IconContribution: "base.contributions.icons"
};
class nfe {
  constructor() {
    this._onDidChange = new j(), this.onDidChange = this._onDidChange.event, this.iconSchema = {
      definitions: {
        icons: {
          type: "object",
          properties: {
            fontId: { type: "string", description: w("iconDefintion.fontId", "The id of the font to use. If not set, the font that is defined first is used.") },
            fontCharacter: { type: "string", description: w("iconDefintion.fontCharacter", "The font character associated with the icon definition.") }
          },
          additionalProperties: !1,
          defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
        }
      },
      type: "object",
      properties: {}
    }, this.iconReferenceSchema = { type: "string", pattern: `^${Vo.iconNameExpression}$`, enum: [], enumDescriptions: [] }, this.iconsById = {}, this.iconFontsById = {};
  }
  registerIcon(e, t, i, r) {
    const o = this.iconsById[e];
    if (o) {
      if (i && !o.description) {
        o.description = i, this.iconSchema.properties[e].markdownDescription = `${i} $(${e})`;
        const l = this.iconReferenceSchema.enum.indexOf(e);
        l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = i), this._onDidChange.fire();
      }
      return o;
    }
    let s = { id: e, description: i, defaults: t, deprecationMessage: r };
    this.iconsById[e] = s;
    let a = { $ref: "#/definitions/icons" };
    return r && (a.deprecationMessage = r), i && (a.markdownDescription = `${i}: $(${e})`), this.iconSchema.properties[e] = a, this.iconReferenceSchema.enum.push(e), this.iconReferenceSchema.enumDescriptions.push(i || ""), this._onDidChange.fire(), { id: e };
  }
  getIcons() {
    return Object.keys(this.iconsById).map((e) => this.iconsById[e]);
  }
  getIcon(e) {
    return this.iconsById[e];
  }
  getIconSchema() {
    return this.iconSchema;
  }
  getIconFont(e) {
    return this.iconFontsById[e];
  }
  toString() {
    const e = (o, s) => o.id.localeCompare(s.id), t = (o) => {
      for (; fa.isThemeIcon(o.defaults); )
        o = this.iconsById[o.defaults.id];
      return `codicon codicon-${o ? o.id : ""}`;
    };
    let i = [];
    i.push("| preview     | identifier                        | default codicon ID                | description"), i.push("| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |");
    const r = Object.keys(this.iconsById).map((o) => this.iconsById[o]);
    for (const o of r.filter((s) => !!s.description).sort(e))
      i.push(`|<i class="${t(o)}"></i>|${o.id}|${fa.isThemeIcon(o.defaults) ? o.defaults.id : o.id}|${o.description || ""}|`);
    i.push("| preview     | identifier                        "), i.push("| ----------- | --------------------------------- |");
    for (const o of r.filter((s) => !fa.isThemeIcon(s.defaults)).sort(e))
      i.push(`|<i class="${t(o)}"></i>|${o.id}|`);
    return i.join(`
`);
  }
}
const Wd = new nfe();
Zn.add(ife.IconContribution, Wd);
function Og(n, e, t, i) {
  return Wd.registerIcon(n, e, t, i);
}
function rfe() {
  return Wd;
}
function ofe() {
  for (const n of cb.all)
    Wd.registerIcon(n.id, n.definition, n.description);
  cb.onDidRegister((n) => Wd.registerIcon(n.id, n.definition, n.description));
}
ofe();
const B3 = "vscode://schemas/icons";
let H3 = Zn.as(i0.JSONContribution);
H3.registerSchema(B3, Wd.getIconSchema());
const M2 = new to(() => H3.notifySchemaChanged(B3), 200);
Wd.onDidChange(() => {
  M2.isScheduled() || M2.schedule();
});
const Fye = Og("widget-close", Vi.close, w("widgetClose", "Icon for the close action in widgets."));
var sfe = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
}, VD;
const Ry = 3;
class Im {
  constructor(e, t, i, r) {
    this.originalLineStart = e, this.originalLineEnd = t, this.modifiedLineStart = i, this.modifiedLineEnd = r;
  }
  getType() {
    return this.originalLineStart === 0 ? 1 : this.modifiedLineStart === 0 ? 2 : 0;
  }
}
class BD {
  constructor(e) {
    this.entries = e;
  }
}
const afe = Og("diff-review-insert", Vi.add, w("diffReviewInsertIcon", "Icon for 'Insert' in diff review.")), lfe = Og("diff-review-remove", Vi.remove, w("diffReviewRemoveIcon", "Icon for 'Remove' in diff review.")), ufe = Og("diff-review-close", Vi.close, w("diffReviewCloseIcon", "Icon for 'Close' in diff review."));
class Ou extends ge {
  constructor(e) {
    super(), this._width = 0, this._diffEditor = e, this._isVisible = !1, this.shadow = bt(document.createElement("div")), this.shadow.setClassName("diff-review-shadow"), this.actionBarContainer = bt(document.createElement("div")), this.actionBarContainer.setClassName("diff-review-actions"), this._actionBar = this._register(new Qp(this.actionBarContainer.domNode)), this._actionBar.push(new Wl("diffreview.close", w("label.close", "Close"), "close-diff-review " + fa.asClassName(ufe), !0, () => sfe(this, void 0, void 0, function* () {
      return this.hide();
    })), { label: !1, icon: !0 }), this.domNode = bt(document.createElement("div")), this.domNode.setClassName("diff-review monaco-editor-background"), this._content = bt(document.createElement("div")), this._content.setClassName("diff-review-content"), this._content.setAttribute("role", "code"), this.scrollbar = this._register(new T3(this._content.domNode, {})), this.domNode.domNode.appendChild(this.scrollbar.getDomNode()), this._register(e.onDidUpdateDiff(() => {
      this._isVisible && (this._diffs = this._compute(), this._render());
    })), this._register(e.getModifiedEditor().onDidChangeCursorPosition(() => {
      this._isVisible && this._render();
    })), this._register(Jr(this.domNode.domNode, "click", (t) => {
      t.preventDefault();
      let i = LG(t.target, "diff-review-row");
      i && this._goToRow(i);
    })), this._register(Jr(this.domNode.domNode, "keydown", (t) => {
      (t.equals(
        18
        /* DownArrow */
      ) || t.equals(
        2066
        /* DownArrow */
      ) || t.equals(
        530
        /* DownArrow */
      )) && (t.preventDefault(), this._goToRow(this._getNextRow())), (t.equals(
        16
        /* UpArrow */
      ) || t.equals(
        2064
        /* UpArrow */
      ) || t.equals(
        528
        /* UpArrow */
      )) && (t.preventDefault(), this._goToRow(this._getPrevRow())), (t.equals(
        9
        /* Escape */
      ) || t.equals(
        2057
        /* Escape */
      ) || t.equals(
        521
        /* Escape */
      ) || t.equals(
        1033
        /* Escape */
      )) && (t.preventDefault(), this.hide()), (t.equals(
        10
        /* Space */
      ) || t.equals(
        3
        /* Enter */
      )) && (t.preventDefault(), this.accept());
    })), this._diffs = [], this._currentDiff = null;
  }
  prev() {
    let e = 0;
    if (this._isVisible || (this._diffs = this._compute()), this._isVisible) {
      let i = -1;
      for (let r = 0, o = this._diffs.length; r < o; r++)
        if (this._diffs[r] === this._currentDiff) {
          i = r;
          break;
        }
      e = this._diffs.length + i - 1;
    } else
      e = this._findDiffIndex(this._diffEditor.getPosition());
    if (this._diffs.length === 0)
      return;
    e = e % this._diffs.length;
    const t = this._diffs[e].entries;
    this._diffEditor.setPosition(new J(t[0].modifiedLineStart, 1)), this._diffEditor.setSelection({ startColumn: 1, startLineNumber: t[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: t[t.length - 1].modifiedLineEnd }), this._isVisible = !0, this._diffEditor.doLayout(), this._render(), this._goToRow(this._getNextRow());
  }
  next() {
    let e = 0;
    if (this._isVisible || (this._diffs = this._compute()), this._isVisible) {
      let i = -1;
      for (let r = 0, o = this._diffs.length; r < o; r++)
        if (this._diffs[r] === this._currentDiff) {
          i = r;
          break;
        }
      e = i + 1;
    } else
      e = this._findDiffIndex(this._diffEditor.getPosition());
    if (this._diffs.length === 0)
      return;
    e = e % this._diffs.length;
    const t = this._diffs[e].entries;
    this._diffEditor.setPosition(new J(t[0].modifiedLineStart, 1)), this._diffEditor.setSelection({ startColumn: 1, startLineNumber: t[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: t[t.length - 1].modifiedLineEnd }), this._isVisible = !0, this._diffEditor.doLayout(), this._render(), this._goToRow(this._getNextRow());
  }
  accept() {
    let e = -1, t = this._getCurrentFocusedRow();
    if (t) {
      let i = parseInt(t.getAttribute("data-line"), 10);
      isNaN(i) || (e = i);
    }
    this.hide(), e !== -1 && (this._diffEditor.setPosition(new J(e, 1)), this._diffEditor.revealPosition(
      new J(e, 1),
      1
      /* Immediate */
    ));
  }
  hide() {
    this._isVisible = !1, this._diffEditor.updateOptions({ readOnly: !1 }), this._diffEditor.focus(), this._diffEditor.doLayout(), this._render();
  }
  _getPrevRow() {
    let e = this._getCurrentFocusedRow();
    return e ? e.previousElementSibling ? e.previousElementSibling : e : this._getFirstRow();
  }
  _getNextRow() {
    let e = this._getCurrentFocusedRow();
    return e ? e.nextElementSibling ? e.nextElementSibling : e : this._getFirstRow();
  }
  _getFirstRow() {
    return this.domNode.domNode.querySelector(".diff-review-row");
  }
  _getCurrentFocusedRow() {
    let e = document.activeElement;
    return e && /diff-review-row/.test(e.className) ? e : null;
  }
  _goToRow(e) {
    let t = this._getCurrentFocusedRow();
    e.tabIndex = 0, e.focus(), t && t !== e && (t.tabIndex = -1), this.scrollbar.scanDomNode();
  }
  isVisible() {
    return this._isVisible;
  }
  layout(e, t, i) {
    this._width = t, this.shadow.setTop(e - 6), this.shadow.setWidth(t), this.shadow.setHeight(this._isVisible ? 6 : 0), this.domNode.setTop(e), this.domNode.setWidth(t), this.domNode.setHeight(i), this._content.setHeight(i), this._content.setWidth(t), this._isVisible ? (this.actionBarContainer.setAttribute("aria-hidden", "false"), this.actionBarContainer.setDisplay("block")) : (this.actionBarContainer.setAttribute("aria-hidden", "true"), this.actionBarContainer.setDisplay("none"));
  }
  _compute() {
    const e = this._diffEditor.getLineChanges();
    if (!e || e.length === 0)
      return [];
    const t = this._diffEditor.getOriginalEditor().getModel(), i = this._diffEditor.getModifiedEditor().getModel();
    return !t || !i ? [] : Ou._mergeAdjacent(e, t.getLineCount(), i.getLineCount());
  }
  static _mergeAdjacent(e, t, i) {
    if (!e || e.length === 0)
      return [];
    let r = [], o = 0;
    for (let u = 0, c = e.length; u < c; u++) {
      const h = e[u], d = h.originalStartLineNumber, f = h.originalEndLineNumber, p = h.modifiedStartLineNumber, g = h.modifiedEndLineNumber;
      let _ = [], m = 0;
      {
        const v = f === 0 ? d : d - 1, C = g === 0 ? p : p - 1;
        let y = 1, b = 1;
        if (u > 0) {
          const E = e[u - 1];
          E.originalEndLineNumber === 0 ? y = E.originalStartLineNumber + 1 : y = E.originalEndLineNumber + 1, E.modifiedEndLineNumber === 0 ? b = E.modifiedStartLineNumber + 1 : b = E.modifiedEndLineNumber + 1;
        }
        let L = v - Ry + 1, S = C - Ry + 1;
        if (L < y) {
          const E = y - L;
          L = L + E, S = S + E;
        }
        if (S < b) {
          const E = b - S;
          L = L + E, S = S + E;
        }
        _[m++] = new Im(L, v, S, C);
      }
      f !== 0 && (_[m++] = new Im(d, f, 0, 0)), g !== 0 && (_[m++] = new Im(0, 0, p, g));
      {
        const v = f === 0 ? d + 1 : f + 1, C = g === 0 ? p + 1 : g + 1;
        let y = t, b = i;
        if (u + 1 < c) {
          const E = e[u + 1];
          E.originalEndLineNumber === 0 ? y = E.originalStartLineNumber : y = E.originalStartLineNumber - 1, E.modifiedEndLineNumber === 0 ? b = E.modifiedStartLineNumber : b = E.modifiedStartLineNumber - 1;
        }
        let L = v + Ry - 1, S = C + Ry - 1;
        if (L > y) {
          const E = y - L;
          L = L + E, S = S + E;
        }
        if (S > b) {
          const E = b - S;
          L = L + E, S = S + E;
        }
        _[m++] = new Im(v, L, C, S);
      }
      r[o++] = new BD(_);
    }
    let s = r[0].entries, a = [], l = 0;
    for (let u = 1, c = r.length; u < c; u++) {
      const h = r[u].entries, d = s[s.length - 1], f = h[0];
      if (d.getType() === 0 && f.getType() === 0 && f.originalLineStart <= d.originalLineEnd) {
        s[s.length - 1] = new Im(d.originalLineStart, f.originalLineEnd, d.modifiedLineStart, f.modifiedLineEnd), s = s.concat(h.slice(1));
        continue;
      }
      a[l++] = new BD(s), s = h;
    }
    return a[l++] = new BD(s), a;
  }
  _findDiffIndex(e) {
    const t = e.lineNumber;
    for (let i = 0, r = this._diffs.length; i < r; i++) {
      const o = this._diffs[i].entries, s = o[o.length - 1].modifiedLineEnd;
      if (t <= s)
        return i;
    }
    return 0;
  }
  _render() {
    const e = this._diffEditor.getOriginalEditor().getOptions(), t = this._diffEditor.getModifiedEditor().getOptions(), i = this._diffEditor.getOriginalEditor().getModel(), r = this._diffEditor.getModifiedEditor().getModel(), o = i.getOptions(), s = r.getOptions();
    if (!this._isVisible || !i || !r) {
      Ts(this._content.domNode), this._currentDiff = null, this.scrollbar.scanDomNode();
      return;
    }
    this._diffEditor.updateOptions({ readOnly: !0 });
    const a = this._findDiffIndex(this._diffEditor.getPosition());
    if (this._diffs[a] === this._currentDiff)
      return;
    this._currentDiff = this._diffs[a];
    const l = this._diffs[a].entries;
    let u = document.createElement("div");
    u.className = "diff-review-table", u.setAttribute("role", "list"), u.setAttribute("aria-label", 'Difference review. Use "Stage | Unstage | Revert Selected Ranges" commands'), io.applyFontInfoSlow(u, t.get(
      40
      /* fontInfo */
    ));
    let c = 0, h = 0, d = 0, f = 0;
    for (let S = 0, E = l.length; S < E; S++) {
      const D = l[S], O = D.originalLineStart, T = D.originalLineEnd, A = D.modifiedLineStart, P = D.modifiedLineEnd;
      O !== 0 && (c === 0 || O < c) && (c = O), T !== 0 && (h === 0 || T > h) && (h = T), A !== 0 && (d === 0 || A < d) && (d = A), P !== 0 && (f === 0 || P > f) && (f = P);
    }
    let p = document.createElement("div");
    p.className = "diff-review-row";
    let g = document.createElement("div");
    g.className = "diff-review-cell diff-review-summary";
    const _ = h - c + 1, m = f - d + 1;
    g.appendChild(document.createTextNode(`${a + 1}/${this._diffs.length}: @@ -${c},${_} +${d},${m} @@`)), p.setAttribute("data-line", String(d));
    const v = (S) => S === 0 ? w("no_lines_changed", "no lines changed") : S === 1 ? w("one_line_changed", "1 line changed") : w("more_lines_changed", "{0} lines changed", S), C = v(_), y = v(m);
    p.setAttribute("aria-label", w({
      key: "header",
      comment: [
        "This is the ARIA label for a git diff header.",
        "A git diff header looks like this: @@ -154,12 +159,39 @@.",
        "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
        "Variables 0 and 1 refer to the diff index out of total number of diffs.",
        "Variables 2 and 4 will be numbers (a line number).",
        'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
      ]
    }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", a + 1, this._diffs.length, c, C, d, y)), p.appendChild(g), p.setAttribute("role", "listitem"), u.appendChild(p);
    const b = t.get(
      56
      /* lineHeight */
    );
    let L = d;
    for (let S = 0, E = l.length; S < E; S++) {
      const D = l[S];
      Ou._renderSection(u, D, L, b, this._width, e, i, o, t, r, s), D.modifiedLineStart !== 0 && (L = D.modifiedLineEnd);
    }
    Ts(this._content.domNode), this._content.domNode.appendChild(u), this.scrollbar.scanDomNode();
  }
  static _renderSection(e, t, i, r, o, s, a, l, u, c, h) {
    const d = t.getType();
    let f = "diff-review-row", p = "";
    const g = "diff-review-spacer";
    let _ = null;
    switch (d) {
      case 1:
        f = "diff-review-row line-insert", p = " char-insert", _ = afe;
        break;
      case 2:
        f = "diff-review-row line-delete", p = " char-delete", _ = lfe;
        break;
    }
    const m = t.originalLineStart, v = t.originalLineEnd, C = t.modifiedLineStart, y = t.modifiedLineEnd, b = Math.max(y - C, v - m), L = s.get(
      128
      /* layoutInfo */
    ), S = L.glyphMarginWidth + L.lineNumbersWidth, E = u.get(
      128
      /* layoutInfo */
    ), D = 10 + E.glyphMarginWidth + E.lineNumbersWidth;
    for (let O = 0; O <= b; O++) {
      const T = m === 0 ? 0 : m + O, A = C === 0 ? 0 : C + O, P = document.createElement("div");
      P.style.minWidth = o + "px", P.className = f, P.setAttribute("role", "listitem"), A !== 0 && (i = A), P.setAttribute("data-line", String(i));
      let G = document.createElement("div");
      G.className = "diff-review-cell", G.style.height = `${r}px`, P.appendChild(G);
      const U = document.createElement("span");
      U.style.width = S + "px", U.style.minWidth = S + "px", U.className = "diff-review-line-number" + p, T !== 0 ? U.appendChild(document.createTextNode(String(T))) : U.innerText = "", G.appendChild(U);
      const $ = document.createElement("span");
      $.style.width = D + "px", $.style.minWidth = D + "px", $.style.paddingRight = "10px", $.className = "diff-review-line-number" + p, A !== 0 ? $.appendChild(document.createTextNode(String(A))) : $.innerText = "", G.appendChild($);
      const k = document.createElement("span");
      if (k.className = g, _) {
        const Ce = document.createElement("span");
        Ce.className = fa.asClassName(_), Ce.innerText = "", k.appendChild(Ce);
      } else
        k.innerText = "";
      G.appendChild(k);
      let se;
      if (A !== 0) {
        let Ce = this._renderLine(c, u, h.tabSize, A);
        Ou._ttPolicy && (Ce = Ou._ttPolicy.createHTML(Ce)), G.insertAdjacentHTML("beforeend", Ce), se = c.getLineContent(A);
      } else {
        let Ce = this._renderLine(a, s, l.tabSize, T);
        Ou._ttPolicy && (Ce = Ou._ttPolicy.createHTML(Ce)), G.insertAdjacentHTML("beforeend", Ce), se = a.getLineContent(T);
      }
      se.length === 0 && (se = w("blankLine", "blank"));
      let ne = "";
      switch (d) {
        case 0:
          T === A ? ne = w({ key: "unchangedLine", comment: ["The placeholders are contents of the line and should not be translated."] }, "{0} unchanged line {1}", se, T) : ne = w("equalLine", "{0} original line {1} modified line {2}", se, T, A);
          break;
        case 1:
          ne = w("insertLine", "+ {0} modified line {1}", se, A);
          break;
        case 2:
          ne = w("deleteLine", "- {0} original line {1}", se, T);
          break;
      }
      P.setAttribute("aria-label", ne), e.appendChild(P);
    }
  }
  static _renderLine(e, t, i, r) {
    const o = e.getLineContent(r), s = t.get(
      40
      /* fontInfo */
    ), a = Zr.createEmpty(o), l = $o.isBasicASCII(o, e.mightContainNonBasicASCII()), u = $o.containsRTL(o, l, e.mightContainRTL());
    return e0(new Sg(s.isMonospace && !t.get(
      27
      /* disableMonospaceOptimizations */
    ), s.canUseHalfwidthRightwardsArrow, o, !1, l, u, 0, a, [], i, 0, s.spaceWidth, s.middotWidth, s.wsmiddotWidth, t.get(
      103
      /* stopRenderingLineAfter */
    ), t.get(
      86
      /* renderWhitespace */
    ), t.get(
      80
      /* renderControlCharacters */
    ), t.get(
      41
      /* fontLigatures */
    ) !== fs.OFF, null)).html;
  }
}
Ou._ttPolicy = (VD = window.trustedTypes) === null || VD === void 0 ? void 0 : VD.createPolicy("diffReview", { createHTML: (n) => n });
_a((n, e) => {
  const t = n.getColor(C3);
  t && e.addRule(`.monaco-diff-editor .diff-review-line-number { color: ${t}; }`);
  const i = n.getColor(C0);
  i && e.addRule(`.monaco-diff-editor .diff-review-shadow { box-shadow: ${i} 0 -6px 6px -6px inset; }`);
});
class cfe extends G_ {
  constructor() {
    super({
      id: "editor.action.diffReview.next",
      label: w("editor.action.diffReview.next", "Go to Next Difference"),
      alias: "Go to Next Difference",
      precondition: hr.has("isInDiffEditor"),
      kbOpts: {
        kbExpr: null,
        primary: 65,
        weight: 100
        /* EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = G3(e);
    i && i.diffReviewNext();
  }
}
class hfe extends G_ {
  constructor() {
    super({
      id: "editor.action.diffReview.prev",
      label: w("editor.action.diffReview.prev", "Go to Previous Difference"),
      alias: "Go to Previous Difference",
      precondition: hr.has("isInDiffEditor"),
      kbOpts: {
        kbExpr: null,
        primary: 1089,
        weight: 100
        /* EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = G3(e);
    i && i.diffReviewPrev();
  }
}
function G3(n) {
  const e = n.get(pr), t = e.listDiffEditors(), i = e.getActiveCodeEditor();
  if (!i)
    return null;
  for (let r = 0, o = t.length; r < o; r++) {
    const s = t[r];
    if (s.getModifiedEditor().getId() === i.getId() || s.getOriginalEditor().getId() === i.getId())
      return s;
  }
  return null;
}
G5(cfe);
G5(hfe);
const xg = Vt("contextViewService"), D0 = Vt("contextMenuService");
var HD = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class dfe extends ge {
  constructor(e, t, i, r, o, s) {
    super(), this._viewZoneId = e, this._marginDomNode = t, this.editor = i, this.diff = r, this._contextMenuService = o, this._clipboardService = s, this._visibility = !1, this._marginDomNode.style.zIndex = "10", this._diffActions = document.createElement("div"), this._diffActions.className = Vi.lightBulb.classNames + " lightbulb-glyph", this._diffActions.style.position = "absolute";
    const a = i.getOption(
      56
      /* lineHeight */
    ), l = i.getModel().getEOL();
    this._diffActions.style.right = "0px", this._diffActions.style.visibility = "hidden", this._diffActions.style.height = `${a}px`, this._diffActions.style.lineHeight = `${a}px`, this._marginDomNode.appendChild(this._diffActions);
    const u = [];
    u.push(new Wl("diff.clipboard.copyDeletedContent", r.originalEndLineNumber > r.modifiedStartLineNumber ? w("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : w("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line"), void 0, !0, () => HD(this, void 0, void 0, function* () {
      const p = new V(r.originalStartLineNumber, 1, r.originalEndLineNumber + 1, 1), g = r.originalModel.getValueInRange(p);
      yield this._clipboardService.writeText(g);
    })));
    let c = 0, h;
    r.originalEndLineNumber > r.modifiedStartLineNumber && (h = new Wl("diff.clipboard.copyDeletedLineContent", w("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", r.originalStartLineNumber), void 0, !0, () => HD(this, void 0, void 0, function* () {
      const p = r.originalModel.getLineContent(r.originalStartLineNumber + c);
      yield this._clipboardService.writeText(p);
    })), u.push(h)), i.getOption(
      78
      /* readOnly */
    ) || u.push(new Wl("diff.inline.revertChange", w("diff.inline.revertChange.label", "Revert this change"), void 0, !0, () => HD(this, void 0, void 0, function* () {
      const p = new V(r.originalStartLineNumber, 1, r.originalEndLineNumber, r.originalModel.getLineMaxColumn(r.originalEndLineNumber)), g = r.originalModel.getValueInRange(p);
      if (r.modifiedEndLineNumber === 0) {
        const _ = i.getModel().getLineMaxColumn(r.modifiedStartLineNumber);
        i.executeEdits("diffEditor", [
          {
            range: new V(r.modifiedStartLineNumber, _, r.modifiedStartLineNumber, _),
            text: l + g
          }
        ]);
      } else {
        const _ = i.getModel().getLineMaxColumn(r.modifiedEndLineNumber);
        i.executeEdits("diffEditor", [
          {
            range: new V(r.modifiedStartLineNumber, 1, r.modifiedEndLineNumber, _),
            text: g
          }
        ]);
      }
    })));
    const f = (p, g) => {
      this._contextMenuService.showContextMenu({
        getAnchor: () => ({
          x: p,
          y: g
        }),
        getActions: () => (h && (h.label = w("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", r.originalStartLineNumber + c)), u),
        autoSelectFirstItem: !0
      });
    };
    this._register(Jr(this._diffActions, "mousedown", (p) => {
      const { top: g, height: _ } = ja(this._diffActions);
      let m = Math.floor(a / 3);
      p.preventDefault(), f(p.posx, g + _ + m);
    })), this._register(i.onMouseMove((p) => {
      p.target.type === 8 || p.target.type === 5 ? p.target.detail.viewZoneId === this._viewZoneId ? (this.visibility = !0, c = this._updateLightBulbPosition(this._marginDomNode, p.event.browserEvent.y, a)) : this.visibility = !1 : this.visibility = !1;
    })), this._register(i.onMouseDown((p) => {
      p.event.rightButton && (p.target.type === 8 || p.target.type === 5) && p.target.detail.viewZoneId === this._viewZoneId && (p.event.preventDefault(), c = this._updateLightBulbPosition(this._marginDomNode, p.event.browserEvent.y, a), f(p.event.posx, p.event.posy + a));
    }));
  }
  get visibility() {
    return this._visibility;
  }
  set visibility(e) {
    this._visibility !== e && (this._visibility = e, e ? this._diffActions.style.visibility = "visible" : this._diffActions.style.visibility = "hidden");
  }
  _updateLightBulbPosition(e, t, i) {
    const { top: r } = ja(e), o = t - r, s = Math.floor(o / i), a = s * i;
    if (this._diffActions.style.top = `${a}px`, this.diff.viewLineCounts) {
      let l = 0;
      for (let u = 0; u < this.diff.viewLineCounts.length; u++)
        if (l += this.diff.viewLineCounts[u], s < l)
          return u;
    }
    return s;
  }
}
const R0 = Vt("clipboardService");
class ffe {
  constructor(e) {
    this.callback = e;
  }
  report(e) {
    this._value = e, this.callback(this._value);
  }
}
ffe.None = Object.freeze({ report() {
} });
const T0 = Vt("editorProgressService");
var pfe = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, vu = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, GD;
class F2 {
  constructor(e, t) {
    this._contextMenuService = e, this._clipboardService = t, this._zones = [], this._inlineDiffMargins = [], this._zonesMap = {}, this._decorations = [];
  }
  getForeignViewZones(e) {
    return e.filter((t) => !this._zonesMap[String(t.id)]);
  }
  clean(e) {
    this._zones.length > 0 && e.changeViewZones((t) => {
      for (const i of this._zones)
        t.removeZone(i);
    }), this._zones = [], this._zonesMap = {}, this._decorations = e.deltaDecorations(this._decorations, []);
  }
  apply(e, t, i, r) {
    const o = r ? fI.capture(e) : null;
    e.changeViewZones((s) => {
      for (const a of this._zones)
        s.removeZone(a);
      for (const a of this._inlineDiffMargins)
        a.dispose();
      this._zones = [], this._zonesMap = {}, this._inlineDiffMargins = [];
      for (let a = 0, l = i.zones.length; a < l; a++) {
        const u = i.zones[a];
        u.suppressMouseDown = !0;
        const c = s.addZone(u);
        this._zones.push(c), this._zonesMap[String(c)] = !0, i.zones[a].diff && u.marginDomNode && (u.suppressMouseDown = !1, this._inlineDiffMargins.push(new dfe(c, u.marginDomNode, e, i.zones[a].diff, this._contextMenuService, this._clipboardService)));
      }
    }), o && o.restore(e), this._decorations = e.deltaDecorations(this._decorations, i.decorations), t && t.setZones(i.overviewZones);
  }
}
let gfe = 0;
const mfe = Og("diff-insert", Vi.add, w("diffInsertIcon", "Line decoration for inserts in the diff editor.")), U3 = Og("diff-remove", Vi.remove, w("diffRemoveIcon", "Line decoration for removals in the diff editor.")), k2 = (GD = window.trustedTypes) === null || GD === void 0 ? void 0 : GD.createPolicy("diffEditorWidget", { createHTML: (n) => n });
let oh = class sr extends ge {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d) {
    super(), this._editorProgressService = d, this._onDidDispose = this._register(new j()), this.onDidDispose = this._onDidDispose.event, this._onDidUpdateDiff = this._register(new j()), this.onDidUpdateDiff = this._onDidUpdateDiff.event, this._onDidContentSizeChange = this._register(new j()), this._lastOriginalWarning = null, this._lastModifiedWarning = null, this._editorWorkerService = o, this._codeEditorService = l, this._contextKeyService = this._register(s.createScoped(e)), this._instantiationService = a.createChild(new s_([Ti, this._contextKeyService])), this._contextKeyService.createKey("isInDiffEditor", !0), this._themeService = u, this._notificationService = c, this._id = ++gfe, this._state = 0, this._updatingDiffProgress = null, this._domElement = e, t = t || {}, this._renderSideBySide = !0, typeof t.renderSideBySide < "u" && (this._renderSideBySide = t.renderSideBySide), this._maxComputationTime = 5e3, typeof t.maxComputationTime < "u" && (this._maxComputationTime = t.maxComputationTime), this._ignoreTrimWhitespace = !0, typeof t.ignoreTrimWhitespace < "u" && (this._ignoreTrimWhitespace = t.ignoreTrimWhitespace), this._renderIndicators = !0, typeof t.renderIndicators < "u" && (this._renderIndicators = t.renderIndicators), this._originalIsEditable = Ge(t.originalEditable, !1), this._diffCodeLens = Ge(t.diffCodeLens, !1), this._diffWordWrap = B2(t.diffWordWrap, "inherit"), typeof t.isInEmbeddedEditor < "u" ? this._contextKeyService.createKey("isInEmbeddedDiffEditor", t.isInEmbeddedEditor) : this._contextKeyService.createKey("isInEmbeddedDiffEditor", !1), this._renderOverviewRuler = !0, typeof t.renderOverviewRuler < "u" && (this._renderOverviewRuler = !!t.renderOverviewRuler), this._updateDecorationsRunner = this._register(new to(() => this._updateDecorations(), 0)), this._containerDomElement = document.createElement("div"), this._containerDomElement.className = sr._getClassName(this._themeService.getColorTheme(), this._renderSideBySide), this._containerDomElement.style.position = "relative", this._containerDomElement.style.height = "100%", this._domElement.appendChild(this._containerDomElement), this._overviewViewportDomElement = bt(document.createElement("div")), this._overviewViewportDomElement.setClassName("diffViewport"), this._overviewViewportDomElement.setPosition("absolute"), this._overviewDomElement = document.createElement("div"), this._overviewDomElement.className = "diffOverview", this._overviewDomElement.style.position = "absolute", this._overviewDomElement.appendChild(this._overviewViewportDomElement.domNode), this._register(Jr(this._overviewDomElement, "mousedown", (p) => {
      this._modifiedEditor.delegateVerticalScrollbarMouseDown(p);
    })), this._renderOverviewRuler && this._containerDomElement.appendChild(this._overviewDomElement), this._originalDomNode = document.createElement("div"), this._originalDomNode.className = "editor original", this._originalDomNode.style.position = "absolute", this._originalDomNode.style.height = "100%", this._containerDomElement.appendChild(this._originalDomNode), this._modifiedDomNode = document.createElement("div"), this._modifiedDomNode.className = "editor modified", this._modifiedDomNode.style.position = "absolute", this._modifiedDomNode.style.height = "100%", this._containerDomElement.appendChild(this._modifiedDomNode), this._beginUpdateDecorationsTimeout = -1, this._currentlyChangingViewZones = !1, this._diffComputationToken = 0, this._originalEditorState = new F2(h, r), this._modifiedEditorState = new F2(h, r), this._isVisible = !0, this._isHandlingScrollEvent = !1, this._elementSizeObserver = this._register(new $5(this._containerDomElement, t.dimension, () => this._onDidContainerSizeChanged())), t.automaticLayout && this._elementSizeObserver.startObserving(), this._diffComputationResult = null, this._originalEditor = this._createLeftHandSideEditor(t, i.originalEditor || {}), this._modifiedEditor = this._createRightHandSideEditor(t, i.modifiedEditor || {}), this._originalOverviewRuler = null, this._modifiedOverviewRuler = null, this._reviewPane = new Ou(this), this._containerDomElement.appendChild(this._reviewPane.domNode.domNode), this._containerDomElement.appendChild(this._reviewPane.shadow.domNode), this._containerDomElement.appendChild(this._reviewPane.actionBarContainer.domNode), this._enableSplitViewResizing = !0, typeof t.enableSplitViewResizing < "u" && (this._enableSplitViewResizing = t.enableSplitViewResizing), this._renderSideBySide ? this._setStrategy(new Fu(this._createDataSource(), this._enableSplitViewResizing)) : this._setStrategy(new V2(this._createDataSource(), this._enableSplitViewResizing)), this._register(u.onDidColorThemeChange((p) => {
      this._strategy && this._strategy.applyColors(p) && this._updateDecorationsRunner.schedule(), this._containerDomElement.className = sr._getClassName(this._themeService.getColorTheme(), this._renderSideBySide);
    }));
    const f = _p.getDiffEditorContributions();
    for (const p of f)
      try {
        this._register(a.createInstance(p.ctor, this));
      } catch (g) {
        Ni(g);
      }
    this._codeEditorService.addDiffEditor(this);
  }
  _setState(e) {
    this._state !== e && (this._state = e, this._updatingDiffProgress && (this._updatingDiffProgress.done(), this._updatingDiffProgress = null), this._state === 1 && (this._updatingDiffProgress = this._editorProgressService.show(!0, 1e3)));
  }
  diffReviewNext() {
    this._reviewPane.next();
  }
  diffReviewPrev() {
    this._reviewPane.prev();
  }
  static _getClassName(e, t) {
    let i = "monaco-diff-editor monaco-editor-background ";
    return t && (i += "side-by-side "), i += Ob(e.type), i;
  }
  _recreateOverviewRulers() {
    this._renderOverviewRuler && (this._originalOverviewRuler && (this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode()), this._originalOverviewRuler.dispose()), this._originalEditor.hasModel() && (this._originalOverviewRuler = this._originalEditor.createOverviewRuler("original diffOverviewRuler"), this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode())), this._modifiedOverviewRuler && (this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode()), this._modifiedOverviewRuler.dispose()), this._modifiedEditor.hasModel() && (this._modifiedOverviewRuler = this._modifiedEditor.createOverviewRuler("modified diffOverviewRuler"), this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode())), this._layoutOverviewRulers());
  }
  _createLeftHandSideEditor(e, t) {
    const i = this._createInnerEditor(this._instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(e), t);
    this._register(i.onDidScrollChange((o) => {
      this._isHandlingScrollEvent || !o.scrollTopChanged && !o.scrollLeftChanged && !o.scrollHeightChanged || (this._isHandlingScrollEvent = !0, this._modifiedEditor.setScrollPosition({
        scrollLeft: o.scrollLeft,
        scrollTop: o.scrollTop
      }), this._isHandlingScrollEvent = !1, this._layoutOverviewViewport());
    })), this._register(i.onDidChangeViewZones(() => {
      this._onViewZonesChanged();
    })), this._register(i.onDidChangeConfiguration((o) => {
      i.getModel() && (o.hasChanged(
        40
        /* fontInfo */
      ) && this._updateDecorationsRunner.schedule(), o.hasChanged(
        129
        /* wrappingInfo */
      ) && (this._updateDecorationsRunner.cancel(), this._updateDecorations()));
    })), this._register(i.onDidChangeModelContent(() => {
      this._isVisible && this._beginUpdateDecorationsSoon();
    }));
    const r = this._contextKeyService.createKey("isInDiffLeftEditor", i.hasWidgetFocus());
    return this._register(i.onDidFocusEditorWidget(() => r.set(!0))), this._register(i.onDidBlurEditorWidget(() => r.set(!1))), this._register(i.onDidContentSizeChange((o) => {
      const s = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + sr.ONE_OVERVIEW_WIDTH, a = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: a,
        contentWidth: s,
        contentHeightChanged: o.contentHeightChanged,
        contentWidthChanged: o.contentWidthChanged
      });
    })), i;
  }
  _createRightHandSideEditor(e, t) {
    const i = this._createInnerEditor(this._instantiationService, this._modifiedDomNode, this._adjustOptionsForRightHandSide(e), t);
    this._register(i.onDidScrollChange((o) => {
      this._isHandlingScrollEvent || !o.scrollTopChanged && !o.scrollLeftChanged && !o.scrollHeightChanged || (this._isHandlingScrollEvent = !0, this._originalEditor.setScrollPosition({
        scrollLeft: o.scrollLeft,
        scrollTop: o.scrollTop
      }), this._isHandlingScrollEvent = !1, this._layoutOverviewViewport());
    })), this._register(i.onDidChangeViewZones(() => {
      this._onViewZonesChanged();
    })), this._register(i.onDidChangeConfiguration((o) => {
      i.getModel() && (o.hasChanged(
        40
        /* fontInfo */
      ) && this._updateDecorationsRunner.schedule(), o.hasChanged(
        129
        /* wrappingInfo */
      ) && (this._updateDecorationsRunner.cancel(), this._updateDecorations()));
    })), this._register(i.onDidChangeModelContent(() => {
      this._isVisible && this._beginUpdateDecorationsSoon();
    })), this._register(i.onDidChangeModelOptions((o) => {
      o.tabSize && this._updateDecorationsRunner.schedule();
    }));
    const r = this._contextKeyService.createKey("isInDiffRightEditor", i.hasWidgetFocus());
    return this._register(i.onDidFocusEditorWidget(() => r.set(!0))), this._register(i.onDidBlurEditorWidget(() => r.set(!1))), this._register(i.onDidContentSizeChange((o) => {
      const s = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + sr.ONE_OVERVIEW_WIDTH, a = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: a,
        contentWidth: s,
        contentHeightChanged: o.contentHeightChanged,
        contentWidthChanged: o.contentWidthChanged
      });
    })), i;
  }
  _createInnerEditor(e, t, i, r) {
    return e.createInstance(Kb, t, i, r);
  }
  dispose() {
    this._codeEditorService.removeDiffEditor(this), this._beginUpdateDecorationsTimeout !== -1 && (window.clearTimeout(this._beginUpdateDecorationsTimeout), this._beginUpdateDecorationsTimeout = -1), this._cleanViewZonesAndDecorations(), this._originalOverviewRuler && (this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode()), this._originalOverviewRuler.dispose()), this._modifiedOverviewRuler && (this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode()), this._modifiedOverviewRuler.dispose()), this._overviewDomElement.removeChild(this._overviewViewportDomElement.domNode), this._renderOverviewRuler && this._containerDomElement.removeChild(this._overviewDomElement), this._containerDomElement.removeChild(this._originalDomNode), this._originalEditor.dispose(), this._containerDomElement.removeChild(this._modifiedDomNode), this._modifiedEditor.dispose(), this._strategy.dispose(), this._containerDomElement.removeChild(this._reviewPane.domNode.domNode), this._containerDomElement.removeChild(this._reviewPane.shadow.domNode), this._containerDomElement.removeChild(this._reviewPane.actionBarContainer.domNode), this._reviewPane.dispose(), this._domElement.removeChild(this._containerDomElement), this._onDidDispose.fire(), super.dispose();
  }
  //------------ begin IDiffEditor methods
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return B_.IDiffEditor;
  }
  getLineChanges() {
    return this._diffComputationResult ? this._diffComputationResult.changes : null;
  }
  getOriginalEditor() {
    return this._originalEditor;
  }
  getModifiedEditor() {
    return this._modifiedEditor;
  }
  updateOptions(e) {
    let t = !1;
    typeof e.renderSideBySide < "u" && this._renderSideBySide !== e.renderSideBySide && (this._renderSideBySide = e.renderSideBySide, t = !0), typeof e.maxComputationTime < "u" && (this._maxComputationTime = e.maxComputationTime, this._isVisible && this._beginUpdateDecorationsSoon());
    let i = !1;
    typeof e.ignoreTrimWhitespace < "u" && this._ignoreTrimWhitespace !== e.ignoreTrimWhitespace && (this._ignoreTrimWhitespace = e.ignoreTrimWhitespace, i = !0), typeof e.renderIndicators < "u" && this._renderIndicators !== e.renderIndicators && (this._renderIndicators = e.renderIndicators, i = !0), i && this._beginUpdateDecorations(), this._originalIsEditable = Ge(e.originalEditable, this._originalIsEditable), this._diffCodeLens = Ge(e.diffCodeLens, this._diffCodeLens), this._diffWordWrap = B2(e.diffWordWrap, this._diffWordWrap), this._modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(e)), this._originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(e)), typeof e.enableSplitViewResizing < "u" && (this._enableSplitViewResizing = e.enableSplitViewResizing), this._strategy.setEnableSplitViewResizing(this._enableSplitViewResizing), t && (this._renderSideBySide ? this._setStrategy(new Fu(this._createDataSource(), this._enableSplitViewResizing)) : this._setStrategy(new V2(this._createDataSource(), this._enableSplitViewResizing)), this._containerDomElement.className = sr._getClassName(this._themeService.getColorTheme(), this._renderSideBySide)), typeof e.renderOverviewRuler < "u" && this._renderOverviewRuler !== e.renderOverviewRuler && (this._renderOverviewRuler = e.renderOverviewRuler, this._renderOverviewRuler ? this._containerDomElement.appendChild(this._overviewDomElement) : this._containerDomElement.removeChild(this._overviewDomElement));
  }
  getModel() {
    return {
      original: this._originalEditor.getModel(),
      modified: this._modifiedEditor.getModel()
    };
  }
  setModel(e) {
    if (e && (!e.original || !e.modified))
      throw new Error(e.original ? "DiffEditorWidget.setModel: Modified model is null" : "DiffEditorWidget.setModel: Original model is null");
    this._cleanViewZonesAndDecorations(), this._originalEditor.setModel(e ? e.original : null), this._modifiedEditor.setModel(e ? e.modified : null), this._updateDecorationsRunner.cancel(), e && (this._originalEditor.setScrollTop(0), this._modifiedEditor.setScrollTop(0)), this._diffComputationResult = null, this._diffComputationToken++, this._setState(
      0
      /* Idle */
    ), e && (this._recreateOverviewRulers(), this._beginUpdateDecorations()), this._layoutOverviewViewport();
  }
  getDomNode() {
    return this._domElement;
  }
  getVisibleColumnFromPosition(e) {
    return this._modifiedEditor.getVisibleColumnFromPosition(e);
  }
  getPosition() {
    return this._modifiedEditor.getPosition();
  }
  setPosition(e) {
    this._modifiedEditor.setPosition(e);
  }
  revealLine(e, t = 0) {
    this._modifiedEditor.revealLine(e, t);
  }
  revealLineInCenter(e, t = 0) {
    this._modifiedEditor.revealLineInCenter(e, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealLineInCenterIfOutsideViewport(e, t);
  }
  revealLineNearTop(e, t = 0) {
    this._modifiedEditor.revealLineNearTop(e, t);
  }
  revealPosition(e, t = 0) {
    this._modifiedEditor.revealPosition(e, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._modifiedEditor.revealPositionInCenter(e, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealPositionInCenterIfOutsideViewport(e, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._modifiedEditor.revealPositionNearTop(e, t);
  }
  getSelection() {
    return this._modifiedEditor.getSelection();
  }
  getSelections() {
    return this._modifiedEditor.getSelections();
  }
  setSelection(e) {
    this._modifiedEditor.setSelection(e);
  }
  setSelections(e) {
    this._modifiedEditor.setSelections(e);
  }
  revealLines(e, t, i = 0) {
    this._modifiedEditor.revealLines(e, t, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._modifiedEditor.revealLinesInCenter(e, t, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._modifiedEditor.revealLinesInCenterIfOutsideViewport(e, t, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._modifiedEditor.revealLinesNearTop(e, t, i);
  }
  revealRange(e, t = 0, i = !1, r = !0) {
    this._modifiedEditor.revealRange(e, t, i, r);
  }
  revealRangeInCenter(e, t = 0) {
    this._modifiedEditor.revealRangeInCenter(e, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealRangeInCenterIfOutsideViewport(e, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._modifiedEditor.revealRangeNearTop(e, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealRangeNearTopIfOutsideViewport(e, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._modifiedEditor.revealRangeAtTop(e, t);
  }
  getSupportedActions() {
    return this._modifiedEditor.getSupportedActions();
  }
  saveViewState() {
    const e = this._originalEditor.saveViewState(), t = this._modifiedEditor.saveViewState();
    return {
      original: e,
      modified: t
    };
  }
  restoreViewState(e) {
    if (e && e.original && e.modified) {
      const t = e;
      this._originalEditor.restoreViewState(t.original), this._modifiedEditor.restoreViewState(t.modified);
    }
  }
  layout(e) {
    this._elementSizeObserver.observe(e);
  }
  focus() {
    this._modifiedEditor.focus();
  }
  hasTextFocus() {
    return this._originalEditor.hasTextFocus() || this._modifiedEditor.hasTextFocus();
  }
  trigger(e, t, i) {
    this._modifiedEditor.trigger(e, t, i);
  }
  changeDecorations(e) {
    return this._modifiedEditor.changeDecorations(e);
  }
  //------------ end IDiffEditor methods
  //------------ begin layouting methods
  _onDidContainerSizeChanged() {
    this._doLayout();
  }
  _getReviewHeight() {
    return this._reviewPane.isVisible() ? this._elementSizeObserver.getHeight() : 0;
  }
  _layoutOverviewRulers() {
    if (!this._renderOverviewRuler || !this._originalOverviewRuler || !this._modifiedOverviewRuler)
      return;
    const e = this._elementSizeObserver.getHeight(), t = this._getReviewHeight(), i = sr.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * sr.ONE_OVERVIEW_WIDTH;
    this._modifiedEditor.getLayoutInfo() && (this._originalOverviewRuler.setLayout({
      top: 0,
      width: sr.ONE_OVERVIEW_WIDTH,
      right: i + sr.ONE_OVERVIEW_WIDTH,
      height: e - t
    }), this._modifiedOverviewRuler.setLayout({
      top: 0,
      right: 0,
      width: sr.ONE_OVERVIEW_WIDTH,
      height: e - t
    }));
  }
  //------------ end layouting methods
  _onViewZonesChanged() {
    this._currentlyChangingViewZones || this._updateDecorationsRunner.schedule();
  }
  _beginUpdateDecorationsSoon() {
    this._beginUpdateDecorationsTimeout !== -1 && (window.clearTimeout(this._beginUpdateDecorationsTimeout), this._beginUpdateDecorationsTimeout = -1), this._beginUpdateDecorationsTimeout = window.setTimeout(() => this._beginUpdateDecorations(), sr.UPDATE_DIFF_DECORATIONS_DELAY);
  }
  static _equals(e, t) {
    return !e && !t ? !0 : !e || !t ? !1 : e.toString() === t.toString();
  }
  _beginUpdateDecorations() {
    this._beginUpdateDecorationsTimeout = -1;
    const e = this._originalEditor.getModel(), t = this._modifiedEditor.getModel();
    if (!e || !t)
      return;
    this._diffComputationToken++;
    const i = this._diffComputationToken;
    if (this._setState(
      1
      /* ComputingDiff */
    ), !this._editorWorkerService.canComputeDiff(e.uri, t.uri)) {
      (!sr._equals(e.uri, this._lastOriginalWarning) || !sr._equals(t.uri, this._lastModifiedWarning)) && (this._lastOriginalWarning = e.uri, this._lastModifiedWarning = t.uri, this._notificationService.warn(w("diff.tooLarge", "Cannot compare files because one file is too large.")));
      return;
    }
    this._editorWorkerService.computeDiff(e.uri, t.uri, this._ignoreTrimWhitespace, this._maxComputationTime).then((r) => {
      i === this._diffComputationToken && e === this._originalEditor.getModel() && t === this._modifiedEditor.getModel() && (this._setState(
        2
        /* DiffComputed */
      ), this._diffComputationResult = r, this._updateDecorationsRunner.schedule(), this._onDidUpdateDiff.fire());
    }, (r) => {
      i === this._diffComputationToken && e === this._originalEditor.getModel() && t === this._modifiedEditor.getModel() && (this._setState(
        2
        /* DiffComputed */
      ), this._diffComputationResult = null, this._updateDecorationsRunner.schedule());
    });
  }
  _cleanViewZonesAndDecorations() {
    this._originalEditorState.clean(this._originalEditor), this._modifiedEditorState.clean(this._modifiedEditor);
  }
  _updateDecorations() {
    if (!this._originalEditor.getModel() || !this._modifiedEditor.getModel())
      return;
    const e = this._diffComputationResult ? this._diffComputationResult.changes : [], t = this._originalEditorState.getForeignViewZones(this._originalEditor.getWhitespaces()), i = this._modifiedEditorState.getForeignViewZones(this._modifiedEditor.getWhitespaces()), r = this._strategy.getEditorsDiffDecorations(e, this._ignoreTrimWhitespace, this._renderIndicators, t, i);
    try {
      this._currentlyChangingViewZones = !0, this._originalEditorState.apply(this._originalEditor, this._originalOverviewRuler, r.original, !1), this._modifiedEditorState.apply(this._modifiedEditor, this._modifiedOverviewRuler, r.modified, !0);
    } finally {
      this._currentlyChangingViewZones = !1;
    }
  }
  _adjustOptionsForSubEditor(e) {
    const t = Object.assign({}, e);
    return t.inDiffEditor = !0, t.automaticLayout = !1, t.scrollbar = Object.assign({}, t.scrollbar || {}), t.scrollbar.vertical = "visible", t.folding = !1, t.codeLens = this._diffCodeLens, t.fixedOverflowWidgets = !0, t.minimap = Object.assign({}, t.minimap || {}), t.minimap.enabled = !1, t;
  }
  _adjustOptionsForLeftHandSide(e) {
    const t = this._adjustOptionsForSubEditor(e);
    return this._renderSideBySide ? t.wordWrapOverride1 = this._diffWordWrap : t.wordWrapOverride1 = "off", e.originalAriaLabel && (t.ariaLabel = e.originalAriaLabel), t.readOnly = !this._originalIsEditable, t.extraEditorClassName = "original-in-monaco-diff-editor", Object.assign(Object.assign({}, t), { dimension: {
      height: 0,
      width: 0
    } });
  }
  _adjustOptionsForRightHandSide(e) {
    const t = this._adjustOptionsForSubEditor(e);
    return e.modifiedAriaLabel && (t.ariaLabel = e.modifiedAriaLabel), t.wordWrapOverride1 = this._diffWordWrap, t.revealHorizontalRightPadding = Kd.revealHorizontalRightPadding.defaultValue + sr.ENTIRE_DIFF_OVERVIEW_WIDTH, t.scrollbar.verticalHasArrows = !1, t.extraEditorClassName = "modified-in-monaco-diff-editor", Object.assign(Object.assign({}, t), { dimension: {
      height: 0,
      width: 0
    } });
  }
  doLayout() {
    this._elementSizeObserver.observe(), this._doLayout();
  }
  _doLayout() {
    const e = this._elementSizeObserver.getWidth(), t = this._elementSizeObserver.getHeight(), i = this._getReviewHeight(), r = this._strategy.layout();
    this._originalDomNode.style.width = r + "px", this._originalDomNode.style.left = "0px", this._modifiedDomNode.style.width = e - r + "px", this._modifiedDomNode.style.left = r + "px", this._overviewDomElement.style.top = "0px", this._overviewDomElement.style.height = t - i + "px", this._overviewDomElement.style.width = sr.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", this._overviewDomElement.style.left = e - sr.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", this._overviewViewportDomElement.setWidth(sr.ENTIRE_DIFF_OVERVIEW_WIDTH), this._overviewViewportDomElement.setHeight(30), this._originalEditor.layout({ width: r, height: t - i }), this._modifiedEditor.layout({ width: e - r - (this._renderOverviewRuler ? sr.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), height: t - i }), (this._originalOverviewRuler || this._modifiedOverviewRuler) && this._layoutOverviewRulers(), this._reviewPane.layout(t - i, e, i), this._layoutOverviewViewport();
  }
  _layoutOverviewViewport() {
    const e = this._computeOverviewViewport();
    e ? (this._overviewViewportDomElement.setTop(e.top), this._overviewViewportDomElement.setHeight(e.height)) : (this._overviewViewportDomElement.setTop(0), this._overviewViewportDomElement.setHeight(0));
  }
  _computeOverviewViewport() {
    const e = this._modifiedEditor.getLayoutInfo();
    if (!e)
      return null;
    const t = this._modifiedEditor.getScrollTop(), i = this._modifiedEditor.getScrollHeight(), r = Math.max(0, e.height), o = Math.max(0, r - 2 * 0), s = i > 0 ? o / i : 0, a = Math.max(0, Math.floor(e.height * s)), l = Math.floor(t * s);
    return {
      height: a,
      top: l
    };
  }
  _createDataSource() {
    return {
      getWidth: () => this._elementSizeObserver.getWidth(),
      getHeight: () => this._elementSizeObserver.getHeight() - this._getReviewHeight(),
      getOptions: () => ({
        renderOverviewRuler: this._renderOverviewRuler
      }),
      getContainerDomNode: () => this._containerDomElement,
      relayoutEditors: () => {
        this._doLayout();
      },
      getOriginalEditor: () => this._originalEditor,
      getModifiedEditor: () => this._modifiedEditor
    };
  }
  _setStrategy(e) {
    this._strategy && this._strategy.dispose(), this._strategy = e, e.applyColors(this._themeService.getColorTheme()), this._diffComputationResult && this._updateDecorations(), this._doLayout();
  }
  _getLineChangeAtOrBeforeLineNumber(e, t) {
    const i = this._diffComputationResult ? this._diffComputationResult.changes : [];
    if (i.length === 0 || e < t(i[0]))
      return null;
    let r = 0, o = i.length - 1;
    for (; r < o; ) {
      const s = Math.floor((r + o) / 2), a = t(i[s]), l = s + 1 <= o ? t(i[s + 1]) : 1073741824;
      e < a ? o = s - 1 : e >= l ? r = s + 1 : (r = s, o = s);
    }
    return i[r];
  }
  _getEquivalentLineForOriginalLineNumber(e) {
    const t = this._getLineChangeAtOrBeforeLineNumber(e, (l) => l.originalStartLineNumber);
    if (!t)
      return e;
    const i = t.originalStartLineNumber + (t.originalEndLineNumber > 0 ? -1 : 0), r = t.modifiedStartLineNumber + (t.modifiedEndLineNumber > 0 ? -1 : 0), o = t.originalEndLineNumber > 0 ? t.originalEndLineNumber - t.originalStartLineNumber + 1 : 0, s = t.modifiedEndLineNumber > 0 ? t.modifiedEndLineNumber - t.modifiedStartLineNumber + 1 : 0, a = e - i;
    return a <= o ? r + Math.min(a, s) : r + s - o + a;
  }
  _getEquivalentLineForModifiedLineNumber(e) {
    const t = this._getLineChangeAtOrBeforeLineNumber(e, (l) => l.modifiedStartLineNumber);
    if (!t)
      return e;
    const i = t.originalStartLineNumber + (t.originalEndLineNumber > 0 ? -1 : 0), r = t.modifiedStartLineNumber + (t.modifiedEndLineNumber > 0 ? -1 : 0), o = t.originalEndLineNumber > 0 ? t.originalEndLineNumber - t.originalStartLineNumber + 1 : 0, s = t.modifiedEndLineNumber > 0 ? t.modifiedEndLineNumber - t.modifiedStartLineNumber + 1 : 0, a = e - r;
    return a <= s ? i + Math.min(a, o) : i + o - s + a;
  }
  getDiffLineInformationForOriginal(e) {
    return this._diffComputationResult ? {
      equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(e)
    } : null;
  }
  getDiffLineInformationForModified(e) {
    return this._diffComputationResult ? {
      equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(e)
    } : null;
  }
};
oh.ONE_OVERVIEW_WIDTH = 15;
oh.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;
oh.UPDATE_DIFF_DECORATIONS_DELAY = 200;
oh = pfe([
  vu(3, R0),
  vu(4, tc),
  vu(5, Ti),
  vu(6, eo),
  vu(7, pr),
  vu(8, Qn),
  vu(9, tl),
  vu(10, D0),
  vu(11, T0)
], oh);
class z3 extends ge {
  constructor(e) {
    super(), this._dataSource = e, this._insertColor = null, this._removeColor = null;
  }
  applyColors(e) {
    const t = (e.getColor(h3) || MT).transparent(2), i = (e.getColor(d3) || FT).transparent(2), r = !t.equals(this._insertColor) || !i.equals(this._removeColor);
    return this._insertColor = t, this._removeColor = i, r;
  }
  getEditorsDiffDecorations(e, t, i, r, o) {
    o = o.sort((u, c) => u.afterLineNumber - c.afterLineNumber), r = r.sort((u, c) => u.afterLineNumber - c.afterLineNumber);
    const s = this._getViewZones(e, r, o, i), a = this._getOriginalEditorDecorations(e, t, i), l = this._getModifiedEditorDecorations(e, t, i);
    return {
      original: {
        decorations: a.decorations,
        overviewZones: a.overviewZones,
        zones: s.original
      },
      modified: {
        decorations: l.decorations,
        overviewZones: l.overviewZones,
        zones: s.modified
      }
    };
  }
}
class W2 {
  constructor(e) {
    this._source = e, this._index = -1, this.current = null, this.advance();
  }
  advance() {
    this._index++, this._index < this._source.length ? this.current = this._source[this._index] : this.current = null;
  }
}
class id {
  constructor(e, t, i, r, o) {
    this._lineChanges = e, this._originalForeignVZ = t, this._modifiedForeignVZ = i, this._originalEditor = r, this._modifiedEditor = o;
  }
  static _getViewLineCount(e, t, i) {
    const r = e.getModel(), o = e._getViewModel();
    if (r && o) {
      const s = a_(r, o, t, i);
      return s.endLineNumber - s.startLineNumber + 1;
    }
    return i - t + 1;
  }
  getViewZones() {
    const e = this._originalEditor.getOption(
      56
      /* lineHeight */
    ), t = this._modifiedEditor.getOption(
      56
      /* lineHeight */
    ), i = this._originalEditor.getOption(
      129
      /* wrappingInfo */
    ).wrappingColumn !== -1, r = this._modifiedEditor.getOption(
      129
      /* wrappingInfo */
    ).wrappingColumn !== -1, o = i || r, s = this._originalEditor.getModel(), a = this._originalEditor._getViewModel().coordinatesConverter, l = this._modifiedEditor._getViewModel().coordinatesConverter, u = {
      original: [],
      modified: []
    };
    let c = 0, h = 0, d = 0, f = 0, p = 0, g = 0;
    const _ = (L, S) => L.afterLineNumber - S.afterLineNumber, m = (L, S) => {
      if (S.domNode === null && L.length > 0) {
        const E = L[L.length - 1];
        if (E.afterLineNumber === S.afterLineNumber && E.domNode === null) {
          E.heightInLines += S.heightInLines;
          return;
        }
      }
      L.push(S);
    }, v = new W2(this._modifiedForeignVZ), C = new W2(this._originalForeignVZ);
    let y = 1, b = 1;
    for (let L = 0, S = this._lineChanges.length; L <= S; L++) {
      const E = L < S ? this._lineChanges[L] : null;
      E !== null ? (d = E.originalStartLineNumber + (E.originalEndLineNumber > 0 ? -1 : 0), f = E.modifiedStartLineNumber + (E.modifiedEndLineNumber > 0 ? -1 : 0), h = E.originalEndLineNumber > 0 ? id._getViewLineCount(this._originalEditor, E.originalStartLineNumber, E.originalEndLineNumber) : 0, c = E.modifiedEndLineNumber > 0 ? id._getViewLineCount(this._modifiedEditor, E.modifiedStartLineNumber, E.modifiedEndLineNumber) : 0, p = Math.max(E.originalStartLineNumber, E.originalEndLineNumber), g = Math.max(E.modifiedStartLineNumber, E.modifiedEndLineNumber)) : (d += 1e7 + h, f += 1e7 + c, p = d, g = f);
      let D = [], O = [];
      if (o) {
        let P;
        E ? E.originalEndLineNumber > 0 ? P = E.originalStartLineNumber - y : P = E.modifiedStartLineNumber - b : P = s.getLineCount() - y;
        for (let G = 0; G < P; G++) {
          const U = y + G, $ = b + G, k = a.getModelLineViewLineCount(U), se = l.getModelLineViewLineCount($);
          k < se ? D.push({
            afterLineNumber: U,
            heightInLines: se - k,
            domNode: null,
            marginDomNode: null
          }) : k > se && O.push({
            afterLineNumber: $,
            heightInLines: k - se,
            domNode: null,
            marginDomNode: null
          });
        }
        E && (y = (E.originalEndLineNumber > 0 ? E.originalEndLineNumber : E.originalStartLineNumber) + 1, b = (E.modifiedEndLineNumber > 0 ? E.modifiedEndLineNumber : E.modifiedStartLineNumber) + 1);
      }
      for (; v.current && v.current.afterLineNumber <= g; ) {
        let P;
        v.current.afterLineNumber <= f ? P = d - f + v.current.afterLineNumber : P = p;
        let G = null;
        E && E.modifiedStartLineNumber <= v.current.afterLineNumber && v.current.afterLineNumber <= E.modifiedEndLineNumber && (G = this._createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion()), D.push({
          afterLineNumber: P,
          heightInLines: v.current.height / t,
          domNode: null,
          marginDomNode: G
        }), v.advance();
      }
      for (; C.current && C.current.afterLineNumber <= p; ) {
        let P;
        C.current.afterLineNumber <= d ? P = f - d + C.current.afterLineNumber : P = g, O.push({
          afterLineNumber: P,
          heightInLines: C.current.height / e,
          domNode: null
        }), C.advance();
      }
      if (E !== null && Ep(E)) {
        const P = this._produceOriginalFromDiff(E, h, c);
        P && D.push(P);
      }
      if (E !== null && Lp(E)) {
        const P = this._produceModifiedFromDiff(E, h, c);
        P && O.push(P);
      }
      let T = 0, A = 0;
      for (D = D.sort(_), O = O.sort(_); T < D.length && A < O.length; ) {
        const P = D[T], G = O[A], U = P.afterLineNumber - d, $ = G.afterLineNumber - f;
        U < $ ? (m(u.original, P), T++) : $ < U ? (m(u.modified, G), A++) : P.shouldNotShrink ? (m(u.original, P), T++) : G.shouldNotShrink ? (m(u.modified, G), A++) : P.heightInLines >= G.heightInLines ? (P.heightInLines -= G.heightInLines, A++) : (G.heightInLines -= P.heightInLines, T++);
      }
      for (; T < D.length; )
        m(u.original, D[T]), T++;
      for (; A < O.length; )
        m(u.modified, O[A]), A++;
    }
    return {
      original: id._ensureDomNodes(u.original),
      modified: id._ensureDomNodes(u.modified)
    };
  }
  static _ensureDomNodes(e) {
    return e.map((t) => (t.domNode || (t.domNode = j3()), t));
  }
}
function xu(n, e, t, i, r) {
  return {
    range: new V(n, e, t, i),
    options: r
  };
}
const $r = {
  charDelete: Mn.register({
    description: "diff-editor-char-delete",
    className: "char-delete"
  }),
  charDeleteWholeLine: Mn.register({
    description: "diff-editor-char-delete-whole-line",
    className: "char-delete",
    isWholeLine: !0
  }),
  charInsert: Mn.register({
    description: "diff-editor-char-insert",
    className: "char-insert"
  }),
  charInsertWholeLine: Mn.register({
    description: "diff-editor-char-insert-whole-line",
    className: "char-insert",
    isWholeLine: !0
  }),
  lineInsert: Mn.register({
    description: "diff-editor-line-insert",
    className: "line-insert",
    marginClassName: "line-insert",
    isWholeLine: !0
  }),
  lineInsertWithSign: Mn.register({
    description: "diff-editor-line-insert-with-sign",
    className: "line-insert",
    linesDecorationsClassName: "insert-sign " + fa.asClassName(mfe),
    marginClassName: "line-insert",
    isWholeLine: !0
  }),
  lineDelete: Mn.register({
    description: "diff-editor-line-delete",
    className: "line-delete",
    marginClassName: "line-delete",
    isWholeLine: !0
  }),
  lineDeleteWithSign: Mn.register({
    description: "diff-editor-line-delete-with-sign",
    className: "line-delete",
    linesDecorationsClassName: "delete-sign " + fa.asClassName(U3),
    marginClassName: "line-delete",
    isWholeLine: !0
  }),
  lineDeleteMargin: Mn.register({
    description: "diff-editor-line-delete-margin",
    marginClassName: "line-delete"
  })
};
class Fu extends z3 {
  constructor(e, t) {
    super(e), this._disableSash = t === !1, this._sashRatio = null, this._sashPosition = null, this._startSashPosition = null, this._sash = this._register(new us(this._dataSource.getContainerDomNode(), this, {
      orientation: 0
      /* VERTICAL */
    })), this._disableSash && (this._sash.state = 0), this._sash.onDidStart(() => this._onSashDragStart()), this._sash.onDidChange((i) => this._onSashDrag(i)), this._sash.onDidEnd(() => this._onSashDragEnd()), this._sash.onDidReset(() => this._onSashReset());
  }
  setEnableSplitViewResizing(e) {
    const t = e === !1;
    this._disableSash !== t && (this._disableSash = t, this._sash.state = this._disableSash ? 0 : 3);
  }
  layout(e = this._sashRatio) {
    const i = this._dataSource.getWidth() - (this._dataSource.getOptions().renderOverviewRuler ? oh.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);
    let r = Math.floor((e || 0.5) * i);
    const o = Math.floor(0.5 * i);
    return r = this._disableSash ? o : r || o, i > Fu.MINIMUM_EDITOR_WIDTH * 2 ? (r < Fu.MINIMUM_EDITOR_WIDTH && (r = Fu.MINIMUM_EDITOR_WIDTH), r > i - Fu.MINIMUM_EDITOR_WIDTH && (r = i - Fu.MINIMUM_EDITOR_WIDTH)) : r = o, this._sashPosition !== r && (this._sashPosition = r, this._sash.layout()), this._sashPosition;
  }
  _onSashDragStart() {
    this._startSashPosition = this._sashPosition;
  }
  _onSashDrag(e) {
    const i = this._dataSource.getWidth() - (this._dataSource.getOptions().renderOverviewRuler ? oh.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), r = this.layout((this._startSashPosition + (e.currentX - e.startX)) / i);
    this._sashRatio = r / i, this._dataSource.relayoutEditors();
  }
  _onSashDragEnd() {
    this._sash.layout();
  }
  _onSashReset() {
    this._sashRatio = 0.5, this._dataSource.relayoutEditors(), this._sash.layout();
  }
  getVerticalSashTop(e) {
    return 0;
  }
  getVerticalSashLeft(e) {
    return this._sashPosition;
  }
  getVerticalSashHeight(e) {
    return this._dataSource.getHeight();
  }
  _getViewZones(e, t, i) {
    const r = this._dataSource.getOriginalEditor(), o = this._dataSource.getModifiedEditor();
    return new vfe(e, t, i, r, o).getViewZones();
  }
  _getOriginalEditorDecorations(e, t, i) {
    const r = this._dataSource.getOriginalEditor(), o = String(this._removeColor), s = {
      decorations: [],
      overviewZones: []
    }, a = r.getModel(), l = r._getViewModel();
    for (const u of e)
      if (Lp(u)) {
        s.decorations.push({
          range: new V(
            u.originalStartLineNumber,
            1,
            u.originalEndLineNumber,
            1073741824
            /* MAX_SAFE_SMALL_INTEGER */
          ),
          options: i ? $r.lineDeleteWithSign : $r.lineDelete
        }), (!Ep(u) || !u.charChanges) && s.decorations.push(xu(u.originalStartLineNumber, 1, u.originalEndLineNumber, 1073741824, $r.charDeleteWholeLine));
        const c = a_(a, l, u.originalStartLineNumber, u.originalEndLineNumber);
        if (s.overviewZones.push(new n_(c.startLineNumber, c.endLineNumber, o)), u.charChanges) {
          for (const h of u.charChanges)
            if (Lp(h))
              if (t)
                for (let d = h.originalStartLineNumber; d <= h.originalEndLineNumber; d++) {
                  let f, p;
                  d === h.originalStartLineNumber ? f = h.originalStartColumn : f = a.getLineFirstNonWhitespaceColumn(d), d === h.originalEndLineNumber ? p = h.originalEndColumn : p = a.getLineLastNonWhitespaceColumn(d), s.decorations.push(xu(d, f, d, p, $r.charDelete));
                }
              else
                s.decorations.push(xu(h.originalStartLineNumber, h.originalStartColumn, h.originalEndLineNumber, h.originalEndColumn, $r.charDelete));
        }
      }
    return s;
  }
  _getModifiedEditorDecorations(e, t, i) {
    const r = this._dataSource.getModifiedEditor(), o = String(this._insertColor), s = {
      decorations: [],
      overviewZones: []
    }, a = r.getModel(), l = r._getViewModel();
    for (const u of e)
      if (Ep(u)) {
        s.decorations.push({
          range: new V(
            u.modifiedStartLineNumber,
            1,
            u.modifiedEndLineNumber,
            1073741824
            /* MAX_SAFE_SMALL_INTEGER */
          ),
          options: i ? $r.lineInsertWithSign : $r.lineInsert
        }), (!Lp(u) || !u.charChanges) && s.decorations.push(xu(u.modifiedStartLineNumber, 1, u.modifiedEndLineNumber, 1073741824, $r.charInsertWholeLine));
        const c = a_(a, l, u.modifiedStartLineNumber, u.modifiedEndLineNumber);
        if (s.overviewZones.push(new n_(c.startLineNumber, c.endLineNumber, o)), u.charChanges) {
          for (const h of u.charChanges)
            if (Ep(h))
              if (t)
                for (let d = h.modifiedStartLineNumber; d <= h.modifiedEndLineNumber; d++) {
                  let f, p;
                  d === h.modifiedStartLineNumber ? f = h.modifiedStartColumn : f = a.getLineFirstNonWhitespaceColumn(d), d === h.modifiedEndLineNumber ? p = h.modifiedEndColumn : p = a.getLineLastNonWhitespaceColumn(d), s.decorations.push(xu(d, f, d, p, $r.charInsert));
                }
              else
                s.decorations.push(xu(h.modifiedStartLineNumber, h.modifiedStartColumn, h.modifiedEndLineNumber, h.modifiedEndColumn, $r.charInsert));
        }
      }
    return s;
  }
}
Fu.MINIMUM_EDITOR_WIDTH = 100;
class vfe extends id {
  constructor(e, t, i, r, o) {
    super(e, t, i, r, o);
  }
  _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
    return null;
  }
  _produceOriginalFromDiff(e, t, i) {
    return i > t ? {
      afterLineNumber: Math.max(e.originalStartLineNumber, e.originalEndLineNumber),
      heightInLines: i - t,
      domNode: null
    } : null;
  }
  _produceModifiedFromDiff(e, t, i) {
    return t > i ? {
      afterLineNumber: Math.max(e.modifiedStartLineNumber, e.modifiedEndLineNumber),
      heightInLines: t - i,
      domNode: null
    } : null;
  }
}
class V2 extends z3 {
  constructor(e, t) {
    super(e), this._decorationsLeft = e.getOriginalEditor().getLayoutInfo().decorationsLeft, this._register(e.getOriginalEditor().onDidLayoutChange((i) => {
      this._decorationsLeft !== i.decorationsLeft && (this._decorationsLeft = i.decorationsLeft, e.relayoutEditors());
    }));
  }
  setEnableSplitViewResizing(e) {
  }
  _getViewZones(e, t, i, r) {
    const o = this._dataSource.getOriginalEditor(), s = this._dataSource.getModifiedEditor();
    return new _fe(e, t, i, o, s, r).getViewZones();
  }
  _getOriginalEditorDecorations(e, t, i) {
    const r = String(this._removeColor), o = {
      decorations: [],
      overviewZones: []
    }, s = this._dataSource.getOriginalEditor(), a = s.getModel(), l = s._getViewModel();
    for (const u of e)
      if (Lp(u)) {
        o.decorations.push({
          range: new V(
            u.originalStartLineNumber,
            1,
            u.originalEndLineNumber,
            1073741824
            /* MAX_SAFE_SMALL_INTEGER */
          ),
          options: $r.lineDeleteMargin
        });
        const c = a_(a, l, u.originalStartLineNumber, u.originalEndLineNumber);
        o.overviewZones.push(new n_(c.startLineNumber, c.endLineNumber, r));
      }
    return o;
  }
  _getModifiedEditorDecorations(e, t, i) {
    const r = this._dataSource.getModifiedEditor(), o = String(this._insertColor), s = {
      decorations: [],
      overviewZones: []
    }, a = r.getModel(), l = r._getViewModel();
    for (const u of e)
      if (Ep(u)) {
        s.decorations.push({
          range: new V(
            u.modifiedStartLineNumber,
            1,
            u.modifiedEndLineNumber,
            1073741824
            /* MAX_SAFE_SMALL_INTEGER */
          ),
          options: i ? $r.lineInsertWithSign : $r.lineInsert
        });
        const c = a_(a, l, u.modifiedStartLineNumber, u.modifiedEndLineNumber);
        if (s.overviewZones.push(new n_(c.startLineNumber, c.endLineNumber, o)), u.charChanges) {
          for (const h of u.charChanges)
            if (Ep(h))
              if (t)
                for (let d = h.modifiedStartLineNumber; d <= h.modifiedEndLineNumber; d++) {
                  let f, p;
                  d === h.modifiedStartLineNumber ? f = h.modifiedStartColumn : f = a.getLineFirstNonWhitespaceColumn(d), d === h.modifiedEndLineNumber ? p = h.modifiedEndColumn : p = a.getLineLastNonWhitespaceColumn(d), s.decorations.push(xu(d, f, d, p, $r.charInsert));
                }
              else
                s.decorations.push(xu(h.modifiedStartLineNumber, h.modifiedStartColumn, h.modifiedEndLineNumber, h.modifiedEndColumn, $r.charInsert));
        } else
          s.decorations.push(xu(u.modifiedStartLineNumber, 1, u.modifiedEndLineNumber, 1073741824, $r.charInsertWholeLine));
      }
    return s;
  }
  layout() {
    return Math.max(5, this._decorationsLeft);
  }
}
class _fe extends id {
  constructor(e, t, i, r, o, s) {
    super(e, t, i, r, o), this._originalModel = r.getModel(), this._renderIndicators = s, this._pendingLineChange = [], this._pendingViewZones = [], this._lineBreaksComputer = this._modifiedEditor._getViewModel().createLineBreaksComputer();
  }
  getViewZones() {
    const e = super.getViewZones();
    return this._finalize(e), e;
  }
  _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
    const e = document.createElement("div");
    return e.className = "inline-added-margin-view-zone", e;
  }
  _produceOriginalFromDiff(e, t, i) {
    const r = document.createElement("div");
    return r.className = "inline-added-margin-view-zone", {
      afterLineNumber: Math.max(e.originalStartLineNumber, e.originalEndLineNumber),
      heightInLines: i,
      domNode: document.createElement("div"),
      marginDomNode: r
    };
  }
  _produceModifiedFromDiff(e, t, i) {
    const r = document.createElement("div");
    r.className = `view-lines line-delete ${md}`;
    const o = document.createElement("div");
    o.className = "inline-deleted-margin-view-zone";
    const s = {
      shouldNotShrink: !0,
      afterLineNumber: e.modifiedEndLineNumber === 0 ? e.modifiedStartLineNumber : e.modifiedStartLineNumber - 1,
      heightInLines: t,
      minWidthInPx: 0,
      domNode: r,
      marginDomNode: o,
      diff: {
        originalStartLineNumber: e.originalStartLineNumber,
        originalEndLineNumber: e.originalEndLineNumber,
        modifiedStartLineNumber: e.modifiedStartLineNumber,
        modifiedEndLineNumber: e.modifiedEndLineNumber,
        originalModel: this._originalModel,
        viewLineCounts: null
      }
    };
    for (let a = e.originalStartLineNumber; a <= e.originalEndLineNumber; a++)
      this._lineBreaksComputer.addRequest(this._originalModel.getLineContent(a), null);
    return this._pendingLineChange.push(e), this._pendingViewZones.push(s), s;
  }
  _finalize(e) {
    const t = this._modifiedEditor.getOptions(), i = this._modifiedEditor.getModel().getOptions().tabSize, r = t.get(
      40
      /* fontInfo */
    ), o = t.get(
      27
      /* disableMonospaceOptimizations */
    ), s = r.typicalHalfwidthCharacterWidth, a = t.get(
      91
      /* scrollBeyondLastColumn */
    ), l = this._originalModel.mightContainNonBasicASCII(), u = this._originalModel.mightContainRTL(), c = t.get(
      56
      /* lineHeight */
    ), d = t.get(
      128
      /* layoutInfo */
    ).decorationsWidth, f = t.get(
      103
      /* stopRenderingLineAfter */
    ), p = t.get(
      86
      /* renderWhitespace */
    ), g = t.get(
      80
      /* renderControlCharacters */
    ), _ = t.get(
      41
      /* fontLigatures */
    ), m = this._lineBreaksComputer.finalize();
    let v = 0;
    for (let C = 0; C < this._pendingLineChange.length; C++) {
      const y = this._pendingLineChange[C], b = this._pendingViewZones[C], L = b.domNode;
      io.applyFontInfoSlow(L, r);
      const S = b.marginDomNode;
      io.applyFontInfoSlow(S, r);
      const E = [];
      if (y.charChanges)
        for (const $ of y.charChanges)
          Lp($) && E.push(new nw(
            new V($.originalStartLineNumber, $.originalStartColumn, $.originalEndLineNumber, $.originalEndColumn),
            "char-delete",
            0
            /* Regular */
          ));
      const D = E.length > 0, O = zp(1e4);
      let T = 0, A = 0, P = null;
      for (let $ = y.originalStartLineNumber; $ <= y.originalEndLineNumber; $++) {
        const k = $ - y.originalStartLineNumber, se = this._originalModel.getLineTokens($), ne = se.getLineContent(), Ce = m[v++], ue = ha.filter(E, $, 1, ne.length + 1);
        if (Ce) {
          let B = 0;
          for (const Y of Ce.breakOffsets) {
            const x = se.sliceAndInflate(B, Y, 0), M = ne.substring(B, Y);
            T = Math.max(T, this._renderOriginalLine(A++, M, x, ha.extractWrapped(ue, B, Y), D, l, u, r, o, c, d, f, p, g, _, i, O, S)), B = Y;
          }
          for (P || (P = []); P.length < k; )
            P[P.length] = 1;
          P[k] = Ce.breakOffsets.length, b.heightInLines += Ce.breakOffsets.length - 1;
          const z = document.createElement("div");
          z.className = "line-delete", e.original.push({
            afterLineNumber: $,
            afterColumn: 0,
            heightInLines: Ce.breakOffsets.length - 1,
            domNode: j3(),
            marginDomNode: z
          });
        } else
          T = Math.max(T, this._renderOriginalLine(A++, ne, se, ue, D, l, u, r, o, c, d, f, p, g, _, i, O, S));
      }
      T += a;
      const G = O.build(), U = k2 ? k2.createHTML(G) : G;
      if (L.innerHTML = U, b.minWidthInPx = T * s, P) {
        const $ = y.originalEndLineNumber - y.originalStartLineNumber;
        for (; P.length <= $; )
          P[P.length] = 1;
      }
      b.diff.viewLineCounts = P;
    }
    e.original.sort((C, y) => C.afterLineNumber - y.afterLineNumber);
  }
  _renderOriginalLine(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g, _, m, v) {
    m.appendASCIIString('<div class="view-line'), o || m.appendASCIIString(" char-delete"), m.appendASCIIString('" style="top:'), m.appendASCIIString(String(e * c)), m.appendASCIIString('px;width:1000000px;">');
    const C = $o.isBasicASCII(t, s), y = $o.containsRTL(t, C, a), b = PN(new Sg(
      l.isMonospace && !u,
      l.canUseHalfwidthRightwardsArrow,
      t,
      !1,
      C,
      y,
      0,
      i,
      r,
      _,
      0,
      l.spaceWidth,
      l.middotWidth,
      l.wsmiddotWidth,
      d,
      f,
      p,
      g !== fs.OFF,
      null
      // Send no selections, original line cannot be selected
    ), m);
    if (m.appendASCIIString("</div>"), this._renderIndicators) {
      const S = document.createElement("div");
      S.className = `delete-sign ${fa.asClassName(U3)}`, S.setAttribute("style", `position:absolute;top:${e * c}px;width:${h}px;height:${c}px;right:0;`), v.appendChild(S);
    }
    const L = b.characterMapping.getAbsoluteOffsets();
    return L.length > 0 ? L[L.length - 1] : 0;
  }
}
function B2(n, e) {
  return hs(n, e, ["off", "on", "inherit"]);
}
function Ep(n) {
  return n.modifiedEndLineNumber > 0;
}
function Lp(n) {
  return n.originalEndLineNumber > 0;
}
function j3() {
  const n = document.createElement("div");
  return n.className = "diagonal-fill", n;
}
function a_(n, e, t, i) {
  const r = n.getLineCount();
  return t = Math.min(r, Math.max(1, t)), i = Math.min(r, Math.max(1, i)), e.coordinatesConverter.convertModelRangeToViewRange(new V(t, n.getLineMinColumn(t), i, n.getLineMaxColumn(i)));
}
_a((n, e) => {
  const t = n.getColor(h3);
  t && (e.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { background-color: ${t}; }`), e.addRule(`.monaco-diff-editor .line-insert, .monaco-diff-editor .char-insert { background-color: ${t}; }`), e.addRule(`.monaco-editor .inline-added-margin-view-zone { background-color: ${t}; }`));
  const i = n.getColor(d3);
  i && (e.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { background-color: ${i}; }`), e.addRule(`.monaco-diff-editor .line-delete, .monaco-diff-editor .char-delete { background-color: ${i}; }`), e.addRule(`.monaco-editor .inline-deleted-margin-view-zone { background-color: ${i}; }`));
  const r = n.getColor(zue);
  r && e.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { border: 1px ${n.type === "hc" ? "dashed" : "solid"} ${r}; }`);
  const o = n.getColor(jue);
  o && e.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { border: 1px ${n.type === "hc" ? "dashed" : "solid"} ${o}; }`);
  const s = n.getColor(C0);
  s && e.addRule(`.monaco-diff-editor.side-by-side .editor.modified { box-shadow: -6px 0 5px -5px ${s}; }`);
  const a = n.getColor($ue);
  a && e.addRule(`.monaco-diff-editor.side-by-side .editor.modified { border-left: 1px solid ${a}; }`);
  const l = n.getColor(sw);
  l && e.addRule(`
			.monaco-diff-editor .diffViewport {
				background: ${l};
			}
		`);
  const u = n.getColor(aw);
  u && e.addRule(`
			.monaco-diff-editor .diffViewport:hover {
				background: ${u};
			}
		`);
  const c = n.getColor(lw);
  c && e.addRule(`
			.monaco-diff-editor .diffViewport:active {
				background: ${c};
			}
		`);
  const h = n.getColor(Kue);
  e.addRule(`
	.monaco-editor .diagonal-fill {
		background-image: linear-gradient(
			-45deg,
			${h} 12.5%,
			#0000 12.5%, #0000 50%,
			${h} 50%, ${h} 62.5%,
			#0000 62.5%, #0000 100%
		);
		background-size: 8px 8px;
	}
	`);
});
const K_ = Vt("themeService"), Ro = Vt("keybindingService");
class Cfe extends ge {
  constructor() {
    super(), this._onCodeEditorAdd = this._register(new j()), this.onCodeEditorAdd = this._onCodeEditorAdd.event, this._onCodeEditorRemove = this._register(new j()), this.onCodeEditorRemove = this._onCodeEditorRemove.event, this._onDiffEditorAdd = this._register(new j()), this._onDiffEditorRemove = this._register(new j()), this._onDecorationTypeRegistered = this._register(new j()), this._modelProperties = /* @__PURE__ */ new Map(), this._codeEditors = /* @__PURE__ */ Object.create(null), this._diffEditors = /* @__PURE__ */ Object.create(null);
  }
  addCodeEditor(e) {
    this._codeEditors[e.getId()] = e, this._onCodeEditorAdd.fire(e);
  }
  removeCodeEditor(e) {
    delete this._codeEditors[e.getId()] && this._onCodeEditorRemove.fire(e);
  }
  listCodeEditors() {
    return Object.keys(this._codeEditors).map((e) => this._codeEditors[e]);
  }
  addDiffEditor(e) {
    this._diffEditors[e.getId()] = e, this._onDiffEditorAdd.fire(e);
  }
  removeDiffEditor(e) {
    delete this._diffEditors[e.getId()] && this._onDiffEditorRemove.fire(e);
  }
  listDiffEditors() {
    return Object.keys(this._diffEditors).map((e) => this._diffEditors[e]);
  }
  getFocusedCodeEditor() {
    let e = null;
    const t = this.listCodeEditors();
    for (const i of t) {
      if (i.hasTextFocus())
        return i;
      i.hasWidgetFocus() && (e = i);
    }
    return e;
  }
  setModelProperty(e, t, i) {
    const r = e.toString();
    let o;
    this._modelProperties.has(r) ? o = this._modelProperties.get(r) : (o = /* @__PURE__ */ new Map(), this._modelProperties.set(r, o)), o.set(t, i);
  }
  getModelProperty(e, t) {
    const i = e.toString();
    if (this._modelProperties.has(i))
      return this._modelProperties.get(i).get(t);
  }
}
var yfe = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, wfe = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
class bfe {
  constructor(e, t, i) {
    this._parent = e, this._editorId = t, this._styleSheet = i, this._refCount = 0;
  }
  ref() {
    this._refCount++;
  }
  unref() {
    var e;
    this._refCount--, this._refCount === 0 && ((e = this._styleSheet.parentNode) === null || e === void 0 || e.removeChild(this._styleSheet), this._parent._removeEditorStyleSheets(this._editorId));
  }
  insertRule(e, t) {
    this._styleSheet.sheet.insertRule(e, t);
  }
  removeRulesContainingSelector(e) {
    TG(e, this._styleSheet);
  }
}
class Sfe {
  constructor(e) {
    this._styleSheet = e;
  }
  ref() {
  }
  unref() {
  }
  insertRule(e, t) {
    this._styleSheet.sheet.insertRule(e, t);
  }
  removeRulesContainingSelector(e) {
    TG(e, this._styleSheet);
  }
}
let KT = class extends Cfe {
  constructor(e, t) {
    super(), this._decorationOptionProviders = /* @__PURE__ */ new Map(), this._editorStyleSheets = /* @__PURE__ */ new Map(), this._globalStyleSheet = e || null, this._themeService = t;
  }
  _getOrCreateGlobalStyleSheet() {
    return this._globalStyleSheet || (this._globalStyleSheet = new Sfe(Os())), this._globalStyleSheet;
  }
  _getOrCreateStyleSheet(e) {
    if (!e)
      return this._getOrCreateGlobalStyleSheet();
    const t = e.getContainerDomNode();
    if (!dN(t))
      return this._getOrCreateGlobalStyleSheet();
    const i = e.getId();
    if (!this._editorStyleSheets.has(i)) {
      const r = new bfe(this, i, Os(t));
      this._editorStyleSheets.set(i, r);
    }
    return this._editorStyleSheets.get(i);
  }
  _removeEditorStyleSheets(e) {
    this._editorStyleSheets.delete(e);
  }
  registerDecorationType(e, t, i, r, o) {
    let s = this._decorationOptionProviders.get(t);
    if (!s) {
      const a = this._getOrCreateStyleSheet(o), l = {
        styleSheet: a,
        key: t,
        parentTypeKey: r,
        options: i || /* @__PURE__ */ Object.create(null)
      };
      r ? s = new Efe(this._themeService, a, l) : s = new Lfe(e, this._themeService, a, l), this._decorationOptionProviders.set(t, s), this._onDecorationTypeRegistered.fire(t);
    }
    s.refCount++;
  }
  removeDecorationType(e) {
    const t = this._decorationOptionProviders.get(e);
    t && (t.refCount--, t.refCount <= 0 && (this._decorationOptionProviders.delete(e), t.dispose(), this.listCodeEditors().forEach((i) => i.removeDecorations(e))));
  }
  resolveDecorationOptions(e, t) {
    const i = this._decorationOptionProviders.get(e);
    if (!i)
      throw new Error("Unknown decoration type key: " + e);
    return i.getOptions(this, t);
  }
};
KT = yfe([
  wfe(1, Qn)
], KT);
class Efe {
  constructor(e, t, i) {
    this._styleSheet = t, this._styleSheet.ref(), this._parentTypeKey = i.parentTypeKey, this.refCount = 0, this._beforeContentRules = new Yb(3, i, e), this._afterContentRules = new Yb(4, i, e);
  }
  getOptions(e, t) {
    const i = e.resolveDecorationOptions(this._parentTypeKey, !0);
    return this._beforeContentRules && (i.beforeContentClassName = this._beforeContentRules.className), this._afterContentRules && (i.afterContentClassName = this._afterContentRules.className), i;
  }
  dispose() {
    this._beforeContentRules && (this._beforeContentRules.dispose(), this._beforeContentRules = null), this._afterContentRules && (this._afterContentRules.dispose(), this._afterContentRules = null), this._styleSheet.unref();
  }
}
class Lfe {
  constructor(e, t, i, r) {
    this._disposables = new ht(), this.description = e, this._styleSheet = i, this._styleSheet.ref(), this.refCount = 0;
    const o = (h) => {
      const d = new Yb(h, r, t);
      if (this._disposables.add(d), d.hasContent)
        return d.className;
    }, s = (h) => {
      const d = new Yb(h, r, t);
      return this._disposables.add(d), d.hasContent ? { className: d.className, hasLetterSpacing: d.hasLetterSpacing } : null;
    };
    this.className = o(
      0
      /* ClassName */
    );
    const a = s(
      1
      /* InlineClassName */
    );
    a && (this.inlineClassName = a.className, this.inlineClassNameAffectsLetterSpacing = a.hasLetterSpacing), this.beforeContentClassName = o(
      3
      /* BeforeContentClassName */
    ), this.afterContentClassName = o(
      4
      /* AfterContentClassName */
    ), this.glyphMarginClassName = o(
      2
      /* GlyphMarginClassName */
    );
    const l = r.options;
    this.isWholeLine = !!l.isWholeLine, this.stickiness = l.rangeBehavior;
    const u = l.light && l.light.overviewRulerColor || l.overviewRulerColor, c = l.dark && l.dark.overviewRulerColor || l.overviewRulerColor;
    (typeof u < "u" || typeof c < "u") && (this.overviewRuler = {
      color: u || c,
      darkColor: c || u,
      position: l.overviewRulerLane || Uv.Center
    });
  }
  getOptions(e, t) {
    return t ? {
      description: this.description,
      inlineClassName: this.inlineClassName,
      beforeContentClassName: this.beforeContentClassName,
      afterContentClassName: this.afterContentClassName,
      className: this.className,
      glyphMarginClassName: this.glyphMarginClassName,
      isWholeLine: this.isWholeLine,
      overviewRuler: this.overviewRuler,
      stickiness: this.stickiness
    } : this;
  }
  dispose() {
    this._disposables.dispose(), this._styleSheet.unref();
  }
}
const Pm = {
  color: "color:{0} !important;",
  opacity: "opacity:{0};",
  backgroundColor: "background-color:{0};",
  outline: "outline:{0};",
  outlineColor: "outline-color:{0};",
  outlineStyle: "outline-style:{0};",
  outlineWidth: "outline-width:{0};",
  border: "border:{0};",
  borderColor: "border-color:{0};",
  borderRadius: "border-radius:{0};",
  borderSpacing: "border-spacing:{0};",
  borderStyle: "border-style:{0};",
  borderWidth: "border-width:{0};",
  fontStyle: "font-style:{0};",
  fontWeight: "font-weight:{0};",
  fontSize: "font-size:{0};",
  fontFamily: "font-family:{0};",
  textDecoration: "text-decoration:{0};",
  cursor: "cursor:{0};",
  letterSpacing: "letter-spacing:{0};",
  gutterIconPath: "background:{0} center center no-repeat;",
  gutterIconSize: "background-size:{0};",
  contentText: "content:'{0}';",
  contentIconPath: "content:{0};",
  margin: "margin:{0};",
  padding: "padding:{0};",
  width: "width:{0};",
  height: "height:{0};"
};
class Yb {
  constructor(e, t, i) {
    this._theme = i.getColorTheme(), this._ruleType = e, this._providerArgs = t, this._usesThemeColors = !1, this._hasContent = !1, this._hasLetterSpacing = !1;
    let r = UD.getClassName(this._providerArgs.key, e);
    this._providerArgs.parentTypeKey && (r = r + " " + UD.getClassName(this._providerArgs.parentTypeKey, e)), this._className = r, this._unThemedSelector = UD.getSelector(this._providerArgs.key, this._providerArgs.parentTypeKey, e), this._buildCSS(), this._usesThemeColors ? this._themeListener = i.onDidColorThemeChange((o) => {
      this._theme = i.getColorTheme(), this._removeCSS(), this._buildCSS();
    }) : this._themeListener = null;
  }
  dispose() {
    this._hasContent && (this._removeCSS(), this._hasContent = !1), this._themeListener && (this._themeListener.dispose(), this._themeListener = null);
  }
  get hasContent() {
    return this._hasContent;
  }
  get hasLetterSpacing() {
    return this._hasLetterSpacing;
  }
  get className() {
    return this._className;
  }
  _buildCSS() {
    const e = this._providerArgs.options;
    let t, i, r;
    switch (this._ruleType) {
      case 0:
        t = this.getCSSTextForModelDecorationClassName(e), i = this.getCSSTextForModelDecorationClassName(e.light), r = this.getCSSTextForModelDecorationClassName(e.dark);
        break;
      case 1:
        t = this.getCSSTextForModelDecorationInlineClassName(e), i = this.getCSSTextForModelDecorationInlineClassName(e.light), r = this.getCSSTextForModelDecorationInlineClassName(e.dark);
        break;
      case 2:
        t = this.getCSSTextForModelDecorationGlyphMarginClassName(e), i = this.getCSSTextForModelDecorationGlyphMarginClassName(e.light), r = this.getCSSTextForModelDecorationGlyphMarginClassName(e.dark);
        break;
      case 3:
        t = this.getCSSTextForModelDecorationContentClassName(e.before), i = this.getCSSTextForModelDecorationContentClassName(e.light && e.light.before), r = this.getCSSTextForModelDecorationContentClassName(e.dark && e.dark.before);
        break;
      case 4:
        t = this.getCSSTextForModelDecorationContentClassName(e.after), i = this.getCSSTextForModelDecorationContentClassName(e.light && e.light.after), r = this.getCSSTextForModelDecorationContentClassName(e.dark && e.dark.after);
        break;
      default:
        throw new Error("Unknown rule type: " + this._ruleType);
    }
    const o = this._providerArgs.styleSheet;
    let s = !1;
    t.length > 0 && (o.insertRule(`${this._unThemedSelector} {${t}}`, 0), s = !0), i.length > 0 && (o.insertRule(`.vs${this._unThemedSelector} {${i}}`, 0), s = !0), r.length > 0 && (o.insertRule(`.vs-dark${this._unThemedSelector}, .hc-black${this._unThemedSelector} {${r}}`, 0), s = !0), this._hasContent = s;
  }
  _removeCSS() {
    this._providerArgs.styleSheet.removeRulesContainingSelector(this._unThemedSelector);
  }
  /**
   * Build the CSS for decorations styled via `className`.
   */
  getCSSTextForModelDecorationClassName(e) {
    if (!e)
      return "";
    const t = [];
    return this.collectCSSText(e, ["backgroundColor"], t), this.collectCSSText(e, ["outline", "outlineColor", "outlineStyle", "outlineWidth"], t), this.collectBorderSettingsCSSText(e, t), t.join("");
  }
  /**
   * Build the CSS for decorations styled via `inlineClassName`.
   */
  getCSSTextForModelDecorationInlineClassName(e) {
    if (!e)
      return "";
    const t = [];
    return this.collectCSSText(e, ["fontStyle", "fontWeight", "textDecoration", "cursor", "color", "opacity", "letterSpacing"], t), e.letterSpacing && (this._hasLetterSpacing = !0), t.join("");
  }
  /**
   * Build the CSS for decorations styled before or after content.
   */
  getCSSTextForModelDecorationContentClassName(e) {
    if (!e)
      return "";
    const t = [];
    if (typeof e < "u") {
      if (this.collectBorderSettingsCSSText(e, t), typeof e.contentIconPath < "u" && t.push(xl(Pm.contentIconPath, Hv(dt.revive(e.contentIconPath)))), typeof e.contentText == "string") {
        const r = e.contentText.match(/^.*$/m)[0].replace(/['\\]/g, "\\$&");
        t.push(xl(Pm.contentText, r));
      }
      this.collectCSSText(e, ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textDecoration", "color", "opacity", "backgroundColor", "margin", "padding"], t), this.collectCSSText(e, ["width", "height"], t) && t.push("display:inline-block;");
    }
    return t.join("");
  }
  /**
   * Build the CSS for decorations styled via `glpyhMarginClassName`.
   */
  getCSSTextForModelDecorationGlyphMarginClassName(e) {
    if (!e)
      return "";
    const t = [];
    return typeof e.gutterIconPath < "u" && (t.push(xl(Pm.gutterIconPath, Hv(dt.revive(e.gutterIconPath)))), typeof e.gutterIconSize < "u" && t.push(xl(Pm.gutterIconSize, e.gutterIconSize))), t.join("");
  }
  collectBorderSettingsCSSText(e, t) {
    return this.collectCSSText(e, ["border", "borderColor", "borderRadius", "borderSpacing", "borderStyle", "borderWidth"], t) ? (t.push(xl("box-sizing: border-box;")), !0) : !1;
  }
  collectCSSText(e, t, i) {
    const r = i.length;
    for (let o of t) {
      const s = this.resolveValue(e[o]);
      typeof s == "string" && i.push(xl(Pm[o], s));
    }
    return i.length !== r;
  }
  resolveValue(e) {
    if (Wre(e)) {
      this._usesThemeColors = !0;
      const t = this._theme.getColor(e.id);
      return t ? t.toString() : "transparent";
    }
    return e;
  }
}
class UD {
  static getClassName(e, t) {
    return "ced-" + e + "-" + t;
  }
  static getSelector(e, t, i) {
    let r = ".monaco-editor ." + this.getClassName(e, i);
    return t && (r = r + "." + this.getClassName(t, i)), i === 3 ? r += "::before" : i === 4 && (r += "::after"), r;
  }
}
var Dfe = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, H2 = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let Xb = class extends KT {
  constructor(e, t, i) {
    super(e, i), this.onCodeEditorAdd(() => this._checkContextKey()), this.onCodeEditorRemove(() => this._checkContextKey()), this._editorIsOpen = t.createKey("editorIsOpen", !1), this._activeCodeEditor = null;
  }
  _checkContextKey() {
    let e = !1;
    for (const t of this.listCodeEditors())
      if (!t.isSimpleWidget) {
        e = !0;
        break;
      }
    this._editorIsOpen.set(e);
  }
  setActiveCodeEditor(e) {
    this._activeCodeEditor = e;
  }
  getActiveCodeEditor() {
    return this._activeCodeEditor;
  }
  openCodeEditor(e, t, i) {
    return t ? Promise.resolve(this.doOpenEditor(t, e)) : Promise.resolve(null);
  }
  doOpenEditor(e, t) {
    if (!this.findModel(e, t.resource)) {
      if (t.resource) {
        const o = t.resource.scheme;
        if (o === vi.http || o === vi.https)
          return IG(t.resource.toString()), e;
      }
      return null;
    }
    const r = t.options ? t.options.selection : null;
    if (r)
      if (typeof r.endLineNumber == "number" && typeof r.endColumn == "number")
        e.setSelection(r), e.revealRangeInCenter(
          r,
          1
          /* Immediate */
        );
      else {
        const o = {
          lineNumber: r.startLineNumber,
          column: r.startColumn
        };
        e.setPosition(o), e.revealPositionInCenter(
          o,
          1
          /* Immediate */
        );
      }
    return e;
  }
  findModel(e, t) {
    const i = e.getModel();
    return i && i.uri.toString() !== t.toString() ? null : i;
  }
};
Xb = Dfe([
  H2(1, Ti),
  H2(2, Qn)
], Xb);
var pI = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, ci = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let Rfe = 0, G2 = !1;
function Tfe() {
  G2 || (G2 = !0, Oae(document.body));
}
let Zb = class extends Kb {
  constructor(e, t, i, r, o, s, a, l, u, c) {
    const h = Object.assign({}, t);
    h.ariaLabel = h.ariaLabel || Eb.editorViewAccessibleLabel, h.ariaLabel = h.ariaLabel + ";" + Eb.accessibilityHelpMessage, super(e, h, {}, i, r, o, s, l, u, c), a instanceof I5 ? this._standaloneKeybindingService = a : this._standaloneKeybindingService = null, Tfe();
  }
  addCommand(e, t, i) {
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService"), null;
    let r = "DYNAMIC_" + ++Rfe, o = hr.deserialize(i);
    return this._standaloneKeybindingService.addDynamicKeybinding(r, e, t, o), r;
  }
  createContextKey(e, t) {
    return this._contextKeyService.createKey(e, t);
  }
  addAction(e) {
    if (typeof e.id != "string" || typeof e.label != "string" || typeof e.run != "function")
      throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), ge.None;
    const t = e.id, i = e.label, r = hr.and(hr.equals("editorId", this.getId()), hr.deserialize(e.precondition)), o = e.keybindings, s = hr.and(r, hr.deserialize(e.keybindingContext)), a = e.contextMenuGroupId || null, l = e.contextMenuOrder || 0, u = (f, ...p) => Promise.resolve(e.run(this, ...p)), c = new ht(), h = this.getId() + ":" + t;
    if (c.add(Xn.registerCommand(h, u)), a) {
      let f = {
        command: {
          id: h,
          title: i
        },
        when: r,
        group: a,
        order: l
      };
      c.add(dv.appendMenuItem(si.EditorContext, f));
    }
    if (Array.isArray(o))
      for (const f of o)
        c.add(this._standaloneKeybindingService.addDynamicKeybinding(h, f, u, s));
    let d = new x3(h, i, i, r, u, this._contextKeyService);
    return this._actions[t] = d, c.add(Ri(() => {
      delete this._actions[t];
    })), c;
  }
  _triggerCommand(e, t) {
    if (this._codeEditorService instanceof Xb)
      try {
        this._codeEditorService.setActiveCodeEditor(this), super._triggerCommand(e, t);
      } finally {
        this._codeEditorService.setActiveCodeEditor(null);
      }
    else
      super._triggerCommand(e, t);
  }
};
Zb = pI([
  ci(2, eo),
  ci(3, pr),
  ci(4, Ko),
  ci(5, Ti),
  ci(6, Ro),
  ci(7, Qn),
  ci(8, tl),
  ci(9, Is)
], Zb);
let qT = class extends Zb {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g) {
    const _ = Object.assign({}, t);
    Lb(d, _, !1);
    const m = c.registerEditorContainer(e);
    typeof _.theme == "string" && c.setTheme(_.theme), typeof _.autoDetectHighContrast < "u" && c.setAutoDetectHighContrast(!!_.autoDetectHighContrast);
    let v = _.model;
    delete _.model, super(e, _, r, o, s, a, l, c, h, f), this._contextViewService = u, this._configurationService = d, this._standaloneThemeService = c, this._register(i), this._register(m);
    let C;
    if (typeof v > "u" ? (C = $3(p, g, _.value || "", _.language || "text/plain", void 0), this._ownsModel = !0) : (C = v, this._ownsModel = !1), this._attachModel(C), C) {
      let y = {
        oldModelUrl: null,
        newModelUrl: C.uri
      };
      this._onDidChangeModel.fire(y);
    }
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    Lb(this._configurationService, e, !1), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _attachModel(e) {
    super._attachModel(e), this._modelData && this._contextViewService.setContainer(this._modelData.view.domNode.domNode);
  }
  _postDetachModelCleanup(e) {
    super._postDetachModelCleanup(e), e && this._ownsModel && (e.dispose(), this._ownsModel = !1);
  }
};
qT = pI([
  ci(3, eo),
  ci(4, pr),
  ci(5, Ko),
  ci(6, Ti),
  ci(7, Ro),
  ci(8, xg),
  ci(9, K_),
  ci(10, tl),
  ci(11, mr),
  ci(12, Is),
  ci(13, ro),
  ci(14, TN)
], qT);
let YT = class extends oh {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g) {
    const _ = Object.assign({}, t);
    Lb(d, _, !0);
    const m = c.registerEditorContainer(e);
    typeof _.theme == "string" && c.setTheme(_.theme), typeof _.autoDetectHighContrast < "u" && c.setAutoDetectHighContrast(!!_.autoDetectHighContrast), super(e, _, {}, g, l, o, r, u, c, h, f, p), this._contextViewService = a, this._configurationService = d, this._standaloneThemeService = c, this._register(i), this._register(m), this._contextViewService.setContainer(this._containerDomElement);
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    Lb(this._configurationService, e, !0), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _createInnerEditor(e, t, i) {
    return e.createInstance(Zb, t, i);
  }
  getOriginalEditor() {
    return super.getOriginalEditor();
  }
  getModifiedEditor() {
    return super.getModifiedEditor();
  }
  addCommand(e, t, i) {
    return this.getModifiedEditor().addCommand(e, t, i);
  }
  createContextKey(e, t) {
    return this.getModifiedEditor().createContextKey(e, t);
  }
  addAction(e) {
    return this.getModifiedEditor().addAction(e);
  }
};
YT = pI([
  ci(3, eo),
  ci(4, Ti),
  ci(5, Ro),
  ci(6, xg),
  ci(7, tc),
  ci(8, pr),
  ci(9, K_),
  ci(10, tl),
  ci(11, mr),
  ci(12, D0),
  ci(13, T0),
  ci(14, R0)
], YT);
function $3(n, e, t, i, r) {
  if (t = t || "", !i) {
    const o = t.indexOf(`
`);
    let s = t;
    return o !== -1 && (s = t.substring(0, o)), U2(n, t, e.createByFilepathOrFirstLine(r || null, s), r);
  }
  return U2(n, t, e.create(i), r);
}
function U2(n, e, t, i) {
  return n.createModel(e, t, i);
}
class Ofe {
  constructor(e) {
    this._languageIdentifier = e;
  }
  getId() {
    return this._languageIdentifier.language;
  }
}
const zD = "text/plain", z2 = "application/unknown";
let Qb = [], K3 = [], q3 = [];
function Ty(n, e = !1) {
  const t = xfe(n);
  Qb.push(t), t.userConfigured ? q3.push(t) : K3.push(t), e && !t.userConfigured && Qb.forEach((i) => {
    i.mime === t.mime || i.userConfigured || (t.extension && i.extension === t.extension && console.warn(`Overwriting extension <<${t.extension}>> to now point to mime <<${t.mime}>>`), t.filename && i.filename === t.filename && console.warn(`Overwriting filename <<${t.filename}>> to now point to mime <<${t.mime}>>`), t.filepattern && i.filepattern === t.filepattern && console.warn(`Overwriting filepattern <<${t.filepattern}>> to now point to mime <<${t.mime}>>`), t.firstline && i.firstline === t.firstline && console.warn(`Overwriting firstline <<${t.firstline}>> to now point to mime <<${t.mime}>>`));
  });
}
function xfe(n) {
  return {
    id: n.id,
    mime: n.mime,
    filename: n.filename,
    extension: n.extension,
    filepattern: n.filepattern,
    firstline: n.firstline,
    userConfigured: n.userConfigured,
    filenameLowercase: n.filename ? n.filename.toLowerCase() : void 0,
    extensionLowercase: n.extension ? n.extension.toLowerCase() : void 0,
    filepatternLowercase: n.filepattern ? n.filepattern.toLowerCase() : void 0,
    filepatternOnPath: n.filepattern ? n.filepattern.indexOf(mn.sep) >= 0 : !1
  };
}
function Nfe(n, e) {
  let t;
  if (n)
    switch (n.scheme) {
      case vi.file:
        t = n.fsPath;
        break;
      case vi.data:
        t = sb.parseMetaData(n).get(sb.META_DATA_LABEL);
        break;
      default:
        t = n.path;
    }
  if (!t)
    return [z2];
  t = t.toLowerCase();
  const i = uG(t), r = j2(t, i, q3);
  if (r)
    return [r, zD];
  const o = j2(t, i, K3);
  if (o)
    return [o, zD];
  if (e) {
    const s = Ife(e);
    if (s)
      return [s, zD];
  }
  return [z2];
}
function j2(n, e, t) {
  let i = null, r = null, o = null;
  for (let s = t.length - 1; s >= 0; s--) {
    const a = t[s];
    if (e === a.filenameLowercase) {
      i = a;
      break;
    }
    if (a.filepattern && (!r || a.filepattern.length > r.filepattern.length)) {
      const l = a.filepatternOnPath ? n : e;
      $G(a.filepatternLowercase, l) && (r = a);
    }
    a.extension && (!o || a.extension.length > o.extension.length) && e.endsWith(a.extensionLowercase) && (o = a);
  }
  return i ? i.mime : r ? r.mime : o ? o.mime : null;
}
function Ife(n) {
  if (CN(n) && (n = n.substr(1)), n.length > 0)
    for (let e = Qb.length - 1; e >= 0; e--) {
      const t = Qb[e];
      if (!t.firstline)
        continue;
      const i = n.match(t.firstline);
      if (i && i.length > 0)
        return t.mime;
    }
  return null;
}
const Pfe = {
  ModesRegistry: "editor.modesRegistry"
};
class Afe {
  constructor() {
    this._onDidChangeLanguages = new j(), this.onDidChangeLanguages = this._onDidChangeLanguages.event, this._languages = [], this._dynamicLanguages = [];
  }
  // --- languages
  registerLanguage(e) {
    return this._languages.push(e), this._onDidChangeLanguages.fire(void 0), {
      dispose: () => {
        for (let t = 0, i = this._languages.length; t < i; t++)
          if (this._languages[t] === e) {
            this._languages.splice(t, 1);
            return;
          }
      }
    };
  }
  getLanguages() {
    return [].concat(this._languages).concat(this._dynamicLanguages);
  }
}
const vd = new Afe();
Zn.add(Pfe.ModesRegistry, vd);
const Y3 = "plaintext", Mfe = ".txt", X3 = new DN(
  Y3,
  1
  /* PlainText */
);
vd.registerLanguage({
  id: Y3,
  extensions: [Mfe],
  aliases: [w("plainText.alias", "Plain Text"), "text"],
  mimetypes: ["text/plain"]
});
ui.register(X3, {
  brackets: [
    ["(", ")"],
    ["[", "]"],
    ["{", "}"]
  ],
  surroundingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: "<", close: ">" },
    { open: '"', close: '"' },
    { open: "'", close: "'" },
    { open: "`", close: "`" }
  ],
  folding: {
    offSide: !0
  }
}, 0);
const Mh = Object.prototype.hasOwnProperty;
class Ffe extends ge {
  constructor(e = !0, t = !1) {
    super(), this._onDidChange = this._register(new j()), this.onDidChange = this._onDidChange.event, this._warnOnOverwrite = t, this._nextLanguageId2 = 1, this._languageIdToLanguage = [], this._languageToLanguageId = /* @__PURE__ */ Object.create(null), this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, e && (this._initializeFromRegistry(), this._register(vd.onDidChangeLanguages((i) => this._initializeFromRegistry())));
  }
  _initializeFromRegistry() {
    this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {};
    const e = vd.getLanguages();
    this._registerLanguages(e);
  }
  _registerLanguages(e) {
    for (const t of e)
      this._registerLanguage(t);
    this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Object.keys(this._languages).forEach((t) => {
      let i = this._languages[t];
      i.name && (this._nameMap[i.name] = i.identifier), i.aliases.forEach((r) => {
        this._lowercaseNameMap[r.toLowerCase()] = i.identifier;
      }), i.mimetypes.forEach((r) => {
        this._mimeTypesMap[r] = i.identifier;
      });
    }), Zn.as(Eg.Configuration).registerOverrideIdentifiers(vd.getLanguages().map((t) => t.id)), this._onDidChange.fire();
  }
  _getLanguageId(e) {
    if (this._languageToLanguageId[e])
      return this._languageToLanguageId[e];
    const t = this._nextLanguageId2++;
    return this._languageIdToLanguage[t] = e, this._languageToLanguageId[e] = t, t;
  }
  _registerLanguage(e) {
    const t = e.id;
    let i;
    if (Mh.call(this._languages, t))
      i = this._languages[t];
    else {
      const r = this._getLanguageId(t);
      i = {
        identifier: new DN(t, r),
        name: null,
        mimetypes: [],
        aliases: [],
        extensions: [],
        filenames: [],
        configurationFiles: []
      }, this._languages[t] = i;
    }
    this._mergeLanguage(i, e);
  }
  _mergeLanguage(e, t) {
    const i = t.id;
    let r = null;
    if (Array.isArray(t.mimetypes) && t.mimetypes.length > 0 && (e.mimetypes.push(...t.mimetypes), r = t.mimetypes[0]), r || (r = `text/x-${i}`, e.mimetypes.push(r)), Array.isArray(t.extensions)) {
      t.configuration ? e.extensions = t.extensions.concat(e.extensions) : e.extensions = e.extensions.concat(t.extensions);
      for (let a of t.extensions)
        Ty({ id: i, mime: r, extension: a }, this._warnOnOverwrite);
    }
    if (Array.isArray(t.filenames))
      for (let a of t.filenames)
        Ty({ id: i, mime: r, filename: a }, this._warnOnOverwrite), e.filenames.push(a);
    if (Array.isArray(t.filenamePatterns))
      for (let a of t.filenamePatterns)
        Ty({ id: i, mime: r, filepattern: a }, this._warnOnOverwrite);
    if (typeof t.firstLine == "string" && t.firstLine.length > 0) {
      let a = t.firstLine;
      a.charAt(0) !== "^" && (a = "^" + a);
      try {
        let l = new RegExp(a);
        ere(l) || Ty({ id: i, mime: r, firstline: l }, this._warnOnOverwrite);
      } catch (l) {
        Ni(l);
      }
    }
    e.aliases.push(i);
    let o = null;
    if (typeof t.aliases < "u" && Array.isArray(t.aliases) && (t.aliases.length === 0 ? o = [null] : o = t.aliases), o !== null)
      for (const a of o)
        !a || a.length === 0 || e.aliases.push(a);
    let s = o !== null && o.length > 0;
    if (!(s && o[0] === null)) {
      let a = (s ? o[0] : null) || i;
      (s || !e.name) && (e.name = a);
    }
    t.configuration && e.configurationFiles.push(t.configuration);
  }
  isRegisteredMode(e) {
    return Mh.call(this._mimeTypesMap, e) ? !0 : Mh.call(this._languages, e);
  }
  getModeIdForLanguageNameLowercase(e) {
    return Mh.call(this._lowercaseNameMap, e) ? this._lowercaseNameMap[e].language : null;
  }
  extractModeIds(e) {
    return e ? e.split(",").map((t) => t.trim()).map((t) => Mh.call(this._mimeTypesMap, t) ? this._mimeTypesMap[t].language : t).filter((t) => Mh.call(this._languages, t)) : [];
  }
  getLanguageIdentifier(e) {
    if (e === RN || e === 0)
      return fb;
    let t;
    if (typeof e == "string")
      t = e;
    else if (t = this._languageIdToLanguage[e], !t)
      return null;
    return Mh.call(this._languages, t) ? this._languages[t].identifier : null;
  }
  getModeIdsFromFilepathOrFirstLine(e, t) {
    if (!e && !t)
      return [];
    let i = Nfe(e, t);
    return this.extractModeIds(i.join(","));
  }
}
class $2 {
  constructor(e, t) {
    this._selector = t, this.languageIdentifier = this._selector();
    let i;
    this._onDidChange = new j({
      onFirstListenerAdd: () => {
        i = e(() => this._evaluate());
      },
      onLastListenerRemove: () => {
        i.dispose();
      }
    }), this.onDidChange = this._onDidChange.event;
  }
  _evaluate() {
    let e = this._selector();
    e.id !== this.languageIdentifier.id && (this.languageIdentifier = e, this._onDidChange.fire(this.languageIdentifier));
  }
}
class kfe extends ge {
  constructor(e = !1) {
    super(), this._onDidCreateMode = this._register(new j()), this.onDidCreateMode = this._onDidCreateMode.event, this._onLanguagesMaybeChanged = this._register(new j({
      leakWarningThreshold: 200
      /* https://github.com/microsoft/vscode/issues/119968 */
    })), this.onLanguagesMaybeChanged = this._onLanguagesMaybeChanged.event, this._instantiatedModes = {}, this._registry = this._register(new Ffe(!0, e)), this._register(this._registry.onDidChange(() => this._onLanguagesMaybeChanged.fire()));
  }
  isRegisteredMode(e) {
    return this._registry.isRegisteredMode(e);
  }
  getModeIdForLanguageName(e) {
    return this._registry.getModeIdForLanguageNameLowercase(e);
  }
  getModeIdByFilepathOrFirstLine(e, t) {
    const i = this._registry.getModeIdsFromFilepathOrFirstLine(e, t);
    return yT(i, null);
  }
  getModeId(e) {
    const t = this._registry.extractModeIds(e);
    return yT(t, null);
  }
  getLanguageIdentifier(e) {
    return this._registry.getLanguageIdentifier(e);
  }
  // --- instantiation
  create(e) {
    return new $2(this.onLanguagesMaybeChanged, () => {
      const t = this.getModeId(e);
      return this._createModeAndGetLanguageIdentifier(t);
    });
  }
  createByFilepathOrFirstLine(e, t) {
    return new $2(this.onLanguagesMaybeChanged, () => {
      const i = this.getModeIdByFilepathOrFirstLine(e, t);
      return this._createModeAndGetLanguageIdentifier(i);
    });
  }
  _createModeAndGetLanguageIdentifier(e) {
    const t = this.getLanguageIdentifier(e || "plaintext") || fb;
    return this._getOrCreateMode(t.language), t;
  }
  triggerMode(e) {
    const t = this.getModeId(e);
    this._getOrCreateMode(t || "plaintext");
  }
  _getOrCreateMode(e) {
    if (!this._instantiatedModes.hasOwnProperty(e)) {
      let t = this.getLanguageIdentifier(e) || fb;
      this._instantiatedModes[e] = new Ofe(t), this._onDidCreateMode.fire(this._instantiatedModes[e]);
    }
    return this._instantiatedModes[e];
  }
}
const gI = Vt("undoRedoService");
class Z3 {
  constructor(e, t) {
    this.resource = e, this.elements = t;
  }
}
class Jp {
  constructor() {
    this.id = Jp._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
}
Jp._ID = 0;
Jp.None = new Jp();
class Pl {
  constructor() {
    this.id = Pl._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
}
Pl._ID = 0;
Pl.None = new Pl();
class Wfe {
  constructor(e, t, i) {
    this._legend = e, this._themeService = t, this._logService = i, this._hashTable = new Nu(), this._hasWarnedOverlappingTokens = !1;
  }
  getMetadata(e, t, i) {
    const r = this._hashTable.get(e, t, i.id);
    let o;
    if (r)
      o = r.metadata, this._logService.getLevel() === $a.Trace && this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${e} / ${t}: foreground ${ra.getForeground(o)}, fontStyle ${ra.getFontStyle(o).toString(2)}`);
    else {
      let s = this._legend.tokenTypes[e];
      const a = [];
      if (s) {
        let l = t;
        for (let c = 0; l > 0 && c < this._legend.tokenModifiers.length; c++)
          l & 1 && a.push(this._legend.tokenModifiers[c]), l = l >> 1;
        l > 0 && this._logService.getLevel() === $a.Trace && (this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${t.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`), a.push("not-in-legend"));
        const u = this._themeService.getColorTheme().getTokenStyleMetadata(s, a, i.language);
        if (typeof u > "u")
          o = 2147483647;
        else {
          if (o = 0, typeof u.italic < "u") {
            const c = (u.italic ? 1 : 0) << 11;
            o |= c | 1;
          }
          if (typeof u.bold < "u") {
            const c = (u.bold ? 2 : 0) << 11;
            o |= c | 2;
          }
          if (typeof u.underline < "u") {
            const c = (u.underline ? 4 : 0) << 11;
            o |= c | 4;
          }
          if (u.foreground) {
            const c = u.foreground << 14;
            o |= c | 8;
          }
          o === 0 && (o = 2147483647);
        }
      } else
        this._logService.getLevel() === $a.Trace && this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${e} for legend: ${JSON.stringify(this._legend.tokenTypes)}`), o = 2147483647, s = "not-in-legend";
      this._hashTable.add(e, t, i.id, o), this._logService.getLevel() === $a.Trace && this._logService.trace(`SemanticTokensProviderStyling ${e} (${s}) / ${t} (${a.join(" ")}): foreground ${ra.getForeground(o)}, fontStyle ${ra.getFontStyle(o).toString(2)}`);
    }
    return o;
  }
  warnOverlappingSemanticTokens(e, t) {
    this._hasWarnedOverlappingTokens || (this._hasWarnedOverlappingTokens = !0, console.warn(`Overlapping semantic tokens detected at lineNumber ${e}, column ${t}`));
  }
}
function Vfe(n, e, t) {
  const i = n.data, r = n.data.length / 5 | 0, o = Math.max(
    Math.ceil(
      r / 1024
      /* DesiredMaxAreas */
    ),
    400
    /* DesiredTokensPerArea */
  ), s = [];
  let a = 0, l = 1, u = 0;
  for (; a < r; ) {
    const c = a;
    let h = Math.min(c + o, r);
    if (h < r) {
      let C = h;
      for (; C - 1 > c && i[5 * C] === 0; )
        C--;
      if (C - 1 === c) {
        let y = h;
        for (; y + 1 < r && i[5 * y] === 0; )
          y++;
        h = y;
      } else
        h = C;
    }
    let d = new Uint32Array((h - c) * 4), f = 0, p = 0, g = 0, _ = 0, m = 0;
    for (; a < h; ) {
      const C = 5 * a, y = i[C], b = i[C + 1], L = l + y, S = y === 0 ? u + b : b, E = i[C + 2], D = i[C + 3], O = i[C + 4], T = e.getMetadata(D, O, t);
      T !== 2147483647 && (p === 0 && (p = L), g === L && m > S && (e.warnOverlappingSemanticTokens(L, S + 1), _ < S ? d[f - 4 + 2] = S : f -= 4), d[f] = L - p, d[f + 1] = S, d[f + 2] = S + E, d[f + 3] = T, f += 4, g = L, _ = S, m = S + E), l = L, u = S, a++;
    }
    f !== d.length && (d = d.subarray(0, f));
    const v = new Nb(p, new xb(d));
    s.push(v);
  }
  return s;
}
class Bfe {
  constructor(e, t, i, r) {
    this.tokenTypeIndex = e, this.tokenModifierSet = t, this.languageId = i, this.metadata = r, this.next = null;
  }
}
class Nu {
  constructor() {
    this._elementsCount = 0, this._currentLengthIndex = 0, this._currentLength = Nu._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < Nu._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], Nu._nullOutEntries(this._elements, this._currentLength);
  }
  static _nullOutEntries(e, t) {
    for (let i = 0; i < t; i++)
      e[i] = null;
  }
  _hash2(e, t) {
    return (e << 5) - e + t | 0;
  }
  _hashFunc(e, t, i) {
    return this._hash2(this._hash2(e, t), i) % this._currentLength;
  }
  get(e, t, i) {
    const r = this._hashFunc(e, t, i);
    let o = this._elements[r];
    for (; o; ) {
      if (o.tokenTypeIndex === e && o.tokenModifierSet === t && o.languageId === i)
        return o;
      o = o.next;
    }
    return null;
  }
  add(e, t, i, r) {
    if (this._elementsCount++, this._growCount !== 0 && this._elementsCount >= this._growCount) {
      const o = this._elements;
      this._currentLengthIndex++, this._currentLength = Nu._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < Nu._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], Nu._nullOutEntries(this._elements, this._currentLength);
      for (const s of o) {
        let a = s;
        for (; a; ) {
          const l = a.next;
          a.next = null, this._add(a), a = l;
        }
      }
    }
    this._add(new Bfe(e, t, i, r));
  }
  _add(e) {
    const t = this._hashFunc(e.tokenTypeIndex, e.tokenModifierSet, e.languageId);
    e.next = this._elements[t], this._elements[t] = e;
  }
}
Nu._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];
function Hfe(n) {
  for (let e = 0, t = n.length; e < t; e += 4) {
    const i = n[e + 0], r = n[e + 1], o = n[e + 2], s = n[e + 3];
    n[e + 0] = s, n[e + 1] = o, n[e + 2] = r, n[e + 3] = i;
  }
}
function Gfe(n) {
  const e = new Uint8Array(n.buffer, n.byteOffset, n.length * 4);
  return J4() || Hfe(e), qS.wrap(e);
}
function Q3(n) {
  const e = new Uint32Array(Ufe(n));
  let t = 0;
  if (e[t++] = n.id, n.type === "full")
    e[t++] = 1, e[t++] = n.data.length, e.set(n.data, t), t += n.data.length;
  else {
    e[t++] = 2, e[t++] = n.deltas.length;
    for (const i of n.deltas)
      e[t++] = i.start, e[t++] = i.deleteCount, i.data ? (e[t++] = i.data.length, e.set(i.data, t), t += i.data.length) : e[t++] = 0;
  }
  return Gfe(e);
}
function Ufe(n) {
  let e = 0;
  if (e += 1 + 1, n.type === "full")
    e += 1 + n.data.length;
  else {
    e += 1, e += (1 + 1 + 1) * n.deltas.length;
    for (const t of n.deltas)
      t.data && (e += t.data.length);
  }
  return e;
}
var O0 = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function mI(n) {
  return n && !!n.data;
}
function zfe(n) {
  return n && Array.isArray(n.edits);
}
function J3(n, e, t) {
  const i = e7(n);
  return i ? {
    provider: i,
    request: Promise.resolve(i.provideDocumentSemanticTokens(n, e, t))
  } : null;
}
function e7(n) {
  const e = db.ordered(n);
  return e.length > 0 ? e[0] : null;
}
function t7(n) {
  const e = JG.ordered(n);
  return e.length > 0 ? e[0] : null;
}
Xn.registerCommand("_provideDocumentSemanticTokensLegend", (n, ...e) => O0(void 0, void 0, void 0, function* () {
  const [t] = e;
  Uo(t instanceof dt);
  const i = n.get(ro).getModel(t);
  if (!i)
    return;
  const r = e7(i);
  return r ? r.getLegend() : n.get(Ko).executeCommand("_provideDocumentRangeSemanticTokensLegend", t);
}));
Xn.registerCommand("_provideDocumentSemanticTokens", (n, ...e) => O0(void 0, void 0, void 0, function* () {
  const [t] = e;
  Uo(t instanceof dt);
  const i = n.get(ro).getModel(t);
  if (!i)
    return;
  const r = J3(i, null, zo.None);
  if (!r)
    return n.get(Ko).executeCommand("_provideDocumentRangeSemanticTokens", t, i.getFullModelRange());
  const { provider: o, request: s } = r;
  let a;
  try {
    a = yield s;
  } catch (u) {
    N_(u);
    return;
  }
  if (!a || !mI(a))
    return;
  const l = Q3({
    id: 0,
    type: "full",
    data: a.data
  });
  return a.resultId && o.releaseDocumentSemanticTokens(a.resultId), l;
}));
Xn.registerCommand("_provideDocumentRangeSemanticTokensLegend", (n, ...e) => O0(void 0, void 0, void 0, function* () {
  const [t] = e;
  Uo(t instanceof dt);
  const i = n.get(ro).getModel(t);
  if (!i)
    return;
  const r = t7(i);
  if (r)
    return r.getLegend();
}));
Xn.registerCommand("_provideDocumentRangeSemanticTokens", (n, ...e) => O0(void 0, void 0, void 0, function* () {
  const [t, i] = e;
  Uo(t instanceof dt), Uo(V.isIRange(i));
  const r = n.get(ro).getModel(t);
  if (!r)
    return;
  const o = t7(r);
  if (!o)
    return;
  let s;
  try {
    s = yield o.provideDocumentRangeSemanticTokens(r, V.lift(i), zo.None);
  } catch (a) {
    N_(a);
    return;
  }
  if (!(!s || !mI(s)))
    return Q3({
      id: 0,
      type: "full",
      data: s.data
    });
}));
var jfe = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Am = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
function Ec(n) {
  return n.toString();
}
function K2(n) {
  const e = new YS(), t = n.createSnapshot();
  let i;
  for (; i = t.read(); )
    e.update(i);
  return e.digest();
}
class $fe {
  constructor(e, t, i) {
    this._modelEventListeners = new ht(), this.model = e, this._languageSelection = null, this._languageSelectionListener = null, this._modelEventListeners.add(e.onWillDispose(() => t(e))), this._modelEventListeners.add(e.onDidChangeLanguage((r) => i(e, r)));
  }
  _disposeLanguageSelection() {
    this._languageSelectionListener && (this._languageSelectionListener.dispose(), this._languageSelectionListener = null);
  }
  dispose() {
    this._modelEventListeners.dispose(), this._disposeLanguageSelection();
  }
  setLanguage(e) {
    this._disposeLanguageSelection(), this._languageSelection = e, this._languageSelectionListener = this._languageSelection.onDidChange(() => this.model.setMode(e.languageIdentifier)), this.model.setMode(e.languageIdentifier);
  }
}
const Kfe = Rs || Ft ? 1 : 2;
class qfe {
  constructor(e, t, i, r, o, s, a, l) {
    this.uri = e, this.initialUndoRedoSnapshot = t, this.time = i, this.sharesUndoRedoStack = r, this.heapSize = o, this.sha1 = s, this.versionId = a, this.alternativeVersionId = l;
  }
}
function Yfe(n) {
  return n.scheme === vi.file || n.scheme === vi.vscodeRemote || n.scheme === vi.userData || n.scheme === "fake-fs";
}
let Jb = class $m extends ge {
  constructor(e, t, i, r, o) {
    super(), this._configurationService = e, this._resourcePropertiesService = t, this._themeService = i, this._logService = r, this._undoRedoService = o, this._onModelAdded = this._register(new j()), this.onModelAdded = this._onModelAdded.event, this._onModelRemoved = this._register(new j()), this.onModelRemoved = this._onModelRemoved.event, this._onModelModeChanged = this._register(new j()), this.onModelModeChanged = this._onModelModeChanged.event, this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null), this._models = {}, this._disposedModels = /* @__PURE__ */ new Map(), this._disposedModelsHeapSize = 0, this._semanticStyling = this._register(new Zfe(this._themeService, this._logService)), this._register(this._configurationService.onDidChangeConfiguration(() => this._updateModelOptions())), this._updateModelOptions(), this._register(new Xfe(this, this._themeService, this._configurationService, this._semanticStyling));
  }
  static _readModelOptions(e, t) {
    let i = Co.tabSize;
    if (e.editor && typeof e.editor.tabSize < "u") {
      const h = parseInt(e.editor.tabSize, 10);
      isNaN(h) || (i = h), i < 1 && (i = 1);
    }
    let r = i;
    if (e.editor && typeof e.editor.indentSize < "u" && e.editor.indentSize !== "tabSize") {
      const h = parseInt(e.editor.indentSize, 10);
      isNaN(h) || (r = h), r < 1 && (r = 1);
    }
    let o = Co.insertSpaces;
    e.editor && typeof e.editor.insertSpaces < "u" && (o = e.editor.insertSpaces === "false" ? !1 : !!e.editor.insertSpaces);
    let s = Kfe;
    const a = e.eol;
    a === `\r
` ? s = 2 : a === `
` && (s = 1);
    let l = Co.trimAutoWhitespace;
    e.editor && typeof e.editor.trimAutoWhitespace < "u" && (l = e.editor.trimAutoWhitespace === "false" ? !1 : !!e.editor.trimAutoWhitespace);
    let u = Co.detectIndentation;
    e.editor && typeof e.editor.detectIndentation < "u" && (u = e.editor.detectIndentation === "false" ? !1 : !!e.editor.detectIndentation);
    let c = Co.largeFileOptimizations;
    return e.editor && typeof e.editor.largeFileOptimizations < "u" && (c = e.editor.largeFileOptimizations === "false" ? !1 : !!e.editor.largeFileOptimizations), {
      isForSimpleWidget: t,
      tabSize: i,
      indentSize: r,
      insertSpaces: o,
      detectIndentation: u,
      defaultEOL: s,
      trimAutoWhitespace: l,
      largeFileOptimizations: c
    };
  }
  _getEOL(e, t) {
    if (e)
      return this._resourcePropertiesService.getEOL(e, t);
    const i = this._configurationService.getValue("files.eol", { overrideIdentifier: t });
    return i && i !== "auto" ? i : Ga === 3 || Ga === 2 ? `
` : `\r
`;
  }
  _shouldRestoreUndoStack() {
    const e = this._configurationService.getValue("files.restoreUndoStack");
    return typeof e == "boolean" ? e : !0;
  }
  getCreationOptions(e, t, i) {
    let r = this._modelCreationOptionsByLanguageAndResource[e + t];
    if (!r) {
      const o = this._configurationService.getValue("editor", { overrideIdentifier: e, resource: t }), s = this._getEOL(t, e);
      r = $m._readModelOptions({ editor: o, eol: s }, i), this._modelCreationOptionsByLanguageAndResource[e + t] = r;
    }
    return r;
  }
  _updateModelOptions() {
    const e = this._modelCreationOptionsByLanguageAndResource;
    this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
    const t = Object.keys(this._models);
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i], s = this._models[o], a = s.model.getLanguageIdentifier().language, l = s.model.uri, u = e[a + l], c = this.getCreationOptions(a, l, s.model.isForSimpleWidget);
      $m._setModelOptionsForModel(s.model, c, u);
    }
  }
  static _setModelOptionsForModel(e, t, i) {
    i && i.defaultEOL !== t.defaultEOL && e.getLineCount() === 1 && e.setEOL(
      t.defaultEOL === 1 ? 0 : 1
      /* CRLF */
    ), !(i && i.detectIndentation === t.detectIndentation && i.insertSpaces === t.insertSpaces && i.tabSize === t.tabSize && i.indentSize === t.indentSize && i.trimAutoWhitespace === t.trimAutoWhitespace) && (t.detectIndentation ? (e.detectIndentation(t.insertSpaces, t.tabSize), e.updateOptions({
      trimAutoWhitespace: t.trimAutoWhitespace
    })) : e.updateOptions({
      insertSpaces: t.insertSpaces,
      tabSize: t.tabSize,
      indentSize: t.indentSize,
      trimAutoWhitespace: t.trimAutoWhitespace
    }));
  }
  // --- begin IModelService
  _insertDisposedModel(e) {
    this._disposedModels.set(Ec(e.uri), e), this._disposedModelsHeapSize += e.heapSize;
  }
  _removeDisposedModel(e) {
    const t = this._disposedModels.get(Ec(e));
    return t && (this._disposedModelsHeapSize -= t.heapSize), this._disposedModels.delete(Ec(e)), t;
  }
  _ensureDisposedModelsHeapSize(e) {
    if (this._disposedModelsHeapSize > e) {
      const t = [];
      for (this._disposedModels.forEach((i) => {
        i.sharesUndoRedoStack || t.push(i);
      }), t.sort((i, r) => i.time - r.time); t.length > 0 && this._disposedModelsHeapSize > e; ) {
        const i = t.shift();
        this._removeDisposedModel(i.uri), i.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(i.initialUndoRedoSnapshot);
      }
    }
  }
  _createModelData(e, t, i, r) {
    const o = this.getCreationOptions(t.language, i, r), s = new Kr(e, o, t, i, this._undoRedoService);
    if (i && this._disposedModels.has(Ec(i))) {
      const u = this._removeDisposedModel(i), c = this._undoRedoService.getElements(i), h = K2(s) === u.sha1;
      if (h || u.sharesUndoRedoStack) {
        for (const d of c.past)
          Ru(d) && d.matchesResource(i) && d.setModel(s);
        for (const d of c.future)
          Ru(d) && d.matchesResource(i) && d.setModel(s);
        this._undoRedoService.setElementsValidFlag(i, !0, (d) => Ru(d) && d.matchesResource(i)), h && (s._overwriteVersionId(u.versionId), s._overwriteAlternativeVersionId(u.alternativeVersionId), s._overwriteInitialUndoRedoSnapshot(u.initialUndoRedoSnapshot));
      } else
        u.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(u.initialUndoRedoSnapshot);
    }
    const a = Ec(s.uri);
    if (this._models[a])
      throw new Error("ModelService: Cannot add model because it already exists!");
    const l = new $fe(s, (u) => this._onWillDispose(u), (u, c) => this._onDidChangeLanguage(u, c));
    return this._models[a] = l, l;
  }
  createModel(e, t, i, r = !1) {
    let o;
    return t ? (o = this._createModelData(e, t.languageIdentifier, i, r), this.setMode(o.model, t)) : o = this._createModelData(e, X3, i, r), this._onModelAdded.fire(o.model), o.model;
  }
  setMode(e, t) {
    if (!t)
      return;
    const i = this._models[Ec(e.uri)];
    i && i.setLanguage(t);
  }
  getModels() {
    const e = [], t = Object.keys(this._models);
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      e.push(this._models[o].model);
    }
    return e;
  }
  getModel(e) {
    const t = Ec(e), i = this._models[t];
    return i ? i.model : null;
  }
  getSemanticTokensProviderStyling(e) {
    return this._semanticStyling.get(e);
  }
  // --- end IModelService
  _onWillDispose(e) {
    const t = Ec(e.uri), i = this._models[t], r = this._undoRedoService.getUriComparisonKey(e.uri) !== e.uri.toString();
    let o = !1, s = 0;
    if (r || this._shouldRestoreUndoStack() && Yfe(e.uri)) {
      const l = this._undoRedoService.getElements(e.uri);
      if (l.past.length > 0 || l.future.length > 0) {
        for (const u of l.past)
          Ru(u) && u.matchesResource(e.uri) && (o = !0, s += u.heapSize(e.uri), u.setModel(e.uri));
        for (const u of l.future)
          Ru(u) && u.matchesResource(e.uri) && (o = !0, s += u.heapSize(e.uri), u.setModel(e.uri));
      }
    }
    const a = $m.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;
    if (o)
      if (!r && s > a) {
        const l = i.model.getInitialUndoRedoSnapshot();
        l !== null && this._undoRedoService.restoreSnapshot(l);
      } else
        this._ensureDisposedModelsHeapSize(a - s), this._undoRedoService.setElementsValidFlag(e.uri, !1, (l) => Ru(l) && l.matchesResource(e.uri)), this._insertDisposedModel(new qfe(e.uri, i.model.getInitialUndoRedoSnapshot(), Date.now(), r, s, K2(e), e.getVersionId(), e.getAlternativeVersionId()));
    else if (!r) {
      const l = i.model.getInitialUndoRedoSnapshot();
      l !== null && this._undoRedoService.restoreSnapshot(l);
    }
    delete this._models[t], i.dispose(), delete this._modelCreationOptionsByLanguageAndResource[e.getLanguageIdentifier().language + e.uri], this._onModelRemoved.fire(e);
  }
  _onDidChangeLanguage(e, t) {
    const i = t.oldLanguage, r = e.getLanguageIdentifier().language, o = this.getCreationOptions(i, e.uri, e.isForSimpleWidget), s = this.getCreationOptions(r, e.uri, e.isForSimpleWidget);
    $m._setModelOptionsForModel(e, s, o), this._onModelModeChanged.fire({ model: e, oldModeId: i });
  }
};
Jb.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024;
Jb = jfe([
  Am(0, mr),
  Am(1, c5),
  Am(2, Qn),
  Am(3, H_),
  Am(4, gI)
], Jb);
const i7 = "editor.semanticHighlighting";
function q2(n, e, t) {
  var i;
  const r = (i = t.getValue(i7, { overrideIdentifier: n.getLanguageIdentifier().language, resource: n.uri })) === null || i === void 0 ? void 0 : i.enabled;
  return typeof r == "boolean" ? r : e.getColorTheme().semanticHighlighting;
}
class Xfe extends ge {
  constructor(e, t, i, r) {
    super(), this._watchers = /* @__PURE__ */ Object.create(null), this._semanticStyling = r;
    const o = (l) => {
      this._watchers[l.uri.toString()] = new nd(l, t, this._semanticStyling);
    }, s = (l, u) => {
      u.dispose(), delete this._watchers[l.uri.toString()];
    }, a = () => {
      for (let l of e.getModels()) {
        const u = this._watchers[l.uri.toString()];
        q2(l, t, i) ? u || o(l) : u && s(l, u);
      }
    };
    this._register(e.onModelAdded((l) => {
      q2(l, t, i) && o(l);
    })), this._register(e.onModelRemoved((l) => {
      const u = this._watchers[l.uri.toString()];
      u && s(l, u);
    })), this._register(i.onDidChangeConfiguration((l) => {
      l.affectsConfiguration(i7) && a();
    })), this._register(t.onDidColorThemeChange(a));
  }
}
class Zfe extends ge {
  constructor(e, t) {
    super(), this._themeService = e, this._logService = t, this._caches = /* @__PURE__ */ new WeakMap(), this._register(this._themeService.onDidColorThemeChange(() => {
      this._caches = /* @__PURE__ */ new WeakMap();
    }));
  }
  get(e) {
    return this._caches.has(e) || this._caches.set(e, new Wfe(e.getLegend(), this._themeService, this._logService)), this._caches.get(e);
  }
}
class Qfe {
  constructor(e, t, i) {
    this._provider = e, this.resultId = t, this.data = i;
  }
  dispose() {
    this._provider.releaseDocumentSemanticTokens(this.resultId);
  }
}
class nd extends ge {
  constructor(e, t, i) {
    super(), this._isDisposed = !1, this._model = e, this._semanticStyling = i, this._fetchDocumentSemanticTokens = this._register(new to(() => this._fetchDocumentSemanticTokensNow(), nd.FETCH_DOCUMENT_SEMANTIC_TOKENS_DELAY)), this._currentDocumentResponse = null, this._currentDocumentRequestCancellationTokenSource = null, this._documentProvidersChangeListeners = [], this._register(this._model.onDidChangeContent(() => {
      this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule();
    })), this._register(this._model.onDidChangeLanguage(() => {
      this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule(0);
    }));
    const r = () => {
      yi(this._documentProvidersChangeListeners), this._documentProvidersChangeListeners = [];
      for (const o of db.all(e))
        typeof o.onDidChange == "function" && this._documentProvidersChangeListeners.push(o.onDidChange(() => this._fetchDocumentSemanticTokens.schedule(0)));
    };
    r(), this._register(db.onDidChange(() => {
      r(), this._fetchDocumentSemanticTokens.schedule();
    })), this._register(t.onDidColorThemeChange((o) => {
      this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule();
    })), this._fetchDocumentSemanticTokens.schedule(0);
  }
  dispose() {
    this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), this._setDocumentSemanticTokens(null, null, null, []), this._isDisposed = !0, super.dispose();
  }
  _fetchDocumentSemanticTokensNow() {
    if (this._currentDocumentRequestCancellationTokenSource)
      return;
    const e = new uh(), t = this._currentDocumentResponse && this._currentDocumentResponse.resultId || null, i = J3(this._model, t, e.token);
    if (!i) {
      this._currentDocumentResponse && this._model.setSemanticTokens(null, !1);
      return;
    }
    const { provider: r, request: o } = i;
    this._currentDocumentRequestCancellationTokenSource = e;
    const s = [], a = this._model.onDidChangeContent((u) => {
      s.push(u);
    }), l = this._semanticStyling.get(r);
    o.then((u) => {
      this._currentDocumentRequestCancellationTokenSource = null, a.dispose(), this._setDocumentSemanticTokens(r, u || null, l, s);
    }, (u) => {
      u && (I_(u) || typeof u.message == "string" && u.message.indexOf("busy") !== -1) || Ni(u), this._currentDocumentRequestCancellationTokenSource = null, a.dispose(), s.length > 0 && (this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule());
    });
  }
  static _copy(e, t, i, r, o) {
    for (let s = 0; s < o; s++)
      i[r + s] = e[t + s];
  }
  _setDocumentSemanticTokens(e, t, i, r) {
    const o = this._currentDocumentResponse, s = () => {
      r.length > 0 && !this._fetchDocumentSemanticTokens.isScheduled() && this._fetchDocumentSemanticTokens.schedule();
    };
    if (this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._isDisposed) {
      e && t && e.releaseDocumentSemanticTokens(t.resultId);
      return;
    }
    if (!e || !i) {
      this._model.setSemanticTokens(null, !1);
      return;
    }
    if (!t) {
      this._model.setSemanticTokens(null, !0), s();
      return;
    }
    if (zfe(t)) {
      if (!o) {
        this._model.setSemanticTokens(null, !0);
        return;
      }
      if (t.edits.length === 0)
        t = {
          resultId: t.resultId,
          data: o.data
        };
      else {
        let a = 0;
        for (const d of t.edits)
          a += (d.data ? d.data.length : 0) - d.deleteCount;
        const l = o.data, u = new Uint32Array(l.length + a);
        let c = l.length, h = u.length;
        for (let d = t.edits.length - 1; d >= 0; d--) {
          const f = t.edits[d], p = c - (f.start + f.deleteCount);
          p > 0 && (nd._copy(l, c - p, u, h - p, p), h -= p), f.data && (nd._copy(f.data, 0, u, h - f.data.length, f.data.length), h -= f.data.length), c = f.start;
        }
        c > 0 && nd._copy(l, 0, u, 0, c), t = {
          resultId: t.resultId,
          data: u
        };
      }
    }
    if (mI(t)) {
      this._currentDocumentResponse = new Qfe(e, t.resultId, t.data);
      const a = Vfe(t, i, this._model.getLanguageIdentifier());
      if (r.length > 0)
        for (const l of r)
          for (const u of a)
            for (const c of l.changes)
              u.applyEdit(c.range, c.text);
      this._model.setSemanticTokens(a, !0);
    } else
      this._model.setSemanticTokens(null, !0);
    s();
  }
}
nd.FETCH_DOCUMENT_SEMANTIC_TOKENS_DELAY = 300;
class Jfe {
  constructor(e, t, i, r, o) {
    this.token = e, this.index = t, this.fontStyle = i, this.foreground = r, this.background = o;
  }
}
function epe(n) {
  if (!n || !Array.isArray(n))
    return [];
  let e = [], t = 0;
  for (let i = 0, r = n.length; i < r; i++) {
    let o = n[i], s = -1;
    if (typeof o.fontStyle == "string") {
      s = 0;
      let u = o.fontStyle.split(" ");
      for (let c = 0, h = u.length; c < h; c++)
        switch (u[c]) {
          case "italic":
            s = s | 1;
            break;
          case "bold":
            s = s | 2;
            break;
          case "underline":
            s = s | 4;
            break;
        }
    }
    let a = null;
    typeof o.foreground == "string" && (a = o.foreground);
    let l = null;
    typeof o.background == "string" && (l = o.background), e[t++] = new Jfe(o.token || "", i, s, a, l);
  }
  return e;
}
function tpe(n, e) {
  n.sort((c, h) => {
    let d = spe(c.token, h.token);
    return d !== 0 ? d : c.index - h.index;
  });
  let t = 0, i = "000000", r = "ffffff";
  for (; n.length >= 1 && n[0].token === ""; ) {
    let c = n.shift();
    c.fontStyle !== -1 && (t = c.fontStyle), c.foreground !== null && (i = c.foreground), c.background !== null && (r = c.background);
  }
  let o = new npe();
  for (let c of e)
    o.getId(c);
  let s = o.getId(i), a = o.getId(r), l = new vI(t, s, a), u = new _I(l);
  for (let c = 0, h = n.length; c < h; c++) {
    let d = n[c];
    u.insert(d.token, d.fontStyle, o.getId(d.foreground), o.getId(d.background));
  }
  return new n7(o, u);
}
const ipe = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
class npe {
  constructor() {
    this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ new Map();
  }
  getId(e) {
    if (e === null)
      return 0;
    const t = e.match(ipe);
    if (!t)
      throw new Error("Illegal value for token color: " + e);
    e = t[1].toUpperCase();
    let i = this._color2id.get(e);
    return i || (i = ++this._lastColorId, this._color2id.set(e, i), this._id2color[i] = ee.fromHex("#" + e), i);
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}
class n7 {
  constructor(e, t) {
    this._colorMap = e, this._root = t, this._cache = /* @__PURE__ */ new Map();
  }
  static createFromRawTokenTheme(e, t) {
    return this.createFromParsedTokenTheme(epe(e), t);
  }
  static createFromParsedTokenTheme(e, t) {
    return tpe(e, t);
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  _match(e) {
    return this._root.match(e);
  }
  match(e, t) {
    let i = this._cache.get(t);
    if (typeof i > "u") {
      let r = this._match(t), o = ope(t);
      i = (r.metadata | o << 8) >>> 0, this._cache.set(t, i);
    }
    return (i | e << 0) >>> 0;
  }
}
const rpe = /\b(comment|string|regex|regexp)\b/;
function ope(n) {
  let e = n.match(rpe);
  if (!e)
    return 0;
  switch (e[1]) {
    case "comment":
      return 1;
    case "string":
      return 2;
    case "regex":
      return 4;
    case "regexp":
      return 4;
  }
  throw new Error("Unexpected match for standard token type!");
}
function spe(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
class vI {
  constructor(e, t, i) {
    this._fontStyle = e, this._foreground = t, this._background = i, this.metadata = (this._fontStyle << 11 | this._foreground << 14 | this._background << 23) >>> 0;
  }
  clone() {
    return new vI(this._fontStyle, this._foreground, this._background);
  }
  acceptOverwrite(e, t, i) {
    e !== -1 && (this._fontStyle = e), t !== 0 && (this._foreground = t), i !== 0 && (this._background = i), this.metadata = (this._fontStyle << 11 | this._foreground << 14 | this._background << 23) >>> 0;
  }
}
class _I {
  constructor(e) {
    this._mainRule = e, this._children = /* @__PURE__ */ new Map();
  }
  match(e) {
    if (e === "")
      return this._mainRule;
    let t = e.indexOf("."), i, r;
    t === -1 ? (i = e, r = "") : (i = e.substring(0, t), r = e.substring(t + 1));
    let o = this._children.get(i);
    return typeof o < "u" ? o.match(r) : this._mainRule;
  }
  insert(e, t, i, r) {
    if (e === "") {
      this._mainRule.acceptOverwrite(t, i, r);
      return;
    }
    let o = e.indexOf("."), s, a;
    o === -1 ? (s = e, a = "") : (s = e.substring(0, o), a = e.substring(o + 1));
    let l = this._children.get(s);
    typeof l > "u" && (l = new _I(this._mainRule.clone()), this._children.set(s, l)), l.insert(a, t, i, r);
  }
}
function ape(n) {
  let e = [];
  for (let t = 1, i = n.length; t < i; t++) {
    let r = n[t];
    e[t] = `.mtk${t} { color: ${r}; }`;
  }
  return e.push(".mtki { font-style: italic; }"), e.push(".mtkb { font-weight: bold; }"), e.push(".mtku { text-decoration: underline; text-underline-position: under; }"), e.join(`
`);
}
const lpe = {
  base: "vs",
  inherit: !1,
  rules: [
    { token: "", foreground: "000000", background: "fffffe" },
    { token: "invalid", foreground: "cd3131" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "001188" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "delimiter.xml", foreground: "0000FF" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "FF0000" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "FF0000" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "attribute.value.number", foreground: "098658" },
    { token: "attribute.value.unit", foreground: "098658" },
    { token: "attribute.value.html", foreground: "0000FF" },
    { token: "attribute.value.xml", foreground: "0000FF" },
    { token: "string", foreground: "A31515" },
    { token: "string.html", foreground: "0000FF" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "string.yaml", foreground: "0451A5" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.json", foreground: "0451A5" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "keyword.flow.scss", foreground: "0000FF" },
    { token: "operator.scss", foreground: "666666" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [Uu]: "#FFFFFE",
    [j_]: "#000000",
    [eI]: "#E5EBF1",
    [y0]: "#D3D3D3",
    [w0]: "#939393",
    [c3]: "#ADD6FF4D",
    [rce]: "#9DDDFF"
  }
}, upe = {
  base: "vs-dark",
  inherit: !1,
  rules: [
    { token: "", foreground: "D4D4D4", background: "1E1E1E" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "74B0DF" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "B5CEA8" },
    { token: "number.hex", foreground: "5BB498" },
    { token: "regexp", foreground: "B46695" },
    { token: "annotation", foreground: "cc6666" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "DCDCDC" },
    { token: "delimiter.html", foreground: "808080" },
    { token: "delimiter.xml", foreground: "808080" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "A79873" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "DD6A6F" },
    { token: "metatag.content.html", foreground: "9CDCFE" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key.json", foreground: "9CDCFE" },
    { token: "string.value.json", foreground: "CE9178" },
    { token: "attribute.name", foreground: "9CDCFE" },
    { token: "attribute.value", foreground: "CE9178" },
    { token: "attribute.value.number.css", foreground: "B5CEA8" },
    { token: "attribute.value.unit.css", foreground: "B5CEA8" },
    { token: "attribute.value.hex.css", foreground: "D4D4D4" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "keyword.json", foreground: "CE9178" },
    { token: "keyword.flow.scss", foreground: "569CD6" },
    { token: "operator.scss", foreground: "909090" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [Uu]: "#1E1E1E",
    [j_]: "#D4D4D4",
    [eI]: "#3A3D41",
    [y0]: "#404040",
    [w0]: "#707070",
    [c3]: "#ADD6FF26"
  }
}, cpe = {
  base: "hc-black",
  inherit: !1,
  rules: [
    { token: "", foreground: "FFFFFF", background: "000000" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "1AEBFF" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "FFFFFF" },
    { token: "regexp", foreground: "C0C0C0" },
    { token: "annotation", foreground: "569CD6" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "FFFF00" },
    { token: "delimiter.html", foreground: "FFFF00" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta", foreground: "D4D4D4" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "569CD6" },
    { token: "metatag.content.html", foreground: "1AEBFF" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key", foreground: "9CDCFE" },
    { token: "string.value", foreground: "CE9178" },
    { token: "attribute.name", foreground: "569CD6" },
    { token: "attribute.value", foreground: "3FF23F" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [Uu]: "#000000",
    [j_]: "#FFFFFF",
    [y0]: "#FFFFFF",
    [w0]: "#FFFFFF"
  }
};
function hpe() {
  const n = new j(), e = rfe();
  return e.onDidChange(() => n.fire()), {
    onDidChange: n.event,
    getCSS() {
      const t = {}, i = (o) => {
        let s = o.defaults;
        for (; fa.isThemeIcon(s); ) {
          const l = e.getIcon(s.id);
          if (!l)
            return;
          s = l.defaults;
        }
        const a = s.fontId;
        if (a) {
          const l = e.getIconFont(a);
          if (l)
            return t[a] = l, `.codicon-${o.id}:before { content: '${s.fontCharacter}'; font-family: ${LF(a)}; }`;
        }
        return `.codicon-${o.id}:before { content: '${s.fontCharacter}'; }`;
      }, r = [];
      for (let o of e.getIcons()) {
        const s = i(o);
        s && r.push(s);
      }
      for (let o in t) {
        const a = t[o].definition.src.map((l) => `${Hv(l.location)} format('${l.format}')`).join(", ");
        r.push(`@font-face { src: ${a}; font-family: ${LF(o)}; }`);
      }
      return r.join(`
`);
    }
  };
}
const rd = "vs", eS = "vs-dark", Dp = "hc-black", dpe = Zn.as(s3.ColorContribution), fpe = Zn.as(k5.ThemingContribution);
class r7 {
  constructor(e, t) {
    this.semanticHighlighting = !1, this.themeData = t;
    let i = t.base;
    e.length > 0 ? (fw(e) ? this.id = e : this.id = i + " " + e, this.themeName = e) : (this.id = i, this.themeName = i), this.colors = null, this.defaultColors = /* @__PURE__ */ Object.create(null), this._tokenTheme = null;
  }
  get base() {
    return this.themeData.base;
  }
  notifyBaseUpdated() {
    this.themeData.inherit && (this.colors = null, this._tokenTheme = null);
  }
  getColors() {
    if (!this.colors) {
      const e = /* @__PURE__ */ new Map();
      for (let t in this.themeData.colors)
        e.set(t, ee.fromHex(this.themeData.colors[t]));
      if (this.themeData.inherit) {
        let t = XT(this.themeData.base);
        for (let i in t.colors)
          e.has(i) || e.set(i, ee.fromHex(t.colors[i]));
      }
      this.colors = e;
    }
    return this.colors;
  }
  getColor(e, t) {
    const i = this.getColors().get(e);
    if (i)
      return i;
    if (t !== !1)
      return this.getDefault(e);
  }
  getDefault(e) {
    let t = this.defaultColors[e];
    return t || (t = dpe.resolveDefaultColor(e, this), this.defaultColors[e] = t, t);
  }
  defines(e) {
    return Object.prototype.hasOwnProperty.call(this.getColors(), e);
  }
  get type() {
    switch (this.base) {
      case rd:
        return Vl.LIGHT;
      case Dp:
        return Vl.HIGH_CONTRAST;
      default:
        return Vl.DARK;
    }
  }
  get tokenTheme() {
    if (!this._tokenTheme) {
      let e = [], t = [];
      if (this.themeData.inherit) {
        let i = XT(this.themeData.base);
        e = i.rules, i.encodedTokensColors && (t = i.encodedTokensColors);
      }
      e = e.concat(this.themeData.rules), this.themeData.encodedTokensColors && (t = this.themeData.encodedTokensColors), this._tokenTheme = n7.createFromRawTokenTheme(e, t);
    }
    return this._tokenTheme;
  }
  getTokenStyleMetadata(e, t, i) {
    const o = this.tokenTheme._match([e].concat(t).join(".")).metadata, s = ra.getForeground(o), a = ra.getFontStyle(o);
    return {
      foreground: s,
      italic: !!(a & 1),
      bold: !!(a & 2),
      underline: !!(a & 4)
    };
  }
}
function fw(n) {
  return n === rd || n === eS || n === Dp;
}
function XT(n) {
  switch (n) {
    case rd:
      return lpe;
    case eS:
      return upe;
    case Dp:
      return cpe;
  }
}
function jD(n) {
  let e = XT(n);
  return new r7(n, e);
}
class ppe extends ge {
  constructor() {
    super(), this._onColorThemeChange = this._register(new j()), this.onDidColorThemeChange = this._onColorThemeChange.event, this._environment = /* @__PURE__ */ Object.create(null), this._autoDetectHighContrast = !0, this._knownThemes = /* @__PURE__ */ new Map(), this._knownThemes.set(rd, jD(rd)), this._knownThemes.set(eS, jD(eS)), this._knownThemes.set(Dp, jD(Dp));
    const e = hpe();
    this._codiconCSS = e.getCSS(), this._themeCSS = "", this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._globalStyleElement = null, this._styleElements = [], this._colorMapOverride = null, this.setTheme(rd), e.onDidChange(() => {
      this._codiconCSS = e.getCSS(), this._updateCSS();
    }), Xne("(forced-colors: active)", () => {
      this._updateActualTheme();
    });
  }
  registerEditorContainer(e) {
    return dN(e) ? this._registerShadowDomContainer(e) : this._registerRegularEditorContainer();
  }
  _registerRegularEditorContainer() {
    return this._globalStyleElement || (this._globalStyleElement = Os(), this._globalStyleElement.className = "monaco-colors", this._globalStyleElement.textContent = this._allCSS, this._styleElements.push(this._globalStyleElement)), ge.None;
  }
  _registerShadowDomContainer(e) {
    const t = Os(e);
    return t.className = "monaco-colors", t.textContent = this._allCSS, this._styleElements.push(t), {
      dispose: () => {
        for (let i = 0; i < this._styleElements.length; i++)
          if (this._styleElements[i] === t) {
            this._styleElements.splice(i, 1);
            return;
          }
      }
    };
  }
  defineTheme(e, t) {
    if (!/^[a-z0-9\-]+$/i.test(e))
      throw new Error("Illegal theme name!");
    if (!fw(t.base) && !fw(e))
      throw new Error("Illegal theme base!");
    this._knownThemes.set(e, new r7(e, t)), fw(e) && this._knownThemes.forEach((i) => {
      i.base === e && i.notifyBaseUpdated();
    }), this._theme.themeName === e && this.setTheme(e);
  }
  getColorTheme() {
    return this._theme;
  }
  setColorMapOverride(e) {
    this._colorMapOverride = e, this._updateThemeOrColorMap();
  }
  setTheme(e) {
    let t;
    this._knownThemes.has(e) ? t = this._knownThemes.get(e) : t = this._knownThemes.get(rd), this._desiredTheme = t, this._updateActualTheme();
  }
  _updateActualTheme() {
    const e = this._autoDetectHighContrast && window.matchMedia("(forced-colors: active)").matches ? this._knownThemes.get(Dp) : this._desiredTheme;
    this._theme !== e && (this._theme = e, this._updateThemeOrColorMap());
  }
  setAutoDetectHighContrast(e) {
    this._autoDetectHighContrast = e, this._updateActualTheme();
  }
  _updateThemeOrColorMap() {
    let e = [], t = {}, i = {
      addRule: (o) => {
        t[o] || (e.push(o), t[o] = !0);
      }
    };
    fpe.getThemingParticipants().forEach((o) => o(this._theme, i, this._environment));
    const r = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
    i.addRule(ape(r)), this._themeCSS = e.join(`
`), this._updateCSS(), ln.setColorMap(r), this._onColorThemeChange.fire(this._theme);
  }
  _updateCSS() {
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._styleElements.forEach((e) => e.textContent = this._allCSS);
  }
  getFileIconTheme() {
    return {
      hasFileIcons: !1,
      hasFolderIcons: !1,
      hidesExplorerArrows: !1
    };
  }
}
var gpe = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, mpe = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
const wv = "data-keybinding-context";
class CI {
  constructor(e, t) {
    this._id = e, this._parent = t, this._value = /* @__PURE__ */ Object.create(null), this._value._contextId = e;
  }
  setValue(e, t) {
    return this._value[e] !== t ? (this._value[e] = t, !0) : !1;
  }
  removeValue(e) {
    return e in this._value ? (delete this._value[e], !0) : !1;
  }
  getValue(e) {
    const t = this._value[e];
    return typeof t > "u" && this._parent ? this._parent.getValue(e) : t;
  }
}
class eg extends CI {
  constructor() {
    super(-1, null);
  }
  setValue(e, t) {
    return !1;
  }
  removeValue(e) {
    return !1;
  }
  getValue(e) {
  }
}
eg.INSTANCE = new eg();
class l_ extends CI {
  constructor(e, t, i) {
    super(e, null), this._configurationService = t, this._values = ov.forConfigKeys(), this._listener = this._configurationService.onDidChangeConfiguration((r) => {
      if (r.source === 6) {
        const o = Array.from(_t.map(this._values, ([s]) => s));
        this._values.clear(), i.fire(new X2(o));
      } else {
        const o = [];
        for (const s of r.affectedKeys) {
          const a = `config.${s}`, l = this._values.findSuperstr(a);
          l !== void 0 && (o.push(..._t.map(l, ([u]) => u)), this._values.deleteSuperstr(a)), this._values.has(a) && (o.push(a), this._values.delete(a));
        }
        i.fire(new X2(o));
      }
    });
  }
  dispose() {
    this._listener.dispose();
  }
  getValue(e) {
    if (e.indexOf(l_._keyPrefix) !== 0)
      return super.getValue(e);
    if (this._values.has(e))
      return this._values.get(e);
    const t = e.substr(l_._keyPrefix.length), i = this._configurationService.getValue(t);
    let r;
    switch (typeof i) {
      case "number":
      case "boolean":
      case "string":
        r = i;
        break;
      default:
        Array.isArray(i) ? r = JSON.stringify(i) : r = i;
    }
    return this._values.set(e, r), r;
  }
  setValue(e, t) {
    return super.setValue(e, t);
  }
  removeValue(e) {
    return super.removeValue(e);
  }
}
l_._keyPrefix = "config.";
class vpe {
  constructor(e, t, i) {
    this._service = e, this._key = t, this._defaultValue = i, this.reset();
  }
  set(e) {
    this._service.setContext(this._key, e);
  }
  reset() {
    typeof this._defaultValue > "u" ? this._service.removeContext(this._key) : this._service.setContext(this._key, this._defaultValue);
  }
  get() {
    return this._service.getContextKeyValue(this._key);
  }
}
class Y2 {
  constructor(e) {
    this.key = e;
  }
  affectsSome(e) {
    return e.has(this.key);
  }
}
class X2 {
  constructor(e) {
    this.keys = e;
  }
  affectsSome(e) {
    for (const t of this.keys)
      if (e.has(t))
        return !0;
    return !1;
  }
}
class _pe {
  constructor(e) {
    this.events = e;
  }
  affectsSome(e) {
    for (const t of this.events)
      if (t.affectsSome(e))
        return !0;
    return !1;
  }
}
class o7 {
  constructor(e) {
    this._onDidChangeContext = new Z1({ merge: (t) => new _pe(t) }), this.onDidChangeContext = this._onDidChangeContext.event, this._isDisposed = !1, this._myContextId = e;
  }
  createKey(e, t) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new vpe(this, e, t);
  }
  bufferChangeEvents(e) {
    this._onDidChangeContext.pause();
    try {
      e();
    } finally {
      this._onDidChangeContext.resume();
    }
  }
  createScoped(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new Cpe(this, e);
  }
  contextMatchesRules(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    const t = this.getContextValuesContainer(this._myContextId);
    return mp.contextMatchesRules(t, e);
  }
  getContextKeyValue(e) {
    if (!this._isDisposed)
      return this.getContextValuesContainer(this._myContextId).getValue(e);
  }
  setContext(e, t) {
    if (this._isDisposed)
      return;
    const i = this.getContextValuesContainer(this._myContextId);
    i && i.setValue(e, t) && this._onDidChangeContext.fire(new Y2(e));
  }
  removeContext(e) {
    this._isDisposed || this.getContextValuesContainer(this._myContextId).removeValue(e) && this._onDidChangeContext.fire(new Y2(e));
  }
  getContext(e) {
    return this._isDisposed ? eg.INSTANCE : this.getContextValuesContainer(ype(e));
  }
}
let ZT = class extends o7 {
  constructor(e) {
    super(0), this._contexts = /* @__PURE__ */ new Map(), this._toDispose = new ht(), this._lastContextId = 0;
    const t = new l_(this._myContextId, e, this._onDidChangeContext);
    this._contexts.set(this._myContextId, t), this._toDispose.add(t);
  }
  dispose() {
    this._onDidChangeContext.dispose(), this._isDisposed = !0, this._toDispose.dispose();
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? eg.INSTANCE : this._contexts.get(e) || eg.INSTANCE;
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ContextKeyService has been disposed");
    let t = ++this._lastContextId;
    return this._contexts.set(t, new CI(t, this.getContextValuesContainer(e))), t;
  }
  disposeContext(e) {
    this._isDisposed || this._contexts.delete(e);
  }
};
ZT = gpe([
  mpe(0, mr)
], ZT);
class Cpe extends o7 {
  constructor(e, t) {
    if (super(e.createChildContext()), this._parentChangeListener = new Kie(), this._parent = e, this._updateParentChangeListener(), this._domNode = t, this._domNode.hasAttribute(wv)) {
      let i = "";
      this._domNode.classList && (i = Array.from(this._domNode.classList.values()).join(", ")), console.error(`Element already has context attribute${i ? ": " + i : ""}`);
    }
    this._domNode.setAttribute(wv, String(this._myContextId));
  }
  _updateParentChangeListener() {
    this._parentChangeListener.value = this._parent.onDidChangeContext(this._onDidChangeContext.fire, this._onDidChangeContext);
  }
  dispose() {
    this._isDisposed || (this._onDidChangeContext.dispose(), this._parent.disposeContext(this._myContextId), this._parentChangeListener.dispose(), this._domNode.removeAttribute(wv), this._isDisposed = !0);
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? eg.INSTANCE : this._parent.getContextValuesContainer(e);
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ScopedContextKeyService has been disposed");
    return this._parent.createChildContext(e);
  }
  disposeContext(e) {
    this._isDisposed || this._parent.disposeContext(e);
  }
}
function ype(n) {
  for (; n; ) {
    if (n.hasAttribute(wv)) {
      const e = n.getAttribute(wv);
      return e ? parseInt(e, 10) : NaN;
    }
    n = n.parentElement;
  }
  return 0;
}
Xn.registerCommand(Nae, function(n, e, t) {
  n.get(Ti).createKey(String(e), t);
});
Xn.registerCommand({
  id: "getContextKeyInfo",
  handler() {
    return [...it.all()].sort((n, e) => n.key.localeCompare(e.key));
  },
  description: {
    description: w("getContextKeyInfo", "A command that returns information about context keys"),
    args: []
  }
});
Xn.registerCommand("_generateContextKeyInfo", function() {
  const n = [], e = /* @__PURE__ */ new Set();
  for (let t of it.all())
    e.has(t.key) || (e.add(t.key), n.push(t));
  n.sort((t, i) => t.key.localeCompare(i.key)), console.log(JSON.stringify(n, void 0, 2));
});
var lr;
(function(n) {
  function e(o, s) {
    if (o.start >= s.end || s.start >= o.end)
      return { start: 0, end: 0 };
    const a = Math.max(o.start, s.start), l = Math.min(o.end, s.end);
    return l - a <= 0 ? { start: 0, end: 0 } : { start: a, end: l };
  }
  n.intersect = e;
  function t(o) {
    return o.end - o.start <= 0;
  }
  n.isEmpty = t;
  function i(o, s) {
    return !t(e(o, s));
  }
  n.intersects = i;
  function r(o, s) {
    const a = [], l = { start: o.start, end: Math.min(s.start, o.end) }, u = { start: Math.max(s.end, o.start), end: o.end };
    return t(l) || a.push(l), t(u) || a.push(u), a;
  }
  n.relativeComplement = r;
})(lr || (lr = {}));
var Gc;
(function(n) {
  n[n.AVOID = 0] = "AVOID", n[n.ALIGN = 1] = "ALIGN";
})(Gc || (Gc = {}));
function Qf(n, e, t) {
  const i = t.mode === Gc.ALIGN ? t.offset : t.offset + t.size, r = t.mode === Gc.ALIGN ? t.offset + t.size : t.offset;
  return t.position === 0 ? e <= n - i ? i : e <= r ? r - e : Math.max(n - e, 0) : e <= r ? r - e : e <= n - i ? i : 0;
}
class tg extends ge {
  constructor(e, t) {
    super(), this.container = null, this.delegate = null, this.toDisposeOnClean = ge.None, this.toDisposeOnSetContainer = ge.None, this.shadowRoot = null, this.shadowRootHostElement = null, this.view = Xe(".context-view"), this.useFixedPosition = !1, this.useShadowDOM = !1, bF(this.view), this.setContainer(e, t), this._register(Ri(() => this.setContainer(
      null,
      1
      /* ABSOLUTE */
    )));
  }
  setContainer(e, t) {
    var i;
    if (this.container && (this.toDisposeOnSetContainer.dispose(), this.shadowRoot ? (this.shadowRoot.removeChild(this.view), this.shadowRoot = null, (i = this.shadowRootHostElement) === null || i === void 0 || i.remove(), this.shadowRootHostElement = null) : this.container.removeChild(this.view), this.container = null), e) {
      if (this.container = e, this.useFixedPosition = t !== 1, this.useShadowDOM = t === 3, this.useShadowDOM) {
        this.shadowRootHostElement = Xe(".shadow-root-host"), this.container.appendChild(this.shadowRootHostElement), this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: "open" });
        const o = document.createElement("style");
        o.textContent = wpe, this.shadowRoot.appendChild(o), this.shadowRoot.appendChild(this.view), this.shadowRoot.appendChild(Xe("slot"));
      } else
        this.container.appendChild(this.view);
      const r = new ht();
      tg.BUBBLE_UP_EVENTS.forEach((o) => {
        r.add(Jr(this.container, o, (s) => {
          this.onDOMEvent(s, !1);
        }));
      }), tg.BUBBLE_DOWN_EVENTS.forEach((o) => {
        r.add(Jr(this.container, o, (s) => {
          this.onDOMEvent(s, !0);
        }, !0));
      }), this.toDisposeOnSetContainer = r;
    }
  }
  show(e) {
    this.isVisible() && this.hide(), Ts(this.view), this.view.className = "context-view", this.view.style.top = "0px", this.view.style.left = "0px", this.view.style.zIndex = "2500", this.view.style.position = this.useFixedPosition ? "fixed" : "absolute", NG(this.view), this.toDisposeOnClean = e.render(this.view) || ge.None, this.delegate = e, this.doLayout(), this.delegate.focus && this.delegate.focus();
  }
  getViewElement() {
    return this.view;
  }
  layout() {
    if (this.isVisible()) {
      if (this.delegate.canRelayout === !1 && !(_g && jS.pointerEvents)) {
        this.hide();
        return;
      }
      this.delegate.layout && this.delegate.layout(), this.doLayout();
    }
  }
  doLayout() {
    if (!this.isVisible())
      return;
    let e = this.delegate.getAnchor(), t;
    if (OG(e)) {
      let h = ja(e);
      t = {
        top: h.top,
        left: h.left,
        width: h.width,
        height: h.height
      };
    } else
      t = {
        top: e.y,
        left: e.x,
        width: e.width || 1,
        height: e.height || 2
      };
    const i = qR(this.view), r = YR(this.view), o = this.delegate.anchorPosition || 0, s = this.delegate.anchorAlignment || 0, a = this.delegate.anchorAxisAlignment || 0;
    let l, u;
    if (a === 0) {
      const h = {
        offset: t.top - window.pageYOffset,
        size: t.height,
        position: o === 0 ? 0 : 1
        /* After */
      }, d = { offset: t.left, size: t.width, position: s === 0 ? 0 : 1, mode: Gc.ALIGN };
      l = Qf(window.innerHeight, r, h) + window.pageYOffset, lr.intersects({ start: l, end: l + r }, { start: h.offset, end: h.offset + h.size }) && (d.mode = Gc.AVOID), u = Qf(window.innerWidth, i, d);
    } else {
      const h = {
        offset: t.left,
        size: t.width,
        position: s === 0 ? 0 : 1
        /* After */
      }, d = { offset: t.top, size: t.height, position: o === 0 ? 0 : 1, mode: Gc.ALIGN };
      u = Qf(window.innerWidth, i, h), lr.intersects({ start: u, end: u + i }, { start: h.offset, end: h.offset + h.size }) && (d.mode = Gc.AVOID), l = Qf(window.innerHeight, r, d) + window.pageYOffset;
    }
    this.view.classList.remove("top", "bottom", "left", "right"), this.view.classList.add(o === 0 ? "bottom" : "top"), this.view.classList.add(s === 0 ? "left" : "right"), this.view.classList.toggle("fixed", this.useFixedPosition);
    const c = ja(this.container);
    this.view.style.top = `${l - (this.useFixedPosition ? ja(this.view).top : c.top)}px`, this.view.style.left = `${u - (this.useFixedPosition ? ja(this.view).left : c.left)}px`, this.view.style.width = "initial";
  }
  hide(e) {
    const t = this.delegate;
    this.delegate = null, t != null && t.onHide && t.onHide(e), this.toDisposeOnClean.dispose(), bF(this.view);
  }
  isVisible() {
    return !!this.delegate;
  }
  onDOMEvent(e, t) {
    this.delegate && (this.delegate.onDOMEvent ? this.delegate.onDOMEvent(e, document.activeElement) : t && !Ku(e.target, this.container) && this.hide());
  }
  dispose() {
    this.hide(), super.dispose();
  }
}
tg.BUBBLE_UP_EVENTS = ["click", "keydown", "focus", "blur"];
tg.BUBBLE_DOWN_EVENTS = ["click"];
let wpe = (
  /* css */
  `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	@font-face {
		font-family: "codicon";
		src: url("./codicon.ttf?5d4d76ab2ce5108968ad644d591a16a6") format("truetype");
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`
);
function Z2(n) {
  let e = n.definition;
  for (; e instanceof Vi; )
    e = e.definition;
  return `.codicon-${n.id}:before { content: '${e.fontCharacter}'; }`;
}
function s7(...n) {
  return function(e, t) {
    for (let i = 0, r = n.length; i < r; i++) {
      const o = n[i](e, t);
      if (o)
        return o;
    }
    return null;
  };
}
const yI = bpe.bind(void 0, !0);
function bpe(n, e, t) {
  if (!t || t.length < e.length)
    return null;
  let i;
  return n ? i = mN(t, e) : i = t.indexOf(e) === 0, i ? e.length > 0 ? [{ start: 0, end: e.length }] : [] : null;
}
function Spe(n, e) {
  const t = e.toLowerCase().indexOf(n.toLowerCase());
  return t === -1 ? null : [{ start: t, end: t + n.length }];
}
function Epe(n, e) {
  return QT(n.toLowerCase(), e.toLowerCase(), 0, 0);
}
function QT(n, e, t, i) {
  if (t === n.length)
    return [];
  if (i === e.length)
    return null;
  if (n[t] === e[i]) {
    let r = null;
    return (r = QT(n, e, t + 1, i + 1)) ? SI({ start: i, end: i + 1 }, r) : null;
  }
  return QT(n, e, t, i + 1);
}
function wI(n) {
  return 97 <= n && n <= 122;
}
function x0(n) {
  return 65 <= n && n <= 90;
}
function bI(n) {
  return 48 <= n && n <= 57;
}
function a7(n) {
  return n === 32 || n === 9 || n === 10 || n === 13;
}
const l7 = /* @__PURE__ */ new Set();
"`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?".split("").forEach((n) => l7.add(n.charCodeAt(0)));
function tS(n) {
  return a7(n) || l7.has(n);
}
function Lpe(n, e) {
  return n === e || tS(n) && tS(e);
}
function u7(n) {
  return wI(n) || x0(n) || bI(n);
}
function SI(n, e) {
  return e.length === 0 ? e = [n] : n.end === e[0].start ? e[0].start = n.start : e.unshift(n), e;
}
function c7(n, e) {
  for (let t = e; t < n.length; t++) {
    const i = n.charCodeAt(t);
    if (x0(i) || bI(i) || t > 0 && !u7(n.charCodeAt(t - 1)))
      return t;
  }
  return n.length;
}
function JT(n, e, t, i) {
  if (t === n.length)
    return [];
  if (i === e.length)
    return null;
  if (n[t] !== e[i].toLowerCase())
    return null;
  {
    let r = null, o = i + 1;
    for (r = JT(n, e, t + 1, i + 1); !r && (o = c7(e, o)) < e.length; )
      r = JT(n, e, t + 1, o), o++;
    return r === null ? null : SI({ start: i, end: i + 1 }, r);
  }
}
function Dpe(n) {
  let e = 0, t = 0, i = 0, r = 0, o = 0;
  for (let c = 0; c < n.length; c++)
    o = n.charCodeAt(c), x0(o) && e++, wI(o) && t++, u7(o) && i++, bI(o) && r++;
  const s = e / n.length, a = t / n.length, l = i / n.length, u = r / n.length;
  return { upperPercent: s, lowerPercent: a, alphaPercent: l, numericPercent: u };
}
function Rpe(n) {
  const { upperPercent: e, lowerPercent: t } = n;
  return t === 0 && e > 0.6;
}
function Tpe(n) {
  const { upperPercent: e, lowerPercent: t, alphaPercent: i, numericPercent: r } = n;
  return t > 0.2 && e < 0.8 && i > 0.6 && r < 0.2;
}
function Ope(n) {
  let e = 0, t = 0, i = 0, r = 0;
  for (let o = 0; o < n.length; o++)
    i = n.charCodeAt(o), x0(i) && e++, wI(i) && t++, a7(i) && r++;
  return (e === 0 || t === 0) && r === 0 ? n.length <= 30 : e <= 5;
}
function h7(n, e) {
  if (!e || (e = e.trim(), e.length === 0) || !Ope(n) || e.length > 60)
    return null;
  const t = Dpe(e);
  if (!Tpe(t)) {
    if (!Rpe(t))
      return null;
    e = e.toLowerCase();
  }
  let i = null, r = 0;
  for (n = n.toLowerCase(); r < e.length && (i = JT(n, e, 0, r)) === null; )
    r = c7(e, r + 1);
  return i;
}
function Uye(n, e, t = !1) {
  if (!e || e.length === 0)
    return null;
  let i = null, r = 0;
  for (n = n.toLowerCase(), e = e.toLowerCase(); r < e.length && (i = eO(n, e, 0, r, t)) === null; )
    r = d7(e, r + 1);
  return i;
}
function eO(n, e, t, i, r) {
  if (t === n.length)
    return [];
  if (i === e.length)
    return null;
  if (Lpe(n.charCodeAt(t), e.charCodeAt(i))) {
    let o = null, s = i + 1;
    if (o = eO(n, e, t + 1, i + 1, r), !r)
      for (; !o && (s = d7(e, s)) < e.length; )
        o = eO(n, e, t + 1, s, r), s++;
    return o === null ? null : SI({ start: i, end: i + 1 }, o);
  } else
    return null;
}
function d7(n, e) {
  for (let t = e; t < n.length; t++)
    if (tS(n.charCodeAt(t)) || t > 0 && tS(n.charCodeAt(t - 1)))
      return t;
  return n.length;
}
const xpe = s7(yI, h7, Spe), Npe = s7(yI, h7, Epe), Q2 = new yN(1e4);
function J2(n, e, t = !1) {
  if (typeof n != "string" || typeof e != "string")
    return null;
  let i = Q2.get(n);
  i || (i = new RegExp(Jne(n), "i"), Q2.set(n, i));
  const r = i.exec(e);
  return r ? [{ start: r.index, end: r.index + r[0].length }] : t ? Npe(n, e) : xpe(n, e);
}
function zye(n, e, t, i, r, o) {
  const s = Math.min(13, n.length);
  for (; t < s; t++) {
    const a = iS(n, e, t, i, r, o, !1);
    if (a)
      return a;
  }
  return [0, o];
}
function jye(n) {
  if (typeof n > "u")
    return [];
  const e = [], t = n[1];
  for (let i = n.length - 1; i > 1; i--) {
    const r = n[i] + t, o = e[e.length - 1];
    o && o.end === r ? o.end = r + 1 : e.push({ start: r, end: r + 1 });
  }
  return e;
}
const Uc = 128;
function EI() {
  const n = [], e = [];
  for (let t = 0; t <= Uc; t++)
    e[t] = 0;
  for (let t = 0; t <= Uc; t++)
    n.push(e.slice(0));
  return n;
}
function f7(n) {
  const e = [];
  for (let t = 0; t <= n; t++)
    e[t] = 0;
  return e;
}
const p7 = f7(2 * Uc), tO = f7(2 * Uc), _u = EI(), Fh = EI(), Oy = EI();
function xy(n, e) {
  if (e < 0 || e >= n.length)
    return !1;
  const t = n.codePointAt(e);
  switch (t) {
    case 95:
    case 45:
    case 46:
    case 32:
    case 47:
    case 92:
    case 39:
    case 34:
    case 58:
    case 36:
    case 60:
    case 40:
    case 91:
      return !0;
    case void 0:
      return !1;
    default:
      return !!nv(t);
  }
}
function eW(n, e) {
  if (e < 0 || e >= n.length)
    return !1;
  switch (n.charCodeAt(e)) {
    case 32:
    case 9:
      return !0;
    default:
      return !1;
  }
}
function pw(n, e, t) {
  return e[n] !== t[n];
}
function Ipe(n, e, t, i, r, o, s = !1) {
  for (; e < t && r < o; )
    n[e] === i[r] && (s && (p7[e] = r), e += 1), r += 1;
  return e === t;
}
var _d;
(function(n) {
  n.Default = [-100, 0];
  function e(t) {
    return !t || t.length === 2 && t[0] === -100 && t[1] === 0;
  }
  n.isDefault = e;
})(_d || (_d = {}));
function iS(n, e, t, i, r, o, s) {
  const a = n.length > Uc ? Uc : n.length, l = i.length > Uc ? Uc : i.length;
  if (t >= a || o >= l || a - t > l - o || !Ipe(e, t, a, r, o, l, !0))
    return;
  Ppe(a, l, t, o, e, r);
  let u = 1, c = 1, h = t, d = o;
  const f = [!1];
  for (u = 1, h = t; h < a; u++, h++) {
    const v = p7[h], C = tO[h], y = h + 1 < a ? tO[h + 1] : l;
    for (c = v - o + 1, d = v; d < y; c++, d++) {
      let b = Number.MIN_SAFE_INTEGER, L = !1;
      d <= C && (b = Ape(n, e, h, t, i, r, d, l, o, _u[u - 1][c - 1] === 0, f));
      let S = 0;
      b !== Number.MAX_SAFE_INTEGER && (L = !0, S = b + Fh[u - 1][c - 1]);
      const E = d > v, D = E ? Fh[u][c - 1] + (_u[u][c - 1] > 0 ? -5 : 0) : 0, O = d > v + 1 && _u[u][c - 1] > 0, T = O ? Fh[u][c - 2] + (_u[u][c - 2] > 0 ? -5 : 0) : 0;
      if (O && (!E || T >= D) && (!L || T >= S))
        Fh[u][c] = T, Oy[u][c] = 3, _u[u][c] = 0;
      else if (E && (!L || D >= S))
        Fh[u][c] = D, Oy[u][c] = 2, _u[u][c] = 0;
      else if (L)
        Fh[u][c] = S, Oy[u][c] = 1, _u[u][c] = _u[u - 1][c - 1] + 1;
      else
        throw new Error("not possible");
    }
  }
  if (!f[0] && !s)
    return;
  u--, c--;
  const p = [Fh[u][c], o];
  let g = 0, _ = 0;
  for (; u >= 1; ) {
    let v = c;
    do {
      const C = Oy[u][v];
      if (C === 3)
        v = v - 2;
      else if (C === 2)
        v = v - 1;
      else
        break;
    } while (v >= 1);
    g > 1 && e[t + u - 1] === r[o + c - 1] && !pw(v + o - 1, i, r) && g + 1 > _u[u][v] && (v = c), v === c ? g++ : g = 1, _ || (_ = v), u--, c = v - 1, p.push(c);
  }
  l === a && (p[0] += 2);
  const m = _ - a;
  return p[0] -= m, p;
}
function Ppe(n, e, t, i, r, o) {
  let s = n - 1, a = e - 1;
  for (; s >= t && a >= i; )
    r[s] === o[a] && (tO[s] = a, s--), a--;
}
function Ape(n, e, t, i, r, o, s, a, l, u, c) {
  if (e[t] !== o[s])
    return Number.MIN_SAFE_INTEGER;
  let h = 1, d = !1;
  return s === t - i ? h = n[t] === r[s] ? 7 : 5 : pw(s, r, o) && (s === 0 || !pw(s - 1, r, o)) ? (h = n[t] === r[s] ? 7 : 5, d = !0) : xy(o, s) && (s === 0 || !xy(o, s - 1)) ? h = 5 : (xy(o, s - 1) || eW(o, s - 1)) && (h = 5, d = !0), h > 1 && t === i && (c[0] = !0), d || (d = pw(s, r, o) || xy(o, s - 1) || eW(o, s - 1)), t === i ? s > l && (h -= d ? 3 : 5) : u ? h += d ? 2 : 0 : h += d ? 0 : 1, s + 1 === a && (h -= d ? 3 : 5), h;
}
function $ye(n, e, t, i, r, o, s) {
  return Mpe(n, e, t, i, r, o, !0, s);
}
function Mpe(n, e, t, i, r, o, s, a) {
  let l = iS(n, e, t, i, r, o, a);
  if (l && !s)
    return l;
  if (n.length >= 3) {
    const u = Math.min(7, n.length - 1);
    for (let c = t + 1; c < u; c++) {
      const h = Fpe(n, c);
      if (h) {
        const d = iS(h, h.toLowerCase(), t, i, r, o, a);
        d && (d[0] -= 3, (!l || d[0] > l[0]) && (l = d));
      }
    }
  }
  return l;
}
function Fpe(n, e) {
  if (e + 1 >= n.length)
    return;
  const t = n[e], i = n[e + 1];
  if (t !== i)
    return n.slice(0, e) + i + t + n.slice(e + 2);
}
const bv = "$(", LI = new RegExp(`\\$\\(${Vo.iconNameExpression}(?:${Vo.iconModifierExpression})?\\)`, "g"), kpe = new RegExp(`(\\\\)?${LI.source}`, "g");
function Kye(n) {
  return n.replace(kpe, (e, t) => t ? e : `\\${e}`);
}
const Wpe = new RegExp(`\\\\${LI.source}`, "g");
function qye(n) {
  return n.replace(Wpe, (e) => `\\${e}`);
}
const Vpe = new RegExp(`(\\s)?(\\\\)?${LI.source}(\\s)?`, "g");
function Bpe(n) {
  return n.indexOf(bv) === -1 ? n : n.replace(Vpe, (e, t, i, r) => i ? e : t || r || "");
}
function Ny(n) {
  const e = n.indexOf(bv);
  return e === -1 ? { text: n } : Hpe(n, e);
}
function Hpe(n, e) {
  const t = [];
  let i = "";
  function r(d) {
    if (d) {
      i += d;
      for (const f of d)
        t.push(a);
    }
  }
  let o = -1, s = "", a = 0, l, u, c = e;
  const h = n.length;
  for (r(n.substr(0, e)); c < h; ) {
    if (l = n[c], u = n[c + 1], l === bv[0] && u === bv[1])
      o = c, r(s), s = bv, c++;
    else if (l === ")" && o !== -1) {
      const d = c - o + 1;
      a += d, o = -1, s = "";
    } else
      o !== -1 ? /^[a-z0-9\-]$/i.test(l) ? s += l : (r(s), o = -1, s = "") : r(l);
    c++;
  }
  return r(s), { text: i, iconOffsets: t };
}
function Iy(n, e, t = !1) {
  const { text: i, iconOffsets: r } = e;
  if (!r || r.length === 0)
    return J2(n, i, t);
  const o = fN(i, " "), s = i.length - o.length, a = J2(n, o, t);
  if (a)
    for (const l of a) {
      const u = r[l.start + s] + s;
      l.start += u, l.end += u;
    }
  return a;
}
const iO = /\(&([^\s&])\)|(^|[^&])&([^\s&])/, $D = /(&amp;)?(&amp;)([^\s&])/g, g7 = va("menu-selection", Vi.check), m7 = va("menu-submenu", Vi.chevronRight);
var nS;
(function(n) {
  n[n.Right = 0] = "Right", n[n.Left = 1] = "Left";
})(nS || (nS = {}));
let v7 = class Km extends Qp {
  constructor(e, t, i = {}) {
    e.classList.add("monaco-menu-container"), e.setAttribute("role", "presentation");
    const r = document.createElement("div");
    r.classList.add("monaco-menu"), r.setAttribute("role", "presentation"), super(r, {
      orientation: 1,
      actionViewItemProvider: (a) => this.doGetActionViewItem(a, i, o),
      context: i.context,
      actionRunner: i.actionRunner,
      ariaLabel: i.ariaLabel,
      focusOnlyEnabledItems: !0,
      triggerKeys: { keys: [3, ...Ft || Rs ? [
        10
        /* Space */
      ] : []], keyDown: !0 }
    }), this.menuElement = r, this.actionsList.setAttribute("role", "menu"), this.actionsList.tabIndex = 0, this.menuDisposables = this._register(new ht()), this.initializeStyleSheet(e), ye(r, Be.KEY_DOWN, (a) => {
      new Ki(a).equals(
        2
        /* Tab */
      ) && a.preventDefault();
    }), i.enableMnemonics && this.menuDisposables.add(ye(r, Be.KEY_DOWN, (a) => {
      const l = a.key.toLocaleLowerCase();
      if (this.mnemonics.has(l)) {
        gi.stop(a, !0);
        const u = this.mnemonics.get(l);
        if (u.length === 1 && (u[0] instanceof tW && u[0].container && this.focusItemByElement(u[0].container), u[0].onClick(a)), u.length > 1) {
          const c = u.shift();
          c && c.container && (this.focusItemByElement(c.container), u.push(c)), this.mnemonics.set(l, u);
        }
      }
    })), Rs && this._register(ye(r, Be.KEY_DOWN, (a) => {
      const l = new Ki(a);
      l.equals(
        14
        /* Home */
      ) || l.equals(
        11
        /* PageUp */
      ) ? (this.focusedItem = this.viewItems.length - 1, this.focusNext(), gi.stop(a, !0)) : (l.equals(
        13
        /* End */
      ) || l.equals(
        12
        /* PageDown */
      )) && (this.focusedItem = 0, this.focusPrevious(), gi.stop(a, !0));
    })), this._register(ye(this.domNode, Be.MOUSE_OUT, (a) => {
      let l = a.relatedTarget;
      Ku(l, this.domNode) || (this.focusedItem = void 0, this.updateFocus(), a.stopPropagation());
    })), this._register(ye(this.actionsList, Be.MOUSE_OVER, (a) => {
      let l = a.target;
      if (!(!l || !Ku(l, this.actionsList) || l === this.actionsList)) {
        for (; l.parentElement !== this.actionsList && l.parentElement !== null; )
          l = l.parentElement;
        if (l.classList.contains("action-item")) {
          const u = this.focusedItem;
          this.setFocusedItem(l), u !== this.focusedItem && this.updateFocus();
        }
      }
    }));
    let o = {
      parent: this
    };
    this.mnemonics = /* @__PURE__ */ new Map(), this.scrollableElement = this._register(new T3(r, {
      alwaysConsumeMouseWheel: !0,
      horizontal: 2,
      vertical: 3,
      verticalScrollbarSize: 7,
      handleMouseWheel: !0,
      useShadows: !0
    }));
    const s = this.scrollableElement.getDomNode();
    s.style.position = "", this._register(ye(s, Be.MOUSE_UP, (a) => {
      a.preventDefault();
    })), r.style.maxHeight = `${Math.max(10, window.innerHeight - e.getBoundingClientRect().top - 35)}px`, t = t.filter((a) => {
      var l;
      return !((l = i.submenuIds) === null || l === void 0) && l.has(a.id) ? (console.warn(`Found submenu cycle: ${a.id}`), !1) : !0;
    }), this.push(t, { icon: !0, label: !0, isMenu: !0 }), e.appendChild(this.scrollableElement.getDomNode()), this.scrollableElement.scanDomNode(), this.viewItems.filter((a) => !(a instanceof KD)).forEach((a, l, u) => {
      a.updatePositionInSet(l + 1, u.length);
    });
  }
  initializeStyleSheet(e) {
    dN(e) ? (this.styleSheet = Os(e), this.styleSheet.textContent = iW) : (Km.globalStyleSheet || (Km.globalStyleSheet = Os(), Km.globalStyleSheet.textContent = iW), this.styleSheet = Km.globalStyleSheet);
  }
  style(e) {
    const t = this.getContainer(), i = e.foregroundColor ? `${e.foregroundColor}` : "", r = e.backgroundColor ? `${e.backgroundColor}` : "", o = e.borderColor ? `1px solid ${e.borderColor}` : "", s = e.shadowColor ? `0 2px 4px ${e.shadowColor}` : "";
    t.style.border = o, this.domNode.style.color = i, this.domNode.style.backgroundColor = r, t.style.boxShadow = s, this.viewItems && this.viewItems.forEach((a) => {
      (a instanceof nO || a instanceof KD) && a.style(e);
    });
  }
  getContainer() {
    return this.scrollableElement.getDomNode();
  }
  get onScroll() {
    return this.scrollableElement.onScroll;
  }
  focusItemByElement(e) {
    const t = this.focusedItem;
    this.setFocusedItem(e), t !== this.focusedItem && this.updateFocus();
  }
  setFocusedItem(e) {
    for (let t = 0; t < this.actionsList.children.length; t++) {
      let i = this.actionsList.children[t];
      if (e === i) {
        this.focusedItem = t;
        break;
      }
    }
  }
  updateFocus(e) {
    super.updateFocus(e, !0), typeof this.focusedItem < "u" && this.scrollableElement.setScrollPosition({
      scrollTop: Math.round(this.menuElement.scrollTop)
    });
  }
  doGetActionViewItem(e, t, i) {
    if (e instanceof Yd)
      return new KD(t.context, e, { icon: !0 });
    if (e instanceof M5) {
      const r = new tW(e, e.actions, i, Object.assign(Object.assign({}, t), { submenuIds: /* @__PURE__ */ new Set([...t.submenuIds || [], e.id]) }));
      if (t.enableMnemonics) {
        const o = r.getMnemonic();
        if (o && r.isEnabled()) {
          let s = [];
          this.mnemonics.has(o) && (s = this.mnemonics.get(o)), s.push(r), this.mnemonics.set(o, s);
        }
      }
      return r;
    } else {
      const r = { enableMnemonics: t.enableMnemonics, useEventAsContext: t.useEventAsContext };
      if (t.getKeyBinding) {
        const s = t.getKeyBinding(e);
        if (s) {
          const a = s.getLabel();
          a && (r.keybinding = a);
        }
      }
      const o = new nO(t.context, e, r);
      if (t.enableMnemonics) {
        const s = o.getMnemonic();
        if (s && o.isEnabled()) {
          let a = [];
          this.mnemonics.has(s) && (a = this.mnemonics.get(s)), a.push(o), this.mnemonics.set(s, a);
        }
      }
      return o;
    }
  }
};
class nO extends yv {
  constructor(e, t, i = {}) {
    if (i.isMenu = !0, super(t, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "", this.options.label && i.enableMnemonics) {
      let r = this.getAction().label;
      if (r) {
        let o = iO.exec(r);
        o && (this.mnemonic = (o[1] ? o[1] : o[3]).toLocaleLowerCase());
      }
    }
    this.runOnceToEnableMouseUp = new to(() => {
      this.element && (this._register(ye(this.element, Be.MOUSE_UP, (r) => {
        if (gi.stop(r, !0), Qr) {
          if (new ca(r).rightButton)
            return;
          this.onClick(r);
        } else
          setTimeout(() => {
            this.onClick(r);
          }, 0);
      })), this._register(ye(this.element, Be.CONTEXT_MENU, (r) => {
        gi.stop(r, !0);
      })));
    }, 100), this._register(this.runOnceToEnableMouseUp);
  }
  render(e) {
    super.render(e), this.element && (this.container = e, this.item = Ie(this.element, Xe("a.action-menu-item")), this._action.id === Yd.ID ? this.item.setAttribute("role", "presentation") : (this.item.setAttribute("role", "menuitem"), this.mnemonic && this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`)), this.check = Ie(this.item, Xe("span.menu-item-check" + g7.cssSelector)), this.check.setAttribute("role", "none"), this.label = Ie(this.item, Xe("span.action-label")), this.options.label && this.options.keybinding && (Ie(this.item, Xe("span.keybinding")).textContent = this.options.keybinding), this.runOnceToEnableMouseUp.schedule(), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked());
  }
  blur() {
    super.blur(), this.applyStyle();
  }
  focus() {
    super.focus(), this.item && this.item.focus(), this.applyStyle();
  }
  updatePositionInSet(e, t) {
    this.item && (this.item.setAttribute("aria-posinset", `${e}`), this.item.setAttribute("aria-setsize", `${t}`));
  }
  updateLabel() {
    if (this.label && this.options.label) {
      Ts(this.label);
      let e = Bpe(this.getAction().label);
      if (e) {
        const t = Gpe(e);
        this.options.enableMnemonics || (e = t), this.label.setAttribute("aria-label", t.replace(/&&/g, "&"));
        const i = iO.exec(e);
        if (i) {
          e = PG(e), $D.lastIndex = 0;
          let r = $D.exec(e);
          for (; r && r[1]; )
            r = $D.exec(e);
          const o = (s) => s.replace(/&amp;&amp;/g, "&amp;");
          r ? this.label.append(fN(o(e.substr(0, r.index)), " "), Xe("u", { "aria-hidden": "true" }, r[3]), AG(o(e.substr(r.index + r[0].length)), " ")) : this.label.innerText = o(e).trim(), this.item && this.item.setAttribute("aria-keyshortcuts", (i[1] ? i[1] : i[3]).toLocaleLowerCase());
        } else
          this.label.innerText = e.replace(/&&/g, "&").trim();
      }
    }
  }
  updateTooltip() {
    let e = null;
    this.getAction().tooltip ? e = this.getAction().tooltip : !this.options.label && this.getAction().label && this.options.icon && (e = this.getAction().label, this.options.keybinding && (e = w({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", e, this.options.keybinding))), e && this.item && (this.item.title = e);
  }
  updateClass() {
    this.cssClass && this.item && this.item.classList.remove(...this.cssClass.split(" ")), this.options.icon && this.label ? (this.cssClass = this.getAction().class || "", this.label.classList.add("icon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" ")), this.updateEnabled()) : this.label && this.label.classList.remove("icon");
  }
  updateEnabled() {
    this.getAction().enabled ? (this.element && (this.element.classList.remove("disabled"), this.element.removeAttribute("aria-disabled")), this.item && (this.item.classList.remove("disabled"), this.item.removeAttribute("aria-disabled"), this.item.tabIndex = 0)) : (this.element && (this.element.classList.add("disabled"), this.element.setAttribute("aria-disabled", "true")), this.item && (this.item.classList.add("disabled"), this.item.setAttribute("aria-disabled", "true")));
  }
  updateChecked() {
    this.item && (this.getAction().checked ? (this.item.classList.add("checked"), this.item.setAttribute("role", "menuitemcheckbox"), this.item.setAttribute("aria-checked", "true")) : (this.item.classList.remove("checked"), this.item.setAttribute("role", "menuitem"), this.item.setAttribute("aria-checked", "false")));
  }
  getMnemonic() {
    return this.mnemonic;
  }
  applyStyle() {
    if (!this.menuStyle)
      return;
    const e = this.element && this.element.classList.contains("focused"), t = e && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor, i = e && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0, r = e && this.menuStyle.selectionBorderColor ? `thin solid ${this.menuStyle.selectionBorderColor}` : "";
    this.item && (this.item.style.color = t ? t.toString() : "", this.item.style.backgroundColor = i ? i.toString() : ""), this.check && (this.check.style.color = t ? t.toString() : ""), this.container && (this.container.style.border = r);
  }
  style(e) {
    this.menuStyle = e, this.applyStyle();
  }
}
class tW extends nO {
  constructor(e, t, i, r) {
    super(e, e, r), this.submenuActions = t, this.parentData = i, this.submenuOptions = r, this.mysubmenu = null, this.submenuDisposables = this._register(new ht()), this.mouseOver = !1, this.expandDirection = r && r.expandDirection !== void 0 ? r.expandDirection : nS.Right, this.showScheduler = new to(() => {
      this.mouseOver && (this.cleanupExistingSubmenu(!1), this.createSubmenu(!1));
    }, 250), this.hideScheduler = new to(() => {
      this.element && !Ku(fp(), this.element) && this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    }, 750);
  }
  render(e) {
    super.render(e), this.element && (this.item && (this.item.classList.add("monaco-submenu-item"), this.item.tabIndex = 0, this.item.setAttribute("aria-haspopup", "true"), this.updateAriaExpanded("false"), this.submenuIndicator = Ie(this.item, Xe("span.submenu-indicator" + m7.cssSelector)), this.submenuIndicator.setAttribute("aria-hidden", "true")), this._register(ye(this.element, Be.KEY_UP, (t) => {
      let i = new Ki(t);
      (i.equals(
        17
        /* RightArrow */
      ) || i.equals(
        3
        /* Enter */
      )) && (gi.stop(t, !0), this.createSubmenu(!0));
    })), this._register(ye(this.element, Be.KEY_DOWN, (t) => {
      let i = new Ki(t);
      fp() === this.item && (i.equals(
        17
        /* RightArrow */
      ) || i.equals(
        3
        /* Enter */
      )) && gi.stop(t, !0);
    })), this._register(ye(this.element, Be.MOUSE_OVER, (t) => {
      this.mouseOver || (this.mouseOver = !0, this.showScheduler.schedule());
    })), this._register(ye(this.element, Be.MOUSE_LEAVE, (t) => {
      this.mouseOver = !1;
    })), this._register(ye(this.element, Be.FOCUS_OUT, (t) => {
      this.element && !Ku(fp(), this.element) && this.hideScheduler.schedule();
    })), this._register(this.parentData.parent.onScroll(() => {
      this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!1);
    })));
  }
  updateEnabled() {
  }
  onClick(e) {
    gi.stop(e, !0), this.cleanupExistingSubmenu(!1), this.createSubmenu(!0);
  }
  cleanupExistingSubmenu(e) {
    if (this.parentData.submenu && (e || this.parentData.submenu !== this.mysubmenu)) {
      try {
        this.parentData.submenu.dispose();
      } catch {
      }
      this.parentData.submenu = void 0, this.updateAriaExpanded("false"), this.submenuContainer && (this.submenuDisposables.clear(), this.submenuContainer = void 0);
    }
  }
  calculateSubmenuMenuLayout(e, t, i, r) {
    const o = { top: 0, left: 0 };
    return o.left = Qf(e.width, t.width, { position: r === nS.Right ? 0 : 1, offset: i.left, size: i.width }), o.left >= i.left && o.left < i.left + i.width && (i.left + 10 + t.width <= e.width && (o.left = i.left + 10), i.top += 10, i.height = 0), o.top = Qf(e.height, t.height, { position: 0, offset: i.top, size: 0 }), o.top + t.height === i.top && o.top + i.height + t.height <= e.height && (o.top += i.height), o;
  }
  createSubmenu(e = !0) {
    if (this.element)
      if (this.parentData.submenu)
        this.parentData.submenu.focus(!1);
      else {
        this.updateAriaExpanded("true"), this.submenuContainer = Ie(this.element, Xe("div.monaco-submenu")), this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
        const t = getComputedStyle(this.parentData.parent.domNode), i = parseFloat(t.paddingTop || "0") || 0;
        this.submenuContainer.style.zIndex = "1", this.submenuContainer.style.position = "fixed", this.submenuContainer.style.top = "0", this.submenuContainer.style.left = "0", this.parentData.submenu = new v7(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new a0()], this.submenuOptions), this.menuStyle && this.parentData.submenu.style(this.menuStyle);
        const r = this.element.getBoundingClientRect(), o = {
          top: r.top - i,
          left: r.left,
          height: r.height + 2 * i,
          width: r.width
        }, s = this.submenuContainer.getBoundingClientRect(), { top: a, left: l } = this.calculateSubmenuMenuLayout(new Ua(window.innerWidth, window.innerHeight), Ua.lift(s), o, this.expandDirection);
        this.submenuContainer.style.left = `${l}px`, this.submenuContainer.style.top = `${a}px`, this.submenuDisposables.add(ye(this.submenuContainer, Be.KEY_UP, (u) => {
          new Ki(u).equals(
            15
            /* LeftArrow */
          ) && (gi.stop(u, !0), this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0));
        })), this.submenuDisposables.add(ye(this.submenuContainer, Be.KEY_DOWN, (u) => {
          new Ki(u).equals(
            15
            /* LeftArrow */
          ) && gi.stop(u, !0);
        })), this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
          this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0);
        })), this.parentData.submenu.focus(e), this.mysubmenu = this.parentData.submenu;
      }
  }
  updateAriaExpanded(e) {
    var t;
    this.item && ((t = this.item) === null || t === void 0 || t.setAttribute("aria-expanded", e));
  }
  applyStyle() {
    if (super.applyStyle(), !this.menuStyle)
      return;
    const t = this.element && this.element.classList.contains("focused") && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    this.submenuIndicator && (this.submenuIndicator.style.color = t ? `${t}` : ""), this.parentData.submenu && this.parentData.submenu.style(this.menuStyle);
  }
  dispose() {
    super.dispose(), this.hideScheduler.dispose(), this.mysubmenu && (this.mysubmenu.dispose(), this.mysubmenu = null), this.submenuContainer && (this.submenuContainer = void 0);
  }
}
class KD extends V3 {
  style(e) {
    this.label && (this.label.style.borderBottomColor = e.separatorColor ? `${e.separatorColor}` : "");
  }
}
function Gpe(n) {
  const e = iO, t = e.exec(n);
  if (!t)
    return n;
  const i = !t[1];
  return n.replace(e, i ? "$2$3" : "").trim();
}
let iW = `
.monaco-menu {
	font-size: 13px;

}

${Z2(g7)}
${Z2(m7)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar.animated .action-item.active {
	transform: scale(1.272019649, 1.272019649); /* 1.272019649 =  */
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	opacity: 0.4;
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid #bbb;
	padding-top: 1px;
	margin-left: .8em;
	margin-right: .8em;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	padding: 0.5em 0 0 0;
	margin-bottom: 0.5em;
	width: 100%;
	height: 0px !important;
	margin-left: .8em !important;
	margin-right: .8em !important;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	border: thin solid transparent; /* prevents jumping behaviour on hover or focus */
}


/* High Contrast Theming */
:host-context(.hc-black) .context-view.monaco-menu-container {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: .5em 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 1.8em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	padding: 0.2em 0 0 0;
	margin-bottom: 0.2em;
}

:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}

/* Arrows */
.monaco-scrollable-element > .scrollbar > .scra {
	cursor: pointer;
	font-size: 11px !important;
}

.monaco-scrollable-element > .visible {
	opacity: 1;

	/* Background rule added for IE9 - to allow clicks on dom node */
	background:rgba(0,0,0,0);

	transition: opacity 100ms linear;
}
.monaco-scrollable-element > .invisible {
	opacity: 0;
	pointer-events: none;
}
.monaco-scrollable-element > .invisible.fade {
	transition: opacity 800ms linear;
}

/* Scrollable Content Inset Shadow */
.monaco-scrollable-element > .shadow {
	position: absolute;
	display: none;
}
.monaco-scrollable-element > .shadow.top {
	display: block;
	top: 0;
	left: 3px;
	height: 3px;
	width: 100%;
	box-shadow: #DDD 0 6px 6px -6px inset;
}
.monaco-scrollable-element > .shadow.left {
	display: block;
	top: 3px;
	left: 0;
	height: 100%;
	width: 3px;
	box-shadow: #DDD 6px 0 6px -6px inset;
}
.monaco-scrollable-element > .shadow.top-left-corner {
	display: block;
	top: 0;
	left: 0;
	height: 3px;
	width: 3px;
}
.monaco-scrollable-element > .shadow.top.left {
	box-shadow: #DDD 6px 6px 6px -6px inset;
}

/* ---------- Default Style ---------- */

:host-context(.vs) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(100, 100, 100, .4);
}
:host-context(.vs-dark) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(121, 121, 121, .4);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(111, 195, 223, .6);
}

.monaco-scrollable-element > .scrollbar > .slider:hover {
	background: rgba(100, 100, 100, .7);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider:hover {
	background: rgba(111, 195, 223, .8);
}

.monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(0, 0, 0, .6);
}
:host-context(.vs-dark) .monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(191, 191, 191, .4);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(111, 195, 223, 1);
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.top {
	box-shadow: none;
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.left {
	box-shadow: #000 6px 0 6px -6px inset;
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.top.left {
	box-shadow: #000 6px 6px 6px -6px inset;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.top {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.left {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.top.left {
	box-shadow: none;
}
`;
function Fa(n, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (let i in e) {
    const r = e[i];
    r && (t[i] = Ic(r, n));
  }
  return t;
}
function DI(n, e, t) {
  function i() {
    const r = Fa(n.getColorTheme(), e);
    typeof t == "function" ? t(r) : t.style(r);
  }
  return i(), n.onDidColorThemeChange(i);
}
function Yye(n, e, t) {
  return DI(e, {
    badgeBackground: (t == null ? void 0 : t.badgeBackground) || a3,
    badgeForeground: (t == null ? void 0 : t.badgeForeground) || l3,
    badgeBorder: dr
  }, n);
}
function ig(n, e, t) {
  return DI(e, Object.assign(Object.assign({}, N0), t || {}), n);
}
const N0 = {
  listFocusBackground: que,
  listFocusForeground: Yue,
  listFocusOutline: Xue,
  listActiveSelectionBackground: pd,
  listActiveSelectionForeground: Qc,
  listFocusAndSelectionBackground: pd,
  listFocusAndSelectionForeground: Qc,
  listInactiveSelectionBackground: Zue,
  listInactiveSelectionForeground: Que,
  listInactiveFocusBackground: Jue,
  listInactiveFocusOutline: ece,
  listHoverBackground: tce,
  listHoverForeground: ice,
  listDropBackground: nce,
  listSelectionOutline: xs,
  listHoverOutline: xs,
  listFilterWidgetBackground: oce,
  listFilterWidgetOutline: sce,
  listFilterWidgetNoMatchesOutline: ace,
  listMatchesShadow: Fb,
  treeIndentGuidesStroke: lce,
  tableColumnsBorder: uce
}, Upe = {
  shadowColor: Fb,
  borderColor: dce,
  foregroundColor: fce,
  backgroundColor: pce,
  selectionForegroundColor: gce,
  selectionBackgroundColor: mce,
  selectionBorderColor: vce,
  separatorColor: _ce
};
function zpe(n, e, t) {
  return DI(e, Object.assign(Object.assign({}, Upe), t), n);
}
class jpe {
  constructor(e, t, i, r, o) {
    this.contextViewService = e, this.telemetryService = t, this.notificationService = i, this.keybindingService = r, this.themeService = o, this.focusToReturn = null, this.block = null, this.options = { blockMouse: !0 };
  }
  configure(e) {
    this.options = e;
  }
  showContextMenu(e) {
    const t = e.getActions();
    if (!t.length)
      return;
    this.focusToReturn = document.activeElement;
    let i, r = OG(e.domForShadowRoot) ? e.domForShadowRoot : void 0;
    this.contextViewService.showContextView({
      getAnchor: () => e.getAnchor(),
      canRelayout: !1,
      anchorAlignment: e.anchorAlignment,
      anchorAxisAlignment: e.anchorAxisAlignment,
      render: (o) => {
        let s = e.getMenuClassName ? e.getMenuClassName() : "";
        s && (o.className += " " + s), this.options.blockMouse && (this.block = o.appendChild(Xe(".context-view-block")), this.block.style.position = "fixed", this.block.style.cursor = "initial", this.block.style.left = "0", this.block.style.top = "0", this.block.style.width = "100%", this.block.style.height = "100%", this.block.style.zIndex = "-1", yt(this.block, Be.MOUSE_DOWN)((u) => u.stopPropagation()));
        const a = new ht(), l = e.actionRunner || new WN();
        return l.onBeforeRun(this.onActionRun, this, a), l.onDidRun(this.onDidActionRun, this, a), i = new v7(o, t, {
          actionViewItemProvider: e.getActionViewItem,
          context: e.getActionsContext ? e.getActionsContext() : null,
          actionRunner: l,
          getKeyBinding: e.getKeyBinding ? e.getKeyBinding : (u) => this.keybindingService.lookupKeybinding(u.id)
        }), a.add(zpe(i, this.themeService)), i.onDidCancel(() => this.contextViewService.hideContextView(!0), null, a), i.onDidBlur(() => this.contextViewService.hideContextView(!0), null, a), yt(window, Be.BLUR)(() => {
          this.contextViewService.hideContextView(!0);
        }, null, a), yt(window, Be.MOUSE_DOWN)((u) => {
          if (u.defaultPrevented)
            return;
          let c = new ca(u), h = c.target;
          if (!c.rightButton) {
            for (; h; ) {
              if (h === o)
                return;
              h = h.parentElement;
            }
            this.contextViewService.hideContextView(!0);
          }
        }, null, a), cp(a, i);
      },
      focus: () => {
        i && i.focus(!!e.autoSelectFirstItem);
      },
      onHide: (o) => {
        e.onHide && e.onHide(!!o), this.block && (this.block.remove(), this.block = null), this.focusToReturn && this.focusToReturn.focus();
      }
    }, r, !!r);
  }
  onActionRun(e) {
    this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "contextMenu" }), this.contextViewService.hideContextView(!1), this.focusToReturn && this.focusToReturn.focus();
  }
  onDidActionRun(e) {
    e.error && !I_(e.error) && this.notificationService.error(e.error);
  }
}
var $pe = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Mm = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let rO = class extends ge {
  constructor(e, t, i, r, o) {
    super(), this.contextMenuHandler = new jpe(i, e, t, r, o);
  }
  configure(e) {
    this.contextMenuHandler.configure(e);
  }
  // ContextMenu
  showContextMenu(e) {
    this.contextMenuHandler.showContextMenu(e), $f.getInstance().resetKeyStatus();
  }
};
rO = $pe([
  Mm(0, p0),
  Mm(1, tl),
  Mm(2, xg),
  Mm(3, Ro),
  Mm(4, Qn)
], rO);
const I0 = Vt("layoutService");
var Kpe = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, qpe = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let oO = class extends ge {
  constructor(e) {
    super(), this.layoutService = e, this.currentViewDisposable = ge.None, this.container = e.container, this.contextView = this._register(new tg(
      this.container,
      1
      /* ABSOLUTE */
    )), this.layout(), this._register(e.onDidLayout(() => this.layout()));
  }
  // ContextView
  setContainer(e, t) {
    this.contextView.setContainer(
      e,
      t || 1
      /* ABSOLUTE */
    );
  }
  showContextView(e, t, i) {
    t ? t !== this.container && (this.container = t, this.setContainer(
      t,
      i ? 3 : 2
      /* FIXED */
    )) : this.container !== this.layoutService.container && (this.container = this.layoutService.container, this.setContainer(
      this.container,
      1
      /* ABSOLUTE */
    )), this.contextView.show(e);
    const r = Ri(() => {
      this.currentViewDisposable === r && this.hideContextView();
    });
    return this.currentViewDisposable = r, r;
  }
  getContextViewElement() {
    return this.contextView.getViewElement();
  }
  layout() {
    this.contextView.layout();
  }
  hideContextView(e) {
    this.contextView.hide(e);
  }
};
oO = Kpe([
  qpe(0, I0)
], oO);
const _7 = Vt("dialogService");
let Ype = class {
  constructor(e) {
    this.incoming = /* @__PURE__ */ new Map(), this.outgoing = /* @__PURE__ */ new Map(), this.data = e;
  }
};
class Xpe {
  constructor(e) {
    this._hashFn = e, this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const e = [];
    for (let t of this._nodes.values())
      t.outgoing.size === 0 && e.push(t);
    return e;
  }
  insertEdge(e, t) {
    const i = this.lookupOrInsertNode(e), r = this.lookupOrInsertNode(t);
    i.outgoing.set(this._hashFn(t), r), r.incoming.set(this._hashFn(e), i);
  }
  removeNode(e) {
    const t = this._hashFn(e);
    this._nodes.delete(t);
    for (let i of this._nodes.values())
      i.outgoing.delete(t), i.incoming.delete(t);
  }
  lookupOrInsertNode(e) {
    const t = this._hashFn(e);
    let i = this._nodes.get(t);
    return i || (i = new Ype(e), this._nodes.set(t, i)), i;
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    let e = [];
    for (let [t, i] of this._nodes)
      e.push(`${t}, (incoming)[${[...i.incoming.keys()].join(", ")}], (outgoing)[${[...i.outgoing.keys()].join(",")}]`);
    return e.join(`
`);
  }
  /**
   * This is brute force and slow and **only** be used
   * to trouble shoot.
   */
  findCycleSlow() {
    for (let [e, t] of this._nodes) {
      const i = /* @__PURE__ */ new Set([e]), r = this._findCycle(t, i);
      if (r)
        return r;
    }
  }
  _findCycle(e, t) {
    for (let [i, r] of e.outgoing) {
      if (t.has(i))
        return [...t, i].join(" -> ");
      t.add(i);
      const o = this._findCycle(r, t);
      if (o)
        return o;
      t.delete(i);
    }
  }
}
class nW extends Error {
  constructor(e) {
    var t;
    super("cyclic dependency between services"), this.message = (t = e.findCycleSlow()) !== null && t !== void 0 ? t : `UNABLE to detect cycle, dumping graph: 
${e.toString()}`;
  }
}
class rS {
  constructor(e = new s_(), t = !1, i) {
    this._activeInstantiations = /* @__PURE__ */ new Set(), this._services = e, this._strict = t, this._parent = i, this._services.set(eo, this);
  }
  createChild(e) {
    return new rS(e, this._strict, this);
  }
  invokeFunction(e, ...t) {
    let i = oa.traceInvocation(e), r = !1;
    try {
      return e({
        get: (s, a) => {
          if (r)
            throw Uie("service accessor is only valid during the invocation of its target method");
          const l = this._getOrCreateServiceInstance(s, i);
          if (!l && a !== mne)
            throw new Error(`[invokeFunction] unknown service '${s}'`);
          return l;
        }
      }, ...t);
    } finally {
      r = !0, i.stop();
    }
  }
  createInstance(e, ...t) {
    let i, r;
    return e instanceof Pc ? (i = oa.traceCreation(e.ctor), r = this._createInstance(e.ctor, e.staticArguments.concat(t), i)) : (i = oa.traceCreation(e), r = this._createInstance(e, t, i)), i.stop(), r;
  }
  _createInstance(e, t = [], i) {
    let r = za.getServiceDependencies(e).sort((a, l) => a.index - l.index), o = [];
    for (const a of r) {
      let l = this._getOrCreateServiceInstance(a.id, i);
      if (!l && this._strict && !a.optional)
        throw new Error(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`);
      o.push(l);
    }
    let s = r.length > 0 ? r[0].index : t.length;
    if (t.length !== s) {
      console.warn(`[createInstance] First service dependency of ${e.name} at position ${s + 1} conflicts with ${t.length} static arguments`);
      let a = s - t.length;
      a > 0 ? t = t.concat(new Array(a)) : t = t.slice(0, s);
    }
    return new e(...t, ...o);
  }
  _setServiceInstance(e, t) {
    if (this._services.get(e) instanceof Pc)
      this._services.set(e, t);
    else if (this._parent)
      this._parent._setServiceInstance(e, t);
    else
      throw new Error("illegalState - setting UNKNOWN service instance");
  }
  _getServiceInstanceOrDescriptor(e) {
    let t = this._services.get(e);
    return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t;
  }
  _getOrCreateServiceInstance(e, t) {
    let i = this._getServiceInstanceOrDescriptor(e);
    return i instanceof Pc ? this._safeCreateAndCacheServiceInstance(e, i, t.branch(e, !0)) : (t.branch(e, !1), i);
  }
  _safeCreateAndCacheServiceInstance(e, t, i) {
    if (this._activeInstantiations.has(e))
      throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
    this._activeInstantiations.add(e);
    try {
      return this._createAndCacheServiceInstance(e, t, i);
    } finally {
      this._activeInstantiations.delete(e);
    }
  }
  _createAndCacheServiceInstance(e, t, i) {
    const r = new Xpe((a) => a.id.toString());
    let o = 0;
    const s = [{ id: e, desc: t, _trace: i }];
    for (; s.length; ) {
      const a = s.pop();
      if (r.lookupOrInsertNode(a), o++ > 1e3)
        throw new nW(r);
      for (let l of za.getServiceDependencies(a.desc.ctor)) {
        let u = this._getServiceInstanceOrDescriptor(l.id);
        if (!u && !l.optional && console.warn(`[createInstance] ${e} depends on ${l.id} which is NOT registered.`), u instanceof Pc) {
          const c = { id: l.id, desc: u, _trace: a._trace.branch(l.id, !0) };
          r.insertEdge(a, c), s.push(c);
        }
      }
    }
    for (; ; ) {
      const a = r.roots();
      if (a.length === 0) {
        if (!r.isEmpty())
          throw new nW(r);
        break;
      }
      for (const { data: l } of a) {
        if (this._getServiceInstanceOrDescriptor(l.id) instanceof Pc) {
          const c = this._createServiceInstanceWithOwner(l.id, l.desc.ctor, l.desc.staticArguments, l.desc.supportsDelayedInstantiation, l._trace);
          this._setServiceInstance(l.id, c);
        }
        r.removeNode(l);
      }
    }
    return this._getServiceInstanceOrDescriptor(e);
  }
  _createServiceInstanceWithOwner(e, t, i = [], r, o) {
    if (this._services.get(e) instanceof Pc)
      return this._createServiceInstance(t, i, r, o);
    if (this._parent)
      return this._parent._createServiceInstanceWithOwner(e, t, i, r, o);
    throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`);
  }
  _createServiceInstance(e, t = [], i, r) {
    if (i) {
      const o = new vG(() => this._createInstance(e, t, r));
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(s, a) {
          if (a in s)
            return s[a];
          let l = o.value, u = l[a];
          return typeof u != "function" || (u = u.bind(l), s[a] = u), u;
        },
        set(s, a, l) {
          return o.value[a] = l, !0;
        }
      });
    } else
      return this._createInstance(e, t, r);
  }
}
class oa {
  constructor(e, t) {
    this.type = e, this.name = t, this._start = Date.now(), this._dep = [];
  }
  static traceInvocation(e) {
    return oa._None;
  }
  static traceCreation(e) {
    return oa._None;
  }
  branch(e, t) {
    let i = new oa(2, e.toString());
    return this._dep.push([e, t, i]), i;
  }
  stop() {
    let e = Date.now() - this._start;
    oa._totals += e;
    let t = !1;
    function i(o, s) {
      let a = [], l = new Array(o + 1).join("	");
      for (const [u, c, h] of s._dep)
        if (c && h) {
          t = !0, a.push(`${l}CREATES -> ${u}`);
          let d = i(o + 1, h);
          d && a.push(d);
        } else
          a.push(`${l}uses -> ${u}`);
      return a.join(`
`);
    }
    let r = [
      `${this.type === 0 ? "CREATE" : "CALL"} ${this.name}`,
      `${i(1, this)}`,
      `DONE, took ${e.toFixed(2)}ms (grand total ${oa._totals.toFixed(2)}ms)`
    ];
    (e > 2 || t) && console.log(r.join(`
`));
  }
}
oa._None = new class extends oa {
  constructor() {
    super(-1, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}();
oa._totals = 0;
const Zpe = Vt("labelService");
class kh extends Error {
  constructor(e, t) {
    super(`ListError [${e}] ${t}`);
  }
}
function rW(n, e) {
  const t = [];
  for (let i of e) {
    if (n.start >= i.range.end)
      continue;
    if (n.end < i.range.start)
      break;
    const r = lr.intersect(n, i.range);
    lr.isEmpty(r) || t.push({
      range: r,
      size: i.size
    });
  }
  return t;
}
function sO({ start: n, end: e }, t) {
  return { start: n + t, end: e + t };
}
function Qpe(n) {
  const e = [];
  let t = null;
  for (let i of n) {
    const r = i.range.start, o = i.range.end, s = i.size;
    if (t && s === t.size) {
      t.range.end = o;
      continue;
    }
    t = { range: { start: r, end: o }, size: s }, e.push(t);
  }
  return e;
}
function Jpe(...n) {
  return Qpe(n.reduce((e, t) => e.concat(t), []));
}
class oW {
  constructor() {
    this.groups = [], this._size = 0;
  }
  splice(e, t, i = []) {
    const r = i.length - t, o = rW({ start: 0, end: e }, this.groups), s = rW({ start: e + t, end: Number.POSITIVE_INFINITY }, this.groups).map((l) => ({ range: sO(l.range, r), size: l.size })), a = i.map((l, u) => ({
      range: { start: e + u, end: e + u + 1 },
      size: l.size
    }));
    this.groups = Jpe(o, a, s), this._size = this.groups.reduce((l, u) => l + u.size * (u.range.end - u.range.start), 0);
  }
  /**
   * Returns the number of items in the range map.
   */
  get count() {
    const e = this.groups.length;
    return e ? this.groups[e - 1].range.end : 0;
  }
  /**
   * Returns the sum of the sizes of all items in the range map.
   */
  get size() {
    return this._size;
  }
  /**
   * Returns the index of the item at the given position.
   */
  indexAt(e) {
    if (e < 0)
      return -1;
    let t = 0, i = 0;
    for (let r of this.groups) {
      const o = r.range.end - r.range.start, s = i + o * r.size;
      if (e < s)
        return t + Math.floor((e - i) / r.size);
      t += o, i = s;
    }
    return t;
  }
  /**
   * Returns the index of the item right after the item at the
   * index of the given position.
   */
  indexAfter(e) {
    return Math.min(this.indexAt(e) + 1, this.count);
  }
  /**
   * Returns the start position of the item at the given index.
   */
  positionAt(e) {
    if (e < 0)
      return -1;
    let t = 0, i = 0;
    for (let r of this.groups) {
      const o = r.range.end - r.range.start, s = i + o;
      if (e < s)
        return t + (e - i) * r.size;
      t += o * r.size, i = s;
    }
    return -1;
  }
}
function ege(n) {
  try {
    n.parentElement && n.parentElement.removeChild(n);
  } catch {
  }
}
class tge {
  constructor(e) {
    this.renderers = e, this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Returns a row either by creating a new one or reusing
   * a previously released row which shares the same templateId.
   */
  alloc(e) {
    let t = this.getTemplateCache(e).pop();
    if (!t) {
      const i = Xe(".monaco-list-row"), o = this.getRenderer(e).renderTemplate(i);
      t = { domNode: i, templateId: e, templateData: o };
    }
    return t;
  }
  /**
   * Releases the row for eventual reuse.
   */
  release(e) {
    e && this.releaseRow(e);
  }
  releaseRow(e) {
    const { domNode: t, templateId: i } = e;
    t && (t.classList.remove("scrolling"), ege(t)), this.getTemplateCache(i).push(e);
  }
  getTemplateCache(e) {
    let t = this.cache.get(e);
    return t || (t = [], this.cache.set(e, t)), t;
  }
  dispose() {
    this.cache.forEach((e, t) => {
      for (const i of e)
        this.getRenderer(t).disposeTemplate(i.templateData), i.templateData = null;
    }), this.cache.clear();
  }
  getRenderer(e) {
    const t = this.renderers.get(e);
    if (!t)
      throw new Error(`No renderer found for ${e}`);
    return t;
  }
}
var Qd = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
};
const Sl = {
  useShadows: !0,
  verticalScrollMode: 1,
  setRowLineHeight: !0,
  setRowHeight: !0,
  supportDynamicHeights: !1,
  dnd: {
    getDragElements(n) {
      return [n];
    },
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    }
  },
  horizontalScrolling: !1,
  transformOptimization: !0,
  alwaysConsumeMouseWheel: !0
};
class q_ {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class ige {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class nge {
  constructor() {
    this.types = [], this.files = [];
  }
  update(e) {
    if (e.types && this.types.splice(0, this.types.length, ...e.types), e.files) {
      this.files.splice(0, this.files.length);
      for (let t = 0; t < e.files.length; t++) {
        const i = e.files.item(t);
        i && (i.size || i.type) && this.files.push(i);
      }
    }
  }
  getData() {
    return {
      types: this.types,
      files: this.files
    };
  }
}
function rge(n, e) {
  return Array.isArray(n) && Array.isArray(e) ? Gu(n, e) : n === e;
}
class oge {
  constructor(e) {
    e != null && e.getSetSize ? this.getSetSize = e.getSetSize.bind(e) : this.getSetSize = (t, i, r) => r, e != null && e.getPosInSet ? this.getPosInSet = e.getPosInSet.bind(e) : this.getPosInSet = (t, i) => i + 1, e != null && e.getRole ? this.getRole = e.getRole.bind(e) : this.getRole = (t) => "listitem", e != null && e.isChecked ? this.isChecked = e.isChecked.bind(e) : this.isChecked = (t) => {
    };
  }
}
class il {
  constructor(e, t, i, r = Sl) {
    if (this.virtualDelegate = t, this.domId = `list_id_${++il.InstanceCount}`, this.renderers = /* @__PURE__ */ new Map(), this.renderWidth = 0, this._scrollHeight = 0, this.scrollableElementUpdateDisposable = null, this.scrollableElementWidthDelayer = new cN(50), this.splicing = !1, this.dragOverAnimationStopDisposable = ge.None, this.dragOverMouseY = 0, this.canDrop = !1, this.currentDragFeedbackDisposable = ge.None, this.onDragLeaveTimeout = ge.None, this.disposables = new ht(), this._onDidChangeContentHeight = new j(), this._horizontalScrolling = !1, r.horizontalScrolling && r.supportDynamicHeights)
      throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
    this.items = [], this.itemId = 0, this.rangeMap = new oW();
    for (const s of i)
      this.renderers.set(s.templateId, s);
    this.cache = this.disposables.add(new tge(this.renderers)), this.lastRenderTop = 0, this.lastRenderHeight = 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-list", this.domNode.classList.add(this.domId), this.domNode.tabIndex = 0, this.domNode.classList.toggle("mouse-support", typeof r.mouseSupport == "boolean" ? r.mouseSupport : !0), this._horizontalScrolling = bl(r, (s) => s.horizontalScrolling, Sl.horizontalScrolling), this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this.additionalScrollHeight = typeof r.additionalScrollHeight > "u" ? 0 : r.additionalScrollHeight, this.accessibilityProvider = new oge(r.accessibilityProvider), this.rowsContainer = document.createElement("div"), this.rowsContainer.className = "monaco-list-rows", bl(r, (s) => s.transformOptimization, Sl.transformOptimization) && (this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)"), this.disposables.add(ri.addTarget(this.rowsContainer)), this.scrollable = new E0(bl(r, (s) => s.smoothScrolling, !1) ? 125 : 0, (s) => zl(s)), this.scrollableElement = this.disposables.add(new iI(this.rowsContainer, {
      alwaysConsumeMouseWheel: bl(r, (s) => s.alwaysConsumeMouseWheel, Sl.alwaysConsumeMouseWheel),
      horizontal: 1,
      vertical: bl(r, (s) => s.verticalScrollMode, Sl.verticalScrollMode),
      useShadows: bl(r, (s) => s.useShadows, Sl.useShadows)
    }, this.scrollable)), this.domNode.appendChild(this.scrollableElement.getDomNode()), e.appendChild(this.domNode), this.scrollableElement.onScroll(this.onScroll, this, this.disposables), yt(this.rowsContainer, Li.Change)((s) => this.onTouchChange(s), this, this.disposables), yt(this.scrollableElement.getDomNode(), "scroll")((s) => s.target.scrollTop = 0, null, this.disposables), Ae.map(yt(this.domNode, "dragover"), (s) => this.toDragEvent(s))(this.onDragOver, this, this.disposables), Ae.map(yt(this.domNode, "drop"), (s) => this.toDragEvent(s))(this.onDrop, this, this.disposables), yt(this.domNode, "dragleave")(this.onDragLeave, this, this.disposables), yt(window, "dragend")(this.onDragEnd, this, this.disposables), this.setRowLineHeight = bl(r, (s) => s.setRowLineHeight, Sl.setRowLineHeight), this.setRowHeight = bl(r, (s) => s.setRowHeight, Sl.setRowHeight), this.supportDynamicHeights = bl(r, (s) => s.supportDynamicHeights, Sl.supportDynamicHeights), this.dnd = bl(r, (s) => s.dnd, Sl.dnd), this.layout();
  }
  get contentHeight() {
    return this.rangeMap.size;
  }
  get horizontalScrolling() {
    return this._horizontalScrolling;
  }
  set horizontalScrolling(e) {
    if (e !== this._horizontalScrolling) {
      if (e && this.supportDynamicHeights)
        throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
      if (this._horizontalScrolling = e, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this._horizontalScrolling) {
        for (const t of this.items)
          this.measureItemWidth(t);
        this.updateScrollWidth(), this.scrollableElement.setScrollDimensions({ width: $L(this.domNode) }), this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
      } else
        this.scrollableElementWidthDelayer.cancel(), this.scrollableElement.setScrollDimensions({ width: this.renderWidth, scrollWidth: this.renderWidth }), this.rowsContainer.style.width = "";
    }
  }
  updateOptions(e) {
    e.additionalScrollHeight !== void 0 && (this.additionalScrollHeight = e.additionalScrollHeight, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), e.smoothScrolling !== void 0 && this.scrollable.setSmoothScrollDuration(e.smoothScrolling ? 125 : 0), e.horizontalScrolling !== void 0 && (this.horizontalScrolling = e.horizontalScrolling);
  }
  splice(e, t, i = []) {
    if (this.splicing)
      throw new Error("Can't run recursive splices.");
    this.splicing = !0;
    try {
      return this._splice(e, t, i);
    } finally {
      this.splicing = !1, this._onDidChangeContentHeight.fire(this.contentHeight);
    }
  }
  _splice(e, t, i = []) {
    const r = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), o = { start: e, end: e + t }, s = lr.intersect(r, o), a = /* @__PURE__ */ new Map();
    for (let L = s.start; L < s.end; L++) {
      const S = this.items[L];
      if (S.dragStartDisposable.dispose(), S.row) {
        let E = a.get(S.templateId);
        E || (E = [], a.set(S.templateId, E));
        const D = this.renderers.get(S.templateId);
        D && D.disposeElement && D.disposeElement(S.element, L, S.row.templateData, S.size), E.push(S.row);
      }
      S.row = null;
    }
    const l = { start: e + t, end: this.items.length }, u = lr.intersect(l, r), c = lr.relativeComplement(l, r), h = i.map((L) => ({
      id: String(this.itemId++),
      element: L,
      templateId: this.virtualDelegate.getTemplateId(L),
      size: this.virtualDelegate.getHeight(L),
      width: void 0,
      hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(L),
      lastDynamicHeightWidth: void 0,
      row: null,
      uri: void 0,
      dropTarget: !1,
      dragStartDisposable: ge.None
    }));
    let d;
    e === 0 && t >= this.items.length ? (this.rangeMap = new oW(), this.rangeMap.splice(0, 0, h), d = this.items, this.items = h) : (this.rangeMap.splice(e, t, h), d = this.items.splice(e, t, ...h));
    const f = i.length - t, p = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), g = sO(u, f), _ = lr.intersect(p, g);
    for (let L = _.start; L < _.end; L++)
      this.updateItemInDOM(this.items[L], L);
    const m = lr.relativeComplement(g, p);
    for (const L of m)
      for (let S = L.start; S < L.end; S++)
        this.removeItemFromDOM(S);
    const v = c.map((L) => sO(L, f)), y = [{ start: e, end: e + i.length }, ...v].map((L) => lr.intersect(p, L)), b = this.getNextToLastElement(y);
    for (const L of y)
      for (let S = L.start; S < L.end; S++) {
        const E = this.items[S], D = a.get(E.templateId), O = D == null ? void 0 : D.pop();
        this.insertItemInDOM(S, b, O);
      }
    for (const L of a.values())
      for (const S of L)
        this.cache.release(S);
    return this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight), d.map((L) => L.element);
  }
  eventuallyUpdateScrollDimensions() {
    this._scrollHeight = this.contentHeight, this.rowsContainer.style.height = `${this._scrollHeight}px`, this.scrollableElementUpdateDisposable || (this.scrollableElementUpdateDisposable = zl(() => {
      this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight }), this.updateScrollWidth(), this.scrollableElementUpdateDisposable = null;
    }));
  }
  eventuallyUpdateScrollWidth() {
    if (!this.horizontalScrolling) {
      this.scrollableElementWidthDelayer.cancel();
      return;
    }
    this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
  }
  updateScrollWidth() {
    if (!this.horizontalScrolling)
      return;
    let e = 0;
    for (const t of this.items)
      typeof t.width < "u" && (e = Math.max(e, t.width));
    this.scrollWidth = e, this.scrollableElement.setScrollDimensions({ scrollWidth: e === 0 ? 0 : e + 10 });
  }
  rerender() {
    if (this.supportDynamicHeights) {
      for (const e of this.items)
        e.lastDynamicHeightWidth = void 0;
      this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }
  get length() {
    return this.items.length;
  }
  get renderHeight() {
    return this.scrollableElement.getScrollDimensions().height;
  }
  element(e) {
    return this.items[e].element;
  }
  domElement(e) {
    const t = this.items[e].row;
    return t && t.domNode;
  }
  elementHeight(e) {
    return this.items[e].size;
  }
  elementTop(e) {
    return this.rangeMap.positionAt(e);
  }
  indexAt(e) {
    return this.rangeMap.indexAt(e);
  }
  indexAfter(e) {
    return this.rangeMap.indexAfter(e);
  }
  layout(e, t) {
    let i = {
      height: typeof e == "number" ? e : Une(this.domNode)
    };
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, i.scrollHeight = this.scrollHeight), this.scrollableElement.setScrollDimensions(i), typeof t < "u" && (this.renderWidth = t, this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight)), this.horizontalScrolling && this.scrollableElement.setScrollDimensions({
      width: typeof t == "number" ? t : $L(this.domNode)
    });
  }
  // Render
  render(e, t, i, r, o, s = !1) {
    const a = this.getRenderRange(t, i), l = lr.relativeComplement(a, e), u = lr.relativeComplement(e, a), c = this.getNextToLastElement(l);
    if (s) {
      const h = lr.intersect(e, a);
      for (let d = h.start; d < h.end; d++)
        this.updateItemInDOM(this.items[d], d);
    }
    for (const h of l)
      for (let d = h.start; d < h.end; d++)
        this.insertItemInDOM(d, c);
    for (const h of u)
      for (let d = h.start; d < h.end; d++)
        this.removeItemFromDOM(d);
    r !== void 0 && (this.rowsContainer.style.left = `-${r}px`), this.rowsContainer.style.top = `-${t}px`, this.horizontalScrolling && o !== void 0 && (this.rowsContainer.style.width = `${Math.max(o, this.renderWidth)}px`), this.lastRenderTop = t, this.lastRenderHeight = i;
  }
  // DOM operations
  insertItemInDOM(e, t, i) {
    const r = this.items[e];
    r.row || (r.row = i ?? this.cache.alloc(r.templateId));
    const o = this.accessibilityProvider.getRole(r.element) || "listitem";
    r.row.domNode.setAttribute("role", o);
    const s = this.accessibilityProvider.isChecked(r.element);
    typeof s < "u" && r.row.domNode.setAttribute("aria-checked", String(!!s)), r.row.domNode.parentElement || (t ? this.rowsContainer.insertBefore(r.row.domNode, t) : this.rowsContainer.appendChild(r.row.domNode)), this.updateItemInDOM(r, e);
    const a = this.renderers.get(r.templateId);
    if (!a)
      throw new Error(`No renderer found for template id ${r.templateId}`);
    a && a.renderElement(r.element, e, r.row.templateData, r.size);
    const l = this.dnd.getDragURI(r.element);
    if (r.dragStartDisposable.dispose(), r.row.domNode.draggable = !!l, l) {
      const u = yt(r.row.domNode, "dragstart");
      r.dragStartDisposable = u((c) => this.onDragStart(r.element, l, c));
    }
    this.horizontalScrolling && (this.measureItemWidth(r), this.eventuallyUpdateScrollWidth());
  }
  measureItemWidth(e) {
    if (!e.row || !e.row.domNode)
      return;
    e.row.domNode.style.width = Qr ? "-moz-fit-content" : "fit-content", e.width = $L(e.row.domNode);
    const t = window.getComputedStyle(e.row.domNode);
    t.paddingLeft && (e.width += parseFloat(t.paddingLeft)), t.paddingRight && (e.width += parseFloat(t.paddingRight)), e.row.domNode.style.width = "";
  }
  updateItemInDOM(e, t) {
    e.row.domNode.style.top = `${this.elementTop(t)}px`, this.setRowHeight && (e.row.domNode.style.height = `${e.size}px`), this.setRowLineHeight && (e.row.domNode.style.lineHeight = `${e.size}px`), e.row.domNode.setAttribute("data-index", `${t}`), e.row.domNode.setAttribute("data-last-element", t === this.length - 1 ? "true" : "false"), e.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(e.element, t, this.length))), e.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(e.element, t))), e.row.domNode.setAttribute("id", this.getElementDomId(t)), e.row.domNode.classList.toggle("drop-target", e.dropTarget);
  }
  removeItemFromDOM(e) {
    const t = this.items[e];
    if (t.dragStartDisposable.dispose(), t.row) {
      const i = this.renderers.get(t.templateId);
      i && i.disposeElement && i.disposeElement(t.element, e, t.row.templateData, t.size), this.cache.release(t.row), t.row = null;
    }
    this.horizontalScrolling && this.eventuallyUpdateScrollWidth();
  }
  getScrollTop() {
    return this.scrollableElement.getScrollPosition().scrollTop;
  }
  setScrollTop(e, t) {
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), this.scrollableElement.setScrollPosition({ scrollTop: e, reuseAnimation: t });
  }
  get scrollTop() {
    return this.getScrollTop();
  }
  set scrollTop(e) {
    this.setScrollTop(e);
  }
  get scrollHeight() {
    return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.additionalScrollHeight;
  }
  // Events
  get onMouseClick() {
    return Ae.map(yt(this.domNode, "click"), (e) => this.toMouseEvent(e));
  }
  get onMouseDblClick() {
    return Ae.map(yt(this.domNode, "dblclick"), (e) => this.toMouseEvent(e));
  }
  get onMouseMiddleClick() {
    return Ae.filter(Ae.map(yt(this.domNode, "auxclick"), (e) => this.toMouseEvent(e)), (e) => e.browserEvent.button === 1);
  }
  get onMouseDown() {
    return Ae.map(yt(this.domNode, "mousedown"), (e) => this.toMouseEvent(e));
  }
  get onContextMenu() {
    return Ae.any(Ae.map(yt(this.domNode, "contextmenu"), (e) => this.toMouseEvent(e)), Ae.map(yt(this.domNode, Li.Contextmenu), (e) => this.toGestureEvent(e)));
  }
  get onTouchStart() {
    return Ae.map(yt(this.domNode, "touchstart"), (e) => this.toTouchEvent(e));
  }
  get onTap() {
    return Ae.map(yt(this.rowsContainer, Li.Tap), (e) => this.toGestureEvent(e));
  }
  toMouseEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], r = i && i.element;
    return { browserEvent: e, index: t, element: r };
  }
  toTouchEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], r = i && i.element;
    return { browserEvent: e, index: t, element: r };
  }
  toGestureEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.initialTarget || null), i = typeof t > "u" ? void 0 : this.items[t], r = i && i.element;
    return { browserEvent: e, index: t, element: r };
  }
  toDragEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], r = i && i.element;
    return { browserEvent: e, index: t, element: r };
  }
  onScroll(e) {
    try {
      const t = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      this.render(t, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth), this.supportDynamicHeights && this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
    } catch (t) {
      throw console.error("Got bad scroll event:", e), t;
    }
  }
  onTouchChange(e) {
    e.preventDefault(), e.stopPropagation(), this.scrollTop -= e.translationY;
  }
  // DND
  onDragStart(e, t, i) {
    if (!i.dataTransfer)
      return;
    const r = this.dnd.getDragElements(e);
    if (i.dataTransfer.effectAllowed = "copyMove", i.dataTransfer.setData(W3.RESOURCES, JSON.stringify([t])), i.dataTransfer.setDragImage) {
      let o;
      this.dnd.getDragLabel && (o = this.dnd.getDragLabel(r, i)), typeof o > "u" && (o = String(r.length));
      const s = Xe(".monaco-drag-image");
      s.textContent = o, document.body.appendChild(s), i.dataTransfer.setDragImage(s, -10, -10), setTimeout(() => document.body.removeChild(s), 0);
    }
    this.currentDragData = new q_(r), bu.CurrentDragAndDropData = new ige(r), this.dnd.onDragStart && this.dnd.onDragStart(this.currentDragData, i);
  }
  onDragOver(e) {
    if (e.browserEvent.preventDefault(), this.onDragLeaveTimeout.dispose(), bu.CurrentDragAndDropData && bu.CurrentDragAndDropData.getData() === "vscode-ui" || (this.setupDragAndDropScrollTopAnimation(e.browserEvent), !e.browserEvent.dataTransfer))
      return !1;
    if (!this.currentDragData)
      if (bu.CurrentDragAndDropData)
        this.currentDragData = bu.CurrentDragAndDropData;
      else {
        if (!e.browserEvent.dataTransfer.types)
          return !1;
        this.currentDragData = new nge();
      }
    const t = this.dnd.onDragOver(this.currentDragData, e.element, e.index, e.browserEvent);
    if (this.canDrop = typeof t == "boolean" ? t : t.accept, !this.canDrop)
      return this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), !1;
    e.browserEvent.dataTransfer.dropEffect = typeof t != "boolean" && t.effect === 0 ? "copy" : "move";
    let i;
    if (typeof t != "boolean" && t.feedback ? i = t.feedback : typeof e.index > "u" ? i = [-1] : i = [e.index], i = h5(i).filter((r) => r >= -1 && r < this.length).sort((r, o) => r - o), i = i[0] === -1 ? [-1] : i, rge(this.currentDragFeedback, i))
      return !0;
    if (this.currentDragFeedback = i, this.currentDragFeedbackDisposable.dispose(), i[0] === -1)
      this.domNode.classList.add("drop-target"), this.rowsContainer.classList.add("drop-target"), this.currentDragFeedbackDisposable = Ri(() => {
        this.domNode.classList.remove("drop-target"), this.rowsContainer.classList.remove("drop-target");
      });
    else {
      for (const r of i) {
        const o = this.items[r];
        o.dropTarget = !0, o.row && o.row.domNode.classList.add("drop-target");
      }
      this.currentDragFeedbackDisposable = Ri(() => {
        for (const r of i) {
          const o = this.items[r];
          o.dropTarget = !1, o.row && o.row.domNode.classList.remove("drop-target");
        }
      });
    }
    return !0;
  }
  onDragLeave() {
    this.onDragLeaveTimeout.dispose(), this.onDragLeaveTimeout = jR(() => this.clearDragOverFeedback(), 100);
  }
  onDrop(e) {
    if (!this.canDrop)
      return;
    const t = this.currentDragData;
    this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.currentDragData = void 0, bu.CurrentDragAndDropData = void 0, !(!t || !e.browserEvent.dataTransfer) && (e.browserEvent.preventDefault(), t.update(e.browserEvent.dataTransfer), this.dnd.drop(t, e.element, e.index, e.browserEvent));
  }
  onDragEnd(e) {
    this.canDrop = !1, this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.currentDragData = void 0, bu.CurrentDragAndDropData = void 0, this.dnd.onDragEnd && this.dnd.onDragEnd(e);
  }
  clearDragOverFeedback() {
    this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), this.currentDragFeedbackDisposable = ge.None;
  }
  // DND scroll top animation
  setupDragAndDropScrollTopAnimation(e) {
    if (!this.dragOverAnimationDisposable) {
      const t = Gne(this.domNode).top;
      this.dragOverAnimationDisposable = Yne(this.animateDragAndDropScrollTop.bind(this, t));
    }
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationStopDisposable = jR(() => {
      this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
    }, 1e3), this.dragOverMouseY = e.pageY;
  }
  animateDragAndDropScrollTop(e) {
    if (this.dragOverMouseY === void 0)
      return;
    const t = this.dragOverMouseY - e, i = this.renderHeight - 35;
    t < 35 ? this.scrollTop += Math.max(-14, Math.floor(0.3 * (t - 35))) : t > i && (this.scrollTop += Math.min(14, Math.floor(0.3 * (t - i))));
  }
  teardownDragAndDropScrollTopAnimation() {
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
  }
  // Util
  getItemIndexFromEventTarget(e) {
    const t = this.scrollableElement.getDomNode();
    let i = e;
    for (; i instanceof HTMLElement && i !== this.rowsContainer && t.contains(i); ) {
      const r = i.getAttribute("data-index");
      if (r) {
        const o = Number(r);
        if (!isNaN(o))
          return o;
      }
      i = i.parentElement;
    }
  }
  getRenderRange(e, t) {
    return {
      start: this.rangeMap.indexAt(e),
      end: this.rangeMap.indexAfter(e + t - 1)
    };
  }
  /**
   * Given a stable rendered state, checks every rendered element whether it needs
   * to be probed for dynamic height. Adjusts scroll height and top if necessary.
   */
  _rerender(e, t, i) {
    const r = this.getRenderRange(e, t);
    let o, s;
    e === this.elementTop(r.start) ? (o = r.start, s = 0) : r.end - r.start > 1 && (o = r.start + 1, s = this.elementTop(o) - e);
    let a = 0;
    for (; ; ) {
      const l = this.getRenderRange(e, t);
      let u = !1;
      for (let c = l.start; c < l.end; c++) {
        const h = this.probeDynamicHeight(c);
        h !== 0 && this.rangeMap.splice(c, 1, [this.items[c]]), a += h, u = u || h !== 0;
      }
      if (!u) {
        a !== 0 && this.eventuallyUpdateScrollDimensions();
        const c = lr.relativeComplement(r, l);
        for (const d of c)
          for (let f = d.start; f < d.end; f++)
            this.items[f].row && this.removeItemFromDOM(f);
        const h = lr.relativeComplement(l, r);
        for (const d of h)
          for (let f = d.start; f < d.end; f++) {
            const p = f + 1, g = p < this.items.length ? this.items[p].row : null, _ = g ? g.domNode : null;
            this.insertItemInDOM(f, _);
          }
        for (let d = l.start; d < l.end; d++)
          this.items[d].row && this.updateItemInDOM(this.items[d], d);
        if (typeof o == "number") {
          const d = this.scrollable.getFutureScrollPosition().scrollTop - e, f = this.elementTop(o) - s + d;
          this.setScrollTop(f, i);
        }
        this._onDidChangeContentHeight.fire(this.contentHeight);
        return;
      }
    }
  }
  probeDynamicHeight(e) {
    const t = this.items[e];
    if (!t.hasDynamicHeight || t.lastDynamicHeightWidth === this.renderWidth || this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(t.element))
      return 0;
    const i = t.size;
    if (!this.setRowHeight && t.row) {
      let s = t.row.domNode.offsetHeight;
      return t.size = s, t.lastDynamicHeightWidth = this.renderWidth, s - i;
    }
    const r = this.cache.alloc(t.templateId);
    r.domNode.style.height = "", this.rowsContainer.appendChild(r.domNode);
    const o = this.renderers.get(t.templateId);
    return o && (o.renderElement(t.element, e, r.templateData, void 0), o.disposeElement && o.disposeElement(t.element, e, r.templateData, void 0)), t.size = r.domNode.offsetHeight, this.virtualDelegate.setDynamicHeight && this.virtualDelegate.setDynamicHeight(t.element, t.size), t.lastDynamicHeightWidth = this.renderWidth, this.rowsContainer.removeChild(r.domNode), this.cache.release(r), t.size - i;
  }
  getNextToLastElement(e) {
    const t = e[e.length - 1];
    if (!t)
      return null;
    const i = this.items[t.end];
    return !i || !i.row ? null : i.row.domNode;
  }
  getElementDomId(e) {
    return `${this.domId}_${e}`;
  }
  // Dispose
  dispose() {
    if (this.items) {
      for (const e of this.items)
        if (e.row) {
          const t = this.renderers.get(e.row.templateId);
          t && (t.disposeElement && t.disposeElement(e.element, -1, e.row.templateData, void 0), t.disposeTemplate(e.row.templateData));
        }
      this.items = [];
    }
    this.domNode && this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), yi(this.disposables);
  }
}
il.InstanceCount = 0;
Qd([
  Wn
], il.prototype, "onMouseClick", null);
Qd([
  Wn
], il.prototype, "onMouseDblClick", null);
Qd([
  Wn
], il.prototype, "onMouseMiddleClick", null);
Qd([
  Wn
], il.prototype, "onMouseDown", null);
Qd([
  Wn
], il.prototype, "onContextMenu", null);
Qd([
  Wn
], il.prototype, "onTouchStart", null);
Qd([
  Wn
], il.prototype, "onTap", null);
class sge {
  constructor(e) {
    this.spliceables = e;
  }
  splice(e, t, i) {
    this.spliceables.forEach((r) => r.splice(e, t, i));
  }
}
var P0 = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, sW = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class age {
  constructor(e) {
    this.trait = e, this.renderedElements = [];
  }
  get templateId() {
    return `template:${this.trait.trait}`;
  }
  renderTemplate(e) {
    return e;
  }
  renderElement(e, t, i) {
    const r = this.renderedElements.findIndex((o) => o.templateData === i);
    if (r >= 0) {
      const o = this.renderedElements[r];
      this.trait.unrender(i), o.index = t;
    } else {
      const o = { index: t, templateData: i };
      this.renderedElements.push(o);
    }
    this.trait.renderIndex(t, i);
  }
  splice(e, t, i) {
    const r = [];
    for (const o of this.renderedElements)
      o.index < e ? r.push(o) : o.index >= e + t && r.push({
        index: o.index + i - t,
        templateData: o.templateData
      });
    this.renderedElements = r;
  }
  renderIndexes(e) {
    for (const { index: t, templateData: i } of this.renderedElements)
      e.indexOf(t) > -1 && this.trait.renderIndex(t, i);
  }
  disposeTemplate(e) {
    const t = this.renderedElements.findIndex((i) => i.templateData === e);
    t < 0 || this.renderedElements.splice(t, 1);
  }
}
let oS = class {
  constructor(e) {
    this._trait = e, this.indexes = [], this.sortedIndexes = [], this._onChange = new j(), this.onChange = this._onChange.event;
  }
  get trait() {
    return this._trait;
  }
  get renderer() {
    return new age(this);
  }
  splice(e, t, i) {
    const r = i.length - t, o = e + t, s = [
      ...this.sortedIndexes.filter((a) => a < e),
      ...i.map((a, l) => a ? l + e : -1).filter((a) => a !== -1),
      ...this.sortedIndexes.filter((a) => a >= o).map((a) => a + r)
    ];
    this.renderer.splice(e, t, i.length), this._set(s, s);
  }
  renderIndex(e, t) {
    t.classList.toggle(this._trait, this.contains(e));
  }
  unrender(e) {
    e.classList.remove(this._trait);
  }
  /**
   * Sets the indexes which should have this trait.
   *
   * @param indexes Indexes which should have this trait.
   * @return The old indexes which had this trait.
   */
  set(e, t) {
    return this._set(e, [...e].sort(aW), t);
  }
  _set(e, t, i) {
    const r = this.indexes, o = this.sortedIndexes;
    this.indexes = e, this.sortedIndexes = t;
    const s = aO(o, e);
    return this.renderer.renderIndexes(s), this._onChange.fire({ indexes: e, browserEvent: i }), r;
  }
  get() {
    return this.indexes;
  }
  contains(e) {
    return tse(this.sortedIndexes, e, aW) >= 0;
  }
  dispose() {
    yi(this._onChange);
  }
};
P0([
  Wn
], oS.prototype, "renderer", null);
class lge extends oS {
  constructor(e) {
    super("selected"), this.setAriaSelected = e;
  }
  renderIndex(e, t) {
    super.renderIndex(e, t), this.setAriaSelected && (this.contains(e) ? t.setAttribute("aria-selected", "true") : t.setAttribute("aria-selected", "false"));
  }
}
class qD {
  constructor(e, t, i) {
    this.trait = e, this.view = t, this.identityProvider = i;
  }
  splice(e, t, i) {
    if (!this.identityProvider)
      return this.trait.splice(e, t, i.map(() => !1));
    const r = this.trait.get().map((s) => this.identityProvider.getId(this.view.element(s)).toString()), o = i.map((s) => r.indexOf(this.identityProvider.getId(s).toString()) > -1);
    this.trait.splice(e, t, o);
  }
}
function sh(n) {
  return n.tagName === "INPUT" || n.tagName === "TEXTAREA";
}
function Jf(n) {
  return n.classList.contains("monaco-editor") ? !0 : n.classList.contains("monaco-list") || !n.parentElement ? !1 : Jf(n.parentElement);
}
class uge {
  constructor(e, t, i) {
    this.list = e, this.view = t, this.disposables = new ht();
    const r = i.multipleSelectionSupport !== !1, o = Ae.chain(yt(t.domNode, "keydown")).filter((s) => !sh(s.target)).map((s) => new Ki(s));
    o.filter(
      (s) => s.keyCode === 3
      /* Enter */
    ).on(this.onEnter, this, this.disposables), o.filter(
      (s) => s.keyCode === 16
      /* UpArrow */
    ).on(this.onUpArrow, this, this.disposables), o.filter(
      (s) => s.keyCode === 18
      /* DownArrow */
    ).on(this.onDownArrow, this, this.disposables), o.filter(
      (s) => s.keyCode === 11
      /* PageUp */
    ).on(this.onPageUpArrow, this, this.disposables), o.filter(
      (s) => s.keyCode === 12
      /* PageDown */
    ).on(this.onPageDownArrow, this, this.disposables), o.filter(
      (s) => s.keyCode === 9
      /* Escape */
    ).on(this.onEscape, this, this.disposables), r && o.filter(
      (s) => (Ft ? s.metaKey : s.ctrlKey) && s.keyCode === 31
      /* KEY_A */
    ).on(this.onCtrlA, this, this.disposables);
  }
  onEnter(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(this.list.getFocus(), e.browserEvent);
  }
  onUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPrevious(1, !1, e.browserEvent), this.list.reveal(this.list.getFocus()[0]), this.view.domNode.focus();
  }
  onDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNext(1, !1, e.browserEvent), this.list.reveal(this.list.getFocus()[0]), this.view.domNode.focus();
  }
  onPageUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPreviousPage(e.browserEvent), this.list.reveal(this.list.getFocus()[0]), this.view.domNode.focus();
  }
  onPageDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNextPage(e.browserEvent), this.list.reveal(this.list.getFocus()[0]), this.view.domNode.focus();
  }
  onCtrlA(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(Ar(this.list.length), e.browserEvent), this.view.domNode.focus();
  }
  onEscape(e) {
    this.list.getSelection().length && (e.preventDefault(), e.stopPropagation(), this.list.setSelection([], e.browserEvent), this.view.domNode.focus());
  }
  dispose() {
    this.disposables.dispose();
  }
}
var ep;
(function(n) {
  n[n.Idle = 0] = "Idle", n[n.Typing = 1] = "Typing";
})(ep || (ep = {}));
const C7 = new class {
  mightProducePrintableCharacter(n) {
    return n.ctrlKey || n.metaKey || n.altKey ? !1 : n.keyCode >= 31 && n.keyCode <= 56 || n.keyCode >= 21 && n.keyCode <= 30 || n.keyCode >= 93 && n.keyCode <= 102 || n.keyCode >= 80 && n.keyCode <= 90;
  }
}();
class cge {
  constructor(e, t, i, r) {
    this.list = e, this.view = t, this.keyboardNavigationLabelProvider = i, this.delegate = r, this.enabled = !1, this.state = ep.Idle, this.automaticKeyboardNavigation = !0, this.triggered = !1, this.previouslyFocused = -1, this.enabledDisposables = new ht(), this.disposables = new ht(), this.updateOptions(e.options);
  }
  updateOptions(e) {
    (typeof e.enableKeyboardNavigation > "u" ? !0 : !!e.enableKeyboardNavigation) ? this.enable() : this.disable(), typeof e.automaticKeyboardNavigation < "u" && (this.automaticKeyboardNavigation = e.automaticKeyboardNavigation);
  }
  enable() {
    if (this.enabled)
      return;
    const e = Ae.chain(yt(this.view.domNode, "keydown")).filter((r) => !sh(r.target)).filter(() => this.automaticKeyboardNavigation || this.triggered).map((r) => new Ki(r)).filter((r) => this.delegate.mightProducePrintableCharacter(r)).forEach((r) => {
      r.stopPropagation(), r.preventDefault();
    }).map((r) => r.browserEvent.key).event, t = Ae.debounce(e, () => null, 800);
    Ae.reduce(Ae.any(e, t), (r, o) => o === null ? null : (r || "") + o)(this.onInput, this, this.enabledDisposables), t(this.onClear, this, this.enabledDisposables), this.enabled = !0, this.triggered = !1;
  }
  disable() {
    this.enabled && (this.enabledDisposables.clear(), this.enabled = !1, this.triggered = !1);
  }
  onClear() {
    var e;
    const t = this.list.getFocus();
    if (t.length > 0 && t[0] === this.previouslyFocused) {
      const i = (e = this.list.options.accessibilityProvider) === null || e === void 0 ? void 0 : e.getAriaLabel(this.list.element(t[0]));
      i && ed(i);
    }
    this.previouslyFocused = -1;
  }
  onInput(e) {
    if (!e) {
      this.state = ep.Idle, this.triggered = !1;
      return;
    }
    const t = this.list.getFocus(), i = t.length > 0 ? t[0] : 0, r = this.state === ep.Idle ? 1 : 0;
    this.state = ep.Typing;
    for (let o = 0; o < this.list.length; o++) {
      const s = (i + o + r) % this.list.length, a = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(s)), l = a && a.toString();
      if (typeof l > "u" || yI(e, l)) {
        this.previouslyFocused = i, this.list.setFocus([s]), this.list.reveal(s);
        return;
      }
    }
  }
  dispose() {
    this.disable(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
}
class hge {
  constructor(e, t) {
    this.list = e, this.view = t, this.disposables = new ht(), Ae.chain(yt(t.domNode, "keydown")).filter((r) => !sh(r.target)).map((r) => new Ki(r)).filter((r) => r.keyCode === 2 && !r.ctrlKey && !r.metaKey && !r.shiftKey && !r.altKey).on(this.onTab, this, this.disposables);
  }
  onTab(e) {
    if (e.target !== this.view.domNode)
      return;
    const t = this.list.getFocus();
    if (t.length === 0)
      return;
    const i = this.view.domElement(t[0]);
    if (!i)
      return;
    const r = i.querySelector("[tabIndex]");
    if (!r || !(r instanceof HTMLElement) || r.tabIndex === -1)
      return;
    const o = window.getComputedStyle(r);
    o.visibility === "hidden" || o.display === "none" || (e.preventDefault(), e.stopPropagation(), r.focus());
  }
  dispose() {
    this.disposables.dispose();
  }
}
function y7(n) {
  return Ft ? n.browserEvent.metaKey : n.browserEvent.ctrlKey;
}
function w7(n) {
  return n.browserEvent.shiftKey;
}
function dge(n) {
  return n instanceof MouseEvent && n.button === 2;
}
const fge = {
  isSelectionSingleChangeEvent: y7,
  isSelectionRangeChangeEvent: w7
};
class b7 {
  constructor(e) {
    this.list = e, this.disposables = new ht(), this._onPointer = new j(), this.onPointer = this._onPointer.event, this.multipleSelectionSupport = e.options.multipleSelectionSupport !== !1, this.multipleSelectionSupport && (this.multipleSelectionController = e.options.multipleSelectionController || fge), this.mouseSupport = typeof e.options.mouseSupport > "u" || !!e.options.mouseSupport, this.mouseSupport && (e.onMouseDown(this.onMouseDown, this, this.disposables), e.onContextMenu(this.onContextMenu, this, this.disposables), e.onMouseDblClick(this.onDoubleClick, this, this.disposables), e.onTouchStart(this.onMouseDown, this, this.disposables), this.disposables.add(ri.addTarget(e.getHTMLElement()))), Ae.any(e.onMouseClick, e.onMouseMiddleClick, e.onTap)(this.onViewPointer, this, this.disposables);
  }
  isSelectionSingleChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionSingleChangeEvent(e) : Ft ? e.browserEvent.metaKey : e.browserEvent.ctrlKey;
  }
  isSelectionRangeChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionRangeChangeEvent(e) : e.browserEvent.shiftKey;
  }
  isSelectionChangeEvent(e) {
    return this.isSelectionSingleChangeEvent(e) || this.isSelectionRangeChangeEvent(e);
  }
  onMouseDown(e) {
    Jf(e.browserEvent.target) || document.activeElement !== e.browserEvent.target && this.list.domFocus();
  }
  onContextMenu(e) {
    if (Jf(e.browserEvent.target))
      return;
    const t = typeof e.index > "u" ? [] : [e.index];
    this.list.setFocus(t, e.browserEvent);
  }
  onViewPointer(e) {
    if (!this.mouseSupport || sh(e.browserEvent.target) || Jf(e.browserEvent.target))
      return;
    const t = e.index;
    if (typeof t > "u") {
      this.list.setFocus([], e.browserEvent), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0);
      return;
    }
    if (this.multipleSelectionSupport && this.isSelectionRangeChangeEvent(e))
      return this.changeSelection(e);
    if (this.multipleSelectionSupport && this.isSelectionChangeEvent(e))
      return this.changeSelection(e);
    this.list.setFocus([t], e.browserEvent), this.list.setAnchor(t), dge(e.browserEvent) || this.list.setSelection([t], e.browserEvent), this._onPointer.fire(e);
  }
  onDoubleClick(e) {
    if (sh(e.browserEvent.target) || Jf(e.browserEvent.target) || this.multipleSelectionSupport && this.isSelectionChangeEvent(e))
      return;
    const t = this.list.getFocus();
    this.list.setSelection(t, e.browserEvent);
  }
  changeSelection(e) {
    const t = e.index;
    let i = this.list.getAnchor();
    if (this.isSelectionRangeChangeEvent(e)) {
      if (typeof i > "u") {
        const c = this.list.getFocus()[0];
        i = c ?? t, this.list.setAnchor(i);
      }
      const r = Math.min(i, t), o = Math.max(i, t), s = Ar(r, o + 1), a = this.list.getSelection(), l = mge(aO(a, [i]), i);
      if (l.length === 0)
        return;
      const u = aO(s, vge(a, l));
      this.list.setSelection(u, e.browserEvent), this.list.setFocus([t], e.browserEvent);
    } else if (this.isSelectionSingleChangeEvent(e)) {
      const r = this.list.getSelection(), o = r.filter((s) => s !== t);
      this.list.setFocus([t]), this.list.setAnchor(t), r.length === o.length ? this.list.setSelection([...o, t], e.browserEvent) : this.list.setSelection(o, e.browserEvent);
    }
  }
  dispose() {
    this.disposables.dispose();
  }
}
class S7 {
  constructor(e, t) {
    this.styleElement = e, this.selectorSuffix = t;
  }
  style(e) {
    const t = this.selectorSuffix && `.${this.selectorSuffix}`, i = [];
    e.listBackground && (e.listBackground.isOpaque() ? i.push(`.monaco-list${t} .monaco-list-rows { background: ${e.listBackground}; }`) : Ft || console.warn(`List with id '${this.selectorSuffix}' was styled with a non-opaque background color. This will break sub-pixel antialiasing.`)), e.listFocusBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.focused { background-color: ${e.listFocusBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.focused:hover { background-color: ${e.listFocusBackground}; }`)), e.listFocusForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), e.listActiveSelectionBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.selected { background-color: ${e.listActiveSelectionBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.selected:hover { background-color: ${e.listActiveSelectionBackground}; }`)), e.listActiveSelectionForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected { color: ${e.listActiveSelectionForeground}; }`), e.listFocusAndSelectionBackground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { background-color: ${e.listFocusAndSelectionBackground}; }
			`), e.listFocusAndSelectionForeground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { color: ${e.listFocusAndSelectionForeground}; }
			`), e.listInactiveFocusForeground && (i.push(`.monaco-list${t} .monaco-list-row.focused { color:  ${e.listInactiveFocusForeground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { color:  ${e.listInactiveFocusForeground}; }`)), e.listInactiveFocusBackground && (i.push(`.monaco-list${t} .monaco-list-row.focused { background-color:  ${e.listInactiveFocusBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { background-color:  ${e.listInactiveFocusBackground}; }`)), e.listInactiveSelectionBackground && (i.push(`.monaco-list${t} .monaco-list-row.selected { background-color:  ${e.listInactiveSelectionBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.selected:hover { background-color:  ${e.listInactiveSelectionBackground}; }`)), e.listInactiveSelectionForeground && i.push(`.monaco-list${t} .monaco-list-row.selected { color: ${e.listInactiveSelectionForeground}; }`), e.listHoverBackground && i.push(`.monaco-list${t}:not(.drop-target) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${e.listHoverBackground}; }`), e.listHoverForeground && i.push(`.monaco-list${t} .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${e.listHoverForeground}; }`), e.listSelectionOutline && i.push(`.monaco-list${t} .monaco-list-row.selected { outline: 1px dotted ${e.listSelectionOutline}; outline-offset: -1px; }`), e.listFocusOutline && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
			`), e.listInactiveFocusOutline && i.push(`.monaco-list${t} .monaco-list-row.focused { outline: 1px dotted ${e.listInactiveFocusOutline}; outline-offset: -1px; }`), e.listHoverOutline && i.push(`.monaco-list${t} .monaco-list-row:hover { outline: 1px dashed ${e.listHoverOutline}; outline-offset: -1px; }`), e.listDropBackground && i.push(`
				.monaco-list${t}.drop-target,
				.monaco-list${t} .monaco-list-rows.drop-target,
				.monaco-list${t} .monaco-list-row.drop-target { background-color: ${e.listDropBackground} !important; color: inherit !important; }
			`), e.listFilterWidgetBackground && i.push(`.monaco-list-type-filter { background-color: ${e.listFilterWidgetBackground} }`), e.listFilterWidgetOutline && i.push(`.monaco-list-type-filter { border: 1px solid ${e.listFilterWidgetOutline}; }`), e.listFilterWidgetNoMatchesOutline && i.push(`.monaco-list-type-filter.no-matches { border: 1px solid ${e.listFilterWidgetNoMatchesOutline}; }`), e.listMatchesShadow && i.push(`.monaco-list-type-filter { box-shadow: 1px 1px 1px ${e.listMatchesShadow}; }`), e.tableColumnsBorder && i.push(`
				.monaco-table:hover > .monaco-split-view2,
				.monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${e.tableColumnsBorder};
			}`), this.styleElement.textContent = i.join(`
`);
  }
}
const pge = {
  listFocusBackground: ee.fromHex("#7FB0D0"),
  listActiveSelectionBackground: ee.fromHex("#0E639C"),
  listActiveSelectionForeground: ee.fromHex("#FFFFFF"),
  listFocusAndSelectionBackground: ee.fromHex("#094771"),
  listFocusAndSelectionForeground: ee.fromHex("#FFFFFF"),
  listInactiveSelectionBackground: ee.fromHex("#3F3F46"),
  listHoverBackground: ee.fromHex("#2A2D2E"),
  listDropBackground: ee.fromHex("#383B3D"),
  treeIndentGuidesStroke: ee.fromHex("#a9a9a9"),
  tableColumnsBorder: ee.fromHex("#cccccc").transparent(0.2)
}, gge = {
  keyboardSupport: !0,
  mouseSupport: !0,
  multipleSelectionSupport: !0,
  dnd: {
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    }
  }
};
function mge(n, e) {
  const t = n.indexOf(e);
  if (t === -1)
    return [];
  const i = [];
  let r = t - 1;
  for (; r >= 0 && n[r] === e - (t - r); )
    i.push(n[r--]);
  for (i.reverse(), r = t; r < n.length && n[r] === e + (r - t); )
    i.push(n[r++]);
  return i;
}
function aO(n, e) {
  const t = [];
  let i = 0, r = 0;
  for (; i < n.length || r < e.length; )
    if (i >= n.length)
      t.push(e[r++]);
    else if (r >= e.length)
      t.push(n[i++]);
    else if (n[i] === e[r]) {
      t.push(n[i]), i++, r++;
      continue;
    } else
      n[i] < e[r] ? t.push(n[i++]) : t.push(e[r++]);
  return t;
}
function vge(n, e) {
  const t = [];
  let i = 0, r = 0;
  for (; i < n.length || r < e.length; )
    if (i >= n.length)
      t.push(e[r++]);
    else if (r >= e.length)
      t.push(n[i++]);
    else if (n[i] === e[r]) {
      i++, r++;
      continue;
    } else
      n[i] < e[r] ? t.push(n[i++]) : r++;
  return t;
}
const aW = (n, e) => n - e;
class _ge {
  constructor(e, t) {
    this._templateId = e, this.renderers = t;
  }
  get templateId() {
    return this._templateId;
  }
  renderTemplate(e) {
    return this.renderers.map((t) => t.renderTemplate(e));
  }
  renderElement(e, t, i, r) {
    let o = 0;
    for (const s of this.renderers)
      s.renderElement(e, t, i[o++], r);
  }
  disposeElement(e, t, i, r) {
    let o = 0;
    for (const s of this.renderers)
      s.disposeElement && s.disposeElement(e, t, i[o], r), o += 1;
  }
  disposeTemplate(e) {
    let t = 0;
    for (const i of this.renderers)
      i.disposeTemplate(e[t++]);
  }
}
class Cge {
  constructor(e) {
    this.accessibilityProvider = e, this.templateId = "a18n";
  }
  renderTemplate(e) {
    return e;
  }
  renderElement(e, t, i) {
    const r = this.accessibilityProvider.getAriaLabel(e);
    r ? i.setAttribute("aria-label", r) : i.removeAttribute("aria-label");
    const o = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(e);
    typeof o == "number" ? i.setAttribute("aria-level", `${o}`) : i.removeAttribute("aria-level");
  }
  disposeTemplate(e) {
  }
}
class yge {
  constructor(e, t) {
    this.list = e, this.dnd = t;
  }
  getDragElements(e) {
    const t = this.list.getSelectedElements();
    return t.indexOf(e) > -1 ? t : [e];
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e, t);
  }
  onDragStart(e, t) {
    this.dnd.onDragStart && this.dnd.onDragStart(e, t);
  }
  onDragOver(e, t, i, r) {
    return this.dnd.onDragOver(e, t, i, r);
  }
  onDragEnd(e) {
    this.dnd.onDragEnd && this.dnd.onDragEnd(e);
  }
  drop(e, t, i, r) {
    this.dnd.drop(e, t, i, r);
  }
}
class Jd {
  constructor(e, t, i, r, o = gge) {
    var s;
    this.user = e, this._options = o, this.focus = new oS("focused"), this.anchor = new oS("anchor"), this.eventBufferer = new oN(), this._ariaLabel = "", this.disposables = new ht(), this._onDidDispose = new j(), this.onDidDispose = this._onDidDispose.event;
    const a = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (s = this._options.accessibilityProvider) === null || s === void 0 ? void 0 : s.getWidgetRole() : "list";
    this.selection = new lge(a !== "listbox"), ch(o, pge, !1);
    const l = [this.focus.renderer, this.selection.renderer];
    this.accessibilityProvider = o.accessibilityProvider, this.accessibilityProvider && (l.push(new Cge(this.accessibilityProvider)), this.accessibilityProvider.onDidChangeActiveDescendant && this.accessibilityProvider.onDidChangeActiveDescendant(this.onDidChangeActiveDescendant, this, this.disposables)), r = r.map((c) => new _ge(c.templateId, [...l, c]));
    const u = Object.assign(Object.assign({}, o), { dnd: o.dnd && new yge(this, o.dnd) });
    if (this.view = new il(t, i, r, u), this.view.domNode.setAttribute("role", a), o.styleController)
      this.styleController = o.styleController(this.view.domId);
    else {
      const c = Os(this.view.domNode);
      this.styleController = new S7(c, this.view.domId);
    }
    if (this.spliceable = new sge([
      new qD(this.focus, this.view, o.identityProvider),
      new qD(this.selection, this.view, o.identityProvider),
      new qD(this.anchor, this.view, o.identityProvider),
      this.view
    ]), this.disposables.add(this.focus), this.disposables.add(this.selection), this.disposables.add(this.anchor), this.disposables.add(this.view), this.disposables.add(this._onDidDispose), this.onDidFocus = Ae.map(yt(this.view.domNode, "focus", !0), () => null), this.onDidBlur = Ae.map(yt(this.view.domNode, "blur", !0), () => null), this.disposables.add(new hge(this, this.view)), typeof o.keyboardSupport != "boolean" || o.keyboardSupport) {
      const c = new uge(this, this.view, o);
      this.disposables.add(c);
    }
    if (o.keyboardNavigationLabelProvider) {
      const c = o.keyboardNavigationDelegate || C7;
      this.typeLabelController = new cge(this, this.view, o.keyboardNavigationLabelProvider, c), this.disposables.add(this.typeLabelController);
    }
    this.mouseController = this.createMouseController(o), this.disposables.add(this.mouseController), this.onDidChangeFocus(this._onFocusChange, this, this.disposables), this.onDidChangeSelection(this._onSelectionChange, this, this.disposables), this.accessibilityProvider && (this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel()), o.multipleSelectionSupport && this.view.domNode.setAttribute("aria-multiselectable", "true");
  }
  get onDidChangeFocus() {
    return Ae.map(this.eventBufferer.wrapEvent(this.focus.onChange), (e) => this.toListEvent(e));
  }
  get onDidChangeSelection() {
    return Ae.map(this.eventBufferer.wrapEvent(this.selection.onChange), (e) => this.toListEvent(e));
  }
  get domId() {
    return this.view.domId;
  }
  get onMouseClick() {
    return this.view.onMouseClick;
  }
  get onMouseDblClick() {
    return this.view.onMouseDblClick;
  }
  get onMouseMiddleClick() {
    return this.view.onMouseMiddleClick;
  }
  get onPointer() {
    return this.mouseController.onPointer;
  }
  get onMouseDown() {
    return this.view.onMouseDown;
  }
  get onTouchStart() {
    return this.view.onTouchStart;
  }
  get onTap() {
    return this.view.onTap;
  }
  /**
   * Possible context menu trigger events:
   * - ContextMenu key
   * - Shift F10
   * - Ctrl Option Shift M (macOS with VoiceOver)
   * - Mouse right click
   */
  get onContextMenu() {
    let e = !1;
    const t = Ae.chain(yt(this.view.domNode, "keydown")).map((o) => new Ki(o)).filter((o) => e = o.keyCode === 58 || o.shiftKey && o.keyCode === 68).map(GR).filter(() => !1).event, i = Ae.chain(yt(this.view.domNode, "keyup")).forEach(() => e = !1).map((o) => new Ki(o)).filter((o) => o.keyCode === 58 || o.shiftKey && o.keyCode === 68).map(GR).map(({ browserEvent: o }) => {
      const s = this.getFocus(), a = s.length ? s[0] : void 0, l = typeof a < "u" ? this.view.element(a) : void 0, u = typeof a < "u" ? this.view.domElement(a) : this.view.domNode;
      return { index: a, element: l, anchor: u, browserEvent: o };
    }).event, r = Ae.chain(this.view.onContextMenu).filter((o) => !e).map(({ element: o, index: s, browserEvent: a }) => ({ element: o, index: s, anchor: { x: a.pageX + 1, y: a.pageY }, browserEvent: a })).event;
    return Ae.any(t, i, r);
  }
  get onKeyDown() {
    return yt(this.view.domNode, "keydown");
  }
  createMouseController(e) {
    return new b7(this);
  }
  updateOptions(e = {}) {
    this._options = Object.assign(Object.assign({}, this._options), e), this.typeLabelController && this.typeLabelController.updateOptions(this._options), this.view.updateOptions(e);
  }
  get options() {
    return this._options;
  }
  splice(e, t, i = []) {
    if (e < 0 || e > this.view.length)
      throw new kh(this.user, `Invalid start index: ${e}`);
    if (t < 0)
      throw new kh(this.user, `Invalid delete count: ${t}`);
    t === 0 && i.length === 0 || this.eventBufferer.bufferEvents(() => this.spliceable.splice(e, t, i));
  }
  rerender() {
    this.view.rerender();
  }
  element(e) {
    return this.view.element(e);
  }
  get length() {
    return this.view.length;
  }
  get contentHeight() {
    return this.view.contentHeight;
  }
  get scrollTop() {
    return this.view.getScrollTop();
  }
  set scrollTop(e) {
    this.view.setScrollTop(e);
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.view.domNode.setAttribute("aria-label", e);
  }
  domFocus() {
    this.view.domNode.focus({ preventScroll: !0 });
  }
  layout(e, t) {
    this.view.layout(e, t);
  }
  setSelection(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new kh(this.user, `Invalid index ${i}`);
    this.selection.set(e, t);
  }
  getSelection() {
    return this.selection.get();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.view.element(e));
  }
  setAnchor(e) {
    if (typeof e > "u") {
      this.anchor.set([]);
      return;
    }
    if (e < 0 || e >= this.length)
      throw new kh(this.user, `Invalid index ${e}`);
    this.anchor.set([e]);
  }
  getAnchor() {
    return yT(this.anchor.get(), void 0);
  }
  setFocus(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new kh(this.user, `Invalid index ${i}`);
    this.focus.set(e, t);
  }
  focusNext(e = 1, t = !1, i, r) {
    if (this.length === 0)
      return;
    const o = this.focus.get(), s = this.findNextIndex(o.length > 0 ? o[0] + e : 0, t, r);
    s > -1 && this.setFocus([s], i);
  }
  focusPrevious(e = 1, t = !1, i, r) {
    if (this.length === 0)
      return;
    const o = this.focus.get(), s = this.findPreviousIndex(o.length > 0 ? o[0] - e : 0, t, r);
    s > -1 && this.setFocus([s], i);
  }
  focusNextPage(e, t) {
    return sW(this, void 0, void 0, function* () {
      let i = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
      i = i === 0 ? 0 : i - 1;
      const r = this.view.element(i), o = this.getFocusedElements()[0];
      if (o !== r) {
        const s = this.findPreviousIndex(i, !1, t);
        s > -1 && o !== this.view.element(s) ? this.setFocus([s], e) : this.setFocus([i], e);
      } else {
        const s = this.view.getScrollTop();
        this.view.setScrollTop(s + this.view.renderHeight - this.view.elementHeight(i)), this.view.getScrollTop() !== s && (this.setFocus([]), yield Vv(0), yield this.focusNextPage(e, t));
      }
    });
  }
  focusPreviousPage(e, t) {
    return sW(this, void 0, void 0, function* () {
      let i;
      const r = this.view.getScrollTop();
      r === 0 ? i = this.view.indexAt(r) : i = this.view.indexAfter(r - 1);
      const o = this.view.element(i), s = this.getFocusedElements()[0];
      if (s !== o) {
        const a = this.findNextIndex(i, !1, t);
        a > -1 && s !== this.view.element(a) ? this.setFocus([a], e) : this.setFocus([i], e);
      } else {
        const a = r;
        this.view.setScrollTop(r - this.view.renderHeight), this.view.getScrollTop() !== a && (this.setFocus([]), yield Vv(0), yield this.focusPreviousPage(e, t));
      }
    });
  }
  focusLast(e, t) {
    if (this.length === 0)
      return;
    const i = this.findPreviousIndex(this.length - 1, !1, t);
    i > -1 && this.setFocus([i], e);
  }
  focusFirst(e, t) {
    this.focusNth(0, e, t);
  }
  focusNth(e, t, i) {
    if (this.length === 0)
      return;
    const r = this.findNextIndex(e, !1, i);
    r > -1 && this.setFocus([r], t);
  }
  findNextIndex(e, t = !1, i) {
    for (let r = 0; r < this.length; r++) {
      if (e >= this.length && !t)
        return -1;
      if (e = e % this.length, !i || i(this.element(e)))
        return e;
      e++;
    }
    return -1;
  }
  findPreviousIndex(e, t = !1, i) {
    for (let r = 0; r < this.length; r++) {
      if (e < 0 && !t)
        return -1;
      if (e = (this.length + e % this.length) % this.length, !i || i(this.element(e)))
        return e;
      e--;
    }
    return -1;
  }
  getFocus() {
    return this.focus.get();
  }
  getFocusedElements() {
    return this.getFocus().map((e) => this.view.element(e));
  }
  reveal(e, t) {
    if (e < 0 || e >= this.length)
      throw new kh(this.user, `Invalid index ${e}`);
    const i = this.view.getScrollTop(), r = this.view.elementTop(e), o = this.view.elementHeight(e);
    if (V_(t)) {
      const s = o - this.view.renderHeight;
      this.view.setScrollTop(s * Pa(t, 0, 1) + r);
    } else {
      const s = r + o, a = i + this.view.renderHeight;
      r < i && s >= a || (r < i || s >= a && o >= this.view.renderHeight ? this.view.setScrollTop(r) : s >= a && this.view.setScrollTop(s - this.view.renderHeight));
    }
  }
  /**
   * Returns the relative position of an element rendered in the list.
   * Returns `null` if the element isn't *entirely* in the visible viewport.
   */
  getRelativeTop(e) {
    if (e < 0 || e >= this.length)
      throw new kh(this.user, `Invalid index ${e}`);
    const t = this.view.getScrollTop(), i = this.view.elementTop(e), r = this.view.elementHeight(e);
    if (i < t || i + r > t + this.view.renderHeight)
      return null;
    const o = r - this.view.renderHeight;
    return Math.abs((t - i) / o);
  }
  getHTMLElement() {
    return this.view.domNode;
  }
  style(e) {
    this.styleController.style(e);
  }
  toListEvent({ indexes: e, browserEvent: t }) {
    return { indexes: e, elements: e.map((i) => this.view.element(i)), browserEvent: t };
  }
  _onFocusChange() {
    const e = this.focus.get();
    this.view.domNode.classList.toggle("element-focused", e.length > 0), this.onDidChangeActiveDescendant();
  }
  onDidChangeActiveDescendant() {
    var e;
    const t = this.focus.get();
    if (t.length > 0) {
      let i;
      !((e = this.accessibilityProvider) === null || e === void 0) && e.getActiveDescendantId && (i = this.accessibilityProvider.getActiveDescendantId(this.view.element(t[0]))), this.view.domNode.setAttribute("aria-activedescendant", i || this.view.getElementDomId(t[0]));
    } else
      this.view.domNode.removeAttribute("aria-activedescendant");
  }
  _onSelectionChange() {
    const e = this.selection.get();
    this.view.domNode.classList.toggle("selection-none", e.length === 0), this.view.domNode.classList.toggle("selection-single", e.length === 1), this.view.domNode.classList.toggle("selection-multiple", e.length > 1);
  }
  dispose() {
    this._onDidDispose.fire(), this.disposables.dispose(), this._onDidDispose.dispose();
  }
}
P0([
  Wn
], Jd.prototype, "onDidChangeFocus", null);
P0([
  Wn
], Jd.prototype, "onDidChangeSelection", null);
P0([
  Wn
], Jd.prototype, "onContextMenu", null);
class wge {
  constructor(e, t) {
    this.renderer = e, this.modelProvider = t;
  }
  get templateId() {
    return this.renderer.templateId;
  }
  renderTemplate(e) {
    return { data: this.renderer.renderTemplate(e), disposable: ge.None };
  }
  renderElement(e, t, i, r) {
    if (i.disposable && i.disposable.dispose(), !i.data)
      return;
    const o = this.modelProvider();
    if (o.isResolved(e))
      return this.renderer.renderElement(o.get(e), e, i.data, r);
    const s = new uh(), a = o.resolve(e, s.token);
    i.disposable = { dispose: () => s.cancel() }, this.renderer.renderPlaceholder(e, i.data), a.then((l) => this.renderer.renderElement(l, e, i.data, r));
  }
  disposeTemplate(e) {
    e.disposable && (e.disposable.dispose(), e.disposable = void 0), e.data && (this.renderer.disposeTemplate(e.data), e.data = void 0);
  }
}
class bge {
  constructor(e, t) {
    this.modelProvider = e, this.accessibilityProvider = t;
  }
  getWidgetAriaLabel() {
    return this.accessibilityProvider.getWidgetAriaLabel();
  }
  getAriaLabel(e) {
    const t = this.modelProvider();
    return t.isResolved(e) ? this.accessibilityProvider.getAriaLabel(t.get(e)) : null;
  }
}
function Sge(n, e) {
  return Object.assign(Object.assign({}, e), { accessibilityProvider: e.accessibilityProvider && new bge(n, e.accessibilityProvider) });
}
class Ege {
  constructor(e, t, i, r, o = {}) {
    const s = () => this.model, a = r.map((l) => new wge(l, s));
    this.list = new Jd(e, t, i, a, Sge(s, o));
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  getHTMLElement() {
    return this.list.getHTMLElement();
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  get onMouseDblClick() {
    return Ae.map(this.list.onMouseDblClick, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onPointer() {
    return Ae.map(this.list.onPointer, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onDidChangeSelection() {
    return Ae.map(this.list.onDidChangeSelection, ({ elements: e, indexes: t, browserEvent: i }) => ({ elements: e.map((r) => this._model.get(r)), indexes: t, browserEvent: i }));
  }
  get model() {
    return this._model;
  }
  set model(e) {
    this._model = e, this.list.splice(0, this.list.length, Ar(e.length));
  }
  getFocus() {
    return this.list.getFocus();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.model.get(e));
  }
  style(e) {
    this.list.style(e);
  }
  dispose() {
    this.list.dispose();
  }
}
const ewe = new it("isWindows", Eo, w("isWindows", "Whether the operating system is Windows")), Lge = "inputFocus";
var Sv;
(function(n) {
  n[n.Unknown = 0] = "Unknown", n[n.Twistie = 1] = "Twistie", n[n.Element = 2] = "Element";
})(Sv || (Sv = {}));
class ms extends Error {
  constructor(e, t) {
    super(`TreeError [${e}] ${t}`);
  }
}
class RI {
  constructor(e) {
    this.fn = e, this._map = /* @__PURE__ */ new WeakMap();
  }
  map(e) {
    let t = this._map.get(e);
    return t || (t = this.fn(e), this._map.set(e, t)), t;
  }
}
function TI(n) {
  return typeof n == "object" && "visibility" in n && "data" in n;
}
function u_(n) {
  switch (n) {
    case !0:
      return 1;
    case !1:
      return 0;
    default:
      return n;
  }
}
function YD(n) {
  return typeof n.collapsible == "boolean";
}
class Dge {
  constructor(e, t, i, r = {}) {
    this.user = e, this.list = t, this.rootRef = [], this.eventBufferer = new oN(), this._onDidChangeCollapseState = new j(), this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event), this._onDidChangeRenderNodeCount = new j(), this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event), this._onDidSplice = new j(), this.onDidSplice = this._onDidSplice.event, this.collapseByDefault = typeof r.collapseByDefault > "u" ? !1 : r.collapseByDefault, this.filter = r.filter, this.autoExpandSingleChildren = typeof r.autoExpandSingleChildren > "u" ? !1 : r.autoExpandSingleChildren, this.root = {
      parent: void 0,
      element: i,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: !1,
      collapsed: !1,
      renderNodeCount: 0,
      visibility: 1,
      visible: !0,
      filterData: void 0
    };
  }
  splice(e, t, i = _t.empty(), r = {}) {
    if (e.length === 0)
      throw new ms(this.user, "Invalid tree location");
    r.diffIdentityProvider ? this.spliceSmart(r.diffIdentityProvider, e, t, i, r) : this.spliceSimple(e, t, i, r);
  }
  spliceSmart(e, t, i, r, o, s) {
    var a;
    r === void 0 && (r = _t.empty()), s === void 0 && (s = (a = o.diffDepth) !== null && a !== void 0 ? a : 0);
    const { parentNode: l } = this.getParentNodeWithListIndex(t), u = [...r], c = t[t.length - 1], h = new dd({ getElements: () => l.children.map((_) => e.getId(_.element).toString()) }, {
      getElements: () => [
        ...l.children.slice(0, c),
        ...u,
        ...l.children.slice(c + i)
      ].map((_) => e.getId(_.element).toString())
    }).ComputeDiff(!1);
    if (h.quitEarly)
      return this.spliceSimple(t, i, u, o);
    const d = t.slice(0, -1), f = (_, m, v) => {
      if (s > 0)
        for (let C = 0; C < v; C++)
          _--, m--, this.spliceSmart(e, [...d, _, 0], Number.MAX_SAFE_INTEGER, u[m].children, o, s - 1);
    };
    let p = Math.min(l.children.length, c + i), g = u.length;
    for (const _ of h.changes.sort((m, v) => v.originalStart - m.originalStart))
      f(p, g, p - (_.originalStart + _.originalLength)), p = _.originalStart, g = _.modifiedStart - c, this.spliceSimple([...d, p], _.originalLength, _t.slice(u, g, g + _.modifiedLength), o);
    f(p, g, p);
  }
  spliceSimple(e, t, i = _t.empty(), { onDidCreateNode: r, onDidDeleteNode: o }) {
    const { parentNode: s, listIndex: a, revealed: l, visible: u } = this.getParentNodeWithListIndex(e), c = [], h = _t.map(i, (L) => this.createTreeNode(L, s, s.visible ? 1 : 0, l, c, r)), d = e[e.length - 1], f = s.children.length > 0;
    let p = 0;
    for (let L = d; L >= 0 && L < s.children.length; L--) {
      const S = s.children[L];
      if (S.visible) {
        p = S.visibleChildIndex;
        break;
      }
    }
    const g = [];
    let _ = 0, m = 0;
    for (const L of h)
      g.push(L), m += L.renderNodeCount, L.visible && (L.visibleChildIndex = p + _++);
    const v = s.children.splice(d, t, ...g);
    let C = 0;
    for (const L of v)
      L.visible && C++;
    if (C !== 0)
      for (let L = d + g.length; L < s.children.length; L++) {
        const S = s.children[L];
        S.visible && (S.visibleChildIndex -= C);
      }
    if (s.visibleChildrenCount += _ - C, l && u) {
      const L = v.reduce((S, E) => S + (E.visible ? E.renderNodeCount : 0), 0);
      this._updateAncestorsRenderNodeCount(s, m - L), this.list.splice(a, L, c);
    }
    if (v.length > 0 && o) {
      const L = (S) => {
        o(S), S.children.forEach(L);
      };
      v.forEach(L);
    }
    const y = s.children.length > 0;
    f !== y && this.setCollapsible(e.slice(0, -1), y), this._onDidSplice.fire({ insertedNodes: g, deletedNodes: v });
    let b = s;
    for (; b; ) {
      if (b.visibility === 2) {
        this.refilter();
        break;
      }
      b = b.parent;
    }
  }
  rerender(e) {
    if (e.length === 0)
      throw new ms(this.user, "Invalid tree location");
    const { node: t, listIndex: i, revealed: r } = this.getTreeNodeWithListIndex(e);
    t.visible && r && this.list.splice(i, 1, [t]);
  }
  has(e) {
    return this.hasTreeNode(e);
  }
  getListIndex(e) {
    const { listIndex: t, visible: i, revealed: r } = this.getTreeNodeWithListIndex(e);
    return i && r ? t : -1;
  }
  getListRenderCount(e) {
    return this.getTreeNode(e).renderNodeCount;
  }
  isCollapsible(e) {
    return this.getTreeNode(e).collapsible;
  }
  setCollapsible(e, t) {
    const i = this.getTreeNode(e);
    typeof t > "u" && (t = !i.collapsible);
    const r = { collapsible: t };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, r));
  }
  isCollapsed(e) {
    return this.getTreeNode(e).collapsed;
  }
  setCollapsed(e, t, i) {
    const r = this.getTreeNode(e);
    typeof t > "u" && (t = !r.collapsed);
    const o = { collapsed: t, recursive: i || !1 };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, o));
  }
  _setCollapseState(e, t) {
    const { node: i, listIndex: r, revealed: o } = this.getTreeNodeWithListIndex(e), s = this._setListNodeCollapseState(i, r, o, t);
    if (i !== this.root && this.autoExpandSingleChildren && s && !YD(t) && i.collapsible && !i.collapsed && !t.recursive) {
      let a = -1;
      for (let l = 0; l < i.children.length; l++)
        if (i.children[l].visible)
          if (a > -1) {
            a = -1;
            break;
          } else
            a = l;
      a > -1 && this._setCollapseState([...e, a], t);
    }
    return s;
  }
  _setListNodeCollapseState(e, t, i, r) {
    const o = this._setNodeCollapseState(e, r, !1);
    if (!i || !e.visible || !o)
      return o;
    const s = e.renderNodeCount, a = this.updateNodeAfterCollapseChange(e), l = s - (t === -1 ? 0 : 1);
    return this.list.splice(t + 1, l, a.slice(1)), o;
  }
  _setNodeCollapseState(e, t, i) {
    let r;
    if (e === this.root ? r = !1 : (YD(t) ? (r = e.collapsible !== t.collapsible, e.collapsible = t.collapsible) : e.collapsible ? (r = e.collapsed !== t.collapsed, e.collapsed = t.collapsed) : r = !1, r && this._onDidChangeCollapseState.fire({ node: e, deep: i })), !YD(t) && t.recursive)
      for (const o of e.children)
        r = this._setNodeCollapseState(o, t, !0) || r;
    return r;
  }
  expandTo(e) {
    this.eventBufferer.bufferEvents(() => {
      let t = this.getTreeNode(e);
      for (; t.parent; )
        t = t.parent, e = e.slice(0, e.length - 1), t.collapsed && this._setCollapseState(e, { collapsed: !1, recursive: !1 });
    });
  }
  refilter() {
    const e = this.root.renderNodeCount, t = this.updateNodeAfterFilterChange(this.root);
    this.list.splice(0, e, t);
  }
  createTreeNode(e, t, i, r, o, s) {
    const a = {
      parent: t,
      element: e.element,
      children: [],
      depth: t.depth + 1,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: typeof e.collapsible == "boolean" ? e.collapsible : typeof e.collapsed < "u",
      collapsed: typeof e.collapsed > "u" ? this.collapseByDefault : e.collapsed,
      renderNodeCount: 1,
      visibility: 1,
      visible: !0,
      filterData: void 0
    }, l = this._filterNode(a, i);
    a.visibility = l, r && o.push(a);
    const u = e.children || _t.empty(), c = r && l !== 0 && !a.collapsed, h = _t.map(u, (p) => this.createTreeNode(p, a, l, c, o, s));
    let d = 0, f = 1;
    for (const p of h)
      a.children.push(p), f += p.renderNodeCount, p.visible && (p.visibleChildIndex = d++);
    return a.collapsible = a.collapsible || a.children.length > 0, a.visibleChildrenCount = d, a.visible = l === 2 ? d > 0 : l === 1, a.visible ? a.collapsed || (a.renderNodeCount = f) : (a.renderNodeCount = 0, r && o.pop()), s && s(a), a;
  }
  updateNodeAfterCollapseChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterCollapseChange(e, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterCollapseChange(e, t) {
    if (e.visible === !1)
      return 0;
    if (t.push(e), e.renderNodeCount = 1, !e.collapsed)
      for (const i of e.children)
        e.renderNodeCount += this._updateNodeAfterCollapseChange(i, t);
    return this._onDidChangeRenderNodeCount.fire(e), e.renderNodeCount;
  }
  updateNodeAfterFilterChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterFilterChange(e, e.visible ? 1 : 0, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterFilterChange(e, t, i, r = !0) {
    let o;
    if (e !== this.root) {
      if (o = this._filterNode(e, t), o === 0)
        return e.visible = !1, e.renderNodeCount = 0, !1;
      r && i.push(e);
    }
    const s = i.length;
    e.renderNodeCount = e === this.root ? 0 : 1;
    let a = !1;
    if (!e.collapsed || o !== 0) {
      let l = 0;
      for (const u of e.children)
        a = this._updateNodeAfterFilterChange(u, o, i, r && !e.collapsed) || a, u.visible && (u.visibleChildIndex = l++);
      e.visibleChildrenCount = l;
    } else
      e.visibleChildrenCount = 0;
    return e !== this.root && (e.visible = o === 2 ? a : o === 1), e.visible ? e.collapsed || (e.renderNodeCount += i.length - s) : (e.renderNodeCount = 0, r && i.pop()), this._onDidChangeRenderNodeCount.fire(e), e.visible;
  }
  _updateAncestorsRenderNodeCount(e, t) {
    if (t !== 0)
      for (; e; )
        e.renderNodeCount += t, this._onDidChangeRenderNodeCount.fire(e), e = e.parent;
  }
  _filterNode(e, t) {
    const i = this.filter ? this.filter.filter(e.element, t) : 1;
    return typeof i == "boolean" ? (e.filterData = void 0, i ? 1 : 0) : TI(i) ? (e.filterData = i.data, u_(i.visibility)) : (e.filterData = void 0, u_(i));
  }
  // cheap
  hasTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return !0;
    const [i, ...r] = e;
    return i < 0 || i > t.children.length ? !1 : this.hasTreeNode(r, t.children[i]);
  }
  // cheap
  getTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return t;
    const [i, ...r] = e;
    if (i < 0 || i > t.children.length)
      throw new ms(this.user, "Invalid tree location");
    return this.getTreeNode(r, t.children[i]);
  }
  // expensive
  getTreeNodeWithListIndex(e) {
    if (e.length === 0)
      return { node: this.root, listIndex: -1, revealed: !0, visible: !1 };
    const { parentNode: t, listIndex: i, revealed: r, visible: o } = this.getParentNodeWithListIndex(e), s = e[e.length - 1];
    if (s < 0 || s > t.children.length)
      throw new ms(this.user, "Invalid tree location");
    const a = t.children[s];
    return { node: a, listIndex: i, revealed: r, visible: o && a.visible };
  }
  getParentNodeWithListIndex(e, t = this.root, i = 0, r = !0, o = !0) {
    const [s, ...a] = e;
    if (s < 0 || s > t.children.length)
      throw new ms(this.user, "Invalid tree location");
    for (let l = 0; l < s; l++)
      i += t.children[l].renderNodeCount;
    return r = r && !t.collapsed, o = o && t.visible, a.length === 0 ? { parentNode: t, listIndex: i, revealed: r, visible: o } : this.getParentNodeWithListIndex(a, t.children[s], i + 1, r, o);
  }
  getNode(e = []) {
    return this.getTreeNode(e);
  }
  // TODO@joao perf!
  getNodeLocation(e) {
    const t = [];
    let i = e;
    for (; i.parent; )
      t.push(i.parent.children.indexOf(i)), i = i.parent;
    return t.reverse();
  }
  getParentNodeLocation(e) {
    if (e.length !== 0)
      return e.length === 1 ? [] : ese(e)[0];
  }
}
const lW = va("tree-item-expanded", Vi.chevronDown), uW = va("tree-filter-on-type-on", Vi.listFilter), cW = va("tree-filter-on-type-off", Vi.listSelection), Rge = va("tree-filter-clear", Vi.close), sS = va("tree-item-loading", Vi.loading);
class Tge extends q_ {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function XD(n) {
  return n instanceof q_ ? new Tge(n) : n;
}
class Oge {
  constructor(e, t) {
    this.modelProvider = e, this.dnd = t, this.autoExpandDisposable = ge.None;
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    this.dnd.onDragStart && this.dnd.onDragStart(XD(e), t);
  }
  onDragOver(e, t, i, r, o = !0) {
    const s = this.dnd.onDragOver(XD(e), t && t.element, i, r), a = this.autoExpandNode !== t;
    if (a && (this.autoExpandDisposable.dispose(), this.autoExpandNode = t), typeof t > "u")
      return s;
    if (a && typeof s != "boolean" && s.autoExpand && (this.autoExpandDisposable = jR(() => {
      const d = this.modelProvider(), f = d.getNodeLocation(t);
      d.isCollapsed(f) && d.setCollapsed(f, !1), this.autoExpandNode = void 0;
    }, 500)), typeof s == "boolean" || !s.accept || typeof s.bubble > "u" || s.feedback) {
      if (!o) {
        const d = typeof s == "boolean" ? s : s.accept, f = typeof s == "boolean" ? void 0 : s.effect;
        return { accept: d, effect: f, feedback: [i] };
      }
      return s;
    }
    if (s.bubble === 1) {
      const d = this.modelProvider(), f = d.getNodeLocation(t), p = d.getParentNodeLocation(f), g = d.getNode(p), _ = p && d.getListIndex(p);
      return this.onDragOver(e, g, _, r, !1);
    }
    const l = this.modelProvider(), u = l.getNodeLocation(t), c = l.getListIndex(u), h = l.getListRenderCount(u);
    return Object.assign(Object.assign({}, s), { feedback: Ar(c, c + h) });
  }
  drop(e, t, i, r) {
    this.autoExpandDisposable.dispose(), this.autoExpandNode = void 0, this.dnd.drop(XD(e), t && t.element, i, r);
  }
  onDragEnd(e) {
    this.dnd.onDragEnd && this.dnd.onDragEnd(e);
  }
}
function xge(n, e) {
  return e && Object.assign(Object.assign({}, e), { identityProvider: e.identityProvider && {
    getId(t) {
      return e.identityProvider.getId(t.element);
    }
  }, dnd: e.dnd && new Oge(n, e.dnd), multipleSelectionController: e.multipleSelectionController && {
    isSelectionSingleChangeEvent(t) {
      return e.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, t), { element: t.element }));
    },
    isSelectionRangeChangeEvent(t) {
      return e.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, t), { element: t.element }));
    }
  }, accessibilityProvider: e.accessibilityProvider && Object.assign(Object.assign({}, e.accessibilityProvider), {
    getSetSize(t) {
      const i = n(), r = i.getNodeLocation(t), o = i.getParentNodeLocation(r);
      return i.getNode(o).visibleChildrenCount;
    },
    getPosInSet(t) {
      return t.visibleChildIndex + 1;
    },
    isChecked: e.accessibilityProvider && e.accessibilityProvider.isChecked ? (t) => e.accessibilityProvider.isChecked(t.element) : void 0,
    getRole: e.accessibilityProvider && e.accessibilityProvider.getRole ? (t) => e.accessibilityProvider.getRole(t.element) : () => "treeitem",
    getAriaLabel(t) {
      return e.accessibilityProvider.getAriaLabel(t.element);
    },
    getWidgetAriaLabel() {
      return e.accessibilityProvider.getWidgetAriaLabel();
    },
    getWidgetRole: e.accessibilityProvider && e.accessibilityProvider.getWidgetRole ? () => e.accessibilityProvider.getWidgetRole() : () => "tree",
    getAriaLevel: e.accessibilityProvider && e.accessibilityProvider.getAriaLevel ? (t) => e.accessibilityProvider.getAriaLevel(t.element) : (t) => t.depth,
    getActiveDescendantId: e.accessibilityProvider.getActiveDescendantId && ((t) => e.accessibilityProvider.getActiveDescendantId(t.element))
  }), keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, e.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(t) {
    return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t.element);
  } }), enableKeyboardNavigation: e.simpleKeyboardNavigation });
}
class OI {
  constructor(e) {
    this.delegate = e;
  }
  getHeight(e) {
    return this.delegate.getHeight(e.element);
  }
  getTemplateId(e) {
    return this.delegate.getTemplateId(e.element);
  }
  hasDynamicHeight(e) {
    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(e.element);
  }
  setDynamicHeight(e, t) {
    this.delegate.setDynamicHeight && this.delegate.setDynamicHeight(e.element, t);
  }
}
var c_;
(function(n) {
  n.None = "none", n.OnHover = "onHover", n.Always = "always";
})(c_ || (c_ = {}));
class Nge {
  constructor(e, t = []) {
    this._elements = t, this.onDidChange = Ae.forEach(e, (i) => this._elements = i);
  }
  get elements() {
    return this._elements;
  }
}
class h_ {
  constructor(e, t, i, r, o = {}) {
    this.renderer = e, this.modelProvider = t, this.activeNodes = r, this.renderedElements = /* @__PURE__ */ new Map(), this.renderedNodes = /* @__PURE__ */ new Map(), this.indent = h_.DefaultIndent, this.hideTwistiesOfChildlessElements = !1, this.shouldRenderIndentGuides = !1, this.renderedIndentGuides = new Xse(), this.activeIndentNodes = /* @__PURE__ */ new Set(), this.indentGuidesDisposable = ge.None, this.disposables = new ht(), this.templateId = e.templateId, this.updateOptions(o), Ae.map(i, (s) => s.node)(this.onDidChangeNodeTwistieState, this, this.disposables), e.onDidChangeTwistieState && e.onDidChangeTwistieState(this.onDidChangeTwistieState, this, this.disposables);
  }
  updateOptions(e = {}) {
    if (typeof e.indent < "u" && (this.indent = Pa(e.indent, 0, 40)), typeof e.renderIndentGuides < "u") {
      const t = e.renderIndentGuides !== c_.None;
      if (t !== this.shouldRenderIndentGuides && (this.shouldRenderIndentGuides = t, this.indentGuidesDisposable.dispose(), t)) {
        const i = new ht();
        this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, i), this.indentGuidesDisposable = i, this._onDidChangeActiveNodes(this.activeNodes.elements);
      }
    }
    typeof e.hideTwistiesOfChildlessElements < "u" && (this.hideTwistiesOfChildlessElements = e.hideTwistiesOfChildlessElements);
  }
  renderTemplate(e) {
    const t = Ie(e, Xe(".monaco-tl-row")), i = Ie(t, Xe(".monaco-tl-indent")), r = Ie(t, Xe(".monaco-tl-twistie")), o = Ie(t, Xe(".monaco-tl-contents")), s = this.renderer.renderTemplate(o);
    return { container: e, indent: i, twistie: r, indentGuidesDisposable: ge.None, templateData: s };
  }
  renderElement(e, t, i, r) {
    typeof r == "number" && (this.renderedNodes.set(e, { templateData: i, height: r }), this.renderedElements.set(e.element, e));
    const o = h_.DefaultIndent + (e.depth - 1) * this.indent;
    i.twistie.style.paddingLeft = `${o}px`, i.indent.style.width = `${o + this.indent - 16}px`, this.renderTwistie(e, i), typeof r == "number" && this.renderIndentGuides(e, i), this.renderer.renderElement(e, t, i.templateData, r);
  }
  disposeElement(e, t, i, r) {
    i.indentGuidesDisposable.dispose(), this.renderer.disposeElement && this.renderer.disposeElement(e, t, i.templateData, r), typeof r == "number" && (this.renderedNodes.delete(e), this.renderedElements.delete(e.element));
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  onDidChangeTwistieState(e) {
    const t = this.renderedElements.get(e);
    t && this.onDidChangeNodeTwistieState(t);
  }
  onDidChangeNodeTwistieState(e) {
    const t = this.renderedNodes.get(e);
    t && (this.renderTwistie(e, t.templateData), this._onDidChangeActiveNodes(this.activeNodes.elements), this.renderIndentGuides(e, t.templateData));
  }
  renderTwistie(e, t) {
    t.twistie.classList.remove(...lW.classNamesArray);
    let i = !1;
    this.renderer.renderTwistie && (i = this.renderer.renderTwistie(e.element, t.twistie)), e.collapsible && (!this.hideTwistiesOfChildlessElements || e.visibleChildrenCount > 0) ? (i || t.twistie.classList.add(...lW.classNamesArray), t.twistie.classList.add("collapsible"), t.twistie.classList.toggle("collapsed", e.collapsed)) : t.twistie.classList.remove("collapsible", "collapsed"), e.collapsible ? t.container.setAttribute("aria-expanded", String(!e.collapsed)) : t.container.removeAttribute("aria-expanded");
  }
  renderIndentGuides(e, t) {
    if (Ts(t.indent), t.indentGuidesDisposable.dispose(), !this.shouldRenderIndentGuides)
      return;
    const i = new ht(), r = this.modelProvider();
    let o = e;
    for (; ; ) {
      const s = r.getNodeLocation(o), a = r.getParentNodeLocation(s);
      if (!a)
        break;
      const l = r.getNode(a), u = Xe(".indent-guide", { style: `width: ${this.indent}px` });
      this.activeIndentNodes.has(l) && u.classList.add("active"), t.indent.childElementCount === 0 ? t.indent.appendChild(u) : t.indent.insertBefore(u, t.indent.firstElementChild), this.renderedIndentGuides.add(l, u), i.add(Ri(() => this.renderedIndentGuides.delete(l, u))), o = l;
    }
    t.indentGuidesDisposable = i;
  }
  _onDidChangeActiveNodes(e) {
    if (!this.shouldRenderIndentGuides)
      return;
    const t = /* @__PURE__ */ new Set(), i = this.modelProvider();
    e.forEach((r) => {
      const o = i.getNodeLocation(r);
      try {
        const s = i.getParentNodeLocation(o);
        r.collapsible && r.children.length > 0 && !r.collapsed ? t.add(r) : s && t.add(i.getNode(s));
      } catch {
      }
    }), this.activeIndentNodes.forEach((r) => {
      t.has(r) || this.renderedIndentGuides.forEach(r, (o) => o.classList.remove("active"));
    }), t.forEach((r) => {
      this.activeIndentNodes.has(r) || this.renderedIndentGuides.forEach(r, (o) => o.classList.add("active"));
    }), this.activeIndentNodes = t;
  }
  dispose() {
    this.renderedNodes.clear(), this.renderedElements.clear(), this.indentGuidesDisposable.dispose(), yi(this.disposables);
  }
}
h_.DefaultIndent = 8;
class Ige {
  constructor(e, t, i) {
    this.tree = e, this.keyboardNavigationLabelProvider = t, this._filter = i, this._totalCount = 0, this._matchCount = 0, this._pattern = "", this._lowercasePattern = "", this.disposables = new ht(), e.onWillRefilter(this.reset, this, this.disposables);
  }
  get totalCount() {
    return this._totalCount;
  }
  get matchCount() {
    return this._matchCount;
  }
  set pattern(e) {
    this._pattern = e, this._lowercasePattern = e.toLowerCase();
  }
  filter(e, t) {
    if (this._filter) {
      const o = this._filter.filter(e, t);
      if (this.tree.options.simpleKeyboardNavigation)
        return o;
      let s;
      if (typeof o == "boolean" ? s = o ? 1 : 0 : TI(o) ? s = u_(o.visibility) : s = o, s === 0)
        return !1;
    }
    if (this._totalCount++, this.tree.options.simpleKeyboardNavigation || !this._pattern)
      return this._matchCount++, { data: _d.Default, visibility: !0 };
    const i = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e), r = Array.isArray(i) ? i : [i];
    for (const o of r) {
      const s = o && o.toString();
      if (typeof s > "u")
        return { data: _d.Default, visibility: !0 };
      const a = iS(this._pattern, this._lowercasePattern, 0, s, s.toLowerCase(), 0, !0);
      if (a)
        return this._matchCount++, r.length === 1 ? { data: a, visibility: !0 } : { data: { label: s, score: a }, visibility: !0 };
    }
    return this.tree.options.filterOnType ? 2 : { data: _d.Default, visibility: !0 };
  }
  reset() {
    this._totalCount = 0, this._matchCount = 0;
  }
  dispose() {
    yi(this.disposables);
  }
}
class Pge {
  constructor(e, t, i, r, o) {
    this.tree = e, this.view = i, this.filter = r, this.keyboardNavigationDelegate = o, this._enabled = !1, this._pattern = "", this._empty = !1, this._onDidChangeEmptyState = new j(), this.positionClassName = "ne", this.automaticKeyboardNavigation = !0, this.triggered = !1, this._onDidChangePattern = new j(), this.enabledDisposables = new ht(), this.disposables = new ht(), this.domNode = Xe(`.monaco-list-type-filter.${this.positionClassName}`), this.domNode.draggable = !0, yt(this.domNode, "dragstart")(this.onDragStart, this, this.disposables), this.messageDomNode = Ie(i.getHTMLElement(), Xe(".monaco-list-type-filter-message")), this.labelDomNode = Ie(this.domNode, Xe("span.label"));
    const s = Ie(this.domNode, Xe(".controls"));
    this._filterOnType = !!e.options.filterOnType, this.filterOnTypeDomNode = Ie(s, Xe("input.filter")), this.filterOnTypeDomNode.type = "checkbox", this.filterOnTypeDomNode.checked = this._filterOnType, this.filterOnTypeDomNode.tabIndex = -1, this.updateFilterOnTypeTitleAndIcon(), yt(this.filterOnTypeDomNode, "input")(this.onDidChangeFilterOnType, this, this.disposables), this.clearDomNode = Ie(s, Xe("button.clear" + Rge.cssSelector)), this.clearDomNode.tabIndex = -1, this.clearDomNode.title = w("clear", "Clear"), this.keyboardNavigationEventFilter = e.options.keyboardNavigationEventFilter, t.onDidSplice(this.onDidSpliceModel, this, this.disposables), this.updateOptions(e.options);
  }
  get enabled() {
    return this._enabled;
  }
  get pattern() {
    return this._pattern;
  }
  get filterOnType() {
    return this._filterOnType;
  }
  updateOptions(e) {
    e.simpleKeyboardNavigation ? this.disable() : this.enable(), typeof e.filterOnType < "u" && (this._filterOnType = !!e.filterOnType, this.filterOnTypeDomNode.checked = this._filterOnType, this.updateFilterOnTypeTitleAndIcon()), typeof e.automaticKeyboardNavigation < "u" && (this.automaticKeyboardNavigation = e.automaticKeyboardNavigation), this.tree.refilter(), this.render(), this.automaticKeyboardNavigation || this.onEventOrInput("");
  }
  enable() {
    if (this._enabled)
      return;
    const e = Ae.chain(yt(this.view.getHTMLElement(), "keydown")).filter((i) => !sh(i.target) || i.target === this.filterOnTypeDomNode).filter((i) => i.key !== "Dead" && !/^Media/.test(i.key)).map((i) => new Ki(i)).filter(this.keyboardNavigationEventFilter || (() => !0)).filter(() => this.automaticKeyboardNavigation || this.triggered).filter((i) => this.keyboardNavigationDelegate.mightProducePrintableCharacter(i) && !(i.keyCode === 18 || i.keyCode === 16 || i.keyCode === 15 || i.keyCode === 17) || (this.pattern.length > 0 || this.triggered) && (i.keyCode === 9 || i.keyCode === 1) && !i.altKey && !i.ctrlKey && !i.metaKey || i.keyCode === 1 && (Ft ? i.altKey && !i.metaKey : i.ctrlKey) && !i.shiftKey).forEach((i) => {
      i.stopPropagation(), i.preventDefault();
    }).event, t = yt(this.clearDomNode, "click");
    Ae.chain(Ae.any(e, t)).event(this.onEventOrInput, this, this.enabledDisposables), this.filter.pattern = "", this.tree.refilter(), this.render(), this._enabled = !0, this.triggered = !1;
  }
  disable() {
    this._enabled && (this.domNode.remove(), this.enabledDisposables.clear(), this.tree.refilter(), this.render(), this._enabled = !1, this.triggered = !1);
  }
  onEventOrInput(e) {
    typeof e == "string" ? this.onInput(e) : e instanceof MouseEvent || e.keyCode === 9 || e.keyCode === 1 && (Ft ? e.altKey : e.ctrlKey) ? this.onInput("") : e.keyCode === 1 ? this.onInput(this.pattern.length === 0 ? "" : this.pattern.substr(0, this.pattern.length - 1)) : this.onInput(this.pattern + e.browserEvent.key);
  }
  onInput(e) {
    const t = this.view.getHTMLElement();
    e && !this.domNode.parentElement ? t.append(this.domNode) : !e && this.domNode.parentElement && (this.domNode.remove(), this.tree.domFocus()), this._pattern = e, this._onDidChangePattern.fire(e), this.filter.pattern = e, this.tree.refilter(), e && this.tree.focusNext(0, !0, void 0, (r) => !_d.isDefault(r.filterData));
    const i = this.tree.getFocus();
    if (i.length > 0) {
      const r = i[0];
      this.tree.getRelativeTop(r) === null && this.tree.reveal(r, 0.5);
    }
    this.render(), e || (this.triggered = !1);
  }
  onDragStart() {
    const e = this.view.getHTMLElement(), { left: t } = ja(e), i = e.clientWidth, r = i / 2, o = this.domNode.clientWidth, s = new ht();
    let a = this.positionClassName;
    const l = () => {
      switch (a) {
        case "nw":
          this.domNode.style.top = "4px", this.domNode.style.left = "4px";
          break;
        case "ne":
          this.domNode.style.top = "4px", this.domNode.style.left = `${i - o - 6}px`;
          break;
      }
    }, u = (h) => {
      h.preventDefault();
      const d = h.clientX - t;
      h.dataTransfer && (h.dataTransfer.dropEffect = "none"), d < r ? a = "nw" : a = "ne", l();
    }, c = () => {
      this.positionClassName = a, this.domNode.className = `monaco-list-type-filter ${this.positionClassName}`, this.domNode.style.top = "", this.domNode.style.left = "", yi(s);
    };
    l(), this.domNode.classList.remove(a), this.domNode.classList.add("dragging"), s.add(Ri(() => this.domNode.classList.remove("dragging"))), yt(document, "dragover")(u, null, s), yt(this.domNode, "dragend")(c, null, s), bu.CurrentDragAndDropData = new efe("vscode-ui"), s.add(Ri(() => bu.CurrentDragAndDropData = void 0));
  }
  onDidSpliceModel() {
    !this._enabled || this.pattern.length === 0 || (this.tree.refilter(), this.render());
  }
  onDidChangeFilterOnType() {
    this.tree.updateOptions({ filterOnType: this.filterOnTypeDomNode.checked }), this.tree.refilter(), this.tree.domFocus(), this.render(), this.updateFilterOnTypeTitleAndIcon();
  }
  updateFilterOnTypeTitleAndIcon() {
    this.filterOnType ? (this.filterOnTypeDomNode.classList.remove(...cW.classNamesArray), this.filterOnTypeDomNode.classList.add(...uW.classNamesArray), this.filterOnTypeDomNode.title = w("disable filter on type", "Disable Filter on Type")) : (this.filterOnTypeDomNode.classList.remove(...uW.classNamesArray), this.filterOnTypeDomNode.classList.add(...cW.classNamesArray), this.filterOnTypeDomNode.title = w("enable filter on type", "Enable Filter on Type"));
  }
  render() {
    const e = this.filter.totalCount > 0 && this.filter.matchCount === 0;
    this.pattern && this.tree.options.filterOnType && e ? (this.messageDomNode.textContent = w("empty", "No elements found"), this._empty = !0) : (this.messageDomNode.innerText = "", this._empty = !1), this.domNode.classList.toggle("no-matches", e), this.domNode.title = w("found", "Matched {0} out of {1} elements", this.filter.matchCount, this.filter.totalCount), this.labelDomNode.textContent = this.pattern.length > 16 ? "" + this.pattern.substr(this.pattern.length - 16) : this.pattern, this._onDidChangeEmptyState.fire(this._empty);
  }
  shouldAllowFocus(e) {
    return !this.enabled || !this.pattern || this.filterOnType || this.filter.totalCount > 0 && this.filter.matchCount <= 1 ? !0 : !_d.isDefault(e.filterData);
  }
  dispose() {
    this._enabled && (this.domNode.remove(), this.enabledDisposables.dispose(), this._enabled = !1, this.triggered = !1), this._onDidChangePattern.dispose(), yi(this.disposables);
  }
}
function hW(n) {
  let e = Sv.Unknown;
  return yF(n.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row") ? e = Sv.Twistie : yF(n.browserEvent.target, "monaco-tl-contents", "monaco-tl-row") && (e = Sv.Element), {
    browserEvent: n.browserEvent,
    element: n.element ? n.element.element : null,
    target: e
  };
}
function gw(n, e) {
  e(n), n.children.forEach((t) => gw(t, e));
}
class ZD {
  constructor(e) {
    this.identityProvider = e, this.nodes = [], this._onDidChange = new j(), this.onDidChange = this._onDidChange.event;
  }
  get nodeSet() {
    return this._nodeSet || (this._nodeSet = this.createNodeSet()), this._nodeSet;
  }
  set(e, t) {
    var i;
    !(!((i = t) === null || i === void 0) && i.__forceEvent) && Gu(this.nodes, e) || this._set(e, !1, t);
  }
  _set(e, t, i) {
    if (this.nodes = [...e], this.elements = void 0, this._nodeSet = void 0, !t) {
      const r = this;
      this._onDidChange.fire({ get elements() {
        return r.get();
      }, browserEvent: i });
    }
  }
  get() {
    return this.elements || (this.elements = this.nodes.map((e) => e.element)), [...this.elements];
  }
  getNodes() {
    return this.nodes;
  }
  has(e) {
    return this.nodeSet.has(e);
  }
  onDidModelSplice({ insertedNodes: e, deletedNodes: t }) {
    if (!this.identityProvider) {
      const l = this.createNodeSet(), u = (c) => l.delete(c);
      t.forEach((c) => gw(c, u)), this.set([...l.values()]);
      return;
    }
    const i = /* @__PURE__ */ new Set(), r = (l) => i.add(this.identityProvider.getId(l.element).toString());
    t.forEach((l) => gw(l, r));
    const o = /* @__PURE__ */ new Map(), s = (l) => o.set(this.identityProvider.getId(l.element).toString(), l);
    e.forEach((l) => gw(l, s));
    const a = [];
    for (const l of this.nodes) {
      const u = this.identityProvider.getId(l.element).toString();
      if (!i.has(u))
        a.push(l);
      else {
        const h = o.get(u);
        h && a.push(h);
      }
    }
    this._set(a, !0);
  }
  createNodeSet() {
    const e = /* @__PURE__ */ new Set();
    for (const t of this.nodes)
      e.add(t);
    return e;
  }
}
class Age extends b7 {
  constructor(e, t) {
    super(e), this.tree = t;
  }
  onViewPointer(e) {
    if (sh(e.browserEvent.target) || Jf(e.browserEvent.target))
      return;
    const t = e.element;
    if (!t)
      return super.onViewPointer(e);
    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e))
      return super.onViewPointer(e);
    const i = e.browserEvent.target, r = i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && e.browserEvent.offsetX < 16;
    let o = !1;
    if (typeof this.tree.expandOnlyOnTwistieClick == "function" ? o = this.tree.expandOnlyOnTwistieClick(t.element) : o = !!this.tree.expandOnlyOnTwistieClick, o && !r && e.browserEvent.detail !== 2)
      return super.onViewPointer(e);
    if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2)
      return super.onViewPointer(e);
    if (t.collapsible) {
      const s = this.tree.model, a = s.getNodeLocation(t), l = e.browserEvent.altKey;
      if (this.tree.setFocus([a]), s.setCollapsed(a, void 0, l), o && r)
        return;
    }
    super.onViewPointer(e);
  }
  onDoubleClick(e) {
    e.browserEvent.target.classList.contains("monaco-tl-twistie") || !this.tree.expandOnDoubleClick || super.onDoubleClick(e);
  }
}
class Mge extends Jd {
  constructor(e, t, i, r, o, s, a, l) {
    super(e, t, i, r, l), this.focusTrait = o, this.selectionTrait = s, this.anchorTrait = a;
  }
  createMouseController(e) {
    return new Age(this, e.tree);
  }
  splice(e, t, i = []) {
    if (super.splice(e, t, i), i.length === 0)
      return;
    const r = [], o = [];
    let s;
    i.forEach((a, l) => {
      this.focusTrait.has(a) && r.push(e + l), this.selectionTrait.has(a) && o.push(e + l), this.anchorTrait.has(a) && (s = e + l);
    }), r.length > 0 && super.setFocus(lk([...super.getFocus(), ...r])), o.length > 0 && super.setSelection(lk([...super.getSelection(), ...o])), typeof s == "number" && super.setAnchor(s);
  }
  setFocus(e, t, i = !1) {
    super.setFocus(e, t), i || this.focusTrait.set(e.map((r) => this.element(r)), t);
  }
  setSelection(e, t, i = !1) {
    super.setSelection(e, t), i || this.selectionTrait.set(e.map((r) => this.element(r)), t);
  }
  setAnchor(e, t = !1) {
    super.setAnchor(e), t || (typeof e > "u" ? this.anchorTrait.set([]) : this.anchorTrait.set([this.element(e)]));
  }
}
class E7 {
  constructor(e, t, i, r, o = {}) {
    this._options = o, this.eventBufferer = new oN(), this.disposables = new ht(), this._onWillRefilter = new j(), this.onWillRefilter = this._onWillRefilter.event, this._onDidUpdateOptions = new j();
    const s = new OI(i), a = new mF(), l = new mF(), u = new Nge(l.event);
    this.renderers = r.map((d) => new h_(d, () => this.model, a.event, u, o));
    for (let d of this.renderers)
      this.disposables.add(d);
    let c;
    o.keyboardNavigationLabelProvider && (c = new Ige(this, o.keyboardNavigationLabelProvider, o.filter), o = Object.assign(Object.assign({}, o), { filter: c }), this.disposables.add(c)), this.focus = new ZD(o.identityProvider), this.selection = new ZD(o.identityProvider), this.anchor = new ZD(o.identityProvider), this.view = new Mge(e, t, s, this.renderers, this.focus, this.selection, this.anchor, Object.assign(Object.assign({}, xge(() => this.model, o)), { tree: this })), this.model = this.createModel(e, this.view, o), a.input = this.model.onDidChangeCollapseState;
    const h = Ae.forEach(this.model.onDidSplice, (d) => {
      this.eventBufferer.bufferEvents(() => {
        this.focus.onDidModelSplice(d), this.selection.onDidModelSplice(d);
      });
    });
    if (h(() => null, null, this.disposables), l.input = Ae.chain(Ae.any(h, this.focus.onDidChange, this.selection.onDidChange)).debounce(() => null, 0).map(() => {
      const d = /* @__PURE__ */ new Set();
      for (const f of this.focus.getNodes())
        d.add(f);
      for (const f of this.selection.getNodes())
        d.add(f);
      return [...d.values()];
    }).event, o.keyboardSupport !== !1) {
      const d = Ae.chain(this.view.onKeyDown).filter((f) => !sh(f.target)).map((f) => new Ki(f));
      d.filter(
        (f) => f.keyCode === 15
        /* LeftArrow */
      ).on(this.onLeftArrow, this, this.disposables), d.filter(
        (f) => f.keyCode === 17
        /* RightArrow */
      ).on(this.onRightArrow, this, this.disposables), d.filter(
        (f) => f.keyCode === 10
        /* Space */
      ).on(this.onSpace, this, this.disposables);
    }
    if (o.keyboardNavigationLabelProvider) {
      const d = o.keyboardNavigationDelegate || C7;
      this.typeFilterController = new Pge(this, this.model, this.view, c, d), this.focusNavigationFilter = (f) => this.typeFilterController.shouldAllowFocus(f), this.disposables.add(this.typeFilterController);
    }
    this.styleElement = Os(this.view.getHTMLElement()), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === c_.Always);
  }
  get onDidChangeFocus() {
    return this.eventBufferer.wrapEvent(this.focus.onDidChange);
  }
  get onDidChangeSelection() {
    return this.eventBufferer.wrapEvent(this.selection.onDidChange);
  }
  get onMouseDblClick() {
    return Ae.map(this.view.onMouseDblClick, hW);
  }
  get onPointer() {
    return Ae.map(this.view.onPointer, hW);
  }
  get onDidFocus() {
    return this.view.onDidFocus;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get expandOnDoubleClick() {
    return typeof this._options.expandOnDoubleClick > "u" ? !0 : this._options.expandOnDoubleClick;
  }
  get expandOnlyOnTwistieClick() {
    return typeof this._options.expandOnlyOnTwistieClick > "u" ? !0 : this._options.expandOnlyOnTwistieClick;
  }
  get onDidDispose() {
    return this.view.onDidDispose;
  }
  updateOptions(e = {}) {
    this._options = Object.assign(Object.assign({}, this._options), e);
    for (const t of this.renderers)
      t.updateOptions(e);
    this.view.updateOptions({
      enableKeyboardNavigation: this._options.simpleKeyboardNavigation,
      automaticKeyboardNavigation: this._options.automaticKeyboardNavigation,
      smoothScrolling: this._options.smoothScrolling,
      horizontalScrolling: this._options.horizontalScrolling
    }), this.typeFilterController && this.typeFilterController.updateOptions(this._options), this._onDidUpdateOptions.fire(this._options), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === c_.Always);
  }
  get options() {
    return this._options;
  }
  // Widget
  getHTMLElement() {
    return this.view.getHTMLElement();
  }
  get scrollTop() {
    return this.view.scrollTop;
  }
  set scrollTop(e) {
    this.view.scrollTop = e;
  }
  domFocus() {
    this.view.domFocus();
  }
  layout(e, t) {
    this.view.layout(e, t);
  }
  style(e) {
    const t = `.${this.view.domId}`, i = [];
    e.treeIndentGuidesStroke && (i.push(`.monaco-list${t}:hover .monaco-tl-indent > .indent-guide, .monaco-list${t}.always .monaco-tl-indent > .indent-guide  { border-color: ${e.treeIndentGuidesStroke.transparent(0.4)}; }`), i.push(`.monaco-list${t} .monaco-tl-indent > .indent-guide.active { border-color: ${e.treeIndentGuidesStroke}; }`)), this.styleElement.textContent = i.join(`
`), this.view.style(e);
  }
  collapse(e, t = !1) {
    return this.model.setCollapsed(e, !0, t);
  }
  expand(e, t = !1) {
    return this.model.setCollapsed(e, !1, t);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  refilter() {
    this._onWillRefilter.fire(void 0), this.model.refilter();
  }
  setSelection(e, t) {
    const i = e.map((o) => this.model.getNode(o));
    this.selection.set(i, t);
    const r = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
    this.view.setSelection(r, t, !0);
  }
  getSelection() {
    return this.selection.get();
  }
  setFocus(e, t) {
    const i = e.map((o) => this.model.getNode(o));
    this.focus.set(i, t);
    const r = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
    this.view.setFocus(r, t, !0);
  }
  focusNext(e = 1, t = !1, i, r = this.focusNavigationFilter) {
    this.view.focusNext(e, t, i, r);
  }
  getFocus() {
    return this.focus.get();
  }
  reveal(e, t) {
    this.model.expandTo(e);
    const i = this.model.getListIndex(e);
    i !== -1 && this.view.reveal(i, t);
  }
  /**
   * Returns the relative position of an element rendered in the list.
   * Returns `null` if the element isn't *entirely* in the visible viewport.
   */
  getRelativeTop(e) {
    const t = this.model.getListIndex(e);
    return t === -1 ? null : this.view.getRelativeTop(t);
  }
  // List
  onLeftArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], r = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(r, !0)) {
      const s = this.model.getParentNodeLocation(r);
      if (!s)
        return;
      const a = this.model.getListIndex(s);
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onRightArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], r = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(r, !1)) {
      if (!i.children.some((l) => l.visible))
        return;
      const [s] = this.view.getFocus(), a = s + 1;
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onSpace(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], r = this.model.getNodeLocation(i), o = e.browserEvent.altKey;
    this.model.setCollapsed(r, void 0, o);
  }
  dispose() {
    yi(this.disposables), this.view.dispose();
  }
}
class xI {
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.nodesByIdentity = /* @__PURE__ */ new Map(), this.model = new Dge(e, t, null, i), this.onDidSplice = this.model.onDidSplice, this.onDidChangeCollapseState = this.model.onDidChangeCollapseState, this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount, i.sorter && (this.sorter = {
      compare(r, o) {
        return i.sorter.compare(r.element, o.element);
      }
    }), this.identityProvider = i.identityProvider;
  }
  setChildren(e, t = _t.empty(), i = {}) {
    const r = this.getElementLocation(e);
    this._setChildren(r, this.preserveCollapseState(t), i);
  }
  _setChildren(e, t = _t.empty(), i) {
    const r = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), s = (l) => {
      var u;
      if (l.element === null)
        return;
      const c = l;
      if (r.add(c.element), this.nodes.set(c.element, c), this.identityProvider) {
        const h = this.identityProvider.getId(c.element).toString();
        o.add(h), this.nodesByIdentity.set(h, c);
      }
      (u = i.onDidCreateNode) === null || u === void 0 || u.call(i, c);
    }, a = (l) => {
      var u;
      if (l.element === null)
        return;
      const c = l;
      if (r.has(c.element) || this.nodes.delete(c.element), this.identityProvider) {
        const h = this.identityProvider.getId(c.element).toString();
        o.has(h) || this.nodesByIdentity.delete(h);
      }
      (u = i.onDidDeleteNode) === null || u === void 0 || u.call(i, c);
    };
    this.model.splice([...e, 0], Number.MAX_VALUE, t, Object.assign(Object.assign({}, i), { onDidCreateNode: s, onDidDeleteNode: a }));
  }
  preserveCollapseState(e = _t.empty()) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), _t.map(e, (t) => {
      let i = this.nodes.get(t.element);
      if (!i && this.identityProvider) {
        const s = this.identityProvider.getId(t.element).toString();
        i = this.nodesByIdentity.get(s);
      }
      if (!i)
        return Object.assign(Object.assign({}, t), { children: this.preserveCollapseState(t.children) });
      const r = typeof t.collapsible == "boolean" ? t.collapsible : i.collapsible, o = typeof t.collapsed < "u" ? t.collapsed : i.collapsed;
      return Object.assign(Object.assign({}, t), {
        collapsible: r,
        collapsed: o,
        children: this.preserveCollapseState(t.children)
      });
    });
  }
  rerender(e) {
    const t = this.getElementLocation(e);
    this.model.rerender(t);
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getElementLocation(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getElementLocation(e);
    return this.model.getListRenderCount(t);
  }
  isCollapsible(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getElementLocation(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const r = this.getElementLocation(e);
    return this.model.setCollapsed(r, t, i);
  }
  expandTo(e) {
    const t = this.getElementLocation(e);
    this.model.expandTo(t);
  }
  refilter() {
    this.model.refilter();
  }
  getNode(e = null) {
    if (e === null)
      return this.model.getNode(this.model.rootRef);
    const t = this.nodes.get(e);
    if (!t)
      throw new ms(this.user, `Tree element not found: ${e}`);
    return t;
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    if (e === null)
      throw new ms(this.user, "Invalid getParentNodeLocation call");
    const t = this.nodes.get(e);
    if (!t)
      throw new ms(this.user, `Tree element not found: ${e}`);
    const i = this.model.getNodeLocation(t), r = this.model.getParentNodeLocation(i);
    return this.model.getNode(r).element;
  }
  getElementLocation(e) {
    if (e === null)
      return [];
    const t = this.nodes.get(e);
    if (!t)
      throw new ms(this.user, `Tree element not found: ${e}`);
    return this.model.getNodeLocation(t);
  }
}
function mw(n) {
  const e = [n.element], t = n.incompressible || !1;
  return {
    element: { elements: e, incompressible: t },
    children: _t.map(_t.from(n.children), mw),
    collapsible: n.collapsible,
    collapsed: n.collapsed
  };
}
function vw(n) {
  const e = [n.element], t = n.incompressible || !1;
  let i, r;
  for (; [r, i] = _t.consume(_t.from(n.children), 2), !(r.length !== 1 || r[0].incompressible); )
    n = r[0], e.push(n.element);
  return {
    element: { elements: e, incompressible: t },
    children: _t.map(_t.concat(r, i), vw),
    collapsible: n.collapsible,
    collapsed: n.collapsed
  };
}
function lO(n, e = 0) {
  let t;
  return e < n.element.elements.length - 1 ? t = [lO(n, e + 1)] : t = _t.map(_t.from(n.children), (i) => lO(i, 0)), e === 0 && n.element.incompressible ? {
    element: n.element.elements[e],
    children: t,
    incompressible: !0,
    collapsible: n.collapsible,
    collapsed: n.collapsed
  } : {
    element: n.element.elements[e],
    children: t,
    collapsible: n.collapsible,
    collapsed: n.collapsed
  };
}
function dW(n) {
  return lO(n, 0);
}
function L7(n, e, t) {
  return n.element === e ? Object.assign(Object.assign({}, n), { children: t }) : Object.assign(Object.assign({}, n), { children: _t.map(_t.from(n.children), (i) => L7(i, e, t)) });
}
const Fge = (n) => ({
  getId(e) {
    return e.elements.map((t) => n.getId(t).toString()).join("\0");
  }
});
class kge {
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.model = new xI(e, t, i), this.enabled = typeof i.compressionEnabled > "u" ? !0 : i.compressionEnabled, this.identityProvider = i.identityProvider;
  }
  get onDidSplice() {
    return this.model.onDidSplice;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get onDidChangeRenderNodeCount() {
    return this.model.onDidChangeRenderNodeCount;
  }
  setChildren(e, t = _t.empty(), i) {
    const r = i.diffIdentityProvider && Fge(i.diffIdentityProvider);
    if (e === null) {
      const f = _t.map(t, this.enabled ? vw : mw);
      this._setChildren(null, f, { diffIdentityProvider: r, diffDepth: 1 / 0 });
      return;
    }
    const o = this.nodes.get(e);
    if (!o)
      throw new Error("Unknown compressed tree node");
    const s = this.model.getNode(o), a = this.model.getParentNodeLocation(o), l = this.model.getNode(a), u = dW(s), c = L7(u, e, t), h = (this.enabled ? vw : mw)(c), d = l.children.map((f) => f === s ? h : f);
    this._setChildren(l.element, d, {
      diffIdentityProvider: r,
      diffDepth: s.depth - l.depth
    });
  }
  setCompressionEnabled(e) {
    if (e === this.enabled)
      return;
    this.enabled = e;
    const i = this.model.getNode().children, r = _t.map(i, dW), o = _t.map(r, e ? vw : mw);
    this._setChildren(null, o, {
      diffIdentityProvider: this.identityProvider,
      diffDepth: 1 / 0
    });
  }
  _setChildren(e, t, i) {
    const r = /* @__PURE__ */ new Set(), o = (a) => {
      for (const l of a.element.elements)
        r.add(l), this.nodes.set(l, a.element);
    }, s = (a) => {
      for (const l of a.element.elements)
        r.has(l) || this.nodes.delete(l);
    };
    this.model.setChildren(e, t, Object.assign(Object.assign({}, i), { onDidCreateNode: o, onDidDeleteNode: s }));
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListRenderCount(t);
  }
  getNode(e) {
    if (typeof e > "u")
      return this.model.getNode();
    const t = this.getCompressedNode(e);
    return this.model.getNode(t);
  }
  // TODO: review this
  getNodeLocation(e) {
    const t = this.model.getNodeLocation(e);
    return t === null ? null : t.elements[t.elements.length - 1];
  }
  // TODO: review this
  getParentNodeLocation(e) {
    const t = this.getCompressedNode(e), i = this.model.getParentNodeLocation(t);
    return i === null ? null : i.elements[i.elements.length - 1];
  }
  isCollapsible(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getCompressedNode(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const r = this.getCompressedNode(e);
    return this.model.setCollapsed(r, t, i);
  }
  expandTo(e) {
    const t = this.getCompressedNode(e);
    this.model.expandTo(t);
  }
  rerender(e) {
    const t = this.getCompressedNode(e);
    this.model.rerender(t);
  }
  refilter() {
    this.model.refilter();
  }
  getCompressedNode(e) {
    if (e === null)
      return null;
    const t = this.nodes.get(e);
    if (!t)
      throw new ms(this.user, `Tree element not found: ${e}`);
    return t;
  }
}
const Wge = (n) => n[n.length - 1];
class NI {
  constructor(e, t) {
    this.unwrapper = e, this.node = t;
  }
  get element() {
    return this.node.element === null ? null : this.unwrapper(this.node.element);
  }
  get children() {
    return this.node.children.map((e) => new NI(this.unwrapper, e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
}
function Vge(n, e) {
  return {
    splice(t, i, r) {
      e.splice(t, i, r.map((o) => n.map(o)));
    },
    updateElementHeight(t, i) {
      e.updateElementHeight(t, i);
    }
  };
}
function Bge(n, e) {
  return Object.assign(Object.assign({}, e), { identityProvider: e.identityProvider && {
    getId(t) {
      return e.identityProvider.getId(n(t));
    }
  }, sorter: e.sorter && {
    compare(t, i) {
      return e.sorter.compare(t.elements[0], i.elements[0]);
    }
  }, filter: e.filter && {
    filter(t, i) {
      return e.filter.filter(n(t), i);
    }
  } });
}
class Hge {
  constructor(e, t, i = {}) {
    this.rootRef = null, this.elementMapper = i.elementMapper || Wge;
    const r = (o) => this.elementMapper(o.elements);
    this.nodeMapper = new RI((o) => new NI(r, o)), this.model = new kge(e, Vge(this.nodeMapper, t), Bge(r, i));
  }
  get onDidSplice() {
    return Ae.map(this.model.onDidSplice, ({ insertedNodes: e, deletedNodes: t }) => ({
      insertedNodes: e.map((i) => this.nodeMapper.map(i)),
      deletedNodes: t.map((i) => this.nodeMapper.map(i))
    }));
  }
  get onDidChangeCollapseState() {
    return Ae.map(this.model.onDidChangeCollapseState, ({ node: e, deep: t }) => ({
      node: this.nodeMapper.map(e),
      deep: t
    }));
  }
  get onDidChangeRenderNodeCount() {
    return Ae.map(this.model.onDidChangeRenderNodeCount, (e) => this.nodeMapper.map(e));
  }
  setChildren(e, t = _t.empty(), i = {}) {
    this.model.setChildren(e, t, i);
  }
  setCompressionEnabled(e) {
    this.model.setCompressionEnabled(e);
  }
  has(e) {
    return this.model.has(e);
  }
  getListIndex(e) {
    return this.model.getListIndex(e);
  }
  getListRenderCount(e) {
    return this.model.getListRenderCount(e);
  }
  getNode(e) {
    return this.nodeMapper.map(this.model.getNode(e));
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    return this.model.getParentNodeLocation(e);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  setCollapsed(e, t, i) {
    return this.model.setCollapsed(e, t, i);
  }
  expandTo(e) {
    return this.model.expandTo(e);
  }
  rerender(e) {
    return this.model.rerender(e);
  }
  refilter() {
    return this.model.refilter();
  }
  getCompressedTreeNode(e = null) {
    return this.model.getNode(e);
  }
}
var Gge = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
};
class II extends E7 {
  constructor(e, t, i, r, o = {}) {
    super(e, t, i, r, o);
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  setChildren(e, t = _t.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  rerender(e) {
    if (e === void 0) {
      this.view.rerender();
      return;
    }
    this.model.rerender(e);
  }
  hasElement(e) {
    return this.model.has(e);
  }
  createModel(e, t, i) {
    return new xI(e, t, i);
  }
}
class D7 {
  constructor(e, t) {
    this._compressedTreeNodeProvider = e, this.renderer = t, this.templateId = t.templateId, t.onDidChangeTwistieState && (this.onDidChangeTwistieState = t.onDidChangeTwistieState);
  }
  get compressedTreeNodeProvider() {
    return this._compressedTreeNodeProvider();
  }
  renderTemplate(e) {
    return { compressedTreeNode: void 0, data: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, r) {
    const o = this.compressedTreeNodeProvider.getCompressedTreeNode(e.element);
    o.element.elements.length === 1 ? (i.compressedTreeNode = void 0, this.renderer.renderElement(e, t, i.data, r)) : (i.compressedTreeNode = o, this.renderer.renderCompressedElements(o, t, i.data, r));
  }
  disposeElement(e, t, i, r) {
    i.compressedTreeNode ? this.renderer.disposeCompressedElements && this.renderer.disposeCompressedElements(i.compressedTreeNode, t, i.data, r) : this.renderer.disposeElement && this.renderer.disposeElement(e, t, i.data, r);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.data);
  }
  renderTwistie(e, t) {
    return this.renderer.renderTwistie ? this.renderer.renderTwistie(e, t) : !1;
  }
}
Gge([
  Wn
], D7.prototype, "compressedTreeNodeProvider", null);
function Uge(n, e) {
  return e && Object.assign(Object.assign({}, e), { keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
    getKeyboardNavigationLabel(t) {
      let i;
      try {
        i = n().getCompressedTreeNode(t);
      } catch {
        return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t);
      }
      return i.element.elements.length === 1 ? e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t) : e.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(i.element.elements);
    }
  } });
}
class R7 extends II {
  constructor(e, t, i, r, o = {}) {
    const s = () => this, a = r.map((l) => new D7(s, l));
    super(e, t, i, a, Uge(s, o));
  }
  setChildren(e, t = _t.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  createModel(e, t, i) {
    return new Hge(e, t, i);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), typeof e.compressionEnabled < "u" && this.model.setCompressionEnabled(e.compressionEnabled);
  }
  getCompressedTreeNode(e = null) {
    return this.model.getCompressedTreeNode(e);
  }
}
var Lc = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function QD(n) {
  return Object.assign(Object.assign({}, n), { children: [], refreshPromise: void 0, stale: !0, slow: !1, collapsedByDefault: void 0 });
}
function uO(n, e) {
  return e.parent ? e.parent === n ? !0 : uO(n, e.parent) : !1;
}
function zge(n, e) {
  return n === e || uO(n, e) || uO(e, n);
}
class PI {
  constructor(e) {
    this.node = e;
  }
  get element() {
    return this.node.element.element;
  }
  get children() {
    return this.node.children.map((e) => new PI(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
}
class jge {
  constructor(e, t, i) {
    this.renderer = e, this.nodeMapper = t, this.onDidChangeTwistieState = i, this.renderedNodes = /* @__PURE__ */ new Map(), this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, r) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, r);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...sS.classNamesArray), !0) : (t.classList.remove(...sS.classNamesArray), !1);
  }
  disposeElement(e, t, i, r) {
    this.renderer.disposeElement && this.renderer.disposeElement(this.nodeMapper.map(e), t, i.templateData, r);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
  }
}
function fW(n) {
  return {
    browserEvent: n.browserEvent,
    elements: n.elements.map((e) => e.element)
  };
}
function pW(n) {
  return {
    browserEvent: n.browserEvent,
    element: n.element && n.element.element,
    target: n.target
  };
}
class $ge extends q_ {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function JD(n) {
  return n instanceof q_ ? new $ge(n) : n;
}
class Kge {
  constructor(e) {
    this.dnd = e;
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    this.dnd.onDragStart && this.dnd.onDragStart(JD(e), t);
  }
  onDragOver(e, t, i, r, o = !0) {
    return this.dnd.onDragOver(JD(e), t && t.element, i, r);
  }
  drop(e, t, i, r) {
    this.dnd.drop(JD(e), t && t.element, i, r);
  }
  onDragEnd(e) {
    this.dnd.onDragEnd && this.dnd.onDragEnd(e);
  }
}
function T7(n) {
  return n && Object.assign(Object.assign({}, n), { collapseByDefault: !0, identityProvider: n.identityProvider && {
    getId(e) {
      return n.identityProvider.getId(e.element);
    }
  }, dnd: n.dnd && new Kge(n.dnd), multipleSelectionController: n.multipleSelectionController && {
    isSelectionSingleChangeEvent(e) {
      return n.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
    },
    isSelectionRangeChangeEvent(e) {
      return n.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
    }
  }, accessibilityProvider: n.accessibilityProvider && Object.assign(Object.assign({}, n.accessibilityProvider), {
    getPosInSet: void 0,
    getSetSize: void 0,
    getRole: n.accessibilityProvider.getRole ? (e) => n.accessibilityProvider.getRole(e.element) : () => "treeitem",
    isChecked: n.accessibilityProvider.isChecked ? (e) => {
      var t;
      return !!(!((t = n.accessibilityProvider) === null || t === void 0) && t.isChecked(e.element));
    } : void 0,
    getAriaLabel(e) {
      return n.accessibilityProvider.getAriaLabel(e.element);
    },
    getWidgetAriaLabel() {
      return n.accessibilityProvider.getWidgetAriaLabel();
    },
    getWidgetRole: n.accessibilityProvider.getWidgetRole ? () => n.accessibilityProvider.getWidgetRole() : () => "tree",
    getAriaLevel: n.accessibilityProvider.getAriaLevel && ((e) => n.accessibilityProvider.getAriaLevel(e.element)),
    getActiveDescendantId: n.accessibilityProvider.getActiveDescendantId && ((e) => n.accessibilityProvider.getActiveDescendantId(e.element))
  }), filter: n.filter && {
    filter(e, t) {
      return n.filter.filter(e.element, t);
    }
  }, keyboardNavigationLabelProvider: n.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, n.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(e) {
    return n.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
  } }), sorter: void 0, expandOnlyOnTwistieClick: typeof n.expandOnlyOnTwistieClick > "u" ? void 0 : typeof n.expandOnlyOnTwistieClick != "function" ? n.expandOnlyOnTwistieClick : (e) => n.expandOnlyOnTwistieClick(e.element), additionalScrollHeight: n.additionalScrollHeight });
}
function cO(n, e) {
  e(n), n.children.forEach((t) => cO(t, e));
}
class O7 {
  constructor(e, t, i, r, o, s = {}) {
    this.user = e, this.dataSource = o, this.nodes = /* @__PURE__ */ new Map(), this.subTreeRefreshPromises = /* @__PURE__ */ new Map(), this.refreshPromises = /* @__PURE__ */ new Map(), this._onDidRender = new j(), this._onDidChangeNodeSlowState = new j(), this.nodeMapper = new RI((a) => new PI(a)), this.disposables = new ht(), this.identityProvider = s.identityProvider, this.autoExpandSingleChildren = typeof s.autoExpandSingleChildren > "u" ? !1 : s.autoExpandSingleChildren, this.sorter = s.sorter, this.collapseByDefault = s.collapseByDefault, this.tree = this.createTree(e, t, i, r, s), this.root = QD({
      element: void 0,
      parent: null,
      hasChildren: !0
    }), this.identityProvider && (this.root = Object.assign(Object.assign({}, this.root), { id: null })), this.nodes.set(null, this.root), this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
  }
  get onDidChangeFocus() {
    return Ae.map(this.tree.onDidChangeFocus, fW);
  }
  get onDidChangeSelection() {
    return Ae.map(this.tree.onDidChangeSelection, fW);
  }
  get onMouseDblClick() {
    return Ae.map(this.tree.onMouseDblClick, pW);
  }
  get onPointer() {
    return Ae.map(this.tree.onPointer, pW);
  }
  get onDidFocus() {
    return this.tree.onDidFocus;
  }
  get onDidDispose() {
    return this.tree.onDidDispose;
  }
  createTree(e, t, i, r, o) {
    const s = new OI(i), a = r.map((u) => new jge(u, this.nodeMapper, this._onDidChangeNodeSlowState.event)), l = T7(o) || {};
    return new II(e, t, s, a, l);
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  // Widget
  getHTMLElement() {
    return this.tree.getHTMLElement();
  }
  get scrollTop() {
    return this.tree.scrollTop;
  }
  set scrollTop(e) {
    this.tree.scrollTop = e;
  }
  domFocus() {
    this.tree.domFocus();
  }
  layout(e, t) {
    this.tree.layout(e, t);
  }
  style(e) {
    this.tree.style(e);
  }
  // Model
  getInput() {
    return this.root.element;
  }
  setInput(e, t) {
    return Lc(this, void 0, void 0, function* () {
      this.refreshPromises.forEach((r) => r.cancel()), this.refreshPromises.clear(), this.root.element = e;
      const i = t && { viewState: t, focus: [], selection: [] };
      yield this._updateChildren(e, !0, !1, i), i && (this.tree.setFocus(i.focus), this.tree.setSelection(i.selection)), t && typeof t.scrollTop == "number" && (this.scrollTop = t.scrollTop);
    });
  }
  _updateChildren(e = this.root.element, t = !0, i = !1, r, o) {
    return Lc(this, void 0, void 0, function* () {
      if (typeof this.root.element > "u")
        throw new ms(this.user, "Tree input not set");
      this.root.refreshPromise && (yield this.root.refreshPromise, yield Ae.toPromise(this._onDidRender.event));
      const s = this.getDataNode(e);
      if (yield this.refreshAndRenderNode(s, t, r, o), i)
        try {
          this.tree.rerender(s);
        } catch {
        }
    });
  }
  // View
  rerender(e) {
    if (e === void 0 || e === this.root.element) {
      this.tree.rerender();
      return;
    }
    const t = this.getDataNode(e);
    this.tree.rerender(t);
  }
  collapse(e, t = !1) {
    const i = this.getDataNode(e);
    return this.tree.collapse(i === this.root ? null : i, t);
  }
  expand(e, t = !1) {
    return Lc(this, void 0, void 0, function* () {
      if (typeof this.root.element > "u")
        throw new ms(this.user, "Tree input not set");
      this.root.refreshPromise && (yield this.root.refreshPromise, yield Ae.toPromise(this._onDidRender.event));
      const i = this.getDataNode(e);
      if (this.tree.hasElement(i) && !this.tree.isCollapsible(i) || (i.refreshPromise && (yield this.root.refreshPromise, yield Ae.toPromise(this._onDidRender.event)), i !== this.root && !i.refreshPromise && !this.tree.isCollapsed(i)))
        return !1;
      const r = this.tree.expand(i === this.root ? null : i, t);
      return i.refreshPromise && (yield this.root.refreshPromise, yield Ae.toPromise(this._onDidRender.event)), r;
    });
  }
  setSelection(e, t) {
    const i = e.map((r) => this.getDataNode(r));
    this.tree.setSelection(i, t);
  }
  getSelection() {
    return this.tree.getSelection().map((t) => t.element);
  }
  setFocus(e, t) {
    const i = e.map((r) => this.getDataNode(r));
    this.tree.setFocus(i, t);
  }
  getFocus() {
    return this.tree.getFocus().map((t) => t.element);
  }
  reveal(e, t) {
    this.tree.reveal(this.getDataNode(e), t);
  }
  // Implementation
  getDataNode(e) {
    const t = this.nodes.get(e === this.root.element ? null : e);
    if (!t)
      throw new ms(this.user, `Data tree node not found: ${e}`);
    return t;
  }
  refreshAndRenderNode(e, t, i, r) {
    return Lc(this, void 0, void 0, function* () {
      yield this.refreshNode(e, t, i), this.render(e, i, r);
    });
  }
  refreshNode(e, t, i) {
    return Lc(this, void 0, void 0, function* () {
      let r;
      return this.subTreeRefreshPromises.forEach((o, s) => {
        !r && zge(s, e) && (r = o.then(() => this.refreshNode(e, t, i)));
      }), r || this.doRefreshSubTree(e, t, i);
    });
  }
  doRefreshSubTree(e, t, i) {
    return Lc(this, void 0, void 0, function* () {
      let r;
      e.refreshPromise = new Promise((o) => r = o), this.subTreeRefreshPromises.set(e, e.refreshPromise), e.refreshPromise.finally(() => {
        e.refreshPromise = void 0, this.subTreeRefreshPromises.delete(e);
      });
      try {
        const o = yield this.doRefreshNode(e, t, i);
        e.stale = !1, yield KR.settled(o.map((s) => this.doRefreshSubTree(s, t, i)));
      } finally {
        r();
      }
    });
  }
  doRefreshNode(e, t, i) {
    return Lc(this, void 0, void 0, function* () {
      e.hasChildren = !!this.dataSource.hasChildren(e.element);
      let r;
      if (!e.hasChildren)
        r = Promise.resolve(_t.empty());
      else {
        const o = Vv(800);
        o.then(() => {
          e.slow = !0, this._onDidChangeNodeSlowState.fire(e);
        }, (s) => null), r = this.doGetChildren(e).finally(() => o.cancel());
      }
      try {
        const o = yield r;
        return this.setChildren(e, o, t, i);
      } catch (o) {
        if (e !== this.root && this.tree.hasElement(e) && this.tree.collapse(e), I_(o))
          return [];
        throw o;
      } finally {
        e.slow && (e.slow = !1, this._onDidChangeNodeSlowState.fire(e));
      }
    });
  }
  doGetChildren(e) {
    let t = this.refreshPromises.get(e);
    return t || (t = mG(() => Lc(this, void 0, void 0, function* () {
      const i = yield this.dataSource.getChildren(e.element);
      return this.processChildren(i);
    })), this.refreshPromises.set(e, t), t.finally(() => {
      this.refreshPromises.delete(e);
    }));
  }
  _onDidChangeCollapseState({ node: e, deep: t }) {
    e.element !== null && !e.collapsed && e.element.stale && (t ? this.collapse(e.element.element) : this.refreshAndRenderNode(e.element, !1).catch(Ni));
  }
  setChildren(e, t, i, r) {
    const o = [...t];
    if (e.children.length === 0 && o.length === 0)
      return [];
    const s = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    for (const c of e.children)
      if (s.set(c.element, c), this.identityProvider) {
        const h = this.tree.isCollapsed(c);
        a.set(c.id, { node: c, collapsed: h });
      }
    const l = [], u = o.map((c) => {
      const h = !!this.dataSource.hasChildren(c);
      if (!this.identityProvider) {
        const g = QD({ element: c, parent: e, hasChildren: h });
        return h && this.collapseByDefault && !this.collapseByDefault(c) && (g.collapsedByDefault = !1, l.push(g)), g;
      }
      const d = this.identityProvider.getId(c).toString(), f = a.get(d);
      if (f) {
        const g = f.node;
        return s.delete(g.element), this.nodes.delete(g.element), this.nodes.set(c, g), g.element = c, g.hasChildren = h, i ? f.collapsed ? (g.children.forEach((_) => cO(_, (m) => this.nodes.delete(m.element))), g.children.splice(0, g.children.length), g.stale = !0) : l.push(g) : h && this.collapseByDefault && !this.collapseByDefault(c) && (g.collapsedByDefault = !1, l.push(g)), g;
      }
      const p = QD({ element: c, parent: e, id: d, hasChildren: h });
      return r && r.viewState.focus && r.viewState.focus.indexOf(d) > -1 && r.focus.push(p), r && r.viewState.selection && r.viewState.selection.indexOf(d) > -1 && r.selection.push(p), r && r.viewState.expanded && r.viewState.expanded.indexOf(d) > -1 ? l.push(p) : h && this.collapseByDefault && !this.collapseByDefault(c) && (p.collapsedByDefault = !1, l.push(p)), p;
    });
    for (const c of s.values())
      cO(c, (h) => this.nodes.delete(h.element));
    for (const c of u)
      this.nodes.set(c.element, c);
    return e.children.splice(0, e.children.length, ...u), e !== this.root && this.autoExpandSingleChildren && u.length === 1 && l.length === 0 && (u[0].collapsedByDefault = !1, l.push(u[0])), l;
  }
  render(e, t, i) {
    const r = e.children.map((s) => this.asTreeElement(s, t)), o = i && Object.assign(Object.assign({}, i), { diffIdentityProvider: i.diffIdentityProvider && {
      getId(s) {
        return i.diffIdentityProvider.getId(s.element);
      }
    } });
    this.tree.setChildren(e === this.root ? null : e, r, o), e !== this.root && this.tree.setCollapsible(e, e.hasChildren), this._onDidRender.fire();
  }
  asTreeElement(e, t) {
    if (e.stale)
      return {
        element: e,
        collapsible: e.hasChildren,
        collapsed: !0
      };
    let i;
    return t && t.viewState.expanded && e.id && t.viewState.expanded.indexOf(e.id) > -1 ? i = !1 : i = e.collapsedByDefault, e.collapsedByDefault = void 0, {
      element: e,
      children: e.hasChildren ? _t.map(e.children, (r) => this.asTreeElement(r, t)) : [],
      collapsible: e.hasChildren,
      collapsed: i
    };
  }
  processChildren(e) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), e;
  }
  dispose() {
    this.disposables.dispose();
  }
}
class AI {
  constructor(e) {
    this.node = e;
  }
  get element() {
    return {
      elements: this.node.element.elements.map((e) => e.element),
      incompressible: this.node.element.incompressible
    };
  }
  get children() {
    return this.node.children.map((e) => new AI(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
}
class qge {
  constructor(e, t, i, r) {
    this.renderer = e, this.nodeMapper = t, this.compressibleNodeMapperProvider = i, this.onDidChangeTwistieState = r, this.renderedNodes = /* @__PURE__ */ new Map(), this.disposables = [], this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, r) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, r);
  }
  renderCompressedElements(e, t, i, r) {
    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, r);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...sS.classNamesArray), !0) : (t.classList.remove(...sS.classNamesArray), !1);
  }
  disposeElement(e, t, i, r) {
    this.renderer.disposeElement && this.renderer.disposeElement(this.nodeMapper.map(e), t, i.templateData, r);
  }
  disposeCompressedElements(e, t, i, r) {
    this.renderer.disposeCompressedElements && this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, r);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear(), this.disposables = yi(this.disposables);
  }
}
function Yge(n) {
  const e = n && T7(n);
  return e && Object.assign(Object.assign({}, e), { keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, e.keyboardNavigationLabelProvider), { getCompressedNodeKeyboardNavigationLabel(t) {
    return n.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(t.map((i) => i.element));
  } }) });
}
class Xge extends O7 {
  constructor(e, t, i, r, o, s, a = {}) {
    super(e, t, i, o, s, a), this.compressionDelegate = r, this.compressibleNodeMapper = new RI((l) => new AI(l)), this.filter = a.filter;
  }
  createTree(e, t, i, r, o) {
    const s = new OI(i), a = r.map((u) => new qge(u, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event)), l = Yge(o) || {};
    return new R7(e, t, s, a, l);
  }
  asTreeElement(e, t) {
    return Object.assign({ incompressible: this.compressionDelegate.isIncompressible(e.element) }, super.asTreeElement(e, t));
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  render(e, t) {
    if (!this.identityProvider)
      return super.render(e, t);
    const i = (d) => this.identityProvider.getId(d).toString(), r = (d) => {
      const f = /* @__PURE__ */ new Set();
      for (const p of d) {
        const g = this.tree.getCompressedTreeNode(p === this.root ? null : p);
        if (g.element)
          for (const _ of g.element.elements)
            f.add(i(_.element));
      }
      return f;
    }, o = r(this.tree.getSelection()), s = r(this.tree.getFocus());
    super.render(e, t);
    const a = this.getSelection();
    let l = !1;
    const u = this.getFocus();
    let c = !1;
    const h = (d) => {
      const f = d.element;
      if (f)
        for (let p = 0; p < f.elements.length; p++) {
          const g = i(f.elements[p].element), _ = f.elements[f.elements.length - 1].element;
          o.has(g) && a.indexOf(_) === -1 && (a.push(_), l = !0), s.has(g) && u.indexOf(_) === -1 && (u.push(_), c = !0);
        }
      d.children.forEach(h);
    };
    h(this.tree.getCompressedTreeNode(e === this.root ? null : e)), l && this.setSelection(a), c && this.setFocus(u);
  }
  // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work
  // and we have to filter everything beforehand
  // Related to #85193 and #85835
  processChildren(e) {
    return this.filter && (e = _t.filter(e, (t) => {
      const i = this.filter.filter(
        t,
        1
        /* Visible */
      ), r = Zge(i);
      if (r === 2)
        throw new Error("Recursive tree visibility not supported in async data compressed trees");
      return r === 1;
    })), super.processChildren(e);
  }
}
function Zge(n) {
  return typeof n == "boolean" ? n ? 1 : 0 : TI(n) ? u_(n.visibility) : u_(n);
}
class Qge extends E7 {
  constructor(e, t, i, r, o, s = {}) {
    super(e, t, i, r, s), this.user = e, this.dataSource = o, this.identityProvider = s.identityProvider;
  }
  createModel(e, t, i) {
    return new xI(e, t, i);
  }
}
const Jge = {
  separatorBorder: ee.transparent
};
class x7 {
  constructor(e, t, i, r) {
    this.container = e, this.view = t, this.disposable = r, this._cachedVisibleSize = void 0, typeof i == "number" ? (this._size = i, this._cachedVisibleSize = void 0, e.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = i.cachedVisibleSize);
  }
  set size(e) {
    this._size = e;
  }
  get size() {
    return this._size;
  }
  get visible() {
    return typeof this._cachedVisibleSize > "u";
  }
  setVisible(e, t) {
    e !== this.visible && (e ? (this.size = Pa(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof t == "number" ? t : this.size, this.size = 0), this.container.classList.toggle("visible", e), this.view.setVisible && this.view.setVisible(e));
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  get priority() {
    return this.view.priority;
  }
  get snap() {
    return !!this.view.snap;
  }
  set enabled(e) {
    this.container.style.pointerEvents = e ? "" : "none";
  }
  layout(e, t) {
    this.layoutContainer(e), this.view.layout(this.size, e, t);
  }
  dispose() {
    return this.disposable.dispose(), this.view;
  }
}
class eme extends x7 {
  layoutContainer(e) {
    this.container.style.top = `${e}px`, this.container.style.height = `${this.size}px`;
  }
}
class tme extends x7 {
  layoutContainer(e) {
    this.container.style.left = `${e}px`, this.container.style.width = `${this.size}px`;
  }
}
var Su;
(function(n) {
  n[n.Idle = 0] = "Idle", n[n.Busy = 1] = "Busy";
})(Su || (Su = {}));
var gW;
(function(n) {
  n.Distribute = { type: "distribute" };
  function e(i) {
    return { type: "split", index: i };
  }
  n.Split = e;
  function t(i) {
    return { type: "invisible", cachedVisibleSize: i };
  }
  n.Invisible = t;
})(gW || (gW = {}));
class ime extends ge {
  constructor(e, t = {}) {
    var i, r;
    super(), this.size = 0, this.contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.state = Su.Idle, this._onDidSashChange = this._register(new j()), this.onDidSashChange = this._onDidSashChange.event, this._onDidSashReset = this._register(new j()), this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this.orientation = Ls(t.orientation) ? 0 : t.orientation, this.inverseAltBehavior = !!t.inverseAltBehavior, this.proportionalLayout = Ls(t.proportionalLayout) ? !0 : !!t.proportionalLayout, this.getSashOrthogonalSize = t.getSashOrthogonalSize, this.el = document.createElement("div"), this.el.classList.add("monaco-split-view2"), this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal"), e.appendChild(this.el), this.sashContainer = Ie(this.el, Xe(".sash-container")), this.viewContainer = Xe(".split-view-container"), this.scrollable = new E0(125, zl), this.scrollableElement = this._register(new iI(this.viewContainer, {
      vertical: this.orientation === 0 ? (i = t.scrollbarVisibility) !== null && i !== void 0 ? i : 1 : 2,
      horizontal: this.orientation === 1 ? (r = t.scrollbarVisibility) !== null && r !== void 0 ? r : 1 : 2
      /* Hidden */
    }, this.scrollable)), this.onDidScroll = this.scrollableElement.onScroll, this._register(this.onDidScroll((o) => {
      this.viewContainer.scrollTop = o.scrollTop, this.viewContainer.scrollLeft = o.scrollLeft;
    })), Ie(this.el, this.scrollableElement.getDomNode()), this.style(t.styles || Jge), t.descriptor && (this.size = t.descriptor.size, t.descriptor.views.forEach((o, s) => {
      const a = Ls(o.visible) || o.visible ? o.size : { type: "invisible", cachedVisibleSize: o.size }, l = o.view;
      this.doAddView(l, a, s, !0);
    }), this.contentSize = this.viewItems.reduce((o, s) => o + s.size, 0), this.saveProportions());
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  set orthogonalStartSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalStartSash = e;
    this._orthogonalStartSash = e;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  set orthogonalEndSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalEndSash = e;
    this._orthogonalEndSash = e;
  }
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  set startSnappingEnabled(e) {
    this._startSnappingEnabled !== e && (this._startSnappingEnabled = e, this.updateSashEnablement());
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  set endSnappingEnabled(e) {
    this._endSnappingEnabled !== e && (this._endSnappingEnabled = e, this.updateSashEnablement());
  }
  style(e) {
    e.separatorBorder.isTransparent() ? (this.el.classList.remove("separator-border"), this.el.style.removeProperty("--separator-border")) : (this.el.classList.add("separator-border"), this.el.style.setProperty("--separator-border", e.separatorBorder.toString()));
  }
  addView(e, t, i = this.viewItems.length, r) {
    this.doAddView(e, t, i, r);
  }
  layout(e, t) {
    const i = Math.max(this.size, this.contentSize);
    if (this.size = e, this.layoutContext = t, this.proportions)
      for (let r = 0; r < this.viewItems.length; r++) {
        const o = this.viewItems[r];
        o.size = Pa(Math.round(this.proportions[r] * e), o.minimumSize, o.maximumSize);
      }
    else {
      const r = Ar(this.viewItems.length), o = r.filter(
        (a) => this.viewItems[a].priority === 1
        /* Low */
      ), s = r.filter(
        (a) => this.viewItems[a].priority === 2
        /* High */
      );
      this.resize(this.viewItems.length - 1, e - i, void 0, o, s);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  saveProportions() {
    this.proportionalLayout && this.contentSize > 0 && (this.proportions = this.viewItems.map((e) => e.size / this.contentSize));
  }
  onSashStart({ sash: e, start: t, alt: i }) {
    for (const a of this.viewItems)
      a.enabled = !1;
    const r = this.sashItems.findIndex((a) => a.sash === e), o = cp(yt(document.body, "keydown")((a) => s(this.sashDragState.current, a.altKey)), yt(document.body, "keyup")(() => s(this.sashDragState.current, !1))), s = (a, l) => {
      const u = this.viewItems.map((p) => p.size);
      let c = Number.NEGATIVE_INFINITY, h = Number.POSITIVE_INFINITY;
      if (this.inverseAltBehavior && (l = !l), l)
        if (r === this.sashItems.length - 1) {
          const g = this.viewItems[r];
          c = (g.minimumSize - g.size) / 2, h = (g.maximumSize - g.size) / 2;
        } else {
          const g = this.viewItems[r + 1];
          c = (g.size - g.maximumSize) / 2, h = (g.size - g.minimumSize) / 2;
        }
      let d, f;
      if (!l) {
        const p = Ar(r, -1), g = Ar(r + 1, this.viewItems.length), _ = p.reduce((E, D) => E + (this.viewItems[D].minimumSize - u[D]), 0), m = p.reduce((E, D) => E + (this.viewItems[D].viewMaximumSize - u[D]), 0), v = g.length === 0 ? Number.POSITIVE_INFINITY : g.reduce((E, D) => E + (u[D] - this.viewItems[D].minimumSize), 0), C = g.length === 0 ? Number.NEGATIVE_INFINITY : g.reduce((E, D) => E + (u[D] - this.viewItems[D].viewMaximumSize), 0), y = Math.max(_, C), b = Math.min(v, m), L = this.findFirstSnapIndex(p), S = this.findFirstSnapIndex(g);
        if (typeof L == "number") {
          const E = this.viewItems[L], D = Math.floor(E.viewMinimumSize / 2);
          d = {
            index: L,
            limitDelta: E.visible ? y - D : y + D,
            size: E.size
          };
        }
        if (typeof S == "number") {
          const E = this.viewItems[S], D = Math.floor(E.viewMinimumSize / 2);
          f = {
            index: S,
            limitDelta: E.visible ? b + D : b - D,
            size: E.size
          };
        }
      }
      this.sashDragState = { start: a, current: a, index: r, sizes: u, minDelta: c, maxDelta: h, alt: l, snapBefore: d, snapAfter: f, disposable: o };
    };
    s(t, i);
  }
  onSashChange({ current: e }) {
    const { index: t, start: i, sizes: r, alt: o, minDelta: s, maxDelta: a, snapBefore: l, snapAfter: u } = this.sashDragState;
    this.sashDragState.current = e;
    const c = e - i, h = this.resize(t, c, r, void 0, void 0, s, a, l, u);
    if (o) {
      const d = t === this.sashItems.length - 1, f = this.viewItems.map((C) => C.size), p = d ? t : t + 1, g = this.viewItems[p], _ = g.size - g.maximumSize, m = g.size - g.minimumSize, v = d ? t - 1 : t + 1;
      this.resize(v, -h, f, void 0, void 0, _, m);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  onSashEnd(e) {
    this._onDidSashChange.fire(e), this.sashDragState.disposable.dispose(), this.saveProportions();
    for (const t of this.viewItems)
      t.enabled = !0;
  }
  onViewChange(e, t) {
    const i = this.viewItems.indexOf(e);
    i < 0 || i >= this.viewItems.length || (t = typeof t == "number" ? t : e.size, t = Pa(t, e.minimumSize, e.maximumSize), this.inverseAltBehavior && i > 0 ? (this.resize(i - 1, Math.floor((e.size - t) / 2)), this.distributeEmptySpace(), this.layoutViews()) : (e.size = t, this.relayout([i], void 0)));
  }
  resizeView(e, t) {
    if (this.state !== Su.Idle)
      throw new Error("Cant modify splitview");
    if (this.state = Su.Busy, e < 0 || e >= this.viewItems.length)
      return;
    const i = Ar(this.viewItems.length).filter((a) => a !== e), r = [...i.filter(
      (a) => this.viewItems[a].priority === 1
      /* Low */
    ), e], o = i.filter(
      (a) => this.viewItems[a].priority === 2
      /* High */
    ), s = this.viewItems[e];
    t = Math.round(t), t = Pa(t, s.minimumSize, Math.min(s.maximumSize, this.size)), s.size = t, this.relayout(r, o), this.state = Su.Idle;
  }
  distributeViewSizes() {
    const e = [];
    let t = 0;
    for (const a of this.viewItems)
      a.maximumSize - a.minimumSize > 0 && (e.push(a), t += a.size);
    const i = Math.floor(t / e.length);
    for (const a of e)
      a.size = Pa(i, a.minimumSize, a.maximumSize);
    const r = Ar(this.viewItems.length), o = r.filter(
      (a) => this.viewItems[a].priority === 1
      /* Low */
    ), s = r.filter(
      (a) => this.viewItems[a].priority === 2
      /* High */
    );
    this.relayout(o, s);
  }
  getViewSize(e) {
    return e < 0 || e >= this.viewItems.length ? -1 : this.viewItems[e].size;
  }
  doAddView(e, t, i = this.viewItems.length, r) {
    if (this.state !== Su.Idle)
      throw new Error("Cant modify splitview");
    this.state = Su.Busy;
    const o = Xe(".split-view-view");
    i === this.viewItems.length ? this.viewContainer.appendChild(o) : this.viewContainer.insertBefore(o, this.viewContainer.children.item(i));
    const s = e.onDidChange((d) => this.onViewChange(c, d)), a = Ri(() => this.viewContainer.removeChild(o)), l = cp(s, a);
    let u;
    typeof t == "number" ? u = t : t.type === "split" ? u = this.getViewSize(t.index) / 2 : t.type === "invisible" ? u = { cachedVisibleSize: t.cachedVisibleSize } : u = e.minimumSize;
    const c = this.orientation === 0 ? new eme(o, e, u, l) : new tme(o, e, u, l);
    if (this.viewItems.splice(i, 0, c), this.viewItems.length > 1) {
      let d = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash };
      const f = this.orientation === 0 ? new us(this.sashContainer, { getHorizontalSashTop: (E) => this.getSashPosition(E), getHorizontalSashWidth: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, d), {
        orientation: 1
        /* HORIZONTAL */
      })) : new us(this.sashContainer, { getVerticalSashLeft: (E) => this.getSashPosition(E), getVerticalSashHeight: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, d), {
        orientation: 0
        /* VERTICAL */
      })), p = this.orientation === 0 ? (E) => ({ sash: f, start: E.startY, current: E.currentY, alt: E.altKey }) : (E) => ({ sash: f, start: E.startX, current: E.currentX, alt: E.altKey }), _ = Ae.map(f.onDidStart, p)(this.onSashStart, this), v = Ae.map(f.onDidChange, p)(this.onSashChange, this), y = Ae.map(f.onDidEnd, () => this.sashItems.findIndex((E) => E.sash === f))(this.onSashEnd, this), b = f.onDidReset(() => {
        const E = this.sashItems.findIndex((P) => P.sash === f), D = Ar(E, -1), O = Ar(E + 1, this.viewItems.length), T = this.findFirstSnapIndex(D), A = this.findFirstSnapIndex(O);
        typeof T == "number" && !this.viewItems[T].visible || typeof A == "number" && !this.viewItems[A].visible || this._onDidSashReset.fire(E);
      }), L = cp(_, v, y, b, f), S = { sash: f, disposable: L };
      this.sashItems.splice(i - 1, 0, S);
    }
    o.appendChild(e.element);
    let h;
    typeof t != "number" && t.type === "split" && (h = [t.index]), r || this.relayout([i], h), this.state = Su.Idle, !r && typeof t != "number" && t.type === "distribute" && this.distributeViewSizes();
  }
  relayout(e, t) {
    const i = this.viewItems.reduce((r, o) => r + o.size, 0);
    this.resize(this.viewItems.length - 1, this.size - i, void 0, e, t), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
  }
  resize(e, t, i = this.viewItems.map((c) => c.size), r, o, s = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, l, u) {
    if (e < 0 || e >= this.viewItems.length)
      return 0;
    const c = Ar(e, -1), h = Ar(e + 1, this.viewItems.length);
    if (o)
      for (const S of o)
        aD(c, S), aD(h, S);
    if (r)
      for (const S of r)
        hy(c, S), hy(h, S);
    const d = c.map((S) => this.viewItems[S]), f = c.map((S) => i[S]), p = h.map((S) => this.viewItems[S]), g = h.map((S) => i[S]), _ = c.reduce((S, E) => S + (this.viewItems[E].minimumSize - i[E]), 0), m = c.reduce((S, E) => S + (this.viewItems[E].maximumSize - i[E]), 0), v = h.length === 0 ? Number.POSITIVE_INFINITY : h.reduce((S, E) => S + (i[E] - this.viewItems[E].minimumSize), 0), C = h.length === 0 ? Number.NEGATIVE_INFINITY : h.reduce((S, E) => S + (i[E] - this.viewItems[E].maximumSize), 0), y = Math.max(_, C, s), b = Math.min(v, m, a);
    let L = !1;
    if (l) {
      const S = this.viewItems[l.index], E = t >= l.limitDelta;
      L = E !== S.visible, S.setVisible(E, l.size);
    }
    if (!L && u) {
      const S = this.viewItems[u.index], E = t < u.limitDelta;
      L = E !== S.visible, S.setVisible(E, u.size);
    }
    if (L)
      return this.resize(e, t, i, r, o, s, a);
    t = Pa(t, y, b);
    for (let S = 0, E = t; S < d.length; S++) {
      const D = d[S], O = Pa(f[S] + E, D.minimumSize, D.maximumSize), T = O - f[S];
      E -= T, D.size = O;
    }
    for (let S = 0, E = t; S < p.length; S++) {
      const D = p[S], O = Pa(g[S] - E, D.minimumSize, D.maximumSize), T = O - g[S];
      E += T, D.size = O;
    }
    return t;
  }
  distributeEmptySpace(e) {
    const t = this.viewItems.reduce((a, l) => a + l.size, 0);
    let i = this.size - t;
    const r = Ar(this.viewItems.length - 1, -1), o = r.filter(
      (a) => this.viewItems[a].priority === 1
      /* Low */
    ), s = r.filter(
      (a) => this.viewItems[a].priority === 2
      /* High */
    );
    for (const a of s)
      aD(r, a);
    for (const a of o)
      hy(r, a);
    typeof e == "number" && hy(r, e);
    for (let a = 0; i !== 0 && a < r.length; a++) {
      const l = this.viewItems[r[a]], u = Pa(l.size + i, l.minimumSize, l.maximumSize), c = u - l.size;
      i -= c, l.size = u;
    }
  }
  layoutViews() {
    this.contentSize = this.viewItems.reduce((t, i) => t + i.size, 0);
    let e = 0;
    for (const t of this.viewItems)
      t.layout(e, this.layoutContext), e += t.size;
    this.sashItems.forEach((t) => t.sash.layout()), this.updateSashEnablement(), this.updateScrollableElement();
  }
  updateScrollableElement() {
    this.orientation === 0 ? this.scrollableElement.setScrollDimensions({
      height: this.size,
      scrollHeight: this.contentSize
    }) : this.scrollableElement.setScrollDimensions({
      width: this.size,
      scrollWidth: this.contentSize
    });
  }
  updateSashEnablement() {
    let e = !1;
    const t = this.viewItems.map((l) => e = l.size - l.minimumSize > 0 || e);
    e = !1;
    const i = this.viewItems.map((l) => e = l.maximumSize - l.size > 0 || e), r = [...this.viewItems].reverse();
    e = !1;
    const o = r.map((l) => e = l.size - l.minimumSize > 0 || e).reverse();
    e = !1;
    const s = r.map((l) => e = l.maximumSize - l.size > 0 || e).reverse();
    let a = 0;
    for (let l = 0; l < this.sashItems.length; l++) {
      const { sash: u } = this.sashItems[l], c = this.viewItems[l];
      a += c.size;
      const h = !(t[l] && s[l + 1]), d = !(i[l] && o[l + 1]);
      if (h && d) {
        const f = Ar(l, -1), p = Ar(l + 1, this.viewItems.length), g = this.findFirstSnapIndex(f), _ = this.findFirstSnapIndex(p), m = typeof g == "number" && !this.viewItems[g].visible, v = typeof _ == "number" && !this.viewItems[_].visible;
        m && o[l] && (a > 0 || this.startSnappingEnabled) ? u.state = 1 : v && t[l] && (a < this.contentSize || this.endSnappingEnabled) ? u.state = 2 : u.state = 0;
      } else
        h && !d ? u.state = 1 : !h && d ? u.state = 2 : u.state = 3;
    }
  }
  getSashPosition(e) {
    let t = 0;
    for (let i = 0; i < this.sashItems.length; i++)
      if (t += this.viewItems[i].size, this.sashItems[i].sash === e)
        return t;
    return 0;
  }
  findFirstSnapIndex(e) {
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.snap)
        return t;
    }
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.maximumSize - i.minimumSize > 0)
        return;
      if (!i.visible && i.snap)
        return t;
    }
  }
  dispose() {
    super.dispose(), this.viewItems.forEach((e) => e.dispose()), this.viewItems = [], this.sashItems.forEach((e) => e.disposable.dispose()), this.sashItems = [];
  }
}
class Y_ {
  constructor(e, t, i) {
    this.columns = e, this.getColumnSize = i, this.templateId = Y_.TemplateId, this.renderedTemplates = /* @__PURE__ */ new Set();
    const r = new Map(t.map((o) => [o.templateId, o]));
    this.renderers = [];
    for (const o of e) {
      const s = r.get(o.templateId);
      if (!s)
        throw new Error(`Table cell renderer for template id ${o.templateId} not found.`);
      this.renderers.push(s);
    }
  }
  renderTemplate(e) {
    const t = Ie(e, Xe(".monaco-table-tr")), i = [], r = [];
    for (let s = 0; s < this.columns.length; s++) {
      const a = this.renderers[s], l = Ie(t, Xe(".monaco-table-td", { "data-col-index": s }));
      l.style.width = `${this.getColumnSize(s)}px`, i.push(l), r.push(a.renderTemplate(l));
    }
    const o = { container: e, cellContainers: i, cellTemplateData: r };
    return this.renderedTemplates.add(o), o;
  }
  renderElement(e, t, i, r) {
    for (let o = 0; o < this.columns.length; o++) {
      const a = this.columns[o].project(e);
      this.renderers[o].renderElement(a, t, i.cellTemplateData[o], r);
    }
  }
  disposeElement(e, t, i, r) {
    for (let o = 0; o < this.columns.length; o++) {
      const s = this.renderers[o];
      if (s.disposeElement) {
        const l = this.columns[o].project(e);
        s.disposeElement(l, t, i.cellTemplateData[o], r);
      }
    }
  }
  disposeTemplate(e) {
    for (let t = 0; t < this.columns.length; t++)
      this.renderers[t].disposeTemplate(e.cellTemplateData[t]);
    Ts(e.container), this.renderedTemplates.delete(e);
  }
  layoutColumn(e, t) {
    for (const { cellContainers: i } of this.renderedTemplates)
      i[e].style.width = `${t}px`;
  }
}
Y_.TemplateId = "row";
function nme(n) {
  return {
    getHeight(e) {
      return n.getHeight(e);
    },
    getTemplateId() {
      return Y_.TemplateId;
    }
  };
}
class rme {
  constructor(e, t) {
    this.column = e, this.index = t, this._onDidLayout = new j(), this.onDidLayout = this._onDidLayout.event, this.element = Xe(".monaco-table-th", { "data-col-index": t, title: e.tooltip }, e.label);
  }
  get minimumSize() {
    var e;
    return (e = this.column.minimumWidth) !== null && e !== void 0 ? e : 120;
  }
  get maximumSize() {
    var e;
    return (e = this.column.maximumWidth) !== null && e !== void 0 ? e : Number.POSITIVE_INFINITY;
  }
  get onDidChange() {
    var e;
    return (e = this.column.onDidChangeWidthConstraints) !== null && e !== void 0 ? e : Ae.None;
  }
  layout(e) {
    this._onDidLayout.fire([this.index, e]);
  }
}
class A0 {
  constructor(e, t, i, r, o, s) {
    this.virtualDelegate = i, this.domId = `table_id_${++A0.InstanceCount}`, this.cachedHeight = 0, this.domNode = Ie(t, Xe(`.monaco-table.${this.domId}`));
    const a = r.map((c, h) => new rme(c, h)), l = {
      size: a.reduce((c, h) => c + h.column.weight, 0),
      views: a.map((c) => ({ size: c.column.weight, view: c }))
    };
    this.splitview = new ime(this.domNode, {
      orientation: 1,
      scrollbarVisibility: 2,
      getSashOrthogonalSize: () => this.cachedHeight,
      descriptor: l
    }), this.splitview.el.style.height = `${i.headerRowHeight}px`, this.splitview.el.style.lineHeight = `${i.headerRowHeight}px`;
    const u = new Y_(r, o, (c) => this.splitview.getViewSize(c));
    this.list = new Jd(e, this.domNode, nme(i), [u], s), this.columnLayoutDisposable = Ae.any(...a.map((c) => c.onDidLayout))(([c, h]) => u.layoutColumn(c, h)), this.styleElement = Os(this.domNode), this.style({});
  }
  get onDidChangeFocus() {
    return this.list.onDidChangeFocus;
  }
  get onDidChangeSelection() {
    return this.list.onDidChangeSelection;
  }
  get onMouseDblClick() {
    return this.list.onMouseDblClick;
  }
  get onPointer() {
    return this.list.onPointer;
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  splice(e, t, i = []) {
    this.list.splice(e, t, i);
  }
  getHTMLElement() {
    return this.domNode;
  }
  style(e) {
    const t = [];
    t.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`), this.styleElement.textContent = t.join(`
`), this.list.style(e);
  }
  getSelectedElements() {
    return this.list.getSelectedElements();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getFocus() {
    return this.list.getFocus();
  }
  dispose() {
    this.splitview.dispose(), this.list.dispose(), this.columnLayoutDisposable.dispose();
  }
}
A0.InstanceCount = 0;
var Xl = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, ot = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
const Zl = Vt("listService");
let hO = class {
  constructor(e) {
    this._themeService = e, this.disposables = new ht(), this.lists = [], this._lastFocusedWidget = void 0, this._hasCreatedStyleController = !1;
  }
  get lastFocusedList() {
    return this._lastFocusedWidget;
  }
  register(e, t) {
    if (!this._hasCreatedStyleController) {
      this._hasCreatedStyleController = !0;
      const r = new S7(Os(), "");
      this.disposables.add(ig(r, this._themeService));
    }
    if (this.lists.some((r) => r.widget === e))
      throw new Error("Cannot register the same widget multiple times");
    const i = { widget: e, extraContextKeys: t };
    return this.lists.push(i), e.getHTMLElement() === document.activeElement && (this._lastFocusedWidget = e), cp(e.onDidFocus(() => this._lastFocusedWidget = e), Ri(() => this.lists.splice(this.lists.indexOf(i), 1)), e.onDidDispose(() => {
      this.lists = this.lists.filter((r) => r !== i), this._lastFocusedWidget === e && (this._lastFocusedWidget = void 0);
    }));
  }
  dispose() {
    this.disposables.dispose();
  }
};
hO = Xl([
  ot(0, Qn)
], hO);
const N7 = new it("listFocus", !0), M0 = new it("listSupportsMultiselect", !0), iwe = hr.and(N7, hr.not(Lge)), MI = new it("listHasSelectionOrFocus", !1), FI = new it("listDoubleSelection", !1), kI = new it("listMultiSelection", !1), F0 = new it("listSelectionNavigation", !1), ome = new it("listSupportsKeyboardNavigation", !0), WI = "listAutomaticKeyboardNavigation", sme = new it(WI, !0);
let mW = !1;
function k0(n, e) {
  const t = n.createScoped(e.getHTMLElement());
  return N7.bindTo(t), t;
}
const ef = "workbench.list.multiSelectModifier", dO = "workbench.list.openMode", Ds = "workbench.list.horizontalScrolling", aS = "workbench.list.keyboardNavigation", VI = "workbench.list.automaticKeyboardNavigation", lS = "workbench.tree.indent", uS = "workbench.tree.renderIndentGuides", Qa = "workbench.list.smoothScrolling", cS = "workbench.tree.expandMode";
function $l(n) {
  return n.getValue(ef) === "alt";
}
class ame extends ge {
  constructor(e) {
    super(), this.configurationService = e, this.useAltAsMultipleSelectionModifier = $l(e), this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration(ef) && (this.useAltAsMultipleSelectionModifier = $l(this.configurationService));
    }));
  }
  isSelectionSingleChangeEvent(e) {
    return this.useAltAsMultipleSelectionModifier ? e.browserEvent.altKey : y7(e);
  }
  isSelectionRangeChangeEvent(e) {
    return w7(e);
  }
}
function W0(n, e, t) {
  const i = new ht(), r = Object.assign({}, n);
  if (n.multipleSelectionSupport !== !1 && !n.multipleSelectionController) {
    const o = new ame(e);
    r.multipleSelectionController = o, i.add(o);
  }
  return r.keyboardNavigationDelegate = {
    mightProducePrintableCharacter(o) {
      return t.mightProducePrintableCharacter(o);
    }
  }, r.smoothScrolling = !!e.getValue(Qa), [r, i];
}
let fO = class extends Jd {
  constructor(e, t, i, r, o, s, a, l, u, c) {
    const h = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!u.getValue(Ds), [d, f] = W0(o, u, c);
    super(e, t, i, r, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, Fa(l.getColorTheme(), N0)), d), { horizontalScrolling: h })), this.disposables.add(f), this.contextKeyService = k0(s, this), this.themeService = l, M0.bindTo(this.contextKeyService).set(o.multipleSelectionSupport !== !1), F0.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this.listHasSelectionOrFocus = MI.bindTo(this.contextKeyService), this.listDoubleSelection = FI.bindTo(this.contextKeyService), this.listMultiSelection = kI.bindTo(this.contextKeyService), this.horizontalScrolling = o.horizontalScrolling, this._useAltAsMultipleSelectionModifier = $l(u), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), o.overrideStyles && this.updateStyles(o.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const _ = this.getSelection(), m = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(_.length > 0 || m.length > 0), this.listMultiSelection.set(_.length > 1), this.listDoubleSelection.set(_.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const _ = this.getSelection(), m = this.getFocus();
      this.listHasSelectionOrFocus.set(_.length > 0 || m.length > 0);
    })), this.disposables.add(u.onDidChangeConfiguration((_) => {
      _.affectsConfiguration(ef) && (this._useAltAsMultipleSelectionModifier = $l(u));
      let m = {};
      if (_.affectsConfiguration(Ds) && this.horizontalScrolling === void 0) {
        const v = !!u.getValue(Ds);
        m = Object.assign(Object.assign({}, m), { horizontalScrolling: v });
      }
      if (_.affectsConfiguration(Qa)) {
        const v = !!u.getValue(Qa);
        m = Object.assign(Object.assign({}, m), { smoothScrolling: v });
      }
      Object.keys(m).length > 0 && this.updateOptions(m);
    })), this.navigator = new I7(this, Object.assign({ configurationService: u }, o)), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles);
  }
  updateStyles(e) {
    var t;
    (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = ig(this, this.themeService, e);
  }
  dispose() {
    var e;
    (e = this._styler) === null || e === void 0 || e.dispose(), super.dispose();
  }
};
fO = Xl([
  ot(5, Ti),
  ot(6, Zl),
  ot(7, Qn),
  ot(8, mr),
  ot(9, Ro)
], fO);
let vW = class extends Ege {
  constructor(e, t, i, r, o, s, a, l, u, c) {
    const h = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!u.getValue(Ds), [d, f] = W0(o, u, c);
    super(e, t, i, r, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, Fa(l.getColorTheme(), N0)), d), { horizontalScrolling: h })), this.disposables = new ht(), this.disposables.add(f), this.contextKeyService = k0(s, this), this.themeService = l, this.horizontalScrolling = o.horizontalScrolling, M0.bindTo(this.contextKeyService).set(o.multipleSelectionSupport !== !1), F0.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this._useAltAsMultipleSelectionModifier = $l(u), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), o.overrideStyles && this.updateStyles(o.overrideStyles), o.overrideStyles && this.disposables.add(ig(this, l, o.overrideStyles)), this.disposables.add(u.onDidChangeConfiguration((_) => {
      _.affectsConfiguration(ef) && (this._useAltAsMultipleSelectionModifier = $l(u));
      let m = {};
      if (_.affectsConfiguration(Ds) && this.horizontalScrolling === void 0) {
        const v = !!u.getValue(Ds);
        m = Object.assign(Object.assign({}, m), { horizontalScrolling: v });
      }
      if (_.affectsConfiguration(Qa)) {
        const v = !!u.getValue(Qa);
        m = Object.assign(Object.assign({}, m), { smoothScrolling: v });
      }
      Object.keys(m).length > 0 && this.updateOptions(m);
    })), this.navigator = new I7(this, Object.assign({ configurationService: u }, o)), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles);
  }
  updateStyles(e) {
    var t;
    (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = ig(this, this.themeService, e);
  }
  dispose() {
    var e;
    (e = this._styler) === null || e === void 0 || e.dispose(), this.disposables.dispose(), super.dispose();
  }
};
vW = Xl([
  ot(5, Ti),
  ot(6, Zl),
  ot(7, Qn),
  ot(8, mr),
  ot(9, Ro)
], vW);
let _W = class extends A0 {
  constructor(e, t, i, r, o, s, a, l, u, c, h) {
    const d = typeof s.horizontalScrolling < "u" ? s.horizontalScrolling : !!c.getValue(Ds), [f, p] = W0(s, c, h);
    super(e, t, i, r, o, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, Fa(u.getColorTheme(), N0)), f), { horizontalScrolling: d })), this.disposables = new ht(), this.disposables.add(p), this.contextKeyService = k0(a, this), this.themeService = u, M0.bindTo(this.contextKeyService).set(s.multipleSelectionSupport !== !1), F0.bindTo(this.contextKeyService).set(!!s.selectionNavigation), this.listHasSelectionOrFocus = MI.bindTo(this.contextKeyService), this.listDoubleSelection = FI.bindTo(this.contextKeyService), this.listMultiSelection = kI.bindTo(this.contextKeyService), this.horizontalScrolling = s.horizontalScrolling, this._useAltAsMultipleSelectionModifier = $l(c), this.disposables.add(this.contextKeyService), this.disposables.add(l.register(this)), s.overrideStyles && this.updateStyles(s.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const m = this.getSelection(), v = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(m.length > 0 || v.length > 0), this.listMultiSelection.set(m.length > 1), this.listDoubleSelection.set(m.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const m = this.getSelection(), v = this.getFocus();
      this.listHasSelectionOrFocus.set(m.length > 0 || v.length > 0);
    })), this.disposables.add(c.onDidChangeConfiguration((m) => {
      m.affectsConfiguration(ef) && (this._useAltAsMultipleSelectionModifier = $l(c));
      let v = {};
      if (m.affectsConfiguration(Ds) && this.horizontalScrolling === void 0) {
        const C = !!c.getValue(Ds);
        v = Object.assign(Object.assign({}, v), { horizontalScrolling: C });
      }
      if (m.affectsConfiguration(Qa)) {
        const C = !!c.getValue(Qa);
        v = Object.assign(Object.assign({}, v), { smoothScrolling: C });
      }
      Object.keys(v).length > 0 && this.updateOptions(v);
    })), this.navigator = new lme(this, Object.assign({ configurationService: c }, s)), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles);
  }
  updateStyles(e) {
    var t;
    (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = ig(this, this.themeService, e);
  }
  dispose() {
    var e;
    (e = this._styler) === null || e === void 0 || e.dispose(), this.disposables.dispose(), super.dispose();
  }
};
_W = Xl([
  ot(6, Ti),
  ot(7, Zl),
  ot(8, Qn),
  ot(9, mr),
  ot(10, Ro)
], _W);
class BI extends ge {
  constructor(e, t) {
    var i;
    super(), this.widget = e, this._onDidOpen = this._register(new j()), this.onDidOpen = this._onDidOpen.event, this._register(Ae.filter(this.widget.onDidChangeSelection, (r) => r.browserEvent instanceof KeyboardEvent)((r) => this.onSelectionFromKeyboard(r))), this._register(this.widget.onPointer((r) => this.onPointer(r.element, r.browserEvent))), this._register(this.widget.onMouseDblClick((r) => this.onMouseDblClick(r.element, r.browserEvent))), typeof (t == null ? void 0 : t.openOnSingleClick) != "boolean" && (t != null && t.configurationService) ? (this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(dO)) !== "doubleClick", this._register(t == null ? void 0 : t.configurationService.onDidChangeConfiguration(() => {
      this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(dO)) !== "doubleClick";
    }))) : this.openOnSingleClick = (i = t == null ? void 0 : t.openOnSingleClick) !== null && i !== void 0 ? i : !0;
  }
  onSelectionFromKeyboard(e) {
    if (e.elements.length !== 1)
      return;
    const t = e.browserEvent, i = typeof t.preserveFocus == "boolean" ? t.preserveFocus : !0, r = typeof t.pinned == "boolean" ? t.pinned : !i, o = !1;
    this._open(this.getSelectedElement(), i, r, o, e.browserEvent);
  }
  onPointer(e, t) {
    if (!this.openOnSingleClick || t.detail === 2)
      return;
    const r = t.button === 1, o = !0, s = r, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, o, s, a, t);
  }
  onMouseDblClick(e, t) {
    if (!t)
      return;
    const i = t.target;
    if (i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && t.offsetX < 16)
      return;
    const o = !1, s = !0, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, o, s, a, t);
  }
  _open(e, t, i, r, o) {
    e && this._onDidOpen.fire({
      editorOptions: {
        preserveFocus: t,
        pinned: i,
        revealIfVisible: !0
      },
      sideBySide: r,
      element: e,
      browserEvent: o
    });
  }
}
class I7 extends BI {
  constructor(e, t) {
    super(e, t), this.widget = e;
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class lme extends BI {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class ume extends BI {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    var e;
    return (e = this.widget.getSelection()[0]) !== null && e !== void 0 ? e : void 0;
  }
}
function cme(n, e) {
  let t = !1;
  return (i) => {
    if (t)
      return t = !1, !1;
    const r = e.softDispatch(i, n);
    return r && r.enterChord ? (t = !0, !1) : (t = !1, !0);
  };
}
let CW = class extends II {
  constructor(e, t, i, r, o, s, a, l, u, c, h) {
    const { options: d, getAutomaticKeyboardNavigation: f, disposable: p } = X_(t, o, s, u, c, h);
    super(e, t, i, r, d), this.disposables.add(p), this.internals = new Vd(this, o, f, o.overrideStyles, s, a, l, u, h), this.disposables.add(this.internals);
  }
};
CW = Xl([
  ot(5, Ti),
  ot(6, Zl),
  ot(7, Qn),
  ot(8, mr),
  ot(9, Ro),
  ot(10, Is)
], CW);
let yW = class extends R7 {
  constructor(e, t, i, r, o, s, a, l, u, c, h) {
    const { options: d, getAutomaticKeyboardNavigation: f, disposable: p } = X_(t, o, s, u, c, h);
    super(e, t, i, r, d), this.disposables.add(p), this.internals = new Vd(this, o, f, o.overrideStyles, s, a, l, u, h), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles);
  }
};
yW = Xl([
  ot(5, Ti),
  ot(6, Zl),
  ot(7, Qn),
  ot(8, mr),
  ot(9, Ro),
  ot(10, Is)
], yW);
let wW = class extends Qge {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d) {
    const { options: f, getAutomaticKeyboardNavigation: p, disposable: g } = X_(t, s, a, c, h, d);
    super(e, t, i, r, o, f), this.disposables.add(g), this.internals = new Vd(this, s, p, s.overrideStyles, a, l, u, c, d), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles);
  }
};
wW = Xl([
  ot(6, Ti),
  ot(7, Zl),
  ot(8, Qn),
  ot(9, mr),
  ot(10, Ro),
  ot(11, Is)
], wW);
let bW = class extends O7 {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d) {
    const { options: f, getAutomaticKeyboardNavigation: p, disposable: g } = X_(t, s, a, c, h, d);
    super(e, t, i, r, o, f), this.disposables.add(g), this.internals = new Vd(this, s, p, s.overrideStyles, a, l, u, c, d), this.disposables.add(this.internals);
  }
  get onDidOpen() {
    return this.internals.onDidOpen;
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles);
  }
};
bW = Xl([
  ot(6, Ti),
  ot(7, Zl),
  ot(8, Qn),
  ot(9, mr),
  ot(10, Ro),
  ot(11, Is)
], bW);
let SW = class extends Xge {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d, f) {
    const { options: p, getAutomaticKeyboardNavigation: g, disposable: _ } = X_(t, a, l, h, d, f);
    super(e, t, i, r, o, s, p), this.disposables.add(_), this.internals = new Vd(this, a, g, a.overrideStyles, l, u, c, h, f), this.disposables.add(this.internals);
  }
};
SW = Xl([
  ot(7, Ti),
  ot(8, Zl),
  ot(9, Qn),
  ot(10, mr),
  ot(11, Ro),
  ot(12, Is)
], SW);
function X_(n, e, t, i, r, o) {
  var s;
  ome.bindTo(t), mW || (sme.bindTo(t), mW = !0);
  const a = () => {
    let p = !!t.getContextKeyValue(WI);
    return p && (p = !!i.getValue(VI)), p;
  }, l = o.isScreenReaderOptimized(), u = e.simpleKeyboardNavigation || l ? "simple" : i.getValue(aS), c = e.horizontalScrolling !== void 0 ? e.horizontalScrolling : !!i.getValue(Ds), [h, d] = W0(e, i, r), f = e.additionalScrollHeight;
  return {
    getAutomaticKeyboardNavigation: a,
    disposable: d,
    options: Object.assign(Object.assign({
      // ...options, // TODO@Joao why is this not splatted here?
      keyboardSupport: !1
    }, h), { indent: i.getValue(lS), renderIndentGuides: i.getValue(uS), smoothScrolling: !!i.getValue(Qa), automaticKeyboardNavigation: a(), simpleKeyboardNavigation: u === "simple", filterOnType: u === "filter", horizontalScrolling: c, keyboardNavigationEventFilter: cme(n, r), additionalScrollHeight: f, hideTwistiesOfChildlessElements: e.hideTwistiesOfChildlessElements, expandOnlyOnTwistieClick: (s = e.expandOnlyOnTwistieClick) !== null && s !== void 0 ? s : i.getValue(cS) === "doubleClick" })
  };
}
let Vd = class {
  constructor(e, t, i, r, o, s, a, l, u) {
    this.tree = e, this.themeService = a, this.disposables = [], this.contextKeyService = k0(o, e), M0.bindTo(this.contextKeyService).set(t.multipleSelectionSupport !== !1), F0.bindTo(this.contextKeyService).set(!!t.selectionNavigation), this.hasSelectionOrFocus = MI.bindTo(this.contextKeyService), this.hasDoubleSelection = FI.bindTo(this.contextKeyService), this.hasMultiSelection = kI.bindTo(this.contextKeyService), this._useAltAsMultipleSelectionModifier = $l(l);
    const d = /* @__PURE__ */ new Set();
    d.add(WI);
    const f = () => {
      const g = u.isScreenReaderOptimized() ? "simple" : l.getValue(aS);
      e.updateOptions({
        simpleKeyboardNavigation: g === "simple",
        filterOnType: g === "filter"
      });
    };
    this.updateStyleOverrides(r), this.disposables.push(this.contextKeyService, s.register(e), e.onDidChangeSelection(() => {
      const p = e.getSelection(), g = e.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.hasSelectionOrFocus.set(p.length > 0 || g.length > 0), this.hasMultiSelection.set(p.length > 1), this.hasDoubleSelection.set(p.length === 2);
      });
    }), e.onDidChangeFocus(() => {
      const p = e.getSelection(), g = e.getFocus();
      this.hasSelectionOrFocus.set(p.length > 0 || g.length > 0);
    }), l.onDidChangeConfiguration((p) => {
      let g = {};
      if (p.affectsConfiguration(ef) && (this._useAltAsMultipleSelectionModifier = $l(l)), p.affectsConfiguration(lS)) {
        const _ = l.getValue(lS);
        g = Object.assign(Object.assign({}, g), { indent: _ });
      }
      if (p.affectsConfiguration(uS)) {
        const _ = l.getValue(uS);
        g = Object.assign(Object.assign({}, g), { renderIndentGuides: _ });
      }
      if (p.affectsConfiguration(Qa)) {
        const _ = !!l.getValue(Qa);
        g = Object.assign(Object.assign({}, g), { smoothScrolling: _ });
      }
      if (p.affectsConfiguration(aS) && f(), p.affectsConfiguration(VI) && (g = Object.assign(Object.assign({}, g), { automaticKeyboardNavigation: i() })), p.affectsConfiguration(Ds) && t.horizontalScrolling === void 0) {
        const _ = !!l.getValue(Ds);
        g = Object.assign(Object.assign({}, g), { horizontalScrolling: _ });
      }
      p.affectsConfiguration(cS) && t.expandOnlyOnTwistieClick === void 0 && (g = Object.assign(Object.assign({}, g), { expandOnlyOnTwistieClick: l.getValue(cS) === "doubleClick" })), Object.keys(g).length > 0 && e.updateOptions(g);
    }), this.contextKeyService.onDidChangeContext((p) => {
      p.affectsSome(d) && e.updateOptions({ automaticKeyboardNavigation: i() });
    }), u.onDidChangeScreenReaderOptimized(() => f())), this.navigator = new ume(e, Object.assign({ configurationService: l }, t)), this.disposables.push(this.navigator);
  }
  get onDidOpen() {
    return this.navigator.onDidOpen;
  }
  updateStyleOverrides(e) {
    yi(this.styler), this.styler = e ? ig(this.tree, this.themeService, e) : ge.None;
  }
  dispose() {
    this.disposables = yi(this.disposables), yi(this.styler), this.styler = void 0;
  }
};
Vd = Xl([
  ot(4, Ti),
  ot(5, Zl),
  ot(6, Qn),
  ot(7, mr),
  ot(8, Is)
], Vd);
const hme = Zn.as(Eg.Configuration);
hme.registerConfiguration({
  id: "workbench",
  order: 7,
  title: w("workbenchConfigurationTitle", "Workbench"),
  type: "object",
  properties: {
    [ef]: {
      type: "string",
      enum: ["ctrlCmd", "alt"],
      enumDescriptions: [
        w("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
        w("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
      ],
      default: "ctrlCmd",
      description: w({
        key: "multiSelectModifier",
        comment: [
          "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
          "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
        ]
      }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
    },
    [dO]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: w({
        key: "openModeModifier",
        comment: ["`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."]
      }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [Ds]: {
      type: "boolean",
      default: !1,
      description: w("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
    },
    [lS]: {
      type: "number",
      default: 8,
      minimum: 0,
      maximum: 40,
      description: w("tree indent setting", "Controls tree indentation in pixels.")
    },
    [uS]: {
      type: "string",
      enum: ["none", "onHover", "always"],
      default: "onHover",
      description: w("render tree indent guides", "Controls whether the tree should render indent guides.")
    },
    [Qa]: {
      type: "boolean",
      default: !1,
      description: w("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
    },
    [aS]: {
      type: "string",
      enum: ["simple", "highlight", "filter"],
      enumDescriptions: [
        w("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
        w("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
        w("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
      ],
      default: "highlight",
      description: w("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter.")
    },
    [VI]: {
      type: "boolean",
      default: !0,
      markdownDescription: w("automatic keyboard navigation setting", "Controls whether keyboard navigation in lists and trees is automatically triggered simply by typing. If set to `false`, keyboard navigation is only triggered when executing the `list.toggleKeyboardNavigation` command, for which you can assign a keyboard shortcut.")
    },
    [cS]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: w("expand mode", "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    }
  }
});
var vs;
(function(n) {
  n[n.Hint = 1] = "Hint", n[n.Info = 2] = "Info", n[n.Warning = 4] = "Warning", n[n.Error = 8] = "Error";
})(vs || (vs = {}));
(function(n) {
  function e(s, a) {
    return a - s;
  }
  n.compare = e;
  const t = /* @__PURE__ */ Object.create(null);
  t[n.Error] = w("sev.error", "Error"), t[n.Warning] = w("sev.warning", "Warning"), t[n.Info] = w("sev.info", "Info");
  function i(s) {
    return t[s] || "";
  }
  n.toString = i;
  function r(s) {
    switch (s) {
      case pn.Error:
        return n.Error;
      case pn.Warning:
        return n.Warning;
      case pn.Info:
        return n.Info;
      case pn.Ignore:
        return n.Hint;
    }
  }
  n.fromSeverity = r;
  function o(s) {
    switch (s) {
      case n.Error:
        return pn.Error;
      case n.Warning:
        return pn.Warning;
      case n.Info:
        return pn.Info;
      case n.Hint:
        return pn.Ignore;
    }
  }
  n.toSeverity = o;
})(vs || (vs = {}));
var EW;
(function(n) {
  const e = "";
  function t(r) {
    return i(r, !0);
  }
  n.makeKey = t;
  function i(r, o) {
    let s = [e];
    return r.source ? s.push(r.source.replace("", "\\")) : s.push(e), r.code ? typeof r.code == "string" ? s.push(r.code.replace("", "\\")) : s.push(r.code.value.replace("", "\\")) : s.push(e), r.severity !== void 0 && r.severity !== null ? s.push(vs.toString(r.severity)) : s.push(e), r.message && o ? s.push(r.message.replace("", "\\")) : s.push(e), r.startLineNumber !== void 0 && r.startLineNumber !== null ? s.push(r.startLineNumber.toString()) : s.push(e), r.startColumn !== void 0 && r.startColumn !== null ? s.push(r.startColumn.toString()) : s.push(e), r.endLineNumber !== void 0 && r.endLineNumber !== null ? s.push(r.endLineNumber.toString()) : s.push(e), r.endColumn !== void 0 && r.endColumn !== null ? s.push(r.endColumn.toString()) : s.push(e), s.push(e), s.join("");
  }
  n.makeKeyOptionalMessage = i;
})(EW || (EW = {}));
const P7 = Vt("markerService");
class dme {
  constructor() {
    this._byResource = new yo(), this._byOwner = /* @__PURE__ */ new Map();
  }
  set(e, t, i) {
    let r = this._byResource.get(e);
    r || (r = /* @__PURE__ */ new Map(), this._byResource.set(e, r)), r.set(t, i);
    let o = this._byOwner.get(t);
    o || (o = new yo(), this._byOwner.set(t, o)), o.set(e, i);
  }
  get(e, t) {
    let i = this._byResource.get(e);
    return i == null ? void 0 : i.get(t);
  }
  delete(e, t) {
    let i = !1, r = !1, o = this._byResource.get(e);
    o && (i = o.delete(t));
    let s = this._byOwner.get(t);
    if (s && (r = s.delete(e)), i !== r)
      throw new Error("illegal state");
    return i && r;
  }
  values(e) {
    var t, i, r, o;
    return typeof e == "string" ? (i = (t = this._byOwner.get(e)) === null || t === void 0 ? void 0 : t.values()) !== null && i !== void 0 ? i : _t.empty() : dt.isUri(e) ? (o = (r = this._byResource.get(e)) === null || r === void 0 ? void 0 : r.values()) !== null && o !== void 0 ? o : _t.empty() : _t.map(_t.concat(...this._byOwner.values()), (s) => s[1]);
  }
}
class fme {
  constructor(e) {
    this.errors = 0, this.infos = 0, this.warnings = 0, this.unknowns = 0, this._data = new yo(), this._service = e, this._subscription = e.onMarkerChanged(this._update, this);
  }
  dispose() {
    this._subscription.dispose();
  }
  _update(e) {
    for (const t of e) {
      const i = this._data.get(t);
      i && this._substract(i);
      const r = this._resourceStats(t);
      this._add(r), this._data.set(t, r);
    }
  }
  _resourceStats(e) {
    const t = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
    if (e.scheme === vi.inMemory || e.scheme === vi.walkThrough || e.scheme === vi.walkThroughSnippet)
      return t;
    for (const { severity: i } of this._service.read({ resource: e }))
      i === vs.Error ? t.errors += 1 : i === vs.Warning ? t.warnings += 1 : i === vs.Info ? t.infos += 1 : t.unknowns += 1;
    return t;
  }
  _substract(e) {
    this.errors -= e.errors, this.warnings -= e.warnings, this.infos -= e.infos, this.unknowns -= e.unknowns;
  }
  _add(e) {
    this.errors += e.errors, this.warnings += e.warnings, this.infos += e.infos, this.unknowns += e.unknowns;
  }
}
class Tl {
  constructor() {
    this._onMarkerChanged = new j(), this.onMarkerChanged = Ae.debounce(this._onMarkerChanged.event, Tl._debouncer, 0), this._data = new dme(), this._stats = new fme(this);
  }
  dispose() {
    this._stats.dispose(), this._onMarkerChanged.dispose();
  }
  remove(e, t) {
    for (const i of t || [])
      this.changeOne(e, i, []);
  }
  changeOne(e, t, i) {
    if (nse(i))
      this._data.delete(t, e) && this._onMarkerChanged.fire([t]);
    else {
      const r = [];
      for (const o of i) {
        const s = Tl._toMarker(e, t, o);
        s && r.push(s);
      }
      this._data.set(t, e, r), this._onMarkerChanged.fire([t]);
    }
  }
  static _toMarker(e, t, i) {
    let { code: r, severity: o, message: s, source: a, startLineNumber: l, startColumn: u, endLineNumber: c, endColumn: h, relatedInformation: d, tags: f } = i;
    if (s)
      return l = l > 0 ? l : 1, u = u > 0 ? u : 1, c = c >= l ? c : l, h = h > 0 ? h : u, {
        resource: t,
        owner: e,
        code: r,
        severity: o,
        message: s,
        source: a,
        startLineNumber: l,
        startColumn: u,
        endLineNumber: c,
        endColumn: h,
        relatedInformation: d,
        tags: f
      };
  }
  read(e = /* @__PURE__ */ Object.create(null)) {
    let { owner: t, resource: i, severities: r, take: o } = e;
    if ((!o || o < 0) && (o = -1), t && i) {
      const s = this._data.get(i, t);
      if (s) {
        const a = [];
        for (const l of s)
          if (Tl._accept(l, r)) {
            const u = a.push(l);
            if (o > 0 && u === o)
              break;
          }
        return a;
      } else
        return [];
    } else if (!t && !i) {
      const s = [];
      for (let a of this._data.values())
        for (let l of a)
          if (Tl._accept(l, r)) {
            const u = s.push(l);
            if (o > 0 && u === o)
              return s;
          }
      return s;
    } else {
      const s = this._data.values(i ?? t), a = [];
      for (const l of s)
        for (const u of l)
          if (Tl._accept(u, r)) {
            const c = a.push(u);
            if (o > 0 && c === o)
              return a;
          }
      return a;
    }
  }
  static _accept(e, t) {
    return t === void 0 || (t & e.severity) === e.severity;
  }
  static _debouncer(e, t) {
    e || (Tl._dedupeMap = new yo(), e = []);
    for (const i of t)
      Tl._dedupeMap.has(i) || (Tl._dedupeMap.set(i, !0), e.push(i));
    return e;
  }
}
var _w = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
}, tp;
(function(n) {
  n[n.None = 0] = "None", n[n.Initialized = 1] = "Initialized", n[n.Closed = 2] = "Closed";
})(tp || (tp = {}));
class d_ extends ge {
  constructor(e, t = /* @__PURE__ */ Object.create(null)) {
    super(), this.database = e, this.options = t, this._onDidChangeStorage = this._register(new j()), this.onDidChangeStorage = this._onDidChangeStorage.event, this.state = tp.None, this.cache = /* @__PURE__ */ new Map(), this.flushDelayer = new xne(d_.DEFAULT_FLUSH_DELAY), this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.whenFlushedCallbacks = [], this.registerListeners();
  }
  registerListeners() {
    this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
  }
  onDidChangeItemsExternal(e) {
    var t, i;
    (t = e.changed) === null || t === void 0 || t.forEach((r, o) => this.accept(o, r)), (i = e.deleted) === null || i === void 0 || i.forEach((r) => this.accept(r, void 0));
  }
  accept(e, t) {
    if (this.state === tp.Closed)
      return;
    let i = !1;
    ps(t) ? i = this.cache.delete(e) : this.cache.get(e) !== t && (this.cache.set(e, t), i = !0), i && this._onDidChangeStorage.fire(e);
  }
  get(e, t) {
    const i = this.cache.get(e);
    return ps(i) ? t : i;
  }
  getBoolean(e, t) {
    const i = this.get(e);
    return ps(i) ? t : i === "true";
  }
  getNumber(e, t) {
    const i = this.get(e);
    return ps(i) ? t : parseInt(i, 10);
  }
  set(e, t) {
    return _w(this, void 0, void 0, function* () {
      if (this.state === tp.Closed)
        return;
      if (ps(t))
        return this.delete(e);
      const i = String(t);
      if (this.cache.get(e) !== i)
        return this.cache.set(e, i), this.pendingInserts.set(e, i), this.pendingDeletes.delete(e), this._onDidChangeStorage.fire(e), this.flushDelayer.trigger(() => this.flushPending());
    });
  }
  delete(e) {
    return _w(this, void 0, void 0, function* () {
      if (!(this.state === tp.Closed || !this.cache.delete(e)))
        return this.pendingDeletes.has(e) || this.pendingDeletes.add(e), this.pendingInserts.delete(e), this._onDidChangeStorage.fire(e), this.flushDelayer.trigger(() => this.flushPending());
    });
  }
  get hasPending() {
    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
  }
  flushPending() {
    return _w(this, void 0, void 0, function* () {
      if (!this.hasPending)
        return;
      const e = { insert: this.pendingInserts, delete: this.pendingDeletes };
      return this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.database.updateItems(e).finally(() => {
        var t;
        if (!this.hasPending)
          for (; this.whenFlushedCallbacks.length; )
            (t = this.whenFlushedCallbacks.pop()) === null || t === void 0 || t();
      });
    });
  }
  dispose() {
    this.flushDelayer.cancel(), this.flushDelayer.dispose(), super.dispose();
  }
}
d_.DEFAULT_FLUSH_DELAY = 100;
class LW {
  constructor() {
    this.onDidChangeItemsExternal = Ae.None, this.items = /* @__PURE__ */ new Map();
  }
  updateItems(e) {
    return _w(this, void 0, void 0, function* () {
      e.insert && e.insert.forEach((t, i) => this.items.set(i, t)), e.delete && e.delete.forEach((t) => this.items.delete(t));
    });
  }
}
const Py = "__$__targetStorageMarker", pme = Vt("storageService");
var DW;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.SHUTDOWN = 1] = "SHUTDOWN";
})(DW || (DW = {}));
class V0 extends ge {
  constructor(e = { flushInterval: V0.DEFAULT_FLUSH_INTERVAL }) {
    super(), this.options = e, this._onDidChangeValue = this._register(new Z1()), this._onDidChangeTarget = this._register(new Z1()), this._onWillSaveState = this._register(new j()), this.onWillSaveState = this._onWillSaveState.event, this._workspaceKeyTargets = void 0, this._globalKeyTargets = void 0;
  }
  emitDidChangeValue(e, t) {
    t === Py ? (e === 0 ? this._globalKeyTargets = void 0 : e === 1 && (this._workspaceKeyTargets = void 0), this._onDidChangeTarget.fire({ scope: e })) : this._onDidChangeValue.fire({ scope: e, key: t, target: this.getKeyTargets(e)[t] });
  }
  get(e, t, i) {
    var r;
    return (r = this.getStorage(t)) === null || r === void 0 ? void 0 : r.get(e, i);
  }
  getBoolean(e, t, i) {
    var r;
    return (r = this.getStorage(t)) === null || r === void 0 ? void 0 : r.getBoolean(e, i);
  }
  getNumber(e, t, i) {
    var r;
    return (r = this.getStorage(t)) === null || r === void 0 ? void 0 : r.getNumber(e, i);
  }
  store(e, t, i, r) {
    if (ps(t)) {
      this.remove(e, i);
      return;
    }
    this.withPausedEmitters(() => {
      var o;
      this.updateKeyTarget(e, i, r), (o = this.getStorage(i)) === null || o === void 0 || o.set(e, t);
    });
  }
  remove(e, t) {
    this.withPausedEmitters(() => {
      var i;
      this.updateKeyTarget(e, t, void 0), (i = this.getStorage(t)) === null || i === void 0 || i.delete(e);
    });
  }
  withPausedEmitters(e) {
    this._onDidChangeValue.pause(), this._onDidChangeTarget.pause();
    try {
      e();
    } finally {
      this._onDidChangeValue.resume(), this._onDidChangeTarget.resume();
    }
  }
  updateKeyTarget(e, t, i) {
    var r, o;
    const s = this.getKeyTargets(t);
    typeof i == "number" ? s[e] !== i && (s[e] = i, (r = this.getStorage(t)) === null || r === void 0 || r.set(Py, JSON.stringify(s))) : typeof s[e] == "number" && (delete s[e], (o = this.getStorage(t)) === null || o === void 0 || o.set(Py, JSON.stringify(s)));
  }
  get workspaceKeyTargets() {
    return this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(
      1
      /* WORKSPACE */
    )), this._workspaceKeyTargets;
  }
  get globalKeyTargets() {
    return this._globalKeyTargets || (this._globalKeyTargets = this.loadKeyTargets(
      0
      /* GLOBAL */
    )), this._globalKeyTargets;
  }
  getKeyTargets(e) {
    return e === 0 ? this.globalKeyTargets : this.workspaceKeyTargets;
  }
  loadKeyTargets(e) {
    const t = this.get(Py, e);
    if (t)
      try {
        return JSON.parse(t);
      } catch {
      }
    return /* @__PURE__ */ Object.create(null);
  }
}
V0.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
class gme extends V0 {
  constructor() {
    super(), this.globalStorage = new d_(new LW()), this.workspaceStorage = new d_(new LW()), this._register(this.workspaceStorage.onDidChangeStorage((e) => this.emitDidChangeValue(1, e))), this._register(this.globalStorage.onDidChangeStorage((e) => this.emitDidChangeValue(0, e)));
  }
  getStorage(e) {
    return e === 0 ? this.globalStorage : this.workspaceStorage;
  }
}
var A7 = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Cw = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let pO = class {
  constructor(e) {
    this._commandService = e;
  }
  /**
   * Create a new menu for the given menu identifier. A menu sends events when it's entries
   * have changed (placement, enablement, checked-state). By default it does send events for
   * sub menu entries. That is more expensive and must be explicitly enabled with the
   * `emitEventsForSubmenuChanges` flag.
   */
  createMenu(e, t, i = !1) {
    return new gO(e, i, this._commandService, t, this);
  }
};
pO = A7([
  Cw(0, Ko)
], pO);
let gO = class Wf {
  constructor(e, t, i, r, o) {
    this._id = e, this._fireEventsForSubmenuChanges = t, this._commandService = i, this._contextKeyService = r, this._menuService = o, this._dispoables = new ht(), this._onDidChange = new j(), this.onDidChange = this._onDidChange.event, this._menuGroups = [], this._contextKeys = /* @__PURE__ */ new Set(), this._build();
    const s = new to(() => this._build(), 50);
    this._dispoables.add(s), this._dispoables.add(dv.onDidChangeMenu((l) => {
      l.has(e) && s.schedule();
    }));
    const a = new to(() => this._onDidChange.fire(this), 50);
    this._dispoables.add(a), this._dispoables.add(r.onDidChangeContext((l) => {
      l.affectsSome(this._contextKeys) && a.schedule();
    }));
  }
  dispose() {
    this._dispoables.dispose(), this._onDidChange.dispose();
  }
  _build() {
    this._menuGroups.length = 0, this._contextKeys.clear();
    const e = dv.getMenuItems(this._id);
    let t;
    e.sort(Wf._compareMenuItems);
    for (let i of e) {
      const r = i.group || "";
      (!t || t[0] !== r) && (t = [r, []], this._menuGroups.push(t)), t[1].push(i), this._collectContextKeys(i);
    }
    this._onDidChange.fire(this);
  }
  _collectContextKeys(e) {
    if (Wf._fillInKbExprKeys(e.when, this._contextKeys), Gm(e)) {
      if (e.command.precondition && Wf._fillInKbExprKeys(e.command.precondition, this._contextKeys), e.command.toggled) {
        const t = e.command.toggled.condition || e.command.toggled;
        Wf._fillInKbExprKeys(t, this._contextKeys);
      }
    } else
      this._fireEventsForSubmenuChanges && dv.getMenuItems(e.submenu).forEach(this._collectContextKeys, this);
  }
  getActions(e) {
    const t = [];
    for (let i of this._menuGroups) {
      const [r, o] = i, s = [];
      for (const a of o)
        if (this._contextKeyService.contextMatchesRules(a.when)) {
          const l = Gm(a) ? new NT(a.command, a.alt, e, this._contextKeyService, this._commandService) : new Mae(a, this._menuService, this._contextKeyService, e);
          s.push(l);
        }
      s.length > 0 && t.push([r, s]);
    }
    return t;
  }
  static _fillInKbExprKeys(e, t) {
    if (e)
      for (let i of e.keys())
        t.add(i);
  }
  static _compareMenuItems(e, t) {
    let i = e.group, r = t.group;
    if (i !== r) {
      if (i) {
        if (!r)
          return -1;
      } else
        return 1;
      if (i === "navigation")
        return -1;
      if (r === "navigation")
        return 1;
      let a = i.localeCompare(r);
      if (a !== 0)
        return a;
    }
    let o = e.order || 0, s = t.order || 0;
    return o < s ? -1 : o > s ? 1 : Wf._compareTitles(Gm(e) ? e.command.title : e.title, Gm(t) ? t.command.title : t.title);
  }
  static _compareTitles(e, t) {
    const i = typeof e == "string" ? e : e.original, r = typeof t == "string" ? t : t.original;
    return i.localeCompare(r);
  }
};
gO = A7([
  Cw(2, Ko),
  Cw(3, Ti),
  Cw(4, V5)
], gO);
var mme = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, RW = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
function Fm(n) {
  return n.toString();
}
class vme extends ge {
  constructor(e) {
    super(), this.model = e, this._markersData = /* @__PURE__ */ new Map(), this._register(Ri(() => {
      this.model.deltaDecorations([...this._markersData.keys()], []), this._markersData.clear();
    }));
  }
  update(e, t) {
    const i = [...this._markersData.keys()];
    this._markersData.clear();
    const r = this.model.deltaDecorations(i, t);
    for (let o = 0; o < r.length; o++)
      this._markersData.set(r[o], e[o]);
    return i.length !== 0 || r.length !== 0;
  }
  getMarker(e) {
    return this._markersData.get(e.id);
  }
}
let mO = class extends ge {
  constructor(e, t) {
    super(), this._markerService = t, this._onDidChangeMarker = this._register(new j()), this._markerDecorations = /* @__PURE__ */ new Map(), e.getModels().forEach((i) => this._onModelAdded(i)), this._register(e.onModelAdded(this._onModelAdded, this)), this._register(e.onModelRemoved(this._onModelRemoved, this)), this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
  }
  dispose() {
    super.dispose(), this._markerDecorations.forEach((e) => e.dispose()), this._markerDecorations.clear();
  }
  getMarker(e, t) {
    const i = this._markerDecorations.get(Fm(e));
    return i && i.getMarker(t) || null;
  }
  _handleMarkerChange(e) {
    e.forEach((t) => {
      const i = this._markerDecorations.get(Fm(t));
      i && this._updateDecorations(i);
    });
  }
  _onModelAdded(e) {
    const t = new vme(e);
    this._markerDecorations.set(Fm(e.uri), t), this._updateDecorations(t);
  }
  _onModelRemoved(e) {
    const t = this._markerDecorations.get(Fm(e.uri));
    t && (t.dispose(), this._markerDecorations.delete(Fm(e.uri))), (e.uri.scheme === vi.inMemory || e.uri.scheme === vi.internal || e.uri.scheme === vi.vscode) && this._markerService && this._markerService.read({ resource: e.uri }).map((i) => i.owner).forEach((i) => this._markerService.remove(i, [e.uri]));
  }
  _updateDecorations(e) {
    const t = this._markerService.read({ resource: e.model.uri, take: 500 });
    let i = t.map((r) => ({
      range: this._createDecorationRange(e.model, r),
      options: this._createDecorationOption(r)
    }));
    e.update(t, i) && this._onDidChangeMarker.fire(e.model);
  }
  _createDecorationRange(e, t) {
    let i = V.lift(t);
    if (t.severity === vs.Hint && !this._hasMarkerTag(
      t,
      1
      /* Unnecessary */
    ) && !this._hasMarkerTag(
      t,
      2
      /* Deprecated */
    ) && (i = i.setEndPosition(i.startLineNumber, i.startColumn + 2)), i = e.validateRange(i), i.isEmpty()) {
      let r = e.getWordAtPosition(i.getStartPosition());
      if (r)
        i = new V(i.startLineNumber, r.startColumn, i.endLineNumber, r.endColumn);
      else {
        let o = e.getLineLastNonWhitespaceColumn(i.startLineNumber) || e.getLineMaxColumn(i.startLineNumber);
        o === 1 || (i.endColumn >= o ? i = new V(i.startLineNumber, o - 1, i.endLineNumber, o) : i = new V(i.startLineNumber, i.startColumn, i.endLineNumber, i.endColumn + 1));
      }
    } else if (t.endColumn === Number.MAX_VALUE && t.startColumn === 1 && i.startLineNumber === i.endLineNumber) {
      let r = e.getLineFirstNonWhitespaceColumn(t.startLineNumber);
      r < i.endColumn && (i = new V(i.startLineNumber, r, i.endLineNumber, i.endColumn), t.startColumn = r);
    }
    return i;
  }
  _createDecorationOption(e) {
    let t, i, r, o, s;
    switch (e.severity) {
      case vs.Hint:
        this._hasMarkerTag(
          e,
          2
          /* Deprecated */
        ) ? t = void 0 : this._hasMarkerTag(
          e,
          1
          /* Unnecessary */
        ) ? t = "squiggly-unnecessary" : t = "squiggly-hint", r = 0;
        break;
      case vs.Warning:
        t = "squiggly-warning", i = Rm(Vce), r = 20, s = {
          color: Rm(yce),
          position: Gp.Inline
        };
        break;
      case vs.Info:
        t = "squiggly-info", i = Rm(Bce), r = 10;
        break;
      case vs.Error:
      default:
        t = "squiggly-error", i = Rm(Wce), r = 30, s = {
          color: Rm(Cce),
          position: Gp.Inline
        };
        break;
    }
    return e.tags && (e.tags.indexOf(
      1
      /* Unnecessary */
    ) !== -1 && (o = "squiggly-inline-unnecessary"), e.tags.indexOf(
      2
      /* Deprecated */
    ) !== -1 && (o = "squiggly-inline-deprecated")), {
      description: "marker-decoration",
      stickiness: 1,
      className: t,
      showIfCollapsed: !0,
      overviewRuler: {
        color: i,
        position: Uv.Right
      },
      minimap: s,
      zIndex: r,
      inlineClassName: o
    };
  }
  _hasMarkerTag(e, t) {
    return e.tags ? e.tags.indexOf(t) >= 0 : !1;
  }
};
mO = mme([
  RW(0, ro),
  RW(1, P7)
], mO);
var _me = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, TW = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let vO = class extends ge {
  constructor(e, t) {
    super(), this._contextKeyService = e, this._configurationService = t, this._accessibilitySupport = 0, this._onDidChangeScreenReaderOptimized = new j(), this._accessibilityModeEnabledContext = Ode.bindTo(this._contextKeyService);
    const i = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
    this._register(this._configurationService.onDidChangeConfiguration((r) => {
      r.affectsConfiguration("editor.accessibilitySupport") && (i(), this._onDidChangeScreenReaderOptimized.fire());
    })), i(), this.onDidChangeScreenReaderOptimized(() => i());
  }
  get onDidChangeScreenReaderOptimized() {
    return this._onDidChangeScreenReaderOptimized.event;
  }
  isScreenReaderOptimized() {
    const e = this._configurationService.getValue("editor.accessibilitySupport");
    return e === "on" || e === "auto" && this._accessibilitySupport === 2;
  }
  getAccessibilitySupport() {
    return this._accessibilitySupport;
  }
};
vO = _me([
  TW(0, Ti),
  TW(1, mr)
], vO);
var Ay = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class Cme {
  constructor() {
    this.mapTextToType = /* @__PURE__ */ new Map(), this.findText = "";
  }
  writeText(e, t) {
    return Ay(this, void 0, void 0, function* () {
      if (t) {
        this.mapTextToType.set(t, e);
        return;
      }
      try {
        return yield navigator.clipboard.writeText(e);
      } catch (o) {
        console.error(o);
      }
      const i = document.activeElement, r = document.body.appendChild(Xe("textarea", { "aria-hidden": !0 }));
      r.style.height = "1px", r.style.width = "1px", r.style.position = "absolute", r.value = e, r.focus(), r.select(), document.execCommand("copy"), i instanceof HTMLElement && i.focus(), document.body.removeChild(r);
    });
  }
  readText(e) {
    return Ay(this, void 0, void 0, function* () {
      if (e)
        return this.mapTextToType.get(e) || "";
      try {
        return yield navigator.clipboard.readText();
      } catch (t) {
        return console.error(t), "";
      }
    });
  }
  readFindText() {
    return Ay(this, void 0, void 0, function* () {
      return this.findText;
    });
  }
  writeFindText(e) {
    return Ay(this, void 0, void 0, function* () {
      this.findText = e;
    });
  }
}
var yme = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, OW = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, My = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function Fy(n) {
  return n.scheme === vi.file ? n.fsPath : n.path;
}
let M7 = 0;
class ky {
  constructor(e, t, i, r, o, s, a) {
    this.id = ++M7, this.type = 0, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabel = t, this.strResource = i, this.resourceLabels = [this.resourceLabel], this.strResources = [this.strResource], this.groupId = r, this.groupOrder = o, this.sourceId = s, this.sourceOrder = a, this.isValid = !0;
  }
  setValid(e) {
    this.isValid = e;
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class xW {
  constructor(e, t) {
    this.resourceLabel = e, this.reason = t;
  }
}
class NW {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  createMessage() {
    const e = [], t = [];
    for (const [, r] of this.elements)
      (r.reason === 0 ? e : t).push(r.resourceLabel);
    let i = [];
    return e.length > 0 && i.push(w({ key: "externalRemoval", comment: ["{0} is a list of filenames"] }, "The following files have been closed and modified on disk: {0}.", e.join(", "))), t.length > 0 && i.push(w({ key: "noParallelUniverses", comment: ["{0} is a list of filenames"] }, "The following files have been modified in an incompatible way: {0}.", t.join(", "))), i.join(`
`);
  }
  get size() {
    return this.elements.size;
  }
  has(e) {
    return this.elements.has(e);
  }
  set(e, t) {
    this.elements.set(e, t);
  }
  delete(e) {
    return this.elements.delete(e);
  }
}
class wme {
  constructor(e, t, i, r, o, s, a) {
    this.id = ++M7, this.type = 1, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabels = t, this.strResources = i, this.groupId = r, this.groupOrder = o, this.sourceId = s, this.sourceOrder = a, this.removedResources = null, this.invalidatedResources = null;
  }
  canSplit() {
    return typeof this.actual.split == "function";
  }
  removeResource(e, t, i) {
    this.removedResources || (this.removedResources = new NW()), this.removedResources.has(t) || this.removedResources.set(t, new xW(e, i));
  }
  setValid(e, t, i) {
    i ? this.invalidatedResources && (this.invalidatedResources.delete(t), this.invalidatedResources.size === 0 && (this.invalidatedResources = null)) : (this.invalidatedResources || (this.invalidatedResources = new NW()), this.invalidatedResources.has(t) || this.invalidatedResources.set(t, new xW(
      e,
      0
      /* ExternalRemoval */
    )));
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class F7 {
  constructor(e, t) {
    this.resourceLabel = e, this.strResource = t, this._past = [], this._future = [], this.locked = !1, this.versionId = 1;
  }
  dispose() {
    for (const e of this._past)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* ExternalRemoval */
      );
    for (const e of this._future)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* ExternalRemoval */
      );
    this.versionId++;
  }
  toString() {
    let e = [];
    e.push(`* ${this.strResource}:`);
    for (let t = 0; t < this._past.length; t++)
      e.push(`   * [UNDO] ${this._past[t]}`);
    for (let t = this._future.length - 1; t >= 0; t--)
      e.push(`   * [REDO] ${this._future[t]}`);
    return e.join(`
`);
  }
  flushAllElements() {
    this._past = [], this._future = [], this.versionId++;
  }
  _setElementValidFlag(e, t) {
    e.type === 1 ? e.setValid(this.resourceLabel, this.strResource, t) : e.setValid(t);
  }
  setElementsValidFlag(e, t) {
    for (const i of this._past)
      t(i.actual) && this._setElementValidFlag(i, e);
    for (const i of this._future)
      t(i.actual) && this._setElementValidFlag(i, e);
  }
  pushElement(e) {
    for (const t of this._future)
      t.type === 1 && t.removeResource(
        this.resourceLabel,
        this.strResource,
        1
        /* NoParallelUniverses */
      );
    this._future = [], this._past.push(e), this.versionId++;
  }
  createSnapshot(e) {
    const t = [];
    for (let i = 0, r = this._past.length; i < r; i++)
      t.push(this._past[i].id);
    for (let i = this._future.length - 1; i >= 0; i--)
      t.push(this._future[i].id);
    return new Z3(e, t);
  }
  restoreSnapshot(e) {
    const t = e.elements.length;
    let i = !0, r = 0, o = -1;
    for (let a = 0, l = this._past.length; a < l; a++, r++) {
      const u = this._past[a];
      i && (r >= t || u.id !== e.elements[r]) && (i = !1, o = 0), !i && u.type === 1 && u.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* ExternalRemoval */
      );
    }
    let s = -1;
    for (let a = this._future.length - 1; a >= 0; a--, r++) {
      const l = this._future[a];
      i && (r >= t || l.id !== e.elements[r]) && (i = !1, s = a), !i && l.type === 1 && l.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* ExternalRemoval */
      );
    }
    o !== -1 && (this._past = this._past.slice(0, o)), s !== -1 && (this._future = this._future.slice(s + 1)), this.versionId++;
  }
  getElements() {
    const e = [], t = [];
    for (const i of this._past)
      e.push(i.actual);
    for (const i of this._future)
      t.push(i.actual);
    return { past: e, future: t };
  }
  getClosestPastElement() {
    return this._past.length === 0 ? null : this._past[this._past.length - 1];
  }
  getSecondClosestPastElement() {
    return this._past.length < 2 ? null : this._past[this._past.length - 2];
  }
  getClosestFutureElement() {
    return this._future.length === 0 ? null : this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  splitPastWorkspaceElement(e, t) {
    for (let i = this._past.length - 1; i >= 0; i--)
      if (this._past[i] === e) {
        t.has(this.strResource) ? this._past[i] = t.get(this.strResource) : this._past.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  splitFutureWorkspaceElement(e, t) {
    for (let i = this._future.length - 1; i >= 0; i--)
      if (this._future[i] === e) {
        t.has(this.strResource) ? this._future[i] = t.get(this.strResource) : this._future.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  moveBackward(e) {
    this._past.pop(), this._future.push(e), this.versionId++;
  }
  moveForward(e) {
    this._future.pop(), this._past.push(e), this.versionId++;
  }
}
class e1 {
  constructor(e) {
    this.editStacks = e, this._versionIds = [];
    for (let t = 0, i = this.editStacks.length; t < i; t++)
      this._versionIds[t] = this.editStacks[t].versionId;
  }
  isValid() {
    for (let e = 0, t = this.editStacks.length; e < t; e++)
      if (this._versionIds[e] !== this.editStacks[e].versionId)
        return !1;
    return !0;
  }
}
const k7 = new F7("", "");
k7.locked = !0;
let hS = class {
  constructor(e, t) {
    this._dialogService = e, this._notificationService = t, this._editStacks = /* @__PURE__ */ new Map(), this._uriComparisonKeyComputers = [];
  }
  getUriComparisonKey(e) {
    for (const t of this._uriComparisonKeyComputers)
      if (t[0] === e.scheme)
        return t[1].getComparisonKey(e);
    return e.toString();
  }
  _print(e) {
    console.log("------------------------------------"), console.log(`AFTER ${e}: `);
    let t = [];
    for (const i of this._editStacks)
      t.push(i[1].toString());
    console.log(t.join(`
`));
  }
  pushElement(e, t = Jp.None, i = Pl.None) {
    if (e.type === 0) {
      const r = Fy(e.resource), o = this.getUriComparisonKey(e.resource);
      this._pushElement(new ky(e, r, o, t.id, t.nextOrder(), i.id, i.nextOrder()));
    } else {
      const r = /* @__PURE__ */ new Set(), o = [], s = [];
      for (const a of e.resources) {
        const l = Fy(a), u = this.getUriComparisonKey(a);
        r.has(u) || (r.add(u), o.push(l), s.push(u));
      }
      o.length === 1 ? this._pushElement(new ky(e, o[0], s[0], t.id, t.nextOrder(), i.id, i.nextOrder())) : this._pushElement(new wme(e, o, s, t.id, t.nextOrder(), i.id, i.nextOrder()));
    }
  }
  _pushElement(e) {
    for (let t = 0, i = e.strResources.length; t < i; t++) {
      const r = e.resourceLabels[t], o = e.strResources[t];
      let s;
      this._editStacks.has(o) ? s = this._editStacks.get(o) : (s = new F7(r, o), this._editStacks.set(o, s)), s.pushElement(e);
    }
  }
  getLastElement(e) {
    const t = this.getUriComparisonKey(e);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      if (i.hasFutureElements())
        return null;
      const r = i.getClosestPastElement();
      return r ? r.actual : null;
    }
    return null;
  }
  _splitPastWorkspaceElement(e, t) {
    const i = e.actual.split(), r = /* @__PURE__ */ new Map();
    for (const o of i) {
      const s = Fy(o.resource), a = this.getUriComparisonKey(o.resource), l = new ky(o, s, a, 0, 0, 0, 0);
      r.set(l.strResource, l);
    }
    for (const o of e.strResources) {
      if (t && t.has(o))
        continue;
      this._editStacks.get(o).splitPastWorkspaceElement(e, r);
    }
  }
  _splitFutureWorkspaceElement(e, t) {
    const i = e.actual.split(), r = /* @__PURE__ */ new Map();
    for (const o of i) {
      const s = Fy(o.resource), a = this.getUriComparisonKey(o.resource), l = new ky(o, s, a, 0, 0, 0, 0);
      r.set(l.strResource, l);
    }
    for (const o of e.strResources) {
      if (t && t.has(o))
        continue;
      this._editStacks.get(o).splitFutureWorkspaceElement(e, r);
    }
  }
  removeElements(e) {
    const t = typeof e == "string" ? e : this.getUriComparisonKey(e);
    this._editStacks.has(t) && (this._editStacks.get(t).dispose(), this._editStacks.delete(t));
  }
  setElementsValidFlag(e, t, i) {
    const r = this.getUriComparisonKey(e);
    this._editStacks.has(r) && this._editStacks.get(r).setElementsValidFlag(t, i);
  }
  createSnapshot(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).createSnapshot(e) : new Z3(e, []);
  }
  restoreSnapshot(e) {
    const t = this.getUriComparisonKey(e.resource);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      i.restoreSnapshot(e), !i.hasPastElements() && !i.hasFutureElements() && (i.dispose(), this._editStacks.delete(t));
    }
  }
  getElements(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).getElements() : { past: [], future: [] };
  }
  _findClosestUndoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [r, o] of this._editStacks) {
      const s = o.getClosestPastElement();
      s && s.sourceId === e && (!t || s.sourceOrder > t.sourceOrder) && (t = s, i = r);
    }
    return [t, i];
  }
  canUndo(e) {
    if (e instanceof Pl) {
      const [, i] = this._findClosestUndoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasPastElements() : !1;
  }
  _onError(e, t) {
    Ni(e);
    for (const i of t.strResources)
      this.removeElements(i);
    this._notificationService.error(e);
  }
  _acquireLocks(e) {
    for (const t of e.editStacks)
      if (t.locked)
        throw new Error("Cannot acquire edit stack lock");
    for (const t of e.editStacks)
      t.locked = !0;
    return () => {
      for (const t of e.editStacks)
        t.locked = !1;
    };
  }
  _safeInvokeWithLocks(e, t, i, r, o) {
    const s = this._acquireLocks(i);
    let a;
    try {
      a = t();
    } catch (l) {
      return s(), r.dispose(), this._onError(l, e);
    }
    return a ? a.then(() => (s(), r.dispose(), o()), (l) => (s(), r.dispose(), this._onError(l, e))) : (s(), r.dispose(), o());
  }
  _invokeWorkspacePrepare(e) {
    return My(this, void 0, void 0, function* () {
      if (typeof e.actual.prepareUndoRedo > "u")
        return ge.None;
      const t = e.actual.prepareUndoRedo();
      return typeof t > "u" ? ge.None : t;
    });
  }
  _invokeResourcePrepare(e, t) {
    if (e.actual.type !== 1 || typeof e.actual.prepareUndoRedo > "u")
      return t(ge.None);
    const i = e.actual.prepareUndoRedo();
    return i ? $ie(i) ? t(i) : i.then((r) => t(r)) : t(ge.None);
  }
  _getAffectedEditStacks(e) {
    const t = [];
    for (const i of e.strResources)
      t.push(this._editStacks.get(i) || k7);
    return new e1(t);
  }
  _tryToSplitAndUndo(e, t, i, r) {
    if (t.canSplit())
      return this._splitPastWorkspaceElement(t, i), this._notificationService.warn(r), new Wy(this._undo(e, 0, !0));
    for (const o of t.strResources)
      this.removeElements(o);
    return this._notificationService.warn(r), new Wy();
  }
  _checkWorkspaceUndo(e, t, i, r) {
    if (t.removedResources)
      return this._tryToSplitAndUndo(e, t, t.removedResources, w({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (r && t.invalidatedResources)
      return this._tryToSplitAndUndo(e, t, t.invalidatedResources, w({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const o = [];
    for (const a of i.editStacks)
      a.getClosestPastElement() !== t && o.push(a.resourceLabel);
    if (o.length > 0)
      return this._tryToSplitAndUndo(e, t, null, w({ key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
    const s = [];
    for (const a of i.editStacks)
      a.locked && s.push(a.resourceLabel);
    return s.length > 0 ? this._tryToSplitAndUndo(e, t, null, w({ key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, s.join(", "))) : i.isValid() ? null : this._tryToSplitAndUndo(e, t, null, w({ key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceUndo(e, t, i) {
    const r = this._getAffectedEditStacks(t), o = this._checkWorkspaceUndo(
      e,
      t,
      r,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return o ? o.returnValue : this._confirmAndExecuteWorkspaceUndo(e, t, r, i);
  }
  _isPartOfUndoGroup(e) {
    if (!e.groupId)
      return !1;
    for (const [, t] of this._editStacks) {
      const i = t.getClosestPastElement();
      if (i) {
        if (i === e) {
          const r = t.getSecondClosestPastElement();
          if (r && r.groupId === e.groupId)
            return !0;
        }
        if (i.groupId === e.groupId)
          return !0;
      }
    }
    return !1;
  }
  _confirmAndExecuteWorkspaceUndo(e, t, i, r) {
    return My(this, void 0, void 0, function* () {
      if (t.canSplit() && !this._isPartOfUndoGroup(t)) {
        const a = yield this._dialogService.show(pn.Info, w("confirmWorkspace", "Would you like to undo '{0}' across all files?", t.label), [
          w({ key: "ok", comment: ["{0} denotes a number that is > 1"] }, "Undo in {0} Files", i.editStacks.length),
          w("nok", "Undo this File"),
          w("cancel", "Cancel")
        ], {
          cancelId: 2
        });
        if (a.choice === 2)
          return;
        if (a.choice === 1)
          return this._splitPastWorkspaceElement(t, null), this._undo(e, 0, !0);
        const l = this._checkWorkspaceUndo(
          e,
          t,
          i,
          /*invalidated resources will be checked after the prepare call*/
          !1
        );
        if (l)
          return l.returnValue;
        r = !0;
      }
      let o;
      try {
        o = yield this._invokeWorkspacePrepare(t);
      } catch (a) {
        return this._onError(a, t);
      }
      const s = this._checkWorkspaceUndo(
        e,
        t,
        i,
        /*now also check that there are no more invalidated resources*/
        !0
      );
      if (s)
        return o.dispose(), s.returnValue;
      for (const a of i.editStacks)
        a.moveBackward(t);
      return this._safeInvokeWithLocks(t, () => t.actual.undo(), i, o, () => this._continueUndoInGroup(t.groupId, r));
    });
  }
  _resourceUndo(e, t, i) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const r = w({ key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not undo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(r);
      return;
    }
    return this._invokeResourcePrepare(t, (r) => (e.moveBackward(t), this._safeInvokeWithLocks(t, () => t.actual.undo(), new e1([e]), r, () => this._continueUndoInGroup(t.groupId, i))));
  }
  _findClosestUndoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [r, o] of this._editStacks) {
      const s = o.getClosestPastElement();
      s && s.groupId === e && (!t || s.groupOrder > t.groupOrder) && (t = s, i = r);
    }
    return [t, i];
  }
  _continueUndoInGroup(e, t) {
    if (!e)
      return;
    const [, i] = this._findClosestUndoElementInGroup(e);
    if (i)
      return this._undo(i, 0, t);
  }
  undo(e) {
    if (e instanceof Pl) {
      const [, t] = this._findClosestUndoElementWithSource(e.id);
      return t ? this._undo(t, e.id, !1) : void 0;
    }
    return typeof e == "string" ? this._undo(e, 0, !1) : this._undo(this.getUriComparisonKey(e), 0, !1);
  }
  _undo(e, t = 0, i) {
    if (!this._editStacks.has(e))
      return;
    const r = this._editStacks.get(e), o = r.getClosestPastElement();
    if (!o)
      return;
    if (o.groupId) {
      const [a, l] = this._findClosestUndoElementInGroup(o.groupId);
      if (o !== a && l)
        return this._undo(l, t, i);
    }
    if ((o.sourceId !== t || o.confirmBeforeUndo) && !i)
      return this._confirmAndContinueUndo(e, t, o);
    try {
      return o.type === 1 ? this._workspaceUndo(e, o, i) : this._resourceUndo(r, o, i);
    } finally {
    }
  }
  _confirmAndContinueUndo(e, t, i) {
    return My(this, void 0, void 0, function* () {
      if ((yield this._dialogService.show(pn.Info, w("confirmDifferentSource", "Would you like to undo '{0}'?", i.label), [
        w("confirmDifferentSource.ok", "Undo"),
        w("cancel", "Cancel")
      ], {
        cancelId: 1
      })).choice !== 1)
        return this._undo(e, t, !0);
    });
  }
  _findClosestRedoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [r, o] of this._editStacks) {
      const s = o.getClosestFutureElement();
      s && s.sourceId === e && (!t || s.sourceOrder < t.sourceOrder) && (t = s, i = r);
    }
    return [t, i];
  }
  canRedo(e) {
    if (e instanceof Pl) {
      const [, i] = this._findClosestRedoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasFutureElements() : !1;
  }
  _tryToSplitAndRedo(e, t, i, r) {
    if (t.canSplit())
      return this._splitFutureWorkspaceElement(t, i), this._notificationService.warn(r), new Wy(this._redo(e));
    for (const o of t.strResources)
      this.removeElements(o);
    return this._notificationService.warn(r), new Wy();
  }
  _checkWorkspaceRedo(e, t, i, r) {
    if (t.removedResources)
      return this._tryToSplitAndRedo(e, t, t.removedResources, w({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (r && t.invalidatedResources)
      return this._tryToSplitAndRedo(e, t, t.invalidatedResources, w({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const o = [];
    for (const a of i.editStacks)
      a.getClosestFutureElement() !== t && o.push(a.resourceLabel);
    if (o.length > 0)
      return this._tryToSplitAndRedo(e, t, null, w({ key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
    const s = [];
    for (const a of i.editStacks)
      a.locked && s.push(a.resourceLabel);
    return s.length > 0 ? this._tryToSplitAndRedo(e, t, null, w({ key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, s.join(", "))) : i.isValid() ? null : this._tryToSplitAndRedo(e, t, null, w({ key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceRedo(e, t) {
    const i = this._getAffectedEditStacks(t), r = this._checkWorkspaceRedo(
      e,
      t,
      i,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return r ? r.returnValue : this._executeWorkspaceRedo(e, t, i);
  }
  _executeWorkspaceRedo(e, t, i) {
    return My(this, void 0, void 0, function* () {
      let r;
      try {
        r = yield this._invokeWorkspacePrepare(t);
      } catch (s) {
        return this._onError(s, t);
      }
      const o = this._checkWorkspaceRedo(
        e,
        t,
        i,
        /*now also check that there are no more invalidated resources*/
        !0
      );
      if (o)
        return r.dispose(), o.returnValue;
      for (const s of i.editStacks)
        s.moveForward(t);
      return this._safeInvokeWithLocks(t, () => t.actual.redo(), i, r, () => this._continueRedoInGroup(t.groupId));
    });
  }
  _resourceRedo(e, t) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const i = w({ key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not redo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(i);
      return;
    }
    return this._invokeResourcePrepare(t, (i) => (e.moveForward(t), this._safeInvokeWithLocks(t, () => t.actual.redo(), new e1([e]), i, () => this._continueRedoInGroup(t.groupId))));
  }
  _findClosestRedoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [r, o] of this._editStacks) {
      const s = o.getClosestFutureElement();
      s && s.groupId === e && (!t || s.groupOrder < t.groupOrder) && (t = s, i = r);
    }
    return [t, i];
  }
  _continueRedoInGroup(e) {
    if (!e)
      return;
    const [, t] = this._findClosestRedoElementInGroup(e);
    if (t)
      return this._redo(t);
  }
  redo(e) {
    if (e instanceof Pl) {
      const [, t] = this._findClosestRedoElementWithSource(e.id);
      return t ? this._redo(t) : void 0;
    }
    return typeof e == "string" ? this._redo(e) : this._redo(this.getUriComparisonKey(e));
  }
  _redo(e) {
    if (!this._editStacks.has(e))
      return;
    const t = this._editStacks.get(e), i = t.getClosestFutureElement();
    if (i) {
      if (i.groupId) {
        const [r, o] = this._findClosestRedoElementInGroup(i.groupId);
        if (i !== r && o)
          return this._redo(o);
      }
      try {
        return i.type === 1 ? this._workspaceRedo(e, i) : this._resourceRedo(t, i);
      } finally {
      }
    }
  }
};
hS = yme([
  OW(0, _7),
  OW(1, tl)
], hS);
class Wy {
  constructor(e) {
    this.returnValue = e;
  }
}
A3(gI, hS);
const bme = { ctrlCmd: !1, alt: !1 };
var f_;
(function(n) {
  n[n.Blur = 1] = "Blur", n[n.Gesture = 2] = "Gesture", n[n.Other = 3] = "Other";
})(f_ || (f_ = {}));
var Aa;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.FIRST = 1] = "FIRST", n[n.SECOND = 2] = "SECOND", n[n.LAST = 3] = "LAST";
})(Aa || (Aa = {}));
const IW = new vG(() => {
  const n = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" });
  return {
    collator: n,
    collatorIsNumeric: n.resolvedOptions().numeric
  };
});
function Sme(n, e, t = !1) {
  const i = n || "", r = e || "", o = IW.value.collator.compare(i, r);
  return IW.value.collatorIsNumeric && o === 0 && i !== r ? i < r ? -1 : 1 : o;
}
function Eme(n, e, t) {
  const i = n.toLowerCase(), r = e.toLowerCase(), o = Lme(n, e, t);
  if (o)
    return o;
  const s = i.endsWith(t), a = r.endsWith(t);
  if (s !== a)
    return s ? -1 : 1;
  const l = Sme(i, r);
  return l !== 0 ? l : i.localeCompare(r);
}
function Lme(n, e, t) {
  const i = n.toLowerCase(), r = e.toLowerCase(), o = i.startsWith(t), s = r.startsWith(t);
  if (o !== s)
    return o ? -1 : 1;
  if (o && s) {
    if (i.length < r.length)
      return -1;
    if (i.length > r.length)
      return 1;
  }
  return 0;
}
const Dme = new RegExp(`(\\\\)?\\$\\((${Vo.iconNameExpression}(?:${Vo.iconModifierExpression})?)\\)`, "g");
function Ev(n) {
  const e = new Array();
  let t, i = 0, r = 0;
  for (; (t = Dme.exec(n)) !== null; ) {
    r = t.index || 0, e.push(n.substring(i, r)), i = (t.index || 0) + t[0].length;
    const [, o, s] = t;
    e.push(o ? `$(${s})` : Rme({ id: s }));
  }
  return i < n.length && e.push(n.substring(i)), e;
}
function Rme(n) {
  const e = Xe("span");
  return e.classList.add(...Vo.asClassNameArray(n)), e;
}
class Bd {
  constructor(e, t) {
    this.supportIcons = t, this.text = "", this.title = "", this.highlights = [], this.didEverRender = !1, this.domNode = document.createElement("span"), this.domNode.className = "monaco-highlighted-label", e.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(e, t = [], i = "", r) {
    e || (e = ""), r && (e = Bd.escapeNewLines(e, t)), !(this.didEverRender && this.text === e && this.title === i && Hu(this.highlights, t)) && (this.text = e, this.title = i, this.highlights = t, this.render());
  }
  render() {
    const e = [];
    let t = 0;
    for (const i of this.highlights) {
      if (i.end === i.start)
        continue;
      if (t < i.start) {
        const s = this.text.substring(t, i.start);
        e.push(Xe("span", void 0, ...this.supportIcons ? Ev(s) : [s])), t = i.end;
      }
      const r = this.text.substring(i.start, i.end), o = Xe("span.highlight", void 0, ...this.supportIcons ? Ev(r) : [r]);
      i.extraClasses && o.classList.add(i.extraClasses), e.push(o), t = i.end;
    }
    if (t < this.text.length) {
      const i = this.text.substring(t);
      e.push(Xe("span", void 0, ...this.supportIcons ? Ev(i) : [i]));
    }
    KS(this.domNode, ...e), this.title ? this.domNode.title = this.title : this.domNode.removeAttribute("title"), this.didEverRender = !0;
  }
  static escapeNewLines(e, t) {
    let i = 0, r = 0;
    return e.replace(/\r\n|\r|\n/g, (o, s) => {
      r = o === `\r
` ? -1 : 0, s += i;
      for (const a of t)
        a.end <= s || (a.start >= s && (a.start += r), a.end >= s && (a.end += r));
      return i += r, "";
    });
  }
}
var _O = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function Tme(n, e) {
  Za(e) ? n.title = e : e != null && e.markdownNotSupportedFallback ? n.title = e.markdownNotSupportedFallback : n.removeAttribute("title");
}
function Ome(n, e, t) {
  if (!t)
    return;
  const i = xme(t);
  let r, o, s = !1, a, l;
  const u = new Er(e, Be.MOUSE_OVER, !0);
  return u.event((c) => {
    if (s)
      return;
    a = new uh();
    function h(_) {
      const m = _.type === Be.MOUSE_DOWN;
      m && (l == null || l.dispose(), l = void 0), (m || _.fromElement === e) && (s = !1, r = void 0, a.dispose(!0), d.dispose(), f.dispose());
    }
    const d = new Er(e, Be.MOUSE_LEAVE, !0);
    d.event(h);
    const f = new Er(e, Be.MOUSE_DOWN, !0);
    f.event(h), s = !0;
    function p(_) {
      o = _.x;
    }
    const g = new Er(e, Be.MOUSE_MOVE, !0);
    g.event(p), setTimeout(() => _O(this, void 0, void 0, function* () {
      var _;
      if (s && i && !r) {
        const m = {
          targetElements: [e],
          dispose: () => {
          }
        };
        r = {
          text: w("iconLabel.loading", "Loading..."),
          target: m,
          hoverPosition: 2
          /* BELOW */
        }, l = PW(r, o, n, s);
        const v = (_ = yield i(a.token)) !== null && _ !== void 0 ? _ : Za(t) ? void 0 : t.markdownNotSupportedFallback;
        v ? (r = {
          text: v,
          target: m,
          showPointer: n.placement === "element",
          hoverPosition: 2
          /* BELOW */
        }, l = PW(r, o, n, s)) : l && (l.dispose(), l = void 0);
      }
      g.dispose();
    }), n.delay);
  }), u;
}
function xme(n) {
  if (Za(n))
    return () => _O(this, void 0, void 0, function* () {
      return n;
    });
  if (sv(n.markdown))
    return n.markdown;
  {
    const e = n.markdown;
    return () => _O(this, void 0, void 0, function* () {
      return e;
    });
  }
}
function PW(n, e, t, i) {
  if (n && i)
    return e !== void 0 && (t.placement === void 0 || t.placement === "mouse") && (n.target.x = e + 10), t.showHover(n);
}
class t1 {
  constructor(e) {
    this._element = e;
  }
  get element() {
    return this._element;
  }
  set textContent(e) {
    this.disposed || e === this._textContent || (this._textContent = e, this._element.textContent = e);
  }
  set className(e) {
    this.disposed || e === this._className || (this._className = e, this._element.className = e);
  }
  set empty(e) {
    this.disposed || e === this._empty || (this._empty = e, this._element.style.marginLeft = e ? "0" : "");
  }
  dispose() {
    this.disposed = !0;
  }
}
class Nme extends ge {
  constructor(e, t) {
    super(), this.customHovers = /* @__PURE__ */ new Map(), this.domNode = this._register(new t1(Ie(e, Xe(".monaco-icon-label")))), this.labelContainer = Ie(this.domNode.element, Xe(".monaco-icon-label-container"));
    const i = Ie(this.labelContainer, Xe("span.monaco-icon-name-container"));
    this.descriptionContainer = this._register(new t1(Ie(this.labelContainer, Xe("span.monaco-icon-description-container")))), t != null && t.supportHighlights || t != null && t.supportIcons ? this.nameNode = new Ame(i, !!t.supportIcons) : this.nameNode = new Ime(i), t != null && t.supportDescriptionHighlights ? this.descriptionNodeFactory = () => new Bd(Ie(this.descriptionContainer.element, Xe("span.label-description")), !!t.supportIcons) : this.descriptionNodeFactory = () => this._register(new t1(Ie(this.descriptionContainer.element, Xe("span.label-description")))), this.hoverDelegate = t == null ? void 0 : t.hoverDelegate;
  }
  setLabel(e, t, i) {
    const r = ["monaco-icon-label"];
    i && (i.extraClasses && r.push(...i.extraClasses), i.italic && r.push("italic"), i.strikethrough && r.push("strikethrough")), this.domNode.className = r.join(" "), this.setupHover(this.labelContainer, i == null ? void 0 : i.title), this.nameNode.setLabel(e, i), (t || this.descriptionNode) && (this.descriptionNode || (this.descriptionNode = this.descriptionNodeFactory()), this.descriptionNode instanceof Bd ? (this.descriptionNode.set(t || "", i ? i.descriptionMatches : void 0), this.setupHover(this.descriptionNode.element, i == null ? void 0 : i.descriptionTitle)) : (this.descriptionNode.textContent = t || "", this.setupHover(this.descriptionNode.element, (i == null ? void 0 : i.descriptionTitle) || ""), this.descriptionNode.empty = !t));
  }
  setupHover(e, t) {
    const i = this.customHovers.get(e);
    if (i && (i.dispose(), this.customHovers.delete(e)), !t) {
      e.removeAttribute("title");
      return;
    }
    if (!this.hoverDelegate)
      Tme(e, t);
    else {
      const r = Ome(this.hoverDelegate, e, t);
      r && this.customHovers.set(e, r);
    }
  }
  dispose() {
    super.dispose();
    for (const e of this.customHovers.values())
      e.dispose();
    this.customHovers.clear();
  }
}
class Ime {
  constructor(e) {
    this.container = e, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && Hu(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = Ie(this.container, Xe("a.label-name", { id: t == null ? void 0 : t.domId }))), this.singleLabel.textContent = e;
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        for (let i = 0; i < e.length; i++) {
          const r = e[i], o = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${i}`;
          Ie(this.container, Xe("a.label-name", { id: o, "data-icon-label-count": e.length, "data-icon-label-index": i, role: "treeitem" }, r)), i < e.length - 1 && Ie(this.container, Xe("span.label-separator", void 0, (t == null ? void 0 : t.separator) || "/"));
        }
      }
  }
}
function Pme(n, e, t) {
  if (!t)
    return;
  let i = 0;
  return n.map((r) => {
    const o = { start: i, end: i + r.length }, s = t.map((a) => lr.intersect(o, a)).filter((a) => !lr.isEmpty(a)).map(({ start: a, end: l }) => ({ start: a - i, end: l - i }));
    return i = o.end + e.length, s;
  });
}
class Ame {
  constructor(e, t) {
    this.container = e, this.supportIcons = t, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && Hu(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = new Bd(Ie(this.container, Xe("a.label-name", { id: t == null ? void 0 : t.domId })), this.supportIcons)), this.singleLabel.set(e, t == null ? void 0 : t.matches, void 0, t == null ? void 0 : t.labelEscapeNewLines);
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        const i = (t == null ? void 0 : t.separator) || "/", r = Pme(e, i, t == null ? void 0 : t.matches);
        for (let o = 0; o < e.length; o++) {
          const s = e[o], a = r ? r[o] : void 0, l = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${o}`, u = Xe("a.label-name", { id: l, "data-icon-label-count": e.length, "data-icon-label-index": o, role: "treeitem" });
          new Bd(Ie(this.container, u), this.supportIcons).set(s, a, void 0, t == null ? void 0 : t.labelEscapeNewLines), o < e.length - 1 && Ie(u, Xe("span.label-separator", void 0, i));
        }
      }
  }
}
class W7 {
  constructor(e) {
    this._prefix = e, this._lastId = 0;
  }
  nextId() {
    return this._prefix + ++this._lastId;
  }
}
const mwe = new W7("id#"), i1 = {}, Mme = new W7("quick-input-button-icon-");
function CO(n) {
  if (!n)
    return;
  let e;
  const t = n.dark.toString();
  return i1[t] ? e = i1[t] : (e = Mme.nextId(), wF(`.${e}`, `background-image: ${Hv(n.light || n.dark)}`), wF(`.vs-dark .${e}, .hc-black .${e}`, `background-image: ${Hv(n.dark)}`), i1[t] = e), e;
}
const Vy = Xe;
class HI {
  constructor(e, t, i) {
    this.os = t, this.keyElements = /* @__PURE__ */ new Set(), this.options = i || /* @__PURE__ */ Object.create(null), this.labelBackground = this.options.keybindingLabelBackground, this.labelForeground = this.options.keybindingLabelForeground, this.labelBorder = this.options.keybindingLabelBorder, this.labelBottomBorder = this.options.keybindingLabelBottomBorder, this.labelShadow = this.options.keybindingLabelShadow, this.domNode = Ie(e, Vy(".monaco-keybinding")), this.didEverRender = !1, e.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(e, t) {
    this.didEverRender && this.keybinding === e && HI.areSame(this.matches, t) || (this.keybinding = e, this.matches = t, this.render());
  }
  render() {
    if (this.clear(), this.keybinding) {
      let [e, t] = this.keybinding.getParts();
      e && this.renderPart(this.domNode, e, this.matches ? this.matches.firstPart : null), t && (Ie(this.domNode, Vy("span.monaco-keybinding-key-chord-separator", void 0, " ")), this.renderPart(this.domNode, t, this.matches ? this.matches.chordPart : null)), this.domNode.title = this.keybinding.getAriaLabel() || "";
    } else
      this.options && this.options.renderUnboundKeybindings && this.renderUnbound(this.domNode);
    this.applyStyles(), this.didEverRender = !0;
  }
  clear() {
    Ts(this.domNode), this.keyElements.clear();
  }
  renderPart(e, t, i) {
    const r = T5.modifierLabels[this.os];
    t.ctrlKey && this.renderKey(e, r.ctrlKey, !!(i != null && i.ctrlKey), r.separator), t.shiftKey && this.renderKey(e, r.shiftKey, !!(i != null && i.shiftKey), r.separator), t.altKey && this.renderKey(e, r.altKey, !!(i != null && i.altKey), r.separator), t.metaKey && this.renderKey(e, r.metaKey, !!(i != null && i.metaKey), r.separator);
    const o = t.keyLabel;
    o && this.renderKey(e, o, !!(i != null && i.keyCode), "");
  }
  renderKey(e, t, i, r) {
    Ie(e, this.createKeyElement(t, i ? ".highlight" : "")), r && Ie(e, Vy("span.monaco-keybinding-key-separator", void 0, r));
  }
  renderUnbound(e) {
    Ie(e, this.createKeyElement(w("unbound", "Unbound")));
  }
  createKeyElement(e, t = "") {
    const i = Vy("span.monaco-keybinding-key" + t, void 0, e);
    return this.keyElements.add(i), i;
  }
  style(e) {
    this.labelBackground = e.keybindingLabelBackground, this.labelForeground = e.keybindingLabelForeground, this.labelBorder = e.keybindingLabelBorder, this.labelBottomBorder = e.keybindingLabelBottomBorder, this.labelShadow = e.keybindingLabelShadow, this.applyStyles();
  }
  applyStyles() {
    var e;
    if (this.element) {
      for (const t of this.keyElements)
        this.labelBackground && (t.style.backgroundColor = (e = this.labelBackground) === null || e === void 0 ? void 0 : e.toString()), this.labelBorder && (t.style.borderColor = this.labelBorder.toString()), this.labelBottomBorder && (t.style.borderBottomColor = this.labelBottomBorder.toString()), this.labelShadow && (t.style.boxShadow = `inset 0 -1px 0 ${this.labelShadow}`);
      this.labelForeground && (this.element.style.color = this.labelForeground.toString());
    }
  }
  static areSame(e, t) {
    return e === t || !e && !t ? !0 : !!e && !!t && Hu(e.firstPart, t.firstPart) && Hu(e.chordPart, t.chordPart);
  }
}
var V7 = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Fme = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
const Dl = Xe;
class kme {
  constructor(e) {
    this.hidden = !1, this._onChecked = new j(), this.onChecked = this._onChecked.event, Object.assign(this, e);
  }
  get checked() {
    return !!this._checked;
  }
  set checked(e) {
    e !== this._checked && (this._checked = e, this._onChecked.fire(e));
  }
  dispose() {
    this._onChecked.dispose();
  }
}
class Z_ {
  get templateId() {
    return Z_.ID;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    t.toDisposeElement = [], t.toDisposeTemplate = [], t.entry = Ie(e, Dl(".quick-input-list-entry"));
    const i = Ie(t.entry, Dl("label.quick-input-list-label"));
    t.toDisposeTemplate.push(Jr(i, Be.CLICK, (u) => {
      t.checkbox.offsetParent || u.preventDefault();
    })), t.checkbox = Ie(i, Dl("input.quick-input-list-checkbox")), t.checkbox.type = "checkbox", t.toDisposeTemplate.push(Jr(t.checkbox, Be.CHANGE, (u) => {
      t.element.checked = t.checkbox.checked;
    }));
    const r = Ie(i, Dl(".quick-input-list-rows")), o = Ie(r, Dl(".quick-input-list-row")), s = Ie(r, Dl(".quick-input-list-row"));
    t.label = new Nme(o, { supportHighlights: !0, supportDescriptionHighlights: !0, supportIcons: !0 });
    const a = Ie(o, Dl(".quick-input-list-entry-keybinding"));
    t.keybinding = new HI(a, Ga);
    const l = Ie(s, Dl(".quick-input-list-label-meta"));
    return t.detail = new Bd(l, !0), t.separator = Ie(t.entry, Dl(".quick-input-list-separator")), t.actionBar = new Qp(t.entry), t.actionBar.domNode.classList.add("quick-input-list-entry-action-bar"), t.toDisposeTemplate.push(t.actionBar), t;
  }
  renderElement(e, t, i) {
    i.toDisposeElement = yi(i.toDisposeElement), i.element = e, i.checkbox.checked = e.checked, i.toDisposeElement.push(e.onChecked((u) => i.checkbox.checked = u));
    const { labelHighlights: r, descriptionHighlights: o, detailHighlights: s } = e, a = /* @__PURE__ */ Object.create(null);
    a.matches = r || [], a.descriptionTitle = e.saneDescription, a.descriptionMatches = o || [], a.extraClasses = e.item.iconClasses, a.italic = e.item.italic, a.strikethrough = e.item.strikethrough, i.label.setLabel(e.saneLabel, e.saneDescription, a), i.keybinding.set(e.item.keybinding), i.detail.set(e.saneDetail, s), e.separator && e.separator.label ? (i.separator.textContent = e.separator.label, i.separator.style.display = "") : i.separator.style.display = "none", i.entry.classList.toggle("quick-input-list-separator-border", !!e.separator), i.actionBar.clear();
    const l = e.item.buttons;
    l && l.length ? (i.actionBar.push(l.map((u, c) => {
      let h = u.iconClass || (u.iconPath ? CO(u.iconPath) : void 0);
      u.alwaysVisible && (h = h ? `${h} always-visible` : "always-visible");
      const d = new Wl(`id-${c}`, "", h, !0, () => Fme(this, void 0, void 0, function* () {
        e.fireButtonTriggered({
          button: u,
          item: e.item
        });
      }));
      return d.tooltip = u.tooltip || "", d;
    }), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions");
  }
  disposeElement(e, t, i) {
    i.toDisposeElement = yi(i.toDisposeElement);
  }
  disposeTemplate(e) {
    e.toDisposeElement = yi(e.toDisposeElement), e.toDisposeTemplate = yi(e.toDisposeTemplate);
  }
}
Z_.ID = "listelement";
class Wme {
  getHeight(e) {
    return e.saneDetail ? 44 : 22;
  }
  getTemplateId(e) {
    return Z_.ID;
  }
}
var $i;
(function(n) {
  n[n.First = 1] = "First", n[n.Second = 2] = "Second", n[n.Last = 3] = "Last", n[n.Next = 4] = "Next", n[n.Previous = 5] = "Previous", n[n.NextPage = 6] = "NextPage", n[n.PreviousPage = 7] = "PreviousPage";
})($i || ($i = {}));
class GI {
  constructor(e, t, i) {
    this.parent = e, this.inputElements = [], this.elements = [], this.elementsToIndexes = /* @__PURE__ */ new Map(), this.matchOnDescription = !1, this.matchOnDetail = !1, this.matchOnLabel = !0, this.matchOnMeta = !0, this.sortByLabel = !0, this._onChangedAllVisibleChecked = new j(), this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event, this._onChangedCheckedCount = new j(), this.onChangedCheckedCount = this._onChangedCheckedCount.event, this._onChangedVisibleCount = new j(), this.onChangedVisibleCount = this._onChangedVisibleCount.event, this._onChangedCheckedElements = new j(), this.onChangedCheckedElements = this._onChangedCheckedElements.event, this._onButtonTriggered = new j(), this.onButtonTriggered = this._onButtonTriggered.event, this._onKeyDown = new j(), this.onKeyDown = this._onKeyDown.event, this._onLeave = new j(), this.onLeave = this._onLeave.event, this._fireCheckedEvents = !0, this.elementDisposables = [], this.disposables = [], this.id = t, this.container = Ie(this.parent, Dl(".quick-input-list"));
    const r = new Wme(), o = new Bme();
    this.list = i.createList("QuickInput", this.container, r, [new Z_()], {
      identityProvider: { getId: (s) => s.saneLabel },
      setRowLineHeight: !1,
      multipleSelectionSupport: !1,
      horizontalScrolling: !1,
      accessibilityProvider: o
    }), this.list.getHTMLElement().id = t, this.disposables.push(this.list), this.disposables.push(this.list.onKeyDown((s) => {
      const a = new Ki(s);
      switch (a.keyCode) {
        case 10:
          this.toggleCheckbox();
          break;
        case 31:
          (Ft ? s.metaKey : s.ctrlKey) && this.list.setFocus(Ar(this.list.length));
          break;
        case 16:
          const l = this.list.getFocus();
          l.length === 1 && l[0] === 0 && this._onLeave.fire();
          break;
        case 18:
          const u = this.list.getFocus();
          u.length === 1 && u[0] === this.list.length - 1 && this._onLeave.fire();
          break;
      }
      this._onKeyDown.fire(a);
    })), this.disposables.push(this.list.onMouseDown((s) => {
      s.browserEvent.button !== 2 && s.browserEvent.preventDefault();
    })), this.disposables.push(ye(this.container, Be.CLICK, (s) => {
      (s.x || s.y) && this._onLeave.fire();
    })), this.disposables.push(this.list.onMouseMiddleClick((s) => {
      this._onLeave.fire();
    })), this.disposables.push(this.list.onContextMenu((s) => {
      typeof s.index == "number" && (s.browserEvent.preventDefault(), this.list.setSelection([s.index]));
    })), this.disposables.push(this._onChangedAllVisibleChecked, this._onChangedCheckedCount, this._onChangedVisibleCount, this._onChangedCheckedElements, this._onButtonTriggered, this._onLeave, this._onKeyDown);
  }
  get onDidChangeFocus() {
    return Ae.map(this.list.onDidChangeFocus, (e) => e.elements.map((t) => t.item));
  }
  get onDidChangeSelection() {
    return Ae.map(this.list.onDidChangeSelection, (e) => ({ items: e.elements.map((t) => t.item), event: e.browserEvent }));
  }
  getAllVisibleChecked() {
    return this.allVisibleChecked(this.elements, !1);
  }
  allVisibleChecked(e, t = !0) {
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i];
      if (!o.hidden)
        if (o.checked)
          t = !0;
        else
          return !1;
    }
    return t;
  }
  getCheckedCount() {
    let e = 0;
    const t = this.elements;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].checked && e++;
    return e;
  }
  getVisibleCount() {
    let e = 0;
    const t = this.elements;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].hidden || e++;
    return e;
  }
  setAllVisibleChecked(e) {
    try {
      this._fireCheckedEvents = !1, this.elements.forEach((t) => {
        t.hidden || (t.checked = e);
      });
    } finally {
      this._fireCheckedEvents = !0, this.fireCheckedEvents();
    }
  }
  setElements(e) {
    this.elementDisposables = yi(this.elementDisposables);
    const t = (i) => this.fireButtonTriggered(i);
    this.inputElements = e, this.elements = e.reduce((i, r, o) => {
      var s, a, l;
      if (r.type !== "separator") {
        const u = o && e[o - 1], c = r.label && r.label.replace(/\r?\n/g, " "), h = r.meta && r.meta.replace(/\r?\n/g, " "), d = r.description && r.description.replace(/\r?\n/g, " "), f = r.detail && r.detail.replace(/\r?\n/g, " "), p = r.ariaLabel || [c, d, f].map((g) => uoe(g)).filter((g) => !!g).join(", ");
        i.push(new kme({
          index: o,
          item: r,
          saneLabel: c,
          saneMeta: h,
          saneAriaLabel: p,
          saneDescription: d,
          saneDetail: f,
          labelHighlights: (s = r.highlights) === null || s === void 0 ? void 0 : s.label,
          descriptionHighlights: (a = r.highlights) === null || a === void 0 ? void 0 : a.description,
          detailHighlights: (l = r.highlights) === null || l === void 0 ? void 0 : l.detail,
          checked: !1,
          separator: u && u.type === "separator" ? u : void 0,
          fireButtonTriggered: t
        }));
      }
      return i;
    }, []), this.elementDisposables.push(...this.elements), this.elementDisposables.push(...this.elements.map((i) => i.onChecked(() => this.fireCheckedEvents()))), this.elementsToIndexes = this.elements.reduce((i, r, o) => (i.set(r.item, o), i), /* @__PURE__ */ new Map()), this.list.splice(0, this.list.length), this.list.splice(0, this.list.length, this.elements), this._onChangedVisibleCount.fire(this.elements.length);
  }
  getFocusedElements() {
    return this.list.getFocusedElements().map((e) => e.item);
  }
  setFocusedElements(e) {
    if (this.list.setFocus(e.filter((t) => this.elementsToIndexes.has(t)).map((t) => this.elementsToIndexes.get(t))), e.length > 0) {
      const t = this.list.getFocus()[0];
      typeof t == "number" && this.list.reveal(t);
    }
  }
  getActiveDescendant() {
    return this.list.getHTMLElement().getAttribute("aria-activedescendant");
  }
  setSelectedElements(e) {
    this.list.setSelection(e.filter((t) => this.elementsToIndexes.has(t)).map((t) => this.elementsToIndexes.get(t)));
  }
  getCheckedElements() {
    return this.elements.filter((e) => e.checked).map((e) => e.item);
  }
  setCheckedElements(e) {
    try {
      this._fireCheckedEvents = !1;
      const t = /* @__PURE__ */ new Set();
      for (const i of e)
        t.add(i);
      for (const i of this.elements)
        i.checked = t.has(i.item);
    } finally {
      this._fireCheckedEvents = !0, this.fireCheckedEvents();
    }
  }
  set enabled(e) {
    this.list.getHTMLElement().style.pointerEvents = e ? "" : "none";
  }
  focus(e) {
    if (!this.list.length)
      return;
    switch (e === $i.Next && this.list.getFocus()[0] === this.list.length - 1 && (e = $i.First), e === $i.Previous && this.list.getFocus()[0] === 0 && (e = $i.Last), e === $i.Second && this.list.length < 2 && (e = $i.First), e) {
      case $i.First:
        this.list.focusFirst();
        break;
      case $i.Second:
        this.list.focusNth(1);
        break;
      case $i.Last:
        this.list.focusLast();
        break;
      case $i.Next:
        this.list.focusNext();
        break;
      case $i.Previous:
        this.list.focusPrevious();
        break;
      case $i.NextPage:
        this.list.focusNextPage();
        break;
      case $i.PreviousPage:
        this.list.focusPreviousPage();
        break;
    }
    const t = this.list.getFocus()[0];
    typeof t == "number" && this.list.reveal(t);
  }
  clearFocus() {
    this.list.setFocus([]);
  }
  domFocus() {
    this.list.domFocus();
  }
  layout(e) {
    this.list.getHTMLElement().style.maxHeight = e ? `calc(${Math.floor(e / 44) * 44}px)` : "", this.list.layout();
  }
  filter(e) {
    if (!(this.sortByLabel || this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
      return this.list.layout(), !1;
    if (e = e.trim(), !e || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
      this.elements.forEach((i) => {
        i.labelHighlights = void 0, i.descriptionHighlights = void 0, i.detailHighlights = void 0, i.hidden = !1;
        const r = i.index && this.inputElements[i.index - 1];
        i.separator = r && r.type === "separator" ? r : void 0;
      });
    else {
      let i;
      this.elements.forEach((r) => {
        const o = this.matchOnLabel ? Kf(Iy(e, Ny(r.saneLabel))) : void 0, s = this.matchOnDescription ? Kf(Iy(e, Ny(r.saneDescription || ""))) : void 0, a = this.matchOnDetail ? Kf(Iy(e, Ny(r.saneDetail || ""))) : void 0, l = this.matchOnMeta ? Kf(Iy(e, Ny(r.saneMeta || ""))) : void 0;
        if (o || s || a || l ? (r.labelHighlights = o, r.descriptionHighlights = s, r.detailHighlights = a, r.hidden = !1) : (r.labelHighlights = void 0, r.descriptionHighlights = void 0, r.detailHighlights = void 0, r.hidden = !r.item.alwaysShow), r.separator = void 0, !this.sortByLabel) {
          const u = r.index && this.inputElements[r.index - 1];
          i = u && u.type === "separator" ? u : i, i && !r.hidden && (r.separator = i, i = void 0);
        }
      });
    }
    const t = this.elements.filter((i) => !i.hidden);
    if (this.sortByLabel && e) {
      const i = e.toLowerCase();
      t.sort((r, o) => Vme(r, o, i));
    }
    return this.elementsToIndexes = t.reduce((i, r, o) => (i.set(r.item, o), i), /* @__PURE__ */ new Map()), this.list.splice(0, this.list.length, t), this.list.setFocus([]), this.list.layout(), this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked()), this._onChangedVisibleCount.fire(t.length), !0;
  }
  toggleCheckbox() {
    try {
      this._fireCheckedEvents = !1;
      const e = this.list.getFocusedElements(), t = this.allVisibleChecked(e);
      for (const i of e)
        i.checked = !t;
    } finally {
      this._fireCheckedEvents = !0, this.fireCheckedEvents();
    }
  }
  display(e) {
    this.container.style.display = e ? "" : "none";
  }
  isDisplayed() {
    return this.container.style.display !== "none";
  }
  dispose() {
    this.elementDisposables = yi(this.elementDisposables), this.disposables = yi(this.disposables);
  }
  fireCheckedEvents() {
    this._fireCheckedEvents && (this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked()), this._onChangedCheckedCount.fire(this.getCheckedCount()), this._onChangedCheckedElements.fire(this.getCheckedElements()));
  }
  fireButtonTriggered(e) {
    this._onButtonTriggered.fire(e);
  }
  style(e) {
    this.list.style(e);
  }
}
V7([
  Wn
], GI.prototype, "onDidChangeFocus", null);
V7([
  Wn
], GI.prototype, "onDidChangeSelection", null);
function Vme(n, e, t) {
  const i = n.labelHighlights || [], r = e.labelHighlights || [];
  return i.length && !r.length ? -1 : !i.length && r.length ? 1 : i.length === 0 && r.length === 0 ? 0 : Eme(n.saneLabel, e.saneLabel, t);
}
class Bme {
  getWidgetAriaLabel() {
    return w("quickInput", "Quick Input");
  }
  getAriaLabel(e) {
    return e.saneAriaLabel;
  }
  getWidgetRole() {
    return "listbox";
  }
  getRole() {
    return "option";
  }
}
function Hme(n, e = {}) {
  const t = B7(e);
  return t.textContent = n, t;
}
function Gme(n, e = {}) {
  const t = B7(e);
  return H7(t, zme(n, !!e.renderCodeSegements), e.actionHandler, e.renderCodeSegements), t;
}
function B7(n) {
  const e = n.inline ? "span" : "div", t = document.createElement(e);
  return n.className && (t.className = n.className), t;
}
class Ume {
  constructor(e) {
    this.source = e, this.index = 0;
  }
  eos() {
    return this.index >= this.source.length;
  }
  next() {
    const e = this.peek();
    return this.advance(), e;
  }
  peek() {
    return this.source[this.index];
  }
  advance() {
    this.index++;
  }
}
function H7(n, e, t, i) {
  let r;
  if (e.type === 2)
    r = document.createTextNode(e.content || "");
  else if (e.type === 3)
    r = document.createElement("b");
  else if (e.type === 4)
    r = document.createElement("i");
  else if (e.type === 7 && i)
    r = document.createElement("code");
  else if (e.type === 5 && t) {
    const o = document.createElement("a");
    o.href = "#", t.disposeables.add(Jr(o, "click", (s) => {
      t.callback(String(e.index), s);
    })), r = o;
  } else
    e.type === 8 ? r = document.createElement("br") : e.type === 1 && (r = n);
  r && n !== r && n.appendChild(r), r && Array.isArray(e.children) && e.children.forEach((o) => {
    H7(r, o, t, i);
  });
}
function zme(n, e) {
  const t = {
    type: 1,
    children: []
  };
  let i = 0, r = t;
  const o = [], s = new Ume(n);
  for (; !s.eos(); ) {
    let a = s.next();
    const l = a === "\\" && yO(s.peek(), e) !== 0;
    if (l && (a = s.next()), !l && jme(a, e) && a === s.peek()) {
      s.advance(), r.type === 2 && (r = o.pop());
      const u = yO(a, e);
      if (r.type === u || r.type === 5 && u === 6)
        r = o.pop();
      else {
        const c = {
          type: u,
          children: []
        };
        u === 5 && (c.index = i, i++), r.children.push(c), o.push(r), r = c;
      }
    } else if (a === `
`)
      r.type === 2 && (r = o.pop()), r.children.push({
        type: 8
        /* NewLine */
      });
    else if (r.type !== 2) {
      const u = {
        type: 2,
        content: a
      };
      r.children.push(u), o.push(r), r = u;
    } else
      r.content += a;
  }
  return r.type === 2 && (r = o.pop()), t;
}
function jme(n, e) {
  return yO(n, e) !== 0;
}
function yO(n, e) {
  switch (n) {
    case "*":
      return 3;
    case "_":
      return 4;
    case "[":
      return 5;
    case "]":
      return 6;
    case "`":
      return e ? 7 : 0;
    default:
      return 0;
  }
}
class $me {
  constructor(e, t = 0, i = e.length, r = t - 1) {
    this.items = e, this.start = t, this.end = i, this.index = r;
  }
  current() {
    return this.index === this.start - 1 || this.index === this.end ? null : this.items[this.index];
  }
  next() {
    return this.index = Math.min(this.index + 1, this.end), this.current();
  }
  previous() {
    return this.index = Math.max(this.index - 1, this.start - 1), this.current();
  }
  first() {
    return this.index = this.start, this.current();
  }
  last() {
    return this.index = this.end - 1, this.current();
  }
}
class Kme {
  constructor(e = [], t = 10) {
    this._initialize(e), this._limit = t, this._onChange();
  }
  add(e) {
    this._history.delete(e), this._history.add(e), this._onChange();
  }
  next() {
    return this._currentPosition() !== this._elements.length - 1 ? this._navigator.next() : null;
  }
  previous() {
    return this._currentPosition() !== 0 ? this._navigator.previous() : null;
  }
  current() {
    return this._navigator.current();
  }
  first() {
    return this._navigator.first();
  }
  last() {
    return this._navigator.last();
  }
  has(e) {
    return this._history.has(e);
  }
  _onChange() {
    this._reduceToLimit();
    const e = this._elements;
    this._navigator = new $me(e, 0, e.length, e.length);
  }
  _reduceToLimit() {
    const e = this._elements;
    e.length > this._limit && this._initialize(e.slice(e.length - this._limit));
  }
  _currentPosition() {
    const e = this._navigator.current();
    return e ? this._elements.indexOf(e) : -1;
  }
  _initialize(e) {
    this._history = /* @__PURE__ */ new Set();
    for (const t of e)
      this._history.add(t);
  }
  get _elements() {
    const e = [];
    return this._history.forEach((t) => e.push(t)), e;
  }
}
const km = Xe, qme = {
  inputBackground: ee.fromHex("#3C3C3C"),
  inputForeground: ee.fromHex("#CCCCCC"),
  inputValidationInfoBorder: ee.fromHex("#55AAFF"),
  inputValidationInfoBackground: ee.fromHex("#063B49"),
  inputValidationWarningBorder: ee.fromHex("#B89500"),
  inputValidationWarningBackground: ee.fromHex("#352A05"),
  inputValidationErrorBorder: ee.fromHex("#BE1100"),
  inputValidationErrorBackground: ee.fromHex("#5A1D1D")
};
class G7 extends S0 {
  constructor(e, t, i) {
    var r;
    super(), this.state = "idle", this.maxHeight = Number.POSITIVE_INFINITY, this._onDidChange = this._register(new j()), this.onDidChange = this._onDidChange.event, this._onDidHeightChange = this._register(new j()), this.onDidHeightChange = this._onDidHeightChange.event, this.contextViewProvider = t, this.options = i || /* @__PURE__ */ Object.create(null), ch(this.options, qme, !1), this.message = null, this.placeholder = this.options.placeholder || "", this.tooltip = (r = this.options.tooltip) !== null && r !== void 0 ? r : this.placeholder || "", this.ariaLabel = this.options.ariaLabel || "", this.inputBackground = this.options.inputBackground, this.inputForeground = this.options.inputForeground, this.inputBorder = this.options.inputBorder, this.inputValidationInfoBorder = this.options.inputValidationInfoBorder, this.inputValidationInfoBackground = this.options.inputValidationInfoBackground, this.inputValidationInfoForeground = this.options.inputValidationInfoForeground, this.inputValidationWarningBorder = this.options.inputValidationWarningBorder, this.inputValidationWarningBackground = this.options.inputValidationWarningBackground, this.inputValidationWarningForeground = this.options.inputValidationWarningForeground, this.inputValidationErrorBorder = this.options.inputValidationErrorBorder, this.inputValidationErrorBackground = this.options.inputValidationErrorBackground, this.inputValidationErrorForeground = this.options.inputValidationErrorForeground, this.options.validationOptions && (this.validation = this.options.validationOptions.validation), this.element = Ie(e, km(".monaco-inputbox.idle"));
    let o = this.options.flexibleHeight ? "textarea" : "input", s = Ie(this.element, km(".ibwrapper"));
    if (this.input = Ie(s, km(o + ".input.empty")), this.input.setAttribute("autocorrect", "off"), this.input.setAttribute("autocapitalize", "off"), this.input.setAttribute("spellcheck", "false"), this.onfocus(this.input, () => this.element.classList.add("synthetic-focus")), this.onblur(this.input, () => this.element.classList.remove("synthetic-focus")), this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight == "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY, this.mirror = Ie(s, km("div.mirror")), this.mirror.innerText = "", this.scrollableElement = new R3(this.element, {
        vertical: 1
        /* Auto */
      }), this.options.flexibleWidth && (this.input.setAttribute("wrap", "off"), this.mirror.style.whiteSpace = "pre", this.mirror.style.wordWrap = "initial"), Ie(e, this.scrollableElement.getDomNode()), this._register(this.scrollableElement), this._register(this.scrollableElement.onScroll((l) => this.input.scrollTop = l.scrollTop));
      const a = Ae.filter(yt(document, "selectionchange"), () => {
        const l = document.getSelection();
        return (l == null ? void 0 : l.anchorNode) === s;
      });
      this._register(a(this.updateScrollDimensions, this)), this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else
      this.input.type = this.options.type || "text", this.input.setAttribute("wrap", "off");
    this.ariaLabel && this.input.setAttribute("aria-label", this.ariaLabel), this.placeholder && this.setPlaceHolder(this.placeholder), this.tooltip && this.setTooltip(this.tooltip), this.oninput(this.input, () => this.onValueChange()), this.onblur(this.input, () => this.onBlur()), this.onfocus(this.input, () => this.onFocus()), this.ignoreGesture(this.input), setTimeout(() => this.updateMirror(), 0), this.options.actions && (this.actionbar = this._register(new Qp(this.element)), this.actionbar.push(this.options.actions, { icon: !0, label: !1 })), this.applyStyles();
  }
  onBlur() {
    this._hideMessage();
  }
  onFocus() {
    this._showMessage();
  }
  setPlaceHolder(e) {
    this.placeholder = e, this.input.setAttribute("placeholder", e);
  }
  setTooltip(e) {
    this.tooltip = e, this.input.title = e;
  }
  setAriaLabel(e) {
    this.ariaLabel = e, e ? this.input.setAttribute("aria-label", this.ariaLabel) : this.input.removeAttribute("aria-label");
  }
  getAriaLabel() {
    return this.ariaLabel;
  }
  get inputElement() {
    return this.input;
  }
  get value() {
    return this.input.value;
  }
  set value(e) {
    this.input.value !== e && (this.input.value = e, this.onValueChange());
  }
  get height() {
    return typeof this.cachedHeight == "number" ? this.cachedHeight : YR(this.element);
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  hasFocus() {
    return document.activeElement === this.input;
  }
  select(e = null) {
    this.input.select(), e && (this.input.setSelectionRange(e.start, e.end), e.end === this.input.value.length && (this.input.scrollLeft = this.input.scrollWidth));
  }
  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }
  enable() {
    this.input.removeAttribute("disabled");
  }
  disable() {
    this.blur(), this.input.disabled = !0, this._hideMessage();
  }
  get width() {
    return qR(this.input);
  }
  set width(e) {
    if (this.options.flexibleHeight && this.options.flexibleWidth) {
      let t = 0;
      if (this.mirror) {
        const i = parseFloat(this.mirror.style.paddingLeft || "") || 0, r = parseFloat(this.mirror.style.paddingRight || "") || 0;
        t = i + r;
      }
      this.input.style.width = e - t + "px";
    } else
      this.input.style.width = e + "px";
    this.mirror && (this.mirror.style.width = e + "px");
  }
  set paddingRight(e) {
    this.options.flexibleHeight && this.options.flexibleWidth ? this.input.style.width = `calc(100% - ${e}px)` : this.input.style.paddingRight = e + "px", this.mirror && (this.mirror.style.paddingRight = e + "px");
  }
  updateScrollDimensions() {
    if (typeof this.cachedContentHeight != "number" || typeof this.cachedHeight != "number" || !this.scrollableElement)
      return;
    const e = this.cachedContentHeight, t = this.cachedHeight, i = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({ scrollHeight: e, height: t }), this.scrollableElement.setScrollPosition({ scrollTop: i });
  }
  showMessage(e, t) {
    this.message = e, this.element.classList.remove("idle"), this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add(this.classForType(e.type));
    const i = this.stylesForType(this.message.type);
    this.element.style.border = i.border ? `1px solid ${i.border}` : "", (this.hasFocus() || t) && this._showMessage();
  }
  hideMessage() {
    this.message = null, this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add("idle"), this._hideMessage(), this.applyStyles();
  }
  validate() {
    let e = null;
    return this.validation && (e = this.validation(this.value), e ? (this.inputElement.setAttribute("aria-invalid", "true"), this.showMessage(e)) : this.inputElement.hasAttribute("aria-invalid") && (this.inputElement.removeAttribute("aria-invalid"), this.hideMessage())), e == null ? void 0 : e.type;
  }
  stylesForType(e) {
    switch (e) {
      case 1:
        return { border: this.inputValidationInfoBorder, background: this.inputValidationInfoBackground, foreground: this.inputValidationInfoForeground };
      case 2:
        return { border: this.inputValidationWarningBorder, background: this.inputValidationWarningBackground, foreground: this.inputValidationWarningForeground };
      default:
        return { border: this.inputValidationErrorBorder, background: this.inputValidationErrorBackground, foreground: this.inputValidationErrorForeground };
    }
  }
  classForType(e) {
    switch (e) {
      case 1:
        return "info";
      case 2:
        return "warning";
      default:
        return "error";
    }
  }
  _showMessage() {
    if (!this.contextViewProvider || !this.message)
      return;
    let e, t = () => e.style.width = qR(this.element) + "px";
    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: 1,
      render: (r) => {
        if (!this.message)
          return null;
        e = Ie(r, km(".monaco-inputbox-container")), t();
        const o = {
          inline: !0,
          className: "monaco-inputbox-message"
        }, s = this.message.formatContent ? Gme(this.message.content, o) : Hme(this.message.content, o);
        s.classList.add(this.classForType(this.message.type));
        const a = this.stylesForType(this.message.type);
        return s.style.backgroundColor = a.background ? a.background.toString() : "", s.style.color = a.foreground ? a.foreground.toString() : "", s.style.border = a.border ? `1px solid ${a.border}` : "", Ie(e, s), null;
      },
      onHide: () => {
        this.state = "closed";
      },
      layout: t
    });
    let i;
    this.message.type === 3 ? i = w("alertErrorMessage", "Error: {0}", this.message.content) : this.message.type === 2 ? i = w("alertWarningMessage", "Warning: {0}", this.message.content) : i = w("alertInfoMessage", "Info: {0}", this.message.content), ed(i), this.state = "open";
  }
  _hideMessage() {
    this.contextViewProvider && (this.state === "open" && this.contextViewProvider.hideContextView(), this.state = "idle");
  }
  onValueChange() {
    this._onDidChange.fire(this.value), this.validate(), this.updateMirror(), this.input.classList.toggle("empty", !this.value), this.state === "open" && this.contextViewProvider && this.contextViewProvider.layout();
  }
  updateMirror() {
    if (!this.mirror)
      return;
    const e = this.value, i = e.charCodeAt(e.length - 1) === 10 ? " " : "";
    e + i ? this.mirror.textContent = e + i : this.mirror.innerText = "", this.layout();
  }
  style(e) {
    this.inputBackground = e.inputBackground, this.inputForeground = e.inputForeground, this.inputBorder = e.inputBorder, this.inputValidationInfoBackground = e.inputValidationInfoBackground, this.inputValidationInfoForeground = e.inputValidationInfoForeground, this.inputValidationInfoBorder = e.inputValidationInfoBorder, this.inputValidationWarningBackground = e.inputValidationWarningBackground, this.inputValidationWarningForeground = e.inputValidationWarningForeground, this.inputValidationWarningBorder = e.inputValidationWarningBorder, this.inputValidationErrorBackground = e.inputValidationErrorBackground, this.inputValidationErrorForeground = e.inputValidationErrorForeground, this.inputValidationErrorBorder = e.inputValidationErrorBorder, this.applyStyles();
  }
  applyStyles() {
    const e = this.inputBackground ? this.inputBackground.toString() : "", t = this.inputForeground ? this.inputForeground.toString() : "", i = this.inputBorder ? this.inputBorder.toString() : "";
    this.element.style.backgroundColor = e, this.element.style.color = t, this.input.style.backgroundColor = "inherit", this.input.style.color = t, this.element.style.borderWidth = i ? "1px" : "", this.element.style.borderStyle = i ? "solid" : "", this.element.style.borderColor = i;
  }
  layout() {
    if (!this.mirror)
      return;
    const e = this.cachedContentHeight;
    this.cachedContentHeight = YR(this.mirror), e !== this.cachedContentHeight && (this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight), this.input.style.height = this.cachedHeight + "px", this._onDidHeightChange.fire(this.cachedContentHeight));
  }
  insertAtCursor(e) {
    const t = this.inputElement, i = t.selectionStart, r = t.selectionEnd, o = t.value;
    i !== null && r !== null && (this.value = o.substr(0, i) + e + o.substr(r), t.setSelectionRange(i + 1, i + 1), this.layout());
  }
  dispose() {
    this._hideMessage(), this.message = null, this.actionbar && this.actionbar.dispose(), super.dispose();
  }
}
class vwe extends G7 {
  constructor(e, t, i) {
    super(e, t, i), this.history = new Kme(i.history, 100);
  }
  addToHistory() {
    this.value && this.value !== this.getCurrentValue() && this.history.add(this.value);
  }
  showNextValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getNextValue();
    e && (e = e === this.value ? this.getNextValue() : e), e && (this.value = e, OT(this.value));
  }
  showPreviousValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getPreviousValue();
    e && (e = e === this.value ? this.getPreviousValue() : e), e && (this.value = e, OT(this.value));
  }
  getCurrentValue() {
    let e = this.history.current();
    return e || (e = this.history.last(), this.history.next()), e;
  }
  getPreviousValue() {
    return this.history.previous() || this.history.first();
  }
  getNextValue() {
    return this.history.next() || this.history.last();
  }
}
const Yme = Xe;
class Xme extends ge {
  constructor(e) {
    super(), this.parent = e, this.onKeyDown = (t) => ye(this.inputBox.inputElement, Be.KEY_DOWN, (i) => {
      t(new Ki(i));
    }), this.onMouseDown = (t) => ye(this.inputBox.inputElement, Be.MOUSE_DOWN, (i) => {
      t(new ca(i));
    }), this.onDidChange = (t) => this.inputBox.onDidChange(t), this.container = Ie(this.parent, Yme(".quick-input-box")), this.inputBox = this._register(new G7(this.container, void 0));
  }
  get value() {
    return this.inputBox.value;
  }
  set value(e) {
    this.inputBox.value = e;
  }
  select(e = null) {
    this.inputBox.select(e);
  }
  isSelectionAtEnd() {
    return this.inputBox.isSelectionAtEnd();
  }
  get placeholder() {
    return this.inputBox.inputElement.getAttribute("placeholder") || "";
  }
  set placeholder(e) {
    this.inputBox.setPlaceHolder(e);
  }
  get ariaLabel() {
    return this.inputBox.getAriaLabel();
  }
  set ariaLabel(e) {
    this.inputBox.setAriaLabel(e);
  }
  get password() {
    return this.inputBox.inputElement.type === "password";
  }
  set password(e) {
    this.inputBox.inputElement.type = e ? "password" : "text";
  }
  setAttribute(e, t) {
    this.inputBox.inputElement.setAttribute(e, t);
  }
  removeAttribute(e) {
    this.inputBox.inputElement.removeAttribute(e);
  }
  showDecoration(e) {
    e === pn.Ignore ? this.inputBox.hideMessage() : this.inputBox.showMessage({ type: e === pn.Info ? 1 : e === pn.Warning ? 2 : 3, content: "" });
  }
  stylesForType(e) {
    return this.inputBox.stylesForType(
      e === pn.Info ? 1 : e === pn.Warning ? 2 : 3
      /* ERROR */
    );
  }
  setFocus() {
    this.inputBox.focus();
  }
  layout() {
    this.inputBox.layout();
  }
  style(e) {
    this.inputBox.style(e);
  }
}
const Zme = {
  badgeBackground: ee.fromHex("#4D4D4D"),
  badgeForeground: ee.fromHex("#FFFFFF")
};
class AW {
  constructor(e, t) {
    this.count = 0, this.options = t || /* @__PURE__ */ Object.create(null), ch(this.options, Zme, !1), this.badgeBackground = this.options.badgeBackground, this.badgeForeground = this.options.badgeForeground, this.badgeBorder = this.options.badgeBorder, this.element = Ie(e, Xe(".monaco-count-badge")), this.countFormat = this.options.countFormat || "{0}", this.titleFormat = this.options.titleFormat || "", this.setCount(this.options.count || 0);
  }
  setCount(e) {
    this.count = e, this.render();
  }
  setTitleFormat(e) {
    this.titleFormat = e, this.render();
  }
  render() {
    this.element.textContent = xl(this.countFormat, this.count), this.element.title = xl(this.titleFormat, this.count), this.applyStyles();
  }
  style(e) {
    this.badgeBackground = e.badgeBackground, this.badgeForeground = e.badgeForeground, this.badgeBorder = e.badgeBorder, this.applyStyles();
  }
  applyStyles() {
    if (this.element) {
      const e = this.badgeBackground ? this.badgeBackground.toString() : "", t = this.badgeForeground ? this.badgeForeground.toString() : "", i = this.badgeBorder ? this.badgeBorder.toString() : "";
      this.element.style.backgroundColor = e, this.element.style.color = t, this.element.style.borderWidth = i ? "1px" : "", this.element.style.borderStyle = i ? "solid" : "", this.element.style.borderColor = i;
    }
  }
}
const MW = "done", FW = "active", n1 = "infinite", kW = "discrete", Qme = {
  progressBarBackground: ee.fromHex("#0E70C0")
};
class Jme extends ge {
  constructor(e, t) {
    super(), this.options = t || /* @__PURE__ */ Object.create(null), ch(this.options, Qme, !1), this.workedVal = 0, this.progressBarBackground = this.options.progressBarBackground, this._register(this.showDelayedScheduler = new to(() => NG(this.element), 0)), this.create(e);
  }
  create(e) {
    this.element = document.createElement("div"), this.element.classList.add("monaco-progress-container"), this.element.setAttribute("role", "progressbar"), this.element.setAttribute("aria-valuemin", "0"), e.appendChild(this.element), this.bit = document.createElement("div"), this.bit.classList.add("progress-bit"), this.element.appendChild(this.bit), this.applyStyles();
  }
  off() {
    this.bit.style.width = "inherit", this.bit.style.opacity = "1", this.element.classList.remove(FW, n1, kW), this.workedVal = 0, this.totalWork = void 0;
  }
  /**
   * Stops the progressbar from showing any progress instantly without fading out.
   */
  stop() {
    return this.doDone(!1);
  }
  doDone(e) {
    return this.element.classList.add(MW), this.element.classList.contains(n1) ? (this.bit.style.opacity = "0", e ? setTimeout(() => this.off(), 200) : this.off()) : (this.bit.style.width = "inherit", e ? setTimeout(() => this.off(), 200) : this.off()), this;
  }
  /**
   * Use this mode to indicate progress that has no total number of work units.
   */
  infinite() {
    return this.bit.style.width = "2%", this.bit.style.opacity = "1", this.element.classList.remove(kW, MW), this.element.classList.add(FW, n1), this;
  }
  getContainer() {
    return this.element;
  }
  style(e) {
    this.progressBarBackground = e.progressBarBackground, this.applyStyles();
  }
  applyStyles() {
    if (this.bit) {
      const e = this.progressBarBackground ? this.progressBarBackground.toString() : "";
      this.bit.style.backgroundColor = e;
    }
  }
}
const eve = {
  buttonBackground: ee.fromHex("#0E639C"),
  buttonHoverBackground: ee.fromHex("#006BB3"),
  buttonForeground: ee.white
};
class WW extends ge {
  constructor(e, t) {
    super(), this._onDidClick = this._register(new j()), this.options = t || /* @__PURE__ */ Object.create(null), ch(this.options, eve, !1), this.buttonForeground = this.options.buttonForeground, this.buttonBackground = this.options.buttonBackground, this.buttonHoverBackground = this.options.buttonHoverBackground, this.buttonSecondaryForeground = this.options.buttonSecondaryForeground, this.buttonSecondaryBackground = this.options.buttonSecondaryBackground, this.buttonSecondaryHoverBackground = this.options.buttonSecondaryHoverBackground, this.buttonBorder = this.options.buttonBorder, this._element = document.createElement("a"), this._element.classList.add("monaco-button"), this._element.tabIndex = 0, this._element.setAttribute("role", "button"), e.appendChild(this._element), this._register(ri.addTarget(this._element)), [Be.CLICK, Li.Tap].forEach((i) => {
      this._register(ye(this._element, i, (r) => {
        if (!this.enabled) {
          gi.stop(r);
          return;
        }
        this._onDidClick.fire(r);
      }));
    }), this._register(ye(this._element, Be.KEY_DOWN, (i) => {
      const r = new Ki(i);
      let o = !1;
      this.enabled && (r.equals(
        3
        /* Enter */
      ) || r.equals(
        10
        /* Space */
      )) ? (this._onDidClick.fire(i), o = !0) : r.equals(
        9
        /* Escape */
      ) && (this._element.blur(), o = !0), o && gi.stop(r, !0);
    })), this._register(ye(this._element, Be.MOUSE_OVER, (i) => {
      this._element.classList.contains("disabled") || this.setHoverBackground();
    })), this._register(ye(this._element, Be.MOUSE_OUT, (i) => {
      this.applyStyles();
    })), this.focusTracker = this._register($S(this._element)), this._register(this.focusTracker.onDidFocus(() => this.setHoverBackground())), this._register(this.focusTracker.onDidBlur(() => this.applyStyles())), this.applyStyles();
  }
  get onDidClick() {
    return this._onDidClick.event;
  }
  setHoverBackground() {
    let e;
    this.options.secondary ? e = this.buttonSecondaryHoverBackground ? this.buttonSecondaryHoverBackground.toString() : null : e = this.buttonHoverBackground ? this.buttonHoverBackground.toString() : null, e && (this._element.style.backgroundColor = e);
  }
  style(e) {
    this.buttonForeground = e.buttonForeground, this.buttonBackground = e.buttonBackground, this.buttonHoverBackground = e.buttonHoverBackground, this.buttonSecondaryForeground = e.buttonSecondaryForeground, this.buttonSecondaryBackground = e.buttonSecondaryBackground, this.buttonSecondaryHoverBackground = e.buttonSecondaryHoverBackground, this.buttonBorder = e.buttonBorder, this.applyStyles();
  }
  applyStyles() {
    if (this._element) {
      let e, t;
      this.options.secondary ? (t = this.buttonSecondaryForeground ? this.buttonSecondaryForeground.toString() : "", e = this.buttonSecondaryBackground ? this.buttonSecondaryBackground.toString() : "") : (t = this.buttonForeground ? this.buttonForeground.toString() : "", e = this.buttonBackground ? this.buttonBackground.toString() : "");
      const i = this.buttonBorder ? this.buttonBorder.toString() : "";
      this._element.style.color = t, this._element.style.backgroundColor = e, this._element.style.borderWidth = i ? "1px" : "", this._element.style.borderStyle = i ? "solid" : "", this._element.style.borderColor = i;
    }
  }
  get element() {
    return this._element;
  }
  set label(e) {
    this._element.classList.add("monaco-text-button"), this.options.supportIcons ? KS(this._element, ...Ev(e)) : this._element.textContent = e, typeof this.options.title == "string" ? this._element.title = this.options.title : this.options.title && (this._element.title = e);
  }
  set enabled(e) {
    e ? (this._element.classList.remove("disabled"), this._element.setAttribute("aria-disabled", String(!1)), this._element.tabIndex = 0) : (this._element.classList.add("disabled"), this._element.setAttribute("aria-disabled", String(!0)));
  }
  get enabled() {
    return !this._element.classList.contains("disabled");
  }
}
var VW = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
const Po = Xe, tve = va("quick-input-back", Vi.arrowLeft), wO = {
  iconClass: tve.classNames,
  tooltip: w("quickInput.back", "Back"),
  handle: -1
  // TODO
};
class B0 extends ge {
  constructor(e) {
    super(), this.ui = e, this.visible = !1, this._enabled = !0, this._busy = !1, this._ignoreFocusOut = !1, this._buttons = [], this.noValidationMessage = B0.noPromptMessage, this._severity = pn.Ignore, this.buttonsUpdated = !1, this.onDidTriggerButtonEmitter = this._register(new j()), this.onDidHideEmitter = this._register(new j()), this.onDisposeEmitter = this._register(new j()), this.visibleDisposables = this._register(new ht()), this.onDidHide = this.onDidHideEmitter.event;
  }
  get title() {
    return this._title;
  }
  set title(e) {
    this._title = e, this.update();
  }
  get description() {
    return this._description;
  }
  set description(e) {
    this._description = e, this.update();
  }
  get step() {
    return this._steps;
  }
  set step(e) {
    this._steps = e, this.update();
  }
  get totalSteps() {
    return this._totalSteps;
  }
  set totalSteps(e) {
    this._totalSteps = e, this.update();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this.update();
  }
  get contextKey() {
    return this._contextKey;
  }
  set contextKey(e) {
    this._contextKey = e, this.update();
  }
  get busy() {
    return this._busy;
  }
  set busy(e) {
    this._busy = e, this.update();
  }
  get ignoreFocusOut() {
    return this._ignoreFocusOut;
  }
  set ignoreFocusOut(e) {
    this._ignoreFocusOut = e, this.update();
  }
  get buttons() {
    return this._buttons;
  }
  set buttons(e) {
    this._buttons = e, this.buttonsUpdated = !0, this.update();
  }
  get validationMessage() {
    return this._validationMessage;
  }
  set validationMessage(e) {
    this._validationMessage = e, this.update();
  }
  get severity() {
    return this._severity;
  }
  set severity(e) {
    this._severity = e, this.update();
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.onDidTriggerButton((e) => {
      this.buttons.indexOf(e) !== -1 && this.onDidTriggerButtonEmitter.fire(e);
    })), this.ui.show(this), this.visible = !0, this.update());
  }
  hide() {
    this.visible && this.ui.hide();
  }
  didHide(e = f_.Other) {
    this.visible = !1, this.visibleDisposables.clear(), this.onDidHideEmitter.fire({ reason: e });
  }
  update() {
    if (!this.visible)
      return;
    const e = this.getTitle();
    e && this.ui.title.textContent !== e ? this.ui.title.textContent = e : !e && this.ui.title.innerHTML !== "&nbsp;" && (this.ui.title.innerText = ";");
    const t = this.getDescription();
    if (this.ui.description1.textContent !== t && (this.ui.description1.textContent = t), this.ui.description2.textContent !== t && (this.ui.description2.textContent = t), this.busy && !this.busyDelay && (this.busyDelay = new ec(), this.busyDelay.setIfNotSet(() => {
      this.visible && this.ui.progressBar.infinite();
    }, 800)), !this.busy && this.busyDelay && (this.ui.progressBar.stop(), this.busyDelay.cancel(), this.busyDelay = void 0), this.buttonsUpdated) {
      this.buttonsUpdated = !1, this.ui.leftActionBar.clear();
      const r = this.buttons.filter((s) => s === wO);
      this.ui.leftActionBar.push(r.map((s, a) => {
        const l = new Wl(`id-${a}`, "", s.iconClass || CO(s.iconPath), !0, () => VW(this, void 0, void 0, function* () {
          this.onDidTriggerButtonEmitter.fire(s);
        }));
        return l.tooltip = s.tooltip || "", l;
      }), { icon: !0, label: !1 }), this.ui.rightActionBar.clear();
      const o = this.buttons.filter((s) => s !== wO);
      this.ui.rightActionBar.push(o.map((s, a) => {
        const l = new Wl(`id-${a}`, "", s.iconClass || CO(s.iconPath), !0, () => VW(this, void 0, void 0, function* () {
          this.onDidTriggerButtonEmitter.fire(s);
        }));
        return l.tooltip = s.tooltip || "", l;
      }), { icon: !0, label: !1 });
    }
    this.ui.ignoreFocusOut = this.ignoreFocusOut, this.ui.setEnabled(this.enabled), this.ui.setContextKey(this.contextKey);
    const i = this.validationMessage || this.noValidationMessage;
    this._lastValidationMessage !== i && (this._lastValidationMessage = i, KS(this.ui.message, ...Ev(i))), this._lastSeverity !== this.severity && (this._lastSeverity = this.severity, this.showMessageDecoration(this.severity));
  }
  getTitle() {
    return this.title && this.step ? `${this.title} (${this.getSteps()})` : this.title ? this.title : this.step ? this.getSteps() : "";
  }
  getDescription() {
    return this.description || "";
  }
  getSteps() {
    return this.step && this.totalSteps ? w("quickInput.steps", "{0}/{1}", this.step, this.totalSteps) : this.step ? String(this.step) : "";
  }
  showMessageDecoration(e) {
    if (this.ui.inputBox.showDecoration(e), e !== pn.Ignore) {
      const t = this.ui.inputBox.stylesForType(e);
      this.ui.message.style.color = t.foreground ? `${t.foreground}` : "", this.ui.message.style.backgroundColor = t.background ? `${t.background}` : "", this.ui.message.style.border = t.border ? `1px solid ${t.border}` : "", this.ui.message.style.paddingBottom = "4px";
    } else
      this.ui.message.style.color = "", this.ui.message.style.backgroundColor = "", this.ui.message.style.border = "", this.ui.message.style.paddingBottom = "";
  }
  dispose() {
    this.hide(), this.onDisposeEmitter.fire(), super.dispose();
  }
}
B0.noPromptMessage = w("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
class p_ extends B0 {
  constructor() {
    super(...arguments), this._value = "", this.onDidChangeValueEmitter = this._register(new j()), this.onWillAcceptEmitter = this._register(new j()), this.onDidAcceptEmitter = this._register(new j()), this.onDidCustomEmitter = this._register(new j()), this._items = [], this.itemsUpdated = !1, this._canSelectMany = !1, this._canAcceptInBackground = !1, this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._sortByLabel = !0, this._autoFocusOnList = !0, this._itemActivation = this.ui.isScreenReaderOptimized() ? Aa.NONE : Aa.FIRST, this._activeItems = [], this.activeItemsUpdated = !1, this.activeItemsToConfirm = [], this.onDidChangeActiveEmitter = this._register(new j()), this._selectedItems = [], this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = [], this.onDidChangeSelectionEmitter = this._register(new j()), this.onDidTriggerItemButtonEmitter = this._register(new j()), this.valueSelectionUpdated = !0, this._ok = "default", this._customButton = !1, this.filterValue = (e) => e, this.onDidChangeValue = this.onDidChangeValueEmitter.event, this.onWillAccept = this.onWillAcceptEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event, this.onDidChangeActive = this.onDidChangeActiveEmitter.event, this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event, this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;
  }
  get quickNavigate() {
    return this._quickNavigate;
  }
  set quickNavigate(e) {
    this._quickNavigate = e, this.update();
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this._value !== e && (this._value = e || "", this.update(), this.onDidChangeValueEmitter.fire(this._value));
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.update();
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this._placeholder = e, this.update();
  }
  get items() {
    return this._items;
  }
  set items(e) {
    this._items = e, this.itemsUpdated = !0, this.update();
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(e) {
    this._canSelectMany = e, this.update();
  }
  get canAcceptInBackground() {
    return this._canAcceptInBackground;
  }
  set canAcceptInBackground(e) {
    this._canAcceptInBackground = e;
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(e) {
    this._matchOnDescription = e, this.update();
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(e) {
    this._matchOnDetail = e, this.update();
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(e) {
    this._matchOnLabel = e, this.update();
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(e) {
    this._sortByLabel = e, this.update();
  }
  get autoFocusOnList() {
    return this._autoFocusOnList;
  }
  set autoFocusOnList(e) {
    this._autoFocusOnList = e, this.update();
  }
  get itemActivation() {
    return this._itemActivation;
  }
  set itemActivation(e) {
    this._itemActivation = e;
  }
  get activeItems() {
    return this._activeItems;
  }
  set activeItems(e) {
    this._activeItems = e, this.activeItemsUpdated = !0, this.update();
  }
  get selectedItems() {
    return this._selectedItems;
  }
  set selectedItems(e) {
    this._selectedItems = e, this.selectedItemsUpdated = !0, this.update();
  }
  get keyMods() {
    return this._quickNavigate ? bme : this.ui.keyMods;
  }
  set valueSelection(e) {
    this._valueSelection = e, this.valueSelectionUpdated = !0, this.update();
  }
  get customButton() {
    return this._customButton;
  }
  set customButton(e) {
    this._customButton = e, this.update();
  }
  get customLabel() {
    return this._customButtonLabel;
  }
  set customLabel(e) {
    this._customButtonLabel = e, this.update();
  }
  get customHover() {
    return this._customButtonHover;
  }
  set customHover(e) {
    this._customButtonHover = e, this.update();
  }
  get ok() {
    return this._ok;
  }
  set ok(e) {
    this._ok = e, this.update();
  }
  get hideInput() {
    return !!this._hideInput;
  }
  set hideInput(e) {
    this._hideInput = e, this.update();
  }
  trySelectFirst() {
    this.autoFocusOnList && (this.canSelectMany || this.ui.list.focus($i.First));
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
      if (e === this.value)
        return;
      this._value = e, this.ui.list.filter(this.filterValue(this.ui.inputBox.value)) && this.trySelectFirst(), this.onDidChangeValueEmitter.fire(e);
    })), this.visibleDisposables.add(this.ui.inputBox.onMouseDown((e) => {
      this.autoFocusOnList || this.ui.list.clearFocus();
    })), this.visibleDisposables.add((this._hideInput ? this.ui.list : this.ui.inputBox).onKeyDown((e) => {
      switch (e.keyCode) {
        case 18:
          this.ui.list.focus($i.Next), this.canSelectMany && this.ui.list.domFocus(), gi.stop(e, !0);
          break;
        case 16:
          this.ui.list.getFocusedElements().length ? this.ui.list.focus($i.Previous) : this.ui.list.focus($i.Last), this.canSelectMany && this.ui.list.domFocus(), gi.stop(e, !0);
          break;
        case 12:
          this.ui.list.focus($i.NextPage), this.canSelectMany && this.ui.list.domFocus(), gi.stop(e, !0);
          break;
        case 11:
          this.ui.list.focus($i.PreviousPage), this.canSelectMany && this.ui.list.domFocus(), gi.stop(e, !0);
          break;
        case 17:
          if (!this._canAcceptInBackground || !this.ui.inputBox.isSelectionAtEnd())
            return;
          this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!0));
          break;
        case 14:
          (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && (this.ui.list.focus($i.First), gi.stop(e, !0));
          break;
        case 13:
          (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && (this.ui.list.focus($i.Last), gi.stop(e, !0));
          break;
      }
    })), this.visibleDisposables.add(this.ui.onDidAccept(() => {
      !this.canSelectMany && this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems)), this.handleAccept(!1);
    })), this.visibleDisposables.add(this.ui.onDidCustom(() => {
      this.onDidCustomEmitter.fire();
    })), this.visibleDisposables.add(this.ui.list.onDidChangeFocus((e) => {
      this.activeItemsUpdated || this.activeItemsToConfirm !== this._activeItems && Gu(e, this._activeItems, (t, i) => t === i) || (this._activeItems = e, this.onDidChangeActiveEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: e, event: t }) => {
      if (this.canSelectMany) {
        e.length && this.ui.list.setSelectedElements([]);
        return;
      }
      this.selectedItemsToConfirm !== this._selectedItems && Gu(e, this._selectedItems, (i, r) => i === r) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e), e.length && this.handleAccept(
        t instanceof MouseEvent && t.button === 1
        /* mouse middle click */
      ));
    })), this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((e) => {
      this.canSelectMany && (this.selectedItemsToConfirm !== this._selectedItems && Gu(e, this._selectedItems, (t, i) => t === i) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e)));
    })), this.visibleDisposables.add(this.ui.list.onButtonTriggered((e) => this.onDidTriggerItemButtonEmitter.fire(e))), this.visibleDisposables.add(this.registerQuickNavigation()), this.valueSelectionUpdated = !0), super.show();
  }
  handleAccept(e) {
    let t = !1;
    this.onWillAcceptEmitter.fire({ veto: () => t = !0 }), t || this.onDidAcceptEmitter.fire({ inBackground: e });
  }
  registerQuickNavigation() {
    return ye(this.ui.container, Be.KEY_UP, (e) => {
      if (this.canSelectMany || !this._quickNavigate)
        return;
      const t = new Ki(e), i = t.keyCode;
      this._quickNavigate.keybindings.some((s) => {
        const [a, l] = s.getParts();
        return l ? !1 : a.shiftKey && i === 4 ? !(t.ctrlKey || t.altKey || t.metaKey) : !!(a.altKey && i === 6 || a.ctrlKey && i === 5 || a.metaKey && i === 57);
      }) && (this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!1)), this._quickNavigate = void 0);
    });
  }
  update() {
    if (!this.visible)
      return;
    const e = !!this._hideInput && this._items.length > 0;
    this.ui.container.classList.toggle("hidden-input", e && !this.description);
    const t = {
      title: !!this.title || !!this.step || !!this.buttons.length,
      description: !!this.description,
      checkAll: this.canSelectMany && !this._hideCheckAll,
      checkBox: this.canSelectMany,
      inputBox: !e,
      progressBar: !e,
      visibleCount: !0,
      count: this.canSelectMany,
      ok: this.ok === "default" ? this.canSelectMany : this.ok,
      list: !0,
      message: !!this.validationMessage,
      customButton: this.customButton
    };
    this.ui.setVisibilities(t), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || "");
    const i = this.ariaLabel || this.placeholder || p_.DEFAULT_ARIA_LABEL;
    if (this.ui.inputBox.ariaLabel !== i && (this.ui.inputBox.ariaLabel = i), this.ui.list.matchOnDescription = this.matchOnDescription, this.ui.list.matchOnDetail = this.matchOnDetail, this.ui.list.matchOnLabel = this.matchOnLabel, this.ui.list.sortByLabel = this.sortByLabel, this.itemsUpdated)
      switch (this.itemsUpdated = !1, this.ui.list.setElements(this.items), this.ui.list.filter(this.filterValue(this.ui.inputBox.value)), this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked(), this.ui.visibleCount.setCount(this.ui.list.getVisibleCount()), this.ui.count.setCount(this.ui.list.getCheckedCount()), this._itemActivation) {
        case Aa.NONE:
          this._itemActivation = Aa.FIRST;
          break;
        case Aa.SECOND:
          this.ui.list.focus($i.Second), this._itemActivation = Aa.FIRST;
          break;
        case Aa.LAST:
          this.ui.list.focus($i.Last), this._itemActivation = Aa.FIRST;
          break;
        default:
          this.trySelectFirst();
          break;
      }
    this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany && (this.canSelectMany ? this.ui.list.clearFocus() : this.trySelectFirst()), this.activeItemsUpdated && (this.activeItemsUpdated = !1, this.activeItemsToConfirm = this._activeItems, this.ui.list.setFocusedElements(this.activeItems), this.activeItemsToConfirm === this._activeItems && (this.activeItemsToConfirm = null)), this.selectedItemsUpdated && (this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = this._selectedItems, this.canSelectMany ? this.ui.list.setCheckedElements(this.selectedItems) : this.ui.list.setSelectedElements(this.selectedItems), this.selectedItemsToConfirm === this._selectedItems && (this.selectedItemsToConfirm = null)), this.ui.customButton.label = this.customLabel || "", this.ui.customButton.element.title = this.customHover || "", this.ui.setComboboxAccessibility(!0), t.inputBox || (this.ui.list.domFocus(), this.canSelectMany && this.ui.list.focus($i.First));
  }
}
p_.DEFAULT_ARIA_LABEL = w("quickInputBox.ariaLabel", "Type to narrow down results.");
class H0 extends ge {
  constructor(e) {
    super(), this.options = e, this.comboboxAccessibility = !1, this.enabled = !0, this.onDidAcceptEmitter = this._register(new j()), this.onDidCustomEmitter = this._register(new j()), this.onDidTriggerButtonEmitter = this._register(new j()), this.keyMods = { ctrlCmd: !1, alt: !1 }, this.controller = null, this.onShowEmitter = this._register(new j()), this.onShow = this.onShowEmitter.event, this.onHideEmitter = this._register(new j()), this.onHide = this.onHideEmitter.event, this.idPrefix = e.idPrefix, this.parentElement = e.container, this.styles = e.styles, this.registerKeyModsListeners();
  }
  registerKeyModsListeners() {
    const e = (t) => {
      this.keyMods.ctrlCmd = t.ctrlKey || t.metaKey, this.keyMods.alt = t.altKey;
    };
    this._register(ye(window, Be.KEY_DOWN, e, !0)), this._register(ye(window, Be.KEY_UP, e, !0)), this._register(ye(window, Be.MOUSE_DOWN, e, !0));
  }
  getUI() {
    if (this.ui)
      return this.ui;
    const e = Ie(this.parentElement, Po(".quick-input-widget.show-file-icons"));
    e.tabIndex = -1, e.style.display = "none";
    const t = Os(e), i = Ie(e, Po(".quick-input-titlebar")), r = this._register(new Qp(i));
    r.domNode.classList.add("quick-input-left-action-bar");
    const o = Ie(i, Po(".quick-input-title")), s = this._register(new Qp(i));
    s.domNode.classList.add("quick-input-right-action-bar");
    const a = Ie(e, Po(".quick-input-description")), l = Ie(e, Po(".quick-input-header")), u = Ie(l, Po("input.quick-input-check-all"));
    u.type = "checkbox", this._register(Jr(u, Be.CHANGE, (O) => {
      const T = u.checked;
      S.setAllVisibleChecked(T);
    })), this._register(ye(u, Be.CLICK, (O) => {
      (O.x || O.y) && f.setFocus();
    }));
    const c = Ie(l, Po(".quick-input-description")), h = Ie(l, Po(".quick-input-and-message")), d = Ie(h, Po(".quick-input-filter")), f = this._register(new Xme(d));
    f.setAttribute("aria-describedby", `${this.idPrefix}message`);
    const p = Ie(d, Po(".quick-input-visible-count"));
    p.setAttribute("aria-live", "polite"), p.setAttribute("aria-atomic", "true");
    const g = new AW(p, { countFormat: w({ key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."] }, "{0} Results") }), _ = Ie(d, Po(".quick-input-count"));
    _.setAttribute("aria-live", "polite");
    const m = new AW(_, { countFormat: w({ key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."] }, "{0} Selected") }), v = Ie(l, Po(".quick-input-action")), C = new WW(v);
    C.label = w("ok", "OK"), this._register(C.onDidClick((O) => {
      this.onDidAcceptEmitter.fire();
    }));
    const y = Ie(l, Po(".quick-input-action")), b = new WW(y);
    b.label = w("custom", "Custom"), this._register(b.onDidClick((O) => {
      this.onDidCustomEmitter.fire();
    }));
    const L = Ie(h, Po(`#${this.idPrefix}message.quick-input-message`)), S = this._register(new GI(e, this.idPrefix + "list", this.options));
    this._register(S.onChangedAllVisibleChecked((O) => {
      u.checked = O;
    })), this._register(S.onChangedVisibleCount((O) => {
      g.setCount(O);
    })), this._register(S.onChangedCheckedCount((O) => {
      m.setCount(O);
    })), this._register(S.onLeave(() => {
      setTimeout(() => {
        f.setFocus(), this.controller instanceof p_ && this.controller.canSelectMany && S.clearFocus();
      }, 0);
    })), this._register(S.onDidChangeFocus(() => {
      this.comboboxAccessibility && this.getUI().inputBox.setAttribute("aria-activedescendant", this.getUI().list.getActiveDescendant() || "");
    }));
    const E = new Jme(e);
    E.getContainer().classList.add("quick-input-progress");
    const D = $S(e);
    return this._register(D), this._register(ye(e, Be.FOCUS, (O) => {
      this.previousFocusElement = O.relatedTarget instanceof HTMLElement ? O.relatedTarget : void 0;
    }, !0)), this._register(D.onDidBlur(() => {
      !this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut() && this.hide(f_.Blur), this.previousFocusElement = void 0;
    })), this._register(ye(e, Be.FOCUS, (O) => {
      f.setFocus();
    })), this._register(ye(e, Be.KEY_DOWN, (O) => {
      const T = new Ki(O);
      switch (T.keyCode) {
        case 3:
          gi.stop(O, !0), this.onDidAcceptEmitter.fire();
          break;
        case 9:
          gi.stop(O, !0), this.hide(f_.Gesture);
          break;
        case 2:
          if (!T.altKey && !T.ctrlKey && !T.metaKey) {
            const A = [".action-label.codicon"];
            e.classList.contains("show-checkboxes") ? A.push("input") : A.push("input[type=text]"), this.getUI().list.isDisplayed() && A.push(".monaco-list");
            const P = e.querySelectorAll(A.join(", "));
            T.shiftKey && T.target === P[0] ? (gi.stop(O, !0), P[P.length - 1].focus()) : !T.shiftKey && T.target === P[P.length - 1] && (gi.stop(O, !0), P[0].focus());
          }
          break;
      }
    })), this.ui = {
      container: e,
      styleSheet: t,
      leftActionBar: r,
      titleBar: i,
      title: o,
      description1: a,
      description2: c,
      rightActionBar: s,
      checkAll: u,
      filterContainer: d,
      inputBox: f,
      visibleCountContainer: p,
      visibleCount: g,
      countContainer: _,
      count: m,
      okContainer: v,
      ok: C,
      message: L,
      customButtonContainer: y,
      customButton: b,
      list: S,
      progressBar: E,
      onDidAccept: this.onDidAcceptEmitter.event,
      onDidCustom: this.onDidCustomEmitter.event,
      onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
      ignoreFocusOut: !1,
      keyMods: this.keyMods,
      isScreenReaderOptimized: () => this.options.isScreenReaderOptimized(),
      show: (O) => this.show(O),
      hide: () => this.hide(),
      setVisibilities: (O) => this.setVisibilities(O),
      setComboboxAccessibility: (O) => this.setComboboxAccessibility(O),
      setEnabled: (O) => this.setEnabled(O),
      setContextKey: (O) => this.options.setContextKey(O)
    }, this.updateStyles(), this.ui;
  }
  pick(e, t = {}, i = zo.None) {
    return new Promise((r, o) => {
      let s = (c) => {
        s = r, t.onKeyMods && t.onKeyMods(a.keyMods), r(c);
      };
      if (i.isCancellationRequested) {
        s(void 0);
        return;
      }
      const a = this.createQuickPick();
      let l;
      const u = [
        a,
        a.onDidAccept(() => {
          if (a.canSelectMany)
            s(a.selectedItems.slice()), a.hide();
          else {
            const c = a.activeItems[0];
            c && (s(c), a.hide());
          }
        }),
        a.onDidChangeActive((c) => {
          const h = c[0];
          h && t.onDidFocus && t.onDidFocus(h);
        }),
        a.onDidChangeSelection((c) => {
          if (!a.canSelectMany) {
            const h = c[0];
            h && (s(h), a.hide());
          }
        }),
        a.onDidTriggerItemButton((c) => t.onDidTriggerItemButton && t.onDidTriggerItemButton(Object.assign(Object.assign({}, c), { removeItem: () => {
          const h = a.items.indexOf(c.item);
          if (h !== -1) {
            const d = a.items.slice(), f = d.splice(h, 1), p = a.activeItems.filter((g) => g !== f[0]);
            a.items = d, p && (a.activeItems = p);
          }
        } }))),
        a.onDidChangeValue((c) => {
          l && !c && (a.activeItems.length !== 1 || a.activeItems[0] !== l) && (a.activeItems = [l]);
        }),
        i.onCancellationRequested(() => {
          a.hide();
        }),
        a.onDidHide(() => {
          yi(u), s(void 0);
        })
      ];
      a.title = t.title, a.canSelectMany = !!t.canPickMany, a.placeholder = t.placeHolder, a.ignoreFocusOut = !!t.ignoreFocusLost, a.matchOnDescription = !!t.matchOnDescription, a.matchOnDetail = !!t.matchOnDetail, a.matchOnLabel = t.matchOnLabel === void 0 || t.matchOnLabel, a.autoFocusOnList = t.autoFocusOnList === void 0 || t.autoFocusOnList, a.quickNavigate = t.quickNavigate, a.contextKey = t.contextKey, a.busy = !0, Promise.all([e, t.activeItem]).then(([c, h]) => {
        l = h, a.busy = !1, a.items = c, a.canSelectMany && (a.selectedItems = c.filter((d) => d.type !== "separator" && d.picked)), l && (a.activeItems = [l]);
      }), a.show(), Promise.resolve(e).then(void 0, (c) => {
        o(c), a.hide();
      });
    });
  }
  createQuickPick() {
    const e = this.getUI();
    return new p_(e);
  }
  show(e) {
    const t = this.getUI();
    this.onShowEmitter.fire();
    const i = this.controller;
    this.controller = e, i && i.didHide(), this.setEnabled(!0), t.leftActionBar.clear(), t.title.textContent = "", t.description1.textContent = "", t.description2.textContent = "", t.rightActionBar.clear(), t.checkAll.checked = !1, t.inputBox.placeholder = "", t.inputBox.password = !1, t.inputBox.showDecoration(pn.Ignore), t.visibleCount.setCount(0), t.count.setCount(0), KS(t.message), t.progressBar.stop(), t.list.setElements([]), t.list.matchOnDescription = !1, t.list.matchOnDetail = !1, t.list.matchOnLabel = !0, t.list.sortByLabel = !0, t.ignoreFocusOut = !1, this.setComboboxAccessibility(!1), t.inputBox.ariaLabel = "";
    const r = this.options.backKeybindingLabel();
    wO.tooltip = r ? w("quickInput.backWithKeybinding", "Back ({0})", r) : w("quickInput.back", "Back"), t.container.style.display = "", this.updateLayout(), t.inputBox.setFocus();
  }
  setVisibilities(e) {
    const t = this.getUI();
    t.title.style.display = e.title ? "" : "none", t.description1.style.display = e.description && (e.inputBox || e.checkAll) ? "" : "none", t.description2.style.display = e.description && !(e.inputBox || e.checkAll) ? "" : "none", t.checkAll.style.display = e.checkAll ? "" : "none", t.filterContainer.style.display = e.inputBox ? "" : "none", t.visibleCountContainer.style.display = e.visibleCount ? "" : "none", t.countContainer.style.display = e.count ? "" : "none", t.okContainer.style.display = e.ok ? "" : "none", t.customButtonContainer.style.display = e.customButton ? "" : "none", t.message.style.display = e.message ? "" : "none", t.progressBar.getContainer().style.display = e.progressBar ? "" : "none", t.list.display(!!e.list), t.container.classList[e.checkBox ? "add" : "remove"]("show-checkboxes"), this.updateLayout();
  }
  setComboboxAccessibility(e) {
    if (e !== this.comboboxAccessibility) {
      const t = this.getUI();
      this.comboboxAccessibility = e, this.comboboxAccessibility ? (t.inputBox.setAttribute("role", "combobox"), t.inputBox.setAttribute("aria-haspopup", "true"), t.inputBox.setAttribute("aria-autocomplete", "list"), t.inputBox.setAttribute("aria-activedescendant", t.list.getActiveDescendant() || "")) : (t.inputBox.removeAttribute("role"), t.inputBox.removeAttribute("aria-haspopup"), t.inputBox.removeAttribute("aria-autocomplete"), t.inputBox.removeAttribute("aria-activedescendant"));
    }
  }
  setEnabled(e) {
    if (e !== this.enabled) {
      this.enabled = e;
      for (const t of this.getUI().leftActionBar.viewItems)
        t.getAction().enabled = e;
      for (const t of this.getUI().rightActionBar.viewItems)
        t.getAction().enabled = e;
      this.getUI().checkAll.disabled = !e, this.getUI().ok.enabled = e, this.getUI().list.enabled = e;
    }
  }
  hide(e) {
    var t;
    const i = this.controller;
    if (i) {
      const r = !(!((t = this.ui) === null || t === void 0) && t.container.contains(document.activeElement));
      this.controller = null, this.onHideEmitter.fire(), this.getUI().container.style.display = "none", r || (this.previousFocusElement && this.previousFocusElement.offsetParent ? (this.previousFocusElement.focus(), this.previousFocusElement = void 0) : this.options.returnFocus()), i.didHide(e);
    }
  }
  layout(e, t) {
    this.dimension = e, this.titleBarOffset = t, this.updateLayout();
  }
  updateLayout() {
    if (this.ui) {
      this.ui.container.style.top = `${this.titleBarOffset}px`;
      const e = this.ui.container.style, t = Math.min(this.dimension.width * 0.62, H0.MAX_WIDTH);
      e.width = t + "px", e.marginLeft = "-" + t / 2 + "px", this.ui.inputBox.layout(), this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
    }
  }
  applyStyles(e) {
    this.styles = e, this.updateStyles();
  }
  updateStyles() {
    if (this.ui) {
      const { quickInputTitleBackground: e, quickInputBackground: t, quickInputForeground: i, contrastBorder: r, widgetShadow: o } = this.styles.widget;
      this.ui.titleBar.style.backgroundColor = e ? e.toString() : "", this.ui.container.style.backgroundColor = t ? t.toString() : "", this.ui.container.style.color = i ? i.toString() : "", this.ui.container.style.border = r ? `1px solid ${r}` : "", this.ui.container.style.boxShadow = o ? `0 0 8px 2px ${o}` : "", this.ui.inputBox.style(this.styles.inputBox), this.ui.count.style(this.styles.countBadge), this.ui.ok.style(this.styles.button), this.ui.customButton.style(this.styles.button), this.ui.progressBar.style(this.styles.progressBar), this.ui.list.style(this.styles.list);
      const s = [];
      this.styles.list.pickerGroupBorder && s.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.list.pickerGroupBorder}; }`), this.styles.list.pickerGroupForeground && s.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.list.pickerGroupForeground}; }`), (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) && (s.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {"), this.styles.keybindingLabel.keybindingLabelBackground && s.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`), this.styles.keybindingLabel.keybindingLabelBorder && s.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`), this.styles.keybindingLabel.keybindingLabelBottomBorder && s.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`), this.styles.keybindingLabel.keybindingLabelShadow && s.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`), this.styles.keybindingLabel.keybindingLabelForeground && s.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`), s.push("}"));
      const a = s.join(`
`);
      a !== this.ui.styleSheet.textContent && (this.ui.styleSheet.textContent = a);
    }
  }
}
H0.MAX_WIDTH = 600;
const U7 = Vt("quickInputService");
var bO;
(function(n) {
  n[n.PRESERVE = 0] = "PRESERVE", n[n.LAST = 1] = "LAST";
})(bO || (bO = {}));
const z7 = {
  Quickaccess: "workbench.contributions.quickaccess"
};
class ive {
  constructor() {
    this.providers = [], this.defaultProvider = void 0;
  }
  registerQuickAccessProvider(e) {
    return e.prefix.length === 0 ? this.defaultProvider = e : this.providers.push(e), this.providers.sort((t, i) => i.prefix.length - t.prefix.length), Ri(() => {
      this.providers.splice(this.providers.indexOf(e), 1), this.defaultProvider === e && (this.defaultProvider = void 0);
    });
  }
  getQuickAccessProviders() {
    return ise([this.defaultProvider, ...this.providers]);
  }
  getQuickAccessProvider(e) {
    return e && this.providers.find((i) => e.startsWith(i.prefix)) || void 0 || this.defaultProvider;
  }
}
Zn.add(z7.Quickaccess, new ive());
var nve = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, BW = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let SO = class extends ge {
  constructor(e, t) {
    super(), this.quickInputService = e, this.instantiationService = t, this.registry = Zn.as(z7.Quickaccess), this.mapProviderToDescriptor = /* @__PURE__ */ new Map(), this.lastAcceptedPickerValues = /* @__PURE__ */ new Map(), this.visibleQuickAccess = void 0;
  }
  show(e = "", t) {
    this.doShowOrPick(e, !1, t);
  }
  doShowOrPick(e, t, i) {
    var r;
    const [o, s] = this.getOrInstantiateProvider(e), a = this.visibleQuickAccess, l = a == null ? void 0 : a.descriptor;
    if (a && s && l === s) {
      e !== s.prefix && !(i != null && i.preserveValue) && (a.picker.value = e), this.adjustValueSelection(a.picker, s, i);
      return;
    }
    if (s && !(i != null && i.preserveValue)) {
      let p;
      if (a && l && l !== s) {
        const g = a.value.substr(l.prefix.length);
        g && (p = `${s.prefix}${g}`);
      }
      if (!p) {
        const g = o == null ? void 0 : o.defaultFilterValue;
        g === bO.LAST ? p = this.lastAcceptedPickerValues.get(s) : typeof g == "string" && (p = `${s.prefix}${g}`);
      }
      typeof p == "string" && (e = p);
    }
    const u = new ht(), c = u.add(this.quickInputService.createQuickPick());
    c.value = e, this.adjustValueSelection(c, s, i), c.placeholder = s == null ? void 0 : s.placeholder, c.quickNavigate = i == null ? void 0 : i.quickNavigateConfiguration, c.hideInput = !!c.quickNavigate && !a, (typeof (i == null ? void 0 : i.itemActivation) == "number" || i != null && i.quickNavigateConfiguration) && (c.itemActivation = (r = i == null ? void 0 : i.itemActivation) !== null && r !== void 0 ? r : Aa.SECOND), c.contextKey = s == null ? void 0 : s.contextKey, c.filterValue = (p) => p.substring(s ? s.prefix.length : 0), s != null && s.placeholder && (c.ariaLabel = s == null ? void 0 : s.placeholder);
    let h, d;
    t && (h = new Promise((p) => d = p), u.add(Xp(c.onWillAccept)((p) => {
      p.veto(), c.hide();
    }))), u.add(this.registerPickerListeners(c, o, s, e));
    const f = u.add(new uh());
    if (o && u.add(o.provide(c, f.token)), Xp(c.onDidHide)(() => {
      c.selectedItems.length === 0 && f.cancel(), u.dispose(), d == null || d(c.selectedItems);
    }), c.show(), t)
      return h;
  }
  adjustValueSelection(e, t, i) {
    var r;
    let o;
    i != null && i.preserveValue ? o = [e.value.length, e.value.length] : o = [(r = t == null ? void 0 : t.prefix.length) !== null && r !== void 0 ? r : 0, e.value.length], e.valueSelection = o;
  }
  registerPickerListeners(e, t, i, r) {
    const o = new ht(), s = this.visibleQuickAccess = { picker: e, descriptor: i, value: r };
    return o.add(Ri(() => {
      s === this.visibleQuickAccess && (this.visibleQuickAccess = void 0);
    })), o.add(e.onDidChangeValue((a) => {
      const [l] = this.getOrInstantiateProvider(a);
      l !== t ? this.show(
        a,
        { preserveValue: !0 }
        /* do not rewrite value from user typing! */
      ) : s.value = a;
    })), i && o.add(e.onDidAccept(() => {
      this.lastAcceptedPickerValues.set(i, e.value);
    })), o;
  }
  getOrInstantiateProvider(e) {
    const t = this.registry.getQuickAccessProvider(e);
    if (!t)
      return [void 0, void 0];
    let i = this.mapProviderToDescriptor.get(t);
    return i || (i = this.instantiationService.createInstance(t.ctor), this.mapProviderToDescriptor.set(t, i)), [i, t];
  }
};
SO = nve([
  BW(0, U7),
  BW(1, eo)
], SO);
var rve = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Wm = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let EO = class extends Pae {
  constructor(e, t, i, r, o) {
    super(i), this.instantiationService = e, this.contextKeyService = t, this.accessibilityService = r, this.layoutService = o, this.contexts = /* @__PURE__ */ new Map();
  }
  get controller() {
    return this._controller || (this._controller = this._register(this.createController())), this._controller;
  }
  get quickAccess() {
    return this._quickAccess || (this._quickAccess = this._register(this.instantiationService.createInstance(SO))), this._quickAccess;
  }
  createController(e = this.layoutService, t) {
    var i, r;
    const o = {
      idPrefix: "quickInput_",
      container: e.container,
      ignoreFocusOut: () => !1,
      isScreenReaderOptimized: () => this.accessibilityService.isScreenReaderOptimized(),
      backKeybindingLabel: () => {
      },
      setContextKey: (a) => this.setContextKey(a),
      returnFocus: () => e.focus(),
      createList: (a, l, u, c, h) => this.instantiationService.createInstance(fO, a, l, u, c, h),
      styles: this.computeStyles()
    }, s = this._register(new H0(Object.assign(Object.assign({}, o), t)));
    return s.layout(e.dimension, (r = (i = e.offset) === null || i === void 0 ? void 0 : i.top) !== null && r !== void 0 ? r : 0), this._register(e.onDidLayout((a) => {
      var l, u;
      return s.layout(a, (u = (l = e.offset) === null || l === void 0 ? void 0 : l.top) !== null && u !== void 0 ? u : 0);
    })), this._register(s.onShow(() => this.resetContextKeys())), this._register(s.onHide(() => this.resetContextKeys())), s;
  }
  setContextKey(e) {
    let t;
    e && (t = this.contexts.get(e), t || (t = new it(e, !1).bindTo(this.contextKeyService), this.contexts.set(e, t))), !(t && t.get()) && (this.resetContextKeys(), t && t.set(!0));
  }
  resetContextKeys() {
    this.contexts.forEach((e) => {
      e.get() && e.reset();
    });
  }
  pick(e, t = {}, i = zo.None) {
    return this.controller.pick(e, t, i);
  }
  createQuickPick() {
    return this.controller.createQuickPick();
  }
  updateStyles() {
    this.controller.applyStyles(this.computeStyles());
  }
  computeStyles() {
    return {
      widget: Object.assign({}, Fa(this.theme, {
        quickInputBackground: r2,
        quickInputForeground: Mue,
        quickInputTitleBackground: Fue,
        contrastBorder: dr,
        widgetShadow: Fb
      })),
      inputBox: Fa(this.theme, {
        inputForeground: gue,
        inputBackground: pue,
        inputBorder: mue,
        inputValidationInfoBackground: vue,
        inputValidationInfoForeground: _ue,
        inputValidationInfoBorder: Cue,
        inputValidationWarningBackground: yue,
        inputValidationWarningForeground: wue,
        inputValidationWarningBorder: bue,
        inputValidationErrorBackground: Sue,
        inputValidationErrorForeground: Eue,
        inputValidationErrorBorder: Lue
      }),
      countBadge: Fa(this.theme, {
        badgeBackground: a3,
        badgeForeground: l3,
        badgeBorder: dr
      }),
      button: Fa(this.theme, {
        buttonForeground: Due,
        buttonBackground: AT,
        buttonHoverBackground: Rue,
        buttonBorder: dr
      }),
      progressBar: Fa(this.theme, {
        progressBarBackground: Tue
      }),
      keybindingLabel: Fa(this.theme, {
        keybindingLabelBackground: Vue,
        keybindingLabelForeground: Bue,
        keybindingLabelBorder: Hue,
        keybindingLabelBottomBorder: Gue,
        keybindingLabelShadow: Fb
      }),
      list: Fa(this.theme, {
        listBackground: r2,
        // Look like focused when inactive.
        listInactiveFocusForeground: cce,
        listInactiveFocusBackground: hce,
        listFocusOutline: xs,
        listInactiveFocusOutline: xs,
        pickerGroupBorder: Wue,
        pickerGroupForeground: kue
      })
    };
  }
};
EO = rve([
  Wm(0, eo),
  Wm(1, Ti),
  Wm(2, Qn),
  Wm(3, Is),
  Wm(4, I0)
], EO);
var j7 = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Yh = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let LO = class extends EO {
  constructor(e, t, i, r, o, s) {
    super(t, i, r, o, s), this.host = void 0;
    const a = ng.get(e);
    this.host = {
      _serviceBrand: void 0,
      get container() {
        return a.widget.getDomNode();
      },
      get dimension() {
        return e.getLayoutInfo();
      },
      get onDidLayout() {
        return e.onDidLayoutChange;
      },
      focus: () => e.focus()
    };
  }
  createController() {
    return super.createController(this.host);
  }
};
LO = j7([
  Yh(1, eo),
  Yh(2, Ti),
  Yh(3, Qn),
  Yh(4, Is),
  Yh(5, I0)
], LO);
let DO = class {
  constructor(e, t) {
    this.instantiationService = e, this.codeEditorService = t, this.mapEditorToService = /* @__PURE__ */ new Map();
  }
  get activeService() {
    const e = this.codeEditorService.getFocusedCodeEditor();
    if (!e)
      throw new Error("Quick input service needs a focused editor to work.");
    let t = this.mapEditorToService.get(e);
    if (!t) {
      const i = t = this.instantiationService.createInstance(LO, e);
      this.mapEditorToService.set(e, t), Xp(e.onDidDispose)(() => {
        i.dispose(), this.mapEditorToService.delete(e);
      });
    }
    return t;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  pick(e, t = {}, i = zo.None) {
    return this.activeService.pick(e, t, i);
  }
  createQuickPick() {
    return this.activeService.createQuickPick();
  }
};
DO = j7([
  Yh(0, eo),
  Yh(1, pr)
], DO);
class ng {
  constructor(e) {
    this.editor = e, this.widget = new G0(this.editor);
  }
  static get(e) {
    return e.getContribution(ng.ID);
  }
  dispose() {
    this.widget.dispose();
  }
}
ng.ID = "editor.controller.quickInput";
class G0 {
  constructor(e) {
    this.codeEditor = e, this.domNode = document.createElement("div"), this.codeEditor.addOverlayWidget(this);
  }
  getId() {
    return G0.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      preference: 2
      /* TOP_CENTER */
    };
  }
  dispose() {
    this.codeEditor.removeOverlayWidget(this);
  }
}
G0.ID = "editor.contrib.quickInputWidget";
U5(ng.ID, ng);
var Mt;
(function(n) {
  const e = new s_();
  class t {
    constructor(l, u) {
      this._serviceId = l, this._factory = u, this._value = null;
    }
    get id() {
      return this._serviceId;
    }
    get(l) {
      if (!this._value) {
        if (l && (this._value = l[this._serviceId.toString()]), this._value || (this._value = this._factory(l)), !this._value)
          throw new Error("Service " + this._serviceId + " is missing!");
        e.set(this._serviceId, this._value);
      }
      return this._value;
    }
  }
  n.LazyStaticService = t;
  let i = [];
  function r(a, l) {
    let u = new t(a, l);
    return i.push(u), u;
  }
  function o(a) {
    let l = new s_();
    for (const [c, h] of Qde())
      l.set(c, h);
    for (let c in a)
      a.hasOwnProperty(c) && l.set(Vt(c), a[c]);
    i.forEach((c) => l.set(c.id, c.get(a)));
    let u = new rS(l, !0);
    return l.set(eo, u), [l, u];
  }
  n.init = o, n.instantiationService = r(eo, () => new rS(e, !0));
  const s = new P5();
  n.configurationService = r(mr, () => s), n.resourceConfigurationService = r(u5, () => new Eae(s)), n.resourcePropertiesService = r(c5, () => new DT(s)), n.contextService = r(_ae, () => new s0()), n.labelService = r(Zpe, () => new Rae()), n.telemetryService = r(p0, () => new Lae()), n.dialogService = r(_7, () => new bae()), n.notificationService = r(tl, () => new o0()), n.markerService = r(P7, () => new Tl()), n.modeService = r(TN, (a) => new kfe()), n.standaloneThemeService = r(K_, () => new ppe()), n.logService = r(H_, () => new ase(new sse())), n.undoRedoService = r(gI, (a) => new hS(n.dialogService.get(a), n.notificationService.get(a))), n.modelService = r(ro, (a) => new Jb(n.configurationService.get(a), n.resourcePropertiesService.get(a), n.standaloneThemeService.get(a), n.logService.get(a), n.undoRedoService.get(a))), n.markerDecorationsService = r(A5, (a) => new mO(n.modelService.get(a), n.markerService.get(a))), n.contextKeyService = r(Ti, (a) => new ZT(n.configurationService.get(a))), n.codeEditorService = r(pr, (a) => new Xb(null, n.contextKeyService.get(a), n.standaloneThemeService.get(a))), n.editorProgressService = r(T0, () => new r0()), n.storageService = r(pme, () => new gme()), n.editorWorkerService = r(tc, (a) => new wT(n.modelService.get(a), n.resourceConfigurationService.get(a), n.logService.get(a)));
})(Mt || (Mt = {}));
class ove extends ge {
  constructor(e, t) {
    super();
    const [i, r] = Mt.init(t);
    this._serviceCollection = i, this._instantiationService = r;
    const o = this.get(mr), s = this.get(tl), a = this.get(p0), l = this.get(Qn), u = this.get(H_), c = this.get(Ti);
    let h = (_, m) => {
      let v = null;
      return t && (v = t[_.toString()]), v || (v = m()), this._serviceCollection.set(_, v), v;
    };
    h(Is, () => new vO(c, o)), h(Zl, () => new hO(l));
    let d = h(Ko, () => new Sae(this._instantiationService)), f = h(Ro, () => this._register(new I5(c, d, a, s, u, e))), p = h(I0, () => new Tae(Mt.codeEditorService.get(pr), e));
    h(U7, () => new DO(r, Mt.codeEditorService.get(pr)));
    let g = h(xg, () => this._register(new oO(p)));
    h(R0, () => new Cme()), h(D0, () => {
      const _ = new rO(a, s, g, f, l);
      return _.configure({ blockMouse: !1 }), this._register(_);
    }), h(V5, () => new pO(d)), h(Mse, () => new Dae(Mt.modelService.get(ro)));
  }
  get(e) {
    let t = this._serviceCollection.get(e);
    if (!t)
      throw new Error("Missing service " + e);
    return t;
  }
  set(e, t) {
    this._serviceCollection.set(e, t);
  }
  has(e) {
    return this._serviceCollection.has(e);
  }
}
function $7(n, e, t) {
  let i = new ove(n, e), r = null;
  i.has(pb) || (r = new LT(Mt.modelService.get()), i.set(pb, r)), i.has(kF) || i.set(kF, new eT(i.get(pr), i.get(Ko)));
  let o = t(i);
  return r && r.setEditor(o), o;
}
function sve(n, e, t) {
  return $7(n, t || {}, (i) => new qT(n, e, i, i.get(eo), i.get(pr), i.get(Ko), i.get(Ti), i.get(Ro), i.get(xg), i.get(K_), i.get(tl), i.get(mr), i.get(Is), i.get(ro), i.get(TN)));
}
function ave(n) {
  return Mt.codeEditorService.get().onCodeEditorAdd((e) => {
    n(e);
  });
}
function lve(n, e, t) {
  return $7(n, t || {}, (i) => new YT(n, e, i, i.get(eo), i.get(Ti), i.get(Ro), i.get(xg), i.get(tc), i.get(pr), i.get(K_), i.get(tl), i.get(mr), i.get(D0), i.get(T0), i.get(R0)));
}
function uve(n, e) {
  return new Mre(n, e);
}
function cve(n, e, t) {
  return $3(Mt.modelService.get(), Mt.modeService.get(), n, e, t);
}
function hve(n, e) {
  Mt.modelService.get().setMode(n, Mt.modeService.get().create(e));
}
function dve(n, e, t) {
  n && Mt.markerService.get().changeOne(e, n.uri, t);
}
function fve(n) {
  return Mt.markerService.get().read(n);
}
function pve(n) {
  return Mt.markerService.get().onMarkerChanged(n);
}
function gve(n) {
  return Mt.modelService.get().getModel(n);
}
function mve() {
  return Mt.modelService.get().getModels();
}
function vve(n) {
  return Mt.modelService.get().onModelAdded(n);
}
function _ve(n) {
  return Mt.modelService.get().onModelRemoved(n);
}
function Cve(n) {
  return Mt.modelService.get().onModelModeChanged((e) => {
    n({
      model: e.model,
      oldLanguage: e.oldModeId
    });
  });
}
function yve(n) {
  return dse(Mt.modelService.get(), n);
}
function wve(n, e) {
  const t = Mt.standaloneThemeService.get();
  return t.registerEditorContainer(n), MN.colorizeElement(t, Mt.modeService.get(), n, e);
}
function bve(n, e, t) {
  return Mt.standaloneThemeService.get().registerEditorContainer(document.body), MN.colorize(Mt.modeService.get(), n, e, t);
}
function Sve(n, e, t = 4) {
  return Mt.standaloneThemeService.get().registerEditorContainer(document.body), MN.colorizeModelLine(n, e, t);
}
function Eve(n) {
  let e = ln.get(n);
  return e || {
    getInitialState: () => XS,
    tokenize: (t, i, r, o) => moe(n, t, r, o)
  };
}
function Lve(n, e) {
  Mt.modeService.get().triggerMode(e);
  let i = Eve(e), r = W_(n), o = [], s = i.getInitialState();
  for (let a = 0, l = r.length; a < l; a++) {
    let u = r[a], c = i.tokenize(u, !0, s, 0);
    o[a] = c.tokens, s = c.endState;
  }
  return o;
}
function Dve(n, e) {
  Mt.standaloneThemeService.get().defineTheme(n, e);
}
function Rve(n) {
  Mt.standaloneThemeService.get().setTheme(n);
}
function Tve() {
  Gae();
}
function Ove(n, e) {
  return Xn.registerCommand({ id: n, handler: e });
}
function xve() {
  return {
    // methods
    create: sve,
    onDidCreateEditor: ave,
    createDiffEditor: lve,
    createDiffNavigator: uve,
    createModel: cve,
    setModelLanguage: hve,
    setModelMarkers: dve,
    getModelMarkers: fve,
    onDidChangeMarkers: pve,
    getModels: mve,
    getModel: gve,
    onDidCreateModel: vve,
    onWillDisposeModel: _ve,
    onDidChangeModelLanguage: Cve,
    createWebWorker: yve,
    colorizeElement: wve,
    colorize: bve,
    colorizeModelLine: Sve,
    tokenize: Lve,
    defineTheme: Dve,
    setTheme: Rve,
    remeasureFonts: Tve,
    registerCommand: Ove,
    // enums
    AccessibilitySupport: sR,
    ContentWidgetPositionPreference: hR,
    CursorChangeReason: dR,
    DefaultEndOfLine: fR,
    EditorAutoIndentStrategy: gR,
    EditorOption: mR,
    EndOfLinePreference: vR,
    EndOfLineSequence: _R,
    MinimapPosition: LR,
    MouseTargetType: DR,
    OverlayWidgetPositionPreference: RR,
    OverviewRulerLane: TR,
    RenderLineNumbersType: OR,
    RenderMinimap: xR,
    ScrollbarVisibility: IR,
    ScrollType: NR,
    TextEditorCursorBlinkingStyle: kR,
    TextEditorCursorStyle: WR,
    TrackedRangeStickiness: VR,
    WrappingIndent: BR,
    // classes
    ConfigurationChangedEvent: iG,
    BareFontInfo: Hp,
    FontInfo: iT,
    TextModelResolvedOptions: ew,
    FindMatch: zv,
    // vars
    EditorType: B_,
    EditorOptions: Kd
  };
}
function Nve(n, e) {
  if (!e || !Array.isArray(e))
    return !1;
  for (const t of e)
    if (!n(t))
      return !1;
  return !0;
}
function By(n, e) {
  return typeof n == "boolean" ? n : e;
}
function HW(n, e) {
  return typeof n == "string" ? n : e;
}
function Ive(n) {
  const e = {};
  for (const t of n)
    e[t] = !0;
  return e;
}
function GW(n, e = !1) {
  e && (n = n.map(function(i) {
    return i.toLowerCase();
  }));
  const t = Ive(n);
  return e ? function(i) {
    return t[i.toLowerCase()] !== void 0 && t.hasOwnProperty(i.toLowerCase());
  } : function(i) {
    return t[i] !== void 0 && t.hasOwnProperty(i);
  };
}
function RO(n, e) {
  e = e.replace(/@@/g, "");
  let t = 0, i;
  do
    i = !1, e = e.replace(/@(\w+)/g, function(o, s) {
      i = !0;
      let a = "";
      if (typeof n[s] == "string")
        a = n[s];
      else if (n[s] && n[s] instanceof RegExp)
        a = n[s].source;
      else
        throw n[s] === void 0 ? ei(n, "language definition does not contain attribute '" + s + "', used at: " + e) : ei(n, "attribute reference '" + s + "' must be a string, used at: " + e);
      return Ff(a) ? "" : "(?:" + a + ")";
    }), t++;
  while (i && t < 5);
  e = e.replace(/\x01/g, "@");
  let r = (n.ignoreCase ? "i" : "") + (n.unicode ? "u" : "");
  return new RegExp(e, r);
}
function Pve(n, e, t, i) {
  if (i < 0)
    return n;
  if (i < e.length)
    return e[i];
  if (i >= 100) {
    i = i - 100;
    let r = t.split(".");
    if (r.unshift(t), i < r.length)
      return r[i];
  }
  return null;
}
function Ave(n, e, t, i) {
  let r = -1, o = t, s = t.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
  s && (s[3] && (r = parseInt(s[3]), s[2] && (r = r + 100)), o = s[4]);
  let a = "~", l = o;
  !o || o.length === 0 ? (a = "!=", l = "") : /^\w*$/.test(l) ? a = "==" : (s = o.match(/^(@|!@|~|!~|==|!=)(.*)$/), s && (a = s[1], l = s[2]));
  let u;
  if ((a === "~" || a === "!~") && /^(\w|\|)*$/.test(l)) {
    let c = GW(l.split("|"), n.ignoreCase);
    u = function(h) {
      return a === "~" ? c(h) : !c(h);
    };
  } else if (a === "@" || a === "!@") {
    let c = n[l];
    if (!c)
      throw ei(n, "the @ match target '" + l + "' is not defined, in rule: " + e);
    if (!Nve(function(d) {
      return typeof d == "string";
    }, c))
      throw ei(n, "the @ match target '" + l + "' must be an array of strings, in rule: " + e);
    let h = GW(c, n.ignoreCase);
    u = function(d) {
      return a === "@" ? h(d) : !h(d);
    };
  } else if (a === "~" || a === "!~")
    if (l.indexOf("$") < 0) {
      let c = RO(n, "^" + l + "$");
      u = function(h) {
        return a === "~" ? c.test(h) : !c.test(h);
      };
    } else
      u = function(c, h, d, f) {
        return RO(n, "^" + Ac(n, l, h, d, f) + "$").test(c);
      };
  else if (l.indexOf("$") < 0) {
    let c = qc(n, l);
    u = function(h) {
      return a === "==" ? h === c : h !== c;
    };
  } else {
    let c = qc(n, l);
    u = function(h, d, f, p, g) {
      let _ = Ac(n, c, d, f, p);
      return a === "==" ? h === _ : h !== _;
    };
  }
  return r === -1 ? {
    name: t,
    value: i,
    test: function(c, h, d, f) {
      return u(c, c, h, d, f);
    }
  } : {
    name: t,
    value: i,
    test: function(c, h, d, f) {
      let p = Pve(c, h, d, r);
      return u(p || "", c, h, d, f);
    }
  };
}
function TO(n, e, t) {
  if (t) {
    if (typeof t == "string")
      return t;
    if (t.token || t.token === "") {
      if (typeof t.token != "string")
        throw ei(n, "a 'token' attribute must be of type string, in rule: " + e);
      {
        let i = { token: t.token };
        if (t.token.indexOf("$") >= 0 && (i.tokenSubst = !0), typeof t.bracket == "string")
          if (t.bracket === "@open")
            i.bracket = 1;
          else if (t.bracket === "@close")
            i.bracket = -1;
          else
            throw ei(n, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + e);
        if (t.next) {
          if (typeof t.next != "string")
            throw ei(n, "the next state must be a string value in rule: " + e);
          {
            let r = t.next;
            if (!/^(@pop|@push|@popall)$/.test(r) && (r[0] === "@" && (r = r.substr(1)), r.indexOf("$") < 0 && !Ose(n, Ac(n, r, "", [], ""))))
              throw ei(n, "the next state '" + t.next + "' is not defined in rule: " + e);
            i.next = r;
          }
        }
        return typeof t.goBack == "number" && (i.goBack = t.goBack), typeof t.switchTo == "string" && (i.switchTo = t.switchTo), typeof t.log == "string" && (i.log = t.log), typeof t.nextEmbedded == "string" && (i.nextEmbedded = t.nextEmbedded, n.usesEmbedded = !0), i;
      }
    } else if (Array.isArray(t)) {
      let i = [];
      for (let r = 0, o = t.length; r < o; r++)
        i[r] = TO(n, e, t[r]);
      return { group: i };
    } else if (t.cases) {
      let i = [];
      for (let o in t.cases)
        if (t.cases.hasOwnProperty(o)) {
          const s = TO(n, e, t.cases[o]);
          o === "@default" || o === "@" || o === "" ? i.push({ test: void 0, value: s, name: o }) : o === "@eos" ? i.push({ test: function(a, l, u, c) {
            return c;
          }, value: s, name: o }) : i.push(Ave(n, e, o, s));
        }
      const r = n.defaultToken;
      return {
        test: function(o, s, a, l) {
          for (const u of i)
            if (!u.test || u.test(o, s, a, l))
              return u.value;
          return r;
        }
      };
    } else
      throw ei(n, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + e);
  } else
    return { token: "" };
}
class Mve {
  constructor(e) {
    this.regex = new RegExp(""), this.action = { token: "" }, this.matchOnlyAtLineStart = !1, this.name = "", this.name = e;
  }
  setRegex(e, t) {
    let i;
    if (typeof t == "string")
      i = t;
    else if (t instanceof RegExp)
      i = t.source;
    else
      throw ei(e, "rules must start with a match string or regular expression: " + this.name);
    this.matchOnlyAtLineStart = i.length > 0 && i[0] === "^", this.name = this.name + ": " + i, this.regex = RO(e, "^(?:" + (this.matchOnlyAtLineStart ? i.substr(1) : i) + ")");
  }
  setAction(e, t) {
    this.action = TO(e, this.name, t);
  }
}
function Fve(n, e) {
  if (!e || typeof e != "object")
    throw new Error("Monarch: expecting a language definition object");
  let t = {};
  t.languageId = n, t.includeLF = By(e.includeLF, !1), t.noThrow = !1, t.maxStack = 100, t.start = typeof e.start == "string" ? e.start : null, t.ignoreCase = By(e.ignoreCase, !1), t.unicode = By(e.unicode, !1), t.tokenPostfix = HW(e.tokenPostfix, "." + t.languageId), t.defaultToken = HW(e.defaultToken, "source"), t.usesEmbedded = !1;
  let i = e;
  i.languageId = n, i.includeLF = t.includeLF, i.ignoreCase = t.ignoreCase, i.unicode = t.unicode, i.noThrow = t.noThrow, i.usesEmbedded = t.usesEmbedded, i.stateNames = e.tokenizer, i.defaultToken = t.defaultToken;
  function r(s, a, l) {
    for (const u of l) {
      let c = u.include;
      if (c) {
        if (typeof c != "string")
          throw ei(t, "an 'include' attribute must be a string at: " + s);
        if (c[0] === "@" && (c = c.substr(1)), !e.tokenizer[c])
          throw ei(t, "include target '" + c + "' is not defined at: " + s);
        r(s + "." + c, a, e.tokenizer[c]);
      } else {
        const h = new Mve(s);
        if (Array.isArray(u) && u.length >= 1 && u.length <= 3)
          if (h.setRegex(i, u[0]), u.length >= 3)
            if (typeof u[1] == "string")
              h.setAction(i, { token: u[1], next: u[2] });
            else if (typeof u[1] == "object") {
              const d = u[1];
              d.next = u[2], h.setAction(i, d);
            } else
              throw ei(t, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + s);
          else
            h.setAction(i, u[1]);
        else {
          if (!u.regex)
            throw ei(t, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + s);
          u.name && typeof u.name == "string" && (h.name = u.name), u.matchOnlyAtStart && (h.matchOnlyAtLineStart = By(u.matchOnlyAtLineStart, !1)), h.setRegex(i, u.regex), h.setAction(i, u.action);
        }
        a.push(h);
      }
    }
  }
  if (!e.tokenizer || typeof e.tokenizer != "object")
    throw ei(t, "a language definition must define the 'tokenizer' attribute as an object");
  t.tokenizer = [];
  for (let s in e.tokenizer)
    if (e.tokenizer.hasOwnProperty(s)) {
      t.start || (t.start = s);
      const a = e.tokenizer[s];
      t.tokenizer[s] = new Array(), r("tokenizer." + s, t.tokenizer[s], a);
    }
  if (t.usesEmbedded = i.usesEmbedded, e.brackets) {
    if (!Array.isArray(e.brackets))
      throw ei(t, "the 'brackets' attribute must be defined as an array");
  } else
    e.brackets = [
      { open: "{", close: "}", token: "delimiter.curly" },
      { open: "[", close: "]", token: "delimiter.square" },
      { open: "(", close: ")", token: "delimiter.parenthesis" },
      { open: "<", close: ">", token: "delimiter.angle" }
    ];
  let o = [];
  for (let s of e.brackets) {
    let a = s;
    if (a && Array.isArray(a) && a.length === 3 && (a = { token: a[2], open: a[0], close: a[1] }), a.open === a.close)
      throw ei(t, "open and close brackets in a 'brackets' attribute must be different: " + a.open + `
 hint: use the 'bracket' attribute if matching on equal brackets is required.`);
    if (typeof a.open == "string" && typeof a.token == "string" && typeof a.close == "string")
      o.push({
        token: a.token + t.tokenPostfix,
        open: qc(t, a.open),
        close: qc(t, a.close)
      });
    else
      throw ei(t, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
  }
  return t.brackets = o, t.noThrow = !0, t;
}
function kve(n) {
  vd.registerLanguage(n);
}
function Wve() {
  let n = [];
  return n = n.concat(vd.getLanguages()), n;
}
function Vve(n) {
  let e = Mt.modeService.get().getLanguageIdentifier(n);
  return e ? e.id : 0;
}
function Bve(n, e) {
  let t = Mt.modeService.get().onDidCreateMode((i) => {
    i.getId() === n && (t.dispose(), e());
  });
  return t;
}
function Hve(n, e) {
  let t = Mt.modeService.get().getLanguageIdentifier(n);
  if (!t)
    throw new Error(`Cannot set configuration for unknown language ${n}`);
  return ui.register(t, e, 100);
}
class Gve {
  constructor(e, t) {
    this._languageIdentifier = e, this._actual = t;
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  tokenize(e, t, i, r) {
    if (typeof this._actual.tokenize == "function")
      return g_.adaptTokenize(this._languageIdentifier.language, this._actual, e, i, r);
    throw new Error("Not supported!");
  }
  tokenize2(e, t, i) {
    let r = this._actual.tokenizeEncoded(e, i);
    return new zS(r.tokens, r.endState);
  }
}
class g_ {
  constructor(e, t, i) {
    this._standaloneThemeService = e, this._languageIdentifier = t, this._actual = i;
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  static _toClassicTokens(e, t, i) {
    let r = [], o = 0;
    for (let s = 0, a = e.length; s < a; s++) {
      const l = e[s];
      let u = l.startIndex;
      s === 0 ? u = 0 : u < o && (u = o), r[s] = new US(u + i, l.scopes, t), o = u;
    }
    return r;
  }
  static adaptTokenize(e, t, i, r, o) {
    let s = t.tokenize(i, r), a = g_._toClassicTokens(s.tokens, e, o), l;
    return s.endState.equals(r) ? l = r : l = s.endState, new uN(a, l);
  }
  tokenize(e, t, i, r) {
    return g_.adaptTokenize(this._languageIdentifier.language, this._actual, e, i, r);
  }
  _toBinaryTokens(e, t) {
    const i = this._languageIdentifier.id, r = this._standaloneThemeService.getColorTheme().tokenTheme;
    let o = [], s = 0, a = 0;
    for (let u = 0, c = e.length; u < c; u++) {
      const h = e[u], d = r.match(i, h.scopes);
      if (s > 0 && o[s - 1] === d)
        continue;
      let f = h.startIndex;
      u === 0 ? f = 0 : f < a && (f = a), o[s++] = f + t, o[s++] = d, a = f;
    }
    let l = new Uint32Array(s);
    for (let u = 0; u < s; u++)
      l[u] = o[u];
    return l;
  }
  tokenize2(e, t, i, r) {
    let o = this._actual.tokenize(e, i), s = this._toBinaryTokens(o.tokens, r), a;
    return o.endState.equals(i) ? a = i : a = o.endState, new zS(s, a);
  }
}
function Uve(n) {
  return "tokenizeEncoded" in n;
}
function K7(n) {
  return n && typeof n.then == "function";
}
function zve(n) {
  if (n) {
    const e = [null];
    for (let t = 1, i = n.length; t < i; t++)
      e[t] = ee.fromHex(n[t]);
    Mt.standaloneThemeService.get().setColorMapOverride(e);
  } else
    Mt.standaloneThemeService.get().setColorMapOverride(null);
}
function jve(n, e) {
  let t = Mt.modeService.get().getLanguageIdentifier(n);
  if (!t)
    throw new Error(`Cannot set tokens provider for unknown language ${n}`);
  const i = (r) => Uve(r) ? new Gve(t, r) : new g_(Mt.standaloneThemeService.get(), t, r);
  return K7(e) ? ln.registerPromise(n, e.then((r) => i(r))) : ln.register(n, i(e));
}
function $ve(n, e) {
  const t = (i) => Ise(Mt.modeService.get(), Mt.standaloneThemeService.get(), n, Fve(n, i));
  return K7(e) ? ln.registerPromise(n, e.then((i) => t(i))) : ln.register(n, t(e));
}
function Kve(n, e) {
  return nT.register(n, e);
}
function qve(n, e) {
  return rT.register(n, e);
}
function Yve(n, e) {
  return oT.register(n, e);
}
function Xve(n, e) {
  return sT.register(n, {
    provideHover: (t, i, r) => {
      let o = t.getWordAtPosition(i);
      return Promise.resolve(e.provideHover(t, i, r)).then((s) => {
        if (s)
          return !s.range && o && (s.range = new V(i.lineNumber, o.startColumn, i.lineNumber, o.endColumn)), s.range || (s.range = new V(i.lineNumber, i.column, i.lineNumber, i.column)), s;
      });
    }
  });
}
function Zve(n, e) {
  return aT.register(n, e);
}
function Qve(n, e) {
  return lT.register(n, e);
}
function Jve(n, e) {
  return hoe.register(n, e);
}
function e_e(n, e) {
  return uT.register(n, e);
}
function t_e(n, e) {
  return hT.register(n, e);
}
function i_e(n, e) {
  return dT.register(n, e);
}
function n_e(n, e) {
  return fT.register(n, e);
}
function r_e(n, e) {
  return pT.register(n, {
    provideCodeActions: (t, i, r, o) => {
      let s = Mt.markerService.get().read({ resource: t.uri }).filter((a) => V.areIntersectingOrTouching(a, i));
      return e.provideCodeActions(t, i, { markers: s, only: r.only }, o);
    }
  });
}
function o_e(n, e) {
  return av.register(n, e);
}
function s_e(n, e) {
  return Au.register(n, e);
}
function a_e(n, e) {
  return ZG.register(n, e);
}
function l_e(n, e) {
  return QG.register(n, e);
}
function u_e(n, e) {
  return hb.register(n, e);
}
function c_e(n, e) {
  return doe.register(n, e);
}
function h_e(n, e) {
  return poe.register(n, e);
}
function d_e(n, e) {
  return cT.register(n, e);
}
function f_e(n, e) {
  return foe.register(n, e);
}
function p_e(n, e) {
  return db.register(n, e);
}
function g_e(n, e) {
  return JG.register(n, e);
}
function m_e(n, e) {
  return coe.register(n, e);
}
function v_e() {
  return {
    register: kve,
    getLanguages: Wve,
    onLanguage: Bve,
    getEncodedLanguageId: Vve,
    // provider methods
    setLanguageConfiguration: Hve,
    setColorMap: zve,
    setTokensProvider: jve,
    setMonarchTokensProvider: $ve,
    registerReferenceProvider: Kve,
    registerRenameProvider: qve,
    registerCompletionItemProvider: u_e,
    registerSignatureHelpProvider: Yve,
    registerHoverProvider: Xve,
    registerDocumentSymbolProvider: Zve,
    registerDocumentHighlightProvider: Qve,
    registerLinkedEditingRangeProvider: Jve,
    registerDefinitionProvider: e_e,
    registerImplementationProvider: t_e,
    registerTypeDefinitionProvider: i_e,
    registerCodeLensProvider: n_e,
    registerCodeActionProvider: r_e,
    registerDocumentFormattingEditProvider: o_e,
    registerDocumentRangeFormattingEditProvider: s_e,
    registerOnTypeFormattingEditProvider: a_e,
    registerLinkProvider: l_e,
    registerColorProvider: c_e,
    registerFoldingRangeProvider: h_e,
    registerDeclarationProvider: d_e,
    registerSelectionRangeProvider: f_e,
    registerDocumentSemanticTokensProvider: p_e,
    registerDocumentRangeSemanticTokensProvider: g_e,
    registerInlineCompletionsProvider: m_e,
    // enums
    DocumentHighlightKind: pR,
    CompletionItemKind: lR,
    CompletionItemTag: uR,
    CompletionItemInsertTextRule: aR,
    SymbolKind: MR,
    SymbolTag: FR,
    IndentAction: CR,
    CompletionTriggerKind: cR,
    SignatureHelpTriggerKind: AR,
    InlayHintKind: yR,
    InlineCompletionTriggerKind: wR,
    // classes
    FoldingRangeKind: Od
  };
}
class m_ {
  static _handleEolEdits(e, t) {
    let i, r = [];
    for (let o of t)
      typeof o.eol == "number" && (i = o.eol), o.range && typeof o.text == "string" && r.push(o);
    return typeof i == "number" && e.hasModel() && e.getModel().pushEOL(i), r;
  }
  static _isFullModelReplaceEdit(e, t) {
    if (!e.hasModel())
      return !1;
    const i = e.getModel(), r = i.validateRange(t.range);
    return i.getFullModelRange().equalsRange(r);
  }
  static execute(e, t, i) {
    i && e.pushUndoStop();
    const r = m_._handleEolEdits(e, t);
    r.length === 1 && m_._isFullModelReplaceEdit(e, r[0]) ? e.executeEdits("formatEditsCommand", r.map((o) => ST.replace(V.lift(o.range), o.text))) : e.executeEdits("formatEditsCommand", r.map((o) => ST.replaceMove(V.lift(o.range), o.text))), i && e.pushUndoStop();
  }
}
class r1 {
  constructor(e) {
    this.value = e, this._lower = e.toLowerCase();
  }
  /**
   * Gives the value by which to index (for equality).
   */
  static toKey(e) {
    return typeof e == "string" ? e.toLowerCase() : e._lower;
  }
}
var tf = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function q7(n) {
  if (n = n.filter((r) => r.range), !n.length)
    return;
  let { range: e } = n[0];
  for (let r = 1; r < n.length; r++)
    e = V.plusRange(e, n[r].range);
  const { startLineNumber: t, endLineNumber: i } = e;
  t === i ? n.length === 1 ? ed(w("hint11", "Made 1 formatting edit on line {0}", t)) : ed(w("hintn1", "Made {0} formatting edits on line {1}", n.length, t)) : n.length === 1 ? ed(w("hint1n", "Made 1 formatting edit between lines {0} and {1}", t, i)) : ed(w("hintnn", "Made {0} formatting edits between lines {1} and {2}", n.length, t, i));
}
function Y7(n) {
  const e = [], t = /* @__PURE__ */ new Set(), i = av.ordered(n);
  for (const o of i)
    e.push(o), o.extensionId && t.add(r1.toKey(o.extensionId));
  const r = Au.ordered(n);
  for (const o of r) {
    if (o.extensionId) {
      if (t.has(r1.toKey(o.extensionId)))
        continue;
      t.add(r1.toKey(o.extensionId));
    }
    e.push({
      displayName: o.displayName,
      extensionId: o.extensionId,
      provideDocumentFormattingEdits(s, a, l) {
        return o.provideDocumentRangeFormattingEdits(s, s.getFullModelRange(), a, l);
      }
    });
  }
  return e;
}
class Hd {
  static setFormatterSelector(e) {
    return { dispose: Hd._selectors.unshift(e) };
  }
  static select(e, t, i) {
    return tf(this, void 0, void 0, function* () {
      if (e.length === 0)
        return;
      const r = _t.first(Hd._selectors);
      if (r)
        return yield r(e, t, i);
    });
  }
}
Hd._selectors = new ua();
function bwe(n, e, t, i, r, o) {
  return tf(this, void 0, void 0, function* () {
    const s = n.get(eo), a = ih(e) ? e.getModel() : e, l = Au.ordered(a), u = yield Hd.select(l, a, i);
    u && (r.report(u), yield s.invokeFunction(__e, u, e, t, o));
  });
}
function __e(n, e, t, i, r) {
  return tf(this, void 0, void 0, function* () {
    const o = n.get(tc);
    let s, a;
    ih(t) ? (s = t.getModel(), a = new F3(t, 5, void 0, r)) : (s = t, a = new k3(t, r));
    let l = [], u = 0;
    for (let h of rse(i).sort(V.compareRangesUsingStarts))
      u > 0 && V.areIntersectingOrTouching(l[u - 1], h) ? l[u - 1] = V.fromPositions(l[u - 1].getStartPosition(), h.getEndPosition()) : u = l.push(h);
    const c = [];
    for (let h of l)
      try {
        const d = yield e.provideDocumentRangeFormattingEdits(s, h, s.getFormattingOptions(), a.token), f = yield o.computeMoreMinimalEdits(s.uri, d);
        if (f && c.push(...f), a.token.isCancellationRequested)
          return !0;
      } finally {
        a.dispose();
      }
    if (c.length === 0)
      return !1;
    if (ih(t))
      m_.execute(t, c, !0), q7(c), t.revealPositionInCenterIfOutsideViewport(
        t.getPosition(),
        1
        /* Immediate */
      );
    else {
      const [{ range: h }] = c, d = new Ut(h.startLineNumber, h.startColumn, h.endLineNumber, h.endColumn);
      s.pushEditOperations([d], c.map((f) => ({
        text: f.text,
        range: V.lift(f.range),
        forceMoveMarkers: !0
      })), (f) => {
        for (const { range: p } of f)
          if (V.areIntersectingOrTouching(p, d))
            return [new Ut(p.startLineNumber, p.startColumn, p.endLineNumber, p.endColumn)];
        return null;
      });
    }
    return !0;
  });
}
function Swe(n, e, t, i, r) {
  return tf(this, void 0, void 0, function* () {
    const o = n.get(eo), s = ih(e) ? e.getModel() : e, a = Y7(s), l = yield Hd.select(a, s, t);
    l && (i.report(l), yield o.invokeFunction(C_e, l, e, t, r));
  });
}
function C_e(n, e, t, i, r) {
  return tf(this, void 0, void 0, function* () {
    const o = n.get(tc);
    let s, a;
    ih(t) ? (s = t.getModel(), a = new F3(t, 5, void 0, r)) : (s = t, a = new k3(t, r));
    let l;
    try {
      const u = yield e.provideDocumentFormattingEdits(s, s.getFormattingOptions(), a.token);
      if (l = yield o.computeMoreMinimalEdits(s.uri, u), a.token.isCancellationRequested)
        return !0;
    } finally {
      a.dispose();
    }
    if (!l || l.length === 0)
      return !1;
    if (ih(t))
      m_.execute(
        t,
        l,
        i !== 2
        /* Silent */
      ), i !== 2 && (q7(l), t.revealPositionInCenterIfOutsideViewport(
        t.getPosition(),
        1
        /* Immediate */
      ));
    else {
      const [{ range: u }] = l, c = new Ut(u.startLineNumber, u.startColumn, u.endLineNumber, u.endColumn);
      s.pushEditOperations([c], l.map((h) => ({
        text: h.text,
        range: V.lift(h.range),
        forceMoveMarkers: !0
      })), (h) => {
        for (const { range: d } of h)
          if (V.areIntersectingOrTouching(d, c))
            return [new Ut(d.startLineNumber, d.startColumn, d.endLineNumber, d.endColumn)];
        return null;
      });
    }
    return !0;
  });
}
function y_e(n, e, t, i, r) {
  return tf(this, void 0, void 0, function* () {
    const o = Au.ordered(e);
    for (const s of o) {
      let a = yield Promise.resolve(s.provideDocumentRangeFormattingEdits(e, t, i, r)).catch(N_);
      if (NN(a))
        return yield n.computeMoreMinimalEdits(e.uri, a);
    }
  });
}
function w_e(n, e, t, i) {
  return tf(this, void 0, void 0, function* () {
    const r = Y7(e);
    for (const o of r) {
      let s = yield Promise.resolve(o.provideDocumentFormattingEdits(e, t, i)).catch(N_);
      if (NN(s))
        return yield n.computeMoreMinimalEdits(e.uri, s);
    }
  });
}
function b_e(n, e, t, i, r) {
  const o = ZG.ordered(e);
  return o.length === 0 || o[0].autoFormatTriggerCharacters.indexOf(i) < 0 ? Promise.resolve(void 0) : Promise.resolve(o[0].provideOnTypeFormattingEdits(e, t, i, r, zo.None)).catch(N_).then((s) => n.computeMoreMinimalEdits(e.uri, s));
}
Xn.registerCommand("_executeFormatRangeProvider", function(n, ...e) {
  const [t, i, r] = e;
  Uo(dt.isUri(t)), Uo(V.isIRange(i));
  const o = n.get(ro).getModel(t);
  if (!o)
    throw P_("resource");
  return y_e(n.get(tc), o, V.lift(i), r, zo.None);
});
Xn.registerCommand("_executeFormatDocumentProvider", function(n, ...e) {
  const [t, i] = e;
  Uo(dt.isUri(t));
  const r = n.get(ro).getModel(t);
  if (!r)
    throw P_("resource");
  return w_e(n.get(tc), r, i, zo.None);
});
Xn.registerCommand("_executeFormatOnTypeProvider", function(n, ...e) {
  const [t, i, r, o] = e;
  Uo(dt.isUri(t)), Uo(J.isIPosition(i)), Uo(typeof r == "string");
  const s = n.get(ro).getModel(t);
  if (!s)
    throw P_("resource");
  return b_e(n.get(tc), s, J.lift(i), r, o);
});
var o1;
Kd.wrappingIndent.defaultValue = 0;
Kd.glyphMargin.defaultValue = !1;
Kd.autoIndent.defaultValue = 3;
Kd.overviewRulerLanes.defaultValue = 2;
Hd.setFormatterSelector((n, e, t) => Promise.resolve(n[0]));
const Fr = fG();
Fr.editor = xve();
Fr.languages = v_e();
const Ewe = Fr.CancellationTokenSource, Lwe = Fr.Emitter, Dwe = Fr.KeyCode, Rwe = Fr.KeyMod, Twe = Fr.Position, Owe = Fr.Range, xwe = Fr.Selection, Nwe = Fr.SelectionDirection, Iwe = Fr.MarkerSeverity, Pwe = Fr.MarkerTag, Awe = Fr.Uri, Mwe = Fr.Token, Fwe = Fr.editor, Hy = Fr.languages;
(!((o1 = gn.MonacoEnvironment) === null || o1 === void 0) && o1.globalAPI || typeof define == "function" && define.amd) && (self.monaco = Fr);
typeof self.require < "u" && typeof self.require.config == "function" && self.require.config({
  ignoreDuplicateModules: [
    "vscode-languageserver-types",
    "vscode-languageserver-types/main",
    "vscode-languageserver-textdocument",
    "vscode-languageserver-textdocument/main",
    "vscode-nls",
    "vscode-nls/vscode-nls",
    "jsonc-parser",
    "jsonc-parser/main",
    "vscode-uri",
    "vscode-uri/index",
    "vs/basic-languages/typescript/typescript"
  ]
});
var X7 = {}, s1 = {}, S_e = (
  /** @class */
  function() {
    function n(e) {
      var t = this;
      this._languageId = e, this._loadingTriggered = !1, this._lazyLoadPromise = new Promise(function(i, r) {
        t._lazyLoadPromiseResolve = i, t._lazyLoadPromiseReject = r;
      });
    }
    return n.getOrCreate = function(e) {
      return s1[e] || (s1[e] = new n(e)), s1[e];
    }, n.prototype.whenLoaded = function() {
      return this._lazyLoadPromise;
    }, n.prototype.load = function() {
      var e = this;
      return this._loadingTriggered || (this._loadingTriggered = !0, X7[this._languageId].loader().then(function(t) {
        return e._lazyLoadPromiseResolve(t);
      }, function(t) {
        return e._lazyLoadPromiseReject(t);
      })), this._lazyLoadPromise;
    }, n;
  }()
);
function E_e(n) {
  var e = n.id;
  X7[e] = n, Hy.register(n);
  var t = S_e.getOrCreate(e);
  Hy.setMonarchTokensProvider(e, t.whenLoaded().then(function(i) {
    return i.language;
  })), Hy.onLanguage(e, function() {
    t.load().then(function(i) {
      Hy.setLanguageConfiguration(e, i.conf);
    });
  });
}
E_e({
  id: "graphql",
  extensions: [".graphql", ".gql"],
  aliases: ["GraphQL", "graphql", "gql"],
  mimetypes: ["application/graphql"],
  loader: function() {
    return Promise.resolve().then(() => R_e);
  }
});
var L_e = {
  comments: {
    lineComment: "#"
  },
  brackets: [
    ["{", "}"],
    ["[", "]"],
    ["(", ")"]
  ],
  autoClosingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: '"""', close: '"""', notIn: ["string", "comment"] },
    { open: '"', close: '"', notIn: ["string", "comment"] }
  ],
  surroundingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: '"""', close: '"""' },
    { open: '"', close: '"' }
  ],
  folding: {
    offSide: !0
  }
}, D_e = {
  // Set defaultToken to invalid to see what you do not tokenize yet
  defaultToken: "invalid",
  tokenPostfix: ".gql",
  keywords: [
    "null",
    "true",
    "false",
    "query",
    "mutation",
    "subscription",
    "extend",
    "schema",
    "directive",
    "scalar",
    "type",
    "interface",
    "union",
    "enum",
    "input",
    "implements",
    "fragment",
    "on"
  ],
  typeKeywords: ["Int", "Float", "String", "Boolean", "ID"],
  directiveLocations: [
    "SCHEMA",
    "SCALAR",
    "OBJECT",
    "FIELD_DEFINITION",
    "ARGUMENT_DEFINITION",
    "INTERFACE",
    "UNION",
    "ENUM",
    "ENUM_VALUE",
    "INPUT_OBJECT",
    "INPUT_FIELD_DEFINITION",
    "QUERY",
    "MUTATION",
    "SUBSCRIPTION",
    "FIELD",
    "FRAGMENT_DEFINITION",
    "FRAGMENT_SPREAD",
    "INLINE_FRAGMENT",
    "VARIABLE_DEFINITION"
  ],
  operators: ["=", "!", "?", ":", "&", "|"],
  // we include these common regular expressions
  symbols: /[=!?:&|]+/,
  // https://facebook.github.io/graphql/draft/#sec-String-Value
  escapes: /\\(?:["\\\/bfnrt]|u[0-9A-Fa-f]{4})/,
  // The main tokenizer for our languages
  tokenizer: {
    root: [
      // fields and argument names
      [
        /[a-z_][\w$]*/,
        {
          cases: {
            "@keywords": "keyword",
            "@default": "key.identifier"
          }
        }
      ],
      // identify typed input variables
      [
        /[$][\w$]*/,
        {
          cases: {
            "@keywords": "keyword",
            "@default": "argument.identifier"
          }
        }
      ],
      // to show class names nicely
      [
        /[A-Z][\w\$]*/,
        {
          cases: {
            "@typeKeywords": "keyword",
            "@default": "type.identifier"
          }
        }
      ],
      // whitespace
      { include: "@whitespace" },
      // delimiters and operators
      [/[{}()\[\]]/, "@brackets"],
      [/@symbols/, { cases: { "@operators": "operator", "@default": "" } }],
      // @ annotations.
      // As an example, we emit a debugging log message on these tokens.
      // Note: message are supressed during the first load -- change some lines to see them.
      [/@\s*[a-zA-Z_\$][\w\$]*/, { token: "annotation", log: "annotation token: $0" }],
      // numbers
      [/\d*\.\d+([eE][\-+]?\d+)?/, "number.float"],
      [/0[xX][0-9a-fA-F]+/, "number.hex"],
      [/\d+/, "number"],
      // delimiter: after number because of .\d floats
      [/[;,.]/, "delimiter"],
      [/"""/, { token: "string", next: "@mlstring", nextEmbedded: "markdown" }],
      // strings
      [/"([^"\\]|\\.)*$/, "string.invalid"],
      [/"/, { token: "string.quote", bracket: "@open", next: "@string" }]
    ],
    mlstring: [
      [/[^"]+/, "string"],
      ['"""', { token: "string", next: "@pop", nextEmbedded: "@pop" }]
    ],
    string: [
      [/[^\\"]+/, "string"],
      [/@escapes/, "string.escape"],
      [/\\./, "string.escape.invalid"],
      [/"/, { token: "string.quote", bracket: "@close", next: "@pop" }]
    ],
    whitespace: [
      [/[ \t\r\n]+/, ""],
      [/#.*$/, "comment"]
    ]
  }
};
const R_e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  conf: L_e,
  language: D_e
}, Symbol.toStringTag, { value: "Module" }));
export {
  Mn as $,
  R as A,
  Ke as B,
  ea as C,
  P_ as D,
  I as E,
  B_e as F,
  Ve as G,
  Kye as H,
  it as I,
  Ti as J,
  U5 as K,
  Z_e as L,
  ct as M,
  ES as N,
  G_e as O,
  Ee as P,
  wo as Q,
  H_e as R,
  G5 as S,
  Ut as T,
  w as U,
  ed as V,
  G_ as W,
  Le as X,
  Xie as Y,
  Q as Z,
  Sd as _,
  W_e as a,
  pCe as a$,
  Rm as a0,
  Uv as a1,
  _a as a2,
  dv as a3,
  si as a4,
  ge as a5,
  to as a6,
  V as a7,
  J as a8,
  Lye as a9,
  Ze as aA,
  Kie as aB,
  ec as aC,
  Cue as aD,
  Vl as aE,
  vue as aF,
  _ue as aG,
  D0 as aH,
  Ro as aI,
  HS as aJ,
  Yd as aK,
  ja as aL,
  Wl as aM,
  j as aN,
  Vi as aO,
  ri as aP,
  aCe as aQ,
  ye as aR,
  Kr as aS,
  Uu as aT,
  dye as aU,
  fye as aV,
  zN as aW,
  m0 as aX,
  eo as aY,
  Ni as aZ,
  mG as a_,
  Dye as aa,
  At as ab,
  go as ac,
  iv as ad,
  Qr as ae,
  GN as af,
  pr as ag,
  R0 as ah,
  BS as ai,
  Mb as aj,
  aue as ak,
  Xn as al,
  dt as am,
  ro as an,
  zo as ao,
  ffe as ap,
  k3 as aq,
  I_ as ar,
  N_ as as,
  pT as at,
  Gu as au,
  PCe as av,
  ise as aw,
  NN as ax,
  ht as ay,
  Lg as az,
  V_e as b,
  fa as b$,
  P7 as b0,
  T0 as b1,
  Mse as b2,
  Ko as b3,
  p0 as b4,
  tl as b5,
  _5 as b6,
  hr as b7,
  Bp as b8,
  Uo as b9,
  Be as bA,
  HG as bB,
  vi as bC,
  Eo as bD,
  fCe as bE,
  Lre as bF,
  Qn as bG,
  Is as bH,
  Kb as bI,
  ch as bJ,
  ee as bK,
  Gh as bL,
  us as bM,
  TG as bN,
  wF as bO,
  W7 as bP,
  WN as bQ,
  Li as bR,
  gi as bS,
  Ki as bT,
  yv as bU,
  V3 as bV,
  $f as bW,
  Rs as bX,
  yt as bY,
  T5 as bZ,
  Ga as b_,
  fT as ba,
  Eye as bb,
  uye as bc,
  Ev as bd,
  Xe as be,
  KS as bf,
  Vt as bg,
  pme as bh,
  yN as bi,
  $R as bj,
  Xp as bk,
  DW as bl,
  A3 as bm,
  LCe as bn,
  Bre as bo,
  Os as bp,
  dN as bq,
  jR as br,
  Ri as bs,
  fI as bt,
  U7 as bu,
  doe as bv,
  mr as bw,
  xt as bx,
  T3 as by,
  Ie as bz,
  Ne as c,
  z5 as c$,
  Hv as c0,
  NT as c1,
  M5 as c2,
  Mae as c3,
  dr as c4,
  xs as c5,
  Jr as c6,
  Qp as c7,
  Ts as c8,
  NG as c9,
  B7 as cA,
  _Ce as cB,
  mwe as cC,
  PG as cD,
  Ae as cE,
  ca as cF,
  qye as cG,
  Pne as cH,
  MF as cI,
  ECe as cJ,
  Aye as cK,
  TN as cL,
  ln as cM,
  BCe as cN,
  sT as cO,
  rse as cP,
  Tye as cQ,
  Rye as cR,
  io as cS,
  zp as cT,
  Zr as cU,
  PN as cV,
  Sg as cW,
  fs as cX,
  Kt as cY,
  kG as cZ,
  _N as c_,
  bF as ca,
  pn as cb,
  wye as cc,
  bye as cd,
  Sye as ce,
  kF as cf,
  V5 as cg,
  Zpe as ch,
  vs as ci,
  u2 as cj,
  xue as ck,
  uw as cl,
  JN as cm,
  Zc as cn,
  u3 as co,
  bp as cp,
  KCe as cq,
  R3 as cr,
  yi as cs,
  W_ as ct,
  tse as cu,
  XR as cv,
  ua as cw,
  Og as cx,
  A5 as cy,
  EW as cz,
  U_e as d,
  n0 as d$,
  j5 as d0,
  m2 as d1,
  KF as d2,
  ST as d3,
  coe as d4,
  Pr as d5,
  TF as d6,
  uG as d7,
  ane as d8,
  mCe as d9,
  Gv as dA,
  jn as dB,
  fd as dC,
  Ua as dD,
  A2 as dE,
  uCe as dF,
  EG as dG,
  sb as dH,
  gCe as dI,
  Y3 as dJ,
  Nme as dK,
  jye as dL,
  RCe as dM,
  Bl as dN,
  bD as dO,
  j_ as dP,
  cce as dQ,
  hce as dR,
  SD as dS,
  rce as dT,
  Jd as dU,
  xl as dV,
  ig as dW,
  Kp as dX,
  Pa as dY,
  qCe as dZ,
  xCe as d_,
  Zne as da,
  ui as db,
  pye as dc,
  gye as dd,
  mye as de,
  vye as df,
  _ae as dg,
  mne as dh,
  ICe as di,
  pb as dj,
  hb as dk,
  yg as dl,
  $ie as dm,
  _d as dn,
  H_ as dp,
  TCe as dq,
  ov as dr,
  iS as ds,
  $ye as dt,
  DF as du,
  zye as dv,
  ak as dw,
  nse as dx,
  tc as dy,
  uh as dz,
  kt as e,
  pue as e$,
  Bo as e0,
  vG as e1,
  aN as e2,
  Ft as e3,
  S0 as e4,
  _ne as e5,
  s2 as e6,
  Yf as e7,
  Fne as e8,
  lCe as e9,
  oye as eA,
  aye as eB,
  sye as eC,
  lye as eD,
  Es as eE,
  xg as eF,
  k_ as eG,
  _g as eH,
  Gp as eI,
  _ye as eJ,
  yye as eK,
  dCe as eL,
  NCe as eM,
  xf as eN,
  jce as eO,
  Vo as eP,
  YCe as eQ,
  ZCe as eR,
  XCe as eS,
  wG as eT,
  zu as eU,
  Fb as eV,
  vwe as eW,
  cN as eX,
  $S as eY,
  qR as eZ,
  Gne as e_,
  yCe as ea,
  yo as eb,
  jo as ec,
  uT as ed,
  cT as ee,
  hT as ef,
  dT as eg,
  nT as eh,
  AW as ei,
  Yye as ej,
  Bd as ek,
  gI as el,
  ime as em,
  gW as en,
  bW as eo,
  iwe as ep,
  Zl as eq,
  cp as er,
  ih as es,
  UCe as et,
  F3 as eu,
  oCe as ev,
  OCe as ew,
  wne as ex,
  Kf as ey,
  $T as ez,
  q as f,
  u5 as f$,
  gue as f0,
  mue as f1,
  yue as f2,
  wue as f3,
  bue as f4,
  Sue as f5,
  Eue as f6,
  Lue as f7,
  CG as f8,
  Fye as f9,
  bwe as fA,
  Swe as fB,
  aT as fC,
  _t as fD,
  Fc as fE,
  QF as fF,
  hye as fG,
  cye as fH,
  Vv as fI,
  wg as fJ,
  Ln as fK,
  xye as fL,
  ki as fM,
  hoe as fN,
  OF as fO,
  sCe as fP,
  QG as fQ,
  XL as fR,
  vCe as fS,
  lT as fT,
  Cye as fU,
  rr as fV,
  OT as fW,
  qF as fX,
  oT as fY,
  rCe as fZ,
  CCe as f_,
  SG as fa,
  o2 as fb,
  eye as fc,
  tye as fd,
  nye as fe,
  iye as ff,
  rye as fg,
  jCe as fh,
  QCe as fi,
  GCe as fj,
  VCe as fk,
  fr as fl,
  Sp as fm,
  $Ce as fn,
  poe as fo,
  Od as fp,
  Ls as fq,
  V_ as fr,
  Za as fs,
  Tre as ft,
  ub as fu,
  ZG as fv,
  b_e as fw,
  m_ as fx,
  q7 as fy,
  Au as fz,
  Ed as g,
  zW as g$,
  Zn as g0,
  Eg as g1,
  rT as g2,
  Jh as g3,
  Eu as g4,
  foe as g5,
  HCe as g6,
  _k as g7,
  _7 as g8,
  JG as g9,
  Ase as gA,
  Oye as gB,
  Dk as gC,
  Zy as gD,
  hCe as gE,
  cCe as gF,
  XF as gG,
  Ok as gH,
  s7 as gI,
  Spe as gJ,
  Uye as gK,
  yI as gL,
  Bpe as gM,
  Tk as gN,
  xk as gO,
  Ewe as gP,
  Dwe as gQ,
  Rwe as gR,
  Iwe as gS,
  Pwe as gT,
  Twe as gU,
  Owe as gV,
  xwe as gW,
  Nwe as gX,
  Mwe as gY,
  Awe as gZ,
  Fwe as g_,
  i7 as ga,
  q2 as gb,
  t7 as gc,
  Vfe as gd,
  c3 as ge,
  JCe as gf,
  YF as gg,
  Ode as gh,
  ewe as gi,
  jp as gj,
  Kd as gk,
  Ot as gl,
  st as gm,
  Nye as gn,
  bt as go,
  Ek as gp,
  Gme as gq,
  K_ as gr,
  Lk as gs,
  XS as gt,
  moe as gu,
  e5 as gv,
  ra as gw,
  z7 as gx,
  Rk as gy,
  MCe as gz,
  vx as h,
  nV as h0,
  K1 as h1,
  M_e as h2,
  v_ as h3,
  N_e as h4,
  X_e as h5,
  F_e as h6,
  A_e as h7,
  k_e as h8,
  fi as i,
  we as j,
  Lo as k,
  B1 as l,
  Y_e as m,
  K_e as n,
  $_e as o,
  q_e as p,
  pt as q,
  I_e as r,
  j_e as s,
  IS as t,
  __ as u,
  P_e as v,
  Q_e as w,
  Hy as x,
  Lwe as y,
  E_e as z
};
