import * as me from "https://cdn.skypack.dev/pin/react@v17.0.1-yH0aYV1FOvoIPeKBbHxg/mode=imports,min/optimized/react.js";
import bt, { Component as fz, useEffect as oh, useCallback as Pv, useContext as pz, useState as RA, useMemo as E1, useRef as gz } from "https://cdn.skypack.dev/pin/react@v17.0.1-yH0aYV1FOvoIPeKBbHxg/mode=imports,min/optimized/react.js";
import * as mz from "https://cdn.skypack.dev/pin/react-dom@v17.0.1-oZ1BXZ5opQ1DbTh7nu9r/mode=imports,min/optimized/react-dom.js";
import pg from "https://cdn.skypack.dev/pin/react-dom@v17.0.1-oZ1BXZ5opQ1DbTh7nu9r/mode=imports,min/optimized/react-dom.js";
import EV from "https://cdn.skypack.dev/pin/react-dom@v17.0.1-oZ1BXZ5opQ1DbTh7nu9r/dist=es2020,mode=imports,min/unoptimized/cjs/react-dom-server.browser.production.min.js";
var Ae = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function LV(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function YO(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function i() {
      if (this instanceof i) {
        var r = [null];
        r.push.apply(r, arguments);
        var o = Function.bind.apply(e, r);
        return new o();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(t, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), t;
}
/**
 * @remix-run/router v1.6.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function li() {
  return li = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, li.apply(this, arguments);
}
var jn;
(function(n) {
  n.Pop = "POP", n.Push = "PUSH", n.Replace = "REPLACE";
})(jn || (jn = {}));
const TA = "popstate";
function vz(n) {
  n === void 0 && (n = {});
  function e(r, o) {
    let {
      pathname: s = "/",
      search: a = "",
      hash: l = ""
    } = eu(r.location.hash.substr(1));
    return Av(
      "",
      {
        pathname: s,
        search: a,
        hash: l
      },
      // state defaults to `null` because `window.history.state` does
      o.state && o.state.usr || null,
      o.state && o.state.key || "default"
    );
  }
  function t(r, o) {
    let s = r.document.querySelector("base"), a = "";
    if (s && s.getAttribute("href")) {
      let l = r.location.href, u = l.indexOf("#");
      a = u === -1 ? l : l.slice(0, u);
    }
    return a + "#" + (typeof o == "string" ? o : sh(o));
  }
  function i(r, o) {
    Or(r.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(o) + ")");
  }
  return Cz(e, t, i, n);
}
function it(n, e) {
  if (n === !1 || n === null || typeof n > "u")
    throw new Error(e);
}
function Or(n, e) {
  if (!n) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {
    }
  }
}
function _z() {
  return Math.random().toString(36).substr(2, 8);
}
function OA(n, e) {
  return {
    usr: n.state,
    key: n.key,
    idx: e
  };
}
function Av(n, e, t, i) {
  return t === void 0 && (t = null), li({
    pathname: typeof n == "string" ? n : n.pathname,
    search: "",
    hash: ""
  }, typeof e == "string" ? eu(e) : e, {
    state: t,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: e && e.key || i || _z()
  });
}
function sh(n) {
  let {
    pathname: e = "/",
    search: t = "",
    hash: i = ""
  } = n;
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i), e;
}
function eu(n) {
  let e = {};
  if (n) {
    let t = n.indexOf("#");
    t >= 0 && (e.hash = n.substr(t), n = n.substr(0, t));
    let i = n.indexOf("?");
    i >= 0 && (e.search = n.substr(i), n = n.substr(0, i)), n && (e.pathname = n);
  }
  return e;
}
function Cz(n, e, t, i) {
  i === void 0 && (i = {});
  let {
    window: r = document.defaultView,
    v5Compat: o = !1
  } = i, s = r.history, a = jn.Pop, l = null, u = c();
  u == null && (u = 0, s.replaceState(li({}, s.state, {
    idx: u
  }), ""));
  function c() {
    return (s.state || {
      idx: null
    }).idx;
  }
  function h() {
    a = jn.Pop;
    let _ = c(), m = _ == null ? null : _ - u;
    u = _, l && l({
      action: a,
      location: g.location,
      delta: m
    });
  }
  function d(_, m) {
    a = jn.Push;
    let v = Av(g.location, _, m);
    t && t(v, _), u = c() + 1;
    let C = OA(v, u), y = g.createHref(v);
    try {
      s.pushState(C, "", y);
    } catch (w) {
      if (w instanceof DOMException && w.name === "DataCloneError")
        throw w;
      r.location.assign(y);
    }
    o && l && l({
      action: a,
      location: g.location,
      delta: 1
    });
  }
  function f(_, m) {
    a = jn.Replace;
    let v = Av(g.location, _, m);
    t && t(v, _), u = c();
    let C = OA(v, u), y = g.createHref(v);
    s.replaceState(C, "", y), o && l && l({
      action: a,
      location: g.location,
      delta: 0
    });
  }
  function p(_) {
    let m = r.location.origin !== "null" ? r.location.origin : r.location.href, v = typeof _ == "string" ? _ : sh(_);
    return it(m, "No window.location.(origin|href) available to create URL for href: " + v), new URL(v, m);
  }
  let g = {
    get action() {
      return a;
    },
    get location() {
      return n(r, s);
    },
    listen(_) {
      if (l)
        throw new Error("A history only accepts one active listener");
      return r.addEventListener(TA, h), l = _, () => {
        r.removeEventListener(TA, h), l = null;
      };
    },
    createHref(_) {
      return e(r, _);
    },
    createURL: p,
    encodeLocation(_) {
      let m = p(_);
      return {
        pathname: m.pathname,
        search: m.search,
        hash: m.hash
      };
    },
    push: d,
    replace: f,
    go(_) {
      return s.go(_);
    }
  };
  return g;
}
var dr;
(function(n) {
  n.data = "data", n.deferred = "deferred", n.redirect = "redirect", n.error = "error";
})(dr || (dr = {}));
const yz = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function wz(n) {
  return n.index === !0;
}
function L1(n, e, t, i) {
  return t === void 0 && (t = []), i === void 0 && (i = {}), n.map((r, o) => {
    let s = [...t, o], a = typeof r.id == "string" ? r.id : s.join("-");
    if (it(r.index !== !0 || !r.children, "Cannot specify children on an index route"), it(!i[a], 'Found a route id collision on id "' + a + `".  Route id's must be globally unique within Data Router usages`), wz(r)) {
      let l = li({}, r, e(r), {
        id: a
      });
      return i[a] = l, l;
    } else {
      let l = li({}, r, e(r), {
        id: a,
        children: void 0
      });
      return i[a] = l, r.children && (l.children = L1(r.children, e, s, i)), l;
    }
  });
}
function Zf(n, e, t) {
  t === void 0 && (t = "/");
  let i = typeof e == "string" ? eu(e) : e, r = ah(i.pathname || "/", t);
  if (r == null)
    return null;
  let o = DV(n);
  bz(o);
  let s = null;
  for (let a = 0; s == null && a < o.length; ++a)
    s = Nz(
      o[a],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      Az(r)
    );
  return s;
}
function DV(n, e, t, i) {
  e === void 0 && (e = []), t === void 0 && (t = []), i === void 0 && (i = "");
  let r = (o, s, a) => {
    let l = {
      relativePath: a === void 0 ? o.path || "" : a,
      caseSensitive: o.caseSensitive === !0,
      childrenIndex: s,
      route: o
    };
    l.relativePath.startsWith("/") && (it(l.relativePath.startsWith(i), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + i + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(i.length));
    let u = Bl([i, l.relativePath]), c = t.concat(l);
    o.children && o.children.length > 0 && (it(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      o.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + u + '".')
    ), DV(o.children, e, c, u)), !(o.path == null && !o.index) && e.push({
      path: u,
      score: Oz(u, o.index),
      routesMeta: c
    });
  };
  return n.forEach((o, s) => {
    var a;
    if (o.path === "" || !((a = o.path) != null && a.includes("?")))
      r(o, s);
    else
      for (let l of RV(o.path))
        r(o, s, l);
  }), e;
}
function RV(n) {
  let e = n.split("/");
  if (e.length === 0)
    return [];
  let [t, ...i] = e, r = t.endsWith("?"), o = t.replace(/\?$/, "");
  if (i.length === 0)
    return r ? [o, ""] : [o];
  let s = RV(i.join("/")), a = [];
  return a.push(...s.map((l) => l === "" ? o : [o, l].join("/"))), r && a.push(...s), a.map((l) => n.startsWith("/") && l === "" ? "/" : l);
}
function bz(n) {
  n.sort((e, t) => e.score !== t.score ? t.score - e.score : xz(e.routesMeta.map((i) => i.childrenIndex), t.routesMeta.map((i) => i.childrenIndex)));
}
const Sz = /^:\w+$/, Ez = 3, Lz = 2, Dz = 1, Rz = 10, Tz = -2, xA = (n) => n === "*";
function Oz(n, e) {
  let t = n.split("/"), i = t.length;
  return t.some(xA) && (i += Tz), e && (i += Lz), t.filter((r) => !xA(r)).reduce((r, o) => r + (Sz.test(o) ? Ez : o === "" ? Dz : Rz), i);
}
function xz(n, e) {
  return n.length === e.length && n.slice(0, -1).every((i, r) => i === e[r]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    n[n.length - 1] - e[e.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function Nz(n, e) {
  let {
    routesMeta: t
  } = n, i = {}, r = "/", o = [];
  for (let s = 0; s < t.length; ++s) {
    let a = t[s], l = s === t.length - 1, u = r === "/" ? e : e.slice(r.length) || "/", c = Iz({
      path: a.relativePath,
      caseSensitive: a.caseSensitive,
      end: l
    }, u);
    if (!c)
      return null;
    Object.assign(i, c.params);
    let h = a.route;
    o.push({
      // TODO: Can this as be avoided?
      params: i,
      pathname: Bl([r, c.pathname]),
      pathnameBase: Wz(Bl([r, c.pathnameBase])),
      route: h
    }), c.pathnameBase !== "/" && (r = Bl([r, c.pathnameBase]));
  }
  return o;
}
function ACe(n, e) {
  e === void 0 && (e = {});
  let t = n;
  t.endsWith("*") && t !== "*" && !t.endsWith("/*") && (Or(!1, 'Route path "' + t + '" will be treated as if it were ' + ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + t.replace(/\*$/, "/*") + '".')), t = t.replace(/\*$/, "/*"));
  const i = t.startsWith("/") ? "/" : "", r = t.split(/\/+/).map((o, s, a) => {
    if (s === a.length - 1 && o === "*")
      return e["*"];
    const u = o.match(/^:(\w+)(\??)$/);
    if (u) {
      const [, c, h] = u;
      let d = e[c];
      return h === "?" ? d ?? "" : (d == null && it(!1, 'Missing ":' + c + '" param'), d);
    }
    return o.replace(/\?$/g, "");
  }).filter((o) => !!o);
  return i + r.join("/");
}
function Iz(n, e) {
  typeof n == "string" && (n = {
    path: n,
    caseSensitive: !1,
    end: !0
  });
  let [t, i] = Pz(n.path, n.caseSensitive, n.end), r = e.match(t);
  if (!r)
    return null;
  let o = r[0], s = o.replace(/(.)\/+$/, "$1"), a = r.slice(1);
  return {
    params: i.reduce((u, c, h) => {
      if (c === "*") {
        let d = a[h] || "";
        s = o.slice(0, o.length - d.length).replace(/(.)\/+$/, "$1");
      }
      return u[c] = Mz(a[h] || "", c), u;
    }, {}),
    pathname: o,
    pathnameBase: s,
    pattern: n
  };
}
function Pz(n, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !0), Or(n === "*" || !n.endsWith("*") || n.endsWith("/*"), 'Route path "' + n + '" will be treated as if it were ' + ('"' + n.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + n.replace(/\*$/, "/*") + '".'));
  let i = [], r = "^" + n.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (s, a) => (i.push(a), "/([^\\/]+)"));
  return n.endsWith("*") ? (i.push("*"), r += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? r += "\\/*$" : n !== "" && n !== "/" && (r += "(?:(?=\\/|$))"), [new RegExp(r, e ? void 0 : "i"), i];
}
function Az(n) {
  try {
    return decodeURI(n);
  } catch (e) {
    return Or(!1, 'The URL path "' + n + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), n;
  }
}
function Mz(n, e) {
  try {
    return decodeURIComponent(n);
  } catch (t) {
    return Or(!1, 'The value for the URL param "' + e + '" will not be decoded because' + (' the string "' + n + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + t + ").")), n;
  }
}
function ah(n, e) {
  if (e === "/")
    return n;
  if (!n.toLowerCase().startsWith(e.toLowerCase()))
    return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length, i = n.charAt(t);
  return i && i !== "/" ? null : n.slice(t) || "/";
}
function Fz(n, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: i = "",
    hash: r = ""
  } = typeof n == "string" ? eu(n) : n;
  return {
    pathname: t ? t.startsWith("/") ? t : kz(t, e) : e,
    search: Vz(i),
    hash: Bz(r)
  };
}
function kz(n, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return n.split("/").forEach((r) => {
    r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r);
  }), t.length > 1 ? t.join("/") : "/";
}
function Y0(n, e, t, i) {
  return "Cannot include a '" + n + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(i) + "].  Please separate it out to the ") + ("`to." + t + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function yS(n) {
  return n.filter((e, t) => t === 0 || e.route.path && e.route.path.length > 0);
}
function XO(n, e, t, i) {
  i === void 0 && (i = !1);
  let r;
  typeof n == "string" ? r = eu(n) : (r = li({}, n), it(!r.pathname || !r.pathname.includes("?"), Y0("?", "pathname", "search", r)), it(!r.pathname || !r.pathname.includes("#"), Y0("#", "pathname", "hash", r)), it(!r.search || !r.search.includes("#"), Y0("#", "search", "hash", r)));
  let o = n === "" || r.pathname === "", s = o ? "/" : r.pathname, a;
  if (i || s == null)
    a = t;
  else {
    let h = e.length - 1;
    if (s.startsWith("..")) {
      let d = s.split("/");
      for (; d[0] === ".."; )
        d.shift(), h -= 1;
      r.pathname = d.join("/");
    }
    a = h >= 0 ? e[h] : "/";
  }
  let l = Fz(r, a), u = s && s !== "/" && s.endsWith("/"), c = (o || s === ".") && t.endsWith("/");
  return !l.pathname.endsWith("/") && (u || c) && (l.pathname += "/"), l;
}
const Bl = (n) => n.join("/").replace(/\/\/+/g, "/"), Wz = (n) => n.replace(/\/+$/, "").replace(/^\/*/, "/"), Vz = (n) => !n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n, Bz = (n) => !n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n, MCe = function(e, t) {
  t === void 0 && (t = 302);
  let i = t;
  typeof i == "number" ? i = {
    status: i
  } : typeof i.status > "u" && (i.status = 302);
  let r = new Headers(i.headers);
  return r.set("Location", e), new Response(null, li({}, i, {
    headers: r
  }));
};
class ZO {
  constructor(e, t, i, r) {
    r === void 0 && (r = !1), this.status = e, this.statusText = t || "", this.internal = r, i instanceof Error ? (this.data = i.toString(), this.error = i) : this.data = i;
  }
}
function TV(n) {
  return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.internal == "boolean" && "data" in n;
}
const OV = ["post", "put", "patch", "delete"], Hz = new Set(OV), Gz = ["get", ...OV], Uz = new Set(Gz), zz = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), jz = /* @__PURE__ */ new Set([307, 308]), X0 = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0
}, $z = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0
}, NA = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
}, xV = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Kz = (n) => ({
  hasErrorBoundary: !!n.hasErrorBoundary
});
function qz(n) {
  const e = n.window ? n.window : typeof window < "u" ? window : void 0, t = typeof e < "u" && typeof e.document < "u" && typeof e.document.createElement < "u", i = !t;
  it(n.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let r;
  if (n.mapRouteProperties)
    r = n.mapRouteProperties;
  else if (n.detectErrorBoundary) {
    let oe = n.detectErrorBoundary;
    r = (Q) => ({
      hasErrorBoundary: oe(Q)
    });
  } else
    r = Kz;
  let o = {}, s = L1(n.routes, r, void 0, o), a, l = n.basename || "/", u = li({
    v7_normalizeFormMethod: !1,
    v7_prependBasename: !1
  }, n.future), c = null, h = /* @__PURE__ */ new Set(), d = null, f = null, p = null, g = n.hydrationData != null, _ = Zf(s, n.history.location, l), m = null;
  if (_ == null) {
    let oe = Ia(404, {
      pathname: n.history.location.pathname
    }), {
      matches: Q,
      route: le
    } = WA(s);
    _ = Q, m = {
      [le.id]: oe
    };
  }
  let v = (
    // All initialMatches need to be loaded before we're ready.  If we have lazy
    // functions around still then we'll need to run them in initialize()
    !_.some((oe) => oe.route.lazy) && // And we have to either have no loaders or have been provided hydrationData
    (!_.some((oe) => oe.route.loader) || n.hydrationData != null)
  ), C, y = {
    historyAction: n.history.action,
    location: n.history.location,
    matches: _,
    initialized: v,
    navigation: X0,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: n.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: n.hydrationData && n.hydrationData.loaderData || {},
    actionData: n.hydrationData && n.hydrationData.actionData || null,
    errors: n.hydrationData && n.hydrationData.errors || m,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, w = jn.Pop, L = !1, S, E = !1, D = !1, x = [], R = [], A = /* @__PURE__ */ new Map(), M = 0, z = -1, j = /* @__PURE__ */ new Map(), $ = /* @__PURE__ */ new Set(), k = /* @__PURE__ */ new Map(), ae = /* @__PURE__ */ new Map(), re = /* @__PURE__ */ new Map(), Y = !1;
  function K() {
    return c = n.history.listen((oe) => {
      let {
        action: Q,
        location: le,
        delta: pe
      } = oe;
      if (Y) {
        Y = !1;
        return;
      }
      Or(re.size === 0 || pe != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let Ee = ai({
        currentLocation: y.location,
        nextLocation: le,
        historyAction: Q
      });
      if (Ee && pe != null) {
        Y = !0, n.history.go(pe * -1), pt(Ee, {
          state: "blocked",
          location: le,
          proceed() {
            pt(Ee, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: le
            }), n.history.go(pe);
          },
          reset() {
            Si(Ee), U({
              blockers: new Map(C.state.blockers)
            });
          }
        });
        return;
      }
      return V(Q, le);
    }), y.initialized || V(jn.Pop, y.location), C;
  }
  function W() {
    c && c(), h.clear(), S && S.abort(), y.fetchers.forEach((oe, Q) => ii(Q)), y.blockers.forEach((oe, Q) => Si(Q));
  }
  function B(oe) {
    return h.add(oe), () => h.delete(oe);
  }
  function U(oe) {
    y = li({}, y, oe), h.forEach((Q) => Q(y));
  }
  function O(oe, Q) {
    var le, pe;
    let Ee = y.actionData != null && y.navigation.formMethod != null && Tu(y.navigation.formMethod) && y.navigation.state === "loading" && ((le = oe.state) == null ? void 0 : le._isRedirect) !== !0, Pe;
    Q.actionData ? Object.keys(Q.actionData).length > 0 ? Pe = Q.actionData : Pe = null : Ee ? Pe = y.actionData : Pe = null;
    let Ke = Q.loaderData ? kA(y.loaderData, Q.loaderData, Q.matches || [], Q.errors) : y.loaderData;
    for (let [Ve] of re)
      Si(Ve);
    let Ne = L === !0 || y.navigation.formMethod != null && Tu(y.navigation.formMethod) && ((pe = oe.state) == null ? void 0 : pe._isRedirect) !== !0;
    a && (s = a, a = void 0), U(li({}, Q, {
      actionData: Pe,
      loaderData: Ke,
      historyAction: w,
      location: oe,
      initialized: !0,
      navigation: X0,
      revalidation: "idle",
      restoreScrollPosition: Yt(oe, Q.matches || y.matches),
      preventScrollReset: Ne,
      blockers: new Map(y.blockers)
    })), E || w === jn.Pop || (w === jn.Push ? n.history.push(oe, oe.state) : w === jn.Replace && n.history.replace(oe, oe.state)), w = jn.Pop, L = !1, E = !1, D = !1, x = [], R = [];
  }
  async function N(oe, Q) {
    if (typeof oe == "number") {
      n.history.go(oe);
      return;
    }
    let le = D1(y.location, y.matches, l, u.v7_prependBasename, oe, Q == null ? void 0 : Q.fromRouteId, Q == null ? void 0 : Q.relative), {
      path: pe,
      submission: Ee,
      error: Pe
    } = IA(u.v7_normalizeFormMethod, !1, le, Q), Ke = y.location, Ne = Av(y.location, pe, Q && Q.state);
    Ne = li({}, Ne, n.history.encodeLocation(Ne));
    let Ve = Q && Q.replace != null ? Q.replace : void 0, Lt = jn.Push;
    Ve === !0 ? Lt = jn.Replace : Ve === !1 || Ee != null && Tu(Ee.formMethod) && Ee.formAction === y.location.pathname + y.location.search && (Lt = jn.Replace);
    let Fe = Q && "preventScrollReset" in Q ? Q.preventScrollReset === !0 : void 0, Rt = ai({
      currentLocation: Ke,
      nextLocation: Ne,
      historyAction: Lt
    });
    if (Rt) {
      pt(Rt, {
        state: "blocked",
        location: Ne,
        proceed() {
          pt(Rt, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: Ne
          }), N(oe, Q);
        },
        reset() {
          Si(Rt), U({
            blockers: new Map(y.blockers)
          });
        }
      });
      return;
    }
    return await V(Lt, Ne, {
      submission: Ee,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: Pe,
      preventScrollReset: Fe,
      replace: Q && Q.replace
    });
  }
  function I() {
    if (It(), U({
      revalidation: "loading"
    }), y.navigation.state !== "submitting") {
      if (y.navigation.state === "idle") {
        V(y.historyAction, y.location, {
          startUninterruptedRevalidation: !0
        });
        return;
      }
      V(w || y.historyAction, y.navigation.location, {
        overrideNavigation: y.navigation
      });
    }
  }
  async function V(oe, Q, le) {
    S && S.abort(), S = null, w = oe, E = (le && le.startUninterruptedRevalidation) === !0, Hn(y.location, y.matches), L = (le && le.preventScrollReset) === !0;
    let pe = a || s, Ee = le && le.overrideNavigation, Pe = Zf(pe, Q, l);
    if (!Pe) {
      let ni = Ia(404, {
        pathname: Q.pathname
      }), {
        matches: Be,
        route: hi
      } = WA(pe);
      tr(), O(Q, {
        matches: Be,
        loaderData: {},
        errors: {
          [hi.id]: ni
        }
      });
      return;
    }
    if (y.initialized && !D && Jz(y.location, Q) && !(le && le.submission && Tu(le.submission.formMethod))) {
      O(Q, {
        matches: Pe
      });
      return;
    }
    S = new AbortController();
    let Ke = am(n.history, Q, S.signal, le && le.submission), Ne, Ve;
    if (le && le.pendingError)
      Ve = {
        [Qf(Pe).route.id]: le.pendingError
      };
    else if (le && le.submission && Tu(le.submission.formMethod)) {
      let ni = await te(Ke, Q, le.submission, Pe, {
        replace: le.replace
      });
      if (ni.shortCircuited)
        return;
      Ne = ni.pendingActionData, Ve = ni.pendingActionError, Ee = li({
        state: "loading",
        location: Q
      }, le.submission), Ke = new Request(Ke.url, {
        signal: Ke.signal
      });
    }
    let {
      shortCircuited: Lt,
      loaderData: Fe,
      errors: Rt
    } = await ue(Ke, Q, Pe, Ee, le && le.submission, le && le.fetcherSubmission, le && le.replace, Ne, Ve);
    Lt || (S = null, O(Q, li({
      matches: Pe
    }, Ne ? {
      actionData: Ne
    } : {}, {
      loaderData: Fe,
      errors: Rt
    })));
  }
  async function te(oe, Q, le, pe, Ee) {
    It();
    let Pe = li({
      state: "submitting",
      location: Q
    }, le);
    U({
      navigation: Pe
    });
    let Ke, Ne = R1(pe, Q);
    if (!Ne.route.action && !Ne.route.lazy)
      Ke = {
        type: dr.error,
        error: Ia(405, {
          method: oe.method,
          pathname: Q.pathname,
          routeId: Ne.route.id
        })
      };
    else if (Ke = await sm("action", oe, Ne, pe, o, r, l), oe.signal.aborted)
      return {
        shortCircuited: !0
      };
    if (pp(Ke)) {
      let Ve;
      return Ee && Ee.replace != null ? Ve = Ee.replace : Ve = Ke.location === y.location.pathname + y.location.search, await $e(y, Ke, {
        submission: le,
        replace: Ve
      }), {
        shortCircuited: !0
      };
    }
    if (rv(Ke)) {
      let Ve = Qf(pe, Ne.route.id);
      return (Ee && Ee.replace) !== !0 && (w = jn.Push), {
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: {},
        pendingActionError: {
          [Ve.route.id]: Ke.error
        }
      };
    }
    if (rd(Ke))
      throw Ia(400, {
        type: "defer-action"
      });
    return {
      pendingActionData: {
        [Ne.route.id]: Ke.data
      }
    };
  }
  async function ue(oe, Q, le, pe, Ee, Pe, Ke, Ne, Ve) {
    let Lt = pe;
    Lt || (Lt = li({
      state: "loading",
      location: Q,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, Ee));
    let Fe = Ee || Pe ? Ee || Pe : Lt.formMethod && Lt.formAction && Lt.formData && Lt.formEncType ? {
      formMethod: Lt.formMethod,
      formAction: Lt.formAction,
      formData: Lt.formData,
      formEncType: Lt.formEncType
    } : void 0, Rt = a || s, [ni, Be] = PA(n.history, y, le, Fe, Q, D, x, R, k, Rt, l, Ne, Ve);
    if (tr((Ai) => !(le && le.some((di) => di.route.id === Ai)) || ni && ni.some((di) => di.route.id === Ai)), ni.length === 0 && Be.length === 0) {
      let Ai = zt();
      return O(Q, li({
        matches: le,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: Ve || null
      }, Ne ? {
        actionData: Ne
      } : {}, Ai ? {
        fetchers: new Map(y.fetchers)
      } : {})), {
        shortCircuited: !0
      };
    }
    if (!E) {
      Be.forEach((di) => {
        let Qi = y.fetchers.get(di.key), sn = {
          state: "loading",
          data: Qi && Qi.data,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          " _hasFetcherDoneAnything ": !0
        };
        y.fetchers.set(di.key, sn);
      });
      let Ai = Ne || y.actionData;
      U(li({
        navigation: Lt
      }, Ai ? Object.keys(Ai).length === 0 ? {
        actionData: null
      } : {
        actionData: Ai
      } : {}, Be.length > 0 ? {
        fetchers: new Map(y.fetchers)
      } : {}));
    }
    z = ++M, Be.forEach((Ai) => {
      Ai.controller && A.set(Ai.key, Ai.controller);
    });
    let hi = () => Be.forEach((Ai) => lt(Ai.key));
    S && S.signal.addEventListener("abort", hi);
    let {
      results: su,
      loaderResults: Nr,
      fetcherResults: Io
    } = await Ot(y.matches, le, ni, Be, oe);
    if (oe.signal.aborted)
      return {
        shortCircuited: !0
      };
    S && S.signal.removeEventListener("abort", hi), Be.forEach((Ai) => A.delete(Ai.key));
    let lo = VA(su);
    if (lo)
      return await $e(y, lo, {
        replace: Ke
      }), {
        shortCircuited: !0
      };
    let {
      loaderData: ul,
      errors: Ir
    } = FA(y, le, ni, Nr, Ve, Be, Io, ae);
    ae.forEach((Ai, di) => {
      Ai.subscribe((Qi) => {
        (Qi || Ai.done) && ae.delete(di);
      });
    });
    let Cn = zt(), _h = Xi(z), ac = Cn || _h || Be.length > 0;
    return li({
      loaderData: ul,
      errors: Ir
    }, ac ? {
      fetchers: new Map(y.fetchers)
    } : {});
  }
  function De(oe) {
    return y.fetchers.get(oe) || $z;
  }
  function ce(oe, Q, le, pe) {
    if (i)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    A.has(oe) && lt(oe);
    let Ee = a || s, Pe = D1(y.location, y.matches, l, u.v7_prependBasename, le, Q, pe == null ? void 0 : pe.relative), Ke = Zf(Ee, Pe, l);
    if (!Ke) {
      ti(oe, Q, Ia(404, {
        pathname: Pe
      }));
      return;
    }
    let {
      path: Ne,
      submission: Ve
    } = IA(u.v7_normalizeFormMethod, !0, Pe, pe), Lt = R1(Ke, Ne);
    if (L = (pe && pe.preventScrollReset) === !0, Ve && Tu(Ve.formMethod)) {
      ke(oe, Q, Ne, Lt, Ke, Ve);
      return;
    }
    k.set(oe, {
      routeId: Q,
      path: Ne
    }), Ie(oe, Q, Ne, Lt, Ke, Ve);
  }
  async function ke(oe, Q, le, pe, Ee, Pe) {
    if (It(), k.delete(oe), !pe.route.action && !pe.route.lazy) {
      let sn = Ia(405, {
        method: Pe.formMethod,
        pathname: le,
        routeId: Q
      });
      ti(oe, Q, sn);
      return;
    }
    let Ke = y.fetchers.get(oe), Ne = li({
      state: "submitting"
    }, Pe, {
      data: Ke && Ke.data,
      " _hasFetcherDoneAnything ": !0
    });
    y.fetchers.set(oe, Ne), U({
      fetchers: new Map(y.fetchers)
    });
    let Ve = new AbortController(), Lt = am(n.history, le, Ve.signal, Pe);
    A.set(oe, Ve);
    let Fe = await sm("action", Lt, pe, Ee, o, r, l);
    if (Lt.signal.aborted) {
      A.get(oe) === Ve && A.delete(oe);
      return;
    }
    if (pp(Fe)) {
      A.delete(oe), $.add(oe);
      let sn = li({
        state: "loading"
      }, Pe, {
        data: void 0,
        " _hasFetcherDoneAnything ": !0
      });
      return y.fetchers.set(oe, sn), U({
        fetchers: new Map(y.fetchers)
      }), $e(y, Fe, {
        submission: Pe,
        isFetchActionRedirect: !0
      });
    }
    if (rv(Fe)) {
      ti(oe, Q, Fe.error);
      return;
    }
    if (rd(Fe))
      throw Ia(400, {
        type: "defer-action"
      });
    let Rt = y.navigation.location || y.location, ni = am(n.history, Rt, Ve.signal), Be = a || s, hi = y.navigation.state !== "idle" ? Zf(Be, y.navigation.location, l) : y.matches;
    it(hi, "Didn't find any matches after fetcher action");
    let su = ++M;
    j.set(oe, su);
    let Nr = li({
      state: "loading",
      data: Fe.data
    }, Pe, {
      " _hasFetcherDoneAnything ": !0
    });
    y.fetchers.set(oe, Nr);
    let [Io, lo] = PA(
      n.history,
      y,
      hi,
      Pe,
      Rt,
      D,
      x,
      R,
      k,
      Be,
      l,
      {
        [pe.route.id]: Fe.data
      },
      void 0
      // No need to send through errors since we short circuit above
    );
    lo.filter((sn) => sn.key !== oe).forEach((sn) => {
      let au = sn.key, lc = y.fetchers.get(au), rC = {
        state: "loading",
        data: lc && lc.data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        " _hasFetcherDoneAnything ": !0
      };
      y.fetchers.set(au, rC), sn.controller && A.set(au, sn.controller);
    }), U({
      fetchers: new Map(y.fetchers)
    });
    let ul = () => lo.forEach((sn) => lt(sn.key));
    Ve.signal.addEventListener("abort", ul);
    let {
      results: Ir,
      loaderResults: Cn,
      fetcherResults: _h
    } = await Ot(y.matches, hi, Io, lo, ni);
    if (Ve.signal.aborted)
      return;
    Ve.signal.removeEventListener("abort", ul), j.delete(oe), A.delete(oe), lo.forEach((sn) => A.delete(sn.key));
    let ac = VA(Ir);
    if (ac)
      return $e(y, ac);
    let {
      loaderData: Ai,
      errors: di
    } = FA(y, y.matches, Io, Cn, void 0, lo, _h, ae);
    if (y.fetchers.has(oe)) {
      let sn = {
        state: "idle",
        data: Fe.data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        " _hasFetcherDoneAnything ": !0
      };
      y.fetchers.set(oe, sn);
    }
    let Qi = Xi(su);
    y.navigation.state === "loading" && su > z ? (it(w, "Expected pending action"), S && S.abort(), O(y.navigation.location, {
      matches: hi,
      loaderData: Ai,
      errors: di,
      fetchers: new Map(y.fetchers)
    })) : (U(li({
      errors: di,
      loaderData: kA(y.loaderData, Ai, hi, di)
    }, Qi || lo.length > 0 ? {
      fetchers: new Map(y.fetchers)
    } : {})), D = !1);
  }
  async function Ie(oe, Q, le, pe, Ee, Pe) {
    let Ke = y.fetchers.get(oe), Ne = li({
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, Pe, {
      data: Ke && Ke.data,
      " _hasFetcherDoneAnything ": !0
    });
    y.fetchers.set(oe, Ne), U({
      fetchers: new Map(y.fetchers)
    });
    let Ve = new AbortController(), Lt = am(n.history, le, Ve.signal);
    A.set(oe, Ve);
    let Fe = await sm("loader", Lt, pe, Ee, o, r, l);
    if (rd(Fe) && (Fe = await AV(Fe, Lt.signal, !0) || Fe), A.get(oe) === Ve && A.delete(oe), Lt.signal.aborted)
      return;
    if (pp(Fe)) {
      $.add(oe), await $e(y, Fe);
      return;
    }
    if (rv(Fe)) {
      let ni = Qf(y.matches, Q);
      y.fetchers.delete(oe), U({
        fetchers: new Map(y.fetchers),
        errors: {
          [ni.route.id]: Fe.error
        }
      });
      return;
    }
    it(!rd(Fe), "Unhandled fetcher deferred data");
    let Rt = {
      state: "idle",
      data: Fe.data,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      " _hasFetcherDoneAnything ": !0
    };
    y.fetchers.set(oe, Rt), U({
      fetchers: new Map(y.fetchers)
    });
  }
  async function $e(oe, Q, le) {
    let {
      submission: pe,
      replace: Ee,
      isFetchActionRedirect: Pe
    } = le === void 0 ? {} : le;
    Q.revalidate && (D = !0);
    let Ke = Av(
      oe.location,
      Q.location,
      // TODO: This can be removed once we get rid of useTransition in Remix v2
      li({
        _isRedirect: !0
      }, Pe ? {
        _isFetchActionRedirect: !0
      } : {})
    );
    if (it(Ke, "Expected a location on the redirect navigation"), xV.test(Q.location) && t) {
      let ni = n.history.createURL(Q.location), Be = ah(ni.pathname, l) == null;
      if (e.location.origin !== ni.origin || Be) {
        Ee ? e.location.replace(Q.location) : e.location.assign(Q.location);
        return;
      }
    }
    S = null;
    let Ne = Ee === !0 ? jn.Replace : jn.Push, {
      formMethod: Ve,
      formAction: Lt,
      formEncType: Fe,
      formData: Rt
    } = oe.navigation;
    !pe && Ve && Lt && Rt && Fe && (pe = {
      formMethod: Ve,
      formAction: Lt,
      formEncType: Fe,
      formData: Rt
    }), jz.has(Q.status) && pe && Tu(pe.formMethod) ? await V(Ne, Ke, {
      submission: li({}, pe, {
        formAction: Q.location
      }),
      // Preserve this flag across redirects
      preventScrollReset: L
    }) : Pe ? await V(Ne, Ke, {
      overrideNavigation: {
        state: "loading",
        location: Ke,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0
      },
      fetcherSubmission: pe,
      // Preserve this flag across redirects
      preventScrollReset: L
    }) : await V(Ne, Ke, {
      overrideNavigation: {
        state: "loading",
        location: Ke,
        formMethod: pe ? pe.formMethod : void 0,
        formAction: pe ? pe.formAction : void 0,
        formEncType: pe ? pe.formEncType : void 0,
        formData: pe ? pe.formData : void 0
      },
      // Preserve this flag across redirects
      preventScrollReset: L
    });
  }
  async function Ot(oe, Q, le, pe, Ee) {
    let Pe = await Promise.all([...le.map((Ve) => sm("loader", Ee, Ve, Q, o, r, l)), ...pe.map((Ve) => Ve.matches && Ve.match && Ve.controller ? sm("loader", am(n.history, Ve.path, Ve.controller.signal), Ve.match, Ve.matches, o, r, l) : {
      type: dr.error,
      error: Ia(404, {
        pathname: Ve.path
      })
    })]), Ke = Pe.slice(0, le.length), Ne = Pe.slice(le.length);
    return await Promise.all([BA(oe, le, Ke, Ke.map(() => Ee.signal), !1, y.loaderData), BA(oe, pe.map((Ve) => Ve.match), Ne, pe.map((Ve) => Ve.controller ? Ve.controller.signal : null), !0)]), {
      results: Pe,
      loaderResults: Ke,
      fetcherResults: Ne
    };
  }
  function It() {
    D = !0, x.push(...tr()), k.forEach((oe, Q) => {
      A.has(Q) && (R.push(Q), lt(Q));
    });
  }
  function ti(oe, Q, le) {
    let pe = Qf(y.matches, Q);
    ii(oe), U({
      errors: {
        [pe.route.id]: le
      },
      fetchers: new Map(y.fetchers)
    });
  }
  function ii(oe) {
    let Q = y.fetchers.get(oe);
    A.has(oe) && !(Q && Q.state === "loading" && j.has(oe)) && lt(oe), k.delete(oe), j.delete(oe), $.delete(oe), y.fetchers.delete(oe);
  }
  function lt(oe) {
    let Q = A.get(oe);
    it(Q, "Expected fetch controller: " + oe), Q.abort(), A.delete(oe);
  }
  function Ui(oe) {
    for (let Q of oe) {
      let pe = {
        state: "idle",
        data: De(Q).data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        " _hasFetcherDoneAnything ": !0
      };
      y.fetchers.set(Q, pe);
    }
  }
  function zt() {
    let oe = [], Q = !1;
    for (let le of $) {
      let pe = y.fetchers.get(le);
      it(pe, "Expected fetcher: " + le), pe.state === "loading" && ($.delete(le), oe.push(le), Q = !0);
    }
    return Ui(oe), Q;
  }
  function Xi(oe) {
    let Q = [];
    for (let [le, pe] of j)
      if (pe < oe) {
        let Ee = y.fetchers.get(le);
        it(Ee, "Expected fetcher: " + le), Ee.state === "loading" && (lt(le), j.delete(le), Q.push(le));
      }
    return Ui(Q), Q.length > 0;
  }
  function Zi(oe, Q) {
    let le = y.blockers.get(oe) || NA;
    return re.get(oe) !== Q && re.set(oe, Q), le;
  }
  function Si(oe) {
    y.blockers.delete(oe), re.delete(oe);
  }
  function pt(oe, Q) {
    let le = y.blockers.get(oe) || NA;
    it(le.state === "unblocked" && Q.state === "blocked" || le.state === "blocked" && Q.state === "blocked" || le.state === "blocked" && Q.state === "proceeding" || le.state === "blocked" && Q.state === "unblocked" || le.state === "proceeding" && Q.state === "unblocked", "Invalid blocker state transition: " + le.state + " -> " + Q.state), y.blockers.set(oe, Q), U({
      blockers: new Map(y.blockers)
    });
  }
  function ai(oe) {
    let {
      currentLocation: Q,
      nextLocation: le,
      historyAction: pe
    } = oe;
    if (re.size === 0)
      return;
    re.size > 1 && Or(!1, "A router only supports one blocker at a time");
    let Ee = Array.from(re.entries()), [Pe, Ke] = Ee[Ee.length - 1], Ne = y.blockers.get(Pe);
    if (!(Ne && Ne.state === "proceeding") && Ke({
      currentLocation: Q,
      nextLocation: le,
      historyAction: pe
    }))
      return Pe;
  }
  function tr(oe) {
    let Q = [];
    return ae.forEach((le, pe) => {
      (!oe || oe(pe)) && (le.cancel(), Q.push(pe), ae.delete(pe));
    }), Q;
  }
  function Nn(oe, Q, le) {
    if (d = oe, p = Q, f = le || ((pe) => pe.key), !g && y.navigation === X0) {
      g = !0;
      let pe = Yt(y.location, y.matches);
      pe != null && U({
        restoreScrollPosition: pe
      });
    }
    return () => {
      d = null, p = null, f = null;
    };
  }
  function Hn(oe, Q) {
    if (d && f && p) {
      let le = Q.map((Ee) => HA(Ee, y.loaderData)), pe = f(oe, le) || oe.key;
      d[pe] = p();
    }
  }
  function Yt(oe, Q) {
    if (d && f && p) {
      let le = Q.map((Pe) => HA(Pe, y.loaderData)), pe = f(oe, le) || oe.key, Ee = d[pe];
      if (typeof Ee == "number")
        return Ee;
    }
    return null;
  }
  function No(oe) {
    o = {}, a = L1(oe, r, void 0, o);
  }
  return C = {
    get basename() {
      return l;
    },
    get state() {
      return y;
    },
    get routes() {
      return s;
    },
    initialize: K,
    subscribe: B,
    enableScrollRestoration: Nn,
    navigate: N,
    fetch: ce,
    revalidate: I,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (oe) => n.history.createHref(oe),
    encodeLocation: (oe) => n.history.encodeLocation(oe),
    getFetcher: De,
    deleteFetcher: ii,
    dispose: W,
    getBlocker: Zi,
    deleteBlocker: Si,
    _internalFetchControllers: A,
    _internalActiveDeferreds: ae,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes: No
  }, C;
}
function Yz(n) {
  return n != null && "formData" in n;
}
function D1(n, e, t, i, r, o, s) {
  let a, l;
  if (o != null && s !== "path") {
    a = [];
    for (let c of e)
      if (a.push(c), c.route.id === o) {
        l = c;
        break;
      }
  } else
    a = e, l = e[e.length - 1];
  let u = XO(r || ".", yS(a).map((c) => c.pathnameBase), ah(n.pathname, t) || n.pathname, s === "path");
  return r == null && (u.search = n.search, u.hash = n.hash), (r == null || r === "" || r === ".") && l && l.route.index && !QO(u.search) && (u.search = u.search ? u.search.replace(/^\?/, "?index&") : "?index"), i && t !== "/" && (u.pathname = u.pathname === "/" ? t : Bl([t, u.pathname])), sh(u);
}
function IA(n, e, t, i) {
  if (!i || !Yz(i))
    return {
      path: t
    };
  if (i.formMethod && !i6(i.formMethod))
    return {
      path: t,
      error: Ia(405, {
        method: i.formMethod
      })
    };
  let r;
  if (i.formData) {
    let a = i.formMethod || "get";
    if (r = {
      formMethod: n ? a.toUpperCase() : a.toLowerCase(),
      formAction: PV(t),
      formEncType: i && i.formEncType || "application/x-www-form-urlencoded",
      formData: i.formData
    }, Tu(r.formMethod))
      return {
        path: t,
        submission: r
      };
  }
  let o = eu(t), s = IV(i.formData);
  return e && o.search && QO(o.search) && s.append("index", ""), o.search = "?" + s, {
    path: sh(o),
    submission: r
  };
}
function Xz(n, e) {
  let t = n;
  if (e) {
    let i = n.findIndex((r) => r.route.id === e);
    i >= 0 && (t = n.slice(0, i));
  }
  return t;
}
function PA(n, e, t, i, r, o, s, a, l, u, c, h, d) {
  let f = d ? Object.values(d)[0] : h ? Object.values(h)[0] : void 0, p = n.createURL(e.location), g = n.createURL(r), _ = d ? Object.keys(d)[0] : void 0, v = Xz(t, _).filter((y, w) => {
    if (y.route.lazy)
      return !0;
    if (y.route.loader == null)
      return !1;
    if (Zz(e.loaderData, e.matches[w], y) || s.some((E) => E === y.route.id))
      return !0;
    let L = e.matches[w], S = y;
    return AA(y, li({
      currentUrl: p,
      currentParams: L.params,
      nextUrl: g,
      nextParams: S.params
    }, i, {
      actionResult: f,
      defaultShouldRevalidate: (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        o || // Clicked the same link, resubmitted a GET form
        p.pathname + p.search === g.pathname + g.search || // Search params affect all loaders
        p.search !== g.search || NV(L, S)
      )
    }));
  }), C = [];
  return l.forEach((y, w) => {
    if (!t.some((D) => D.route.id === y.routeId))
      return;
    let L = Zf(u, y.path, c);
    if (!L) {
      C.push({
        key: w,
        routeId: y.routeId,
        path: y.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let S = R1(L, y.path);
    if (a.includes(w)) {
      C.push({
        key: w,
        routeId: y.routeId,
        path: y.path,
        matches: L,
        match: S,
        controller: new AbortController()
      });
      return;
    }
    AA(S, li({
      currentUrl: p,
      currentParams: e.matches[e.matches.length - 1].params,
      nextUrl: g,
      nextParams: t[t.length - 1].params
    }, i, {
      actionResult: f,
      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
      defaultShouldRevalidate: o
    })) && C.push({
      key: w,
      routeId: y.routeId,
      path: y.path,
      matches: L,
      match: S,
      controller: new AbortController()
    });
  }), [v, C];
}
function Zz(n, e, t) {
  let i = (
    // [a] -> [a, b]
    !e || // [a, b] -> [a, c]
    t.route.id !== e.route.id
  ), r = n[t.route.id] === void 0;
  return i || r;
}
function NV(n, e) {
  let t = n.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    n.pathname !== e.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    t != null && t.endsWith("*") && n.params["*"] !== e.params["*"]
  );
}
function AA(n, e) {
  if (n.route.shouldRevalidate) {
    let t = n.route.shouldRevalidate(e);
    if (typeof t == "boolean")
      return t;
  }
  return e.defaultShouldRevalidate;
}
async function MA(n, e, t) {
  if (!n.lazy)
    return;
  let i = await n.lazy();
  if (!n.lazy)
    return;
  let r = t[n.id];
  it(r, "No route found in manifest");
  let o = {};
  for (let s in i) {
    let l = r[s] !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    s !== "hasErrorBoundary";
    Or(!l, 'Route "' + r.id + '" has a static property "' + s + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + s + '" will be ignored.')), !l && !yz.has(s) && (o[s] = i[s]);
  }
  Object.assign(r, o), Object.assign(r, li({}, e(r), {
    lazy: void 0
  }));
}
async function sm(n, e, t, i, r, o, s, a, l, u) {
  a === void 0 && (a = !1), l === void 0 && (l = !1);
  let c, h, d, f = (_) => {
    let m, v = new Promise((C, y) => m = y);
    return d = () => m(), e.signal.addEventListener("abort", d), Promise.race([_({
      request: e,
      params: t.params,
      context: u
    }), v]);
  };
  try {
    let _ = t.route[n];
    if (t.route.lazy)
      if (_)
        h = (await Promise.all([f(_), MA(t.route, o, r)]))[0];
      else if (await MA(t.route, o, r), _ = t.route[n], _)
        h = await f(_);
      else if (n === "action") {
        let m = new URL(e.url), v = m.pathname + m.search;
        throw Ia(405, {
          method: e.method,
          pathname: v,
          routeId: t.route.id
        });
      } else
        return {
          type: dr.data,
          data: void 0
        };
    else if (_)
      h = await f(_);
    else {
      let m = new URL(e.url), v = m.pathname + m.search;
      throw Ia(404, {
        pathname: v
      });
    }
    it(h !== void 0, "You defined " + (n === "action" ? "an action" : "a loader") + " for route " + ('"' + t.route.id + "\" but didn't return anything from your `" + n + "` ") + "function. Please return a value or `null`.");
  } catch (_) {
    c = dr.error, h = _;
  } finally {
    d && e.signal.removeEventListener("abort", d);
  }
  if (t6(h)) {
    let _ = h.status;
    if (zz.has(_)) {
      let C = h.headers.get("Location");
      if (it(C, "Redirects returned/thrown from loaders/actions must have a Location header"), !xV.test(C))
        C = D1(new URL(e.url), i.slice(0, i.indexOf(t) + 1), s, !0, C);
      else if (!a) {
        let y = new URL(e.url), w = C.startsWith("//") ? new URL(y.protocol + C) : new URL(C), L = ah(w.pathname, s) != null;
        w.origin === y.origin && L && (C = w.pathname + w.search + w.hash);
      }
      if (a)
        throw h.headers.set("Location", C), h;
      return {
        type: dr.redirect,
        status: _,
        location: C,
        revalidate: h.headers.get("X-Remix-Revalidate") !== null
      };
    }
    if (l)
      throw {
        type: c || dr.data,
        response: h
      };
    let m, v = h.headers.get("Content-Type");
    return v && /\bapplication\/json\b/.test(v) ? m = await h.json() : m = await h.text(), c === dr.error ? {
      type: c,
      error: new ZO(_, h.statusText, m),
      headers: h.headers
    } : {
      type: dr.data,
      data: m,
      statusCode: h.status,
      headers: h.headers
    };
  }
  if (c === dr.error)
    return {
      type: c,
      error: h
    };
  if (e6(h)) {
    var p, g;
    return {
      type: dr.deferred,
      deferredData: h,
      statusCode: (p = h.init) == null ? void 0 : p.status,
      headers: ((g = h.init) == null ? void 0 : g.headers) && new Headers(h.init.headers)
    };
  }
  return {
    type: dr.data,
    data: h
  };
}
function am(n, e, t, i) {
  let r = n.createURL(PV(e)).toString(), o = {
    signal: t
  };
  if (i && Tu(i.formMethod)) {
    let {
      formMethod: s,
      formEncType: a,
      formData: l
    } = i;
    o.method = s.toUpperCase(), o.body = a === "application/x-www-form-urlencoded" ? IV(l) : l;
  }
  return new Request(r, o);
}
function IV(n) {
  let e = new URLSearchParams();
  for (let [t, i] of n.entries())
    e.append(t, i instanceof File ? i.name : i);
  return e;
}
function Qz(n, e, t, i, r) {
  let o = {}, s = null, a, l = !1, u = {};
  return t.forEach((c, h) => {
    let d = e[h].route.id;
    if (it(!pp(c), "Cannot handle redirect results in processLoaderData"), rv(c)) {
      let f = Qf(n, d), p = c.error;
      i && (p = Object.values(i)[0], i = void 0), s = s || {}, s[f.route.id] == null && (s[f.route.id] = p), o[d] = void 0, l || (l = !0, a = TV(c.error) ? c.error.status : 500), c.headers && (u[d] = c.headers);
    } else
      rd(c) ? (r.set(d, c.deferredData), o[d] = c.deferredData.data) : o[d] = c.data, c.statusCode != null && c.statusCode !== 200 && !l && (a = c.statusCode), c.headers && (u[d] = c.headers);
  }), i && (s = i, o[Object.keys(i)[0]] = void 0), {
    loaderData: o,
    errors: s,
    statusCode: a || 200,
    loaderHeaders: u
  };
}
function FA(n, e, t, i, r, o, s, a) {
  let {
    loaderData: l,
    errors: u
  } = Qz(e, t, i, r, a);
  for (let c = 0; c < o.length; c++) {
    let {
      key: h,
      match: d,
      controller: f
    } = o[c];
    it(s !== void 0 && s[c] !== void 0, "Did not find corresponding fetcher result");
    let p = s[c];
    if (!(f && f.signal.aborted))
      if (rv(p)) {
        let g = Qf(n.matches, d == null ? void 0 : d.route.id);
        u && u[g.route.id] || (u = li({}, u, {
          [g.route.id]: p.error
        })), n.fetchers.delete(h);
      } else if (pp(p))
        it(!1, "Unhandled fetcher revalidation redirect");
      else if (rd(p))
        it(!1, "Unhandled fetcher deferred data");
      else {
        let g = {
          state: "idle",
          data: p.data,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          " _hasFetcherDoneAnything ": !0
        };
        n.fetchers.set(h, g);
      }
  }
  return {
    loaderData: l,
    errors: u
  };
}
function kA(n, e, t, i) {
  let r = li({}, e);
  for (let o of t) {
    let s = o.route.id;
    if (e.hasOwnProperty(s) ? e[s] !== void 0 && (r[s] = e[s]) : n[s] !== void 0 && o.route.loader && (r[s] = n[s]), i && i.hasOwnProperty(s))
      break;
  }
  return r;
}
function Qf(n, e) {
  return (e ? n.slice(0, n.findIndex((i) => i.route.id === e) + 1) : [...n]).reverse().find((i) => i.route.hasErrorBoundary === !0) || n[0];
}
function WA(n) {
  let e = n.find((t) => t.index || !t.path || t.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route: e
    }],
    route: e
  };
}
function Ia(n, e) {
  let {
    pathname: t,
    routeId: i,
    method: r,
    type: o
  } = e === void 0 ? {} : e, s = "Unknown Server Error", a = "Unknown @remix-run/router error";
  return n === 400 ? (s = "Bad Request", r && t && i ? a = "You made a " + r + ' request to "' + t + '" but ' + ('did not provide a `loader` for route "' + i + '", ') + "so there is no way to handle the request." : o === "defer-action" && (a = "defer() is not supported in actions")) : n === 403 ? (s = "Forbidden", a = 'Route "' + i + '" does not match URL "' + t + '"') : n === 404 ? (s = "Not Found", a = 'No route matches URL "' + t + '"') : n === 405 && (s = "Method Not Allowed", r && t && i ? a = "You made a " + r.toUpperCase() + ' request to "' + t + '" but ' + ('did not provide an `action` for route "' + i + '", ') + "so there is no way to handle the request." : r && (a = 'Invalid request method "' + r.toUpperCase() + '"')), new ZO(n || 500, s, new Error(a), !0);
}
function VA(n) {
  for (let e = n.length - 1; e >= 0; e--) {
    let t = n[e];
    if (pp(t))
      return t;
  }
}
function PV(n) {
  let e = typeof n == "string" ? eu(n) : n;
  return sh(li({}, e, {
    hash: ""
  }));
}
function Jz(n, e) {
  return n.pathname !== e.pathname || n.search !== e.search ? !1 : n.hash === "" ? e.hash !== "" : n.hash === e.hash ? !0 : e.hash !== "";
}
function rd(n) {
  return n.type === dr.deferred;
}
function rv(n) {
  return n.type === dr.error;
}
function pp(n) {
  return (n && n.type) === dr.redirect;
}
function e6(n) {
  let e = n;
  return e && typeof e == "object" && typeof e.data == "object" && typeof e.subscribe == "function" && typeof e.cancel == "function" && typeof e.resolveData == "function";
}
function t6(n) {
  return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.headers == "object" && typeof n.body < "u";
}
function i6(n) {
  return Uz.has(n.toLowerCase());
}
function Tu(n) {
  return Hz.has(n.toLowerCase());
}
async function BA(n, e, t, i, r, o) {
  for (let s = 0; s < t.length; s++) {
    let a = t[s], l = e[s];
    if (!l)
      continue;
    let u = n.find((h) => h.route.id === l.route.id), c = u != null && !NV(u, l) && (o && o[l.route.id]) !== void 0;
    if (rd(a) && (r || c)) {
      let h = i[s];
      it(h, "Expected an AbortSignal for revalidating fetcher deferred result"), await AV(a, h, r).then((d) => {
        d && (t[s] = d || t[s]);
      });
    }
  }
}
async function AV(n, e, t) {
  if (t === void 0 && (t = !1), !await n.deferredData.resolveData(e)) {
    if (t)
      try {
        return {
          type: dr.data,
          data: n.deferredData.unwrappedData
        };
      } catch (r) {
        return {
          type: dr.error,
          error: r
        };
      }
    return {
      type: dr.data,
      data: n.deferredData.data
    };
  }
}
function QO(n) {
  return new URLSearchParams(n).getAll("index").some((e) => e === "");
}
function HA(n, e) {
  let {
    route: t,
    pathname: i,
    params: r
  } = n;
  return {
    id: t.id,
    pathname: i,
    params: r,
    data: e[t.id],
    handle: t.handle
  };
}
function R1(n, e) {
  let t = typeof e == "string" ? eu(e).search : e.search;
  if (n[n.length - 1].route.index && QO(t || ""))
    return n[n.length - 1];
  let i = yS(n);
  return i[i.length - 1];
}
/**
 * React Router v6.12.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Rw() {
  return Rw = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Rw.apply(this, arguments);
}
const gg = /* @__PURE__ */ me.createContext(null);
process.env.NODE_ENV !== "production" && (gg.displayName = "DataRouter");
const wS = /* @__PURE__ */ me.createContext(null);
process.env.NODE_ENV !== "production" && (wS.displayName = "DataRouterState");
const n6 = /* @__PURE__ */ me.createContext(null);
process.env.NODE_ENV !== "production" && (n6.displayName = "Await");
const tu = /* @__PURE__ */ me.createContext(null);
process.env.NODE_ENV !== "production" && (tu.displayName = "Navigation");
const E_ = /* @__PURE__ */ me.createContext(null);
process.env.NODE_ENV !== "production" && (E_.displayName = "Location");
const rl = /* @__PURE__ */ me.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
process.env.NODE_ENV !== "production" && (rl.displayName = "Route");
const JO = /* @__PURE__ */ me.createContext(null);
process.env.NODE_ENV !== "production" && (JO.displayName = "RouteError");
function r6(n, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e;
  L_() || (process.env.NODE_ENV !== "production" ? it(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : it(!1));
  let {
    basename: i,
    navigator: r
  } = me.useContext(tu), {
    hash: o,
    pathname: s,
    search: a
  } = bS(n, {
    relative: t
  }), l = s;
  return i !== "/" && (l = s === "/" ? i : Bl([i, s])), r.createHref({
    pathname: l,
    search: a,
    hash: o
  });
}
function L_() {
  return me.useContext(E_) != null;
}
function Jd() {
  return L_() || (process.env.NODE_ENV !== "production" ? it(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : it(!1)), me.useContext(E_).location;
}
const MV = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function FV(n) {
  me.useContext(tu).static || me.useLayoutEffect(n);
}
function kV() {
  let {
    isDataRoute: n
  } = me.useContext(rl);
  return n ? v6() : o6();
}
function o6() {
  L_() || (process.env.NODE_ENV !== "production" ? it(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : it(!1));
  let n = me.useContext(gg), {
    basename: e,
    navigator: t
  } = me.useContext(tu), {
    matches: i
  } = me.useContext(rl), {
    pathname: r
  } = Jd(), o = JSON.stringify(yS(i).map((l) => l.pathnameBase)), s = me.useRef(!1);
  return FV(() => {
    s.current = !0;
  }), me.useCallback(function(l, u) {
    if (u === void 0 && (u = {}), process.env.NODE_ENV !== "production" && Or(s.current, MV), !s.current)
      return;
    if (typeof l == "number") {
      t.go(l);
      return;
    }
    let c = XO(l, JSON.parse(o), r, u.relative === "path");
    n == null && e !== "/" && (c.pathname = c.pathname === "/" ? e : Bl([e, c.pathname])), (u.replace ? t.replace : t.push)(c, u.state, u);
  }, [e, t, o, r, n]);
}
const s6 = /* @__PURE__ */ me.createContext(null);
function a6(n) {
  let e = me.useContext(rl).outlet;
  return e && /* @__PURE__ */ me.createElement(s6.Provider, {
    value: n
  }, e);
}
function FCe() {
  let {
    matches: n
  } = me.useContext(rl), e = n[n.length - 1];
  return e ? e.params : {};
}
function bS(n, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e, {
    matches: i
  } = me.useContext(rl), {
    pathname: r
  } = Jd(), o = JSON.stringify(yS(i).map((s) => s.pathnameBase));
  return me.useMemo(() => XO(n, JSON.parse(o), r, t === "path"), [n, o, r, t]);
}
function kCe(n, e) {
  return WV(n, e);
}
function WV(n, e, t) {
  L_() || (process.env.NODE_ENV !== "production" ? it(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : it(!1));
  let {
    navigator: i
  } = me.useContext(tu), {
    matches: r
  } = me.useContext(rl), o = r[r.length - 1], s = o ? o.params : {}, a = o ? o.pathname : "/", l = o ? o.pathnameBase : "/", u = o && o.route;
  if (process.env.NODE_ENV !== "production") {
    let m = u && u.path || "";
    _6(a, !u || m.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + a + '" (under <Route path="' + m + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + m + '"> to <Route ') + ('path="' + (m === "/" ? "*" : m + "/*") + '">.'));
  }
  let c = Jd(), h;
  if (e) {
    var d;
    let m = typeof e == "string" ? eu(e) : e;
    l === "/" || (d = m.pathname) != null && d.startsWith(l) || (process.env.NODE_ENV !== "production" ? it(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + l + '" ') + ('but pathname "' + m.pathname + '" was given in the `location` prop.')) : it(!1)), h = m;
  } else
    h = c;
  let f = h.pathname || "/", p = l === "/" ? f : f.slice(l.length) || "/", g = Zf(n, {
    pathname: p
  });
  process.env.NODE_ENV !== "production" && (process.env.NODE_ENV !== "production" && Or(u || g != null, 'No routes matched location "' + h.pathname + h.search + h.hash + '" '), process.env.NODE_ENV !== "production" && Or(g == null || g[g.length - 1].route.element !== void 0 || g[g.length - 1].route.Component !== void 0, 'Matched leaf route at location "' + h.pathname + h.search + h.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let _ = d6(g && g.map((m) => Object.assign({}, m, {
    params: Object.assign({}, s, m.params),
    pathname: Bl([
      l,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(m.pathname).pathname : m.pathname
    ]),
    pathnameBase: m.pathnameBase === "/" ? l : Bl([
      l,
      // Re-encode pathnames that were decoded inside matchRoutes
      i.encodeLocation ? i.encodeLocation(m.pathnameBase).pathname : m.pathnameBase
    ])
  })), r, t);
  return e && _ ? /* @__PURE__ */ me.createElement(E_.Provider, {
    value: {
      location: Rw({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, h),
      navigationType: jn.Pop
    }
  }, _) : _;
}
function l6() {
  let n = g6(), e = TV(n) ? n.status + " " + n.statusText : n instanceof Error ? n.message : JSON.stringify(n), t = n instanceof Error ? n.stack : null, i = "rgba(200,200,200, 0.5)", r = {
    padding: "0.5rem",
    backgroundColor: i
  }, o = {
    padding: "2px 4px",
    backgroundColor: i
  }, s = null;
  return process.env.NODE_ENV !== "production" && (console.error("Error handled by React Router default ErrorBoundary:", n), s = /* @__PURE__ */ me.createElement(me.Fragment, null, /* @__PURE__ */ me.createElement("p", null, " Hey developer "), /* @__PURE__ */ me.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ me.createElement("code", {
    style: o
  }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ me.createElement("code", {
    style: o
  }, "errorElement"), " prop on your route."))), /* @__PURE__ */ me.createElement(me.Fragment, null, /* @__PURE__ */ me.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ me.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, e), t ? /* @__PURE__ */ me.createElement("pre", {
    style: r
  }, t) : null, s);
}
const u6 = /* @__PURE__ */ me.createElement(l6, null);
class c6 extends me.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return {
      error: e
    };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error || t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    console.error("React Router caught the following error during render", e, t);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ me.createElement(rl.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ me.createElement(JO.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function h6(n) {
  let {
    routeContext: e,
    match: t,
    children: i
  } = n, r = me.useContext(gg);
  return r && r.static && r.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ me.createElement(rl.Provider, {
    value: e
  }, i);
}
function d6(n, e, t) {
  var i;
  if (e === void 0 && (e = []), t === void 0 && (t = null), n == null) {
    var r;
    if ((r = t) != null && r.errors)
      n = t.matches;
    else
      return null;
  }
  let o = n, s = (i = t) == null ? void 0 : i.errors;
  if (s != null) {
    let a = o.findIndex((l) => l.route.id && (s == null ? void 0 : s[l.route.id]));
    a >= 0 || (process.env.NODE_ENV !== "production" ? it(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(s).join(",")) : it(!1)), o = o.slice(0, Math.min(o.length, a + 1));
  }
  return o.reduceRight((a, l, u) => {
    let c = l.route.id ? s == null ? void 0 : s[l.route.id] : null, h = null;
    t && (h = l.route.errorElement || u6);
    let d = e.concat(o.slice(0, u + 1)), f = () => {
      let p;
      return c ? p = h : l.route.Component ? p = /* @__PURE__ */ me.createElement(l.route.Component, null) : l.route.element ? p = l.route.element : p = a, /* @__PURE__ */ me.createElement(h6, {
        match: l,
        routeContext: {
          outlet: a,
          matches: d,
          isDataRoute: t != null
        },
        children: p
      });
    };
    return t && (l.route.ErrorBoundary || l.route.errorElement || u === 0) ? /* @__PURE__ */ me.createElement(c6, {
      location: t.location,
      revalidation: t.revalidation,
      component: h,
      error: c,
      children: f(),
      routeContext: {
        outlet: null,
        matches: d,
        isDataRoute: !0
      }
    }) : f();
  }, null);
}
var Tw;
(function(n) {
  n.UseBlocker = "useBlocker", n.UseRevalidator = "useRevalidator", n.UseNavigateStable = "useNavigate";
})(Tw || (Tw = {}));
var Od;
(function(n) {
  n.UseBlocker = "useBlocker", n.UseLoaderData = "useLoaderData", n.UseActionData = "useActionData", n.UseRouteError = "useRouteError", n.UseNavigation = "useNavigation", n.UseRouteLoaderData = "useRouteLoaderData", n.UseMatches = "useMatches", n.UseRevalidator = "useRevalidator", n.UseNavigateStable = "useNavigate", n.UseRouteId = "useRouteId";
})(Od || (Od = {}));
function ex(n) {
  return n + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function VV(n) {
  let e = me.useContext(gg);
  return e || (process.env.NODE_ENV !== "production" ? it(!1, ex(n)) : it(!1)), e;
}
function BV(n) {
  let e = me.useContext(wS);
  return e || (process.env.NODE_ENV !== "production" ? it(!1, ex(n)) : it(!1)), e;
}
function f6(n) {
  let e = me.useContext(rl);
  return e || (process.env.NODE_ENV !== "production" ? it(!1, ex(n)) : it(!1)), e;
}
function tx(n) {
  let e = f6(n), t = e.matches[e.matches.length - 1];
  return t.route.id || (process.env.NODE_ENV !== "production" ? it(!1, n + ' can only be used on routes that contain a unique "id"') : it(!1)), t.route.id;
}
function p6() {
  return tx(Od.UseRouteId);
}
function g6() {
  var n;
  let e = me.useContext(JO), t = BV(Od.UseRouteError), i = tx(Od.UseRouteError);
  return e || ((n = t.errors) == null ? void 0 : n[i]);
}
let m6 = 0;
function WCe(n) {
  let {
    router: e
  } = VV(Tw.UseBlocker), t = BV(Od.UseBlocker), [i] = me.useState(() => String(++m6)), r = me.useCallback((s) => typeof n == "function" ? !!n(s) : !!n, [n]), o = e.getBlocker(i, r);
  return me.useEffect(() => () => e.deleteBlocker(i), [e, i]), t.blockers.get(i) || o;
}
function v6() {
  let {
    router: n
  } = VV(Tw.UseNavigateStable), e = tx(Od.UseNavigateStable), t = me.useRef(!1);
  return FV(() => {
    t.current = !0;
  }), me.useCallback(function(r, o) {
    o === void 0 && (o = {}), process.env.NODE_ENV !== "production" && Or(t.current, MV), t.current && (typeof r == "number" ? n.navigate(r) : n.navigate(r, Rw({
      fromRouteId: e
    }, o)));
  }, [n, e]);
}
const GA = {};
function _6(n, e, t) {
  !e && !GA[n] && (GA[n] = !0, process.env.NODE_ENV !== "production" && Or(!1, t));
}
const UA = "startTransition";
function VCe(n) {
  let {
    fallbackElement: e,
    router: t
  } = n, [i, r] = me.useState(t.state), o = me.useCallback((u) => {
    UA in me ? me[UA](() => r(u)) : r(u);
  }, [r]);
  me.useLayoutEffect(() => t.subscribe(o), [t, o]);
  let s = me.useMemo(() => ({
    createHref: t.createHref,
    encodeLocation: t.encodeLocation,
    go: (u) => t.navigate(u),
    push: (u, c, h) => t.navigate(u, {
      state: c,
      preventScrollReset: h == null ? void 0 : h.preventScrollReset
    }),
    replace: (u, c, h) => t.navigate(u, {
      replace: !0,
      state: c,
      preventScrollReset: h == null ? void 0 : h.preventScrollReset
    })
  }), [t]), a = t.basename || "/", l = me.useMemo(() => ({
    router: t,
    navigator: s,
    static: !1,
    basename: a
  }), [t, s, a]);
  return /* @__PURE__ */ me.createElement(me.Fragment, null, /* @__PURE__ */ me.createElement(gg.Provider, {
    value: l
  }, /* @__PURE__ */ me.createElement(wS.Provider, {
    value: i
  }, /* @__PURE__ */ me.createElement(y6, {
    basename: a,
    location: i.location,
    navigationType: i.historyAction,
    navigator: s
  }, i.initialized ? /* @__PURE__ */ me.createElement(C6, {
    routes: t.routes,
    state: i
  }) : e))), null);
}
function C6(n) {
  let {
    routes: e,
    state: t
  } = n;
  return WV(e, void 0, t);
}
function BCe(n) {
  return a6(n.context);
}
function y6(n) {
  let {
    basename: e = "/",
    children: t = null,
    location: i,
    navigationType: r = jn.Pop,
    navigator: o,
    static: s = !1
  } = n;
  L_() && (process.env.NODE_ENV !== "production" ? it(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : it(!1));
  let a = e.replace(/^\/*/, "/"), l = me.useMemo(() => ({
    basename: a,
    navigator: o,
    static: s
  }), [a, o, s]);
  typeof i == "string" && (i = eu(i));
  let {
    pathname: u = "/",
    search: c = "",
    hash: h = "",
    state: d = null,
    key: f = "default"
  } = i, p = me.useMemo(() => {
    let g = ah(u, a);
    return g == null ? null : {
      location: {
        pathname: g,
        search: c,
        hash: h,
        state: d,
        key: f
      },
      navigationType: r
    };
  }, [a, u, c, h, d, f, r]);
  return process.env.NODE_ENV !== "production" && Or(p != null, '<Router basename="' + a + '"> is not able to match the URL ' + ('"' + u + c + h + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), p == null ? null : /* @__PURE__ */ me.createElement(tu.Provider, {
    value: l
  }, /* @__PURE__ */ me.createElement(E_.Provider, {
    children: t,
    value: p
  }));
}
var zA;
(function(n) {
  n[n.pending = 0] = "pending", n[n.success = 1] = "success", n[n.error = 2] = "error";
})(zA || (zA = {}));
new Promise(() => {
});
function w6(n) {
  let e = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: n.ErrorBoundary != null || n.errorElement != null
  };
  return n.Component && (process.env.NODE_ENV !== "production" && n.element && process.env.NODE_ENV !== "production" && Or(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(e, {
    element: /* @__PURE__ */ me.createElement(n.Component),
    Component: void 0
  })), n.ErrorBoundary && (process.env.NODE_ENV !== "production" && n.errorElement && process.env.NODE_ENV !== "production" && Or(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(e, {
    errorElement: /* @__PURE__ */ me.createElement(n.ErrorBoundary),
    ErrorBoundary: void 0
  })), e;
}
var T1 = {}, b6 = {
  get exports() {
    return T1;
  },
  set exports(n) {
    T1 = n;
  }
};
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(n) {
  (function() {
    var e = {}.hasOwnProperty;
    function t() {
      for (var i = [], r = 0; r < arguments.length; r++) {
        var o = arguments[r];
        if (o) {
          var s = typeof o;
          if (s === "string" || s === "number")
            i.push(o);
          else if (Array.isArray(o)) {
            if (o.length) {
              var a = t.apply(null, o);
              a && i.push(a);
            }
          } else if (s === "object")
            if (o.toString === Object.prototype.toString)
              for (var l in o)
                e.call(o, l) && o[l] && i.push(l);
            else
              i.push(o.toString());
        }
      }
      return i.join(" ");
    }
    n.exports ? (t.default = t, n.exports = t) : window.classNames = t;
  })();
})(b6);
const HCe = T1;
var fd = [], S6 = function() {
  return fd.some(function(n) {
    return n.activeTargets.length > 0;
  });
}, E6 = function() {
  return fd.some(function(n) {
    return n.skippedTargets.length > 0;
  });
}, jA = "ResizeObserver loop completed with undelivered notifications.", L6 = function() {
  var n;
  typeof ErrorEvent == "function" ? n = new ErrorEvent("error", {
    message: jA
  }) : (n = document.createEvent("Event"), n.initEvent("error", !1, !1), n.message = jA), window.dispatchEvent(n);
}, Mv;
(function(n) {
  n.BORDER_BOX = "border-box", n.CONTENT_BOX = "content-box", n.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Mv || (Mv = {}));
var pd = function(n) {
  return Object.freeze(n);
}, D6 = function() {
  function n(e, t) {
    this.inlineSize = e, this.blockSize = t, pd(this);
  }
  return n;
}(), HV = function() {
  function n(e, t, i, r) {
    return this.x = e, this.y = t, this.width = i, this.height = r, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, pd(this);
  }
  return n.prototype.toJSON = function() {
    var e = this, t = e.x, i = e.y, r = e.top, o = e.right, s = e.bottom, a = e.left, l = e.width, u = e.height;
    return { x: t, y: i, top: r, right: o, bottom: s, left: a, width: l, height: u };
  }, n.fromRect = function(e) {
    return new n(e.x, e.y, e.width, e.height);
  }, n;
}(), ix = function(n) {
  return n instanceof SVGElement && "getBBox" in n;
}, GV = function(n) {
  if (ix(n)) {
    var e = n.getBBox(), t = e.width, i = e.height;
    return !t && !i;
  }
  var r = n, o = r.offsetWidth, s = r.offsetHeight;
  return !(o || s || n.getClientRects().length);
}, $A = function(n) {
  var e;
  if (n instanceof Element)
    return !0;
  var t = (e = n == null ? void 0 : n.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView;
  return !!(t && n instanceof t.Element);
}, R6 = function(n) {
  switch (n.tagName) {
    case "INPUT":
      if (n.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ov = typeof window < "u" ? window : {}, xC = /* @__PURE__ */ new WeakMap(), KA = /auto|scroll/, T6 = /^tb|vertical/, O6 = /msie|trident/i.test(ov.navigator && ov.navigator.userAgent), El = function(n) {
  return parseFloat(n || "0");
}, gp = function(n, e, t) {
  return n === void 0 && (n = 0), e === void 0 && (e = 0), t === void 0 && (t = !1), new D6((t ? e : n) || 0, (t ? n : e) || 0);
}, qA = pd({
  devicePixelContentBoxSize: gp(),
  borderBoxSize: gp(),
  contentBoxSize: gp(),
  contentRect: new HV(0, 0, 0, 0)
}), UV = function(n, e) {
  if (e === void 0 && (e = !1), xC.has(n) && !e)
    return xC.get(n);
  if (GV(n))
    return xC.set(n, qA), qA;
  var t = getComputedStyle(n), i = ix(n) && n.ownerSVGElement && n.getBBox(), r = !O6 && t.boxSizing === "border-box", o = T6.test(t.writingMode || ""), s = !i && KA.test(t.overflowY || ""), a = !i && KA.test(t.overflowX || ""), l = i ? 0 : El(t.paddingTop), u = i ? 0 : El(t.paddingRight), c = i ? 0 : El(t.paddingBottom), h = i ? 0 : El(t.paddingLeft), d = i ? 0 : El(t.borderTopWidth), f = i ? 0 : El(t.borderRightWidth), p = i ? 0 : El(t.borderBottomWidth), g = i ? 0 : El(t.borderLeftWidth), _ = h + u, m = l + c, v = g + f, C = d + p, y = a ? n.offsetHeight - C - n.clientHeight : 0, w = s ? n.offsetWidth - v - n.clientWidth : 0, L = r ? _ + v : 0, S = r ? m + C : 0, E = i ? i.width : El(t.width) - L - w, D = i ? i.height : El(t.height) - S - y, x = E + _ + w + v, R = D + m + y + C, A = pd({
    devicePixelContentBoxSize: gp(Math.round(E * devicePixelRatio), Math.round(D * devicePixelRatio), o),
    borderBoxSize: gp(x, R, o),
    contentBoxSize: gp(E, D, o),
    contentRect: new HV(h, l, E, D)
  });
  return xC.set(n, A), A;
}, zV = function(n, e, t) {
  var i = UV(n, t), r = i.borderBoxSize, o = i.contentBoxSize, s = i.devicePixelContentBoxSize;
  switch (e) {
    case Mv.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case Mv.BORDER_BOX:
      return r;
    default:
      return o;
  }
}, x6 = function() {
  function n(e) {
    var t = UV(e);
    this.target = e, this.contentRect = t.contentRect, this.borderBoxSize = pd([t.borderBoxSize]), this.contentBoxSize = pd([t.contentBoxSize]), this.devicePixelContentBoxSize = pd([t.devicePixelContentBoxSize]);
  }
  return n;
}(), jV = function(n) {
  if (GV(n))
    return 1 / 0;
  for (var e = 0, t = n.parentNode; t; )
    e += 1, t = t.parentNode;
  return e;
}, N6 = function() {
  var n = 1 / 0, e = [];
  fd.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var a = [];
      s.activeTargets.forEach(function(u) {
        var c = new x6(u.target), h = jV(u.target);
        a.push(c), u.lastReportedSize = zV(u.target, u.observedBox), h < n && (n = h);
      }), e.push(function() {
        s.callback.call(s.observer, a, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var t = 0, i = e; t < i.length; t++) {
    var r = i[t];
    r();
  }
  return n;
}, YA = function(n) {
  fd.forEach(function(t) {
    t.activeTargets.splice(0, t.activeTargets.length), t.skippedTargets.splice(0, t.skippedTargets.length), t.observationTargets.forEach(function(r) {
      r.isActive() && (jV(r.target) > n ? t.activeTargets.push(r) : t.skippedTargets.push(r));
    });
  });
}, I6 = function() {
  var n = 0;
  for (YA(n); S6(); )
    n = N6(), YA(n);
  return E6() && L6(), n > 0;
}, Z0, $V = [], P6 = function() {
  return $V.splice(0).forEach(function(n) {
    return n();
  });
}, A6 = function(n) {
  if (!Z0) {
    var e = 0, t = document.createTextNode(""), i = { characterData: !0 };
    new MutationObserver(function() {
      return P6();
    }).observe(t, i), Z0 = function() {
      t.textContent = "".concat(e ? e-- : e++);
    };
  }
  $V.push(n), Z0();
}, M6 = function(n) {
  A6(function() {
    requestAnimationFrame(n);
  });
}, qy = 0, F6 = function() {
  return !!qy;
}, k6 = 250, W6 = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, XA = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], ZA = function(n) {
  return n === void 0 && (n = 0), Date.now() + n;
}, Q0 = !1, V6 = function() {
  function n() {
    var e = this;
    this.stopped = !0, this.listener = function() {
      return e.schedule();
    };
  }
  return n.prototype.run = function(e) {
    var t = this;
    if (e === void 0 && (e = k6), !Q0) {
      Q0 = !0;
      var i = ZA(e);
      M6(function() {
        var r = !1;
        try {
          r = I6();
        } finally {
          if (Q0 = !1, e = i - ZA(), !F6())
            return;
          r ? t.run(1e3) : e > 0 ? t.run(e) : t.start();
        }
      });
    }
  }, n.prototype.schedule = function() {
    this.stop(), this.run();
  }, n.prototype.observe = function() {
    var e = this, t = function() {
      return e.observer && e.observer.observe(document.body, W6);
    };
    document.body ? t() : ov.addEventListener("DOMContentLoaded", t);
  }, n.prototype.start = function() {
    var e = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), XA.forEach(function(t) {
      return ov.addEventListener(t, e.listener, !0);
    }));
  }, n.prototype.stop = function() {
    var e = this;
    this.stopped || (this.observer && this.observer.disconnect(), XA.forEach(function(t) {
      return ov.removeEventListener(t, e.listener, !0);
    }), this.stopped = !0);
  }, n;
}(), O1 = new V6(), QA = function(n) {
  !qy && n > 0 && O1.start(), qy += n, !qy && O1.stop();
}, B6 = function(n) {
  return !ix(n) && !R6(n) && getComputedStyle(n).display === "inline";
}, H6 = function() {
  function n(e, t) {
    this.target = e, this.observedBox = t || Mv.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return n.prototype.isActive = function() {
    var e = zV(this.target, this.observedBox, !0);
    return B6(this.target) && (this.lastReportedSize = e), this.lastReportedSize.inlineSize !== e.inlineSize || this.lastReportedSize.blockSize !== e.blockSize;
  }, n;
}(), G6 = function() {
  function n(e, t) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = e, this.callback = t;
  }
  return n;
}(), NC = /* @__PURE__ */ new WeakMap(), JA = function(n, e) {
  for (var t = 0; t < n.length; t += 1)
    if (n[t].target === e)
      return t;
  return -1;
}, IC = function() {
  function n() {
  }
  return n.connect = function(e, t) {
    var i = new G6(e, t);
    NC.set(e, i);
  }, n.observe = function(e, t, i) {
    var r = NC.get(e), o = r.observationTargets.length === 0;
    JA(r.observationTargets, t) < 0 && (o && fd.push(r), r.observationTargets.push(new H6(t, i && i.box)), QA(1), O1.schedule());
  }, n.unobserve = function(e, t) {
    var i = NC.get(e), r = JA(i.observationTargets, t), o = i.observationTargets.length === 1;
    r >= 0 && (o && fd.splice(fd.indexOf(i), 1), i.observationTargets.splice(r, 1), QA(-1));
  }, n.disconnect = function(e) {
    var t = this, i = NC.get(e);
    i.observationTargets.slice().forEach(function(r) {
      return t.unobserve(e, r.target);
    }), i.activeTargets.splice(0, i.activeTargets.length);
  }, n;
}(), U6 = function() {
  function n(e) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof e != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    IC.connect(this, e);
  }
  return n.prototype.observe = function(e, t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!$A(e))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    IC.observe(this, e, t);
  }, n.prototype.unobserve = function(e) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!$A(e))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    IC.unobserve(this, e);
  }, n.prototype.disconnect = function() {
    IC.disconnect(this);
  }, n.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, n;
}();
const z6 = bt[typeof document < "u" && document.createElement !== void 0 ? "useLayoutEffect" : "useEffect"], j6 = z6, $6 = (n) => {
  const e = me.useRef(n);
  return me.useEffect(() => {
    e.current = n;
  }), e;
}, K6 = $6, q6 = typeof window < "u" && "ResizeObserver" in window ? (
  // @ts-ignore
  window.ResizeObserver
) : U6;
function Y6() {
}
function GCe(n, e) {
  const t = Z6(), i = K6(e);
  return j6(() => {
    let r = !1;
    const o = n && "current" in n ? n.current : n;
    if (!o)
      return Y6;
    function s(a, l) {
      r || i.current(a, l);
    }
    return t.subscribe(o, s), () => {
      r = !0, t.unsubscribe(o, s);
    };
  }, [n, t, i]), t.observer;
}
function X6() {
  let n = !1, e = [];
  const t = /* @__PURE__ */ new Map(), i = new q6((r, o) => {
    e = e.concat(r);
    function s() {
      const a = /* @__PURE__ */ new Set();
      for (let l = 0; l < e.length; l++) {
        if (a.has(e[l].target))
          continue;
        a.add(e[l].target);
        const u = t.get(e[l].target);
        u == null || u.forEach((c) => c(e[l], o));
      }
      e = [], n = !1;
    }
    n || window.requestAnimationFrame(s), n = !0;
  });
  return {
    observer: i,
    subscribe(r, o) {
      var s;
      i.observe(r);
      const a = (s = t.get(r)) !== null && s !== void 0 ? s : [];
      a.push(o), t.set(r, a);
    },
    unsubscribe(r, o) {
      var s;
      const a = (s = t.get(r)) !== null && s !== void 0 ? s : [];
      if (a.length === 1) {
        i.unobserve(r), t.delete(r);
        return;
      }
      const l = a.indexOf(o);
      l !== -1 && a.splice(l, 1), t.set(r, a);
    }
  };
}
let J0;
const Z6 = () => J0 || (J0 = X6());
var KV = {}, qV = {}, Qu = {}, eM = {
  get exports() {
    return Qu;
  },
  set exports(n) {
    Qu = n;
  }
}, Ow = {}, Q6 = {
  get exports() {
    return Ow;
  },
  set exports(n) {
    Ow = n;
  }
}, Ci = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tM;
function J6() {
  if (tM)
    return Ci;
  tM = 1;
  var n = typeof Symbol == "function" && Symbol.for, e = n ? Symbol.for("react.element") : 60103, t = n ? Symbol.for("react.portal") : 60106, i = n ? Symbol.for("react.fragment") : 60107, r = n ? Symbol.for("react.strict_mode") : 60108, o = n ? Symbol.for("react.profiler") : 60114, s = n ? Symbol.for("react.provider") : 60109, a = n ? Symbol.for("react.context") : 60110, l = n ? Symbol.for("react.async_mode") : 60111, u = n ? Symbol.for("react.concurrent_mode") : 60111, c = n ? Symbol.for("react.forward_ref") : 60112, h = n ? Symbol.for("react.suspense") : 60113, d = n ? Symbol.for("react.suspense_list") : 60120, f = n ? Symbol.for("react.memo") : 60115, p = n ? Symbol.for("react.lazy") : 60116, g = n ? Symbol.for("react.block") : 60121, _ = n ? Symbol.for("react.fundamental") : 60117, m = n ? Symbol.for("react.responder") : 60118, v = n ? Symbol.for("react.scope") : 60119;
  function C(w) {
    if (typeof w == "object" && w !== null) {
      var L = w.$$typeof;
      switch (L) {
        case e:
          switch (w = w.type, w) {
            case l:
            case u:
            case i:
            case o:
            case r:
            case h:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case a:
                case c:
                case p:
                case f:
                case s:
                  return w;
                default:
                  return L;
              }
          }
        case t:
          return L;
      }
    }
  }
  function y(w) {
    return C(w) === u;
  }
  return Ci.AsyncMode = l, Ci.ConcurrentMode = u, Ci.ContextConsumer = a, Ci.ContextProvider = s, Ci.Element = e, Ci.ForwardRef = c, Ci.Fragment = i, Ci.Lazy = p, Ci.Memo = f, Ci.Portal = t, Ci.Profiler = o, Ci.StrictMode = r, Ci.Suspense = h, Ci.isAsyncMode = function(w) {
    return y(w) || C(w) === l;
  }, Ci.isConcurrentMode = y, Ci.isContextConsumer = function(w) {
    return C(w) === a;
  }, Ci.isContextProvider = function(w) {
    return C(w) === s;
  }, Ci.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === e;
  }, Ci.isForwardRef = function(w) {
    return C(w) === c;
  }, Ci.isFragment = function(w) {
    return C(w) === i;
  }, Ci.isLazy = function(w) {
    return C(w) === p;
  }, Ci.isMemo = function(w) {
    return C(w) === f;
  }, Ci.isPortal = function(w) {
    return C(w) === t;
  }, Ci.isProfiler = function(w) {
    return C(w) === o;
  }, Ci.isStrictMode = function(w) {
    return C(w) === r;
  }, Ci.isSuspense = function(w) {
    return C(w) === h;
  }, Ci.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === i || w === u || w === o || w === r || w === h || w === d || typeof w == "object" && w !== null && (w.$$typeof === p || w.$$typeof === f || w.$$typeof === s || w.$$typeof === a || w.$$typeof === c || w.$$typeof === _ || w.$$typeof === m || w.$$typeof === v || w.$$typeof === g);
  }, Ci.typeOf = C, Ci;
}
var yi = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iM;
function e8() {
  return iM || (iM = 1, process.env.NODE_ENV !== "production" && function() {
    var n = typeof Symbol == "function" && Symbol.for, e = n ? Symbol.for("react.element") : 60103, t = n ? Symbol.for("react.portal") : 60106, i = n ? Symbol.for("react.fragment") : 60107, r = n ? Symbol.for("react.strict_mode") : 60108, o = n ? Symbol.for("react.profiler") : 60114, s = n ? Symbol.for("react.provider") : 60109, a = n ? Symbol.for("react.context") : 60110, l = n ? Symbol.for("react.async_mode") : 60111, u = n ? Symbol.for("react.concurrent_mode") : 60111, c = n ? Symbol.for("react.forward_ref") : 60112, h = n ? Symbol.for("react.suspense") : 60113, d = n ? Symbol.for("react.suspense_list") : 60120, f = n ? Symbol.for("react.memo") : 60115, p = n ? Symbol.for("react.lazy") : 60116, g = n ? Symbol.for("react.block") : 60121, _ = n ? Symbol.for("react.fundamental") : 60117, m = n ? Symbol.for("react.responder") : 60118, v = n ? Symbol.for("react.scope") : 60119;
    function C(ce) {
      return typeof ce == "string" || typeof ce == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      ce === i || ce === u || ce === o || ce === r || ce === h || ce === d || typeof ce == "object" && ce !== null && (ce.$$typeof === p || ce.$$typeof === f || ce.$$typeof === s || ce.$$typeof === a || ce.$$typeof === c || ce.$$typeof === _ || ce.$$typeof === m || ce.$$typeof === v || ce.$$typeof === g);
    }
    function y(ce) {
      if (typeof ce == "object" && ce !== null) {
        var ke = ce.$$typeof;
        switch (ke) {
          case e:
            var Ie = ce.type;
            switch (Ie) {
              case l:
              case u:
              case i:
              case o:
              case r:
              case h:
                return Ie;
              default:
                var $e = Ie && Ie.$$typeof;
                switch ($e) {
                  case a:
                  case c:
                  case p:
                  case f:
                  case s:
                    return $e;
                  default:
                    return ke;
                }
            }
          case t:
            return ke;
        }
      }
    }
    var w = l, L = u, S = a, E = s, D = e, x = c, R = i, A = p, M = f, z = t, j = o, $ = r, k = h, ae = !1;
    function re(ce) {
      return ae || (ae = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), Y(ce) || y(ce) === l;
    }
    function Y(ce) {
      return y(ce) === u;
    }
    function K(ce) {
      return y(ce) === a;
    }
    function W(ce) {
      return y(ce) === s;
    }
    function B(ce) {
      return typeof ce == "object" && ce !== null && ce.$$typeof === e;
    }
    function U(ce) {
      return y(ce) === c;
    }
    function O(ce) {
      return y(ce) === i;
    }
    function N(ce) {
      return y(ce) === p;
    }
    function I(ce) {
      return y(ce) === f;
    }
    function V(ce) {
      return y(ce) === t;
    }
    function te(ce) {
      return y(ce) === o;
    }
    function ue(ce) {
      return y(ce) === r;
    }
    function De(ce) {
      return y(ce) === h;
    }
    yi.AsyncMode = w, yi.ConcurrentMode = L, yi.ContextConsumer = S, yi.ContextProvider = E, yi.Element = D, yi.ForwardRef = x, yi.Fragment = R, yi.Lazy = A, yi.Memo = M, yi.Portal = z, yi.Profiler = j, yi.StrictMode = $, yi.Suspense = k, yi.isAsyncMode = re, yi.isConcurrentMode = Y, yi.isContextConsumer = K, yi.isContextProvider = W, yi.isElement = B, yi.isForwardRef = U, yi.isFragment = O, yi.isLazy = N, yi.isMemo = I, yi.isPortal = V, yi.isProfiler = te, yi.isStrictMode = ue, yi.isSuspense = De, yi.isValidElementType = C, yi.typeOf = y;
  }()), yi;
}
var nM;
function YV() {
  return nM || (nM = 1, function(n) {
    process.env.NODE_ENV === "production" ? n.exports = J6() : n.exports = e8();
  }(Q6)), Ow;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var eL, rM;
function t8() {
  if (rM)
    return eL;
  rM = 1;
  var n = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, t = Object.prototype.propertyIsEnumerable;
  function i(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function r() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return eL = r() ? Object.assign : function(o, s) {
    for (var a, l = i(o), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var h in a)
        e.call(a, h) && (l[h] = a[h]);
      if (n) {
        u = n(a);
        for (var d = 0; d < u.length; d++)
          t.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, eL;
}
var tL, oM;
function nx() {
  if (oM)
    return tL;
  oM = 1;
  var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return tL = n, tL;
}
var iL, sM;
function XV() {
  return sM || (sM = 1, iL = Function.call.bind(Object.prototype.hasOwnProperty)), iL;
}
var nL, aM;
function i8() {
  if (aM)
    return nL;
  aM = 1;
  var n = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = nx(), t = {}, i = XV();
    n = function(o) {
      var s = "Warning: " + o;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function r(o, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in o)
        if (i(o, c)) {
          var h;
          try {
            if (typeof o[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            h = o[c](s, c, l, a, null, e);
          } catch (p) {
            h = p;
          }
          if (h && !(h instanceof Error) && n(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof h + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), h instanceof Error && !(h.message in t)) {
            t[h.message] = !0;
            var f = u ? u() : "";
            n(
              "Failed " + a + " type: " + h.message + (f ?? "")
            );
          }
        }
    }
  }
  return r.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (t = {});
  }, nL = r, nL;
}
var rL, lM;
function n8() {
  if (lM)
    return rL;
  lM = 1;
  var n = YV(), e = t8(), t = nx(), i = XV(), r = i8(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return rL = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function h(Y) {
      var K = Y && (u && Y[u] || Y[c]);
      if (typeof K == "function")
        return K;
    }
    var d = "<<anonymous>>", f = {
      array: m("array"),
      bigint: m("bigint"),
      bool: m("boolean"),
      func: m("function"),
      number: m("number"),
      object: m("object"),
      string: m("string"),
      symbol: m("symbol"),
      any: v(),
      arrayOf: C,
      element: y(),
      elementType: w(),
      instanceOf: L,
      node: x(),
      objectOf: E,
      oneOf: S,
      oneOfType: D,
      shape: A,
      exact: M
    };
    function p(Y, K) {
      return Y === K ? Y !== 0 || 1 / Y === 1 / K : Y !== Y && K !== K;
    }
    function g(Y, K) {
      this.message = Y, this.data = K && typeof K == "object" ? K : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function _(Y) {
      if (process.env.NODE_ENV !== "production")
        var K = {}, W = 0;
      function B(O, N, I, V, te, ue, De) {
        if (V = V || d, ue = ue || I, De !== t) {
          if (l) {
            var ce = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw ce.name = "Invariant Violation", ce;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ke = V + ":" + I;
            !K[ke] && // Avoid spamming the console because they are often not actionable except for lib authors
            W < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + ue + "` prop on `" + V + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), K[ke] = !0, W++);
          }
        }
        return N[I] == null ? O ? N[I] === null ? new g("The " + te + " `" + ue + "` is marked as required " + ("in `" + V + "`, but its value is `null`.")) : new g("The " + te + " `" + ue + "` is marked as required in " + ("`" + V + "`, but its value is `undefined`.")) : null : Y(N, I, V, te, ue);
      }
      var U = B.bind(null, !1);
      return U.isRequired = B.bind(null, !0), U;
    }
    function m(Y) {
      function K(W, B, U, O, N, I) {
        var V = W[B], te = $(V);
        if (te !== Y) {
          var ue = k(V);
          return new g(
            "Invalid " + O + " `" + N + "` of type " + ("`" + ue + "` supplied to `" + U + "`, expected ") + ("`" + Y + "`."),
            { expectedType: Y }
          );
        }
        return null;
      }
      return _(K);
    }
    function v() {
      return _(s);
    }
    function C(Y) {
      function K(W, B, U, O, N) {
        if (typeof Y != "function")
          return new g("Property `" + N + "` of component `" + U + "` has invalid PropType notation inside arrayOf.");
        var I = W[B];
        if (!Array.isArray(I)) {
          var V = $(I);
          return new g("Invalid " + O + " `" + N + "` of type " + ("`" + V + "` supplied to `" + U + "`, expected an array."));
        }
        for (var te = 0; te < I.length; te++) {
          var ue = Y(I, te, U, O, N + "[" + te + "]", t);
          if (ue instanceof Error)
            return ue;
        }
        return null;
      }
      return _(K);
    }
    function y() {
      function Y(K, W, B, U, O) {
        var N = K[W];
        if (!a(N)) {
          var I = $(N);
          return new g("Invalid " + U + " `" + O + "` of type " + ("`" + I + "` supplied to `" + B + "`, expected a single ReactElement."));
        }
        return null;
      }
      return _(Y);
    }
    function w() {
      function Y(K, W, B, U, O) {
        var N = K[W];
        if (!n.isValidElementType(N)) {
          var I = $(N);
          return new g("Invalid " + U + " `" + O + "` of type " + ("`" + I + "` supplied to `" + B + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return _(Y);
    }
    function L(Y) {
      function K(W, B, U, O, N) {
        if (!(W[B] instanceof Y)) {
          var I = Y.name || d, V = re(W[B]);
          return new g("Invalid " + O + " `" + N + "` of type " + ("`" + V + "` supplied to `" + U + "`, expected ") + ("instance of `" + I + "`."));
        }
        return null;
      }
      return _(K);
    }
    function S(Y) {
      if (!Array.isArray(Y))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), s;
      function K(W, B, U, O, N) {
        for (var I = W[B], V = 0; V < Y.length; V++)
          if (p(I, Y[V]))
            return null;
        var te = JSON.stringify(Y, function(De, ce) {
          var ke = k(ce);
          return ke === "symbol" ? String(ce) : ce;
        });
        return new g("Invalid " + O + " `" + N + "` of value `" + String(I) + "` " + ("supplied to `" + U + "`, expected one of " + te + "."));
      }
      return _(K);
    }
    function E(Y) {
      function K(W, B, U, O, N) {
        if (typeof Y != "function")
          return new g("Property `" + N + "` of component `" + U + "` has invalid PropType notation inside objectOf.");
        var I = W[B], V = $(I);
        if (V !== "object")
          return new g("Invalid " + O + " `" + N + "` of type " + ("`" + V + "` supplied to `" + U + "`, expected an object."));
        for (var te in I)
          if (i(I, te)) {
            var ue = Y(I, te, U, O, N + "." + te, t);
            if (ue instanceof Error)
              return ue;
          }
        return null;
      }
      return _(K);
    }
    function D(Y) {
      if (!Array.isArray(Y))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var K = 0; K < Y.length; K++) {
        var W = Y[K];
        if (typeof W != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ae(W) + " at index " + K + "."
          ), s;
      }
      function B(U, O, N, I, V) {
        for (var te = [], ue = 0; ue < Y.length; ue++) {
          var De = Y[ue], ce = De(U, O, N, I, V, t);
          if (ce == null)
            return null;
          ce.data && i(ce.data, "expectedType") && te.push(ce.data.expectedType);
        }
        var ke = te.length > 0 ? ", expected one of type [" + te.join(", ") + "]" : "";
        return new g("Invalid " + I + " `" + V + "` supplied to " + ("`" + N + "`" + ke + "."));
      }
      return _(B);
    }
    function x() {
      function Y(K, W, B, U, O) {
        return z(K[W]) ? null : new g("Invalid " + U + " `" + O + "` supplied to " + ("`" + B + "`, expected a ReactNode."));
      }
      return _(Y);
    }
    function R(Y, K, W, B, U) {
      return new g(
        (Y || "React class") + ": " + K + " type `" + W + "." + B + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + U + "`."
      );
    }
    function A(Y) {
      function K(W, B, U, O, N) {
        var I = W[B], V = $(I);
        if (V !== "object")
          return new g("Invalid " + O + " `" + N + "` of type `" + V + "` " + ("supplied to `" + U + "`, expected `object`."));
        for (var te in Y) {
          var ue = Y[te];
          if (typeof ue != "function")
            return R(U, O, N, te, k(ue));
          var De = ue(I, te, U, O, N + "." + te, t);
          if (De)
            return De;
        }
        return null;
      }
      return _(K);
    }
    function M(Y) {
      function K(W, B, U, O, N) {
        var I = W[B], V = $(I);
        if (V !== "object")
          return new g("Invalid " + O + " `" + N + "` of type `" + V + "` " + ("supplied to `" + U + "`, expected `object`."));
        var te = e({}, W[B], Y);
        for (var ue in te) {
          var De = Y[ue];
          if (i(Y, ue) && typeof De != "function")
            return R(U, O, N, ue, k(De));
          if (!De)
            return new g(
              "Invalid " + O + " `" + N + "` key `" + ue + "` supplied to `" + U + "`.\nBad object: " + JSON.stringify(W[B], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(Y), null, "  ")
            );
          var ce = De(I, ue, U, O, N + "." + ue, t);
          if (ce)
            return ce;
        }
        return null;
      }
      return _(K);
    }
    function z(Y) {
      switch (typeof Y) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !Y;
        case "object":
          if (Array.isArray(Y))
            return Y.every(z);
          if (Y === null || a(Y))
            return !0;
          var K = h(Y);
          if (K) {
            var W = K.call(Y), B;
            if (K !== Y.entries) {
              for (; !(B = W.next()).done; )
                if (!z(B.value))
                  return !1;
            } else
              for (; !(B = W.next()).done; ) {
                var U = B.value;
                if (U && !z(U[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function j(Y, K) {
      return Y === "symbol" ? !0 : K ? K["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && K instanceof Symbol : !1;
    }
    function $(Y) {
      var K = typeof Y;
      return Array.isArray(Y) ? "array" : Y instanceof RegExp ? "object" : j(K, Y) ? "symbol" : K;
    }
    function k(Y) {
      if (typeof Y > "u" || Y === null)
        return "" + Y;
      var K = $(Y);
      if (K === "object") {
        if (Y instanceof Date)
          return "date";
        if (Y instanceof RegExp)
          return "regexp";
      }
      return K;
    }
    function ae(Y) {
      var K = k(Y);
      switch (K) {
        case "array":
        case "object":
          return "an " + K;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + K;
        default:
          return K;
      }
    }
    function re(Y) {
      return !Y.constructor || !Y.constructor.name ? d : Y.constructor.name;
    }
    return f.checkPropTypes = r, f.resetWarningCache = r.resetWarningCache, f.PropTypes = f, f;
  }, rL;
}
var oL, uM;
function r8() {
  if (uM)
    return oL;
  uM = 1;
  var n = nx();
  function e() {
  }
  function t() {
  }
  return t.resetWarningCache = e, oL = function() {
    function i(s, a, l, u, c, h) {
      if (h !== n) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    i.isRequired = i;
    function r() {
      return i;
    }
    var o = {
      array: i,
      bigint: i,
      bool: i,
      func: i,
      number: i,
      object: i,
      string: i,
      symbol: i,
      any: i,
      arrayOf: r,
      element: i,
      elementType: i,
      instanceOf: r,
      node: i,
      objectOf: r,
      oneOf: r,
      oneOfType: r,
      shape: r,
      exact: r,
      checkPropTypes: t,
      resetWarningCache: e
    };
    return o.PropTypes = o, o;
  }, oL;
}
if (process.env.NODE_ENV !== "production") {
  var o8 = YV(), s8 = !0;
  eM.exports = n8()(o8.isElement, s8);
} else
  eM.exports = r8()();
(function(n) {
  var e = Ae && Ae.__extends || function() {
    var u = function(c, h) {
      return u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, f) {
        d.__proto__ = f;
      } || function(d, f) {
        for (var p in f)
          f.hasOwnProperty(p) && (d[p] = f[p]);
      }, u(c, h);
    };
    return function(c, h) {
      u(c, h);
      function d() {
        this.constructor = c;
      }
      c.prototype = h === null ? Object.create(h) : (d.prototype = h.prototype, new d());
    };
  }(), t = Ae && Ae.__assign || function() {
    return t = Object.assign || function(u) {
      for (var c, h = 1, d = arguments.length; h < d; h++) {
        c = arguments[h];
        for (var f in c)
          Object.prototype.hasOwnProperty.call(c, f) && (u[f] = c[f]);
      }
      return u;
    }, t.apply(this, arguments);
  }, i = Ae && Ae.__rest || function(u, c) {
    var h = {};
    for (var d in u)
      Object.prototype.hasOwnProperty.call(u, d) && c.indexOf(d) < 0 && (h[d] = u[d]);
    if (u != null && typeof Object.getOwnPropertySymbols == "function")
      for (var f = 0, d = Object.getOwnPropertySymbols(u); f < d.length; f++)
        c.indexOf(d[f]) < 0 && Object.prototype.propertyIsEnumerable.call(u, d[f]) && (h[d[f]] = u[d[f]]);
    return h;
  };
  n.__esModule = !0, n.FlexView = n.FlexViewInternal = void 0;
  var r = bt, o = Qu;
  function s(u) {
    process.env.NODE_ENV !== "production" && console.warn(u);
  }
  function a(u, c) {
    return u.filter(c).length > 0;
  }
  var l = (
    /** @class */
    function(u) {
      e(c, u);
      function c() {
        return u !== null && u.apply(this, arguments) || this;
      }
      return c.prototype.componentDidMount = function() {
        this.logWarnings();
      }, c.prototype.logWarnings = function() {
        var h = this.props, d = h.basis, f = h.hAlignContent, p = h.vAlignContent, g = h.children, _ = h.column;
        if (d === "auto" && s('basis is "auto" by default: forcing it to "auto"  will leave "shrink:true" as default'), process.env.NODE_ENV !== "production" && typeof g < "u" && !_ && f === "center") {
          var m = a([].concat(g), function(C) {
            var y = (typeof C == "object" && C !== null ? C.props : void 0) || {}, w = y.style || {}, L = w.marginLeft || y.marginLeft, S = w.marginRight || y.marginRight;
            return L === "auto" && S === "auto";
          });
          m && s(`In a row with hAlignContent="center" there should be no child with marginLeft and marginRight set to "auto"
https://github.com/buildo/react-flexview/issues/30`);
        }
        if (process.env.NODE_ENV !== "production" && typeof g < "u" && _ && p === "center") {
          var v = a([].concat(g), function(C) {
            var y = (typeof C == "object" && C !== null ? C.props : void 0) || {}, w = y.style || {}, L = w.marginTop || y.marginTop, S = w.marginBottom || y.marginBottom;
            return L === "auto" && S === "auto";
          });
          v && s(`In a column with vAlignContent="center" there should be no child with marginTop and marginBottom set to "auto"
https://github.com/buildo/react-flexview/issues/30`);
        }
      }, c.prototype.getGrow = function() {
        var h = this.props.grow;
        return typeof h == "number" ? h : h ? 1 : 0;
      }, c.prototype.getShrink = function() {
        var h = this.props, d = h.shrink, f = h.basis;
        return typeof d == "number" ? d : d ? 1 : d === !1 || f && f !== "auto" ? 0 : 1;
      }, c.prototype.getBasis = function() {
        var h = this.props.basis;
        if (h) {
          var d = typeof h == "number" || String(parseInt(h, 10)) === h ? "px" : "";
          return h + d;
        }
        return "auto";
      }, c.prototype.getStyle = function() {
        var h = this.props, d = h.column, f = h.wrap, p = h.vAlignContent, g = h.hAlignContent, _ = {
          width: this.props.width,
          height: this.props.height,
          marginLeft: this.props.marginLeft,
          marginTop: this.props.marginTop,
          marginRight: this.props.marginRight,
          marginBottom: this.props.marginBottom
        };
        function m(v) {
          switch (v) {
            case "top":
            case "left":
              return "flex-start";
            case "center":
              return "center";
            case "bottom":
            case "right":
              return "flex-end";
          }
        }
        return t(t({
          boxSizing: "border-box",
          // some browsers don't set these by default on flex
          minWidth: 0,
          minHeight: 0,
          // flex properties
          display: "flex",
          flexDirection: d ? "column" : "row",
          flexWrap: f ? "wrap" : "nowrap",
          flex: this.getGrow() + " " + this.getShrink() + " " + this.getBasis(),
          justifyContent: m(d ? p : g),
          alignItems: m(d ? g : p)
        }, _), this.props.style);
      }, c.prototype.getElementProps = function() {
        var h = this.props;
        h.children, h.className, h.style, h.column, h.grow, h.shrink, h.basis, h.wrap, h.vAlignContent, h.hAlignContent, h.width, h.height, h.marginBottom, h.marginTop, h.marginLeft, h.marginRight, h.componentRef, h.component;
        var d = i(h, ["children", "className", "style", "column", "grow", "shrink", "basis", "wrap", "vAlignContent", "hAlignContent", "width", "height", "marginBottom", "marginTop", "marginLeft", "marginRight", "componentRef", "component"]);
        return d;
      }, c.prototype.render = function() {
        return r.createElement(this.props.component || "div", t({ ref: this.props.componentRef, className: this.props.className, style: this.getStyle(), children: this.props.children }, this.getElementProps()));
      }, c.propTypes = {
        children: o.node,
        column: o.bool,
        vAlignContent: o.oneOf(["top", "center", "bottom"]),
        hAlignContent: o.oneOf(["left", "center", "right"]),
        marginLeft: o.oneOfType([o.string, o.number]),
        marginTop: o.oneOfType([o.string, o.number]),
        marginRight: o.oneOfType([o.string, o.number]),
        marginBottom: o.oneOfType([o.string, o.number]),
        grow: o.oneOfType([o.bool, o.number]),
        shrink: o.oneOfType([o.bool, o.number]),
        basis: o.oneOfType([o.string, o.number]),
        wrap: o.bool,
        height: o.oneOfType([o.string, o.number]),
        width: o.oneOfType([o.string, o.number]),
        className: o.string,
        style: o.object,
        component: o.elementType
      }, c;
    }(r.Component)
  );
  n.FlexViewInternal = l, n.FlexView = r.forwardRef(function(u, c) {
    return r.createElement(l, t({}, u, { componentRef: c }));
  }), n.default = n.FlexView;
})(qV);
(function(n) {
  n.__esModule = !0;
  var e = qV;
  n.default = e.FlexView;
})(KV);
const UCe = /* @__PURE__ */ LV(KV);
var xw = {}, a8 = {
  get exports() {
    return xw;
  },
  set exports(n) {
    xw = n;
  }
}, xd = {}, Nw = {}, l8 = {
  get exports() {
    return Nw;
  },
  set exports(n) {
    Nw = n;
  }
}, ol = {}, Fv = {}, u8 = {
  get exports() {
    return Fv;
  },
  set exports(n) {
    Fv = n;
  }
};
(function(n, e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = a;
  /*!
   * Adapted from jQuery UI core
   *
   * http://jqueryui.com
   *
   * Copyright 2014 jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/category/ui-core/
   */
  var t = /input|select|textarea|button|object|iframe/;
  function i(l) {
    var u = l.offsetWidth <= 0 && l.offsetHeight <= 0;
    if (u && !l.innerHTML)
      return !0;
    try {
      var c = window.getComputedStyle(l);
      return u ? c.getPropertyValue("overflow") !== "visible" || // if 'overflow: visible' set, check if there is actually any overflow
      l.scrollWidth <= 0 && l.scrollHeight <= 0 : c.getPropertyValue("display") == "none";
    } catch {
      return console.warn("Failed to inspect element style"), !1;
    }
  }
  function r(l) {
    for (var u = l, c = l.getRootNode && l.getRootNode(); u && u !== document.body; ) {
      if (c && u === c && (u = c.host.parentNode), i(u))
        return !1;
      u = u.parentNode;
    }
    return !0;
  }
  function o(l, u) {
    var c = l.nodeName.toLowerCase(), h = t.test(c) && !l.disabled || c === "a" && l.href || u;
    return h && r(l);
  }
  function s(l) {
    var u = l.getAttribute("tabindex");
    u === null && (u = void 0);
    var c = isNaN(u);
    return (c || u >= 0) && o(l, !c);
  }
  function a(l) {
    var u = [].slice.call(l.querySelectorAll("*"), 0).reduce(function(c, h) {
      return c.concat(h.shadowRoot ? a(h.shadowRoot) : [h]);
    }, []);
    return u.filter(s);
  }
  n.exports = e.default;
})(u8, Fv);
Object.defineProperty(ol, "__esModule", {
  value: !0
});
ol.resetState = f8;
ol.log = p8;
ol.handleBlur = kv;
ol.handleFocus = Wv;
ol.markForFocusLater = g8;
ol.returnFocus = m8;
ol.popWithoutFocus = v8;
ol.setupScopedFocus = _8;
ol.teardownScopedFocus = C8;
var c8 = Fv, h8 = d8(c8);
function d8(n) {
  return n && n.__esModule ? n : { default: n };
}
var Nd = [], Jf = null, x1 = !1;
function f8() {
  Nd = [];
}
function p8() {
  process.env.NODE_ENV !== "production" && (console.log("focusManager ----------"), Nd.forEach(function(n) {
    var e = n || {};
    console.log(e.nodeName, e.className, e.id);
  }), console.log("end focusManager ----------"));
}
function kv() {
  x1 = !0;
}
function Wv() {
  if (x1) {
    if (x1 = !1, !Jf)
      return;
    setTimeout(function() {
      if (!Jf.contains(document.activeElement)) {
        var n = (0, h8.default)(Jf)[0] || Jf;
        n.focus();
      }
    }, 0);
  }
}
function g8() {
  Nd.push(document.activeElement);
}
function m8() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, e = null;
  try {
    Nd.length !== 0 && (e = Nd.pop(), e.focus({ preventScroll: n }));
    return;
  } catch {
    console.warn(["You tried to return focus to", e, "but it is not in the DOM anymore"].join(" "));
  }
}
function v8() {
  Nd.length > 0 && Nd.pop();
}
function _8(n) {
  Jf = n, window.addEventListener ? (window.addEventListener("blur", kv, !1), document.addEventListener("focus", Wv, !0)) : (window.attachEvent("onBlur", kv), document.attachEvent("onFocus", Wv));
}
function C8() {
  Jf = null, window.addEventListener ? (window.removeEventListener("blur", kv), document.removeEventListener("focus", Wv)) : (window.detachEvent("onBlur", kv), document.detachEvent("onFocus", Wv));
}
var Iw = {}, y8 = {
  get exports() {
    return Iw;
  },
  set exports(n) {
    Iw = n;
  }
};
(function(n, e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = s;
  var t = Fv, i = r(t);
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function o() {
    var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
    return a.activeElement.shadowRoot ? o(a.activeElement.shadowRoot) : a.activeElement;
  }
  function s(a, l) {
    var u = (0, i.default)(a);
    if (!u.length) {
      l.preventDefault();
      return;
    }
    var c = void 0, h = l.shiftKey, d = u[0], f = u[u.length - 1], p = o();
    if (a === p) {
      if (!h)
        return;
      c = f;
    }
    if (f === p && !h && (c = d), d === p && h && (c = f), c) {
      l.preventDefault(), c.focus();
      return;
    }
    var g = /(\bChrome\b|\bSafari\b)\//.exec(navigator.userAgent), _ = g != null && g[1] != "Chrome" && /\biPod\b|\biPad\b/g.exec(navigator.userAgent) == null;
    if (_) {
      var m = u.indexOf(p);
      if (m > -1 && (m += h ? -1 : 1), c = u[m], typeof c > "u") {
        l.preventDefault(), c = h ? f : d, c.focus();
        return;
      }
      l.preventDefault(), c.focus();
    }
  }
  n.exports = e.default;
})(y8, Iw);
var sl = {}, w8 = process.env.NODE_ENV !== "production", ZV = function() {
};
if (w8) {
  var b8 = function(e, t) {
    var i = arguments.length;
    t = new Array(i > 1 ? i - 1 : 0);
    for (var r = 1; r < i; r++)
      t[r - 1] = arguments[r];
    var o = 0, s = "Warning: " + e.replace(/%s/g, function() {
      return t[o++];
    });
    typeof console < "u" && console.error(s);
    try {
      throw new Error(s);
    } catch {
    }
  };
  ZV = function(n, e, t) {
    var i = arguments.length;
    t = new Array(i > 2 ? i - 2 : 0);
    for (var r = 2; r < i; r++)
      t[r - 2] = arguments[r];
    if (e === void 0)
      throw new Error(
        "`warning(condition, format, ...args)` requires a warning message argument"
      );
    n || b8.apply(null, [e].concat(t));
  };
}
var S8 = ZV, Za = {}, N1 = {}, E8 = {
  get exports() {
    return N1;
  },
  set exports(n) {
    N1 = n;
  }
};
/*!
  Copyright (c) 2015 Jed Watson.
  Based on code that is Copyright 2013-2015, Facebook, Inc.
  All rights reserved.
*/
(function(n) {
  (function() {
    var e = !!(typeof window < "u" && window.document && window.document.createElement), t = {
      canUseDOM: e,
      canUseWorkers: typeof Worker < "u",
      canUseEventListeners: e && !!(window.addEventListener || window.attachEvent),
      canUseViewport: e && !!window.screen
    };
    n.exports ? n.exports = t : window.ExecutionEnvironment = t;
  })();
})(E8);
Object.defineProperty(Za, "__esModule", {
  value: !0
});
Za.canUseDOM = Za.SafeNodeList = Za.SafeHTMLCollection = void 0;
var L8 = N1, D8 = R8(L8);
function R8(n) {
  return n && n.__esModule ? n : { default: n };
}
var SS = D8.default, T8 = SS.canUseDOM ? window.HTMLElement : {};
Za.SafeHTMLCollection = SS.canUseDOM ? window.HTMLCollection : {};
Za.SafeNodeList = SS.canUseDOM ? window.NodeList : {};
Za.canUseDOM = SS.canUseDOM;
Za.default = T8;
Object.defineProperty(sl, "__esModule", {
  value: !0
});
sl.resetState = P8;
sl.log = A8;
sl.assertNodeList = QV;
sl.setElement = M8;
sl.validateElement = rx;
sl.hide = F8;
sl.show = k8;
sl.documentNotReadyOrSSRTesting = W8;
var O8 = S8, x8 = I8(O8), N8 = Za;
function I8(n) {
  return n && n.__esModule ? n : { default: n };
}
var fs = null;
function P8() {
  fs && (fs.removeAttribute ? fs.removeAttribute("aria-hidden") : fs.length != null ? fs.forEach(function(n) {
    return n.removeAttribute("aria-hidden");
  }) : document.querySelectorAll(fs).forEach(function(n) {
    return n.removeAttribute("aria-hidden");
  })), fs = null;
}
function A8() {
  if (process.env.NODE_ENV !== "production") {
    var n = fs || {};
    console.log("ariaAppHider ----------"), console.log(n.nodeName, n.className, n.id), console.log("end ariaAppHider ----------");
  }
}
function QV(n, e) {
  if (!n || !n.length)
    throw new Error("react-modal: No elements were found for selector " + e + ".");
}
function M8(n) {
  var e = n;
  if (typeof e == "string" && N8.canUseDOM) {
    var t = document.querySelectorAll(e);
    QV(t, e), e = t;
  }
  return fs = e || fs, fs;
}
function rx(n) {
  var e = n || fs;
  return e ? Array.isArray(e) || e instanceof HTMLCollection || e instanceof NodeList ? e : [e] : ((0, x8.default)(!1, ["react-modal: App element is not defined.", "Please use `Modal.setAppElement(el)` or set `appElement={el}`.", "This is needed so screen readers don't see main content", "when modal is opened. It is not recommended, but you can opt-out", "by setting `ariaHideApp={false}`."].join(" ")), []);
}
function F8(n) {
  var e = !0, t = !1, i = void 0;
  try {
    for (var r = rx(n)[Symbol.iterator](), o; !(e = (o = r.next()).done); e = !0) {
      var s = o.value;
      s.setAttribute("aria-hidden", "true");
    }
  } catch (a) {
    t = !0, i = a;
  } finally {
    try {
      !e && r.return && r.return();
    } finally {
      if (t)
        throw i;
    }
  }
}
function k8(n) {
  var e = !0, t = !1, i = void 0;
  try {
    for (var r = rx(n)[Symbol.iterator](), o; !(e = (o = r.next()).done); e = !0) {
      var s = o.value;
      s.removeAttribute("aria-hidden");
    }
  } catch (a) {
    t = !0, i = a;
  } finally {
    try {
      !e && r.return && r.return();
    } finally {
      if (t)
        throw i;
    }
  }
}
function W8() {
  fs = null;
}
var mg = {};
Object.defineProperty(mg, "__esModule", {
  value: !0
});
mg.resetState = V8;
mg.log = B8;
var gd = {}, md = {};
function cM(n, e) {
  n.classList.remove(e);
}
function V8() {
  var n = document.getElementsByTagName("html")[0];
  for (var e in gd)
    cM(n, gd[e]);
  var t = document.body;
  for (var i in md)
    cM(t, md[i]);
  gd = {}, md = {};
}
function B8() {
  if (process.env.NODE_ENV !== "production") {
    var n = document.getElementsByTagName("html")[0].className, e = `Show tracked classes:

`;
    e += "<html /> (" + n + `):
  `;
    for (var t in gd)
      e += "  " + t + " " + gd[t] + `
  `;
    n = document.body.className, e += `

doc.body (` + n + `):
  `;
    for (var i in md)
      e += "  " + i + " " + md[i] + `
  `;
    e += `
`, console.log(e);
  }
}
var H8 = function(e, t) {
  return e[t] || (e[t] = 0), e[t] += 1, t;
}, G8 = function(e, t) {
  return e[t] && (e[t] -= 1), t;
}, U8 = function(e, t, i) {
  i.forEach(function(r) {
    H8(t, r), e.add(r);
  });
}, z8 = function(e, t, i) {
  i.forEach(function(r) {
    G8(t, r), t[r] === 0 && e.remove(r);
  });
};
mg.add = function(e, t) {
  return U8(e.classList, e.nodeName.toLowerCase() == "html" ? gd : md, t.split(" "));
};
mg.remove = function(e, t) {
  return z8(e.classList, e.nodeName.toLowerCase() == "html" ? gd : md, t.split(" "));
};
var vg = {};
Object.defineProperty(vg, "__esModule", {
  value: !0
});
vg.log = $8;
vg.resetState = K8;
function j8(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
var JV = function n() {
  var e = this;
  j8(this, n), this.register = function(t) {
    if (e.openInstances.indexOf(t) !== -1) {
      process.env.NODE_ENV !== "production" && console.warn("React-Modal: Cannot register modal instance that's already open");
      return;
    }
    e.openInstances.push(t), e.emit("register");
  }, this.deregister = function(t) {
    var i = e.openInstances.indexOf(t);
    if (i === -1) {
      process.env.NODE_ENV !== "production" && console.warn("React-Modal: Unable to deregister " + t + " as it was never registered");
      return;
    }
    e.openInstances.splice(i, 1), e.emit("deregister");
  }, this.subscribe = function(t) {
    e.subscribers.push(t);
  }, this.emit = function(t) {
    e.subscribers.forEach(function(i) {
      return i(
        t,
        // shallow copy to avoid accidental mutation
        e.openInstances.slice()
      );
    });
  }, this.openInstances = [], this.subscribers = [];
}, Pw = new JV();
function $8() {
  console.log("portalOpenInstances ----------"), console.log(Pw.openInstances.length), Pw.openInstances.forEach(function(n) {
    return console.log(n);
  }), console.log("end portalOpenInstances ----------");
}
function K8() {
  Pw = new JV();
}
vg.default = Pw;
var ox = {};
Object.defineProperty(ox, "__esModule", {
  value: !0
});
ox.resetState = Z8;
ox.log = Q8;
var q8 = vg, Y8 = X8(q8);
function X8(n) {
  return n && n.__esModule ? n : { default: n };
}
var $r = void 0, Pa = void 0, vd = [];
function Z8() {
  for (var n = [$r, Pa], e = 0; e < n.length; e++) {
    var t = n[e];
    t && t.parentNode && t.parentNode.removeChild(t);
  }
  $r = Pa = null, vd = [];
}
function Q8() {
  console.log("bodyTrap ----------"), console.log(vd.length);
  for (var n = [$r, Pa], e = 0; e < n.length; e++) {
    var t = n[e], i = t || {};
    console.log(i.nodeName, i.className, i.id);
  }
  console.log("edn bodyTrap ----------");
}
function hM() {
  if (vd.length === 0) {
    process.env.NODE_ENV !== "production" && console.warn("React-Modal: Open instances > 0 expected");
    return;
  }
  vd[vd.length - 1].focusContent();
}
function J8(n, e) {
  !$r && !Pa && ($r = document.createElement("div"), $r.setAttribute("data-react-modal-body-trap", ""), $r.style.position = "absolute", $r.style.opacity = "0", $r.setAttribute("tabindex", "0"), $r.addEventListener("focus", hM), Pa = $r.cloneNode(), Pa.addEventListener("focus", hM)), vd = e, vd.length > 0 ? (document.body.firstChild !== $r && document.body.insertBefore($r, document.body.firstChild), document.body.lastChild !== Pa && document.body.appendChild(Pa)) : ($r.parentElement && $r.parentElement.removeChild($r), Pa.parentElement && Pa.parentElement.removeChild(Pa));
}
Y8.default.subscribe(J8);
(function(n, e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = Object.assign || function(z) {
    for (var j = 1; j < arguments.length; j++) {
      var $ = arguments[j];
      for (var k in $)
        Object.prototype.hasOwnProperty.call($, k) && (z[k] = $[k]);
    }
    return z;
  }, i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(z) {
    return typeof z;
  } : function(z) {
    return z && typeof Symbol == "function" && z.constructor === Symbol && z !== Symbol.prototype ? "symbol" : typeof z;
  }, r = function() {
    function z(j, $) {
      for (var k = 0; k < $.length; k++) {
        var ae = $[k];
        ae.enumerable = ae.enumerable || !1, ae.configurable = !0, "value" in ae && (ae.writable = !0), Object.defineProperty(j, ae.key, ae);
      }
    }
    return function(j, $, k) {
      return $ && z(j.prototype, $), k && z(j, k), j;
    };
  }(), o = bt, s = Qu, a = w(s), l = ol, u = y(l), c = Iw, h = w(c), d = sl, f = y(d), p = mg, g = y(p), _ = Za, m = w(_), v = vg, C = w(v);
  function y(z) {
    if (z && z.__esModule)
      return z;
    var j = {};
    if (z != null)
      for (var $ in z)
        Object.prototype.hasOwnProperty.call(z, $) && (j[$] = z[$]);
    return j.default = z, j;
  }
  function w(z) {
    return z && z.__esModule ? z : { default: z };
  }
  function L(z, j) {
    if (!(z instanceof j))
      throw new TypeError("Cannot call a class as a function");
  }
  function S(z, j) {
    if (!z)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return j && (typeof j == "object" || typeof j == "function") ? j : z;
  }
  function E(z, j) {
    if (typeof j != "function" && j !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof j);
    z.prototype = Object.create(j && j.prototype, { constructor: { value: z, enumerable: !1, writable: !0, configurable: !0 } }), j && (Object.setPrototypeOf ? Object.setPrototypeOf(z, j) : z.__proto__ = j);
  }
  var D = {
    overlay: "ReactModal__Overlay",
    content: "ReactModal__Content"
  }, x = 9, R = 27, A = 0, M = function(z) {
    E(j, z);
    function j($) {
      L(this, j);
      var k = S(this, (j.__proto__ || Object.getPrototypeOf(j)).call(this, $));
      return k.setOverlayRef = function(ae) {
        k.overlay = ae, k.props.overlayRef && k.props.overlayRef(ae);
      }, k.setContentRef = function(ae) {
        k.content = ae, k.props.contentRef && k.props.contentRef(ae);
      }, k.afterClose = function() {
        var ae = k.props, re = ae.appElement, Y = ae.ariaHideApp, K = ae.htmlOpenClassName, W = ae.bodyOpenClassName;
        W && g.remove(document.body, W), K && g.remove(document.getElementsByTagName("html")[0], K), Y && A > 0 && (A -= 1, A === 0 && f.show(re)), k.props.shouldFocusAfterRender && (k.props.shouldReturnFocusAfterClose ? (u.returnFocus(k.props.preventScroll), u.teardownScopedFocus()) : u.popWithoutFocus()), k.props.onAfterClose && k.props.onAfterClose(), C.default.deregister(k);
      }, k.open = function() {
        k.beforeOpen(), k.state.afterOpen && k.state.beforeClose ? (clearTimeout(k.closeTimer), k.setState({ beforeClose: !1 })) : (k.props.shouldFocusAfterRender && (u.setupScopedFocus(k.node), u.markForFocusLater()), k.setState({ isOpen: !0 }, function() {
          k.openAnimationFrame = requestAnimationFrame(function() {
            k.setState({ afterOpen: !0 }), k.props.isOpen && k.props.onAfterOpen && k.props.onAfterOpen({
              overlayEl: k.overlay,
              contentEl: k.content
            });
          });
        }));
      }, k.close = function() {
        k.props.closeTimeoutMS > 0 ? k.closeWithTimeout() : k.closeWithoutTimeout();
      }, k.focusContent = function() {
        return k.content && !k.contentHasFocus() && k.content.focus({ preventScroll: !0 });
      }, k.closeWithTimeout = function() {
        var ae = Date.now() + k.props.closeTimeoutMS;
        k.setState({ beforeClose: !0, closesAt: ae }, function() {
          k.closeTimer = setTimeout(k.closeWithoutTimeout, k.state.closesAt - Date.now());
        });
      }, k.closeWithoutTimeout = function() {
        k.setState({
          beforeClose: !1,
          isOpen: !1,
          afterOpen: !1,
          closesAt: null
        }, k.afterClose);
      }, k.handleKeyDown = function(ae) {
        ae.keyCode === x && (0, h.default)(k.content, ae), k.props.shouldCloseOnEsc && ae.keyCode === R && (ae.stopPropagation(), k.requestClose(ae));
      }, k.handleOverlayOnClick = function(ae) {
        k.shouldClose === null && (k.shouldClose = !0), k.shouldClose && k.props.shouldCloseOnOverlayClick && (k.ownerHandlesClose() ? k.requestClose(ae) : k.focusContent()), k.shouldClose = null;
      }, k.handleContentOnMouseUp = function() {
        k.shouldClose = !1;
      }, k.handleOverlayOnMouseDown = function(ae) {
        !k.props.shouldCloseOnOverlayClick && ae.target == k.overlay && ae.preventDefault();
      }, k.handleContentOnClick = function() {
        k.shouldClose = !1;
      }, k.handleContentOnMouseDown = function() {
        k.shouldClose = !1;
      }, k.requestClose = function(ae) {
        return k.ownerHandlesClose() && k.props.onRequestClose(ae);
      }, k.ownerHandlesClose = function() {
        return k.props.onRequestClose;
      }, k.shouldBeClosed = function() {
        return !k.state.isOpen && !k.state.beforeClose;
      }, k.contentHasFocus = function() {
        return document.activeElement === k.content || k.content.contains(document.activeElement);
      }, k.buildClassName = function(ae, re) {
        var Y = (typeof re > "u" ? "undefined" : i(re)) === "object" ? re : {
          base: D[ae],
          afterOpen: D[ae] + "--after-open",
          beforeClose: D[ae] + "--before-close"
        }, K = Y.base;
        return k.state.afterOpen && (K = K + " " + Y.afterOpen), k.state.beforeClose && (K = K + " " + Y.beforeClose), typeof re == "string" && re ? K + " " + re : K;
      }, k.attributesFromObject = function(ae, re) {
        return Object.keys(re).reduce(function(Y, K) {
          return Y[ae + "-" + K] = re[K], Y;
        }, {});
      }, k.state = {
        afterOpen: !1,
        beforeClose: !1
      }, k.shouldClose = null, k.moveFromContentToOverlay = null, k;
    }
    return r(j, [{
      key: "componentDidMount",
      value: function() {
        this.props.isOpen && this.open();
      }
    }, {
      key: "componentDidUpdate",
      value: function(k, ae) {
        process.env.NODE_ENV !== "production" && (k.bodyOpenClassName !== this.props.bodyOpenClassName && console.warn('React-Modal: "bodyOpenClassName" prop has been modified. This may cause unexpected behavior when multiple modals are open.'), k.htmlOpenClassName !== this.props.htmlOpenClassName && console.warn('React-Modal: "htmlOpenClassName" prop has been modified. This may cause unexpected behavior when multiple modals are open.')), this.props.isOpen && !k.isOpen ? this.open() : !this.props.isOpen && k.isOpen && this.close(), this.props.shouldFocusAfterRender && this.state.isOpen && !ae.isOpen && this.focusContent();
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.state.isOpen && this.afterClose(), clearTimeout(this.closeTimer), cancelAnimationFrame(this.openAnimationFrame);
      }
    }, {
      key: "beforeOpen",
      value: function() {
        var k = this.props, ae = k.appElement, re = k.ariaHideApp, Y = k.htmlOpenClassName, K = k.bodyOpenClassName;
        K && g.add(document.body, K), Y && g.add(document.getElementsByTagName("html")[0], Y), re && (A += 1, f.hide(ae)), C.default.register(this);
      }
      // Don't steal focus from inner elements
    }, {
      key: "render",
      value: function() {
        var k = this.props, ae = k.id, re = k.className, Y = k.overlayClassName, K = k.defaultStyles, W = k.children, B = re ? {} : K.content, U = Y ? {} : K.overlay;
        if (this.shouldBeClosed())
          return null;
        var O = {
          ref: this.setOverlayRef,
          className: this.buildClassName("overlay", Y),
          style: t({}, U, this.props.style.overlay),
          onClick: this.handleOverlayOnClick,
          onMouseDown: this.handleOverlayOnMouseDown
        }, N = t({
          id: ae,
          ref: this.setContentRef,
          style: t({}, B, this.props.style.content),
          className: this.buildClassName("content", re),
          tabIndex: "-1",
          onKeyDown: this.handleKeyDown,
          onMouseDown: this.handleContentOnMouseDown,
          onMouseUp: this.handleContentOnMouseUp,
          onClick: this.handleContentOnClick,
          role: this.props.role,
          "aria-label": this.props.contentLabel
        }, this.attributesFromObject("aria", t({ modal: !0 }, this.props.aria)), this.attributesFromObject("data", this.props.data || {}), {
          "data-testid": this.props.testId
        }), I = this.props.contentElement(N, W);
        return this.props.overlayElement(O, I);
      }
    }]), j;
  }(o.Component);
  M.defaultProps = {
    style: {
      overlay: {},
      content: {}
    },
    defaultStyles: {}
  }, M.propTypes = {
    isOpen: a.default.bool.isRequired,
    defaultStyles: a.default.shape({
      content: a.default.object,
      overlay: a.default.object
    }),
    style: a.default.shape({
      content: a.default.object,
      overlay: a.default.object
    }),
    className: a.default.oneOfType([a.default.string, a.default.object]),
    overlayClassName: a.default.oneOfType([a.default.string, a.default.object]),
    bodyOpenClassName: a.default.string,
    htmlOpenClassName: a.default.string,
    ariaHideApp: a.default.bool,
    appElement: a.default.oneOfType([a.default.instanceOf(m.default), a.default.instanceOf(_.SafeHTMLCollection), a.default.instanceOf(_.SafeNodeList), a.default.arrayOf(a.default.instanceOf(m.default))]),
    onAfterOpen: a.default.func,
    onAfterClose: a.default.func,
    onRequestClose: a.default.func,
    closeTimeoutMS: a.default.number,
    shouldFocusAfterRender: a.default.bool,
    shouldCloseOnOverlayClick: a.default.bool,
    shouldReturnFocusAfterClose: a.default.bool,
    preventScroll: a.default.bool,
    role: a.default.string,
    contentLabel: a.default.string,
    aria: a.default.object,
    data: a.default.object,
    children: a.default.node,
    shouldCloseOnEsc: a.default.bool,
    overlayRef: a.default.func,
    contentRef: a.default.func,
    id: a.default.string,
    overlayElement: a.default.func,
    contentElement: a.default.func,
    testId: a.default.string
  }, e.default = M, n.exports = e.default;
})(l8, Nw);
function eB() {
  var n = this.constructor.getDerivedStateFromProps(this.props, this.state);
  n != null && this.setState(n);
}
function tB(n) {
  function e(t) {
    var i = this.constructor.getDerivedStateFromProps(n, t);
    return i ?? null;
  }
  this.setState(e.bind(this));
}
function iB(n, e) {
  try {
    var t = this.props, i = this.state;
    this.props = n, this.state = e, this.__reactInternalSnapshotFlag = !0, this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      t,
      i
    );
  } finally {
    this.props = t, this.state = i;
  }
}
eB.__suppressDeprecationWarning = !0;
tB.__suppressDeprecationWarning = !0;
iB.__suppressDeprecationWarning = !0;
function e9(n) {
  var e = n.prototype;
  if (!e || !e.isReactComponent)
    throw new Error("Can only polyfill class components");
  if (typeof n.getDerivedStateFromProps != "function" && typeof e.getSnapshotBeforeUpdate != "function")
    return n;
  var t = null, i = null, r = null;
  if (typeof e.componentWillMount == "function" ? t = "componentWillMount" : typeof e.UNSAFE_componentWillMount == "function" && (t = "UNSAFE_componentWillMount"), typeof e.componentWillReceiveProps == "function" ? i = "componentWillReceiveProps" : typeof e.UNSAFE_componentWillReceiveProps == "function" && (i = "UNSAFE_componentWillReceiveProps"), typeof e.componentWillUpdate == "function" ? r = "componentWillUpdate" : typeof e.UNSAFE_componentWillUpdate == "function" && (r = "UNSAFE_componentWillUpdate"), t !== null || i !== null || r !== null) {
    var o = n.displayName || n.name, s = typeof n.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
    throw Error(
      `Unsafe legacy lifecycles will not be called for components using new component APIs.

` + o + " uses " + s + " but also contains the following legacy lifecycles:" + (t !== null ? `
  ` + t : "") + (i !== null ? `
  ` + i : "") + (r !== null ? `
  ` + r : "") + `

The above lifecycles should be removed. Learn more about this warning here:
https://fb.me/react-async-component-lifecycle-hooks`
    );
  }
  if (typeof n.getDerivedStateFromProps == "function" && (e.componentWillMount = eB, e.componentWillReceiveProps = tB), typeof e.getSnapshotBeforeUpdate == "function") {
    if (typeof e.componentDidUpdate != "function")
      throw new Error(
        "Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype"
      );
    e.componentWillUpdate = iB;
    var a = e.componentDidUpdate;
    e.componentDidUpdate = function(u, c, h) {
      var d = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : h;
      a.call(this, u, c, d);
    };
  }
  return n;
}
const t9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  polyfill: e9
}, Symbol.toStringTag, { value: "Module" })), i9 = /* @__PURE__ */ YO(t9);
Object.defineProperty(xd, "__esModule", {
  value: !0
});
xd.bodyOpenClassName = xd.portalClassName = void 0;
var dM = Object.assign || function(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e];
    for (var i in t)
      Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
  }
  return n;
}, n9 = function() {
  function n(e, t) {
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
    }
  }
  return function(e, t, i) {
    return t && n(e.prototype, t), i && n(e, i), e;
  };
}(), nB = bt, Aw = D_(nB), r9 = pg, Mw = D_(r9), o9 = Qu, vt = D_(o9), s9 = Nw, fM = D_(s9), a9 = sl, l9 = c9(a9), Uc = Za, pM = D_(Uc), u9 = i9;
function c9(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}
function D_(n) {
  return n && n.__esModule ? n : { default: n };
}
function h9(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function gM(n, e) {
  if (!n)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : n;
}
function d9(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  n.prototype = Object.create(e && e.prototype, { constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e);
}
var f9 = xd.portalClassName = "ReactModalPortal", p9 = xd.bodyOpenClassName = "ReactModal__Body--open", $h = Uc.canUseDOM && Mw.default.createPortal !== void 0, I1 = function(e) {
  return document.createElement(e);
}, mM = function() {
  return $h ? Mw.default.createPortal : Mw.default.unstable_renderSubtreeIntoContainer;
};
function PC(n) {
  return n();
}
var _g = function(n) {
  d9(e, n);
  function e() {
    var t, i, r, o;
    h9(this, e);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return o = (i = (r = gM(this, (t = e.__proto__ || Object.getPrototypeOf(e)).call.apply(t, [this].concat(a))), r), r.removePortal = function() {
      !$h && Mw.default.unmountComponentAtNode(r.node);
      var u = PC(r.props.parentSelector);
      u && u.contains(r.node) ? u.removeChild(r.node) : console.warn('React-Modal: "parentSelector" prop did not returned any DOM element. Make sure that the parent element is unmounted to avoid any memory leaks.');
    }, r.portalRef = function(u) {
      r.portal = u;
    }, r.renderPortal = function(u) {
      var c = mM(), h = c(r, Aw.default.createElement(fM.default, dM({ defaultStyles: e.defaultStyles }, u)), r.node);
      r.portalRef(h);
    }, i), gM(r, o);
  }
  return n9(e, [{
    key: "componentDidMount",
    value: function() {
      if (Uc.canUseDOM) {
        $h || (this.node = I1("div")), this.node.className = this.props.portalClassName;
        var i = PC(this.props.parentSelector);
        i.appendChild(this.node), !$h && this.renderPortal(this.props);
      }
    }
  }, {
    key: "getSnapshotBeforeUpdate",
    value: function(i) {
      var r = PC(i.parentSelector), o = PC(this.props.parentSelector);
      return { prevParent: r, nextParent: o };
    }
  }, {
    key: "componentDidUpdate",
    value: function(i, r, o) {
      if (Uc.canUseDOM) {
        var s = this.props, a = s.isOpen, l = s.portalClassName;
        i.portalClassName !== l && (this.node.className = l);
        var u = o.prevParent, c = o.nextParent;
        c !== u && (u.removeChild(this.node), c.appendChild(this.node)), !(!i.isOpen && !a) && !$h && this.renderPortal(this.props);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      if (!(!Uc.canUseDOM || !this.node || !this.portal)) {
        var i = this.portal.state, r = Date.now(), o = i.isOpen && this.props.closeTimeoutMS && (i.closesAt || r + this.props.closeTimeoutMS);
        o ? (i.beforeClose || this.portal.closeWithTimeout(), setTimeout(this.removePortal, o - r)) : this.removePortal();
      }
    }
  }, {
    key: "render",
    value: function() {
      if (!Uc.canUseDOM || !$h)
        return null;
      !this.node && $h && (this.node = I1("div"));
      var i = mM();
      return i(Aw.default.createElement(fM.default, dM({
        ref: this.portalRef,
        defaultStyles: e.defaultStyles
      }, this.props)), this.node);
    }
  }], [{
    key: "setAppElement",
    value: function(i) {
      l9.setElement(i);
    }
    /* eslint-disable react/no-unused-prop-types */
    /* eslint-enable react/no-unused-prop-types */
  }]), e;
}(nB.Component);
_g.propTypes = {
  isOpen: vt.default.bool.isRequired,
  style: vt.default.shape({
    content: vt.default.object,
    overlay: vt.default.object
  }),
  portalClassName: vt.default.string,
  bodyOpenClassName: vt.default.string,
  htmlOpenClassName: vt.default.string,
  className: vt.default.oneOfType([vt.default.string, vt.default.shape({
    base: vt.default.string.isRequired,
    afterOpen: vt.default.string.isRequired,
    beforeClose: vt.default.string.isRequired
  })]),
  overlayClassName: vt.default.oneOfType([vt.default.string, vt.default.shape({
    base: vt.default.string.isRequired,
    afterOpen: vt.default.string.isRequired,
    beforeClose: vt.default.string.isRequired
  })]),
  appElement: vt.default.oneOfType([vt.default.instanceOf(pM.default), vt.default.instanceOf(Uc.SafeHTMLCollection), vt.default.instanceOf(Uc.SafeNodeList), vt.default.arrayOf(vt.default.instanceOf(pM.default))]),
  onAfterOpen: vt.default.func,
  onRequestClose: vt.default.func,
  closeTimeoutMS: vt.default.number,
  ariaHideApp: vt.default.bool,
  shouldFocusAfterRender: vt.default.bool,
  shouldCloseOnOverlayClick: vt.default.bool,
  shouldReturnFocusAfterClose: vt.default.bool,
  preventScroll: vt.default.bool,
  parentSelector: vt.default.func,
  aria: vt.default.object,
  data: vt.default.object,
  role: vt.default.string,
  contentLabel: vt.default.string,
  shouldCloseOnEsc: vt.default.bool,
  overlayRef: vt.default.func,
  contentRef: vt.default.func,
  id: vt.default.string,
  overlayElement: vt.default.func,
  contentElement: vt.default.func
};
_g.defaultProps = {
  isOpen: !1,
  portalClassName: f9,
  bodyOpenClassName: p9,
  role: "dialog",
  ariaHideApp: !0,
  closeTimeoutMS: 0,
  shouldFocusAfterRender: !0,
  shouldCloseOnEsc: !0,
  shouldCloseOnOverlayClick: !0,
  shouldReturnFocusAfterClose: !0,
  preventScroll: !1,
  parentSelector: function() {
    return document.body;
  },
  overlayElement: function(e, t) {
    return Aw.default.createElement(
      "div",
      e,
      t
    );
  },
  contentElement: function(e, t) {
    return Aw.default.createElement(
      "div",
      e,
      t
    );
  }
};
_g.defaultStyles = {
  overlay: {
    position: "fixed",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(255, 255, 255, 0.75)"
  },
  content: {
    position: "absolute",
    top: "40px",
    left: "40px",
    right: "40px",
    bottom: "40px",
    border: "1px solid #ccc",
    background: "#fff",
    overflow: "auto",
    WebkitOverflowScrolling: "touch",
    borderRadius: "4px",
    outline: "none",
    padding: "20px"
  }
};
(0, u9.polyfill)(_g);
process.env.NODE_ENV !== "production" && (_g.setCreateHTMLElement = function(n) {
  return I1 = n;
});
xd.default = _g;
(function(n, e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = xd, i = r(t);
  function r(o) {
    return o && o.__esModule ? o : { default: o };
  }
  e.default = i.default, n.exports = e.default;
})(a8, xw);
const zCe = /* @__PURE__ */ LV(xw);
var mp = {}, g9 = {
  get exports() {
    return mp;
  },
  set exports(n) {
    mp = n;
  }
};
/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.13.3
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 20.07.2022
 */
(function(n) {
  (function(e, t) {
    n.exports = t(e, e.document, void 0);
  })(
    typeof window < "u" ? window : Ae,
    function(e, t, i) {
      var r = "OverlayScrollbars", o = {
        o: "object",
        f: "function",
        a: "array",
        s: "string",
        b: "boolean",
        n: "number",
        u: "undefined",
        z: "null"
        //d : 'date',
        //e : 'error',
        //r : 'regexp',
        //y : 'symbol'
      }, s = {
        c: "class",
        s: "style",
        i: "id",
        l: "length",
        p: "prototype",
        ti: "tabindex",
        oH: "offsetHeight",
        cH: "clientHeight",
        sH: "scrollHeight",
        oW: "offsetWidth",
        cW: "clientWidth",
        sW: "scrollWidth",
        hOP: "hasOwnProperty",
        bCR: "getBoundingClientRect"
      }, a = function() {
        var g = {}, _ = {}, m = ["-webkit-", "-moz-", "-o-", "-ms-"], v = ["WebKit", "Moz", "O", "MS"];
        function C(y) {
          return y.charAt(0).toUpperCase() + y.slice(1);
        }
        return {
          _cssPrefixes: m,
          _jsPrefixes: v,
          _cssProperty: function(y) {
            var w = _[y];
            if (_[s.hOP](y))
              return w;
            for (var L = C(y), S = t.createElement("div")[s.s], E, D = 0, x, R; D < m.length; D++)
              for (R = m[D].replace(/-/g, ""), E = [
                y,
                //transition
                m[D] + y,
                //-webkit-transition
                R + L,
                //webkitTransition
                C(R) + L
                //WebkitTransition
              ], x = 0; x < E[s.l]; x++)
                if (S[E[x]] !== i) {
                  w = E[x];
                  break;
                }
            return _[y] = w, w;
          },
          _cssPropertyValue: function(y, w, L) {
            var S = y + " " + w, E = _[S];
            if (_[s.hOP](S))
              return E;
            for (var D = t.createElement("div")[s.s], x = w.split(" "), R = L || "", A = 0, M = -1, z; A < x[s.l]; A++)
              for (; M < a._cssPrefixes[s.l]; M++)
                if (z = M < 0 ? x[A] : a._cssPrefixes[M] + x[A], D.cssText = y + ":" + z + R, D[s.l]) {
                  E = z;
                  break;
                }
            return _[S] = E, E;
          },
          _jsAPI: function(y, w, L) {
            var S = 0, E = g[y];
            if (!g[s.hOP](y)) {
              for (E = e[y]; S < v[s.l]; S++)
                E = E || e[(w ? v[S] : v[S].toLowerCase()) + C(y)];
              g[y] = E;
            }
            return E || L;
          }
        };
      }(), l = function() {
        function g(m) {
          return m ? e.innerWidth || t.documentElement[s.cW] || t.body[s.cW] : e.innerHeight || t.documentElement[s.cH] || t.body[s.cH];
        }
        function _(m, v) {
          if (typeof m != o.f)
            throw "Can't bind function!";
          var C = s.p, y = Array[C].slice.call(arguments, 2), w = function() {
          }, L = function() {
            return m.apply(this instanceof w ? this : v, y.concat(Array[C].slice.call(arguments)));
          };
          return m[C] && (w[C] = m[C]), L[C] = new w(), L;
        }
        return {
          /**
           * Gets the current window width.
           * @returns {Number|number} The current window width in pixel.
           */
          wW: _(g, 0, !0),
          /**
           * Gets the current window height.
           * @returns {Number|number} The current window height in pixel.
           */
          wH: _(g, 0),
          /**
           * Gets the MutationObserver Object or undefined if not supported.
           * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.
           */
          mO: _(a._jsAPI, 0, "MutationObserver", !0),
          /**
           * Gets the ResizeObserver Object or undefined if not supported.
           * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.
           */
          rO: _(a._jsAPI, 0, "ResizeObserver", !0),
          /**
           * Gets the RequestAnimationFrame method or it's corresponding polyfill.
           * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.
           */
          rAF: _(a._jsAPI, 0, "requestAnimationFrame", !1, function(m) {
            return e.setTimeout(m, 1e3 / 60);
          }),
          /**
           * Gets the CancelAnimationFrame method or it's corresponding polyfill.
           * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.
           */
          cAF: _(a._jsAPI, 0, "cancelAnimationFrame", !1, function(m) {
            return e.clearTimeout(m);
          }),
          /**
           * Gets the current time.
           * @returns {number} The current time.
           */
          now: function() {
            return Date.now && Date.now() || (/* @__PURE__ */ new Date()).getTime();
          },
          /**
           * Stops the propagation of the given event.
           * @param event The event of which the propagation shall be stoped.
           */
          stpP: function(m) {
            m.stopPropagation ? m.stopPropagation() : m.cancelBubble = !0;
          },
          /**
           * Prevents the default action of the given event.
           * @param event The event of which the default action shall be prevented.
           */
          prvD: function(m) {
            m.preventDefault && m.cancelable ? m.preventDefault() : m.returnValue = !1;
          },
          /**
           * Gets the pageX and pageY values of the given mouse event.
           * @param event The mouse event of which the pageX and pageX shall be got.
           * @returns {{x: number, y: number}} x = pageX value, y = pageY value.
           */
          page: function(m) {
            m = m.originalEvent || m;
            var v = "page", C = "client", y = "X", w = "Y", L = m.target || m.srcElement || t, S = L.ownerDocument || t, E = S.documentElement, D = S.body;
            if (m.touches !== i) {
              var x = m.touches[0];
              return {
                x: x[v + y],
                y: x[v + w]
              };
            }
            return !m[v + y] && m[C + y] && m[C + y] != null ? {
              x: m[C + y] + (E && E.scrollLeft || D && D.scrollLeft || 0) - (E && E.clientLeft || D && D.clientLeft || 0),
              y: m[C + w] + (E && E.scrollTop || D && D.scrollTop || 0) - (E && E.clientTop || D && D.clientTop || 0)
            } : {
              x: m[v + y],
              y: m[v + w]
            };
          },
          /**
           * Gets the clicked mouse button of the given mouse event.
           * @param event The mouse event of which the clicked button shal be got.
           * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)
           */
          mBtn: function(m) {
            var v = m.button;
            return !m.which && v !== i ? v & 1 ? 1 : v & 2 ? 3 : v & 4 ? 2 : 0 : m.which;
          },
          /**
           * Checks whether a item is in the given array and returns its index.
           * @param item The item of which the position in the array shall be determined.
           * @param arr The array.
           * @returns {number} The zero based index of the item or -1 if the item isn't in the array.
           */
          inA: function(m, v) {
            for (var C = 0; C < v[s.l]; C++)
              try {
                if (v[C] === m)
                  return C;
              } catch {
              }
            return -1;
          },
          /**
           * Returns true if the given value is a array.
           * @param arr The potential array.
           * @returns {boolean} True if the given value is a array, false otherwise.
           */
          isA: function(m) {
            var v = Array.isArray;
            return v ? v(m) : this.type(m) == o.a;
          },
          /**
           * Determine the internal JavaScript [[Class]] of the given object.
           * @param obj The object of which the type shall be determined.
           * @returns {string} The type of the given object.
           */
          type: function(m) {
            return m === i || m === null ? m + "" : Object[s.p].toString.call(m).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
          },
          bind: _
          /**
          	                 * Gets the vendor-prefixed CSS property by the given name.
          	                 * For example the given name is "transform" and you're using a old Firefox browser then the returned value would be "-moz-transform".
          	                 * If the browser doesn't need a vendor-prefix, then the returned string is the given name.
          	                 * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.
          	                 * @param propName The unprefixed CSS property name.
          	                 * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.
          
          	                cssProp: function(propName) {
          	                    return VENDORS._cssProperty(propName);
          	                }
          	                */
        };
      }(), u = Math, c = e.jQuery, h = function() {
        var g = {
          p: u.PI,
          c: u.cos,
          s: u.sin,
          w: u.pow,
          t: u.sqrt,
          n: u.asin,
          a: u.abs,
          o: 1.70158
        };
        return {
          swing: function(_, m, v, C, y) {
            return 0.5 - g.c(_ * g.p) / 2;
          },
          linear: function(_, m, v, C, y) {
            return _;
          },
          easeInQuad: function(_, m, v, C, y) {
            return C * (m /= y) * m + v;
          },
          easeOutQuad: function(_, m, v, C, y) {
            return -C * (m /= y) * (m - 2) + v;
          },
          easeInOutQuad: function(_, m, v, C, y) {
            return (m /= y / 2) < 1 ? C / 2 * m * m + v : -C / 2 * (--m * (m - 2) - 1) + v;
          },
          easeInCubic: function(_, m, v, C, y) {
            return C * (m /= y) * m * m + v;
          },
          easeOutCubic: function(_, m, v, C, y) {
            return C * ((m = m / y - 1) * m * m + 1) + v;
          },
          easeInOutCubic: function(_, m, v, C, y) {
            return (m /= y / 2) < 1 ? C / 2 * m * m * m + v : C / 2 * ((m -= 2) * m * m + 2) + v;
          },
          easeInQuart: function(_, m, v, C, y) {
            return C * (m /= y) * m * m * m + v;
          },
          easeOutQuart: function(_, m, v, C, y) {
            return -C * ((m = m / y - 1) * m * m * m - 1) + v;
          },
          easeInOutQuart: function(_, m, v, C, y) {
            return (m /= y / 2) < 1 ? C / 2 * m * m * m * m + v : -C / 2 * ((m -= 2) * m * m * m - 2) + v;
          },
          easeInQuint: function(_, m, v, C, y) {
            return C * (m /= y) * m * m * m * m + v;
          },
          easeOutQuint: function(_, m, v, C, y) {
            return C * ((m = m / y - 1) * m * m * m * m + 1) + v;
          },
          easeInOutQuint: function(_, m, v, C, y) {
            return (m /= y / 2) < 1 ? C / 2 * m * m * m * m * m + v : C / 2 * ((m -= 2) * m * m * m * m + 2) + v;
          },
          easeInSine: function(_, m, v, C, y) {
            return -C * g.c(m / y * (g.p / 2)) + C + v;
          },
          easeOutSine: function(_, m, v, C, y) {
            return C * g.s(m / y * (g.p / 2)) + v;
          },
          easeInOutSine: function(_, m, v, C, y) {
            return -C / 2 * (g.c(g.p * m / y) - 1) + v;
          },
          easeInExpo: function(_, m, v, C, y) {
            return m == 0 ? v : C * g.w(2, 10 * (m / y - 1)) + v;
          },
          easeOutExpo: function(_, m, v, C, y) {
            return m == y ? v + C : C * (-g.w(2, -10 * m / y) + 1) + v;
          },
          easeInOutExpo: function(_, m, v, C, y) {
            return m == 0 ? v : m == y ? v + C : (m /= y / 2) < 1 ? C / 2 * g.w(2, 10 * (m - 1)) + v : C / 2 * (-g.w(2, -10 * --m) + 2) + v;
          },
          easeInCirc: function(_, m, v, C, y) {
            return -C * (g.t(1 - (m /= y) * m) - 1) + v;
          },
          easeOutCirc: function(_, m, v, C, y) {
            return C * g.t(1 - (m = m / y - 1) * m) + v;
          },
          easeInOutCirc: function(_, m, v, C, y) {
            return (m /= y / 2) < 1 ? -C / 2 * (g.t(1 - m * m) - 1) + v : C / 2 * (g.t(1 - (m -= 2) * m) + 1) + v;
          },
          easeInElastic: function(_, m, v, C, y) {
            var w = g.o, L = 0, S = C;
            return m == 0 ? v : (m /= y) == 1 ? v + C : (L || (L = y * 0.3), S < g.a(C) ? (S = C, w = L / 4) : w = L / (2 * g.p) * g.n(C / S), -(S * g.w(2, 10 * (m -= 1)) * g.s((m * y - w) * (2 * g.p) / L)) + v);
          },
          easeOutElastic: function(_, m, v, C, y) {
            var w = g.o, L = 0, S = C;
            return m == 0 ? v : (m /= y) == 1 ? v + C : (L || (L = y * 0.3), S < g.a(C) ? (S = C, w = L / 4) : w = L / (2 * g.p) * g.n(C / S), S * g.w(2, -10 * m) * g.s((m * y - w) * (2 * g.p) / L) + C + v);
          },
          easeInOutElastic: function(_, m, v, C, y) {
            var w = g.o, L = 0, S = C;
            return m == 0 ? v : (m /= y / 2) == 2 ? v + C : (L || (L = y * (0.3 * 1.5)), S < g.a(C) ? (S = C, w = L / 4) : w = L / (2 * g.p) * g.n(C / S), m < 1 ? -0.5 * (S * g.w(2, 10 * (m -= 1)) * g.s((m * y - w) * (2 * g.p) / L)) + v : S * g.w(2, -10 * (m -= 1)) * g.s((m * y - w) * (2 * g.p) / L) * 0.5 + C + v);
          },
          easeInBack: function(_, m, v, C, y, w) {
            return w = w || g.o, C * (m /= y) * m * ((w + 1) * m - w) + v;
          },
          easeOutBack: function(_, m, v, C, y, w) {
            return w = w || g.o, C * ((m = m / y - 1) * m * ((w + 1) * m + w) + 1) + v;
          },
          easeInOutBack: function(_, m, v, C, y, w) {
            return w = w || g.o, (m /= y / 2) < 1 ? C / 2 * (m * m * (((w *= 1.525) + 1) * m - w)) + v : C / 2 * ((m -= 2) * m * (((w *= 1.525) + 1) * m + w) + 2) + v;
          },
          easeInBounce: function(_, m, v, C, y) {
            return C - this.easeOutBounce(_, y - m, 0, C, y) + v;
          },
          easeOutBounce: function(_, m, v, C, y) {
            var w = 7.5625;
            return (m /= y) < 1 / 2.75 ? C * (w * m * m) + v : m < 2 / 2.75 ? C * (w * (m -= 1.5 / 2.75) * m + 0.75) + v : m < 2.5 / 2.75 ? C * (w * (m -= 2.25 / 2.75) * m + 0.9375) + v : C * (w * (m -= 2.625 / 2.75) * m + 0.984375) + v;
          },
          easeInOutBounce: function(_, m, v, C, y) {
            return m < y / 2 ? this.easeInBounce(_, m * 2, 0, C, y) * 0.5 + v : this.easeOutBounce(_, m * 2 - y, 0, C, y) * 0.5 + C * 0.5 + v;
          }
        };
      }(), d = function() {
        var g = /[^\x20\t\r\n\f]+/g, _ = " ", m = "", v = "scrollLeft", C = "scrollTop", y = [], w = l.type, L = {
          animationIterationCount: !0,
          columnCount: !0,
          fillOpacity: !0,
          flexGrow: !0,
          flexShrink: !0,
          fontWeight: !0,
          lineHeight: !0,
          opacity: !0,
          order: !0,
          orphans: !0,
          widows: !0,
          zIndex: !0,
          zoom: !0
        };
        function S() {
          var O, N, I, V, te, ue, De = arguments[0] || {}, ce = 1, ke = arguments[s.l], Ie = !1;
          for (w(De) == o.b && (Ie = De, De = arguments[1] || {}, ce = 2), w(De) != o.o && !w(De) == o.f && (De = {}), ke === ce && (De = U, --ce); ce < ke; ce++)
            if ((te = arguments[ce]) != null)
              for (V in te)
                O = De[V], I = te[V], De !== I && (Ie && I && (R(I) || (N = l.isA(I))) ? (N ? (N = !1, ue = O && l.isA(O) ? O : []) : ue = O && R(O) ? O : {}, De[V] = S(Ie, ue, I)) : I !== i && (De[V] = I));
          return De;
        }
        function E(O, N, I) {
          for (var V = I || 0; V < N[s.l]; V++)
            if (N[V] === O)
              return V;
          return -1;
        }
        function D(O) {
          return w(O) == o.f;
        }
        function x(O) {
          for (var N in O)
            return !1;
          return !0;
        }
        function R(O) {
          if (!O || w(O) != o.o)
            return !1;
          var N, I = s.p, V = Object[I].hasOwnProperty, te = V.call(O, "constructor"), ue = O.constructor && O.constructor[I] && V.call(O.constructor[I], "isPrototypeOf");
          if (O.constructor && !te && !ue)
            return !1;
          for (N in O)
            ;
          return w(N) == o.u || V.call(O, N);
        }
        function A(O, N) {
          var I = 0;
          if (M(O))
            for (; I < O[s.l] && N.call(O[I], I, O[I]) !== !1; I++)
              ;
          else
            for (I in O)
              if (N.call(O[I], I, O[I]) === !1)
                break;
          return O;
        }
        function M(O) {
          var N = !!O && [s.l] in O && O[s.l], I = w(O);
          return D(I) ? !1 : I == o.a || N === 0 || w(N) == o.n && N > 0 && N - 1 in O;
        }
        function z(O) {
          var N = O.match(g) || [];
          return N.join(_);
        }
        function j(O, N) {
          for (var I = (O.parentNode || t).querySelectorAll(N) || [], V = I[s.l]; V--; )
            if (I[V] == O)
              return !0;
          return !1;
        }
        function $(O, N, I) {
          if (l.isA(I))
            for (var V = 0; V < I[s.l]; V++)
              $(O, N, I[V]);
          else
            w(I) == o.s ? O.insertAdjacentHTML(N, I) : O.insertAdjacentElement(N, I.nodeType ? I : I[0]);
        }
        function k(O, N, I) {
          try {
            O[s.s][N] !== i && (O[s.s][N] = ae(N, I));
          } catch {
          }
        }
        function ae(O, N) {
          return !L[O.toLowerCase()] && w(N) == o.n && (N += "px"), N;
        }
        function re(O, N) {
          var I, V;
          N !== !1 && O.q.splice(0, 1), O.q[s.l] > 0 ? (V = O.q[0], K(O.el, V.props, V.duration, V.easing, V.complete, !0)) : (I = E(O, y), I > -1 && y.splice(I, 1));
        }
        function Y(O, N, I) {
          N === v || N === C ? O[N] = I : k(O, N, I);
        }
        function K(O, N, I, V, te, ue) {
          var De = R(I), ce = {}, ke = {}, Ie = 0, $e, Ot, It, ti, ii, lt;
          for (De ? (V = I.easing, I.start, It = I.progress, ti = I.step, ii = I.specialEasing, te = I.complete, lt = I.duration) : lt = I, ii = ii || {}, lt = lt || 400, V = V || "swing", ue = ue || !1; Ie < y[s.l]; Ie++)
            if (y[Ie].el === O) {
              Ot = y[Ie];
              break;
            }
          Ot || (Ot = {
            el: O,
            q: []
          }, y.push(Ot));
          for ($e in N)
            $e === v || $e === C ? ce[$e] = O[$e] : ce[$e] = U(O).css($e);
          for ($e in ce)
            ce[$e] !== N[$e] && N[$e] !== i && (ke[$e] = N[$e]);
          if (x(ke))
            ue && re(Ot);
          else {
            var Ui, zt, Xi, Zi, Si, pt, ai, tr, Nn, Hn = ue ? 0 : E(Yt, Ot.q), Yt = {
              props: ke,
              duration: De ? I : lt,
              easing: V,
              complete: te
            };
            if (Hn === -1 && (Hn = Ot.q[s.l], Ot.q.push(Yt)), Hn === 0)
              if (lt > 0)
                ai = l.now(), tr = function() {
                  Ui = l.now(), Nn = Ui - ai, zt = Yt.stop || Nn >= lt, Xi = 1 - (u.max(0, ai + lt - Ui) / lt || 0);
                  for ($e in ke)
                    Zi = parseFloat(ce[$e]), Si = parseFloat(ke[$e]), pt = (Si - Zi) * h[ii[$e] || V](Xi, Xi * lt, 0, 1, lt) + Zi, Y(O, $e, pt), D(ti) && ti(pt, {
                      elem: O,
                      prop: $e,
                      start: Zi,
                      now: pt,
                      end: Si,
                      pos: Xi,
                      options: {
                        easing: V,
                        speacialEasing: ii,
                        duration: lt,
                        complete: te,
                        step: ti
                      },
                      startTime: ai
                    });
                  D(It) && It({}, Xi, u.max(0, lt - Nn)), zt ? (re(Ot), D(te) && te()) : Yt.frame = l.rAF()(tr);
                }, Yt.frame = l.rAF()(tr);
              else {
                for ($e in ke)
                  Y(O, $e, ke[$e]);
                re(Ot);
              }
          }
        }
        function W(O, N, I) {
          for (var V, te, ue, De = 0; De < y[s.l]; De++)
            if (V = y[De], V.el === O) {
              if (V.q[s.l] > 0) {
                if (te = V.q[0], te.stop = !0, l.cAF()(te.frame), V.q.splice(0, 1), I)
                  for (ue in te.props)
                    Y(O, ue, te.props[ue]);
                N ? V.q = [] : re(V, !1);
              }
              break;
            }
        }
        function B(O) {
          return !!(O[s.oW] || O[s.oH] || O.getClientRects()[s.l]);
        }
        function U(O) {
          if (arguments[s.l] === 0)
            return this;
          var N = new U(), I = O, V = 0, te, ue;
          if (w(O) == o.s)
            for (I = [], O.charAt(0) === "<" ? (ue = t.createElement("div"), ue.innerHTML = O, te = ue.children) : te = t.querySelectorAll(O); V < te[s.l]; V++)
              I.push(te[V]);
          if (I) {
            for (w(I) != o.s && (!M(I) || I === e || I === I.self) && (I = [I]), V = 0; V < I[s.l]; V++)
              N[V] = I[V];
            N[s.l] = I[s.l];
          }
          return N;
        }
        return U[s.p] = {
          //EVENTS:
          on: function(O, N) {
            O = (O || m).match(g) || [m];
            var I = O[s.l], V = 0, te;
            return this.each(function() {
              te = this;
              try {
                if (te.addEventListener)
                  for (; V < I; V++)
                    te.addEventListener(O[V], N);
                else if (te.detachEvent)
                  for (; V < I; V++)
                    te.attachEvent("on" + O[V], N);
              } catch {
              }
            });
          },
          off: function(O, N) {
            O = (O || m).match(g) || [m];
            var I = O[s.l], V = 0, te;
            return this.each(function() {
              te = this;
              try {
                if (te.removeEventListener)
                  for (; V < I; V++)
                    te.removeEventListener(O[V], N);
                else if (te.detachEvent)
                  for (; V < I; V++)
                    te.detachEvent("on" + O[V], N);
              } catch {
              }
            });
          },
          one: function(O, N) {
            return O = (O || m).match(g) || [m], this.each(function() {
              var I = U(this);
              U.each(O, function(V, te) {
                var ue = function(De) {
                  N.call(this, De), I.off(te, ue);
                };
                I.on(te, ue);
              });
            });
          },
          trigger: function(O) {
            var N, I;
            return this.each(function() {
              N = this, t.createEvent ? (I = t.createEvent("HTMLEvents"), I.initEvent(O, !0, !1), N.dispatchEvent(I)) : N.fireEvent("on" + O);
            });
          },
          //DOM NODE INSERTING / REMOVING:
          append: function(O) {
            return this.each(function() {
              $(this, "beforeend", O);
            });
          },
          prepend: function(O) {
            return this.each(function() {
              $(this, "afterbegin", O);
            });
          },
          before: function(O) {
            return this.each(function() {
              $(this, "beforebegin", O);
            });
          },
          after: function(O) {
            return this.each(function() {
              $(this, "afterend", O);
            });
          },
          remove: function() {
            return this.each(function() {
              var O = this, N = O.parentNode;
              N != null && N.removeChild(O);
            });
          },
          unwrap: function() {
            var O = [], N, I, V;
            for (this.each(function() {
              V = this.parentNode, E(V, O) === -1 && O.push(V);
            }), N = 0; N < O[s.l]; N++) {
              for (I = O[N], V = I.parentNode; I.firstChild; )
                V.insertBefore(I.firstChild, I);
              V.removeChild(I);
            }
            return this;
          },
          wrapAll: function(O) {
            for (var N, I = this, V = U(O)[0], te = V, ue = I[0].parentNode, De = I[0].previousSibling; te.childNodes[s.l] > 0; )
              te = te.childNodes[0];
            for (N = 0; I[s.l] - N; te.firstChild === I[0] && N++)
              te.appendChild(I[N]);
            var ce = De ? De.nextSibling : ue.firstChild;
            return ue.insertBefore(V, ce), this;
          },
          wrapInner: function(O) {
            return this.each(function() {
              var N = U(this), I = N.contents();
              I[s.l] ? I.wrapAll(O) : N.append(O);
            });
          },
          wrap: function(O) {
            return this.each(function() {
              U(this).wrapAll(O);
            });
          },
          //DOM NODE MANIPULATION / INFORMATION:
          css: function(O, N) {
            var I, V, te, ue = e.getComputedStyle;
            return w(O) == o.s ? N === i ? (I = this[0], te = ue ? ue(I, null) : I.currentStyle[O], ue ? te != null ? te.getPropertyValue(O) : I[s.s][O] : te) : this.each(function() {
              k(this, O, N);
            }) : this.each(function() {
              for (V in O)
                k(this, V, O[V]);
            });
          },
          hasClass: function(O) {
            for (var N, I = 0, V = _ + O + _, te; N = this[I++]; ) {
              if (te = N.classList, te && te.contains(O))
                return !0;
              if (N.nodeType === 1 && (_ + z(N.className + m) + _).indexOf(V) > -1)
                return !0;
            }
            return !1;
          },
          addClass: function(O) {
            var N, I, V, te, ue, De, ce, ke, Ie = 0, $e = 0;
            if (O) {
              for (N = O.match(g) || []; I = this[Ie++]; )
                if (ke = I.classList, ce === i && (ce = ke !== i), ce)
                  for (; ue = N[$e++]; )
                    ke.add(ue);
                else if (te = I.className + m, V = I.nodeType === 1 && _ + z(te) + _, V) {
                  for (; ue = N[$e++]; )
                    V.indexOf(_ + ue + _) < 0 && (V += ue + _);
                  De = z(V), te !== De && (I.className = De);
                }
            }
            return this;
          },
          removeClass: function(O) {
            var N, I, V, te, ue, De, ce, ke, Ie = 0, $e = 0;
            if (O) {
              for (N = O.match(g) || []; I = this[Ie++]; )
                if (ke = I.classList, ce === i && (ce = ke !== i), ce)
                  for (; ue = N[$e++]; )
                    ke.remove(ue);
                else if (te = I.className + m, V = I.nodeType === 1 && _ + z(te) + _, V) {
                  for (; ue = N[$e++]; )
                    for (; V.indexOf(_ + ue + _) > -1; )
                      V = V.replace(_ + ue + _, _);
                  De = z(V), te !== De && (I.className = De);
                }
            }
            return this;
          },
          hide: function() {
            return this.each(function() {
              this[s.s].display = "none";
            });
          },
          show: function() {
            return this.each(function() {
              this[s.s].display = "block";
            });
          },
          attr: function(O, N) {
            for (var I = 0, V; V = this[I++]; ) {
              if (N === i)
                return V.getAttribute(O);
              V.setAttribute(O, N);
            }
            return this;
          },
          removeAttr: function(O) {
            return this.each(function() {
              this.removeAttribute(O);
            });
          },
          offset: function() {
            var O = this[0], N = O[s.bCR](), I = e.pageXOffset || t.documentElement[v], V = e.pageYOffset || t.documentElement[C];
            return {
              top: N.top + V,
              left: N.left + I
            };
          },
          position: function() {
            var O = this[0];
            return {
              top: O.offsetTop,
              left: O.offsetLeft
            };
          },
          scrollLeft: function(O) {
            for (var N = 0, I; I = this[N++]; ) {
              if (O === i)
                return I[v];
              I[v] = O;
            }
            return this;
          },
          scrollTop: function(O) {
            for (var N = 0, I; I = this[N++]; ) {
              if (O === i)
                return I[C];
              I[C] = O;
            }
            return this;
          },
          val: function(O) {
            var N = this[0];
            return O ? (N.value = O, this) : N.value;
          },
          //DOM TRAVERSAL / FILTERING:
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          eq: function(O) {
            return U(this[O >= 0 ? O : this[s.l] + O]);
          },
          find: function(O) {
            var N = [], I;
            return this.each(function() {
              var V = this, te = V.querySelectorAll(O);
              for (I = 0; I < te[s.l]; I++)
                N.push(te[I]);
            }), U(N);
          },
          children: function(O) {
            var N = [], I, V, te;
            return this.each(function() {
              for (V = this.children, te = 0; te < V[s.l]; te++)
                I = V[te], O ? (I.matches && I.matches(O) || j(I, O)) && N.push(I) : N.push(I);
            }), U(N);
          },
          parent: function(O) {
            var N = [], I;
            return this.each(function() {
              I = this.parentNode, (!O || U(I).is(O)) && N.push(I);
            }), U(N);
          },
          is: function(O) {
            var N, I;
            for (I = 0; I < this[s.l]; I++) {
              if (N = this[I], O === ":visible")
                return B(N);
              if (O === ":hidden")
                return !B(N);
              if (N.matches && N.matches(O) || j(N, O))
                return !0;
            }
            return !1;
          },
          contents: function() {
            var O = [], N, I;
            return this.each(function() {
              for (N = this.childNodes, I = 0; I < N[s.l]; I++)
                O.push(N[I]);
            }), U(O);
          },
          each: function(O) {
            return A(this, O);
          },
          //ANIMATION:
          animate: function(O, N, I, V) {
            return this.each(function() {
              K(this, O, N, I, V);
            });
          },
          stop: function(O, N) {
            return this.each(function() {
              W(this, O, N);
            });
          }
        }, S(U, {
          extend: S,
          inArray: E,
          isEmptyObject: x,
          isPlainObject: R,
          each: A
        }), U;
      }(), f = function() {
        var g = [], _ = "__overlayScrollbars__";
        return function(m, v) {
          var C = arguments[s.l];
          if (C < 1)
            return g;
          if (v)
            m[_] = v, g.push(m);
          else {
            var y = l.inA(m, g);
            if (y > -1)
              if (C > 1)
                delete m[_], g.splice(y, 1);
              else
                return g[y][_];
          }
        };
      }(), p = function() {
        var g, _, m, v = [], C = function() {
          var E = l.type, D = [
            o.b,
            //boolean
            o.n,
            //number
            o.s,
            //string
            o.a,
            //array
            o.o,
            //object
            o.f,
            //function
            o.z
            //null
          ], x = " ", R = ":", A = [o.z, o.s], M = o.n, z = [o.z, o.b], j = [!0, o.b], $ = [!1, o.b], k = [null, [o.z, o.f]], ae = [["img"], [o.s, o.a, o.z]], re = [["style", "class"], [o.s, o.a, o.z]], Y = "n:none b:both h:horizontal v:vertical", K = "v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden", W = "v:visible h:hidden a:auto", B = "n:never s:scroll l:leave m:move", U = {
            className: ["os-theme-dark", A],
            //null || string
            resize: ["none", Y],
            //none || both  || horizontal || vertical || n || b || h || v
            sizeAutoCapable: j,
            //true || false
            clipAlways: j,
            //true || false
            normalizeRTL: j,
            //true || false
            paddingAbsolute: $,
            //true || false
            autoUpdate: [null, z],
            //true || false || null
            autoUpdateInterval: [33, M],
            //number
            updateOnLoad: ae,
            //string || array || null
            nativeScrollbarsOverlaid: {
              showNativeScrollbars: $,
              //true || false
              initialize: j
              //true || false
            },
            overflowBehavior: {
              x: ["scroll", K],
              //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
              y: ["scroll", K]
              //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
            },
            scrollbars: {
              visibility: ["auto", W],
              //visible || hidden || auto || v || h || a
              autoHide: ["never", B],
              //never || scroll || leave || move || n || s || l || m
              autoHideDelay: [800, M],
              //number
              dragScrolling: j,
              //true || false
              clickScrolling: $,
              //true || false
              touchSupport: j,
              //true || false
              snapHandle: $
              //true || false
            },
            textarea: {
              dynWidth: $,
              //true || false
              dynHeight: $,
              //true || false
              inheritedAttrs: re
              //string || array || null
            },
            callbacks: {
              onInitialized: k,
              //null || function
              onInitializationWithdrawn: k,
              //null || function
              onDestroyed: k,
              //null || function
              onScrollStart: k,
              //null || function
              onScroll: k,
              //null || function
              onScrollStop: k,
              //null || function
              onOverflowChanged: k,
              //null || function
              onOverflowAmountChanged: k,
              //null || function
              onDirectionChanged: k,
              //null || function
              onContentSizeChanged: k,
              //null || function
              onHostSizeChanged: k,
              //null || function
              onUpdated: k
              //null || function
            }
          }, O = function(N) {
            var I = function(V) {
              var te, ue, De;
              for (te in V)
                V[s.hOP](te) && (ue = V[te], De = E(ue), De == o.a ? V[te] = ue[N ? 1 : 0] : De == o.o && (V[te] = I(ue)));
              return V;
            };
            return I(d.extend(!0, {}, U));
          };
          return {
            _defaults: O(),
            _template: O(!0),
            /**
             * Validates the passed object by the passed template.
             * @param obj The object which shall be validated.
             * @param template The template which defines the allowed values and types.
             * @param writeErrors True if errors shall be logged to the console.
             * @param diffObj If a object is passed then only valid differences to this object will be returned.
             * @returns {{}} A object which contains two objects called "default" and "prepared" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.
             */
            _validate: function(N, I, V, te) {
              var ue = {}, De = {}, ce = d.extend(!0, {}, N), ke = d.inArray, Ie = d.isEmptyObject, $e = function(Ot, It, ti, ii, lt, Ui) {
                for (var zt in It)
                  if (It[s.hOP](zt) && Ot[s.hOP](zt)) {
                    var Xi = !1, Zi = !1, Si = It[zt], pt = E(Si), ai = pt == o.o, tr = l.isA(Si) ? Si : [Si], Nn = ti[zt], Hn = Ot[zt], Yt = E(Hn), No = Ui ? Ui + "." : "", oe = 'The option "' + No + zt + `" wasn't set, because`, Q = [], le = [], pe, Ee, Pe, Ke, Ne, Ve, Lt, Fe;
                    if (Nn = Nn === i ? {} : Nn, ai && Yt == o.o)
                      ii[zt] = {}, lt[zt] = {}, $e(Hn, Si, Nn, ii[zt], lt[zt], No + zt), d.each([Ot, ii, lt], function(Rt, ni) {
                        Ie(ni[zt]) && delete ni[zt];
                      });
                    else if (!ai) {
                      for (Ve = 0; Ve < tr[s.l]; Ve++)
                        if (Ne = tr[Ve], pt = E(Ne), Pe = pt == o.s && ke(Ne, D) === -1, Pe)
                          for (Q.push(o.s), pe = Ne.split(x), le = le.concat(pe), Lt = 0; Lt < pe[s.l]; Lt++) {
                            for (Ee = pe[Lt].split(R), Ke = Ee[0], Fe = 0; Fe < Ee[s.l]; Fe++)
                              if (Hn === Ee[Fe]) {
                                Xi = !0;
                                break;
                              }
                            if (Xi)
                              break;
                          }
                        else if (Q.push(Ne), Yt === Ne) {
                          Xi = !0;
                          break;
                        }
                      Xi ? (Zi = Hn !== Nn, Zi && (ii[zt] = Hn), (Pe ? ke(Nn, Ee) < 0 : Zi) && (lt[zt] = Pe ? Ke : Hn)) : V && console.warn(oe + " it doesn't accept the type [ " + Yt.toUpperCase() + ' ] with the value of "' + Hn + `".\r
Accepted types are: [ ` + Q.join(", ").toUpperCase() + " ]." + (le[length] > 0 ? `\r
Valid strings are: [ ` + le.join(", ").split(R).join(", ") + " ]." : "")), delete Ot[zt];
                    }
                  }
              };
              return $e(ce, I, te || {}, ue, De), !Ie(ce) && V && console.warn(`The following options are discarded due to invalidity:\r
` + e.JSON.stringify(ce, null, 2)), {
                _default: ue,
                _prepared: De
              };
            }
          };
        }();
        function y() {
          _ || (_ = new w(C._defaults)), m || (m = new L(_));
        }
        function w(E) {
          var D = this, x = "overflow", R = "hidden", A = "scroll", M = d("body"), z = d('<div id="os-dummy-scrollbar-size"><div></div></div>'), j = z[0], $ = d(z.children("div").eq(0));
          M.append(z), z.hide().show();
          var k = Y(j), ae = {
            x: k.x === 0,
            y: k.y === 0
          }, re = function() {
            var K = e.navigator.userAgent, W = "indexOf", B = "substring", U = K[W]("MSIE "), O = K[W]("Trident/"), N = K[W]("Edge/"), I = K[W]("rv:"), V, te = parseInt;
            return U > 0 ? V = te(K[B](U + 5, K[W](".", U)), 10) : O > 0 ? V = te(K[B](I + 3, K[W](".", I)), 10) : N > 0 && (V = te(K[B](N + 5, K[W](".", N)), 10)), V;
          }();
          d.extend(D, {
            defaultOptions: E,
            msie: re,
            autoUpdateLoop: !1,
            autoUpdateRecommended: !l.mO(),
            nativeScrollbarSize: k,
            nativeScrollbarIsOverlaid: ae,
            nativeScrollbarStyling: function() {
              var K = !1;
              z.addClass("os-viewport-native-scrollbars-invisible");
              try {
                K = z.css("scrollbar-width") === "none" && (re > 9 || !re) || e.getComputedStyle(j, "::-webkit-scrollbar").getPropertyValue("display") === "none";
              } catch {
              }
              return K;
            }(),
            overlayScrollbarDummySize: { x: 30, y: 30 },
            cssCalc: a._cssPropertyValue("width", "calc", "(1px)") || null,
            restrictedMeasuring: function() {
              z.css(x, R);
              var K = {
                w: j[s.sW],
                h: j[s.sH]
              };
              z.css(x, "visible");
              var W = {
                w: j[s.sW],
                h: j[s.sH]
              };
              return K.w - W.w !== 0 || K.h - W.h !== 0;
            }(),
            rtlScrollBehavior: function() {
              z.css({ "overflow-y": R, "overflow-x": A, direction: "rtl" }).scrollLeft(0);
              var K = z.offset(), W = $.offset();
              z.scrollLeft(-999);
              var B = $.offset();
              return {
                //origin direction = determines if the zero scroll position is on the left or right side
                //'i' means 'invert' (i === true means that the axis must be inverted to be correct)
                //true = on the left side
                //false = on the right side
                i: K.left === W.left,
                //negative = determines if the maximum scroll is positive or negative
                //'n' means 'negate' (n === true means that the axis must be negated to be correct)
                //true = negative
                //false = positive
                n: W.left !== B.left
              };
            }(),
            supportTransform: !!a._cssProperty("transform"),
            supportTransition: !!a._cssProperty("transition"),
            supportPassiveEvents: function() {
              var K = !1;
              try {
                e.addEventListener("test", null, Object.defineProperty({}, "passive", {
                  get: function() {
                    K = !0;
                  }
                }));
              } catch {
              }
              return K;
            }(),
            supportResizeObserver: !!l.rO(),
            supportMutationObserver: !!l.mO()
          }), z.removeAttr(s.s).remove(), function() {
            if (ae.x && ae.y)
              return;
            var K = u.abs, W = l.wW(), B = l.wH(), U = I(), O = function() {
              if (f().length > 0) {
                var V = l.wW(), te = l.wH(), ue = V - W, De = te - B;
                if (ue === 0 && De === 0)
                  return;
                var ce = u.round(V / (W / 100)), ke = u.round(te / (B / 100)), Ie = K(ue), $e = K(De), Ot = K(ce), It = K(ke), ti = I(), ii = Ie > 2 && $e > 2, lt = !N(Ot, It), Ui = ti !== U && U > 0, zt = ii && lt && Ui, Xi = D.nativeScrollbarSize, Zi;
                zt && (M.append(z), Zi = D.nativeScrollbarSize = Y(z[0]), z.remove(), (Xi.x !== Zi.x || Xi.y !== Zi.y) && d.each(f(), function() {
                  f(this) && f(this).update("zoom");
                })), W = V, B = te, U = ti;
              }
            };
            function N(V, te) {
              var ue = K(V), De = K(te);
              return !(ue === De || ue + 1 === De || ue - 1 === De);
            }
            function I() {
              var V = e.screen.deviceXDPI || 0, te = e.screen.logicalXDPI || 1;
              return e.devicePixelRatio || V / te;
            }
            d(e).on("resize", O);
          }();
          function Y(K) {
            return {
              x: K[s.oH] - K[s.cH],
              y: K[s.oW] - K[s.cW]
            };
          }
        }
        function L(E) {
          var D = this, x = d.inArray, R = l.now, A = "autoUpdate", M = A + "Interval", z = s.l, j = [], $ = [], k = !1, ae = 33, re = ae, Y = R(), K, W = function() {
            if (j[z] > 0 && k) {
              K = l.rAF()(function() {
                W();
              });
              var B = R(), U = B - Y, O, N, I, V, te, ue;
              if (U > re) {
                Y = B - U % re, O = ae;
                for (var De = 0; De < j[z]; De++)
                  N = j[De], N !== i && (I = N.options(), V = I[A], te = u.max(1, I[M]), ue = R(), (V === !0 || V === null) && ue - $[De] > te && (N.update("auto"), $[De] = new Date(ue += te)), O = u.max(1, u.min(O, te)));
                re = O;
              }
            } else
              re = ae;
          };
          D.add = function(B) {
            x(B, j) === -1 && (j.push(B), $.push(R()), j[z] > 0 && !k && (k = !0, E.autoUpdateLoop = k, W()));
          }, D.remove = function(B) {
            var U = x(B, j);
            U > -1 && ($.splice(U, 1), j.splice(U, 1), j[z] === 0 && k && (k = !1, E.autoUpdateLoop = k, K !== i && (l.cAF()(K), K = -1)));
          };
        }
        function S(E, D, x, R, A) {
          var M = l.type, z = d.inArray, j = d.each, $ = new g(), k = d[s.p];
          if (!pA(E))
            return;
          if (f(E)) {
            var ae = f(E);
            return ae.options(D), ae;
          }
          var re, Y, K, W, B, U, O, N, I, V, te, ue, De, ce, ke, Ie, $e, Ot, It, ti, ii, lt, Ui, zt, Xi, Zi, Si, pt, ai, tr = {}, Nn = {}, Hn = {}, Yt = {}, No = {}, oe = "-hidden", Q = "margin-", le = "padding-", pe = "border-", Ee = "top", Pe = "right", Ke = "bottom", Ne = "left", Ve = "min-", Lt = "max-", Fe = "width", Rt = "height", ni = "float", Be = "", hi = "auto", su = "sync", Nr = "scroll", Io = "100%", lo = "x", ul = "y", Ir = ".", Cn = " ", _h = "scrollbar", ac = "-horizontal", Ai = "-vertical", di = Nr + "Left", Qi = Nr + "Top", sn = "mousedown touchstart", au = "mouseup touchend touchcancel", lc = "mousemove touchmove", rC = "mouseenter", fP = "mouseleave", JE = "keydown", e0 = "keyup", Hg = "selectstart", t0 = "transitionend webkitTransitionEnd oTransitionEnd", i0 = "__overlayScrollbarsRO__", uo = "os-", pP = uo + "html", Br = uo + "host", oC = Br + "-foreign", n0 = Br + "-textarea", gP = Br + "-" + _h + ac + oe, mP = Br + "-" + _h + Ai + oe, vP = Br + "-transition", _P = Br + "-rtl", r0 = Br + "-resize-disabled", sC = Br + "-scrolling", Gg = Br + "-overflow", Gg = Br + "-overflow", CP = Gg + "-x", yP = Gg + "-y", aC = uo + "textarea", IU = aC + "-cover", o0 = uo + "padding", lC = uo + "viewport", s0 = lC + "-native-scrollbars-invisible", wP = lC + "-native-scrollbars-overlaid", a0 = uo + "content", PU = uo + "content-arrange", AU = uo + "content-glue", MU = uo + "size-auto-observer", Ch = uo + "resize-observer", uC = uo + "resize-observer-item", bP = uC + "-final", cC = uo + "text-inherit", lu = uo + _h, SP = lu + "-track", EP = SP + "-off", LP = lu + "-handle", DP = LP + "-off", RP = lu + "-unusable", Ug = lu + "-" + hi + oe, l0 = lu + "-corner", zg = l0 + "-resize", TP = zg + "-both", OP = zg + ac, xP = zg + Ai, FU = lu + ac, kU = lu + Ai, yh = uo + "dragging", hC = uo + "theme-none", u0 = [
            s0,
            wP,
            EP,
            DP,
            RP,
            Ug,
            zg,
            TP,
            OP,
            xP,
            yh
          ].join(Cn), c0 = [], h0 = [s.ti], NP, jg, Gn, uu = {}, WU = "added removed on contract", IP, wh = {}, PP, AP = 42, d0 = "load", bh = [], dC, cl, gf, Sh, jt, ot, ba, Sa, Ws, Pt, hn, cu, Hr, hu, co, Eh, fC, $g, Lh, pC, Kg, qg, mf, uc, Zo, gC, mC, cc, Dh, Vs, Yg, Rh, MP, hl, Xg, Bs, hc, FP, f0, kP, WP, VP, BP, HP, GP, UP, vf, _f, p0, g0, zP, jP, $P, KP, qP, YP, m0, XP, du, Zg, v0, vC, _0, ZP, QP, JP, dc, eA = {}, _C, CC, C0, y0, dl, tA = ["wrap", "cols", "rows"], w0 = [s.i, s.c, s.s, "open"].concat(h0), b0 = [], S0, iA, nA, E0, L0, fc, Hs, Th, D0, pc, yC, wC, R0, T0;
          function Po(P, H, X, J, se) {
            var fe = l.isA(H) && l.isA(X), ye = J ? "removeEventListener" : "addEventListener", Oe = J ? "off" : "on", Te = fe ? !1 : H.split(Cn), xe = 0, rt = d.isPlainObject(se), Ye = te && (rt ? se._passive : se) || !1, mt = rt && (se._capture || !1), Dt = te ? {
              passive: Ye,
              capture: mt
            } : mt;
            if (fe)
              for (; xe < H[s.l]; xe++)
                Po(P, H[xe], X[xe], J, se);
            else
              for (; xe < Te[s.l]; xe++)
                te ? P[0][ye](Te[xe], X, Dt) : P[Oe](Te[xe], X);
          }
          function Ea(P, H, X, J) {
            Po(P, H, X, !1, J), b0.push(l.bind(Po, 0, P, H, X, !0, J));
          }
          function bC(P, H) {
            if (P) {
              var X = l.rO(), J = "animationstart mozAnimationStart webkitAnimationStart MSAnimationStart", se = "childNodes", fe = 3333333, ye = function() {
                P[Qi](fe)[di](pt ? K.n ? -fe : K.i ? 0 : fe : fe), H();
              };
              if (H) {
                if (ue) {
                  var Oe = P.addClass("observed").append(Jo(Ch)).contents()[0], Te = Oe[i0] = new X(ye);
                  Te.observe(Oe);
                } else if (B > 9 || !W) {
                  P.prepend(
                    Jo(
                      Ch,
                      Jo(
                        { c: uC, dir: "ltr" },
                        Jo(
                          uC,
                          Jo(bP)
                        ) + Jo(
                          uC,
                          Jo({ c: bP, style: "width: 200%; height: 200%" })
                        )
                      )
                    )
                  );
                  var xe = P[0][se][0][se][0], rt = d(xe[se][1]), Ye = d(xe[se][0]), mt = d(Ye[0][se][0]), Dt = xe[s.oW], $t = xe[s.oH], ut, Xt, At, Ji, Ar = 2, yn = R.nativeScrollbarSize, fo = function() {
                    Ye[di](fe)[Qi](fe), rt[di](fe)[Qi](fe);
                  }, ir = function() {
                    Xt = 0, ut && (Dt = At, $t = Ji, ye());
                  }, Pn = function(Ei) {
                    return At = xe[s.oW], Ji = xe[s.oH], ut = At != Dt || Ji != $t, Ei && ut && !Xt ? (l.cAF()(Xt), Xt = l.rAF()(ir)) : Ei || ir(), fo(), Ei && (l.prvD(Ei), l.stpP(Ei)), !1;
                  }, An = {}, dn = {};
                  Oh(dn, Be, [
                    -((yn.y + 1) * Ar),
                    yn.x * -Ar,
                    yn.y * -Ar,
                    -((yn.x + 1) * Ar)
                  ]), d(xe).css(dn), Ye.on(Nr, Pn), rt.on(Nr, Pn), P.on(J, function() {
                    Pn(!1);
                  }), An[Fe] = fe, An[Rt] = fe, mt.css(An), fo();
                } else {
                  var Un = mf.attachEvent, Ra = B !== i;
                  if (Un)
                    P.prepend(Jo(Ch)), Cf(P, Ir + Ch)[0].attachEvent("onresize", ye);
                  else {
                    var fn = mf.createElement(o.o);
                    fn.setAttribute(s.ti, "-1"), fn.setAttribute(s.c, Ch), fn.onload = function() {
                      var Ei = this.contentDocument.defaultView;
                      Ei.addEventListener("resize", ye), Ei.document.documentElement.style.display = "none";
                    }, fn.type = "text/html", Ra && P.prepend(fn), fn.data = "about:blank", Ra || P.prepend(fn), P.on(J, ye);
                  }
                }
                if (P[0] === mC) {
                  var zs = function() {
                    var Ei = ot.css("direction"), Ue = {}, en = 0, tn = !1;
                    return Ei !== BP && (Ei === "ltr" ? (Ue[Ne] = 0, Ue[Pe] = hi, en = fe) : (Ue[Ne] = hi, Ue[Pe] = 0, en = K.n ? -fe : K.i ? 0 : fe), Sa.children().eq(0).css(Ue), Sa[di](en)[Qi](fe), BP = Ei, tn = !0), tn;
                  };
                  zs(), Ea(P, Nr, function(Ei) {
                    return zs() && La(), l.prvD(Ei), l.stpP(Ei), !1;
                  });
                }
              } else if (ue) {
                var Oe = P.contents()[0], Mi = Oe[i0];
                Mi && (Mi.disconnect(), delete Oe[i0]);
              } else
                pu(P.children(Ir + Ch).eq(0));
            }
          }
          function VU() {
            if (De) {
              var P = 11, H = l.mO(), X = l.now(), J, se, fe, ye, Oe, Te, xe, rt, Ye, mt;
              C0 = function(Dt) {
                var $t = !1, ut = !1, Xt, At = [];
                return ce && !ai && (j(Dt, function() {
                  Xt = this, J = Xt.target, se = Xt.attributeName, fe = se === s.c, ye = Xt.oldValue, Oe = J.className, It && fe && !ut && ye.indexOf(oC) > -1 && Oe.indexOf(oC) < 0 && (Te = fA(!0), Zo.className = Oe.split(Cn).concat(ye.split(Cn).filter(function(Ji) {
                    return Ji.match(Te);
                  })).join(Cn), $t = ut = !0), $t || ($t = fe ? lA(ye, Oe) : se === s.s ? ye !== J[s.s].cssText : !0), At.push(se);
                }), I0(At), $t && $.update(ut || hi)), $t;
              }, y0 = function(Dt) {
                var $t = !1, ut;
                return ce && !ai && (j(Dt, function() {
                  return ut = this, $t = GU(ut), !$t;
                }), $t && (rt = l.now(), Ye = hc || Bs, mt = function() {
                  ke || (X = rt, Ie && P0(), Ye ? La() : $.update(hi));
                }, clearTimeout(xe), P <= 0 || rt - X > P || !Ye ? mt() : xe = setTimeout(mt, P))), $t;
              }, _C = new H(C0), CC = new H(y0);
            }
          }
          function rA() {
            De && !dl && (_C.observe(Zo, {
              attributes: !0,
              attributeOldValue: !0,
              attributeFilter: w0
            }), CC.observe(Ie ? uc : Vs, {
              attributes: !0,
              attributeOldValue: !0,
              subtree: !Ie,
              childList: !Ie,
              characterData: !Ie,
              attributeFilter: Ie ? tA : w0
            }), dl = !0);
          }
          function O0() {
            De && dl && (_C.disconnect(), CC.disconnect(), dl = !1);
          }
          function BU() {
            if (!ai) {
              var P, H = {
                w: mC[s.sW],
                h: mC[s.sH]
              };
              P = xh(H, $P), $P = H, P && La({ _hostSizeChanged: !0 });
            }
          }
          function oA() {
            Th && fl(!0);
          }
          function sA() {
            Th && !Sh.hasClass(yh) && fl(!1);
          }
          function HU() {
            Hs && (fl(!0), clearTimeout(nA), nA = setTimeout(function() {
              Hs && !ke && fl(!1);
            }, 100));
          }
          function Qg(P) {
            return l.prvD(P), !1;
          }
          function x0(P) {
            if (!ke) {
              var H = P.target, X = d(P.target), J = d.inArray(H, bh);
              J > -1 && bh.splice(J, 1), mA(function(se, fe) {
                X.is(fe) && La({ _contentSizeChanged: !0 });
              });
            }
          }
          function N0(P) {
            P || N0(!0), Po(
              ot,
              lc.split(Cn)[0],
              HU,
              !Hs || P,
              !0
            ), Po(
              ot,
              [rC, fP],
              [oA, sA],
              !Th || P,
              !0
            ), !ce && !P && ot.one("mouseover", oA);
          }
          function aA() {
            var P = {};
            return $e && cu && (P.w = pl(cu.css(Ve + Fe)), P.h = pl(cu.css(Ve + Rt)), P.c = xh(P, dc), P.f = !0), dc = P, !!P.c;
          }
          function lA(P, H) {
            var X = typeof H == o.s ? H.split(Cn) : [], J = typeof P == o.s ? P.split(Cn) : [], se = YU(J, X), fe = z(hC, se), ye, Oe;
            if (fe > -1 && se.splice(fe, 1), se[s.l] > 0) {
              for (Oe = fA(!0, !0), ye = 0; ye < se.length; ye++)
                if (!se[ye].match(Oe))
                  return !0;
            }
            return !1;
          }
          function GU(P) {
            var H = P.attributeName, X = P.target, J = P.type, se = "closest";
            if (X === Vs)
              return H === null;
            if (J === "attributes" && (H === s.c || H === s.s) && !Ie) {
              if (H === s.c && d(X).hasClass(Br))
                return lA(P.oldValue, X.className);
              if (typeof X[se] != o.f)
                return !0;
              if (X[se](Ir + Ch) !== null || X[se](Ir + lu) !== null || X[se](Ir + l0) !== null)
                return !1;
            }
            return !0;
          }
          function UU() {
            if (ai)
              return !1;
            var P = gA(), H = Ie && Bs && !vC ? jt.val().length : 0, X = !dl && Bs && !Ie, J = {}, se, fe, ye, Oe;
            return X && (se = hn.css(ni), J[ni] = pt ? Pe : Ne, J[Fe] = hi, hn.css(J)), Oe = {
              w: P[s.sW] + H,
              h: P[s.sH] + H
            }, X && (J[ni] = se, J[Fe] = Io, hn.css(J)), fe = aA(), ye = xh(Oe, jP), jP = Oe, ye || fe;
          }
          function zU() {
            if (!(ai || dl)) {
              var P, H, X, J = [], se = [
                {
                  _elem: ot,
                  _attrs: w0.concat(":visible")
                },
                {
                  _elem: Ie ? jt : i,
                  _attrs: tA
                }
              ];
              return j(se, function(fe, ye) {
                P = ye._elem, P && j(ye._attrs, function(Oe, Te) {
                  H = Te.charAt(0) === ":" ? P.is(Te) : P.attr(Te), X = eA[Te], xh(H, X) && J.push(Te), eA[Te] = H;
                });
              }), I0(J), J[s.l] > 0;
            }
          }
          function jU(P) {
            if (!ce)
              return !0;
            var H = "flex-grow", X = "flex-shrink", J = "flex-basis", se = [
              Fe,
              Ve + Fe,
              Lt + Fe,
              Q + Ne,
              Q + Pe,
              Ne,
              Pe,
              "font-weight",
              "word-spacing",
              H,
              X,
              J
            ], fe = [
              le + Ne,
              le + Pe,
              pe + Ne + Fe,
              pe + Pe + Fe
            ], ye = [
              Rt,
              Ve + Rt,
              Lt + Rt,
              Q + Ee,
              Q + Ke,
              Ee,
              Ke,
              "line-height",
              H,
              X,
              J
            ], Oe = [
              le + Ee,
              le + Ke,
              pe + Ee + Fe,
              pe + Ke + Fe
            ], Te = "s", xe = "v-s", rt = vf.x === Te || vf.x === xe, Ye = vf.y === Te || vf.y === xe, mt = !1, Dt = function($t, ut) {
              for (var Xt = 0; Xt < $t[s.l]; Xt++)
                if ($t[Xt] === ut)
                  return !0;
              return !1;
            };
            return Ye && (mt = Dt(ye, P), !mt && !ti && (mt = Dt(Oe, P))), rt && !mt && (mt = Dt(se, P), !mt && !ti && (mt = Dt(fe, P))), mt;
          }
          function I0(P) {
            P = P || h0, j(P, function(H, X) {
              if (l.inA(X, h0) > -1) {
                var J = jt.attr(X);
                M(J) == o.s ? Pt.attr(X, J) : Pt.removeAttr(X);
              }
            });
          }
          function P0() {
            if (!ai) {
              var P = !vC, H = Yt.w, X = Yt.h, J = {}, se = Bs || P, fe, ye, Oe, Te;
              return J[Ve + Fe] = Be, J[Ve + Rt] = Be, J[Fe] = hi, jt.css(J), fe = uc[s.oW], ye = se ? u.max(fe, uc[s.sW] - 1) : 1, J[Fe] = Bs ? hi : Io, J[Ve + Fe] = Io, J[Rt] = hi, jt.css(J), Oe = uc[s.oH], Te = u.max(Oe, uc[s.sH] - 1), J[Fe] = ye, J[Rt] = Te, hu.css(J), J[Ve + Fe] = H, J[Ve + Rt] = X, jt.css(J), {
                _originalWidth: fe,
                _originalHeight: Oe,
                _dynamicWidth: ye,
                _dynamicHeight: Te
              };
            }
          }
          function La(P) {
            clearTimeout(PP), P = P || {}, wh._hostSizeChanged |= P._hostSizeChanged, wh._contentSizeChanged |= P._contentSizeChanged, wh._force |= P._force;
            var H = l.now(), X = !!wh._hostSizeChanged, J = !!wh._contentSizeChanged, se = !!wh._force, fe = P._changedOptions, ye = ce && !ke && !se && !fe && H - IP < AP && !hc && !Bs, Oe;
            if (ye && (PP = setTimeout(La, AP)), !(ke || ye || ai && !fe || ce && !se && (Oe = ot.is(":hidden")) || ot.css("display") === "inline")) {
              IP = H, wh = {}, U && !(re.x && re.y) ? (N.x = 0, N.y = 0) : N = ho({}, R.nativeScrollbarSize), No = {
                x: (N.x + (re.x ? 0 : 3)) * 3,
                y: (N.y + (re.y ? 0 : 3)) * 3
              }, fe = fe || {};
              var Te = function() {
                return xh.apply(this, [].slice.call(arguments).concat([se]));
              }, xe = {
                x: Pt[di](),
                y: Pt[Qi]()
              }, rt = Gn.scrollbars, Ye = Gn.textarea, mt = rt.visibility, Dt = Te(mt, KP), $t = rt.autoHide, ut = Te($t, qP), Xt = rt.clickScrolling, At = Te(Xt, YP), Ji = rt.dragScrolling, Ar = Te(Ji, m0), yn = Gn.className, fo = Te(yn, Zg), ir = Gn.resize, Pn = Te(ir, XP) && !$e, An = Gn.paddingAbsolute, dn = Te(An, HP), Un = Gn.clipAlways, Ra = Te(Un, GP), fn = Gn.sizeAutoCapable && !$e, zs = Te(fn, zP), Mi = Gn.nativeScrollbarsOverlaid.showNativeScrollbars, Ei = Te(Mi, p0), Ue = Gn.autoUpdate, en = Te(Ue, g0), tn = Gn.overflowBehavior, es = Te(tn, vf, se), gu = Ye.dynWidth, Nh = Te(JP, gu), po = Ye.dynHeight, gl = Te(QP, po);
              if (L0 = $t === "n", fc = $t === "s", Hs = $t === "m", Th = $t === "l", E0 = rt.autoHideDelay, v0 = Zg, yC = ir === "n", wC = ir === "b", R0 = ir === "h", T0 = ir === "v", du = Gn.normalizeRTL, Mi = Mi && re.x && re.y, KP = mt, qP = $t, YP = Xt, m0 = Ji, Zg = yn, XP = ir, HP = An, GP = Un, zP = fn, p0 = Mi, g0 = Ue, vf = ho({}, tn), JP = gu, QP = po, hl = hl || { x: !1, y: !1 }, fo && (Pr(ot, v0 + Cn + hC), In(ot, yn !== i && yn !== null && yn.length > 0 ? yn : hC)), en && (Ue === !0 || Ue === null && W ? (O0(), A.add($)) : (A.remove($), rA())), zs)
                if (fn)
                  if (Hr ? Hr.show() : (Hr = d(Jo(AU)), Ws.before(Hr)), ii)
                    ba.show();
                  else {
                    ba = d(Jo(MU)), gC = ba[0], Hr.before(ba);
                    var ml = { w: -1, h: -1 };
                    bC(ba, function() {
                      var Ph = {
                        w: gC[s.oW],
                        h: gC[s.oH]
                      };
                      xh(Ph, ml) && (ce && hc && Ph.h > 0 || Bs && Ph.w > 0 || ce && !hc && Ph.h === 0 || !Bs && Ph.w === 0) && La(), ml = Ph;
                    }), ii = !0, O !== null && ba.css(Rt, O + "(100% + 1px)");
                  }
                else
                  ii && ba.hide(), Hr && Hr.hide();
              se && (Sa.find("*").trigger(Nr), ii && ba.find("*").trigger(Nr)), Oe = Oe === i ? ot.is(":hidden") : Oe;
              var ts = Ie ? jt.attr("wrap") !== "off" : !1, em = Te(ts, vC), is = ot.css("direction"), Gr = Te(is, VP), mu = ot.css("box-sizing"), ns = Te(mu, FP), an = V0(le), Cr;
              try {
                Cr = ii ? gC[s.bCR]() : null;
              } catch {
                return;
              }
              pt = is === "rtl", ti = mu === "border-box";
              var yr = pt ? Ne : Pe, Zt = pt ? Pe : Ne, js = !1, gc = ii && ot.css(ni) !== "none" ? u.round(Cr.right - Cr.left) === 0 && (An ? !0 : Zo[s.cW] - lt > 0) : !1;
              if (fn && !gc) {
                var Ih = Zo[s.oW], vu = Hr.css(Fe);
                Hr.css(Fe, hi);
                var vl = Zo[s.oW];
                Hr.css(Fe, vu), js = Ih !== vl, js || (Hr.css(Fe, Ih + 1), vl = Zo[s.oW], Hr.css(Fe, vu), js = Ih !== vl);
              }
              var Bt = (gc || js) && fn && !Oe, wr = Te(Bt, Bs), _u = !Bt && Bs, zi = ii && fn && !Oe ? u.round(Cr.bottom - Cr.top) === 0 : !1, br = Te(zi, hc), $s = !zi && hc, tm = Bt && ti || !ti, SC = zi && ti || !ti, Ks = V0(pe, "-" + Fe, !tm, !SC), _l = V0(Q), Qe = {}, tt = {}, wn = function() {
                return {
                  w: Zo[s.cW],
                  h: Zo[s.cH]
                };
              }, Ur = function() {
                return {
                  w: cc[s.oW] + u.max(0, Vs[s.cW] - Vs[s.sW]),
                  h: cc[s.oH] + u.max(0, Vs[s.cH] - Vs[s.sH])
                };
              }, _i = lt = an.l + an.r, qs = Ui = an.t + an.b;
              if (_i *= An ? 1 : 0, qs *= An ? 1 : 0, an.c = Te(an, f0), zt = Ks.l + Ks.r, Xi = Ks.t + Ks.b, Ks.c = Te(Ks, kP), Zi = _l.l + _l.r, Si = _l.t + _l.b, _l.c = Te(_l, WP), vC = ts, VP = is, FP = mu, Bs = Bt, hc = zi, f0 = an, kP = Ks, WP = _l, Gr && ii && ba.css(ni, Zt), an.c || Gr || dn || wr || br || ns || zs) {
                var Mn = {}, go = {}, mc = [an.t, an.r, an.b, an.l];
                Oh(tt, Q, [-an.t, -an.r, -an.b, -an.l]), An ? (Oh(Mn, Be, mc), Oh(Ie ? go : Qe, le)) : (Oh(Mn, Be), Oh(Ie ? go : Qe, le, mc)), Ws.css(Mn), jt.css(go);
              }
              Yt = Ur();
              var nn = Ie ? P0() : !1, Ys = Ie && Te(nn, ZP), Cl = Ie && nn ? {
                w: gu ? nn._dynamicWidth : nn._originalWidth,
                h: po ? nn._dynamicHeight : nn._originalHeight
              } : {};
              if (ZP = nn, zi && (br || dn || ns || an.c || Ks.c) ? Qe[Rt] = hi : (br || dn) && (Qe[Rt] = Io), Bt && (wr || dn || ns || an.c || Ks.c || Gr) ? (Qe[Fe] = hi, tt[Lt + Fe] = Io) : (wr || dn) && (Qe[Fe] = Io, Qe[ni] = Be, tt[Lt + Fe] = Be), Bt ? (tt[Fe] = hi, Qe[Fe] = a._cssPropertyValue(Fe, "max-content intrinsic") || hi, Qe[ni] = Zt) : tt[Fe] = Be, zi ? tt[Rt] = Cl.h || Vs[s.cH] : tt[Rt] = Be, fn && Hr.css(tt), hn.css(Qe), Qe = {}, tt = {}, X || J || Ys || Gr || ns || dn || wr || Bt || br || zi || Ei || es || Ra || Pn || Dt || ut || Ar || At || Nh || gl || em) {
                var nr = "overflow", Cu = nr + "-x", yl = nr + "-y", vc = "hidden", Xs = "visible";
                if (!U) {
                  var wl = {}, G0 = hl.y && Xg.ys && !Mi ? re.y ? Pt.css(yr) : -N.y : 0, JU = hl.x && Xg.xs && !Mi ? re.x ? Pt.css(Ke) : -N.x : 0;
                  Oh(wl, Be), Pt.css(wl);
                }
                var _c = gA(), im = {
                  //use clientSize because natively overlaidScrollbars add borders
                  w: Cl.w || _c[s.cW],
                  h: Cl.h || _c[s.cH]
                }, vA = {
                  w: _c[s.sW],
                  h: _c[s.sH]
                };
                U || (wl[Ke] = $s ? Be : JU, wl[yr] = _u ? Be : G0, Pt.css(wl)), Yt = Ur();
                var nm = wn(), U0 = {
                  w: nm.w - Zi - zt - (ti ? 0 : lt),
                  h: nm.h - Si - Xi - (ti ? 0 : Ui)
                }, yf = {
                  //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually
                  //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding
                  w: u.max((Bt ? im.w : vA.w) + _i, U0.w),
                  h: u.max((zi ? im.h : vA.h) + qs, U0.h)
                };
                if (yf.c = Te(yf, UP), UP = yf, fn) {
                  (yf.c || zi || Bt) && (tt[Fe] = yf.w, tt[Rt] = yf.h, Ie || (im = {
                    //use clientSize because natively overlaidScrollbars add borders
                    w: _c[s.cW],
                    h: _c[s.cH]
                  }));
                  var _A = {}, CA = function(bn) {
                    var Mr = Gs(bn), Zs = Mr._w_h, pn = Mr._width_height, Qt = bn ? Bt : zi, Ta = bn ? zt : Xi, Ah = bn ? lt : Ui, q0 = bn ? Zi : Si, OC = Yt[Zs] - Ta - q0 - (ti ? 0 : Ah);
                    (!Qt || !Qt && Ks.c) && (tt[pn] = U0[Zs] - 1), Qt && im[Zs] < OC && (!(bn && Ie) || !ts) && (Ie && (_A[pn] = pl(hu.css(pn)) - 1), tt[pn] -= 1), im[Zs] > 0 && (tt[pn] = u.max(1, tt[pn]));
                  };
                  CA(!0), CA(!1), Ie && hu.css(_A), Hr.css(tt);
                }
                Bt && (Qe[Fe] = Io), Bt && !ti && !dl && (Qe[ni] = "none"), hn.css(Qe), Qe = {};
                var Cc = {
                  w: _c[s.sW],
                  h: _c[s.sH]
                };
                Cc.c = J = Te(Cc, Rh), Rh = Cc, Yt = Ur(), nm = wn(), X = Te(nm, Yg), Yg = nm;
                var z0 = Ie && (Yt.w === 0 || Yt.h === 0), EC = _f, wf = {}, rm = {}, yA = {}, bl = {}, rn = {}, Fi = {}, om = {}, wA = cc[s.bCR](), bA = function(bn) {
                  var Mr = Gs(bn), Zs = Gs(!bn), pn = Zs._x_y, Qt = Mr._x_y, Ta = Mr._w_h, Ah = Mr._width_height, q0 = Nr + Mr._Left_Top + "Max", OC = wA[Ah] ? u.abs(wA[Ah] - Yt[Ta]) : 0, dz = EC && EC[Qt] > 0 && Dh[q0] === 0;
                  wf[Qt] = tn[Qt] === "v-s", rm[Qt] = tn[Qt] === "v-h", yA[Qt] = tn[Qt] === "s", bl[Qt] = u.max(0, u.round((Cc[Ta] - Yt[Ta]) * 100) / 100), bl[Qt] *= z0 || dz && OC > 0 && OC < 1 ? 0 : 1, rn[Qt] = bl[Qt] > 0, Fi[Qt] = wf[Qt] || rm[Qt] ? rn[pn] && !wf[pn] && !rm[pn] : rn[Qt], Fi[Qt + "s"] = Fi[Qt] ? yA[Qt] || wf[Qt] : !1, om[Qt] = rn[Qt] && Fi[Qt + "s"];
                };
                if (bA(!0), bA(!1), bl.c = Te(bl, _f), _f = bl, rn.c = Te(rn, hl), hl = rn, Fi.c = Te(Fi, Xg), Xg = Fi, re.x || re.y) {
                  var ez = "px solid transparent", j0 = {}, yu = {}, LC = se, $0;
                  (rn.x || rn.y) && (yu.w = re.y && rn.y ? Cc.w + Y.y : Be, yu.h = re.x && rn.x ? Cc.h + Y.x : Be, LC = Te(yu, MP), MP = yu), (rn.c || Fi.c || Cc.c || Gr || wr || br || Bt || zi || Ei) && (Qe[Q + Zt] = Qe[pe + Zt] = Be, $0 = function(bn) {
                    var Mr = Gs(bn), Zs = Gs(!bn), pn = Mr._x_y, Qt = bn ? Ke : yr, Ta = bn ? zi : Bt;
                    re[pn] && rn[pn] && Fi[pn + "s"] ? (Qe[Q + Qt] = Ta ? Mi ? Be : Y[pn] : Be, Qe[pe + Qt] = (!bn || !Ta) && !Mi ? Y[pn] + ez : Be) : (yu[Zs._w_h] = Qe[Q + Qt] = Qe[pe + Qt] = Be, LC = !0);
                  }, U ? Us(Pt, s0, !Mi) : ($0(!0), $0(!1))), Mi && (yu.w = yu.h = Be, LC = !0), LC && !U && (j0[Fe] = Fi.y ? yu.w : Be, j0[Rt] = Fi.x ? yu.h : Be, cu || (cu = d(Jo(PU)), Pt.prepend(cu)), cu.css(j0)), hn.css(Qe);
                }
                var rr = {}, Mn = {}, K0;
                if ((X || rn.c || Fi.c || Cc.c || es || ns || Ei || Gr || Ra || br) && (rr[Zt] = Be, K0 = function(bn) {
                  var Mr = Gs(bn), Zs = Gs(!bn), pn = Mr._x_y, Qt = Mr._X_Y, Ta = bn ? Ke : yr, Ah = function() {
                    rr[Ta] = Be, tr[Zs._w_h] = 0;
                  };
                  rn[pn] && Fi[pn + "s"] ? (rr[nr + Qt] = Nr, Mi || U ? Ah() : (rr[Ta] = -(re[pn] ? Y[pn] : N[pn]), tr[Zs._w_h] = re[pn] ? Y[Zs._x_y] : 0)) : (rr[nr + Qt] = Be, Ah());
                }, K0(!0), K0(!1), !U && (Yt.h < No.x || Yt.w < No.y) && (rn.x && Fi.x && !re.x || rn.y && Fi.y && !re.y) ? (rr[le + Ee] = No.x, rr[Q + Ee] = -No.x, rr[le + Zt] = No.y, rr[Q + Zt] = -No.y) : rr[le + Ee] = rr[Q + Ee] = rr[le + Zt] = rr[Q + Zt] = Be, rr[le + yr] = rr[Q + yr] = Be, rn.x && Fi.x || rn.y && Fi.y || z0 ? Ie && z0 && (Mn[Cu] = Mn[yl] = vc) : (!Un || rm.x || wf.x || rm.y || wf.y) && (Ie && (Mn[Cu] = Mn[yl] = Be), rr[Cu] = rr[yl] = Xs), Ws.css(Mn), Pt.css(rr), rr = {}, (rn.c || ns || wr || br) && !(re.x && re.y))) {
                  var DC = Vs[s.s];
                  DC.webkitTransform = "scale(1)", DC.display = "run-in", Vs[s.oH], DC.display = Be, DC.webkitTransform = Be;
                }
                if (Qe = {}, Gr || wr || br)
                  if (pt && Bt) {
                    var tz = hn.css(ni), SA = u.round(hn.css(ni, Be).css(Ne, Be).position().left);
                    hn.css(ni, tz);
                    var iz = u.round(hn.position().left);
                    SA !== iz && (Qe[Ne] = SA);
                  } else
                    Qe[Ne] = Be;
                if (hn.css(Qe), Ie && J) {
                  var Sl = XU();
                  if (Sl) {
                    var EA = _0 === i ? !0 : Sl._rows !== _0._rows, LA = Sl._cursorRow, nz = Sl._cursorColumn, rz = Sl._widestRow, oz = Sl._rows, sz = Sl._columns, az = Sl._cursorPosition, lz = Sl._cursorMax, DA = az >= lz && S0, RC = {
                      x: !ts && nz === sz && LA === rz ? _f.x : -1,
                      y: (ts ? DA || EA && (EC && xe.y === EC.y) : (DA || EA) && LA === oz) ? _f.y : -1
                    };
                    xe.x = RC.x > -1 ? pt && du && K.i ? 0 : RC.x : xe.x, xe.y = RC.y > -1 ? RC.y : xe.y;
                  }
                  _0 = Sl;
                }
                pt && K.i && re.y && rn.x && du && (xe.x += tr.w || 0), Bt && ot[di](0), zi && ot[Qi](0), Pt[di](xe.x)[Qi](xe.y);
                var uz = mt === "v", cz = mt === "h", hz = mt === "a", TC = function(bn, Mr) {
                  Mr = Mr === i ? bn : Mr, hA(!0, bn, om.x), hA(!1, Mr, om.y);
                };
                Us(ot, Gg, Fi.x || Fi.y), Us(ot, CP, Fi.x), Us(ot, yP, Fi.y), Gr && !$e && Us(ot, _P, pt), $e && In(ot, r0), Pn && (Us(ot, r0, yC), Us(co, zg, !yC), Us(co, TP, wC), Us(co, OP, R0), Us(co, xP, T0)), (Dt || es || Fi.c || rn.c || Ei) && (Mi ? Ei && (Pr(ot, sC), Mi && TC(!1)) : hz ? TC(om.x, om.y) : uz ? TC(!0) : cz && TC(!1)), (ut || Ei) && (N0(!Th && !Hs), fl(L0, !L0)), (X || bl.c || br || wr || Pn || ns || dn || Ei || Gr) && (k0(!0), Da(!0), k0(!1), Da(!1)), At && dA(!0, Xt), Ar && dA(!1, Ji), Qo("onDirectionChanged", {
                  isRTL: pt,
                  dir: is
                }, Gr), Qo("onHostSizeChanged", {
                  width: Yg.w,
                  height: Yg.h
                }, X), Qo("onContentSizeChanged", {
                  width: Rh.w,
                  height: Rh.h
                }, J), Qo("onOverflowChanged", {
                  x: rn.x,
                  y: rn.y,
                  xScrollable: Fi.xs,
                  yScrollable: Fi.ys,
                  clipped: Fi.x || Fi.y
                }, rn.c || Fi.c), Qo("onOverflowAmountChanged", {
                  x: bl.x,
                  y: bl.y
                }, bl.c);
              }
              $e && dc && (hl.c || dc.c) && (dc.f || aA(), re.y && hl.x && hn.css(Ve + Fe, dc.w + Y.y), re.x && hl.y && hn.css(Ve + Rt, dc.h + Y.x), dc.c = !1), ce && fe.updateOnLoad && uA(), Qo("onUpdated", { forced: se });
            }
          }
          function uA() {
            Ie || mA(function(P, H) {
              hn.find(H).each(function(X, J) {
                l.inA(J, bh) < 0 && (bh.push(J), d(J).off(d0, x0).on(d0, x0));
              });
            });
          }
          function A0(P) {
            var H = C._validate(P, C._template, !0, jg);
            return jg = ho({}, jg, H._default), Gn = ho({}, Gn, H._prepared), H._prepared;
          }
          function M0(P) {
            var H = "parent", X = "os-resize-observer-host", J = aC + Cn + cC, se = Ie ? Cn + cC : Be, fe = Gn.textarea.inheritedAttrs, ye = {}, Oe = function() {
              var rt = P ? jt : ot;
              j(ye, function(Ye, mt) {
                M(mt) == o.s && (Ye == s.c ? rt.addClass(mt) : rt.attr(Ye, mt));
              });
            }, Te = [
              Br,
              oC,
              n0,
              r0,
              _P,
              gP,
              mP,
              vP,
              sC,
              Gg,
              CP,
              yP,
              hC,
              aC,
              cC,
              Zg
            ].join(Cn), xe = {};
            ot = ot || (Ie ? It ? jt[H]()[H]()[H]()[H]() : d(Jo(n0)) : jt), hn = hn || fu(a0 + se), Pt = Pt || fu(lC + se), Ws = Ws || fu(o0 + se), Sa = Sa || fu(X), hu = hu || (Ie ? fu(IU) : i), It && In(ot, oC), P && Pr(ot, Te), fe = M(fe) == o.s ? fe.split(Cn) : fe, l.isA(fe) && Ie && j(fe, function(rt, Ye) {
              M(Ye) == o.s && (ye[Ye] = P ? ot.attr(Ye) : jt.attr(Ye));
            }), P ? (It && ce ? (Sa.children().remove(), j([Ws, Pt, hn, hu], function(rt, Ye) {
              Ye && Pr(Ye.removeAttr(s.s), u0);
            }), In(ot, Ie ? n0 : Br)) : (pu(Sa), hn.contents().unwrap().unwrap().unwrap(), Ie && (jt.unwrap(), pu(ot), pu(hu), Oe())), Ie && jt.removeAttr(s.s), $e && Pr(gf, pP)) : (Ie && (Gn.sizeAutoCapable || (xe[Fe] = jt.css(Fe), xe[Rt] = jt.css(Rt)), It || jt.addClass(cC).wrap(ot), ot = jt[H]().css(xe)), It || (In(jt, Ie ? J : Br), ot.wrapInner(hn).wrapInner(Pt).wrapInner(Ws).prepend(Sa), hn = Cf(ot, Ir + a0), Pt = Cf(ot, Ir + lC), Ws = Cf(ot, Ir + o0), Ie && (hn.prepend(hu), Oe())), U && In(Pt, s0), re.x && re.y && In(Pt, wP), $e && In(gf, pP), mC = Sa[0], Zo = ot[0], cc = Ws[0], Dh = Pt[0], Vs = hn[0], I0());
          }
          function $U() {
            var P = [
              112,
              113,
              114,
              115,
              116,
              117,
              118,
              119,
              120,
              121,
              123,
              //F1 to F12
              33,
              34,
              //page up, page down
              37,
              38,
              39,
              40,
              //left, up, right, down arrows
              16,
              17,
              18,
              19,
              20,
              144
              //Shift, Ctrl, Alt, Pause, CapsLock, NumLock
            ], H = [], X, J, se = 175, fe = "focus";
            function ye(ut) {
              P0(), $.update(hi), ut && W && clearInterval(X);
            }
            function Oe(ut) {
              return jt[di](K.i && du ? 9999999 : 0), jt[Qi](0), l.prvD(ut), l.stpP(ut), !1;
            }
            function Te(ut) {
              setTimeout(function() {
                ke || ye();
              }, 50);
            }
            function xe() {
              S0 = !0, In(ot, fe);
            }
            function rt() {
              S0 = !1, H = [], Pr(ot, fe), ye(!0);
            }
            function Ye(ut) {
              var Xt = ut.keyCode;
              z(Xt, P) < 0 && (H[s.l] || (ye(), X = setInterval(ye, 1e3 / 60)), z(Xt, H) < 0 && H.push(Xt));
            }
            function mt(ut) {
              var Xt = ut.keyCode, At = z(Xt, H);
              z(Xt, P) < 0 && (At > -1 && H.splice(At, 1), H[s.l] || ye(!0));
            }
            function Dt(ut) {
              g0 !== !0 && (ut = ut.originalEvent || ut, jU(ut.propertyName) && $.update(hi));
            }
            function $t(ut) {
              ai || (J !== i ? clearTimeout(J) : ((fc || Hs) && fl(!0), Jg() || In(ot, sC), Qo("onScrollStart", ut)), pc || (Da(!0), Da(!1)), Qo("onScroll", ut), J = setTimeout(function() {
                ke || (clearTimeout(J), J = i, (fc || Hs) && fl(!1), Jg() || Pr(ot, sC), Qo("onScrollStop", ut));
              }, se));
            }
            Ie ? (B > 9 || !W ? Ea(jt, "input", ye) : Ea(
              jt,
              [JE, e0],
              [Ye, mt]
            ), Ea(
              jt,
              [Nr, "drop", fe, fe + "out"],
              [Oe, Te, xe, rt]
            )) : Ea(hn, t0, Dt), Ea(Pt, Nr, $t, !0);
          }
          function F0(P) {
            var H = function(fe) {
              var ye = fe ? FU : kU, Oe = fu(lu + Cn + ye, !0), Te = fu(SP, Oe), xe = fu(LP, Oe);
              return !It && !P && (Oe.append(Te), Te.append(xe)), {
                _scrollbar: Oe,
                _track: Te,
                _handle: xe
              };
            };
            function X(fe) {
              var ye = Gs(fe), Oe = ye._scrollbar, Te = ye._track, xe = ye._handle;
              It && ce ? j([Oe, Te, xe], function(rt, Ye) {
                Pr(Ye.removeAttr(s.s), u0);
              }) : pu(Oe || H(fe)._scrollbar);
            }
            var J, se;
            P ? (X(!0), X()) : (J = H(!0), se = H(), Eh = J._scrollbar, fC = J._track, $g = J._handle, Lh = se._scrollbar, pC = se._track, Kg = se._handle, It || (Ws.after(Lh), Ws.after(Eh)));
          }
          function cA(P) {
            var H = Gs(P), X = H._info, J = qg.top !== qg, se = H._x_y, fe = H._X_Y, ye = Nr + H._Left_Top, Oe = "active", Te = "snapHandle", xe = "click", rt = 1, Ye = [16, 17], mt, Dt, $t, ut;
            function Xt(Ue) {
              return B && J ? Ue["screen" + fe] : l.page(Ue)[se];
            }
            function At(Ue) {
              return Gn.scrollbars[Ue];
            }
            function Ji() {
              rt = 0.5;
            }
            function Ar() {
              rt = 1;
            }
            function yn(Ue) {
              l.stpP(Ue);
            }
            function fo(Ue) {
              z(Ue.keyCode, Ye) > -1 && Ji();
            }
            function ir(Ue) {
              z(Ue.keyCode, Ye) > -1 && Ar();
            }
            function Pn(Ue) {
              var en = Ue.originalEvent || Ue, tn = en.touches !== i;
              return ai || ke || Jg() || !m0 || tn && !At("touchSupport") ? !1 : l.mBtn(Ue) === 1 || tn;
            }
            function An(Ue) {
              if (Pn(Ue)) {
                var en = X._trackLength, tn = X._handleLength, es = X._maxScroll, gu = (Xt(Ue) - $t) * ut, Nh = gu / (en - tn), po = es * Nh;
                po = isFinite(po) ? po : 0, pt && P && !K.i && (po *= -1), Pt[ye](u.round(Dt + po)), pc && Da(P, Dt + po), te || l.prvD(Ue);
              } else
                dn(Ue);
            }
            function dn(Ue) {
              if (Ue = Ue || Ue.originalEvent, Po(
                cl,
                [lc, au, JE, e0, Hg],
                [An, dn, fo, ir, Qg],
                !0
              ), l.rAF()(function() {
                Po(cl, xe, yn, !0, { _capture: !0 });
              }), pc && Da(P, !0), pc = !1, Pr(Sh, yh), Pr(H._handle, Oe), Pr(H._track, Oe), Pr(H._scrollbar, Oe), Dt = i, $t = i, ut = 1, Ar(), mt !== i && ($.scrollStop(), clearTimeout(mt), mt = i), Ue) {
                var en = Zo[s.bCR](), tn = Ue.clientX >= en.left && Ue.clientX <= en.right && Ue.clientY >= en.top && Ue.clientY <= en.bottom;
                tn || sA(), (fc || Hs) && fl(!1);
              }
            }
            function Un(Ue) {
              Pn(Ue) && Ra(Ue);
            }
            function Ra(Ue) {
              Dt = Pt[ye](), Dt = isNaN(Dt) ? 0 : Dt, (pt && P && !K.n || !pt) && (Dt = Dt < 0 ? 0 : Dt), ut = B0()[se], $t = Xt(Ue), pc = !At(Te), In(Sh, yh), In(H._handle, Oe), In(H._scrollbar, Oe), Po(
                cl,
                [lc, au, Hg],
                [An, dn, Qg]
              ), l.rAF()(function() {
                Po(cl, xe, yn, !1, { _capture: !0 });
              }), (B || !Ot) && l.prvD(Ue), l.stpP(Ue);
            }
            function fn(Ue) {
              if (Pn(Ue)) {
                var en = H._info._handleLength / Math.round(u.min(1, Yt[H._w_h] / Rh[H._w_h]) * H._info._trackLength), tn = u.round(Yt[H._w_h] * en), es = 270 * en, gu = 400 * en, Nh = H._track.offset()[H._left_top], po = Ue.ctrlKey, gl = Ue.shiftKey, ml = gl && po, ts = !0, em = "linear", is, Gr, mu = function(Cr) {
                  pc && Da(P, Cr);
                }, ns = function() {
                  mu(), Ra(Ue);
                }, an = function() {
                  if (!ke) {
                    var Cr = ($t - Nh) * ut, yr = X._handleOffset, Zt = X._trackLength, js = X._handleLength, gc = X._maxScroll, Ih = X._currentScroll, vu = es * rt, vl = ts ? u.max(gu, vu) : vu, Bt = gc * ((Cr - js / 2) / (Zt - js)), wr = pt && P && (!K.i && !K.n || du), _u = wr ? yr < Cr : yr > Cr, zi = {}, br = {
                      easing: em,
                      step: function($s) {
                        pc && (Pt[ye]($s), Da(P, $s));
                      }
                    };
                    Bt = isFinite(Bt) ? Bt : 0, Bt = pt && P && !K.i ? gc - Bt : Bt, gl ? (Pt[ye](Bt), ml ? (Bt = Pt[ye](), Pt[ye](Ih), Bt = wr && K.i ? gc - Bt : Bt, Bt = wr && K.n ? -Bt : Bt, zi[se] = Bt, $.scroll(zi, ho(br, {
                      duration: 130,
                      complete: ns
                    }))) : ns()) : (is = ts ? _u : is, Gr = wr ? is ? yr + js >= Cr : yr <= Cr : is ? yr <= Cr : yr + js >= Cr, Gr ? (clearTimeout(mt), $.scrollStop(), mt = i, mu(!0)) : (mt = setTimeout(an, vl), zi[se] = (is ? "-=" : "+=") + tn, $.scroll(zi, ho(br, {
                      duration: vu
                    }))), ts = !1);
                  }
                };
                po && Ji(), ut = B0()[se], $t = l.page(Ue)[se], pc = !At(Te), In(Sh, yh), In(H._track, Oe), In(H._scrollbar, Oe), Po(
                  cl,
                  [au, JE, e0, Hg],
                  [dn, fo, ir, Qg]
                ), an(), l.prvD(Ue), l.stpP(Ue);
              }
            }
            function zs(Ue) {
              D0 = !0, (fc || Hs) && fl(!0);
            }
            function Mi(Ue) {
              D0 = !1, (fc || Hs) && fl(!1);
            }
            function Ei(Ue) {
              l.stpP(Ue);
            }
            Ea(
              H._handle,
              sn,
              Un
            ), Ea(
              H._track,
              [sn, rC, fP],
              [fn, zs, Mi]
            ), Ea(
              H._scrollbar,
              sn,
              Ei
            ), I && Ea(H._scrollbar, t0, function(Ue) {
              Ue.target === H._scrollbar[0] && (k0(P), Da(P));
            });
          }
          function hA(P, H, X) {
            var J = P ? gP : mP, se = P ? Eh : Lh;
            Us(ot, J, !H), Us(se, RP, !X);
          }
          function fl(P, H) {
            if (clearTimeout(iA), P)
              Pr(Eh, Ug), Pr(Lh, Ug);
            else {
              var X, J = "active", se = function() {
                !D0 && !ke && (X = $g.hasClass(J) || Kg.hasClass(J), !X && (fc || Hs || Th) && In(Eh, Ug), !X && (fc || Hs || Th) && In(Lh, Ug));
              };
              E0 > 0 && H !== !0 ? iA = setTimeout(se, E0) : se();
            }
          }
          function k0(P) {
            var H = {}, X = Gs(P), J = X._info, se = 1e6, fe = u.min(1, Yt[X._w_h] / Rh[X._w_h]);
            H[X._width_height] = u.floor(fe * 100 * se) / se + "%", Jg() || X._handle.css(H), J._handleLength = X._handle[0]["offset" + X._Width_Height], J._handleLengthRatio = fe;
          }
          function Da(P, H) {
            var X = M(H) == o.b, J = 250, se = pt && P, fe = Gs(P), ye = fe._info, Oe = "translate(", Te = a._cssProperty("transform"), xe = a._cssProperty("transition"), rt = P ? Pt[di]() : Pt[Qi](), Ye = H === i || X ? rt : H, mt = ye._handleLength, Dt = fe._track[0]["offset" + fe._Width_Height], $t = Dt - mt, ut = {}, Xt, At, Ji = (Dh[Nr + fe._Width_Height] - Dh["client" + fe._Width_Height]) * (K.n && se ? -1 : 1), Ar = function(dn) {
              return isNaN(dn / Ji) ? 0 : u.max(0, u.min(1, dn / Ji));
            }, yn = function(dn) {
              var Un = $t * dn;
              return Un = isNaN(Un) ? 0 : Un, Un = se && !K.i ? Dt - mt - Un : Un, Un = u.max(0, Un), Un;
            }, fo = Ar(rt), ir = Ar(Ye), Pn = yn(ir), An = yn(fo);
            ye._maxScroll = Ji, ye._currentScroll = rt, ye._currentScrollRatio = fo, V ? (Xt = se ? -(Dt - mt - Pn) : Pn, At = P ? Oe + Xt + "px, 0)" : Oe + "0, " + Xt + "px)", ut[Te] = At, I && (ut[xe] = X && u.abs(Pn - ye._handleOffset) > 1 ? qU(fe._handle) + ", " + (Te + Cn + J + "ms") : Be)) : ut[fe._left_top] = Pn, Jg() || (fe._handle.css(ut), V && I && X && fe._handle.one(t0, function() {
              ke || fe._handle.css(xe, Be);
            })), ye._handleOffset = Pn, ye._snappedHandleOffset = An, ye._trackLength = Dt;
          }
          function dA(P, H) {
            var X = H ? "removeClass" : "addClass", J = P ? fC : $g, se = P ? pC : Kg, fe = P ? EP : DP;
            J[X](fe), se[X](fe);
          }
          function Gs(P) {
            return {
              _width_height: P ? Fe : Rt,
              _Width_Height: P ? "Width" : "Height",
              _left_top: P ? Ne : Ee,
              _Left_Top: P ? "Left" : "Top",
              _x_y: P ? lo : ul,
              _X_Y: P ? "X" : "Y",
              _w_h: P ? "w" : "h",
              _l_t: P ? "l" : "t",
              _track: P ? fC : pC,
              _handle: P ? $g : Kg,
              _scrollbar: P ? Eh : Lh,
              _info: P ? Nn : Hn
            };
          }
          function W0(P) {
            co = co || fu(l0, !0), P ? It && ce ? Pr(co.removeAttr(s.s), u0) : pu(co) : It || ot.append(co);
          }
          function KU() {
            var P = qg.top !== qg, H = {}, X = {}, J = {}, se;
            function fe(xe) {
              if (Oe(xe)) {
                var rt = Te(xe), Ye = {};
                (R0 || wC) && (Ye[Fe] = X.w + (rt.x - H.x) * J.x), (T0 || wC) && (Ye[Rt] = X.h + (rt.y - H.y) * J.y), ot.css(Ye), l.stpP(xe);
              } else
                ye(xe);
            }
            function ye(xe) {
              var rt = xe !== i;
              Po(
                cl,
                [Hg, lc, au],
                [Qg, fe, ye],
                !0
              ), Pr(Sh, yh), co.releaseCapture && co.releaseCapture(), rt && (se && rA(), $.update(hi)), se = !1;
            }
            function Oe(xe) {
              var rt = xe.originalEvent || xe, Ye = rt.touches !== i;
              return ai || ke ? !1 : l.mBtn(xe) === 1 || Ye;
            }
            function Te(xe) {
              return B && P ? { x: xe.screenX, y: xe.screenY } : l.page(xe);
            }
            Ea(co, sn, function(xe) {
              Oe(xe) && !yC && (dl && (se = !0, O0()), H = Te(xe), X.w = Zo[s.oW] - (ti ? 0 : lt), X.h = Zo[s.oH] - (ti ? 0 : Ui), J = B0(), Po(
                cl,
                [Hg, lc, au],
                [Qg, fe, ye]
              ), In(Sh, yh), co.setCapture && co.setCapture(), l.prvD(xe), l.stpP(xe));
            });
          }
          function Qo(P, H, X) {
            if (X !== !1)
              if (ce) {
                var J = Gn.callbacks[P], se = P, fe;
                se.substr(0, 2) === "on" && (se = se.substr(2, 1).toLowerCase() + se.substr(3)), M(J) == o.f && J.call($, H), j(uu, function() {
                  fe = this, M(fe.on) == o.f && fe.on(se, H);
                });
              } else
                ke || c0.push({ n: P, a: H });
          }
          function Oh(P, H, X) {
            H = H || Be, X = X || [Be, Be, Be, Be], P[H + Ee] = X[0], P[H + Pe] = X[1], P[H + Ke] = X[2], P[H + Ne] = X[3];
          }
          function V0(P, H, X, J) {
            return H = H || Be, P = P || Be, {
              t: J ? 0 : pl(ot.css(P + Ee + H)),
              r: X ? 0 : pl(ot.css(P + Pe + H)),
              b: J ? 0 : pl(ot.css(P + Ke + H)),
              l: X ? 0 : pl(ot.css(P + Ne + H))
            };
          }
          function qU(P) {
            var H = a._cssProperty("transition"), X = P.css(H);
            if (X)
              return X;
            for (var J = "\\s*(([^,(]+(\\(.+?\\))?)+)[\\s,]*", se = new RegExp(J), fe = new RegExp("^(" + J + ")+$"), ye = "property duration timing-function delay".split(" "), Oe = [], Te, xe, rt = 0, Ye, mt = function(Dt) {
              if (Te = [], !Dt.match(fe))
                return Dt;
              for (; Dt.match(se); )
                Te.push(RegExp.$1), Dt = Dt.replace(se, Be);
              return Te;
            }; rt < ye[s.l]; rt++)
              for (xe = mt(P.css(H + "-" + ye[rt])), Ye = 0; Ye < xe[s.l]; Ye++)
                Oe[Ye] = (Oe[Ye] ? Oe[Ye] + Cn : Be) + xe[Ye];
            return Oe.join(", ");
          }
          function fA(P, H) {
            var X, J, se, fe = function(ye, Oe) {
              if (se = "", Oe && typeof ye == o.s)
                for (J = ye.split(Cn), X = 0; X < J[s.l]; X++)
                  se += "|" + J[X] + "$";
              return se;
            };
            return new RegExp(
              "(^" + Br + "([-_].+|)$)" + fe(Zg, P) + fe(v0, H),
              "g"
            );
          }
          function B0() {
            var P = cc[s.bCR]();
            return {
              x: V && 1 / (u.round(P.width) / cc[s.oW]) || 1,
              y: V && 1 / (u.round(P.height) / cc[s.oH]) || 1
            };
          }
          function pA(P) {
            var H = "ownerDocument", X = "HTMLElement", J = P && P[H] && P[H].parentWindow || e;
            return typeof J[X] == o.o ? P instanceof J[X] : (
              //DOM2
              P && typeof P == o.o && P !== null && P.nodeType === 1 && typeof P.nodeName == o.s
            );
          }
          function YU(P, H) {
            var X = [], J = [], se, fe;
            for (se = 0; se < P.length; se++)
              X[P[se]] = !0;
            for (se = 0; se < H.length; se++)
              X[H[se]] ? delete X[H[se]] : X[H[se]] = !0;
            for (fe in X)
              J.push(fe);
            return J;
          }
          function pl(P, H) {
            var X = H ? parseFloat(P) : parseInt(P, 10);
            return isNaN(X) ? 0 : X;
          }
          function XU() {
            var P = uc.selectionStart;
            if (P !== i) {
              var H = jt.val(), X = H[s.l], J = H.split(`
`), se = J[s.l], fe = H.substr(0, P).split(`
`), ye = 0, Oe = 0, Te = fe[s.l], xe = fe[fe[s.l] - 1][s.l], rt, Ye;
              for (Ye = 0; Ye < J[s.l]; Ye++)
                rt = J[Ye][s.l], rt > Oe && (ye = Ye + 1, Oe = rt);
              return {
                _cursorRow: Te,
                //cursorRow
                _cursorColumn: xe,
                //cursorCol
                _rows: se,
                //rows
                _columns: Oe,
                //cols
                _widestRow: ye,
                //wRow
                _cursorPosition: P,
                //pos
                _cursorMax: X
                //max
              };
            }
          }
          function Jg() {
            return p0 && re.x && re.y;
          }
          function gA() {
            return Ie ? hu[0] : Vs;
          }
          function Jo(P, H) {
            return "<div " + (P ? M(P) == o.s ? 'class="' + P + '"' : function() {
              var X, J = Be;
              if (d.isPlainObject(P))
                for (X in P)
                  J += (X === "c" ? "class" : X) + '="' + P[X] + '" ';
              return J;
            }() : Be) + ">" + (H || Be) + "</div>";
          }
          function fu(P, H) {
            var X = M(H) == o.b, J = X ? ot : H || ot;
            return It && !J[s.l] ? null : It ? J[X ? "children" : "find"](Ir + P.replace(/\s/g, Ir)).eq(0) : d(Jo(P));
          }
          function H0(P, H) {
            for (var X = H.split(Ir), J = 0, se; J < X.length; J++) {
              if (!P[s.hOP](X[J]))
                return;
              se = P[X[J]], J < X.length && M(se) == o.o && (P = se);
            }
            return se;
          }
          function ZU(P, H, X) {
            for (var J = H.split(Ir), se = J.length, fe = 0, ye = {}, Oe = ye; fe < se; fe++)
              ye = ye[J[fe]] = fe + 1 < se ? {} : X;
            d.extend(P, Oe, !0);
          }
          function mA(P) {
            var H = Gn.updateOnLoad;
            H = M(H) == o.s ? H.split(Cn) : H, l.isA(H) && !ke && j(H, P);
          }
          function xh(P, H, X) {
            if (X)
              return X;
            if (M(P) == o.o && M(H) == o.o) {
              for (var J in P)
                if (J !== "c")
                  if (P[s.hOP](J) && H[s.hOP](J)) {
                    if (xh(P[J], H[J]))
                      return !0;
                  } else
                    return !0;
            } else
              return P !== H;
            return !1;
          }
          function ho() {
            return d.extend.apply(this, [!0].concat([].slice.call(arguments)));
          }
          function In(P, H) {
            return k.addClass.call(P, H);
          }
          function Pr(P, H) {
            return k.removeClass.call(P, H);
          }
          function Us(P, H, X) {
            return X ? In(P, H) : Pr(P, H);
          }
          function pu(P) {
            return k.remove.call(P);
          }
          function Cf(P, H) {
            return k.find.call(P, H).eq(0);
          }
          $.sleep = function() {
            ai = !0;
          }, $.update = function(P) {
            if (!ke) {
              var H, X, J = M(P) == o.s, se, fe, ye;
              return J ? P === hi ? (H = zU(), X = UU(), se = H || X, se && La({
                _contentSizeChanged: X,
                _changedOptions: ce ? i : Gn
              })) : P === su ? dl ? (fe = C0(_C.takeRecords()), ye = y0(CC.takeRecords())) : fe = $.update(hi) : P === "zoom" && La({
                _hostSizeChanged: !0,
                _contentSizeChanged: !0
              }) : (P = ai || P, ai = !1, (!$.update(su) || P) && La({ _force: P })), uA(), se || fe || ye;
            }
          }, $.options = function(P, H) {
            var X = {}, J;
            if (d.isEmptyObject(P) || !d.isPlainObject(P))
              if (M(P) == o.s)
                if (arguments.length > 1)
                  ZU(X, P, H), J = A0(X);
                else
                  return H0(jg, P);
              else
                return jg;
            else
              J = A0(P);
            d.isEmptyObject(J) || La({ _changedOptions: J });
          }, $.destroy = function() {
            if (!ke) {
              A.remove($), O0(), bC(Sa), bC(ba);
              for (var P in uu)
                $.removeExt(P);
              for (; b0[s.l] > 0; )
                b0.pop()();
              N0(!0), Hr && pu(Hr), cu && pu(cu), ii && pu(ba), F0(!0), W0(!0), M0(!0);
              for (var H = 0; H < bh[s.l]; H++)
                d(bh[H]).off(d0, x0);
              bh = i, ke = !0, ai = !0, f(E, 0), Qo("onDestroyed");
            }
          }, $.scroll = function(P, H, X, J) {
            if (arguments.length === 0 || P === i) {
              var se = Nn, fe = Hn, ye = du && pt && K.i, Oe = du && pt && K.n, Te = se._currentScroll, xe = se._currentScrollRatio, rt = se._maxScroll;
              return xe = ye ? 1 - xe : xe, Te = ye ? rt - Te : Te, Te *= Oe ? -1 : 1, rt *= Oe ? -1 : 1, {
                position: {
                  x: Te,
                  y: fe._currentScroll
                },
                ratio: {
                  x: xe,
                  y: fe._currentScrollRatio
                },
                max: {
                  x: rt,
                  y: fe._maxScroll
                },
                handleOffset: {
                  x: se._handleOffset,
                  y: fe._handleOffset
                },
                handleLength: {
                  x: se._handleLength,
                  y: fe._handleLength
                },
                handleLengthRatio: {
                  x: se._handleLengthRatio,
                  y: fe._handleLengthRatio
                },
                trackLength: {
                  x: se._trackLength,
                  y: fe._trackLength
                },
                snappedHandleOffset: {
                  x: se._snappedHandleOffset,
                  y: fe._snappedHandleOffset
                },
                isRTL: pt,
                isRTLNormalized: du
              };
            }
            $.update(su);
            var Ye = du, mt = [lo, Ne, "l"], Dt = [ul, Ee, "t"], $t = ["+=", "-=", "*=", "/="], ut = M(H) == o.o, Xt = ut ? H.complete : J, At, Ji = {}, Ar = {}, yn, fo, ir, Pn = "end", An = "begin", dn = "center", Un = "nearest", Ra = "always", fn = "never", zs = "ifneeded", Mi = s.l, Ei, Ue, en, tn, es, gu = [lo, ul, "xy", "yx"], Nh = [An, Pn, dn, Un], po = [Ra, fn, zs], gl = P[s.hOP]("el"), ml = gl ? P.el : P, ts = ml instanceof d || c ? ml instanceof c : !1, em = ts ? !1 : pA(ml), is = function() {
              yn && Da(!0), fo && Da(!1);
            }, Gr = M(Xt) != o.f ? i : function() {
              is(), Xt();
            };
            function mu(Qe, tt) {
              for (At = 0; At < tt[Mi]; At++)
                if (Qe === tt[At])
                  return !0;
              return !1;
            }
            function ns(Qe, tt) {
              var wn = Qe ? mt : Dt;
              if (tt = M(tt) == o.s || M(tt) == o.n ? [tt, tt] : tt, l.isA(tt))
                return Qe ? tt[0] : tt[1];
              if (M(tt) == o.o) {
                for (At = 0; At < wn[Mi]; At++)
                  if (wn[At] in tt)
                    return tt[wn[At]];
              }
            }
            function an(Qe, tt) {
              var wn = M(tt) == o.s, Ur, _i, qs = Qe ? Nn : Hn, Mn = qs._currentScroll, go = qs._maxScroll, mc = " * ", nn, Ys = pt && Qe, Cl = Ys && K.n && !Ye, nr = "replace", Cu = eval, yl;
              if (wn ? (tt[Mi] > 2 && (yl = tt.substr(0, 2), z(yl, $t) > -1 && (Ur = yl)), tt = Ur ? tt.substr(2) : tt, tt = tt[nr](/min/g, 0)[nr](/</g, 0)[nr](/max/g, (Cl ? "-" : Be) + Io)[nr](/>/g, (Cl ? "-" : Be) + Io)[nr](/px/g, Be)[nr](/%/g, mc + go * (Ys && K.n ? -1 : 1) / 100)[nr](/vw/g, mc + Yt.w)[nr](/vh/g, mc + Yt.h), _i = pl(isNaN(tt) ? pl(Cu(tt), !0).toFixed() : tt)) : _i = tt, _i !== i && !isNaN(_i) && M(_i) == o.n) {
                var vc = Ye && Ys, Xs = Mn * (vc && K.n ? -1 : 1), wl = vc && K.i, G0 = vc && K.n;
                switch (Xs = wl ? go - Xs : Xs, Ur) {
                  case "+=":
                    nn = Xs + _i;
                    break;
                  case "-=":
                    nn = Xs - _i;
                    break;
                  case "*=":
                    nn = Xs * _i;
                    break;
                  case "/=":
                    nn = Xs / _i;
                    break;
                  default:
                    nn = _i;
                    break;
                }
                nn = wl ? go - nn : nn, nn *= G0 ? -1 : 1, nn = Ys && K.n ? u.min(0, u.max(go, nn)) : u.max(0, u.min(go, nn));
              }
              return nn === Mn ? i : nn;
            }
            function Cr(Qe, tt, wn, Ur) {
              var _i = [wn, wn], qs = M(Qe), Mn, go;
              if (qs == tt)
                Qe = [Qe, Qe];
              else if (qs == o.a) {
                if (Mn = Qe[Mi], Mn > 2 || Mn < 1)
                  Qe = _i;
                else
                  for (Mn === 1 && (Qe[1] = wn), At = 0; At < Mn; At++)
                    if (go = Qe[At], M(go) != tt || !mu(go, Ur)) {
                      Qe = _i;
                      break;
                    }
              } else
                qs == o.o ? Qe = [Qe[lo] || wn, Qe[ul] || wn] : Qe = _i;
              return { x: Qe[0], y: Qe[1] };
            }
            function yr(Qe) {
              var tt = [], wn, Ur, _i = [Ee, Pe, Ke, Ne];
              for (At = 0; At < Qe[Mi] && At !== _i[Mi]; At++)
                wn = Qe[At], Ur = M(wn), Ur == o.b ? tt.push(wn ? pl(es.css(Q + _i[At])) : 0) : tt.push(Ur == o.n ? wn : 0);
              return tt;
            }
            if (ts || em) {
              var Zt = gl ? P.margin : 0, js = gl ? P.axis : 0, gc = gl ? P.scroll : 0, Ih = gl ? P.block : 0, vu = [0, 0, 0, 0], vl = M(Zt), Bt;
              if (es = ts ? ml : d(ml), es[Mi] > 0) {
                vl == o.n || vl == o.b ? Zt = yr([Zt, Zt, Zt, Zt]) : vl == o.a ? (Bt = Zt[Mi], Bt === 2 ? Zt = yr([Zt[0], Zt[1], Zt[0], Zt[1]]) : Bt >= 4 ? Zt = yr(Zt) : Zt = vu) : vl == o.o ? Zt = yr([Zt[Ee], Zt[Pe], Zt[Ke], Zt[Ne]]) : Zt = vu, Ei = mu(js, gu) ? js : "xy", Ue = Cr(gc, o.s, Ra, po), en = Cr(Ih, o.s, An, Nh), tn = Zt;
                var wr = {
                  l: Nn._currentScroll,
                  t: Hn._currentScroll
                }, _u = Ws.offset(), zi = es.offset(), br = {
                  x: Ue.x == fn || Ei == ul,
                  y: Ue.y == fn || Ei == lo
                };
                zi[Ee] -= tn[0], zi[Ne] -= tn[3];
                var $s = {
                  x: u.round(zi[Ne] - _u[Ne] + wr.l),
                  y: u.round(zi[Ee] - _u[Ee] + wr.t)
                };
                if (pt && (!K.n && !K.i && ($s.x = u.round(_u[Ne] - zi[Ne] + wr.l)), K.n && Ye && ($s.x *= -1), K.i && Ye && ($s.x = u.round(_u[Ne] - zi[Ne] + (Nn._maxScroll - wr.l)))), en.x != An || en.y != An || Ue.x == zs || Ue.y == zs || pt) {
                  var tm = es[0], SC = V ? tm[s.bCR]() : {
                    width: tm[s.oW],
                    height: tm[s.oH]
                  }, Ks = {
                    w: SC[Fe] + tn[3] + tn[1],
                    h: SC[Rt] + tn[0] + tn[2]
                  }, _l = function(Qe) {
                    var tt = Gs(Qe), wn = tt._w_h, Ur = tt._left_top, _i = tt._x_y, qs = en[_i] == (Qe && pt ? An : Pn), Mn = en[_i] == dn, go = en[_i] == Un, mc = Ue[_i] == fn, nn = Ue[_i] == zs, Ys = Yt[wn], Cl = _u[Ur], nr = Ks[wn], Cu = zi[Ur], yl = Mn ? 2 : 1, vc = Cu + nr / 2, Xs = Cl + Ys / 2, wl = nr <= Ys && Cu >= Cl && Cu + nr <= Cl + Ys;
                    mc ? br[_i] = !0 : br[_i] || ((go || nn) && (br[_i] = nn ? wl : !1, qs = nr < Ys ? vc > Xs : vc < Xs), $s[_i] -= qs || Mn ? (Ys / yl - nr / yl) * (Qe && pt && Ye ? -1 : 1) : 0);
                  };
                  _l(!0), _l(!1);
                }
                br.y && delete $s.y, br.x && delete $s.x, P = $s;
              }
            }
            Ji[di] = an(!0, ns(!0, P)), Ji[Qi] = an(!1, ns(!1, P)), yn = Ji[di] !== i, fo = Ji[Qi] !== i, (yn || fo) && (H > 0 || ut) ? ut ? (H.complete = Gr, Pt.animate(Ji, H)) : (ir = {
              duration: H,
              complete: Gr
            }, l.isA(X) || d.isPlainObject(X) ? (Ar[di] = X[0] || X.x, Ar[Qi] = X[1] || X.y, ir.specialEasing = Ar) : ir.easing = X, Pt.animate(Ji, ir)) : (yn && Pt[di](Ji[di]), fo && Pt[Qi](Ji[Qi]), is());
          }, $.scrollStop = function(P, H, X) {
            return Pt.stop(P, H, X), $;
          }, $.getElements = function(P) {
            var H = {
              target: uc,
              host: Zo,
              padding: cc,
              viewport: Dh,
              content: Vs,
              scrollbarHorizontal: {
                scrollbar: Eh[0],
                track: fC[0],
                handle: $g[0]
              },
              scrollbarVertical: {
                scrollbar: Lh[0],
                track: pC[0],
                handle: Kg[0]
              },
              scrollbarCorner: co[0]
            };
            return M(P) == o.s ? H0(H, P) : H;
          }, $.getState = function(P) {
            function H(J) {
              if (!d.isPlainObject(J))
                return J;
              var se = ho({}, J), fe = function(ye, Oe) {
                se[s.hOP](ye) && (se[Oe] = se[ye], delete se[ye]);
              };
              return fe("w", Fe), fe("h", Rt), delete se.c, se;
            }
            var X = {
              destroyed: !!H(ke),
              sleeping: !!H(ai),
              autoUpdate: H(!dl),
              widthAuto: H(Bs),
              heightAuto: H(hc),
              padding: H(f0),
              overflowAmount: H(_f),
              hideOverflow: H(Xg),
              hasOverflow: H(hl),
              contentScrollSize: H(Rh),
              viewportSize: H(Yt),
              hostSize: H(Yg),
              documentMixed: H(Ot)
            };
            return M(P) == o.s ? H0(X, P) : X;
          }, $.ext = function(P) {
            var H, X = WU.split(" "), J = 0;
            if (M(P) == o.s) {
              if (uu[s.hOP](P))
                for (H = ho({}, uu[P]); J < X.length; J++)
                  delete H[X[J]];
            } else {
              H = {};
              for (J in uu)
                H[J] = ho({}, $.ext(J));
            }
            return H;
          }, $.addExt = function(P, H) {
            var X = g.extension(P), J, se, fe, ye, Oe = !0;
            if (X) {
              if (uu[s.hOP](P))
                return $.ext(P);
              if (J = X.extensionFactory.call(
                $,
                ho({}, X.defaultOptions),
                d,
                l
              ), J && (fe = J.contract, M(fe) == o.f && (ye = fe(e), Oe = M(ye) == o.b ? ye : Oe), Oe))
                return uu[P] = J, se = J.added, M(se) == o.f && se(H), $.ext(P);
            } else
              console.warn('A extension with the name "' + P + `" isn't registered.`);
          }, $.removeExt = function(P) {
            var H = uu[P], X;
            return H ? (delete uu[P], X = H.removed, M(X) == o.f && X(), !0) : !1;
          };
          function QU(P, H, X) {
            NP = R.defaultOptions, U = R.nativeScrollbarStyling, N = ho({}, R.nativeScrollbarSize), re = ho({}, R.nativeScrollbarIsOverlaid), Y = ho({}, R.overlayScrollbarDummySize), K = ho({}, R.rtlScrollBehavior), A0(ho({}, NP, H)), O = R.cssCalc, B = R.msie, W = R.autoUpdateRecommended, I = R.supportTransition, V = R.supportTransform, te = R.supportPassiveEvents, ue = R.supportResizeObserver, De = R.supportMutationObserver, R.restrictedMeasuring, cl = d(P.ownerDocument), mf = cl[0], dC = d(mf.defaultView || mf.parentWindow), qg = dC[0], gf = Cf(cl, "html"), Sh = Cf(gf, "body"), jt = d(P), uc = jt[0], Ie = jt.is("textarea"), $e = jt.is("body"), Ot = mf !== t, It = Ie ? jt.hasClass(aC) && jt.parent().hasClass(a0) : jt.hasClass(Br) && jt.children(Ir + o0)[s.l];
            var J, se;
            return re.x && re.y && !Gn.nativeScrollbarsOverlaid.initialize ? (ce = !0, Qo("onInitializationWithdrawn"), It && (M0(!0), F0(!0), W0(!0)), ce = !1, ke = !0, ai = !0, $) : ($e && (J = {}, J.l = u.max(jt[di](), gf[di](), dC[di]()), J.t = u.max(jt[Qi](), gf[Qi](), dC[Qi]()), se = function() {
              Pt.removeAttr(s.ti), Po(Pt, sn, se, !0, !0);
            }), M0(), F0(), W0(), $U(), cA(!0), cA(!1), KU(), VU(), bC(Sa, BU), $e && (Pt[di](J.l)[Qi](J.t), t.activeElement == P && Dh.focus && (Pt.attr(s.ti, "-1"), Dh.focus(), Po(Pt, sn, se, !1, !0))), $.update(hi), ce = !0, Qo("onInitialized"), j(c0, function(fe, ye) {
              Qo(ye.n, ye.a);
            }), c0 = [], M(X) == o.s && (X = [X]), l.isA(X) ? j(X, function(fe, ye) {
              $.addExt(ye);
            }) : d.isPlainObject(X) && j(X, function(fe, ye) {
              $.addExt(fe, ye);
            }), setTimeout(function() {
              I && !ke && In(ot, vP);
            }, 333), $);
          }
          return g.valid(QU(E, D, x)) && f(E, $), $;
        }
        return g = e[r] = function(E, D, x) {
          if (arguments[s.l] === 0)
            return this;
          var R = [], A = d.isPlainObject(D), M, z;
          return E ? (E = E[s.l] != i ? E : [E[0] || E], y(), E[s.l] > 0 && (A ? d.each(E, function(j, $) {
            M = $, M !== i && R.push(S(M, D, x, _, m));
          }) : d.each(E, function(j, $) {
            M = f($), (D === "!" && g.valid(M) || l.type(D) == o.f && D($, M) || D === i) && R.push(M);
          }), z = R[s.l] === 1 ? R[0] : R), z) : A || !D ? z : R;
        }, g.globals = function() {
          y();
          var E = d.extend(!0, {}, _);
          return delete E.msie, E;
        }, g.defaultOptions = function(E) {
          y();
          var D = _.defaultOptions;
          if (E === i)
            return d.extend(!0, {}, D);
          _.defaultOptions = d.extend(!0, {}, D, C._validate(E, C._template, !0, D)._default);
        }, g.valid = function(E) {
          return E instanceof g && !E.getState().destroyed;
        }, g.extension = function(E, D, x) {
          var R = l.type(E) == o.s, A = arguments[s.l], M = 0;
          if (A < 1 || !R)
            return d.extend(!0, { length: v[s.l] }, v);
          if (R) {
            if (l.type(D) == o.f)
              v.push({
                name: E,
                extensionFactory: D,
                defaultOptions: x
              });
            else
              for (; M < v[s.l]; M++)
                if (v[M].name === E)
                  if (A > 1)
                    v.splice(M, 1);
                  else
                    return d.extend(!0, {}, v[M]);
          }
        }, g;
      }();
      return c && c.fn && (c.fn.overlayScrollbars = function(g, _) {
        var m = this;
        return c.isPlainObject(g) ? (c.each(m, function() {
          p(this, g, _);
        }), m) : p(m, g);
      }), p;
    }
  );
})(g9);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function m9(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
}
class jCe extends fz {
  constructor(e) {
    super(e), this._osInstance = null, this._osTargetRef = bt.createRef();
  }
  osInstance() {
    return this._osInstance;
  }
  osTarget() {
    return this._osTargetRef.current || null;
  }
  componentDidMount() {
    this._osInstance = mp(this.osTarget(), this.props.options || {}, this.props.extensions), vM(this._osInstance, this.props.className);
  }
  componentWillUnmount() {
    mp.valid(this._osInstance) && (this._osInstance.destroy(), this._osInstance = null);
  }
  componentDidUpdate(e) {
    mp.valid(this._osInstance) && (this._osInstance.options(this.props.options), e.className !== this.props.className && vM(this._osInstance, this.props.className));
  }
  render() {
    const e = this.props, t = m9(e, ["options", "extensions", "children", "className"]);
    return bt.createElement(
      "div",
      Object.assign({ className: "os-host" }, t, { ref: this._osTargetRef }),
      bt.createElement("div", { className: "os-resize-observer-host" }),
      bt.createElement(
        "div",
        { className: "os-padding" },
        bt.createElement(
          "div",
          { className: "os-viewport" },
          bt.createElement("div", { className: "os-content" }, this.props.children)
        )
      ),
      bt.createElement(
        "div",
        { className: "os-scrollbar os-scrollbar-horizontal " },
        bt.createElement(
          "div",
          { className: "os-scrollbar-track" },
          bt.createElement("div", { className: "os-scrollbar-handle" })
        )
      ),
      bt.createElement(
        "div",
        { className: "os-scrollbar os-scrollbar-vertical" },
        bt.createElement(
          "div",
          { className: "os-scrollbar-track" },
          bt.createElement("div", { className: "os-scrollbar-handle" })
        )
      ),
      bt.createElement("div", { className: "os-scrollbar-corner" })
    );
  }
}
function vM(n, e) {
  if (mp.valid(n)) {
    const { host: t } = n.getElements(), i = new RegExp(`(^os-host([-_].+|)$)|${n.options().className.replace(/\s/g, "$|")}$`, "g"), r = t.className.split(" ").filter((o) => o.match(i)).join(" ");
    t.className = `${r} ${e || ""}`;
  }
}
var _M = function(e) {
  return e.reduce(function(t, i) {
    var r = i[0], o = i[1];
    return t[r] = o, t;
  }, {});
}, CM = typeof window < "u" && window.document && window.document.createElement ? me.useLayoutEffect : me.useEffect, zo = "top", va = "bottom", _a = "right", jo = "left", ES = "auto", R_ = [zo, va, _a, jo], Vp = "start", Vv = "end", v9 = "clippingParents", rB = "viewport", lm = "popper", _9 = "reference", yM = /* @__PURE__ */ R_.reduce(function(n, e) {
  return n.concat([e + "-" + Vp, e + "-" + Vv]);
}, []), oB = /* @__PURE__ */ [].concat(R_, [ES]).reduce(function(n, e) {
  return n.concat([e, e + "-" + Vp, e + "-" + Vv]);
}, []), C9 = "beforeRead", y9 = "read", w9 = "afterRead", b9 = "beforeMain", S9 = "main", E9 = "afterMain", L9 = "beforeWrite", D9 = "write", R9 = "afterWrite", P1 = [C9, y9, w9, b9, S9, E9, L9, D9, R9];
function Kl(n) {
  return n ? (n.nodeName || "").toLowerCase() : null;
}
function Ca(n) {
  if (n == null)
    return window;
  if (n.toString() !== "[object Window]") {
    var e = n.ownerDocument;
    return e && e.defaultView || window;
  }
  return n;
}
function Id(n) {
  var e = Ca(n).Element;
  return n instanceof e || n instanceof Element;
}
function Ss(n) {
  var e = Ca(n).HTMLElement;
  return n instanceof e || n instanceof HTMLElement;
}
function sx(n) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = Ca(n).ShadowRoot;
  return n instanceof e || n instanceof ShadowRoot;
}
function T9(n) {
  var e = n.state;
  Object.keys(e.elements).forEach(function(t) {
    var i = e.styles[t] || {}, r = e.attributes[t] || {}, o = e.elements[t];
    !Ss(o) || !Kl(o) || (Object.assign(o.style, i), Object.keys(r).forEach(function(s) {
      var a = r[s];
      a === !1 ? o.removeAttribute(s) : o.setAttribute(s, a === !0 ? "" : a);
    }));
  });
}
function O9(n) {
  var e = n.state, t = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function() {
    Object.keys(e.elements).forEach(function(i) {
      var r = e.elements[i], o = e.attributes[i] || {}, s = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : t[i]), a = s.reduce(function(l, u) {
        return l[u] = "", l;
      }, {});
      !Ss(r) || !Kl(r) || (Object.assign(r.style, a), Object.keys(o).forEach(function(l) {
        r.removeAttribute(l);
      }));
    });
  };
}
const x9 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: T9,
  effect: O9,
  requires: ["computeStyles"]
};
function Qa(n) {
  return n.split("-")[0];
}
var _d = Math.max, Fw = Math.min, Bp = Math.round;
function A1() {
  var n = navigator.userAgentData;
  return n != null && n.brands ? n.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function sB() {
  return !/^((?!chrome|android).)*safari/i.test(A1());
}
function Hp(n, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  var i = n.getBoundingClientRect(), r = 1, o = 1;
  e && Ss(n) && (r = n.offsetWidth > 0 && Bp(i.width) / n.offsetWidth || 1, o = n.offsetHeight > 0 && Bp(i.height) / n.offsetHeight || 1);
  var s = Id(n) ? Ca(n) : window, a = s.visualViewport, l = !sB() && t, u = (i.left + (l && a ? a.offsetLeft : 0)) / r, c = (i.top + (l && a ? a.offsetTop : 0)) / o, h = i.width / r, d = i.height / o;
  return {
    width: h,
    height: d,
    top: c,
    right: u + h,
    bottom: c + d,
    left: u,
    x: u,
    y: c
  };
}
function ax(n) {
  var e = Hp(n), t = n.offsetWidth, i = n.offsetHeight;
  return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - i) <= 1 && (i = e.height), {
    x: n.offsetLeft,
    y: n.offsetTop,
    width: t,
    height: i
  };
}
function aB(n, e) {
  var t = e.getRootNode && e.getRootNode();
  if (n.contains(e))
    return !0;
  if (t && sx(t)) {
    var i = e;
    do {
      if (i && n.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function tl(n) {
  return Ca(n).getComputedStyle(n);
}
function N9(n) {
  return ["table", "td", "th"].indexOf(Kl(n)) >= 0;
}
function ph(n) {
  return ((Id(n) ? n.ownerDocument : (
    // $FlowFixMe[prop-missing]
    n.document
  )) || window.document).documentElement;
}
function LS(n) {
  return Kl(n) === "html" ? n : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    n.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    n.parentNode || // DOM Element detected
    (sx(n) ? n.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    ph(n)
  );
}
function wM(n) {
  return !Ss(n) || // https://github.com/popperjs/popper-core/issues/837
  tl(n).position === "fixed" ? null : n.offsetParent;
}
function I9(n) {
  var e = /firefox/i.test(A1()), t = /Trident/i.test(A1());
  if (t && Ss(n)) {
    var i = tl(n);
    if (i.position === "fixed")
      return null;
  }
  var r = LS(n);
  for (sx(r) && (r = r.host); Ss(r) && ["html", "body"].indexOf(Kl(r)) < 0; ) {
    var o = tl(r);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || e && o.willChange === "filter" || e && o.filter && o.filter !== "none")
      return r;
    r = r.parentNode;
  }
  return null;
}
function T_(n) {
  for (var e = Ca(n), t = wM(n); t && N9(t) && tl(t).position === "static"; )
    t = wM(t);
  return t && (Kl(t) === "html" || Kl(t) === "body" && tl(t).position === "static") ? e : t || I9(n) || e;
}
function lx(n) {
  return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y";
}
function sv(n, e, t) {
  return _d(n, Fw(e, t));
}
function P9(n, e, t) {
  var i = sv(n, e, t);
  return i > t ? t : i;
}
function lB() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function uB(n) {
  return Object.assign({}, lB(), n);
}
function cB(n, e) {
  return e.reduce(function(t, i) {
    return t[i] = n, t;
  }, {});
}
var A9 = function(e, t) {
  return e = typeof e == "function" ? e(Object.assign({}, t.rects, {
    placement: t.placement
  })) : e, uB(typeof e != "number" ? e : cB(e, R_));
};
function M9(n) {
  var e, t = n.state, i = n.name, r = n.options, o = t.elements.arrow, s = t.modifiersData.popperOffsets, a = Qa(t.placement), l = lx(a), u = [jo, _a].indexOf(a) >= 0, c = u ? "height" : "width";
  if (!(!o || !s)) {
    var h = A9(r.padding, t), d = ax(o), f = l === "y" ? zo : jo, p = l === "y" ? va : _a, g = t.rects.reference[c] + t.rects.reference[l] - s[l] - t.rects.popper[c], _ = s[l] - t.rects.reference[l], m = T_(o), v = m ? l === "y" ? m.clientHeight || 0 : m.clientWidth || 0 : 0, C = g / 2 - _ / 2, y = h[f], w = v - d[c] - h[p], L = v / 2 - d[c] / 2 + C, S = sv(y, L, w), E = l;
    t.modifiersData[i] = (e = {}, e[E] = S, e.centerOffset = S - L, e);
  }
}
function F9(n) {
  var e = n.state, t = n.options, i = t.element, r = i === void 0 ? "[data-popper-arrow]" : i;
  if (r != null && !(typeof r == "string" && (r = e.elements.popper.querySelector(r), !r))) {
    if (process.env.NODE_ENV !== "production" && (Ss(r) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !aB(e.elements.popper, r)) {
      process.env.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    e.elements.arrow = r;
  }
}
const k9 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: M9,
  effect: F9,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Gp(n) {
  return n.split("-")[1];
}
var W9 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function V9(n) {
  var e = n.x, t = n.y, i = window, r = i.devicePixelRatio || 1;
  return {
    x: Bp(e * r) / r || 0,
    y: Bp(t * r) / r || 0
  };
}
function bM(n) {
  var e, t = n.popper, i = n.popperRect, r = n.placement, o = n.variation, s = n.offsets, a = n.position, l = n.gpuAcceleration, u = n.adaptive, c = n.roundOffsets, h = n.isFixed, d = s.x, f = d === void 0 ? 0 : d, p = s.y, g = p === void 0 ? 0 : p, _ = typeof c == "function" ? c({
    x: f,
    y: g
  }) : {
    x: f,
    y: g
  };
  f = _.x, g = _.y;
  var m = s.hasOwnProperty("x"), v = s.hasOwnProperty("y"), C = jo, y = zo, w = window;
  if (u) {
    var L = T_(t), S = "clientHeight", E = "clientWidth";
    if (L === Ca(t) && (L = ph(t), tl(L).position !== "static" && a === "absolute" && (S = "scrollHeight", E = "scrollWidth")), L = L, r === zo || (r === jo || r === _a) && o === Vv) {
      y = va;
      var D = h && L === w && w.visualViewport ? w.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        L[S]
      );
      g -= D - i.height, g *= l ? 1 : -1;
    }
    if (r === jo || (r === zo || r === va) && o === Vv) {
      C = _a;
      var x = h && L === w && w.visualViewport ? w.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        L[E]
      );
      f -= x - i.width, f *= l ? 1 : -1;
    }
  }
  var R = Object.assign({
    position: a
  }, u && W9), A = c === !0 ? V9({
    x: f,
    y: g
  }) : {
    x: f,
    y: g
  };
  if (f = A.x, g = A.y, l) {
    var M;
    return Object.assign({}, R, (M = {}, M[y] = v ? "0" : "", M[C] = m ? "0" : "", M.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + g + "px)" : "translate3d(" + f + "px, " + g + "px, 0)", M));
  }
  return Object.assign({}, R, (e = {}, e[y] = v ? g + "px" : "", e[C] = m ? f + "px" : "", e.transform = "", e));
}
function B9(n) {
  var e = n.state, t = n.options, i = t.gpuAcceleration, r = i === void 0 ? !0 : i, o = t.adaptive, s = o === void 0 ? !0 : o, a = t.roundOffsets, l = a === void 0 ? !0 : a;
  if (process.env.NODE_ENV !== "production") {
    var u = tl(e.elements.popper).transitionProperty || "";
    s && ["transform", "top", "right", "bottom", "left"].some(function(h) {
      return u.indexOf(h) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var c = {
    placement: Qa(e.placement),
    variation: Gp(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: r,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, bM(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: s,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, bM(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const H9 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: B9,
  data: {}
};
var AC = {
  passive: !0
};
function G9(n) {
  var e = n.state, t = n.instance, i = n.options, r = i.scroll, o = r === void 0 ? !0 : r, s = i.resize, a = s === void 0 ? !0 : s, l = Ca(e.elements.popper), u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return o && u.forEach(function(c) {
    c.addEventListener("scroll", t.update, AC);
  }), a && l.addEventListener("resize", t.update, AC), function() {
    o && u.forEach(function(c) {
      c.removeEventListener("scroll", t.update, AC);
    }), a && l.removeEventListener("resize", t.update, AC);
  };
}
const U9 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: G9,
  data: {}
};
var z9 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Yy(n) {
  return n.replace(/left|right|bottom|top/g, function(e) {
    return z9[e];
  });
}
var j9 = {
  start: "end",
  end: "start"
};
function SM(n) {
  return n.replace(/start|end/g, function(e) {
    return j9[e];
  });
}
function ux(n) {
  var e = Ca(n), t = e.pageXOffset, i = e.pageYOffset;
  return {
    scrollLeft: t,
    scrollTop: i
  };
}
function cx(n) {
  return Hp(ph(n)).left + ux(n).scrollLeft;
}
function $9(n, e) {
  var t = Ca(n), i = ph(n), r = t.visualViewport, o = i.clientWidth, s = i.clientHeight, a = 0, l = 0;
  if (r) {
    o = r.width, s = r.height;
    var u = sB();
    (u || !u && e === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: o,
    height: s,
    x: a + cx(n),
    y: l
  };
}
function K9(n) {
  var e, t = ph(n), i = ux(n), r = (e = n.ownerDocument) == null ? void 0 : e.body, o = _d(t.scrollWidth, t.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), s = _d(t.scrollHeight, t.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), a = -i.scrollLeft + cx(n), l = -i.scrollTop;
  return tl(r || t).direction === "rtl" && (a += _d(t.clientWidth, r ? r.clientWidth : 0) - o), {
    width: o,
    height: s,
    x: a,
    y: l
  };
}
function hx(n) {
  var e = tl(n), t = e.overflow, i = e.overflowX, r = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(t + r + i);
}
function hB(n) {
  return ["html", "body", "#document"].indexOf(Kl(n)) >= 0 ? n.ownerDocument.body : Ss(n) && hx(n) ? n : hB(LS(n));
}
function av(n, e) {
  var t;
  e === void 0 && (e = []);
  var i = hB(n), r = i === ((t = n.ownerDocument) == null ? void 0 : t.body), o = Ca(i), s = r ? [o].concat(o.visualViewport || [], hx(i) ? i : []) : i, a = e.concat(s);
  return r ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(av(LS(s)))
  );
}
function M1(n) {
  return Object.assign({}, n, {
    left: n.x,
    top: n.y,
    right: n.x + n.width,
    bottom: n.y + n.height
  });
}
function q9(n, e) {
  var t = Hp(n, !1, e === "fixed");
  return t.top = t.top + n.clientTop, t.left = t.left + n.clientLeft, t.bottom = t.top + n.clientHeight, t.right = t.left + n.clientWidth, t.width = n.clientWidth, t.height = n.clientHeight, t.x = t.left, t.y = t.top, t;
}
function EM(n, e, t) {
  return e === rB ? M1($9(n, t)) : Id(e) ? q9(e, t) : M1(K9(ph(n)));
}
function Y9(n) {
  var e = av(LS(n)), t = ["absolute", "fixed"].indexOf(tl(n).position) >= 0, i = t && Ss(n) ? T_(n) : n;
  return Id(i) ? e.filter(function(r) {
    return Id(r) && aB(r, i) && Kl(r) !== "body";
  }) : [];
}
function X9(n, e, t, i) {
  var r = e === "clippingParents" ? Y9(n) : [].concat(e), o = [].concat(r, [t]), s = o[0], a = o.reduce(function(l, u) {
    var c = EM(n, u, i);
    return l.top = _d(c.top, l.top), l.right = Fw(c.right, l.right), l.bottom = Fw(c.bottom, l.bottom), l.left = _d(c.left, l.left), l;
  }, EM(n, s, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function dB(n) {
  var e = n.reference, t = n.element, i = n.placement, r = i ? Qa(i) : null, o = i ? Gp(i) : null, s = e.x + e.width / 2 - t.width / 2, a = e.y + e.height / 2 - t.height / 2, l;
  switch (r) {
    case zo:
      l = {
        x: s,
        y: e.y - t.height
      };
      break;
    case va:
      l = {
        x: s,
        y: e.y + e.height
      };
      break;
    case _a:
      l = {
        x: e.x + e.width,
        y: a
      };
      break;
    case jo:
      l = {
        x: e.x - t.width,
        y: a
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var u = r ? lx(r) : null;
  if (u != null) {
    var c = u === "y" ? "height" : "width";
    switch (o) {
      case Vp:
        l[u] = l[u] - (e[c] / 2 - t[c] / 2);
        break;
      case Vv:
        l[u] = l[u] + (e[c] / 2 - t[c] / 2);
        break;
    }
  }
  return l;
}
function Bv(n, e) {
  e === void 0 && (e = {});
  var t = e, i = t.placement, r = i === void 0 ? n.placement : i, o = t.strategy, s = o === void 0 ? n.strategy : o, a = t.boundary, l = a === void 0 ? v9 : a, u = t.rootBoundary, c = u === void 0 ? rB : u, h = t.elementContext, d = h === void 0 ? lm : h, f = t.altBoundary, p = f === void 0 ? !1 : f, g = t.padding, _ = g === void 0 ? 0 : g, m = uB(typeof _ != "number" ? _ : cB(_, R_)), v = d === lm ? _9 : lm, C = n.rects.popper, y = n.elements[p ? v : d], w = X9(Id(y) ? y : y.contextElement || ph(n.elements.popper), l, c, s), L = Hp(n.elements.reference), S = dB({
    reference: L,
    element: C,
    strategy: "absolute",
    placement: r
  }), E = M1(Object.assign({}, C, S)), D = d === lm ? E : L, x = {
    top: w.top - D.top + m.top,
    bottom: D.bottom - w.bottom + m.bottom,
    left: w.left - D.left + m.left,
    right: D.right - w.right + m.right
  }, R = n.modifiersData.offset;
  if (d === lm && R) {
    var A = R[r];
    Object.keys(x).forEach(function(M) {
      var z = [_a, va].indexOf(M) >= 0 ? 1 : -1, j = [zo, va].indexOf(M) >= 0 ? "y" : "x";
      x[M] += A[j] * z;
    });
  }
  return x;
}
function Z9(n, e) {
  e === void 0 && (e = {});
  var t = e, i = t.placement, r = t.boundary, o = t.rootBoundary, s = t.padding, a = t.flipVariations, l = t.allowedAutoPlacements, u = l === void 0 ? oB : l, c = Gp(i), h = c ? a ? yM : yM.filter(function(p) {
    return Gp(p) === c;
  }) : R_, d = h.filter(function(p) {
    return u.indexOf(p) >= 0;
  });
  d.length === 0 && (d = h, process.env.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var f = d.reduce(function(p, g) {
    return p[g] = Bv(n, {
      placement: g,
      boundary: r,
      rootBoundary: o,
      padding: s
    })[Qa(g)], p;
  }, {});
  return Object.keys(f).sort(function(p, g) {
    return f[p] - f[g];
  });
}
function Q9(n) {
  if (Qa(n) === ES)
    return [];
  var e = Yy(n);
  return [SM(n), e, SM(e)];
}
function J9(n) {
  var e = n.state, t = n.options, i = n.name;
  if (!e.modifiersData[i]._skip) {
    for (var r = t.mainAxis, o = r === void 0 ? !0 : r, s = t.altAxis, a = s === void 0 ? !0 : s, l = t.fallbackPlacements, u = t.padding, c = t.boundary, h = t.rootBoundary, d = t.altBoundary, f = t.flipVariations, p = f === void 0 ? !0 : f, g = t.allowedAutoPlacements, _ = e.options.placement, m = Qa(_), v = m === _, C = l || (v || !p ? [Yy(_)] : Q9(_)), y = [_].concat(C).reduce(function(U, O) {
      return U.concat(Qa(O) === ES ? Z9(e, {
        placement: O,
        boundary: c,
        rootBoundary: h,
        padding: u,
        flipVariations: p,
        allowedAutoPlacements: g
      }) : O);
    }, []), w = e.rects.reference, L = e.rects.popper, S = /* @__PURE__ */ new Map(), E = !0, D = y[0], x = 0; x < y.length; x++) {
      var R = y[x], A = Qa(R), M = Gp(R) === Vp, z = [zo, va].indexOf(A) >= 0, j = z ? "width" : "height", $ = Bv(e, {
        placement: R,
        boundary: c,
        rootBoundary: h,
        altBoundary: d,
        padding: u
      }), k = z ? M ? _a : jo : M ? va : zo;
      w[j] > L[j] && (k = Yy(k));
      var ae = Yy(k), re = [];
      if (o && re.push($[A] <= 0), a && re.push($[k] <= 0, $[ae] <= 0), re.every(function(U) {
        return U;
      })) {
        D = R, E = !1;
        break;
      }
      S.set(R, re);
    }
    if (E)
      for (var Y = p ? 3 : 1, K = function(O) {
        var N = y.find(function(I) {
          var V = S.get(I);
          if (V)
            return V.slice(0, O).every(function(te) {
              return te;
            });
        });
        if (N)
          return D = N, "break";
      }, W = Y; W > 0; W--) {
        var B = K(W);
        if (B === "break")
          break;
      }
    e.placement !== D && (e.modifiersData[i]._skip = !0, e.placement = D, e.reset = !0);
  }
}
const ej = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: J9,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function LM(n, e, t) {
  return t === void 0 && (t = {
    x: 0,
    y: 0
  }), {
    top: n.top - e.height - t.y,
    right: n.right - e.width + t.x,
    bottom: n.bottom - e.height + t.y,
    left: n.left - e.width - t.x
  };
}
function DM(n) {
  return [zo, _a, va, jo].some(function(e) {
    return n[e] >= 0;
  });
}
function tj(n) {
  var e = n.state, t = n.name, i = e.rects.reference, r = e.rects.popper, o = e.modifiersData.preventOverflow, s = Bv(e, {
    elementContext: "reference"
  }), a = Bv(e, {
    altBoundary: !0
  }), l = LM(s, i), u = LM(a, r, o), c = DM(l), h = DM(u);
  e.modifiersData[t] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: u,
    isReferenceHidden: c,
    hasPopperEscaped: h
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": c,
    "data-popper-escaped": h
  });
}
const ij = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: tj
};
function nj(n, e, t) {
  var i = Qa(n), r = [jo, zo].indexOf(i) >= 0 ? -1 : 1, o = typeof t == "function" ? t(Object.assign({}, e, {
    placement: n
  })) : t, s = o[0], a = o[1];
  return s = s || 0, a = (a || 0) * r, [jo, _a].indexOf(i) >= 0 ? {
    x: a,
    y: s
  } : {
    x: s,
    y: a
  };
}
function rj(n) {
  var e = n.state, t = n.options, i = n.name, r = t.offset, o = r === void 0 ? [0, 0] : r, s = oB.reduce(function(c, h) {
    return c[h] = nj(h, e.rects, o), c;
  }, {}), a = s[e.placement], l = a.x, u = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[i] = s;
}
const oj = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: rj
};
function sj(n) {
  var e = n.state, t = n.name;
  e.modifiersData[t] = dB({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
const aj = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: sj,
  data: {}
};
function lj(n) {
  return n === "x" ? "y" : "x";
}
function uj(n) {
  var e = n.state, t = n.options, i = n.name, r = t.mainAxis, o = r === void 0 ? !0 : r, s = t.altAxis, a = s === void 0 ? !1 : s, l = t.boundary, u = t.rootBoundary, c = t.altBoundary, h = t.padding, d = t.tether, f = d === void 0 ? !0 : d, p = t.tetherOffset, g = p === void 0 ? 0 : p, _ = Bv(e, {
    boundary: l,
    rootBoundary: u,
    padding: h,
    altBoundary: c
  }), m = Qa(e.placement), v = Gp(e.placement), C = !v, y = lx(m), w = lj(y), L = e.modifiersData.popperOffsets, S = e.rects.reference, E = e.rects.popper, D = typeof g == "function" ? g(Object.assign({}, e.rects, {
    placement: e.placement
  })) : g, x = typeof D == "number" ? {
    mainAxis: D,
    altAxis: D
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, D), R = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, A = {
    x: 0,
    y: 0
  };
  if (L) {
    if (o) {
      var M, z = y === "y" ? zo : jo, j = y === "y" ? va : _a, $ = y === "y" ? "height" : "width", k = L[y], ae = k + _[z], re = k - _[j], Y = f ? -E[$] / 2 : 0, K = v === Vp ? S[$] : E[$], W = v === Vp ? -E[$] : -S[$], B = e.elements.arrow, U = f && B ? ax(B) : {
        width: 0,
        height: 0
      }, O = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : lB(), N = O[z], I = O[j], V = sv(0, S[$], U[$]), te = C ? S[$] / 2 - Y - V - N - x.mainAxis : K - V - N - x.mainAxis, ue = C ? -S[$] / 2 + Y + V + I + x.mainAxis : W + V + I + x.mainAxis, De = e.elements.arrow && T_(e.elements.arrow), ce = De ? y === "y" ? De.clientTop || 0 : De.clientLeft || 0 : 0, ke = (M = R == null ? void 0 : R[y]) != null ? M : 0, Ie = k + te - ke - ce, $e = k + ue - ke, Ot = sv(f ? Fw(ae, Ie) : ae, k, f ? _d(re, $e) : re);
      L[y] = Ot, A[y] = Ot - k;
    }
    if (a) {
      var It, ti = y === "x" ? zo : jo, ii = y === "x" ? va : _a, lt = L[w], Ui = w === "y" ? "height" : "width", zt = lt + _[ti], Xi = lt - _[ii], Zi = [zo, jo].indexOf(m) !== -1, Si = (It = R == null ? void 0 : R[w]) != null ? It : 0, pt = Zi ? zt : lt - S[Ui] - E[Ui] - Si + x.altAxis, ai = Zi ? lt + S[Ui] + E[Ui] - Si - x.altAxis : Xi, tr = f && Zi ? P9(pt, lt, ai) : sv(f ? pt : zt, lt, f ? ai : Xi);
      L[w] = tr, A[w] = tr - lt;
    }
    e.modifiersData[i] = A;
  }
}
const cj = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: uj,
  requiresIfExists: ["offset"]
};
function hj(n) {
  return {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  };
}
function dj(n) {
  return n === Ca(n) || !Ss(n) ? ux(n) : hj(n);
}
function fj(n) {
  var e = n.getBoundingClientRect(), t = Bp(e.width) / n.offsetWidth || 1, i = Bp(e.height) / n.offsetHeight || 1;
  return t !== 1 || i !== 1;
}
function pj(n, e, t) {
  t === void 0 && (t = !1);
  var i = Ss(e), r = Ss(e) && fj(e), o = ph(e), s = Hp(n, r, t), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !t) && ((Kl(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  hx(o)) && (a = dj(e)), Ss(e) ? (l = Hp(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : o && (l.x = cx(o))), {
    x: s.left + a.scrollLeft - l.x,
    y: s.top + a.scrollTop - l.y,
    width: s.width,
    height: s.height
  };
}
function gj(n) {
  var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), i = [];
  n.forEach(function(o) {
    e.set(o.name, o);
  });
  function r(o) {
    t.add(o.name);
    var s = [].concat(o.requires || [], o.requiresIfExists || []);
    s.forEach(function(a) {
      if (!t.has(a)) {
        var l = e.get(a);
        l && r(l);
      }
    }), i.push(o);
  }
  return n.forEach(function(o) {
    t.has(o.name) || r(o);
  }), i;
}
function mj(n) {
  var e = gj(n);
  return P1.reduce(function(t, i) {
    return t.concat(e.filter(function(r) {
      return r.phase === i;
    }));
  }, []);
}
function vj(n) {
  var e;
  return function() {
    return e || (e = new Promise(function(t) {
      Promise.resolve().then(function() {
        e = void 0, t(n());
      });
    })), e;
  };
}
function yc(n) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
    t[i - 1] = arguments[i];
  return [].concat(t).reduce(function(r, o) {
    return r.replace(/%s/, o);
  }, n);
}
var Mh = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', _j = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', RM = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function Cj(n) {
  n.forEach(function(e) {
    [].concat(Object.keys(e), RM).filter(function(t, i, r) {
      return r.indexOf(t) === i;
    }).forEach(function(t) {
      switch (t) {
        case "name":
          typeof e.name != "string" && console.error(yc(Mh, String(e.name), '"name"', '"string"', '"' + String(e.name) + '"'));
          break;
        case "enabled":
          typeof e.enabled != "boolean" && console.error(yc(Mh, e.name, '"enabled"', '"boolean"', '"' + String(e.enabled) + '"'));
          break;
        case "phase":
          P1.indexOf(e.phase) < 0 && console.error(yc(Mh, e.name, '"phase"', "either " + P1.join(", "), '"' + String(e.phase) + '"'));
          break;
        case "fn":
          typeof e.fn != "function" && console.error(yc(Mh, e.name, '"fn"', '"function"', '"' + String(e.fn) + '"'));
          break;
        case "effect":
          e.effect != null && typeof e.effect != "function" && console.error(yc(Mh, e.name, '"effect"', '"function"', '"' + String(e.fn) + '"'));
          break;
        case "requires":
          e.requires != null && !Array.isArray(e.requires) && console.error(yc(Mh, e.name, '"requires"', '"array"', '"' + String(e.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(e.requiresIfExists) || console.error(yc(Mh, e.name, '"requiresIfExists"', '"array"', '"' + String(e.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + e.name + '" modifier, valid properties are ' + RM.map(function(i) {
            return '"' + i + '"';
          }).join(", ") + '; but "' + t + '" was provided.');
      }
      e.requires && e.requires.forEach(function(i) {
        n.find(function(r) {
          return r.name === i;
        }) == null && console.error(yc(_j, String(e.name), i, i));
      });
    });
  });
}
function yj(n, e) {
  var t = /* @__PURE__ */ new Set();
  return n.filter(function(i) {
    var r = e(i);
    if (!t.has(r))
      return t.add(r), !0;
  });
}
function wj(n) {
  var e = n.reduce(function(t, i) {
    var r = t[i.name];
    return t[i.name] = r ? Object.assign({}, r, i, {
      options: Object.assign({}, r.options, i.options),
      data: Object.assign({}, r.data, i.data)
    }) : i, t;
  }, {});
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}
var TM = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", bj = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", OM = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function xM() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return !e.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function Sj(n) {
  n === void 0 && (n = {});
  var e = n, t = e.defaultModifiers, i = t === void 0 ? [] : t, r = e.defaultOptions, o = r === void 0 ? OM : r;
  return function(a, l, u) {
    u === void 0 && (u = o);
    var c = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, OM, o),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, h = [], d = !1, f = {
      state: c,
      setOptions: function(m) {
        var v = typeof m == "function" ? m(c.options) : m;
        g(), c.options = Object.assign({}, o, c.options, v), c.scrollParents = {
          reference: Id(a) ? av(a) : a.contextElement ? av(a.contextElement) : [],
          popper: av(l)
        };
        var C = mj(wj([].concat(i, c.options.modifiers)));
        if (c.orderedModifiers = C.filter(function(R) {
          return R.enabled;
        }), process.env.NODE_ENV !== "production") {
          var y = yj([].concat(C, c.options.modifiers), function(R) {
            var A = R.name;
            return A;
          });
          if (Cj(y), Qa(c.options.placement) === ES) {
            var w = c.orderedModifiers.find(function(R) {
              var A = R.name;
              return A === "flip";
            });
            w || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var L = tl(l), S = L.marginTop, E = L.marginRight, D = L.marginBottom, x = L.marginLeft;
          [S, E, D, x].some(function(R) {
            return parseFloat(R);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return p(), f.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!d) {
          var m = c.elements, v = m.reference, C = m.popper;
          if (!xM(v, C)) {
            process.env.NODE_ENV !== "production" && console.error(TM);
            return;
          }
          c.rects = {
            reference: pj(v, T_(C), c.options.strategy === "fixed"),
            popper: ax(C)
          }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(R) {
            return c.modifiersData[R.name] = Object.assign({}, R.data);
          });
          for (var y = 0, w = 0; w < c.orderedModifiers.length; w++) {
            if (process.env.NODE_ENV !== "production" && (y += 1, y > 100)) {
              console.error(bj);
              break;
            }
            if (c.reset === !0) {
              c.reset = !1, w = -1;
              continue;
            }
            var L = c.orderedModifiers[w], S = L.fn, E = L.options, D = E === void 0 ? {} : E, x = L.name;
            typeof S == "function" && (c = S({
              state: c,
              options: D,
              name: x,
              instance: f
            }) || c);
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: vj(function() {
        return new Promise(function(_) {
          f.forceUpdate(), _(c);
        });
      }),
      destroy: function() {
        g(), d = !0;
      }
    };
    if (!xM(a, l))
      return process.env.NODE_ENV !== "production" && console.error(TM), f;
    f.setOptions(u).then(function(_) {
      !d && u.onFirstUpdate && u.onFirstUpdate(_);
    });
    function p() {
      c.orderedModifiers.forEach(function(_) {
        var m = _.name, v = _.options, C = v === void 0 ? {} : v, y = _.effect;
        if (typeof y == "function") {
          var w = y({
            state: c,
            name: m,
            instance: f,
            options: C
          }), L = function() {
          };
          h.push(w || L);
        }
      });
    }
    function g() {
      h.forEach(function(_) {
        return _();
      }), h = [];
    }
    return f;
  };
}
var Ej = [U9, aj, H9, x9, oj, ej, cj, k9, ij], Lj = /* @__PURE__ */ Sj({
  defaultModifiers: Ej
}), Dj = typeof Element < "u", Rj = typeof Map == "function", Tj = typeof Set == "function", Oj = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function Xy(n, e) {
  if (n === e)
    return !0;
  if (n && e && typeof n == "object" && typeof e == "object") {
    if (n.constructor !== e.constructor)
      return !1;
    var t, i, r;
    if (Array.isArray(n)) {
      if (t = n.length, t != e.length)
        return !1;
      for (i = t; i-- !== 0; )
        if (!Xy(n[i], e[i]))
          return !1;
      return !0;
    }
    var o;
    if (Rj && n instanceof Map && e instanceof Map) {
      if (n.size !== e.size)
        return !1;
      for (o = n.entries(); !(i = o.next()).done; )
        if (!e.has(i.value[0]))
          return !1;
      for (o = n.entries(); !(i = o.next()).done; )
        if (!Xy(i.value[1], e.get(i.value[0])))
          return !1;
      return !0;
    }
    if (Tj && n instanceof Set && e instanceof Set) {
      if (n.size !== e.size)
        return !1;
      for (o = n.entries(); !(i = o.next()).done; )
        if (!e.has(i.value[0]))
          return !1;
      return !0;
    }
    if (Oj && ArrayBuffer.isView(n) && ArrayBuffer.isView(e)) {
      if (t = n.length, t != e.length)
        return !1;
      for (i = t; i-- !== 0; )
        if (n[i] !== e[i])
          return !1;
      return !0;
    }
    if (n.constructor === RegExp)
      return n.source === e.source && n.flags === e.flags;
    if (n.valueOf !== Object.prototype.valueOf)
      return n.valueOf() === e.valueOf();
    if (n.toString !== Object.prototype.toString)
      return n.toString() === e.toString();
    if (r = Object.keys(n), t = r.length, t !== Object.keys(e).length)
      return !1;
    for (i = t; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(e, r[i]))
        return !1;
    if (Dj && n instanceof Element)
      return !1;
    for (i = t; i-- !== 0; )
      if (!((r[i] === "_owner" || r[i] === "__v" || r[i] === "__o") && n.$$typeof) && !Xy(n[r[i]], e[r[i]]))
        return !1;
    return !0;
  }
  return n !== n && e !== e;
}
var xj = function(e, t) {
  try {
    return Xy(e, t);
  } catch (i) {
    if ((i.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw i;
  }
}, Nj = [], $Ce = function(e, t, i) {
  i === void 0 && (i = {});
  var r = me.useRef(null), o = {
    onFirstUpdate: i.onFirstUpdate,
    placement: i.placement || "bottom",
    strategy: i.strategy || "absolute",
    modifiers: i.modifiers || Nj
  }, s = me.useState({
    styles: {
      popper: {
        position: o.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), a = s[0], l = s[1], u = me.useMemo(function() {
    return {
      name: "updateState",
      enabled: !0,
      phase: "write",
      fn: function(f) {
        var p = f.state, g = Object.keys(p.elements);
        mz.flushSync(function() {
          l({
            styles: _M(g.map(function(_) {
              return [_, p.styles[_] || {}];
            })),
            attributes: _M(g.map(function(_) {
              return [_, p.attributes[_]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []), c = me.useMemo(function() {
    var d = {
      onFirstUpdate: o.onFirstUpdate,
      placement: o.placement,
      strategy: o.strategy,
      modifiers: [].concat(o.modifiers, [u, {
        name: "applyStyles",
        enabled: !1
      }])
    };
    return xj(r.current, d) ? r.current || d : (r.current = d, d);
  }, [o.onFirstUpdate, o.placement, o.strategy, o.modifiers, u]), h = me.useRef();
  return CM(function() {
    h.current && h.current.setOptions(c);
  }, [c]), CM(function() {
    if (!(e == null || t == null)) {
      var d = i.createPopper || Lj, f = d(e, t, c);
      return h.current = f, function() {
        f.destroy(), h.current = null;
      };
    }
  }, [e, t, i.createPopper]), {
    state: h.current ? h.current.state : null,
    styles: a.styles,
    attributes: a.attributes,
    update: h.current ? h.current.update : null,
    forceUpdate: h.current ? h.current.forceUpdate : null
  };
};
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function vp(n) {
  return n == null || n === "" ? null : n;
}
function ge(n, e) {
  return e === void 0 && (e = !1), n != null && (n !== "" || e);
}
function Je(n) {
  return !ge(n);
}
function ms(n) {
  return n == null || n.length === 0;
}
function dx(n) {
  return n != null && typeof n.toString == "function" ? n.toString() : null;
}
function ca(n) {
  if (n !== void 0) {
    if (n === null || n === "")
      return null;
    if (typeof n == "number")
      return isNaN(n) ? void 0 : n;
    var e = parseInt(n, 10);
    return isNaN(e) ? void 0 : e;
  }
}
function Bu(n) {
  if (n !== void 0)
    return n === null || n === "" ? !1 : typeof n == "boolean" ? n : /true/i.test(n);
}
function Ij(n) {
  if (!(n == null || n === ""))
    return n;
}
function Pj(n, e) {
  return n == null && e == null ? !0 : n == null && e != null || n != null && e == null ? !1 : n === e;
}
function Aj(n, e) {
  var t = n ? JSON.stringify(n) : null, i = e ? JSON.stringify(e) : null;
  return t === i;
}
function F1(n, e, t) {
  t === void 0 && (t = !1);
  var i = n == null, r = e == null;
  if (n && n.toNumber && (n = n.toNumber()), e && e.toNumber && (e = e.toNumber()), i && r)
    return 0;
  if (i)
    return -1;
  if (r)
    return 1;
  function o(s, a) {
    return s > a ? 1 : s < a ? -1 : 0;
  }
  if (typeof n != "string" || !t)
    return o(n, e);
  try {
    return n.localeCompare(e);
  } catch {
    return o(n, e);
  }
}
function ef(n) {
  if (n instanceof Set || n instanceof Map) {
    var e = [];
    return n.forEach(function(t) {
      return e.push(t);
    }), e;
  }
  return Object.values(n);
}
const Mj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attrToBoolean: Bu,
  attrToNumber: ca,
  attrToString: Ij,
  defaultComparator: F1,
  exists: ge,
  jsonEquals: Aj,
  makeNull: vp,
  missing: Je,
  missingOrEmpty: ms,
  referenceCompare: Pj,
  toStringOrNull: dx,
  values: ef
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var fB = (
  /** @class */
  function() {
    function n() {
      this.existingKeys = {};
    }
    return n.prototype.addExistingKeys = function(e) {
      for (var t = 0; t < e.length; t++)
        this.existingKeys[e[t]] = !0;
    }, n.prototype.getUniqueKey = function(e, t) {
      e = dx(e);
      for (var i = 0; ; ) {
        var r = void 0;
        if (e ? (r = e, i !== 0 && (r += "_" + i)) : t ? (r = t, i !== 0 && (r += "_" + i)) : r = "" + i, !this.existingKeys[r])
          return this.existingKeys[r] = !0, r;
        i++;
      }
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function pi(n, e) {
  n != null && (Array.isArray(n) ? n.forEach(function(t, i) {
    return e("" + i, t);
  }) : Object.keys(n).forEach(function(t) {
    return e(t, n[t]);
  }));
}
function fx(n) {
  for (var e = {}, t = Object.keys(n), i = 0; i < t.length; i++) {
    var r = t[i], o = n[r];
    e[r] = o;
  }
  return e;
}
function Fj(n) {
  return JSON.parse(JSON.stringify(n));
}
function kw(n, e) {
  if (n) {
    var t = n, i = {};
    return Object.keys(t).forEach(function(r) {
      if (!(e && e.indexOf(r) >= 0)) {
        var o = t[r], s = Up(o) && o.constructor === Object;
        s ? i[r] = kw(o) : i[r] = o;
      }
    }), i;
  }
}
function pB(n, e) {
  return n[e];
}
function gB(n, e, t) {
  n[e] = t;
}
function kj(n, e) {
  for (var t = [], i = 2; i < arguments.length; i++)
    t[i - 2] = arguments[i];
  t.forEach(function(r) {
    return mB(n, e, r);
  });
}
function mB(n, e, t, i) {
  var r = pB(n, t);
  r !== void 0 && gB(e, t, i ? i(r) : r);
}
function vB(n) {
  var e = {};
  return n.filter(function(t) {
    return t != null;
  }).forEach(function(t) {
    Object.keys(t).forEach(function(i) {
      return e[i] = null;
    });
  }), Object.keys(e);
}
function Ja(n) {
  if (!n)
    return [];
  var e = Object;
  if (typeof e.values == "function")
    return e.values(n);
  var t = [];
  for (var i in n)
    n.hasOwnProperty(i) && n.propertyIsEnumerable(i) && t.push(n[i]);
  return t;
}
function ha(n, e, t, i) {
  t === void 0 && (t = !0), i === void 0 && (i = !1), ge(e) && pi(e, function(r, o) {
    var s = n[r];
    if (s !== o) {
      if (i) {
        var a = s == null && o != null;
        if (a) {
          var l = typeof o == "object" && o.constructor === Object, u = l;
          u && (s = {}, n[r] = s);
        }
      }
      Up(o) && Up(s) && !Array.isArray(s) ? ha(s, o, t, i) : (t || o !== void 0) && (n[r] = o);
    }
  });
}
function Wj(n) {
  return Je(n) || Object.keys(n).length === 0;
}
function Vj(n, e, t) {
  if (n == null)
    return t;
  for (var i = e.split("."), r = n; i.length > 1; )
    if (r = r[i.shift()], r == null)
      return t;
  var o = r[i[0]];
  return o ?? t;
}
function Bj(n, e, t) {
  if (n != null) {
    for (var i = e.split("."), r = n; i.length > 1; )
      if (r = r[i.shift()], r == null)
        return;
    r[i[0]] = t;
  }
}
function _B(n) {
  return Object.freeze(n), ef(n).forEach(function(e) {
    (Up(e) || typeof e == "function") && _B(e);
  }), n;
}
function Ww(n, e, t) {
  if (!(!e || !n)) {
    if (!t)
      return n[e];
    for (var i = e.split("."), r = n, o = 0; o < i.length; o++) {
      if (r == null)
        return;
      r = r[i[o]];
    }
    return r;
  }
}
function CB(n, e) {
  Object.keys(n).forEach(function(r) {
    var o = n[r];
    typeof o == "object" && (n[r] = void 0);
  });
  var t = Object.getPrototypeOf(n), i = {};
  Object.keys(t).forEach(function(r) {
    var o = t[r];
    if (typeof o == "function") {
      var s = function() {
        console.warn("AG Grid: " + e + " function " + r + `() cannot be called as the grid has been destroyed.
                     Please don't call grid API functions on destroyed grids - as a matter of fact you shouldn't
                     be keeping the API reference, your application has a memory leak! Remove the API reference
                     when the grid is destroyed.`);
      };
      i[r] = { value: s, writable: !0 };
    }
  }), Object.defineProperties(n, i);
}
function Up(n) {
  return typeof n == "object" && n !== null;
}
const Hj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cloneObject: fx,
  copyPropertiesIfPresent: kj,
  copyPropertyIfPresent: mB,
  deepCloneDefinition: kw,
  deepCloneObject: Fj,
  deepFreeze: _B,
  get: Vj,
  getAllKeysInObjects: vB,
  getAllValuesInObject: Ja,
  getProperty: pB,
  getValueUsingField: Ww,
  isNonNullObject: Up,
  iterateObject: pi,
  mergeDeep: ha,
  missingOrEmptyObject: Wj,
  removeAllReferences: CB,
  set: Bj,
  setProperty: gB
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Gj = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, Uj = /([^\s,]+)/g, NM = {};
function mi(n, e) {
  NM[e] || (n(), NM[e] = !0);
}
function DS(n) {
  if (n.name)
    return n.name;
  var e = /function\s+([^\(]+)/.exec(n.toString());
  return e && e.length === 2 ? e[1].trim() : null;
}
function zj(n) {
  var e = n.toString().replace(Gj, "");
  return e.slice(e.indexOf("(") + 1, e.indexOf(")")).match(Uj) || [];
}
function px(n) {
  return !!(n && n.constructor && n.call && n.apply);
}
function yB(n) {
  wB(n, 400);
}
var sL = [], aL = !1;
function k1(n) {
  sL.push(n), !aL && (aL = !0, window.setTimeout(function() {
    var e = sL.slice();
    sL.length = 0, aL = !1, e.forEach(function(t) {
      return t();
    });
  }, 0));
}
function wB(n, e) {
  e === void 0 && (e = 0), n.length > 0 && window.setTimeout(function() {
    return n.forEach(function(t) {
      return t();
    });
  }, e);
}
function lh(n, e, t) {
  t === void 0 && (t = !1);
  var i;
  return function() {
    for (var r = [], o = 0; o < arguments.length; o++)
      r[o] = arguments[o];
    var s = this, a = t && !i;
    window.clearTimeout(i), i = window.setTimeout(function() {
      i = null, t || n.apply(s, r);
    }, e), a && n.apply(s, r);
  };
}
function bB(n, e, t, i) {
  t === void 0 && (t = 100);
  var r = (/* @__PURE__ */ new Date()).getTime(), o = null, s = !1, a = function() {
    var l = (/* @__PURE__ */ new Date()).getTime() - r > t;
    (n() || l) && (e(), s = !0, o != null && (window.clearInterval(o), o = null), l && i && console.warn(i));
  };
  a(), s || (o = window.setInterval(a, 10));
}
function jj() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  return function(t) {
    return n.reduce(function(i, r) {
      return r(i);
    }, t);
  };
}
function SB(n) {
  n && n();
}
const $j = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  callIfPresent: SB,
  compose: jj,
  debounce: lh,
  doOnce: mi,
  executeAfter: wB,
  executeInAWhile: yB,
  executeNextVMTurn: k1,
  getFunctionName: DS,
  getFunctionParameters: zj,
  isFunction: px,
  waitUntil: bB
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var EB = (
  /** @class */
  function() {
    function n(e, t) {
      if (this.beanWrappers = {}, this.destroyed = !1, !(!e || !e.beanClasses)) {
        this.contextParams = e, this.logger = t, this.logger.log(">> creating ag-Application Context"), this.createBeans();
        var i = this.getBeanInstances();
        this.wireBeans(i), this.logger.log(">> ag-Application Context ready - component is alive");
      }
    }
    return n.prototype.getBeanInstances = function() {
      return ef(this.beanWrappers).map(function(e) {
        return e.beanInstance;
      });
    }, n.prototype.createBean = function(e, t) {
      if (!e)
        throw Error("Can't wire to bean since it is null");
      return this.wireBeans([e], t), e;
    }, n.prototype.wireBeans = function(e, t) {
      this.autoWireBeans(e), this.methodWireBeans(e), this.callLifeCycleMethods(e, "preConstructMethods"), ge(t) && e.forEach(t), this.callLifeCycleMethods(e, "postConstructMethods");
    }, n.prototype.createBeans = function() {
      var e = this;
      this.contextParams.beanClasses.forEach(this.createBeanWrapper.bind(this)), pi(this.beanWrappers, function(i, r) {
        var o;
        r.bean.__agBeanMetaData && r.bean.__agBeanMetaData.autowireMethods && r.bean.__agBeanMetaData.autowireMethods.agConstructor && (o = r.bean.__agBeanMetaData.autowireMethods.agConstructor);
        var s = e.getBeansForParameters(o, r.bean.name), a = Kj(r.bean, s);
        r.beanInstance = a;
      });
      var t = Object.keys(this.beanWrappers).join(", ");
      this.logger.log("created beans: " + t);
    }, n.prototype.createBeanWrapper = function(e) {
      var t = e.__agBeanMetaData;
      if (!t) {
        var i = void 0;
        e.prototype.constructor ? i = DS(e.prototype.constructor) : i = "" + e, console.error("Context item " + i + " is not a bean");
        return;
      }
      var r = {
        bean: e,
        beanInstance: null,
        beanName: t.beanName
      };
      this.beanWrappers[t.beanName] = r;
    }, n.prototype.autoWireBeans = function(e) {
      var t = this;
      e.forEach(function(i) {
        t.forEachMetaDataInHierarchy(i, function(r, o) {
          var s = r.agClassAttributes;
          s && s.forEach(function(a) {
            var l = t.lookupBeanInstance(o, a.beanName, a.optional);
            i[a.attributeName] = l;
          });
        });
      });
    }, n.prototype.methodWireBeans = function(e) {
      var t = this;
      e.forEach(function(i) {
        t.forEachMetaDataInHierarchy(i, function(r, o) {
          pi(r.autowireMethods, function(s, a) {
            if (s !== "agConstructor") {
              var l = t.getBeansForParameters(a, o);
              i[s].apply(i, l);
            }
          });
        });
      });
    }, n.prototype.forEachMetaDataInHierarchy = function(e, t) {
      for (var i = Object.getPrototypeOf(e); i != null; ) {
        var r = i.constructor;
        if (r.hasOwnProperty("__agBeanMetaData")) {
          var o = r.__agBeanMetaData, s = this.getBeanName(r);
          t(o, s);
        }
        i = Object.getPrototypeOf(i);
      }
    }, n.prototype.getBeanName = function(e) {
      if (e.__agBeanMetaData && e.__agBeanMetaData.beanName)
        return e.__agBeanMetaData.beanName;
      var t = e.toString(), i = t.substring(9, t.indexOf("("));
      return i;
    }, n.prototype.getBeansForParameters = function(e, t) {
      var i = this, r = [];
      return e && pi(e, function(o, s) {
        var a = i.lookupBeanInstance(t, s);
        r[Number(o)] = a;
      }), r;
    }, n.prototype.lookupBeanInstance = function(e, t, i) {
      if (i === void 0 && (i = !1), t === "context")
        return this;
      if (this.contextParams.providedBeanInstances && this.contextParams.providedBeanInstances.hasOwnProperty(t))
        return this.contextParams.providedBeanInstances[t];
      var r = this.beanWrappers[t];
      return r ? r.beanInstance : (i || console.error("AG Grid: unable to find bean reference " + t + " while initialising " + e), null);
    }, n.prototype.callLifeCycleMethods = function(e, t) {
      var i = this;
      e.forEach(function(r) {
        return i.callLifeCycleMethodsOnBean(r, t);
      });
    }, n.prototype.callLifeCycleMethodsOnBean = function(e, t, i) {
      var r = {};
      this.forEachMetaDataInHierarchy(e, function(s) {
        var a = s[t];
        a && a.forEach(function(l) {
          l != i && (r[l] = !0);
        });
      });
      var o = Object.keys(r);
      o.forEach(function(s) {
        return e[s]();
      });
    }, n.prototype.getBean = function(e) {
      return this.lookupBeanInstance("getBean", e, !0);
    }, n.prototype.destroy = function() {
      if (!this.destroyed) {
        this.logger.log(">> Shutting down ag-Application Context");
        var e = this.getBeanInstances();
        this.destroyBeans(e), this.contextParams.providedBeanInstances = null, this.destroyed = !0, this.logger.log(">> ag-Application Context shut down - component is dead");
      }
    }, n.prototype.destroyBean = function(e) {
      e && this.destroyBeans([e]);
    }, n.prototype.destroyBeans = function(e) {
      var t = this;
      return e ? (e.forEach(function(i) {
        t.callLifeCycleMethodsOnBean(i, "preDestroyMethods", "destroy");
        var r = i;
        typeof r.destroy == "function" && r.destroy();
      }), []) : [];
    }, n;
  }()
);
function Kj(n, e) {
  var t = [null].concat(e), i = n.bind.apply(n, t);
  return new i();
}
function W1(n, e, t) {
  var i = Pd(n.constructor);
  i.preConstructMethods || (i.preConstructMethods = []), i.preConstructMethods.push(e);
}
function Le(n, e, t) {
  var i = Pd(n.constructor);
  i.postConstructMethods || (i.postConstructMethods = []), i.postConstructMethods.push(e);
}
function To(n, e, t) {
  var i = Pd(n.constructor);
  i.preDestroyMethods || (i.preDestroyMethods = []), i.preDestroyMethods.push(e);
}
function qe(n) {
  return function(e) {
    var t = Pd(e);
    t.beanName = n;
  };
}
function T(n) {
  return function(e, t, i) {
    LB(e, n, !1, e, t, null);
  };
}
function fi(n) {
  return function(e, t, i) {
    LB(e, n, !0, e, t, null);
  };
}
function LB(n, e, t, i, r, o) {
  if (e === null) {
    console.error("AG Grid: Autowired name should not be null");
    return;
  }
  if (typeof o == "number") {
    console.error("AG Grid: Autowired should be on an attribute");
    return;
  }
  var s = Pd(n.constructor);
  s.agClassAttributes || (s.agClassAttributes = []), s.agClassAttributes.push({
    attributeName: r,
    beanName: e,
    optional: t
  });
}
function Eo(n) {
  return function(e, t, i) {
    var r = typeof e == "function" ? e : e.constructor, o;
    if (typeof i == "number") {
      var s = void 0;
      t ? (o = Pd(r), s = t) : (o = Pd(r), s = "agConstructor"), o.autowireMethods || (o.autowireMethods = {}), o.autowireMethods[s] || (o.autowireMethods[s] = {}), o.autowireMethods[s][i] = n;
    }
  };
}
function Pd(n) {
  return n.hasOwnProperty("__agBeanMetaData") || (n.__agBeanMetaData = {}), n.__agBeanMetaData;
}
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var IM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, MC = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, ic = (
  /** @class */
  function() {
    function n() {
      this.allSyncListeners = /* @__PURE__ */ new Map(), this.allAsyncListeners = /* @__PURE__ */ new Map(), this.globalSyncListeners = /* @__PURE__ */ new Set(), this.globalAsyncListeners = /* @__PURE__ */ new Set(), this.asyncFunctionsQueue = [], this.scheduled = !1, this.firedEvents = {};
    }
    return n.prototype.setBeans = function(e, t, i, r) {
      if (r === void 0 && (r = null), this.frameworkOverrides = i, r) {
        var o = t.useAsyncEvents();
        this.addGlobalListener(r, o);
      }
    }, n.prototype.getListeners = function(e, t, i) {
      var r = t ? this.allAsyncListeners : this.allSyncListeners, o = r.get(e);
      return !o && i && (o = /* @__PURE__ */ new Set(), r.set(e, o)), o;
    }, n.prototype.noRegisteredListenersExist = function() {
      return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
    }, n.prototype.addEventListener = function(e, t, i) {
      i === void 0 && (i = !1), this.getListeners(e, i, !0).add(t);
    }, n.prototype.removeEventListener = function(e, t, i) {
      i === void 0 && (i = !1);
      var r = this.getListeners(e, i, !1);
      if (r && (r.delete(t), r.size === 0)) {
        var o = i ? this.allAsyncListeners : this.allSyncListeners;
        o.delete(e);
      }
    }, n.prototype.addGlobalListener = function(e, t) {
      t === void 0 && (t = !1), (t ? this.globalAsyncListeners : this.globalSyncListeners).add(e);
    }, n.prototype.removeGlobalListener = function(e, t) {
      t === void 0 && (t = !1), (t ? this.globalAsyncListeners : this.globalSyncListeners).delete(e);
    }, n.prototype.dispatchEvent = function(e) {
      this.dispatchToListeners(e, !0), this.dispatchToListeners(e, !1), this.firedEvents[e.type] = !0;
    }, n.prototype.dispatchEventOnce = function(e) {
      this.firedEvents[e.type] || this.dispatchEvent(e);
    }, n.prototype.dispatchToListeners = function(e, t) {
      var i = this, r = e.type, o = function(l) {
        return l.forEach(function(u) {
          t ? i.dispatchAsync(function() {
            return u(e);
          }) : u(e);
        });
      }, s = this.getListeners(r, t, !1);
      s && o(s);
      var a = t ? this.globalAsyncListeners : this.globalSyncListeners;
      a.forEach(function(l) {
        t ? i.dispatchAsync(function() {
          return i.frameworkOverrides.dispatchEvent(r, function() {
            return l(r, e);
          }, !0);
        }) : i.frameworkOverrides.dispatchEvent(r, function() {
          return l(r, e);
        }, !0);
      });
    }, n.prototype.dispatchAsync = function(e) {
      this.asyncFunctionsQueue.push(e), this.scheduled || (window.setTimeout(this.flushAsyncQueue.bind(this), 0), this.scheduled = !0);
    }, n.prototype.flushAsyncQueue = function() {
      this.scheduled = !1;
      var e = this.asyncFunctionsQueue.slice();
      this.asyncFunctionsQueue = [], e.forEach(function(t) {
        return t();
      });
    }, IM([
      MC(0, Eo("loggerFactory")),
      MC(1, Eo("gridOptionsWrapper")),
      MC(2, Eo("frameworkOverrides")),
      MC(3, Eo("globalEventListener"))
    ], n.prototype, "setBeans", null), n = IM([
      qe("eventService")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Z = (
  /** @class */
  function() {
    function n() {
    }
    return n.ROW_BUFFER_SIZE = 10, n.LAYOUT_INTERVAL = 500, n.BATCH_WAIT_MILLIS = 50, n.EXPORT_TYPE_DRAG_COPY = "dragCopy", n.EXPORT_TYPE_CLIPBOARD = "clipboard", n.EXPORT_TYPE_EXCEL = "excel", n.EXPORT_TYPE_CSV = "csv", n.ROW_MODEL_TYPE_INFINITE = "infinite", n.ROW_MODEL_TYPE_VIEWPORT = "viewport", n.ROW_MODEL_TYPE_CLIENT_SIDE = "clientSide", n.ROW_MODEL_TYPE_SERVER_SIDE = "serverSide", n.ALWAYS = "always", n.ONLY_WHEN_GROUPING = "onlyWhenGrouping", n.PINNED_TOP = "top", n.PINNED_BOTTOM = "bottom", n.DOM_LAYOUT_NORMAL = "normal", n.DOM_LAYOUT_PRINT = "print", n.DOM_LAYOUT_AUTO_HEIGHT = "autoHeight", n.GROUP_AUTO_COLUMN_ID = "ag-Grid-AutoColumn", n.SOURCE_PASTE = "paste", n.PINNED_RIGHT = "right", n.PINNED_LEFT = "left", n.SORT_ASC = "asc", n.SORT_DESC = "desc", n.INPUT_SELECTOR = "input, select, button, textarea", n.FOCUSABLE_SELECTOR = "[tabindex], input, select, button, textarea", n.FOCUSABLE_EXCLUDE = ".ag-hidden, .ag-hidden *, [disabled], .ag-disabled, .ag-disabled *", n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var ht;
(function(n) {
  n.CommunityCoreModule = "@ag-grid-community/core", n.CommunityAllModules = "@ag-grid-community/all", n.InfiniteRowModelModule = "@ag-grid-community/infinite-row-model", n.ClientSideRowModelModule = "@ag-grid-community/client-side-row-model", n.CsvExportModule = "@ag-grid-community/csv-export", n.EnterpriseCoreModule = "@ag-grid-enterprise/core", n.EnterpriseAllModules = "@ag-grid-enterprise/all", n.RowGroupingModule = "@ag-grid-enterprise/row-grouping", n.ColumnToolPanelModule = "@ag-grid-enterprise/column-tool-panel", n.FiltersToolPanelModule = "@ag-grid-enterprise/filter-tool-panel", n.MenuModule = "@ag-grid-enterprise/menu", n.SetFilterModule = "@ag-grid-enterprise/set-filter", n.MultiFilterModule = "@ag-grid-enterprise/multi-filter", n.StatusBarModule = "@ag-grid-enterprise/status-bar", n.SideBarModule = "@ag-grid-enterprise/side-bar", n.RangeSelectionModule = "@ag-grid-enterprise/range-selection", n.MasterDetailModule = "@ag-grid-enterprise/master-detail", n.RichSelectModule = "@ag-grid-enterprise/rich-select", n.GridChartsModule = "@ag-grid-enterprise/charts", n.ViewportRowModelModule = "@ag-grid-enterprise/viewport-row-model", n.ServerSideRowModelModule = "@ag-grid-enterprise/server-side-row-model", n.ExcelExportModule = "@ag-grid-enterprise/excel-export", n.ClipboardModule = "@ag-grid-enterprise/clipboard", n.SparklinesModule = "@ag-grid-enterprise/sparklines", n.AngularModule = "@ag-grid-community/angular", n.ReactModule = "@ag-grid-community/react", n.VueModule = "@ag-grid-community/vue", n.PolymerModule = "@ag-grid-community/polymer";
})(ht || (ht = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gt = (
  /** @class */
  function() {
    function n() {
    }
    return n.register = function(e, t) {
      t === void 0 && (t = !0), n.modulesMap[e.moduleName] = e, n.moduleBased === void 0 ? n.moduleBased = t : n.moduleBased !== t && mi(function() {
        console.warn("AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms."), console.warn("Please see https://www.ag-grid.com/javascript-grid/packages-modules/ for more information.");
      }, "ModulePackageCheck");
    }, n.registerModules = function(e, t) {
      t === void 0 && (t = !0), e && e.forEach(function(i) {
        return n.register(i, t);
      });
    }, n.assertRegistered = function(e, t) {
      if (this.isRegistered(e))
        return !0;
      var i = t + e, r;
      return n.moduleBased ? r = "AG Grid: unable to use " + t + " as module " + e + " is not present. Please see: https://www.ag-grid.com/javascript-grid/modules/" : r = "AG Grid: unable to use " + t + " as package 'ag-grid-enterprise' is not present. Please see: https://www.ag-grid.com/javascript-grid/packages/", mi(function() {
        console.warn(r);
      }, i), !1;
    }, n.isRegistered = function(e) {
      return !!n.modulesMap[e];
    }, n.getRegisteredModules = function() {
      return ef(n.modulesMap);
    }, n.isPackageBased = function() {
      return !n.moduleBased;
    }, n.modulesMap = {}, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var bf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, qj = 0, Gt = (
  /** @class */
  function() {
    function n(e, t, i, r) {
      this.instanceId = qj++, this.moving = !1, this.menuVisible = !1, this.filterActive = !1, this.eventService = new ic(), this.rowGroupActive = !1, this.pivotActive = !1, this.aggregationActive = !1, this.colDef = e, this.userProvidedColDef = t, this.colId = i, this.primary = r, this.setState(e);
    }
    return n.prototype.getInstanceId = function() {
      return this.instanceId;
    }, n.prototype.setState = function(e) {
      e.sort !== void 0 ? (e.sort === Z.SORT_ASC || e.sort === Z.SORT_DESC) && (this.sort = e.sort) : (e.initialSort === Z.SORT_ASC || e.initialSort === Z.SORT_DESC) && (this.sort = e.initialSort);
      var t = ca(e.sortIndex), i = ca(e.initialSortIndex);
      t !== void 0 ? t !== null && (this.sortIndex = t) : i !== null && (this.sortIndex = i);
      var r = Bu(e.hide), o = Bu(e.initialHide);
      r !== void 0 ? this.visible = !r : this.visible = !o, e.pinned !== void 0 ? this.setPinned(e.pinned) : this.setPinned(e.initialPinned);
      var s = ca(e.flex), a = ca(e.initialFlex);
      s !== void 0 ? this.flex = s : a !== void 0 && (this.flex = a);
    }, n.prototype.setColDef = function(e, t) {
      this.colDef = e, this.userProvidedColDef = t, this.initMinAndMaxWidths(), this.initDotNotation();
    }, n.prototype.getUserProvidedColDef = function() {
      return this.userProvidedColDef;
    }, n.prototype.setParent = function(e) {
      this.parent = e;
    }, n.prototype.getParent = function() {
      return this.parent;
    }, n.prototype.setOriginalParent = function(e) {
      this.originalParent = e;
    }, n.prototype.getOriginalParent = function() {
      return this.originalParent;
    }, n.prototype.initialise = function() {
      this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.validate();
    }, n.prototype.initDotNotation = function() {
      var e = this.gridOptionsWrapper.isSuppressFieldDotNotation();
      this.fieldContainsDots = ge(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !e, this.tooltipFieldContainsDots = ge(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !e;
    }, n.prototype.initMinAndMaxWidths = function() {
      var e = this.colDef;
      this.minWidth = this.columnUtils.calculateColMinWidth(e), this.maxWidth = this.columnUtils.calculateColMaxWidth(e);
    }, n.prototype.resetActualWidth = function(e) {
      e === void 0 && (e = "api");
      var t = this.columnUtils.calculateColInitialWidth(this.colDef);
      this.setActualWidth(t, e, !0);
    }, n.prototype.isEmptyGroup = function() {
      return !1;
    }, n.prototype.isRowGroupDisplayed = function(e) {
      if (Je(this.colDef) || Je(this.colDef.showRowGroup))
        return !1;
      var t = this.colDef.showRowGroup === !0, i = this.colDef.showRowGroup === e;
      return t || i;
    }, n.prototype.isPrimary = function() {
      return this.primary;
    }, n.prototype.isFilterAllowed = function() {
      var e = !!this.colDef.filter || !!this.colDef.filterFramework;
      return this.primary && e;
    }, n.prototype.isFieldContainsDots = function() {
      return this.fieldContainsDots;
    }, n.prototype.isTooltipFieldContainsDots = function() {
      return this.tooltipFieldContainsDots;
    }, n.prototype.validate = function() {
      var e = this.colDef;
      function t(s, a, l) {
        mi(function() {
          l ? console.warn(s, l) : mi(function() {
            return console.warn(s);
          }, a);
        }, a);
      }
      var i = this.gridOptionsWrapper.isRowModelDefault();
      if (i && !gt.isRegistered(ht.RowGroupingModule)) {
        var r = ["enableRowGroup", "rowGroup", "rowGroupIndex", "enablePivot", "enableValue", "pivot", "pivotIndex", "aggFunc"];
        r.forEach(function(s) {
          ge(e[s]) && (gt.isPackageBased() ? t("AG Grid: " + s + " is only valid in ag-grid-enterprise, your column definition should not have " + s, "ColumnRowGroupingMissing" + s) : t("AG Grid: " + s + " is only valid with AG Grid Enterprise Module " + ht.RowGroupingModule + " - your column definition should not have " + s, "ColumnRowGroupingMissing" + s));
        });
      }
      if (gt.isRegistered(ht.RichSelectModule) || this.colDef.cellEditor === "agRichSelect" && (gt.isPackageBased() ? t("AG Grid: " + this.colDef.cellEditor + " can only be used with ag-grid-enterprise", "ColumnRichSelectMissing") : t("AG Grid: " + this.colDef.cellEditor + " can only be used with AG Grid Enterprise Module " + ht.RichSelectModule, "ColumnRichSelectMissing")), this.gridOptionsWrapper.isTreeData()) {
        var o = ["rowGroup", "rowGroupIndex", "pivot", "pivotIndex"];
        o.forEach(function(s) {
          ge(e[s]) && t("AG Grid: " + s + " is not possible when doing tree data, your column definition should not have " + s, "TreeDataCannotRowGroup");
        });
      }
      ge(this.colDef.width) && typeof this.colDef.width != "number" && t("AG Grid: colDef.width should be a number, not " + typeof this.colDef.width, "ColumnCheck_asdfawef"), e.pinnedRowCellRenderer && t("AG Grid: pinnedRowCellRenderer no longer exists, use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned. This was an unfortunate (but necessary) change we had to do to allow future plans we have of re-skinng the data grid in frameworks such as React, Angular and Vue. See https://www.ag-grid.com/javascript-grid/cell-rendering/#many-renderers-one-column", "colDef.pinnedRowCellRenderer-deprecated"), e.pinnedRowCellRendererParams && t("AG Grid: pinnedRowCellRenderer no longer exists, use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned. This was an unfortunate (but necessary) change we had to do to allow future plans we have of re-skinng the data grid in frameworks such as React, Angular and Vue. See https://www.ag-grid.com/javascript-grid/cell-rendering/#many-renderers-one-column", "colDef.pinnedRowCellRenderer-deprecated"), e.pinnedRowCellRendererFramework && t("AG Grid: pinnedRowCellRenderer no longer exists, use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned. This was an unfortunate (but necessary) change we had to do to allow future plans we have of re-skinng the data grid in frameworks such as React, Angular and Vue. See https://www.ag-grid.com/javascript-grid/cell-rendering/#many-renderers-one-column", "colDef.pinnedRowCellRenderer-deprecated"), e.pinnedRowValueGetter && t("AG Grid: pinnedRowCellRenderer is deprecated, use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned. This was an unfortunate (but necessary) change we had to do to allow future plans we have of re-skinng the data grid in frameworks such as React, Angular and Vue.", "colDef.pinnedRowCellRenderer-deprecated");
    }, n.prototype.addEventListener = function(e, t) {
      this.eventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.eventService.removeEventListener(e, t);
    }, n.prototype.createColumnFunctionCallbackParams = function(e) {
      return {
        node: e,
        data: e.data,
        column: this,
        colDef: this.colDef,
        context: this.gridOptionsWrapper.getContext(),
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi()
      };
    }, n.prototype.isSuppressNavigable = function(e) {
      if (typeof this.colDef.suppressNavigable == "boolean")
        return this.colDef.suppressNavigable;
      if (typeof this.colDef.suppressNavigable == "function") {
        var t = this.createColumnFunctionCallbackParams(e), i = this.colDef.suppressNavigable;
        return i(t);
      }
      return !1;
    }, n.prototype.isCellEditable = function(e) {
      return e.group && !this.gridOptionsWrapper.isEnableGroupEdit() ? !1 : this.isColumnFunc(e, this.colDef.editable);
    }, n.prototype.isSuppressFillHandle = function() {
      return !!Bu(this.colDef.suppressFillHandle);
    }, n.prototype.isAutoHeight = function() {
      return !!Bu(this.colDef.autoHeight);
    }, n.prototype.isRowDrag = function(e) {
      return this.isColumnFunc(e, this.colDef.rowDrag);
    }, n.prototype.isDndSource = function(e) {
      return this.isColumnFunc(e, this.colDef.dndSource);
    }, n.prototype.isCellCheckboxSelection = function(e) {
      return this.isColumnFunc(e, this.colDef.checkboxSelection);
    }, n.prototype.isSuppressPaste = function(e) {
      return this.isColumnFunc(e, this.colDef ? this.colDef.suppressPaste : null);
    }, n.prototype.isResizable = function() {
      return !!Bu(this.colDef.resizable);
    }, n.prototype.isColumnFunc = function(e, t) {
      if (typeof t == "boolean")
        return t;
      if (typeof t == "function") {
        var i = this.createColumnFunctionCallbackParams(e), r = t;
        return r(i);
      }
      return !1;
    }, n.prototype.setMoving = function(e, t) {
      t === void 0 && (t = "api"), this.moving = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_MOVING_CHANGED, t));
    }, n.prototype.createColumnEvent = function(e, t) {
      return {
        api: this.gridApi,
        columnApi: this.columnApi,
        type: e,
        column: this,
        columns: [this],
        source: t
      };
    }, n.prototype.isMoving = function() {
      return this.moving;
    }, n.prototype.getSort = function() {
      return this.sort;
    }, n.prototype.setSort = function(e, t) {
      t === void 0 && (t = "api"), this.sort !== e && (this.sort = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_SORT_CHANGED, t)));
    }, n.prototype.setMenuVisible = function(e, t) {
      t === void 0 && (t = "api"), this.menuVisible !== e && (this.menuVisible = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_MENU_VISIBLE_CHANGED, t)));
    }, n.prototype.isMenuVisible = function() {
      return this.menuVisible;
    }, n.prototype.isSortAscending = function() {
      return this.sort === Z.SORT_ASC;
    }, n.prototype.isSortDescending = function() {
      return this.sort === Z.SORT_DESC;
    }, n.prototype.isSortNone = function() {
      return Je(this.sort);
    }, n.prototype.isSorting = function() {
      return ge(this.sort);
    }, n.prototype.getSortIndex = function() {
      return this.sortIndex;
    }, n.prototype.setSortIndex = function(e) {
      this.sortIndex = e;
    }, n.prototype.setAggFunc = function(e) {
      this.aggFunc = e;
    }, n.prototype.getAggFunc = function() {
      return this.aggFunc;
    }, n.prototype.getLeft = function() {
      return this.left;
    }, n.prototype.getOldLeft = function() {
      return this.oldLeft;
    }, n.prototype.getRight = function() {
      return this.left + this.actualWidth;
    }, n.prototype.setLeft = function(e, t) {
      t === void 0 && (t = "api"), this.oldLeft = this.left, this.left !== e && (this.left = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_LEFT_CHANGED, t)));
    }, n.prototype.isFilterActive = function() {
      return this.filterActive;
    }, n.prototype.setFilterActive = function(e, t, i) {
      t === void 0 && (t = "api"), this.filterActive !== e && (this.filterActive = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_FILTER_ACTIVE_CHANGED, t)));
      var r = this.createColumnEvent(n.EVENT_FILTER_CHANGED, t);
      i && ha(r, i), this.eventService.dispatchEvent(r);
    }, n.prototype.setPinned = function(e) {
      e === !0 || e === Z.PINNED_LEFT ? this.pinned = Z.PINNED_LEFT : e === Z.PINNED_RIGHT ? this.pinned = Z.PINNED_RIGHT : this.pinned = null;
    }, n.prototype.setFirstRightPinned = function(e, t) {
      t === void 0 && (t = "api"), this.firstRightPinned !== e && (this.firstRightPinned = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_FIRST_RIGHT_PINNED_CHANGED, t)));
    }, n.prototype.setLastLeftPinned = function(e, t) {
      t === void 0 && (t = "api"), this.lastLeftPinned !== e && (this.lastLeftPinned = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_LAST_LEFT_PINNED_CHANGED, t)));
    }, n.prototype.isFirstRightPinned = function() {
      return this.firstRightPinned;
    }, n.prototype.isLastLeftPinned = function() {
      return this.lastLeftPinned;
    }, n.prototype.isPinned = function() {
      return this.pinned === Z.PINNED_LEFT || this.pinned === Z.PINNED_RIGHT;
    }, n.prototype.isPinnedLeft = function() {
      return this.pinned === Z.PINNED_LEFT;
    }, n.prototype.isPinnedRight = function() {
      return this.pinned === Z.PINNED_RIGHT;
    }, n.prototype.getPinned = function() {
      return this.pinned;
    }, n.prototype.setVisible = function(e, t) {
      t === void 0 && (t = "api");
      var i = e === !0;
      this.visible !== i && (this.visible = i, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_VISIBLE_CHANGED, t)));
    }, n.prototype.isVisible = function() {
      return this.visible;
    }, n.prototype.getColDef = function() {
      return this.colDef;
    }, n.prototype.getColumnGroupShow = function() {
      return this.colDef.columnGroupShow;
    }, n.prototype.getColId = function() {
      return this.colId;
    }, n.prototype.getId = function() {
      return this.getColId();
    }, n.prototype.getUniqueId = function() {
      return this.getId();
    }, n.prototype.getDefinition = function() {
      return this.colDef;
    }, n.prototype.getActualWidth = function() {
      return this.actualWidth;
    }, n.prototype.createBaseColDefParams = function(e) {
      var t = {
        node: e,
        data: e.data,
        colDef: this.colDef,
        column: this,
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        context: this.gridOptionsWrapper.getContext()
      };
      return t;
    }, n.prototype.getColSpan = function(e) {
      if (Je(this.colDef.colSpan))
        return 1;
      var t = this.createBaseColDefParams(e), i = this.colDef.colSpan(t);
      return Math.max(i, 1);
    }, n.prototype.getRowSpan = function(e) {
      if (Je(this.colDef.rowSpan))
        return 1;
      var t = this.createBaseColDefParams(e), i = this.colDef.rowSpan(t);
      return Math.max(i, 1);
    }, n.prototype.setActualWidth = function(e, t, i) {
      t === void 0 && (t = "api"), i === void 0 && (i = !1), this.minWidth != null && (e = Math.max(e, this.minWidth)), this.maxWidth != null && (e = Math.min(e, this.maxWidth)), this.actualWidth !== e && (this.actualWidth = e, this.flex && t !== "flex" && t !== "gridInitializing" && (this.flex = null), i || this.fireColumnWidthChangedEvent(t));
    }, n.prototype.fireColumnWidthChangedEvent = function(e) {
      this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_WIDTH_CHANGED, e));
    }, n.prototype.isGreaterThanMax = function(e) {
      return this.maxWidth != null ? e > this.maxWidth : !1;
    }, n.prototype.getMinWidth = function() {
      return this.minWidth;
    }, n.prototype.getMaxWidth = function() {
      return this.maxWidth;
    }, n.prototype.getFlex = function() {
      return this.flex || 0;
    }, n.prototype.setFlex = function(e) {
      this.flex !== e && (this.flex = e);
    }, n.prototype.setMinimum = function(e) {
      e === void 0 && (e = "api"), ge(this.minWidth) && this.setActualWidth(this.minWidth, e);
    }, n.prototype.setRowGroupActive = function(e, t) {
      t === void 0 && (t = "api"), this.rowGroupActive !== e && (this.rowGroupActive = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_ROW_GROUP_CHANGED, t)));
    }, n.prototype.isRowGroupActive = function() {
      return this.rowGroupActive;
    }, n.prototype.setPivotActive = function(e, t) {
      t === void 0 && (t = "api"), this.pivotActive !== e && (this.pivotActive = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_PIVOT_CHANGED, t)));
    }, n.prototype.isPivotActive = function() {
      return this.pivotActive;
    }, n.prototype.isAnyFunctionActive = function() {
      return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
    }, n.prototype.isAnyFunctionAllowed = function() {
      return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
    }, n.prototype.setValueActive = function(e, t) {
      t === void 0 && (t = "api"), this.aggregationActive !== e && (this.aggregationActive = e, this.eventService.dispatchEvent(this.createColumnEvent(n.EVENT_VALUE_CHANGED, t)));
    }, n.prototype.isValueActive = function() {
      return this.aggregationActive;
    }, n.prototype.isAllowPivot = function() {
      return this.colDef.enablePivot === !0;
    }, n.prototype.isAllowValue = function() {
      return this.colDef.enableValue === !0;
    }, n.prototype.isAllowRowGroup = function() {
      return this.colDef.enableRowGroup === !0;
    }, n.prototype.getMenuTabs = function(e) {
      var t = this.getColDef().menuTabs;
      return t == null && (t = e), t;
    }, n.prototype.isLockPosition = function() {
      return console.warn("AG Grid: since v21, col.isLockPosition() should not be used, please use col.getColDef().lockPosition instead."), this.colDef ? !!this.colDef.lockPosition : !1;
    }, n.prototype.isLockVisible = function() {
      return console.warn("AG Grid: since v21, col.isLockVisible() should not be used, please use col.getColDef().lockVisible instead."), this.colDef ? !!this.colDef.lockVisible : !1;
    }, n.prototype.isLockPinned = function() {
      return console.warn("AG Grid: since v21, col.isLockPinned() should not be used, please use col.getColDef().lockPinned instead."), this.colDef ? !!this.colDef.lockPinned : !1;
    }, n.EVENT_MOVING_CHANGED = "movingChanged", n.EVENT_LEFT_CHANGED = "leftChanged", n.EVENT_WIDTH_CHANGED = "widthChanged", n.EVENT_LAST_LEFT_PINNED_CHANGED = "lastLeftPinnedChanged", n.EVENT_FIRST_RIGHT_PINNED_CHANGED = "firstRightPinnedChanged", n.EVENT_VISIBLE_CHANGED = "visibleChanged", n.EVENT_FILTER_CHANGED = "filterChanged", n.EVENT_FILTER_ACTIVE_CHANGED = "filterActiveChanged", n.EVENT_SORT_CHANGED = "sortChanged", n.EVENT_MENU_VISIBLE_CHANGED = "menuVisibleChanged", n.EVENT_ROW_GROUP_CHANGED = "columnRowGroupChanged", n.EVENT_PIVOT_CHANGED = "columnPivotChanged", n.EVENT_VALUE_CHANGED = "columnValueChanged", bf([
      T("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), bf([
      T("columnUtils")
    ], n.prototype, "columnUtils", void 0), bf([
      T("columnApi")
    ], n.prototype, "columnApi", void 0), bf([
      T("gridApi")
    ], n.prototype, "gridApi", void 0), bf([
      T("context")
    ], n.prototype, "context", void 0), bf([
      Le
    ], n.prototype, "initialise", null), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function DB() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  for (var t = 0; t < n.length; t++) {
    var i = n[t];
    if (ge(i))
      return i;
  }
  return null;
}
function Yj(n) {
  return n != null && n.length > 0;
}
function Ti(n) {
  if (!(!n || !n.length))
    return n[n.length - 1];
}
function Cd(n, e, t) {
  return n == null && e == null ? !0 : n != null && e != null && n.length === e.length && n.every(function(i, r) {
    return t ? t(i, e[r]) : e[r] === i;
  });
}
function Xj(n, e) {
  return Cd(n, e);
}
function Zj(n, e) {
  return Cd(n, e);
}
function RB(n) {
  return n.sort(function(e, t) {
    return e - t;
  });
}
function Qj(n, e) {
  if (n)
    for (var t = n.length - 2; t >= 0; t--) {
      var i = n[t] === e, r = n[t + 1] === e;
      i && r && n.splice(t + 1, 1);
    }
}
function Zr(n, e) {
  var t = n.indexOf(e);
  t >= 0 && n.splice(t, 1);
}
function gx(n, e) {
  e.forEach(function(t) {
    return Zr(n, t);
  });
}
function Hv(n, e, t) {
  n.splice(t, 0, e);
}
function Jj(n, e, t) {
  if (!(n == null || e == null))
    for (var i = e.length - 1; i >= 0; i--) {
      var r = e[i];
      Hv(n, r, t);
    }
}
function V1(n, e, t) {
  gx(n, e), e.slice().reverse().forEach(function(i) {
    return Hv(n, i, t);
  });
}
function Es(n, e) {
  return n.indexOf(e) > -1;
}
function e$(n) {
  return [].concat.apply([], n);
}
function B1(n, e) {
  e == null || n == null || e.forEach(function(t) {
    return n.push(t);
  });
}
function t$(n) {
  return n.map(dx);
}
function i$(n, e) {
  if (n != null)
    for (var t = n.length - 1; t >= 0; t--)
      e(n[t], t);
}
const n$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  areEqual: Cd,
  compareArrays: Xj,
  existsAndNotEmpty: Yj,
  firstExistingValue: DB,
  flatten: e$,
  forEachReverse: i$,
  includes: Es,
  insertArrayIntoArray: Jj,
  insertIntoArray: Hv,
  last: Ti,
  moveInArray: V1,
  pushAll: B1,
  removeAllFromArray: gx,
  removeFromArray: Zr,
  removeRepeatsFromArray: Qj,
  shallowCompare: Zj,
  sortNumerically: RB,
  toStrings: t$
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var r$ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Qr = (
  /** @class */
  function() {
    function n(e, t, i, r) {
      this.displayedChildren = [], this.localEventService = new ic(), this.groupId = t, this.instanceId = i, this.providedColumnGroup = e, this.pinned = r;
    }
    return n.createUniqueId = function(e, t) {
      return e + "_" + t;
    }, n.prototype.reset = function() {
      this.parent = null, this.children = null, this.displayedChildren = null;
    }, n.prototype.getParent = function() {
      return this.parent;
    }, n.prototype.setParent = function(e) {
      this.parent = e;
    }, n.prototype.getUniqueId = function() {
      return n.createUniqueId(this.groupId, this.instanceId);
    }, n.prototype.isEmptyGroup = function() {
      return this.displayedChildren.length === 0;
    }, n.prototype.isMoving = function() {
      var e = this.getProvidedColumnGroup().getLeafColumns();
      return !e || e.length === 0 ? !1 : e.every(function(t) {
        return t.isMoving();
      });
    }, n.prototype.checkLeft = function() {
      if (this.displayedChildren.forEach(function(r) {
        r instanceof n && r.checkLeft();
      }), this.displayedChildren.length > 0)
        if (this.gridOptionsWrapper.isEnableRtl()) {
          var e = Ti(this.displayedChildren), t = e.getLeft();
          this.setLeft(t);
        } else {
          var i = this.displayedChildren[0].getLeft();
          this.setLeft(i);
        }
      else
        this.setLeft(null);
    }, n.prototype.getLeft = function() {
      return this.left;
    }, n.prototype.getOldLeft = function() {
      return this.oldLeft;
    }, n.prototype.setLeft = function(e) {
      this.oldLeft = e, this.left !== e && (this.left = e, this.localEventService.dispatchEvent(this.createAgEvent(n.EVENT_LEFT_CHANGED)));
    }, n.prototype.getPinned = function() {
      return this.pinned;
    }, n.prototype.createAgEvent = function(e) {
      return { type: e };
    }, n.prototype.addEventListener = function(e, t) {
      this.localEventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.localEventService.removeEventListener(e, t);
    }, n.prototype.getGroupId = function() {
      return this.groupId;
    }, n.prototype.getInstanceId = function() {
      return this.instanceId;
    }, n.prototype.isChildInThisGroupDeepSearch = function(e) {
      var t = !1;
      return this.children.forEach(function(i) {
        e === i && (t = !0), i instanceof n && i.isChildInThisGroupDeepSearch(e) && (t = !0);
      }), t;
    }, n.prototype.getActualWidth = function() {
      var e = 0;
      return this.displayedChildren && this.displayedChildren.forEach(function(t) {
        e += t.getActualWidth();
      }), e;
    }, n.prototype.isResizable = function() {
      if (!this.displayedChildren)
        return !1;
      var e = !1;
      return this.displayedChildren.forEach(function(t) {
        t.isResizable() && (e = !0);
      }), e;
    }, n.prototype.getMinWidth = function() {
      var e = 0;
      return this.displayedChildren.forEach(function(t) {
        e += t.getMinWidth() || 0;
      }), e;
    }, n.prototype.addChild = function(e) {
      this.children || (this.children = []), this.children.push(e);
    }, n.prototype.getDisplayedChildren = function() {
      return this.displayedChildren;
    }, n.prototype.getLeafColumns = function() {
      var e = [];
      return this.addLeafColumns(e), e;
    }, n.prototype.getDisplayedLeafColumns = function() {
      var e = [];
      return this.addDisplayedLeafColumns(e), e;
    }, n.prototype.getDefinition = function() {
      return this.providedColumnGroup.getColGroupDef();
    }, n.prototype.getColGroupDef = function() {
      return this.providedColumnGroup.getColGroupDef();
    }, n.prototype.isPadding = function() {
      return this.providedColumnGroup.isPadding();
    }, n.prototype.isExpandable = function() {
      return this.providedColumnGroup.isExpandable();
    }, n.prototype.isExpanded = function() {
      return this.providedColumnGroup.isExpanded();
    }, n.prototype.setExpanded = function(e) {
      this.providedColumnGroup.setExpanded(e);
    }, n.prototype.addDisplayedLeafColumns = function(e) {
      this.displayedChildren.forEach(function(t) {
        t instanceof Gt ? e.push(t) : t instanceof n && t.addDisplayedLeafColumns(e);
      });
    }, n.prototype.addLeafColumns = function(e) {
      this.children.forEach(function(t) {
        t instanceof Gt ? e.push(t) : t instanceof n && t.addLeafColumns(e);
      });
    }, n.prototype.getChildren = function() {
      return this.children;
    }, n.prototype.getColumnGroupShow = function() {
      return this.providedColumnGroup.getColumnGroupShow();
    }, n.prototype.getProvidedColumnGroup = function() {
      return this.providedColumnGroup;
    }, n.prototype.getOriginalColumnGroup = function() {
      return console.warn("AG Grid: columnGroup.getOriginalColumnGroup() is deprecated due to a method rename, use columnGroup.getProvidedColumnGroup() instead"), this.getProvidedColumnGroup();
    }, n.prototype.getPaddingLevel = function() {
      var e = this.getParent();
      return !this.isPadding() || !e || !e.isPadding() ? 0 : 1 + e.getPaddingLevel();
    }, n.prototype.calculateDisplayedColumns = function() {
      var e = this;
      this.displayedChildren = [];
      for (var t = this; t != null && t.isPadding(); )
        t = t.getParent();
      var i = t ? t.providedColumnGroup.isExpandable() : !1;
      if (!i) {
        this.displayedChildren = this.children, this.localEventService.dispatchEvent(this.createAgEvent(n.EVENT_DISPLAYED_CHILDREN_CHANGED));
        return;
      }
      this.children.forEach(function(r) {
        var o = r instanceof n && (!r.displayedChildren || !r.displayedChildren.length);
        if (!o) {
          var s = r.getColumnGroupShow();
          switch (s) {
            case n.HEADER_GROUP_SHOW_OPEN:
              t.providedColumnGroup.isExpanded() && e.displayedChildren.push(r);
              break;
            case n.HEADER_GROUP_SHOW_CLOSED:
              t.providedColumnGroup.isExpanded() || e.displayedChildren.push(r);
              break;
            default:
              e.displayedChildren.push(r);
              break;
          }
        }
      }), this.localEventService.dispatchEvent(this.createAgEvent(n.EVENT_DISPLAYED_CHILDREN_CHANGED));
    }, n.HEADER_GROUP_SHOW_OPEN = "open", n.HEADER_GROUP_SHOW_CLOSED = "closed", n.EVENT_LEFT_CHANGED = "leftChanged", n.EVENT_DISPLAYED_CHILDREN_CHANGED = "displayedChildrenChanged", r$([
      T("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gn = (
  /** @class */
  function() {
    function n(e, t, i, r) {
      this.localEventService = new ic(), this.expandable = !1, this.colGroupDef = e, this.groupId = t, this.expanded = !!e && !!e.openByDefault, this.padding = i, this.level = r;
    }
    return n.prototype.setOriginalParent = function(e) {
      this.originalParent = e;
    }, n.prototype.getOriginalParent = function() {
      return this.originalParent;
    }, n.prototype.getLevel = function() {
      return this.level;
    }, n.prototype.isVisible = function() {
      return this.children ? this.children.some(function(e) {
        return e.isVisible();
      }) : !1;
    }, n.prototype.isPadding = function() {
      return this.padding;
    }, n.prototype.setExpanded = function(e) {
      this.expanded = e === void 0 ? !1 : e;
      var t = {
        type: n.EVENT_EXPANDED_CHANGED
      };
      this.localEventService.dispatchEvent(t);
    }, n.prototype.isExpandable = function() {
      return this.expandable;
    }, n.prototype.isExpanded = function() {
      return this.expanded;
    }, n.prototype.getGroupId = function() {
      return this.groupId;
    }, n.prototype.getId = function() {
      return this.getGroupId();
    }, n.prototype.setChildren = function(e) {
      this.children = e;
    }, n.prototype.getChildren = function() {
      return this.children;
    }, n.prototype.getColGroupDef = function() {
      return this.colGroupDef;
    }, n.prototype.getLeafColumns = function() {
      var e = [];
      return this.addLeafColumns(e), e;
    }, n.prototype.addLeafColumns = function(e) {
      this.children && this.children.forEach(function(t) {
        t instanceof Gt ? e.push(t) : t instanceof n && t.addLeafColumns(e);
      });
    }, n.prototype.getColumnGroupShow = function() {
      var e = this.colGroupDef;
      if (e)
        return e.columnGroupShow;
    }, n.prototype.setupExpandable = function() {
      var e = this;
      this.setExpandable(), this.getLeafColumns().forEach(function(t) {
        return t.addEventListener(Gt.EVENT_VISIBLE_CHANGED, e.onColumnVisibilityChanged.bind(e));
      });
    }, n.prototype.setExpandable = function() {
      if (!this.isPadding()) {
        for (var e = !1, t = !1, i = !1, r = this.findChildrenRemovingPadding(), o = 0, s = r.length; o < s; o++) {
          var a = r[o];
          if (a.isVisible()) {
            var l = a.getColumnGroupShow();
            l === Qr.HEADER_GROUP_SHOW_OPEN ? (e = !0, i = !0) : l === Qr.HEADER_GROUP_SHOW_CLOSED ? (t = !0, i = !0) : (e = !0, t = !0);
          }
        }
        var u = e && t && i;
        if (this.expandable !== u) {
          this.expandable = u;
          var c = {
            type: n.EVENT_EXPANDABLE_CHANGED
          };
          this.localEventService.dispatchEvent(c);
        }
      }
    }, n.prototype.findChildrenRemovingPadding = function() {
      var e = [], t = function(i) {
        i.forEach(function(r) {
          var o = r instanceof n && r.isPadding();
          o ? t(r.children) : e.push(r);
        });
      };
      return t(this.children), e;
    }, n.prototype.onColumnVisibilityChanged = function() {
      this.setExpandable();
    }, n.prototype.addEventListener = function(e, t) {
      this.localEventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.localEventService.removeEventListener(e, t);
    }, n.EVENT_EXPANDED_CHANGED = "expandedChanged", n.EVENT_EXPANDABLE_CHANGED = "expandableChanged", n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var o$ = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
};
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var TB = "__ag_Grid_Stop_Propagation", s$ = ["touchstart", "touchend", "touchmove", "touchcancel"], lL = {};
function zp(n) {
  n[TB] = !0;
}
function Hl(n) {
  return n[TB] === !0;
}
var mx = function() {
  var n = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  }, e = function(t) {
    if (typeof lL[t] == "boolean")
      return lL[t];
    var i = document.createElement(n[t] || "div");
    return t = "on" + t, lL[t] = t in i;
  };
  return e;
}();
function Vw(n, e, t) {
  for (var i = e.target; i; ) {
    var r = n.getDomData(i, t);
    if (r)
      return r;
    i = i.parentElement;
  }
  return null;
}
function a$(n, e) {
  n.addEventListener("changed", e), n.addEventListener("paste", e), n.addEventListener("input", e);
}
function Bw(n, e) {
  return !e || !n ? !1 : vx(e).indexOf(n) >= 0;
}
function OB(n) {
  for (var e = [], t = n.target; t; )
    e.push(t), t = t.parentElement;
  return e;
}
function l$(n) {
  n.__agGridEventPath = vx(n);
}
function vx(n) {
  var e = n;
  return e.path ? e.path : e.composedPath ? e.composedPath() : e.__agGridEventPath ? e.__agGridEventPath : OB(n);
}
function xB(n, e, t, i) {
  var r = Es(s$, t), o = r ? { passive: !0 } : void 0;
  n && n.addEventListener && n.addEventListener(e, t, i, o);
}
const u$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addAgGridEventPath: l$,
  addChangeListener: a$,
  addSafePassiveEventListener: xB,
  createEventPath: OB,
  getCtrlForEvent: Vw,
  getEventPath: vx,
  isElementInEventPath: Bw,
  isEventSupported: mx,
  isStopPropagationForAgGrid: Hl,
  stopPropagationForAgGrid: zp
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var um = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Se = (
  /** @class */
  function() {
    function n() {
      var e = this;
      this.destroyFunctions = [], this.destroyed = !1, this.__v_skip = !0, this.isAlive = function() {
        return !e.destroyed;
      };
    }
    return n.prototype.getFrameworkOverrides = function() {
      return this.frameworkOverrides;
    }, n.prototype.getContext = function() {
      return this.context;
    }, n.prototype.destroy = function() {
      this.destroyFunctions.forEach(function(e) {
        return e();
      }), this.destroyFunctions.length = 0, this.destroyed = !0, this.dispatchEvent({ type: n.EVENT_DESTROYED });
    }, n.prototype.addEventListener = function(e, t) {
      this.localEventService || (this.localEventService = new ic()), this.localEventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.localEventService && this.localEventService.removeEventListener(e, t);
    }, n.prototype.dispatchEventAsync = function(e) {
      var t = this;
      window.setTimeout(function() {
        return t.dispatchEvent(e);
      }, 0);
    }, n.prototype.dispatchEvent = function(e) {
      this.localEventService && this.localEventService.dispatchEvent(e);
    }, n.prototype.addManagedListener = function(e, t, i) {
      var r = this;
      if (!this.destroyed) {
        e instanceof HTMLElement ? xB(this.getFrameworkOverrides(), e, t, i) : e.addEventListener(t, i);
        var o = function() {
          return e.removeEventListener(t, i), r.destroyFunctions = r.destroyFunctions.filter(function(s) {
            return s !== o;
          }), null;
        };
        return this.destroyFunctions.push(o), o;
      }
    }, n.prototype.addDestroyFunc = function(e) {
      this.isAlive() ? this.destroyFunctions.push(e) : e();
    }, n.prototype.createManagedBean = function(e, t) {
      var i = this.createBean(e, t);
      return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), i;
    }, n.prototype.createBean = function(e, t, i) {
      return (t || this.getContext()).createBean(e, i);
    }, n.prototype.destroyBean = function(e, t) {
      return (t || this.getContext()).destroyBean(e);
    }, n.prototype.destroyBeans = function(e, t) {
      var i = this;
      return e && e.forEach(function(r) {
        return i.destroyBean(r, t);
      }), [];
    }, n.EVENT_DESTROYED = "destroyed", um([
      T("frameworkOverrides")
    ], n.prototype, "frameworkOverrides", void 0), um([
      T("context")
    ], n.prototype, "context", void 0), um([
      T("eventService")
    ], n.prototype, "eventService", void 0), um([
      T("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), um([
      To
    ], n.prototype, "destroy", null), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var c$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), uL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, h$ = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, NB = (
  /** @class */
  function(n) {
    c$(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setBeans = function(t) {
      this.logger = t.create("ColumnFactory");
    }, e.prototype.createColumnTree = function(t, i, r) {
      var o = new fB(), s = this.extractExistingTreeData(r), a = s.existingCols, l = s.existingGroups, u = s.existingColKeys;
      o.addExistingKeys(u);
      var c = this.recursivelyCreateColumns(t, 0, i, a, o, l), h = this.findMaxDept(c, 0);
      this.logger.log("Number of levels for grouped columns is " + h);
      var d = this.balanceColumnTree(c, 0, h, o), f = function(p, g) {
        p instanceof gn && p.setupExpandable(), p.setOriginalParent(g);
      };
      return this.columnUtils.depthFirstOriginalTreeSearch(null, d, f), {
        columnTree: d,
        treeDept: h
      };
    }, e.prototype.extractExistingTreeData = function(t) {
      var i = [], r = [], o = [];
      return t && this.columnUtils.depthFirstOriginalTreeSearch(null, t, function(s) {
        if (s instanceof gn) {
          var a = s;
          r.push(a);
        } else {
          var l = s;
          o.push(l.getId()), i.push(l);
        }
      }), { existingCols: i, existingGroups: r, existingColKeys: o };
    }, e.prototype.createForAutoGroups = function(t, i) {
      var r = this, o = [];
      return t.forEach(function(s) {
        var a = r.createAutoGroupTreeItem(i, s);
        o.push(a);
      }), o;
    }, e.prototype.createAutoGroupTreeItem = function(t, i) {
      for (var r = this.findDepth(t), o = i, s = r - 1; s >= 0; s--) {
        var a = new gn(null, "FAKE_PATH_" + i.getId() + "}_" + s, !0, s);
        this.context.createBean(a), a.setChildren([o]), o.setOriginalParent(a), o = a;
      }
      return o;
    }, e.prototype.findDepth = function(t) {
      for (var i = 0, r = t; r && r[0] && r[0] instanceof gn; )
        i++, r = r[0].getChildren();
      return i;
    }, e.prototype.balanceColumnTree = function(t, i, r, o) {
      for (var s = [], a = 0; a < t.length; a++) {
        var l = t[a];
        if (l instanceof gn) {
          var u = l, c = this.balanceColumnTree(u.getChildren(), i + 1, r, o);
          u.setChildren(c), s.push(u);
        } else {
          for (var h = void 0, d = void 0, f = r - 1; f >= i; f--) {
            var p = o.getUniqueKey(null, null), g = this.createMergedColGroupDef(null), _ = new gn(g, p, !0, i);
            this.context.createBean(_), d && d.setChildren([_]), d = _, h || (h = d);
          }
          if (h && d) {
            s.push(h);
            var m = t.some(function(v) {
              return v instanceof gn;
            });
            if (m) {
              d.setChildren([l]);
              continue;
            } else {
              d.setChildren(t);
              break;
            }
          }
          s.push(l);
        }
      }
      return s;
    }, e.prototype.findMaxDept = function(t, i) {
      for (var r = i, o = 0; o < t.length; o++) {
        var s = t[o];
        if (s instanceof gn) {
          var a = s, l = this.findMaxDept(a.getChildren(), i + 1);
          r < l && (r = l);
        }
      }
      return r;
    }, e.prototype.recursivelyCreateColumns = function(t, i, r, o, s, a) {
      var l = this, u = [];
      return t && t.forEach(function(c) {
        var h;
        l.isColumnGroup(c) ? h = l.createColumnGroup(r, c, i, o, s, a) : h = l.createColumn(r, c, o, s), u.push(h);
      }), u;
    }, e.prototype.createColumnGroup = function(t, i, r, o, s, a) {
      var l = this.createMergedColGroupDef(i), u = s.getUniqueKey(l.groupId || null, null), c = new gn(l, u, !1, r);
      this.context.createBean(c);
      var h = this.findExistingGroup(i, a);
      h && h.isExpanded() && c.setExpanded(!0);
      var d = this.recursivelyCreateColumns(l.children, r + 1, t, o, s, a);
      return c.setChildren(d), c;
    }, e.prototype.createMergedColGroupDef = function(t) {
      var i = {};
      return Object.assign(i, this.gridOptionsWrapper.getDefaultColGroupDef()), Object.assign(i, t), this.checkForDeprecatedItems(i), i;
    }, e.prototype.createColumn = function(t, i, r, o) {
      var s = this.mergeColDefs(i);
      this.checkForDeprecatedItems(s);
      var a = this.findExistingColumn(i, r);
      if (a)
        a.setColDef(s, i), this.applyColumnState(a, s);
      else {
        var l = o.getUniqueKey(s.colId, s.field);
        a = new Gt(s, i, l, t), this.context.createBean(a);
      }
      return a;
    }, e.prototype.applyColumnState = function(t, i) {
      var r = ca(i.flex);
      r !== void 0 && t.setFlex(r);
      var o = t.getFlex() <= 0;
      if (o) {
        var s = ca(i.width);
        if (s != null)
          t.setActualWidth(s);
        else {
          var a = t.getActualWidth();
          t.setActualWidth(a);
        }
      }
      i.sort !== void 0 && (i.sort == Z.SORT_ASC || i.sort == Z.SORT_DESC ? t.setSort(i.sort) : t.setSort(void 0));
      var l = ca(i.sortIndex);
      l !== void 0 && t.setSortIndex(l);
      var u = Bu(i.hide);
      u !== void 0 && t.setVisible(!u), i.pinned !== void 0 && t.setPinned(i.pinned);
    }, e.prototype.findExistingColumn = function(t, i) {
      var r = (i || []).find(function(o) {
        var s = o.getUserProvidedColDef();
        if (!s)
          return !1;
        var a = t.colId != null, l = t.field != null;
        return a ? o.getId() === t.colId : l ? s.field === t.field : s === t;
      });
      return i && r && Zr(i, r), r || null;
    }, e.prototype.findExistingGroup = function(t, i) {
      var r = i.find(function(o) {
        var s = o.getColGroupDef();
        if (!s)
          return !1;
        var a = t.groupId != null;
        return a ? o.getId() === t.groupId : !1;
      });
      return r && Zr(i, r), r || null;
    }, e.prototype.mergeColDefs = function(t) {
      var i = {}, r = this.gridOptionsWrapper.getDefaultColDef();
      ha(i, r, !1, !0);
      var o = t.type;
      return o || (o = r && r.type), o && this.assignColumnTypes(o, i), ha(i, t, !1, !0), i;
    }, e.prototype.assignColumnTypes = function(t, i) {
      var r = [];
      if (t instanceof Array) {
        var o = t.some(function(l) {
          return typeof l != "string";
        });
        o ? console.warn("AG Grid: if colDef.type is supplied an array it should be of type 'string[]'") : r = t;
      } else if (typeof t == "string")
        r = t.split(",");
      else {
        console.warn("AG Grid: colDef.type should be of type 'string' | 'string[]'");
        return;
      }
      var s = Object.assign({}, o$), a = this.gridOptionsWrapper.getColumnTypes() || {};
      pi(a, function(l, u) {
        l in s ? console.warn("AG Grid: the column type '" + l + "' is a default column type and cannot be overridden.") : s[l] = u;
      }), r.forEach(function(l) {
        var u = s[l.trim()];
        u ? ha(i, u, !1, !0) : console.warn("AG Grid: colDef.type '" + l + "' does not correspond to defined gridOptions.columnTypes");
      });
    }, e.prototype.checkForDeprecatedItems = function(t) {
      if (t) {
        var i = t;
        i.group !== void 0 && console.warn("AG Grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3"), i.headerGroup !== void 0 && console.warn("AG Grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3"), i.headerGroupShow !== void 0 && console.warn("AG Grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3"), i.suppressRowGroup !== void 0 && console.warn("AG Grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead"), i.suppressAggregation !== void 0 && console.warn("AG Grid: colDef.suppressAggregation is deprecated, please use colDef.type instead"), (i.suppressRowGroup || i.suppressAggregation) && console.warn("AG Grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead"), i.displayName && (console.warn("AG Grid: Found displayName " + i.displayName + ", please use headerName instead, displayName is deprecated."), i.headerName = i.displayName);
      }
    }, e.prototype.isColumnGroup = function(t) {
      return t.children !== void 0;
    }, uL([
      T("columnUtils")
    ], e.prototype, "columnUtils", void 0), uL([
      h$(0, Eo("loggerFactory"))
    ], e.prototype, "setBeans", null), e = uL([
      qe("columnFactory")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var F = (
  /** @class */
  function() {
    function n() {
    }
    return n.EVENT_COLUMN_EVERYTHING_CHANGED = "columnEverythingChanged", n.EVENT_NEW_COLUMNS_LOADED = "newColumnsLoaded", n.EVENT_COLUMN_PIVOT_MODE_CHANGED = "columnPivotModeChanged", n.EVENT_COLUMN_ROW_GROUP_CHANGED = "columnRowGroupChanged", n.EVENT_EXPAND_COLLAPSE_ALL = "expandOrCollapseAll", n.EVENT_COLUMN_PIVOT_CHANGED = "columnPivotChanged", n.EVENT_GRID_COLUMNS_CHANGED = "gridColumnsChanged", n.EVENT_COLUMN_VALUE_CHANGED = "columnValueChanged", n.EVENT_COLUMN_MOVED = "columnMoved", n.EVENT_COLUMN_VISIBLE = "columnVisible", n.EVENT_COLUMN_PINNED = "columnPinned", n.EVENT_COLUMN_GROUP_OPENED = "columnGroupOpened", n.EVENT_COLUMN_RESIZED = "columnResized", n.EVENT_DISPLAYED_COLUMNS_CHANGED = "displayedColumnsChanged", n.EVENT_VIRTUAL_COLUMNS_CHANGED = "virtualColumnsChanged", n.EVENT_ASYNC_TRANSACTIONS_FLUSHED = "asyncTransactionsFlushed", n.EVENT_ROW_GROUP_OPENED = "rowGroupOpened", n.EVENT_ROW_DATA_CHANGED = "rowDataChanged", n.EVENT_ROW_DATA_UPDATED = "rowDataUpdated", n.EVENT_PINNED_ROW_DATA_CHANGED = "pinnedRowDataChanged", n.EVENT_RANGE_SELECTION_CHANGED = "rangeSelectionChanged", n.EVENT_CHART_CREATED = "chartCreated", n.EVENT_CHART_RANGE_SELECTION_CHANGED = "chartRangeSelectionChanged", n.EVENT_CHART_OPTIONS_CHANGED = "chartOptionsChanged", n.EVENT_CHART_DESTROYED = "chartDestroyed", n.EVENT_TOOL_PANEL_VISIBLE_CHANGED = "toolPanelVisibleChanged", n.EVENT_COLUMN_PANEL_ITEM_DRAG_START = "columnPanelItemDragStart", n.EVENT_COLUMN_PANEL_ITEM_DRAG_END = "columnPanelItemDragEnd", n.EVENT_MODEL_UPDATED = "modelUpdated", n.EVENT_PASTE_START = "pasteStart", n.EVENT_PASTE_END = "pasteEnd", n.EVENT_FILL_START = "fillStart", n.EVENT_FILL_END = "fillEnd", n.EVENT_CELL_CLICKED = "cellClicked", n.EVENT_CELL_DOUBLE_CLICKED = "cellDoubleClicked", n.EVENT_CELL_MOUSE_DOWN = "cellMouseDown", n.EVENT_CELL_CONTEXT_MENU = "cellContextMenu", n.EVENT_CELL_VALUE_CHANGED = "cellValueChanged", n.EVENT_CELL_EDIT_REQUEST = "cellEditRequest", n.EVENT_ROW_VALUE_CHANGED = "rowValueChanged", n.EVENT_CELL_FOCUSED = "cellFocused", n.EVENT_ROW_SELECTED = "rowSelected", n.EVENT_SELECTION_CHANGED = "selectionChanged", n.EVENT_CELL_KEY_DOWN = "cellKeyDown", n.EVENT_CELL_KEY_PRESS = "cellKeyPress", n.EVENT_CELL_MOUSE_OVER = "cellMouseOver", n.EVENT_CELL_MOUSE_OUT = "cellMouseOut", n.EVENT_FILTER_CHANGED = "filterChanged", n.EVENT_FILTER_MODIFIED = "filterModified", n.EVENT_FILTER_OPENED = "filterOpened", n.EVENT_SORT_CHANGED = "sortChanged", n.EVENT_VIRTUAL_ROW_REMOVED = "virtualRowRemoved", n.EVENT_ROW_CLICKED = "rowClicked", n.EVENT_ROW_DOUBLE_CLICKED = "rowDoubleClicked", n.EVENT_GRID_READY = "gridReady", n.EVENT_GRID_SIZE_CHANGED = "gridSizeChanged", n.EVENT_VIEWPORT_CHANGED = "viewportChanged", n.EVENT_SCROLLBAR_WIDTH_CHANGED = "scrollbarWidthChanged", n.EVENT_FIRST_DATA_RENDERED = "firstDataRendered", n.EVENT_DRAG_STARTED = "dragStarted", n.EVENT_DRAG_STOPPED = "dragStopped", n.EVENT_CHECKBOX_CHANGED = "checkboxChanged", n.EVENT_ROW_EDITING_STARTED = "rowEditingStarted", n.EVENT_ROW_EDITING_STOPPED = "rowEditingStopped", n.EVENT_CELL_EDITING_STARTED = "cellEditingStarted", n.EVENT_CELL_EDITING_STOPPED = "cellEditingStopped", n.EVENT_BODY_SCROLL = "bodyScroll", n.EVENT_BODY_SCROLL_END = "bodyScrollEnd", n.EVENT_HEIGHT_SCALE_CHANGED = "heightScaleChanged", n.EVENT_PAGINATION_CHANGED = "paginationChanged", n.EVENT_COMPONENT_STATE_CHANGED = "componentStateChanged", n.EVENT_BODY_HEIGHT_CHANGED = "bodyHeightChanged", n.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED = "displayedColumnsWidthChanged", n.EVENT_SCROLL_VISIBILITY_CHANGED = "scrollVisibilityChanged", n.EVENT_COLUMN_HOVER_CHANGED = "columnHoverChanged", n.EVENT_FLASH_CELLS = "flashCells", n.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED = "paginationPixelOffsetChanged", n.EVENT_DISPLAYED_ROWS_CHANGED = "displayedRowsChanged", n.EVENT_LEFT_PINNED_WIDTH_CHANGED = "leftPinnedWidthChanged", n.EVENT_RIGHT_PINNED_WIDTH_CHANGED = "rightPinnedWidthChanged", n.EVENT_ROW_CONTAINER_HEIGHT_CHANGED = "rowContainerHeightChanged", n.EVENT_ROW_DRAG_ENTER = "rowDragEnter", n.EVENT_ROW_DRAG_MOVE = "rowDragMove", n.EVENT_ROW_DRAG_LEAVE = "rowDragLeave", n.EVENT_ROW_DRAG_END = "rowDragEnd", n.EVENT_POPUP_TO_FRONT = "popupToFront", n.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST = "columnRowGroupChangeRequest", n.EVENT_COLUMN_PIVOT_CHANGE_REQUEST = "columnPivotChangeRequest", n.EVENT_COLUMN_VALUE_CHANGE_REQUEST = "columnValueChangeRequest", n.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST = "columnAggFuncChangeRequest", n.EVENT_KEYBOARD_FOCUS = "keyboardFocus", n.EVENT_MOUSE_FOCUS = "mouseFocus", n.EVENT_STORE_UPDATED = "storeUpdated", n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var IB = (
  /** @class */
  function() {
    function n() {
      this.existingIds = {};
    }
    return n.prototype.getInstanceIdForKey = function(e) {
      var t = this.existingIds[e], i;
      return typeof t != "number" ? i = 0 : i = t + 1, this.existingIds[e] = i, i;
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var d$ = /[&<>"']/g, f$ = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function p$(n) {
  var e = String.fromCharCode;
  function t(h) {
    var d = [];
    if (!h)
      return [];
    for (var f = h.length, p = 0, g, _; p < f; )
      g = h.charCodeAt(p++), g >= 55296 && g <= 56319 && p < f ? (_ = h.charCodeAt(p++), (_ & 64512) == 56320 ? d.push(((g & 1023) << 10) + (_ & 1023) + 65536) : (d.push(g), p--)) : d.push(g);
    return d;
  }
  function i(h) {
    if (h >= 55296 && h <= 57343)
      throw Error("Lone surrogate U+" + h.toString(16).toUpperCase() + " is not a scalar value");
  }
  function r(h, d) {
    return e(h >> d & 63 | 128);
  }
  function o(h) {
    if (h >= 0 && h <= 31 && h !== 10) {
      var d = h.toString(16).toUpperCase(), f = d.padStart(4, "0");
      return "_x" + f + "_";
    }
    if (!(h & 4294967168))
      return e(h);
    var p = "";
    return h & 4294965248 ? h & 4294901760 ? h & 4292870144 || (p = e(h >> 18 & 7 | 240), p += r(h, 12), p += r(h, 6)) : (i(h), p = e(h >> 12 & 15 | 224), p += r(h, 6)) : p = e(h >> 6 & 31 | 192), p += e(h & 63 | 128), p;
  }
  for (var s = t(n), a = s.length, l = -1, u, c = ""; ++l < a; )
    u = s[l], c += o(u);
  return c;
}
function PB(n) {
  return n == null ? null : n.replace(/([A-Z])/g, function(e) {
    return "-" + e[0].toLowerCase();
  });
}
function AB(n) {
  return n == null ? null : n.replace(/-([a-z])/g, function(e) {
    return e[1].toUpperCase();
  });
}
function H1(n) {
  return n[0].toUpperCase() + n.substr(1).toLowerCase();
}
function ql(n) {
  return n == null ? null : n.toString().toString().replace(d$, function(e) {
    return f$[e];
  });
}
function _x(n) {
  if (!n || n == null)
    return null;
  var e = /([A-Z])([A-Z])([a-z])|([a-z])([A-Z])/g, t = n.replace(e, "$1$4 $2$3$5").replace(".", " ").split(" ");
  return t.map(function(i) {
    return i.substring(0, 1).toUpperCase() + (i.length > 1 ? i.substring(1, i.length) : "");
  }).join(" ");
}
const g$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  camelCaseToHumanText: _x,
  camelCaseToHyphen: PB,
  capitalise: H1,
  escapeString: ql,
  hyphenToCamelCase: AB,
  utf8_encode: p$
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function zc(n) {
  var e = /* @__PURE__ */ new Map();
  return n.forEach(function(t) {
    return e.set(t[0], t[1]);
  }), e;
}
function m$(n, e) {
  var t = /* @__PURE__ */ new Map();
  return n.forEach(function(i) {
    return t.set(e(i), i);
  }), t;
}
function v$(n) {
  var e = [];
  return n.forEach(function(t, i) {
    return e.push(i);
  }), e;
}
const _$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  convertToMap: zc,
  keys: v$,
  mapById: m$
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var C$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), or = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, y$ = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, PM = globalThis && globalThis.__values || function(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], i = 0;
  if (t)
    return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function() {
        return n && i >= n.length && (n = void 0), { value: n && n[i++], done: !n };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, w$ = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, AM = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(w$(arguments[e]));
  return n;
}, MB = (
  /** @class */
  function(n) {
    C$(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.primaryHeaderRowCount = 0, t.secondaryHeaderRowCount = 0, t.secondaryColumnsPresent = !1, t.gridHeaderRowCount = 0, t.displayedColumnsLeft = [], t.displayedColumnsRight = [], t.displayedColumnsCenter = [], t.displayedColumns = [], t.displayedColumnsAndGroupsMap = {}, t.viewportColumns = [], t.viewportColumnsCenter = [], t.autoHeightActiveAtLeastOnce = !1, t.rowGroupColumns = [], t.valueColumns = [], t.pivotColumns = [], t.ready = !1, t.autoGroupsNeedBuilding = !1, t.forceRecreateAutoGroups = !1, t.pivotMode = !1, t.bodyWidth = 0, t.leftWidth = 0, t.rightWidth = 0, t.bodyWidthDirty = !0, t.colDefVersion = 0, t.flexColsCalculatedAtLestOnce = !1, t;
    }
    return e.prototype.init = function() {
      var t = this;
      this.suppressColumnVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation();
      var i = this.gridOptionsWrapper.isPivotMode();
      this.isPivotSettingAllowed(i) && (this.pivotMode = i), this.usingTreeData = this.gridOptionsWrapper.isTreeData(), this.addManagedListener(this.gridOptionsWrapper, "autoGroupColumnDef", function() {
        return t.onAutoGroupColumnDefChanged();
      }), this.addManagedListener(this.gridOptionsWrapper, "defaultColDef", function() {
        return t.onDefaultColDefChanged();
      });
    }, e.prototype.onAutoGroupColumnDefChanged = function() {
      this.autoGroupsNeedBuilding = !0, this.forceRecreateAutoGroups = !0, this.updateGridColumns(), this.updateDisplayedColumns("gridOptionsChanged");
    }, e.prototype.onDefaultColDefChanged = function() {
      this.colDefVersion++, this.forceRecreateAutoGroups = !0, this.createColumnsFromColumnDefs(!0);
    }, e.prototype.getColDefVersion = function() {
      return this.colDefVersion;
    }, e.prototype.setColumnDefs = function(t, i) {
      i === void 0 && (i = "api");
      var r = !!this.columnDefs;
      this.colDefVersion++, this.columnDefs = t, this.createColumnsFromColumnDefs(r, i);
    }, e.prototype.createColumnsFromColumnDefs = function(t, i) {
      var r = this;
      i === void 0 && (i = "api");
      var o = t ? this.compareColumnStatesAndRaiseEvents(i) : void 0;
      this.valueCache.expire(), this.autoGroupsNeedBuilding = !0;
      var s = this.primaryColumns, a = this.primaryColumnTree, l = this.columnFactory.createColumnTree(this.columnDefs, !0, a);
      this.primaryColumnTree = l.columnTree, this.primaryHeaderRowCount = l.treeDept + 1, this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree), this.primaryColumnsMap = {}, this.primaryColumns.forEach(function(h) {
        return r.primaryColumnsMap[h.getId()] = h;
      }), this.extractRowGroupColumns(i, s), this.extractPivotColumns(i, s), this.extractValueColumns(i, s), this.ready = !0;
      var u = this.gridColsArePrimary === void 0, c = this.gridColsArePrimary || u;
      c && (this.updateGridColumns(), t && !this.gridOptionsWrapper.isMaintainColumnOrder() && this.orderGridColumnsLikePrimary(), this.updateDisplayedColumns(i), this.checkViewportColumns()), this.dispatchEverythingChanged(i), o && o(), this.dispatchNewColumnsLoaded();
    }, e.prototype.dispatchNewColumnsLoaded = function() {
      var t = {
        type: F.EVENT_NEW_COLUMNS_LOADED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(t);
    }, e.prototype.dispatchEverythingChanged = function(t) {
      t === void 0 && (t = "api");
      var i = {
        type: F.EVENT_COLUMN_EVERYTHING_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi,
        source: t
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.orderGridColumnsLikePrimary = function() {
      var t = this, i = this.primaryColumns;
      i && this.gridColumns.sort(function(r, o) {
        var s = i.indexOf(r), a = i.indexOf(o), l = s >= 0, u = a >= 0;
        if (l && u)
          return s - a;
        if (l)
          return 1;
        if (u)
          return -1;
        var c = t.gridColumns.indexOf(r), h = t.gridColumns.indexOf(o);
        return c - h;
      });
    }, e.prototype.getAllDisplayedAutoHeightCols = function() {
      return this.displayedAutoHeightCols;
    }, e.prototype.setViewport = function() {
      this.gridOptionsWrapper.isEnableRtl() ? (this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth, this.viewportRight = this.bodyWidth - this.scrollPosition) : (this.viewportLeft = this.scrollPosition, this.viewportRight = this.scrollWidth + this.scrollPosition);
    }, e.prototype.getDisplayedColumnsStartingAt = function(t) {
      for (var i = t, r = []; i != null; )
        r.push(i), i = this.getDisplayedColAfter(i);
      return r;
    }, e.prototype.checkViewportColumns = function() {
      if (this.displayedColumnsCenter != null) {
        var t = this.viewportColumns.map(function(o) {
          return o.getId();
        }).join("#");
        this.extractViewport();
        var i = this.viewportColumns.map(function(o) {
          return o.getId();
        }).join("#");
        if (t !== i) {
          var r = {
            type: F.EVENT_VIRTUAL_COLUMNS_CHANGED,
            api: this.gridApi,
            columnApi: this.columnApi
          };
          this.eventService.dispatchEvent(r);
        }
      }
    }, e.prototype.setViewportPosition = function(t, i) {
      (t !== this.scrollWidth || i !== this.scrollPosition || this.bodyWidthDirty) && (this.scrollWidth = t, this.scrollPosition = i, this.bodyWidthDirty = !0, this.setViewport(), this.ready && this.checkViewportColumns());
    }, e.prototype.isPivotMode = function() {
      return this.pivotMode;
    }, e.prototype.isPivotSettingAllowed = function(t) {
      return t && this.gridOptionsWrapper.isTreeData() ? (console.warn("AG Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'"), !1) : !0;
    }, e.prototype.setPivotMode = function(t, i) {
      if (i === void 0 && (i = "api"), !(t === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode))) {
        this.pivotMode = t, this.autoGroupsNeedBuilding = !0, this.updateGridColumns(), this.updateDisplayedColumns(i);
        var r = {
          type: F.EVENT_COLUMN_PIVOT_MODE_CHANGED,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(r);
      }
    }, e.prototype.getSecondaryPivotColumn = function(t, i) {
      if (!this.secondaryColumnsPresent || !this.secondaryColumns)
        return null;
      var r = this.getPrimaryColumn(i), o = null;
      return this.secondaryColumns.forEach(function(s) {
        var a = s.getColDef().pivotKeys, l = s.getColDef().pivotValueColumn, u = Cd(a, t), c = l === r;
        u && c && (o = s);
      }), o;
    }, e.prototype.setBeans = function(t) {
      this.logger = t.create("columnModel");
    }, e.prototype.setFirstRightAndLastLeftPinned = function(t) {
      var i, r;
      this.gridOptionsWrapper.isEnableRtl() ? (i = this.displayedColumnsLeft ? this.displayedColumnsLeft[0] : null, r = this.displayedColumnsRight ? Ti(this.displayedColumnsRight) : null) : (i = this.displayedColumnsLeft ? Ti(this.displayedColumnsLeft) : null, r = this.displayedColumnsRight ? this.displayedColumnsRight[0] : null), this.gridColumns.forEach(function(o) {
        o.setLastLeftPinned(o === i, t), o.setFirstRightPinned(o === r, t);
      });
    }, e.prototype.autoSizeColumns = function(t) {
      var i = this, r = t.columns, o = t.skipHeader, s = t.skipHeaderGroups, a = t.stopAtGroup, l = t.source, u = l === void 0 ? "api" : l;
      this.animationFrameService.flushAllFrames();
      for (var c = [], h = -1, d = o ?? this.gridOptionsWrapper.isSkipHeaderOnAutoSize(), f = s ?? d; h !== 0; )
        h = 0, this.actionOnGridColumns(r, function(p) {
          if (c.indexOf(p) >= 0)
            return !1;
          var g = i.autoWidthCalculator.getPreferredWidthForColumn(p, d);
          if (g > 0) {
            var _ = i.normaliseColumnWidth(p, g);
            p.setActualWidth(_, u), c.push(p), h++;
          }
          return !0;
        }, u);
      f || this.autoSizeColumnGroupsByColumns(r, a), this.fireColumnResizedEvent(c, !0, "autosizeColumns");
    }, e.prototype.fireColumnResizedEvent = function(t, i, r, o) {
      if (o === void 0 && (o = null), t && t.length) {
        var s = {
          type: F.EVENT_COLUMN_RESIZED,
          columns: t,
          column: t.length === 1 ? t[0] : null,
          flexColumns: o,
          finished: i,
          api: this.gridApi,
          columnApi: this.columnApi,
          source: r
        };
        this.eventService.dispatchEvent(s);
      }
    }, e.prototype.autoSizeColumn = function(t, i, r) {
      r === void 0 && (r = "api"), t && this.autoSizeColumns({ columns: [t], skipHeader: i, skipHeaderGroups: !0, source: r });
    }, e.prototype.autoSizeColumnGroupsByColumns = function(t, i) {
      var r, o, s, a, l = /* @__PURE__ */ new Set(), u = this.getGridColumns(t);
      u.forEach(function(v) {
        for (var C = v.getParent(); C && C != i; )
          C.isPadding() || l.add(C), C = C.getParent();
      });
      var c, h = [];
      try {
        for (var d = PM(l), f = d.next(); !f.done; f = d.next()) {
          var p = f.value;
          try {
            for (var g = (s = void 0, PM(this.ctrlsService.getHeaderRowContainerCtrls())), _ = g.next(); !_.done; _ = g.next()) {
              var m = _.value;
              if (c = m.getHeaderCtrlForColumn(p), c)
                break;
            }
          } catch (v) {
            s = { error: v };
          } finally {
            try {
              _ && !_.done && (a = g.return) && a.call(g);
            } finally {
              if (s)
                throw s.error;
            }
          }
          c && c.resizeLeafColumnsToFit();
        }
      } catch (v) {
        r = { error: v };
      } finally {
        try {
          f && !f.done && (o = d.return) && o.call(d);
        } finally {
          if (r)
            throw r.error;
        }
      }
      return h;
    }, e.prototype.autoSizeAllColumns = function(t, i) {
      i === void 0 && (i = "api");
      var r = this.getAllDisplayedColumns();
      this.autoSizeColumns({ columns: r, skipHeader: t, source: i });
    }, e.prototype.getColumnsFromTree = function(t) {
      var i = [], r = function(o) {
        for (var s = 0; s < o.length; s++) {
          var a = o[s];
          a instanceof Gt ? i.push(a) : a instanceof gn && r(a.getChildren());
        }
      };
      return r(t), i;
    }, e.prototype.getAllDisplayedTrees = function() {
      return this.displayedTreeLeft && this.displayedTreeRight && this.displayedTreeCentre ? this.displayedTreeLeft.concat(this.displayedTreeCentre).concat(this.displayedTreeRight) : null;
    }, e.prototype.getPrimaryColumnTree = function() {
      return this.primaryColumnTree;
    }, e.prototype.getHeaderRowCount = function() {
      return this.gridHeaderRowCount;
    }, e.prototype.getDisplayedTreeLeft = function() {
      return this.displayedTreeLeft;
    }, e.prototype.getDisplayedTreeRight = function() {
      return this.displayedTreeRight;
    }, e.prototype.getDisplayedTreeCentre = function() {
      return this.displayedTreeCentre;
    }, e.prototype.isColumnDisplayed = function(t) {
      return this.getAllDisplayedColumns().indexOf(t) >= 0;
    }, e.prototype.getAllDisplayedColumns = function() {
      return this.displayedColumns;
    }, e.prototype.getViewportColumns = function() {
      return this.viewportColumns;
    }, e.prototype.getDisplayedLeftColumnsForRow = function(t) {
      return this.colSpanActive ? this.getDisplayedColumnsForRow(t, this.displayedColumnsLeft) : this.displayedColumnsLeft;
    }, e.prototype.getDisplayedRightColumnsForRow = function(t) {
      return this.colSpanActive ? this.getDisplayedColumnsForRow(t, this.displayedColumnsRight) : this.displayedColumnsRight;
    }, e.prototype.getDisplayedColumnsForRow = function(t, i, r, o) {
      for (var s = [], a = null, l = function(h) {
        var d = i[h], f = i.length - h, p = Math.min(d.getColSpan(t), f), g = [d];
        if (p > 1) {
          for (var _ = p - 1, m = 1; m <= _; m++)
            g.push(i[h + m]);
          h += _;
        }
        var v;
        if (r ? (v = !1, g.forEach(function(y) {
          r(y) && (v = !0);
        })) : v = !0, v) {
          if (s.length === 0 && a) {
            var C = o ? o(d) : !1;
            C && s.push(a);
          }
          s.push(d);
        }
        a = d, u = h;
      }, u, c = 0; c < i.length; c++)
        l(c), c = u;
      return s;
    }, e.prototype.getViewportCenterColumnsForRow = function(t) {
      var i = this;
      if (!this.colSpanActive)
        return this.viewportColumnsCenter;
      var r = function(s) {
        var a = s.getLeft();
        return ge(a) && a > i.viewportLeft;
      }, o = this.suppressColumnVirtualisation ? null : this.isColumnInViewport.bind(this);
      return this.getDisplayedColumnsForRow(t, this.displayedColumnsCenter, o, r);
    }, e.prototype.getAriaColumnIndex = function(t) {
      return this.getAllGridColumns().indexOf(t) + 1;
    }, e.prototype.isColumnInViewport = function(t) {
      if (t.isAutoHeight())
        return !0;
      var i = t.getLeft() || 0, r = i + t.getActualWidth(), o = this.viewportLeft - 200, s = this.viewportRight + 200, a = i < o && r < o, l = i > s && r > s;
      return !a && !l;
    }, e.prototype.getDisplayedColumnsLeftWidth = function() {
      return this.getWidthOfColsInList(this.displayedColumnsLeft);
    }, e.prototype.getDisplayedColumnsRightWidth = function() {
      return this.getWidthOfColsInList(this.displayedColumnsRight);
    }, e.prototype.updatePrimaryColumnList = function(t, i, r, o, s, a) {
      var l = this;
      if (a === void 0 && (a = "api"), !(!t || ms(t))) {
        var u = !1;
        if (t.forEach(function(h) {
          var d = l.getPrimaryColumn(h);
          if (d) {
            if (r) {
              if (i.indexOf(d) >= 0)
                return;
              i.push(d);
            } else {
              if (i.indexOf(d) < 0)
                return;
              Zr(i, d);
            }
            o(d), u = !0;
          }
        }), !!u) {
          this.autoGroupsNeedBuilding && this.updateGridColumns(), this.updateDisplayedColumns(a);
          var c = {
            type: s,
            columns: i,
            column: i.length === 1 ? i[0] : null,
            api: this.gridApi,
            columnApi: this.columnApi,
            source: a
          };
          this.eventService.dispatchEvent(c);
        }
      }
    }, e.prototype.setRowGroupColumns = function(t, i) {
      i === void 0 && (i = "api"), this.autoGroupsNeedBuilding = !0, this.setPrimaryColumnList(t, this.rowGroupColumns, F.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this), i);
    }, e.prototype.setRowGroupActive = function(t, i, r) {
      t !== i.isRowGroupActive() && (i.setRowGroupActive(t, r), !t && !this.gridOptionsWrapper.isSuppressMakeColumnVisibleAfterUnGroup() && i.setVisible(!0, r));
    }, e.prototype.addRowGroupColumn = function(t, i) {
      i === void 0 && (i = "api"), t && this.addRowGroupColumns([t], i);
    }, e.prototype.addRowGroupColumns = function(t, i) {
      i === void 0 && (i = "api"), this.autoGroupsNeedBuilding = !0, this.updatePrimaryColumnList(t, this.rowGroupColumns, !0, this.setRowGroupActive.bind(this, !0), F.EVENT_COLUMN_ROW_GROUP_CHANGED, i);
    }, e.prototype.removeRowGroupColumns = function(t, i) {
      i === void 0 && (i = "api"), this.autoGroupsNeedBuilding = !0, this.updatePrimaryColumnList(t, this.rowGroupColumns, !1, this.setRowGroupActive.bind(this, !1), F.EVENT_COLUMN_ROW_GROUP_CHANGED, i);
    }, e.prototype.removeRowGroupColumn = function(t, i) {
      i === void 0 && (i = "api"), t && this.removeRowGroupColumns([t], i);
    }, e.prototype.addPivotColumns = function(t, i) {
      i === void 0 && (i = "api"), this.updatePrimaryColumnList(t, this.pivotColumns, !0, function(r) {
        return r.setPivotActive(!0, i);
      }, F.EVENT_COLUMN_PIVOT_CHANGED, i);
    }, e.prototype.setPivotColumns = function(t, i) {
      i === void 0 && (i = "api"), this.setPrimaryColumnList(t, this.pivotColumns, F.EVENT_COLUMN_PIVOT_CHANGED, function(r, o) {
        o.setPivotActive(r, i);
      }, i);
    }, e.prototype.addPivotColumn = function(t, i) {
      i === void 0 && (i = "api"), this.addPivotColumns([t], i);
    }, e.prototype.removePivotColumns = function(t, i) {
      i === void 0 && (i = "api"), this.updatePrimaryColumnList(t, this.pivotColumns, !1, function(r) {
        return r.setPivotActive(!1, i);
      }, F.EVENT_COLUMN_PIVOT_CHANGED, i);
    }, e.prototype.removePivotColumn = function(t, i) {
      i === void 0 && (i = "api"), this.removePivotColumns([t], i);
    }, e.prototype.setPrimaryColumnList = function(t, i, r, o, s) {
      var a = this;
      i.length = 0, ge(t) && t.forEach(function(l) {
        var u = a.getPrimaryColumn(l);
        u && i.push(u);
      }), (this.primaryColumns || []).forEach(function(l) {
        var u = i.indexOf(l) >= 0;
        o(u, l);
      }), this.autoGroupsNeedBuilding && this.updateGridColumns(), this.updateDisplayedColumns(s), this.fireColumnEvent(r, i, s);
    }, e.prototype.setValueColumns = function(t, i) {
      i === void 0 && (i = "api"), this.setPrimaryColumnList(t, this.valueColumns, F.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this), i);
    }, e.prototype.setValueActive = function(t, i, r) {
      if (t !== i.isValueActive() && (i.setValueActive(t, r), t && !i.getAggFunc())) {
        var o = this.aggFuncService.getDefaultAggFunc(i);
        i.setAggFunc(o);
      }
    }, e.prototype.addValueColumns = function(t, i) {
      i === void 0 && (i = "api"), this.updatePrimaryColumnList(t, this.valueColumns, !0, this.setValueActive.bind(this, !0), F.EVENT_COLUMN_VALUE_CHANGED, i);
    }, e.prototype.addValueColumn = function(t, i) {
      i === void 0 && (i = "api"), t && this.addValueColumns([t], i);
    }, e.prototype.removeValueColumn = function(t, i) {
      i === void 0 && (i = "api"), this.removeValueColumns([t], i);
    }, e.prototype.removeValueColumns = function(t, i) {
      i === void 0 && (i = "api"), this.updatePrimaryColumnList(t, this.valueColumns, !1, this.setValueActive.bind(this, !1), F.EVENT_COLUMN_VALUE_CHANGED, i);
    }, e.prototype.normaliseColumnWidth = function(t, i) {
      var r = t.getMinWidth();
      ge(r) && i < r && (i = r);
      var o = t.getMaxWidth();
      return ge(o) && t.isGreaterThanMax(i) && (i = o), i;
    }, e.prototype.getPrimaryOrGridColumn = function(t) {
      var i = this.getPrimaryColumn(t);
      return i || this.getGridColumn(t);
    }, e.prototype.setColumnWidths = function(t, i, r, o) {
      var s = this;
      o === void 0 && (o = "api");
      var a = [];
      t.forEach(function(l) {
        var u = s.getPrimaryOrGridColumn(l.key);
        if (u) {
          a.push({
            width: l.newWidth,
            ratios: [1],
            columns: [u]
          });
          var c = s.gridOptionsWrapper.getColResizeDefault() === "shift";
          if (c && (i = !i), i) {
            var h = s.getDisplayedColAfter(u);
            if (!h)
              return;
            var d = u.getActualWidth() - l.newWidth, f = h.getActualWidth() + d;
            a.push({
              width: f,
              ratios: [1],
              columns: [h]
            });
          }
        }
      }), a.length !== 0 && this.resizeColumnSets({
        resizeSets: a,
        finished: r,
        source: o
      });
    }, e.prototype.checkMinAndMaxWidthsForSet = function(t) {
      var i = t.columns, r = t.width, o = 0, s = 0, a = !0;
      i.forEach(function(c) {
        var h = c.getMinWidth();
        o += h || 0;
        var d = c.getMaxWidth();
        ge(d) && d > 0 ? s += d : a = !1;
      });
      var l = r >= o, u = !a || r <= s;
      return l && u;
    }, e.prototype.resizeColumnSets = function(t) {
      var i = this, r = t.resizeSets, o = t.finished, s = t.source, a = !r || r.every(function(p) {
        return i.checkMinAndMaxWidthsForSet(p);
      });
      if (!a) {
        if (o) {
          var l = r && r.length > 0 ? r[0].columns : null;
          this.fireColumnResizedEvent(l, o, s);
        }
        return;
      }
      var u = [], c = [];
      r.forEach(function(p) {
        var g = p.width, _ = p.columns, m = p.ratios, v = {}, C = {};
        _.forEach(function(E) {
          return c.push(E);
        });
        for (var y = !0, w = 0, L = function() {
          if (w++, w > 1e3)
            return console.error("AG Grid: infinite loop in resizeColumnSets"), "break";
          y = !1;
          var E = [], D = 0, x = g;
          _.forEach(function(A, M) {
            var z = C[A.getId()];
            if (z)
              x -= v[A.getId()];
            else {
              E.push(A);
              var j = m[M];
              D += j;
            }
          });
          var R = 1 / D;
          E.forEach(function(A, M) {
            var z = M === E.length - 1, j;
            z ? j = x : (j = Math.round(m[M] * g * R), x -= j);
            var $ = A.getMinWidth(), k = A.getMaxWidth();
            ge($) && j < $ ? (j = $, C[A.getId()] = !0, y = !0) : ge(k) && k > 0 && j > k && (j = k, C[A.getId()] = !0, y = !0), v[A.getId()] = j;
          });
        }; y; ) {
          var S = L();
          if (S === "break")
            break;
        }
        _.forEach(function(E) {
          var D = v[E.getId()], x = E.getActualWidth();
          x !== D && (E.setActualWidth(D, s), u.push(E));
        });
      });
      var h = u.length > 0, d = this.refreshFlexedColumns({ resizingCols: c, skipSetLeft: !0 });
      h && (this.setLeftValues(s), this.updateBodyWidths(), this.checkViewportColumns());
      var f = c.concat(d);
      (h || o) && this.fireColumnResizedEvent(f, o, s, d);
    }, e.prototype.setColumnAggFunc = function(t, i, r) {
      if (r === void 0 && (r = "api"), !!t) {
        var o = this.getPrimaryColumn(t);
        o && (o.setAggFunc(i), this.fireColumnEvent(F.EVENT_COLUMN_VALUE_CHANGED, [o], r));
      }
    }, e.prototype.fireColumnEvent = function(t, i, r) {
      var o = {
        type: t,
        columns: i,
        column: i && i.length == 1 ? i[0] : null,
        api: this.gridApi,
        columnApi: this.columnApi,
        source: r
      };
      this.eventService.dispatchEvent(o);
    }, e.prototype.moveRowGroupColumn = function(t, i, r) {
      r === void 0 && (r = "api");
      var o = this.rowGroupColumns[t];
      this.rowGroupColumns.splice(t, 1), this.rowGroupColumns.splice(i, 0, o);
      var s = {
        type: F.EVENT_COLUMN_ROW_GROUP_CHANGED,
        columns: this.rowGroupColumns,
        column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,
        api: this.gridApi,
        columnApi: this.columnApi,
        source: r
      };
      this.eventService.dispatchEvent(s);
    }, e.prototype.moveColumns = function(t, i, r) {
      if (r === void 0 && (r = "api"), this.columnAnimationService.start(), i > this.gridColumns.length - t.length) {
        console.warn("AG Grid: tried to insert columns in invalid location, toIndex = " + i), console.warn("AG Grid: remember that you should not count the moving columns when calculating the new index");
        return;
      }
      var o = this.getGridColumns(t), s = !this.doesMovePassRules(o, i);
      if (!s) {
        V1(this.gridColumns, o, i), this.updateDisplayedColumns(r);
        var a = {
          type: F.EVENT_COLUMN_MOVED,
          columns: o,
          column: o.length === 1 ? o[0] : null,
          toIndex: i,
          api: this.gridApi,
          columnApi: this.columnApi,
          source: r
        };
        this.eventService.dispatchEvent(a), this.columnAnimationService.finish();
      }
    }, e.prototype.doesMovePassRules = function(t, i) {
      var r = this.gridColumns.slice();
      return V1(r, t, i), !(!this.doesMovePassMarryChildren(r) || !this.doesMovePassLockedPositions(r));
    }, e.prototype.sortColumnsLikeGridColumns = function(t) {
      var i = this;
      if (!(!t || t.length <= 1)) {
        var r = t.filter(function(o) {
          return i.gridColumns.indexOf(o) < 0;
        }).length > 0;
        r || t.sort(function(o, s) {
          var a = i.gridColumns.indexOf(o), l = i.gridColumns.indexOf(s);
          return a - l;
        });
      }
    }, e.prototype.doesMovePassLockedPositions = function(t) {
      var i = !1, r = !0;
      return t.forEach(function(o) {
        o.getColDef().lockPosition ? i && (r = !1) : i = !0;
      }), r;
    }, e.prototype.doesMovePassMarryChildren = function(t) {
      var i = !0;
      return this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function(r) {
        if (r instanceof gn) {
          var o = r, s = o.getColGroupDef(), a = s && s.marryChildren;
          if (a) {
            var l = [];
            o.getLeafColumns().forEach(function(f) {
              var p = t.indexOf(f);
              l.push(p);
            });
            var u = Math.max.apply(Math, l), c = Math.min.apply(Math, l), h = u - c, d = o.getLeafColumns().length - 1;
            h > d && (i = !1);
          }
        }
      }), i;
    }, e.prototype.moveColumn = function(t, i, r) {
      r === void 0 && (r = "api"), this.moveColumns([t], i, r);
    }, e.prototype.moveColumnByIndex = function(t, i, r) {
      r === void 0 && (r = "api");
      var o = this.gridColumns[t];
      this.moveColumn(o, i, r);
    }, e.prototype.getColumnDefs = function() {
      var t = this;
      if (this.primaryColumns) {
        var i = this.primaryColumns.slice();
        return this.gridColsArePrimary ? i.sort(function(r, o) {
          return t.gridColumns.indexOf(r) - t.gridColumns.indexOf(o);
        }) : this.lastPrimaryOrder && i.sort(function(r, o) {
          return t.lastPrimaryOrder.indexOf(r) - t.lastPrimaryOrder.indexOf(o);
        }), this.columnDefFactory.buildColumnDefs(i, this.rowGroupColumns, this.pivotColumns);
      }
    }, e.prototype.getBodyContainerWidth = function() {
      return this.bodyWidth;
    }, e.prototype.getContainerWidth = function(t) {
      switch (t) {
        case Z.PINNED_LEFT:
          return this.leftWidth;
        case Z.PINNED_RIGHT:
          return this.rightWidth;
        default:
          return this.bodyWidth;
      }
    }, e.prototype.updateBodyWidths = function() {
      var t = this.getWidthOfColsInList(this.displayedColumnsCenter), i = this.getWidthOfColsInList(this.displayedColumnsLeft), r = this.getWidthOfColsInList(this.displayedColumnsRight);
      this.bodyWidthDirty = this.bodyWidth !== t;
      var o = this.bodyWidth !== t || this.leftWidth !== i || this.rightWidth !== r;
      if (o) {
        this.bodyWidth = t, this.leftWidth = i, this.rightWidth = r;
        var s = {
          type: F.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(s);
      }
    }, e.prototype.getValueColumns = function() {
      return this.valueColumns ? this.valueColumns : [];
    }, e.prototype.getPivotColumns = function() {
      return this.pivotColumns ? this.pivotColumns : [];
    }, e.prototype.isPivotActive = function() {
      return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;
    }, e.prototype.getRowGroupColumns = function() {
      return this.rowGroupColumns ? this.rowGroupColumns : [];
    }, e.prototype.getDisplayedCenterColumns = function() {
      return this.displayedColumnsCenter;
    }, e.prototype.getDisplayedLeftColumns = function() {
      return this.displayedColumnsLeft;
    }, e.prototype.getDisplayedRightColumns = function() {
      return this.displayedColumnsRight;
    }, e.prototype.getDisplayedColumns = function(t) {
      switch (t) {
        case Z.PINNED_LEFT:
          return this.getDisplayedLeftColumns();
        case Z.PINNED_RIGHT:
          return this.getDisplayedRightColumns();
        default:
          return this.getDisplayedCenterColumns();
      }
    }, e.prototype.getAllPrimaryColumns = function() {
      return this.primaryColumns ? this.primaryColumns.slice() : null;
    }, e.prototype.getSecondaryColumns = function() {
      return this.secondaryColumns ? this.secondaryColumns.slice() : null;
    }, e.prototype.getAllColumnsForQuickFilter = function() {
      return this.columnsForQuickFilter;
    }, e.prototype.getAllGridColumns = function() {
      return this.gridColumns;
    }, e.prototype.isEmpty = function() {
      return ms(this.gridColumns);
    }, e.prototype.isRowGroupEmpty = function() {
      return ms(this.rowGroupColumns);
    }, e.prototype.setColumnVisible = function(t, i, r) {
      r === void 0 && (r = "api"), this.setColumnsVisible([t], i, r);
    }, e.prototype.setColumnsVisible = function(t, i, r) {
      var o = this;
      i === void 0 && (i = !1), r === void 0 && (r = "api"), this.columnAnimationService.start(), this.actionOnGridColumns(t, function(s) {
        return s.isVisible() !== i ? (s.setVisible(i, r), !0) : !1;
      }, r, function() {
        var s = {
          type: F.EVENT_COLUMN_VISIBLE,
          visible: i,
          column: null,
          columns: null,
          api: o.gridApi,
          columnApi: o.columnApi,
          source: r
        };
        return s;
      }), this.columnAnimationService.finish();
    }, e.prototype.setColumnPinned = function(t, i, r) {
      r === void 0 && (r = "api"), t && this.setColumnsPinned([t], i, r);
    }, e.prototype.setColumnsPinned = function(t, i, r) {
      var o = this;
      if (r === void 0 && (r = "api"), this.gridOptionsWrapper.getDomLayout() === "print") {
        console.warn("Changing the column pinning status is not allowed with domLayout='print'");
        return;
      }
      this.columnAnimationService.start();
      var s;
      i === !0 || i === Z.PINNED_LEFT ? s = Z.PINNED_LEFT : i === Z.PINNED_RIGHT ? s = Z.PINNED_RIGHT : s = null, this.actionOnGridColumns(t, function(a) {
        return a.getPinned() !== s ? (a.setPinned(s), !0) : !1;
      }, r, function() {
        var a = {
          type: F.EVENT_COLUMN_PINNED,
          pinned: s,
          column: null,
          columns: null,
          api: o.gridApi,
          columnApi: o.columnApi,
          source: r
        };
        return a;
      }), this.columnAnimationService.finish();
    }, e.prototype.actionOnGridColumns = function(t, i, r, o) {
      var s = this;
      if (!ms(t)) {
        var a = [];
        if (t.forEach(function(u) {
          var c = s.getGridColumn(u);
          if (c) {
            var h = i(c);
            h !== !1 && a.push(c);
          }
        }), !!a.length && (this.updateDisplayedColumns(r), ge(o) && o)) {
          var l = o();
          l.columns = a, l.column = a.length === 1 ? a[0] : null, this.eventService.dispatchEvent(l);
        }
      }
    }, e.prototype.getDisplayedColBefore = function(t) {
      var i = this.getAllDisplayedColumns(), r = i.indexOf(t);
      return r > 0 ? i[r - 1] : null;
    }, e.prototype.getDisplayedColAfter = function(t) {
      var i = this.getAllDisplayedColumns(), r = i.indexOf(t);
      return r < i.length - 1 ? i[r + 1] : null;
    }, e.prototype.getDisplayedGroupAfter = function(t) {
      return this.getDisplayedGroupAtDirection(t, "After");
    }, e.prototype.getDisplayedGroupBefore = function(t) {
      return this.getDisplayedGroupAtDirection(t, "Before");
    }, e.prototype.getDisplayedGroupAtDirection = function(t, i) {
      for (var r = t.getProvidedColumnGroup().getLevel() + t.getPaddingLevel(), o = t.getDisplayedLeafColumns(), s = i === "After" ? Ti(o) : o[0], a = "getDisplayedCol" + i; ; ) {
        var l = this[a](s);
        if (!l)
          return null;
        var u = this.getColumnGroupAtLevel(l, r);
        if (u !== t)
          return u;
      }
    }, e.prototype.getColumnGroupAtLevel = function(t, i) {
      for (var r = t.getParent(), o, s; ; ) {
        var a = r.getProvidedColumnGroup();
        if (o = a.getLevel(), s = r.getPaddingLevel(), o + s <= i)
          break;
        r = r.getParent();
      }
      return r;
    }, e.prototype.isPinningLeft = function() {
      return this.displayedColumnsLeft.length > 0;
    }, e.prototype.isPinningRight = function() {
      return this.displayedColumnsRight.length > 0;
    }, e.prototype.getPrimaryAndSecondaryAndAutoColumns = function() {
      var t = this.primaryColumns ? this.primaryColumns.slice(0) : [];
      return this.groupAutoColumns && ge(this.groupAutoColumns) && this.groupAutoColumns.forEach(function(i) {
        return t.push(i);
      }), this.secondaryColumnsPresent && this.secondaryColumns && this.secondaryColumns.forEach(function(i) {
        return t.push(i);
      }), t;
    }, e.prototype.createStateItemFromColumn = function(t) {
      var i = t.isRowGroupActive() ? this.rowGroupColumns.indexOf(t) : null, r = t.isPivotActive() ? this.pivotColumns.indexOf(t) : null, o = t.isValueActive() ? t.getAggFunc() : null, s = t.getSort() != null ? t.getSort() : null, a = t.getSortIndex() != null ? t.getSortIndex() : null, l = t.getFlex() != null && t.getFlex() > 0 ? t.getFlex() : null, u = {
        colId: t.getColId(),
        width: t.getActualWidth(),
        hide: !t.isVisible(),
        pinned: t.getPinned(),
        sort: s,
        sortIndex: a,
        aggFunc: o,
        rowGroup: t.isRowGroupActive(),
        rowGroupIndex: i,
        pivot: t.isPivotActive(),
        pivotIndex: r,
        flex: l
      };
      return u;
    }, e.prototype.getColumnState = function() {
      if (Je(this.primaryColumns) || !this.isAlive())
        return [];
      var t = this.getPrimaryAndSecondaryAndAutoColumns(), i = t.map(this.createStateItemFromColumn.bind(this));
      return this.pivotMode || this.orderColumnStateList(i), i;
    }, e.prototype.getPrimaryAndAutoGroupCols = function() {
      return this.groupAutoColumns ? AM(this.primaryColumns || [], this.groupAutoColumns) : this.primaryColumns;
    }, e.prototype.orderColumnStateList = function(t) {
      var i = zc(this.gridColumns.map(function(r, o) {
        return [r.getColId(), o];
      }));
      t.sort(function(r, o) {
        var s = i.has(r.colId) ? i.get(r.colId) : -1, a = i.has(o.colId) ? i.get(o.colId) : -1;
        return s - a;
      });
    }, e.prototype.resetColumnState = function(t) {
      t === void 0 && (t = "api");
      var i = this.getColumnsFromTree(this.primaryColumnTree), r = [], o = 1e3, s = 1e3, a = [];
      this.groupAutoColumns && (a = a.concat(this.groupAutoColumns)), i && (a = a.concat(i)), a.forEach(function(l) {
        var u = function(S, E) {
          return S ?? E ?? null;
        }, c = l.getColDef(), h = u(c.sort, c.initialSort), d = u(c.sortIndex, c.initialSortIndex), f = u(c.hide, c.initialHide), p = u(c.pinned, c.initialPinned), g = u(c.width, c.initialWidth), _ = u(c.flex, c.initialFlex), m = u(c.rowGroupIndex, c.initialRowGroupIndex), v = u(c.rowGroup, c.initialRowGroup);
        m == null && (v == null || v == !1) && (m = null, v = null);
        var C = u(c.pivotIndex, c.initialPivotIndex), y = u(c.pivot, c.initialPivot);
        C == null && (y == null || y == !1) && (C = null, y = null);
        var w = u(c.aggFunc, c.initialAggFunc), L = {
          colId: l.getColId(),
          sort: h,
          sortIndex: d,
          hide: f,
          pinned: p,
          width: g,
          flex: _,
          rowGroup: v,
          rowGroupIndex: m,
          pivot: y,
          pivotIndex: C,
          aggFunc: w
        };
        Je(m) && v && (L.rowGroupIndex = o++), Je(C) && y && (L.pivotIndex = s++), r.push(L);
      }), this.applyColumnState({ state: r, applyOrder: !0 }, t);
    }, e.prototype.applyColumnState = function(t, i) {
      var r = this;
      if (i === void 0 && (i = "api"), ms(this.primaryColumns))
        return !1;
      if (t && t.state && !t.state.forEach)
        return console.warn("AG Grid: applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state."), !1;
      this.columnAnimationService.start();
      var o = this.compareColumnStatesAndRaiseEvents(i);
      this.autoGroupsNeedBuilding = !0;
      var s = this.primaryColumns.slice(), a = !0, l = {}, u = {}, c = [], h = this.rowGroupColumns.slice(), d = this.pivotColumns.slice();
      t.state && t.state.forEach(function(_) {
        var m = Z.GROUP_AUTO_COLUMN_ID, v = _.colId || "", C = v.startsWith(m);
        if (C) {
          c.push(_);
          return;
        }
        var y = r.getPrimaryColumn(v);
        y ? (r.syncColumnWithStateItem(y, _, t.defaultState, l, u, !1, i), Zr(s, y)) : a = !1;
      });
      var f = function(_) {
        return r.syncColumnWithStateItem(_, null, t.defaultState, l, u, !1, i);
      };
      s.forEach(f);
      var p = function(_, m, v, C) {
        var y = _[v.getId()], w = _[C.getId()], L = y != null, S = w != null;
        if (L && S)
          return y - w;
        if (L)
          return -1;
        if (S)
          return 1;
        var E = m.indexOf(v), D = m.indexOf(C), x = E >= 0, R = D >= 0;
        return x && R ? E - D : x ? -1 : 1;
      };
      this.rowGroupColumns.sort(p.bind(this, l, h)), this.pivotColumns.sort(p.bind(this, u, d)), this.updateGridColumns();
      var g = this.groupAutoColumns ? this.groupAutoColumns.slice() : [];
      return c.forEach(function(_) {
        var m = r.getAutoColumn(_.colId);
        Zr(g, m), r.syncColumnWithStateItem(m, _, t.defaultState, null, null, !0, i);
      }), g.forEach(f), this.applyOrderAfterApplyState(t), this.updateDisplayedColumns(i), this.dispatchEverythingChanged(i), o(), this.columnAnimationService.finish(), a;
    }, e.prototype.applyOrderAfterApplyState = function(t) {
      if (!(!this.gridColsArePrimary || !t.applyOrder || !t.state)) {
        var i = [], r = {}, o = {};
        this.gridColumns.forEach(function(a) {
          return o[a.getId()] = a;
        }), t.state.forEach(function(a) {
          if (!(!a.colId || r[a.colId])) {
            var l = o[a.colId];
            l && (i.push(l), r[a.colId] = !0);
          }
        });
        var s = 0;
        if (this.gridColumns.forEach(function(a) {
          var l = a.getColId(), u = r[l] != null;
          if (!u) {
            var c = l.startsWith(Z.GROUP_AUTO_COLUMN_ID);
            c ? Hv(i, a, s++) : i.push(a);
          }
        }), i = this.putFixedColumnsFirst(i), !this.doesMovePassMarryChildren(i)) {
          console.warn("AG Grid: Applying column order broke a group where columns should be married together. Applying new order has been discarded.");
          return;
        }
        this.gridColumns = i;
      }
    }, e.prototype.compareColumnStatesAndRaiseEvents = function(t) {
      var i = this, r = {
        rowGroupColumns: this.rowGroupColumns.slice(),
        pivotColumns: this.pivotColumns.slice(),
        valueColumns: this.valueColumns.slice()
      }, o = this.getColumnState(), s = {};
      return o.forEach(function(a) {
        s[a.colId] = a;
      }), function() {
        if (!i.gridOptionsWrapper.isSuppressColumnStateEvents()) {
          var a = i.getPrimaryAndAutoGroupCols(), l = function(m, v, C, y) {
            var w = v.map(y), L = C.map(y), S = Cd(w, L);
            if (!S) {
              var E = {
                type: m,
                columns: C,
                column: C.length === 1 ? C[0] : null,
                api: i.gridApi,
                columnApi: i.columnApi,
                source: t
              };
              i.eventService.dispatchEvent(E);
            }
          }, u = function(m) {
            var v = [];
            return (a || []).forEach(function(C) {
              var y = s[C.getColId()];
              y && m(y, C) && v.push(C);
            }), v;
          }, c = function(m) {
            return m.getColId();
          };
          l(F.EVENT_COLUMN_ROW_GROUP_CHANGED, r.rowGroupColumns, i.rowGroupColumns, c), l(F.EVENT_COLUMN_PIVOT_CHANGED, r.pivotColumns, i.pivotColumns, c);
          var h = function(m, v) {
            var C = m.aggFunc != null, y = C != v.isValueActive(), w = C && m.aggFunc != v.getAggFunc();
            return y || w;
          }, d = u(h);
          d.length > 0 && i.fireColumnEvent(F.EVENT_COLUMN_VALUE_CHANGED, i.valueColumns, t);
          var f = function(m, v) {
            return m.width != v.getActualWidth();
          };
          i.fireColumnResizedEvent(u(f), !0, t);
          var p = function(m, v) {
            return m.pinned != v.getPinned();
          };
          i.raiseColumnPinnedEvent(u(p), t);
          var g = function(m, v) {
            return m.hide == v.isVisible();
          };
          i.raiseColumnVisibleEvent(u(g), t);
          var _ = function(m, v) {
            return m.sort != v.getSort() || m.sortIndex != v.getSortIndex();
          };
          u(_).length > 0 && i.sortController.dispatchSortChangedEvents(), i.raiseColumnMovedEvent(o, t);
        }
      };
    }, e.prototype.raiseColumnPinnedEvent = function(t, i) {
      if (t.length) {
        var r = t.length === 1 ? t[0] : null, o = this.getCommonValue(t, function(a) {
          return a.getPinned();
        }), s = {
          type: F.EVENT_COLUMN_PINNED,
          // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
          pinned: o ?? null,
          columns: t,
          column: r,
          api: this.gridApi,
          columnApi: this.columnApi,
          source: i
        };
        this.eventService.dispatchEvent(s);
      }
    }, e.prototype.getCommonValue = function(t, i) {
      if (!(!t || t.length == 0)) {
        for (var r = i(t[0]), o = 1; o < t.length; o++)
          if (r !== i(t[o]))
            return;
        return r;
      }
    }, e.prototype.raiseColumnVisibleEvent = function(t, i) {
      if (t.length) {
        var r = t.length === 1 ? t[0] : null, o = this.getCommonValue(t, function(a) {
          return a.isVisible();
        }), s = {
          type: F.EVENT_COLUMN_VISIBLE,
          visible: o,
          columns: t,
          column: r,
          api: this.gridApi,
          columnApi: this.columnApi,
          source: i
        };
        this.eventService.dispatchEvent(s);
      }
    }, e.prototype.raiseColumnMovedEvent = function(t, i) {
      var r = this, o = this.getColumnState(), s = {};
      o.forEach(function(d) {
        return s[d.colId] = d;
      });
      var a = {};
      t.forEach(function(d) {
        s[d.colId] && (a[d.colId] = !0);
      });
      var l = t.filter(function(d) {
        return a[d.colId];
      }), u = o.filter(function(d) {
        return a[d.colId];
      }), c = [];
      if (u.forEach(function(d, f) {
        var p = l && l[f];
        if (p && p.colId !== d.colId) {
          var g = r.getGridColumn(p.colId);
          g && c.push(g);
        }
      }), !!c.length) {
        var h = {
          type: F.EVENT_COLUMN_MOVED,
          columns: c,
          column: null,
          api: this.gridApi,
          columnApi: this.columnApi,
          source: i
        };
        this.eventService.dispatchEvent(h);
      }
    }, e.prototype.syncColumnWithStateItem = function(t, i, r, o, s, a, l) {
      if (t) {
        var u = function(D, x) {
          var R = { value1: void 0, value2: void 0 }, A = !1;
          return i && (i[D] !== void 0 && (R.value1 = i[D], A = !0), ge(x) && i[x] !== void 0 && (R.value2 = i[x], A = !0)), !A && r && (r[D] !== void 0 && (R.value1 = r[D]), ge(x) && r[x] !== void 0 && (R.value2 = r[x])), R;
        }, c = u("hide").value1;
        c !== void 0 && t.setVisible(!c, l);
        var h = u("pinned").value1;
        h !== void 0 && t.setPinned(h);
        var d = this.columnUtils.calculateColMinWidth(t.getColDef()), f = u("flex").value1;
        f !== void 0 && t.setFlex(f);
        var p = t.getFlex() <= 0;
        if (p) {
          var g = u("width").value1;
          g != null && d != null && g >= d && t.setActualWidth(g, l);
        }
        var _ = u("sort").value1;
        _ !== void 0 && (_ === Z.SORT_DESC || _ === Z.SORT_ASC ? t.setSort(_) : t.setSort(void 0));
        var m = u("sortIndex").value1;
        if (m !== void 0 && t.setSortIndex(m), !a) {
          var v = u("aggFunc").value1;
          v !== void 0 && (typeof v == "string" ? (t.setAggFunc(v), t.isValueActive() || (t.setValueActive(!0, l), this.valueColumns.push(t))) : (ge(v) && console.warn("AG Grid: stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON."), t.isValueActive() && (t.setValueActive(!1, l), Zr(this.valueColumns, t))));
          var C = u("rowGroup", "rowGroupIndex"), y = C.value1, w = C.value2;
          (y !== void 0 || w !== void 0) && (typeof w == "number" || y ? (t.isRowGroupActive() || (t.setRowGroupActive(!0, l), this.rowGroupColumns.push(t)), o && typeof w == "number" && (o[t.getId()] = w)) : t.isRowGroupActive() && (t.setRowGroupActive(!1, l), Zr(this.rowGroupColumns, t)));
          var L = u("pivot", "pivotIndex"), S = L.value1, E = L.value2;
          (S !== void 0 || E !== void 0) && (typeof E == "number" || S ? (t.isPivotActive() || (t.setPivotActive(!0, l), this.pivotColumns.push(t)), s && typeof E == "number" && (s[t.getId()] = E)) : t.isPivotActive() && (t.setPivotActive(!1, l), Zr(this.pivotColumns, t)));
        }
      }
    }, e.prototype.getGridColumns = function(t) {
      return this.getColumns(t, this.getGridColumn.bind(this));
    }, e.prototype.getColumns = function(t, i) {
      var r = [];
      return t && t.forEach(function(o) {
        var s = i(o);
        s && r.push(s);
      }), r;
    }, e.prototype.getColumnWithValidation = function(t) {
      if (t == null)
        return null;
      var i = this.getGridColumn(t);
      return i || console.warn("AG Grid: could not find column " + t), i;
    }, e.prototype.getPrimaryColumn = function(t) {
      return this.primaryColumns ? this.getColumn(t, this.primaryColumns, this.primaryColumnsMap) : null;
    }, e.prototype.getGridColumn = function(t) {
      return this.getColumn(t, this.gridColumns, this.gridColumnsMap);
    }, e.prototype.getColumn = function(t, i, r) {
      if (!t)
        return null;
      if (typeof t == "string" && r[t])
        return r[t];
      for (var o = 0; o < i.length; o++)
        if (this.columnsMatch(i[o], t))
          return i[o];
      return this.getAutoColumn(t);
    }, e.prototype.getAutoColumn = function(t) {
      var i = this;
      return !this.groupAutoColumns || !ge(this.groupAutoColumns) || Je(this.groupAutoColumns) ? null : this.groupAutoColumns.find(function(r) {
        return i.columnsMatch(r, t);
      }) || null;
    }, e.prototype.columnsMatch = function(t, i) {
      var r = t === i, o = t.getColDef() === i, s = t.getColId() == i;
      return r || o || s;
    }, e.prototype.getDisplayNameForColumn = function(t, i, r) {
      if (r === void 0 && (r = !1), !t)
        return null;
      var o = this.getHeaderName(t.getColDef(), t, null, null, i);
      return r ? this.wrapHeaderNameWithAggFunc(t, o) : o;
    }, e.prototype.getDisplayNameForProvidedColumnGroup = function(t, i, r) {
      var o = i ? i.getColGroupDef() : null;
      return o ? this.getHeaderName(o, null, t, i, r) : null;
    }, e.prototype.getDisplayNameForColumnGroup = function(t, i) {
      return this.getDisplayNameForProvidedColumnGroup(t, t.getProvidedColumnGroup(), i);
    }, e.prototype.getHeaderName = function(t, i, r, o, s) {
      var a = t.headerValueGetter;
      if (a) {
        var l = {
          colDef: t,
          column: i,
          columnGroup: r,
          providedColumnGroup: o,
          location: s,
          api: this.gridOptionsWrapper.getApi(),
          context: this.gridOptionsWrapper.getContext()
        };
        return typeof a == "function" ? a(l) : typeof a == "string" ? this.expressionService.evaluate(a, l) : (console.warn("ag-grid: headerValueGetter must be a function or a string"), "");
      } else {
        if (t.headerName != null)
          return t.headerName;
        if (t.field)
          return _x(t.field);
      }
      return "";
    }, e.prototype.wrapHeaderNameWithAggFunc = function(t, i) {
      if (this.gridOptionsWrapper.isSuppressAggFuncInHeader())
        return i;
      var r = t.getColDef().pivotValueColumn, o = ge(r), s = null, a;
      if (o)
        s = r ? r.getAggFunc() : null, a = !0;
      else {
        var l = t.isValueActive(), u = this.pivotMode || !this.isRowGroupEmpty();
        l && u ? (s = t.getAggFunc(), a = !0) : a = !1;
      }
      if (a) {
        var c = typeof s == "string" ? s : "func", h = this.gridOptionsWrapper.getLocaleTextFunc(), d = h(c, c);
        return d + "(" + i + ")";
      }
      return i;
    }, e.prototype.getColumnGroup = function(t, i) {
      if (!t)
        return null;
      if (t instanceof Qr)
        return t;
      var r = this.getAllDisplayedTrees(), o = typeof i == "number", s = null;
      return this.columnUtils.depthFirstAllColumnTreeSearch(r, function(a) {
        if (a instanceof Qr) {
          var l = a, u = void 0;
          o ? u = t === l.getGroupId() && i === l.getInstanceId() : u = t === l.getGroupId(), u && (s = l);
        }
      }), s;
    }, e.prototype.isReady = function() {
      return this.ready;
    }, e.prototype.extractValueColumns = function(t, i) {
      this.valueColumns = this.extractColumns(
        i,
        this.valueColumns,
        function(r, o) {
          return r.setValueActive(o, t);
        },
        // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null
        function() {
        },
        function() {
        },
        // aggFunc is a string, so return it's existence
        function(r) {
          var o = r.aggFunc;
          if (o === null || o === "")
            return null;
          if (o !== void 0)
            return !!o;
        },
        function(r) {
          return r.initialAggFunc != null && r.initialAggFunc != "";
        }
      ), this.valueColumns.forEach(function(r) {
        var o = r.getColDef();
        o.aggFunc != null && o.aggFunc != "" ? r.setAggFunc(o.aggFunc) : r.getAggFunc() || r.setAggFunc(o.initialAggFunc);
      });
    }, e.prototype.extractRowGroupColumns = function(t, i) {
      this.rowGroupColumns = this.extractColumns(i, this.rowGroupColumns, function(r, o) {
        return r.setRowGroupActive(o, t);
      }, function(r) {
        return r.rowGroupIndex;
      }, function(r) {
        return r.initialRowGroupIndex;
      }, function(r) {
        return r.rowGroup;
      }, function(r) {
        return r.initialRowGroup;
      });
    }, e.prototype.extractColumns = function(t, i, r, o, s, a, l) {
      t === void 0 && (t = []), i === void 0 && (i = []);
      var u = [], c = [];
      (this.primaryColumns || []).forEach(function(f) {
        var p = t.indexOf(f) < 0, g = f.getColDef(), _ = Bu(a(g)), m = Bu(l(g)), v = ca(o(g)), C = ca(s(g)), y, w = _ !== void 0, L = v !== void 0, S = m !== void 0, E = C !== void 0;
        if (w ? y = _ : L ? v === null ? y = !1 : y = v >= 0 : p ? S ? y = m : E ? y = C != null && C >= 0 : y = !1 : y = i.indexOf(f) >= 0, y) {
          var D = p ? v != null || C != null : v != null;
          D ? u.push(f) : c.push(f);
        }
      });
      var h = function(f) {
        var p = o(f.getColDef()), g = s(f.getColDef());
        return p ?? g;
      };
      u.sort(function(f, p) {
        var g = h(f), _ = h(p);
        return g === _ ? 0 : g < _ ? -1 : 1;
      });
      var d = [].concat(u);
      return i.forEach(function(f) {
        c.indexOf(f) >= 0 && d.push(f);
      }), c.forEach(function(f) {
        d.indexOf(f) < 0 && d.push(f);
      }), i.forEach(function(f) {
        d.indexOf(f) < 0 && r(f, !1);
      }), d.forEach(function(f) {
        i.indexOf(f) < 0 && r(f, !0);
      }), d;
    }, e.prototype.extractPivotColumns = function(t, i) {
      this.pivotColumns = this.extractColumns(i, this.pivotColumns, function(r, o) {
        return r.setPivotActive(o, t);
      }, function(r) {
        return r.pivotIndex;
      }, function(r) {
        return r.initialPivotIndex;
      }, function(r) {
        return r.pivot;
      }, function(r) {
        return r.initialPivot;
      });
    }, e.prototype.resetColumnGroupState = function(t) {
      t === void 0 && (t = "api");
      var i = [];
      this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, function(r) {
        if (r instanceof gn) {
          var o = r.getColGroupDef(), s = {
            groupId: r.getGroupId(),
            open: o ? o.openByDefault : void 0
          };
          i.push(s);
        }
      }), this.setColumnGroupState(i, t);
    }, e.prototype.getColumnGroupState = function() {
      var t = [];
      return this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function(i) {
        if (i instanceof gn) {
          var r = i;
          t.push({
            groupId: r.getGroupId(),
            open: r.isExpanded()
          });
        }
      }), t;
    }, e.prototype.setColumnGroupState = function(t, i) {
      var r = this;
      i === void 0 && (i = "api"), this.columnAnimationService.start();
      var o = [];
      t.forEach(function(s) {
        var a = s.groupId, l = s.open, u = r.getProvidedColumnGroup(a);
        u && u.isExpanded() !== l && (r.logger.log("columnGroupOpened(" + u.getGroupId() + "," + l + ")"), u.setExpanded(l), o.push(u));
      }), this.updateGroupsAndDisplayedColumns(i), this.setFirstRightAndLastLeftPinned(i), o.forEach(function(s) {
        var a = {
          type: F.EVENT_COLUMN_GROUP_OPENED,
          columnGroup: s,
          api: r.gridApi,
          columnApi: r.columnApi
        };
        r.eventService.dispatchEvent(a);
      }), this.columnAnimationService.finish();
    }, e.prototype.setColumnGroupOpened = function(t, i, r) {
      r === void 0 && (r = "api");
      var o;
      t instanceof gn ? o = t.getId() : o = t || "", this.setColumnGroupState([{ groupId: o, open: i }], r);
    }, e.prototype.getProvidedColumnGroup = function(t) {
      typeof t != "string" && console.error("AG Grid: group key must be a string");
      var i = null;
      return this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function(r) {
        if (r instanceof gn) {
          var o = r;
          o.getId() === t && (i = o);
        }
      }), i;
    }, e.prototype.calculateColumnsForDisplay = function() {
      var t = this, i;
      return this.pivotMode && !this.secondaryColumnsPresent ? i = this.gridColumns.filter(function(r) {
        var o = t.groupAutoColumns && Es(t.groupAutoColumns, r), s = t.valueColumns && Es(t.valueColumns, r);
        return o || s;
      }) : i = this.gridColumns.filter(function(r) {
        var o = t.groupAutoColumns && Es(t.groupAutoColumns, r);
        return o || r.isVisible();
      }), i;
    }, e.prototype.checkColSpanActiveInCols = function(t) {
      var i = !1;
      return t.forEach(function(r) {
        ge(r.getColDef().colSpan) && (i = !0);
      }), i;
    }, e.prototype.calculateColumnsForGroupDisplay = function() {
      var t = this;
      this.groupDisplayColumns = [];
      var i = function(r) {
        var o = r.getColDef();
        o && ge(o.showRowGroup) && t.groupDisplayColumns.push(r);
      };
      this.gridColumns.forEach(i), this.groupAutoColumns && this.groupAutoColumns.forEach(i);
    }, e.prototype.getGroupDisplayColumns = function() {
      return this.groupDisplayColumns;
    }, e.prototype.updateDisplayedColumns = function(t) {
      var i = this.calculateColumnsForDisplay();
      this.buildDisplayedTrees(i), this.calculateColumnsForGroupDisplay(), this.updateGroupsAndDisplayedColumns(t), this.setFirstRightAndLastLeftPinned(t);
    }, e.prototype.isSecondaryColumnsPresent = function() {
      return this.secondaryColumnsPresent;
    }, e.prototype.setSecondaryColumns = function(t, i) {
      i === void 0 && (i = "api");
      var r = t && t.length > 0;
      if (!(!r && !this.secondaryColumnsPresent)) {
        if (r) {
          this.processSecondaryColumnDefinitions(t);
          var o = this.columnFactory.createColumnTree(t, !1);
          this.secondaryBalancedTree = o.columnTree, this.secondaryHeaderRowCount = o.treeDept + 1, this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree), this.secondaryColumnsPresent = !0;
        } else
          this.secondaryBalancedTree = null, this.secondaryHeaderRowCount = -1, this.secondaryColumns = null, this.secondaryColumnsPresent = !1;
        this.updateGridColumns(), this.updateDisplayedColumns(i);
      }
    }, e.prototype.processSecondaryColumnDefinitions = function(t) {
      var i = this.gridOptionsWrapper.getProcessSecondaryColDefFunc(), r = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();
      if (!(!i && !r)) {
        var o = function(s) {
          s.forEach(function(a) {
            var l = ge(a.children);
            if (l) {
              var u = a;
              r && r(u), o(u.children);
            } else {
              var c = a;
              i && i(c);
            }
          });
        };
        t && o(t);
      }
    }, e.prototype.updateGridColumns = function() {
      var t = this;
      this.gridColsArePrimary && (this.lastPrimaryOrder = this.gridColumns), this.secondaryColumns && this.secondaryBalancedTree ? (this.gridBalancedTree = this.secondaryBalancedTree.slice(), this.gridHeaderRowCount = this.secondaryHeaderRowCount, this.gridColumns = this.secondaryColumns.slice(), this.gridColsArePrimary = !1) : this.primaryColumns && (this.gridBalancedTree = this.primaryColumnTree.slice(), this.gridHeaderRowCount = this.primaryHeaderRowCount, this.gridColumns = this.primaryColumns.slice(), this.gridColsArePrimary = !0, this.orderGridColsLikeLastPrimary()), this.addAutoGroupToGridColumns(), this.gridColumns = this.putFixedColumnsFirst(this.gridColumns), this.setupQuickFilterColumns(), this.clearDisplayedAndViewportColumns(), this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns), this.gridColumnsMap = {}, this.gridColumns.forEach(function(r) {
        return t.gridColumnsMap[r.getId()] = r;
      }), this.setAutoHeightActive();
      var i = {
        type: F.EVENT_GRID_COLUMNS_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.setAutoHeightActive = function() {
      if (this.autoHeightActive = this.gridColumns.filter(function(o) {
        return o.isAutoHeight();
      }).length > 0, this.autoHeightActive) {
        this.autoHeightActiveAtLeastOnce = !0;
        var t = this.rowModel.getType(), i = t === Z.ROW_MODEL_TYPE_CLIENT_SIDE || t === Z.ROW_MODEL_TYPE_SERVER_SIDE;
        if (!i) {
          var r = "AG Grid - autoHeight columns only work with Client Side Row Model and Server Side Row Model.";
          mi(function() {
            return console.warn(r);
          }, "autoHeightActive.wrongRowModel");
        }
      }
    }, e.prototype.orderGridColsLikeLastPrimary = function() {
      if (!Je(this.lastPrimaryOrder)) {
        var t = zc(this.lastPrimaryOrder.map(function(u, c) {
          return [u, c];
        })), i = !0;
        if (this.gridColumns.forEach(function(u) {
          t.has(u) && (i = !1);
        }), !i) {
          var r = zc(this.gridColumns.map(function(u) {
            return [u, !0];
          })), o = this.lastPrimaryOrder.filter(function(u) {
            return r.has(u);
          }), s = zc(o.map(function(u) {
            return [u, !0];
          })), a = this.gridColumns.filter(function(u) {
            return !s.has(u);
          }), l = o.slice();
          a.forEach(function(u) {
            var c = u.getOriginalParent();
            if (!c) {
              l.push(u);
              return;
            }
            for (var h = []; !h.length && c; ) {
              var d = c.getLeafColumns();
              d.forEach(function(g) {
                var _ = l.indexOf(g) >= 0, m = h.indexOf(g) < 0;
                _ && m && h.push(g);
              }), c = c.getOriginalParent();
            }
            if (!h.length) {
              l.push(u);
              return;
            }
            var f = h.map(function(g) {
              return l.indexOf(g);
            }), p = Math.max.apply(Math, AM(f));
            Hv(l, u, p + 1);
          }), this.gridColumns = l;
        }
      }
    }, e.prototype.isPrimaryColumnGroupsPresent = function() {
      return this.primaryHeaderRowCount > 1;
    }, e.prototype.setupQuickFilterColumns = function() {
      this.groupAutoColumns ? this.columnsForQuickFilter = (this.primaryColumns || []).concat(this.groupAutoColumns) : this.primaryColumns && (this.columnsForQuickFilter = this.primaryColumns);
    }, e.prototype.putFixedColumnsFirst = function(t) {
      var i = t.filter(function(o) {
        return o.getColDef().lockPosition;
      }), r = t.filter(function(o) {
        return !o.getColDef().lockPosition;
      });
      return i.concat(r);
    }, e.prototype.addAutoGroupToGridColumns = function() {
      if (this.createGroupAutoColumnsIfNeeded(), !Je(this.groupAutoColumns)) {
        this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;
        var t = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);
        this.gridBalancedTree = t.concat(this.gridBalancedTree);
      }
    }, e.prototype.clearDisplayedAndViewportColumns = function() {
      this.displayedTreeLeft = [], this.displayedTreeRight = [], this.displayedTreeCentre = [], this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {}, this.displayedColumnsLeft = [], this.displayedColumnsRight = [], this.displayedColumnsCenter = [], this.displayedColumns = [], this.viewportColumns = [];
    }, e.prototype.updateGroupsAndDisplayedColumns = function(t) {
      this.updateOpenClosedVisibilityInColumnGroups(), this.deriveDisplayedColumns(t), this.refreshFlexedColumns(), this.extractViewport(), this.updateBodyWidths();
      var i = {
        type: F.EVENT_DISPLAYED_COLUMNS_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.deriveDisplayedColumns = function(t) {
      this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeLeft, this.displayedColumnsLeft), this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeCentre, this.displayedColumnsCenter), this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeRight, this.displayedColumnsRight), this.joinDisplayedColumns(), this.setLeftValues(t), this.displayedAutoHeightCols = this.displayedColumns.filter(function(i) {
        return i.isAutoHeight();
      });
    }, e.prototype.isAutoRowHeightActive = function() {
      return this.autoHeightActive;
    }, e.prototype.wasAutoRowHeightEverActive = function() {
      return this.autoHeightActiveAtLeastOnce;
    }, e.prototype.joinDisplayedColumns = function() {
      this.gridOptionsWrapper.isEnableRtl() ? this.displayedColumns = this.displayedColumnsRight.concat(this.displayedColumnsCenter).concat(this.displayedColumnsLeft) : this.displayedColumns = this.displayedColumnsLeft.concat(this.displayedColumnsCenter).concat(this.displayedColumnsRight);
    }, e.prototype.setLeftValues = function(t) {
      this.setLeftValuesOfColumns(t), this.setLeftValuesOfGroups();
    }, e.prototype.setLeftValuesOfColumns = function(t) {
      var i = this;
      if (this.primaryColumns) {
        var r = this.primaryColumns.slice(0), o = this.gridOptionsWrapper.isEnableRtl();
        [
          this.displayedColumnsLeft,
          this.displayedColumnsRight,
          this.displayedColumnsCenter
        ].forEach(function(s) {
          if (o) {
            var a = i.getWidthOfColsInList(s);
            s.forEach(function(u) {
              a -= u.getActualWidth(), u.setLeft(a, t);
            });
          } else {
            var l = 0;
            s.forEach(function(u) {
              u.setLeft(l, t), l += u.getActualWidth();
            });
          }
          gx(r, s);
        }), r.forEach(function(s) {
          s.setLeft(null, t);
        });
      }
    }, e.prototype.setLeftValuesOfGroups = function() {
      [
        this.displayedTreeLeft,
        this.displayedTreeRight,
        this.displayedTreeCentre
      ].forEach(function(t) {
        t.forEach(function(i) {
          if (i instanceof Qr) {
            var r = i;
            r.checkLeft();
          }
        });
      });
    }, e.prototype.derivedDisplayedColumnsFromDisplayedTree = function(t, i) {
      i.length = 0, this.columnUtils.depthFirstDisplayedColumnTreeSearch(t, function(r) {
        r instanceof Gt && i.push(r);
      });
    }, e.prototype.extractViewportColumns = function() {
      this.suppressColumnVirtualisation ? this.viewportColumnsCenter = this.displayedColumnsCenter : this.viewportColumnsCenter = this.filterOutColumnsWithinViewport(), this.viewportColumns = this.viewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight);
    }, e.prototype.getVirtualHeaderGroupRow = function(t, i) {
      var r;
      switch (t) {
        case Z.PINNED_LEFT:
          r = this.viewportRowLeft[i];
          break;
        case Z.PINNED_RIGHT:
          r = this.viewportRowRight[i];
          break;
        default:
          r = this.viewportRowCenter[i];
          break;
      }
      return Je(r) && (r = []), r;
    }, e.prototype.extractViewportRows = function() {
      this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {};
      var t = {};
      this.viewportColumns.forEach(function(r) {
        return t[r.getId()] = !0;
      });
      var i = function(r, o, s) {
        for (var a = !1, l = 0; l < r.length; l++) {
          var u = r[l], c = !1;
          if (u instanceof Gt)
            c = t[u.getId()] === !0;
          else {
            var h = u, d = h.getDisplayedChildren();
            d && (c = i(d, o, s + 1));
          }
          c && (a = !0, o[s] || (o[s] = []), o[s].push(u));
        }
        return a;
      };
      i(this.displayedTreeLeft, this.viewportRowLeft, 0), i(this.displayedTreeRight, this.viewportRowRight, 0), i(this.displayedTreeCentre, this.viewportRowCenter, 0);
    }, e.prototype.extractViewport = function() {
      this.extractViewportColumns(), this.extractViewportRows();
    }, e.prototype.filterOutColumnsWithinViewport = function() {
      return this.displayedColumnsCenter.filter(this.isColumnInViewport.bind(this));
    }, e.prototype.refreshFlexedColumns = function(t) {
      var i = this;
      t === void 0 && (t = {});
      var r = t.source ? t.source : "flex";
      if (t.viewportWidth != null && (this.flexViewportWidth = t.viewportWidth), !this.flexViewportWidth)
        return [];
      var o = -1;
      t.resizingCols && t.resizingCols.forEach(function(y) {
        var w = i.displayedColumnsCenter.indexOf(y);
        o < w && (o = w);
      });
      var s = function(y) {
        var w = i.displayedColumnsCenter.indexOf(y) > o;
        return y.getFlex() && w;
      }, a = this.displayedColumnsCenter.filter(function(y) {
        return !s(y);
      }), l = this.displayedColumnsCenter.filter(function(y) {
        return s(y);
      }), u = [];
      if (!l.length)
        return [];
      var c = [], h;
      e:
        for (; ; ) {
          var d = l.reduce(function(y, w) {
            return y + w.getFlex();
          }, 0);
          h = this.flexViewportWidth - this.getWidthOfColsInList(a);
          for (var f = 0; f < l.length; f++) {
            var p = l[f], g = h * p.getFlex() / d, _ = 0, m = p.getMinWidth(), v = p.getMaxWidth();
            if (ge(m) && g < m ? _ = m : ge(v) && g > v && (_ = v), _) {
              p.setActualWidth(_, r), Zr(l, p), u.push(p), a.push(p);
              continue e;
            }
            c[f] = Math.round(g);
          }
          break;
        }
      var C = h;
      return l.forEach(function(y, w) {
        y.setActualWidth(Math.min(c[w], C), r), u.push(y), C -= c[w];
      }), t.skipSetLeft || this.setLeftValues(r), t.updateBodyWidths && this.updateBodyWidths(), t.fireResizedEvent && this.fireColumnResizedEvent(u, !0, r, l), this.flexColsCalculatedAtLestOnce || (this.gridOptionsWrapper.isRowModelDefault() && this.rowModel.resetRowHeights(), this.flexColsCalculatedAtLestOnce = !0), l;
    }, e.prototype.sizeColumnsToFit = function(t, i, r) {
      i === void 0 && (i = "sizeColumnsToFit");
      var o = this.getAllDisplayedColumns();
      if (!(t <= 0 || !o.length)) {
        var s = [], a = [];
        o.forEach(function(C) {
          C.getColDef().suppressSizeToFit === !0 ? a.push(C) : s.push(C);
        });
        var l = s.slice(0), u = !1, c = function(C) {
          Zr(s, C), a.push(C);
        };
        for (s.forEach(function(C) {
          return C.resetActualWidth(i);
        }); !u; ) {
          u = !0;
          var h = t - this.getWidthOfColsInList(a);
          if (h <= 0)
            s.forEach(function(C) {
              C.setMinimum(i);
            });
          else
            for (var d = h / this.getWidthOfColsInList(s), f = h, p = s.length - 1; p >= 0; p--) {
              var g = s[p], _ = g.getMinWidth(), m = g.getMaxWidth(), v = Math.round(g.getActualWidth() * d);
              ge(_) && v < _ ? (v = _, c(g), u = !1) : ge(m) && g.isGreaterThanMax(v) ? (v = m, c(g), u = !1) : p === 0 && (v = f), g.setActualWidth(v, i, !0), f -= v;
            }
        }
        l.forEach(function(C) {
          C.fireColumnWidthChangedEvent(i);
        }), this.setLeftValues(i), this.updateBodyWidths(), !r && this.fireColumnResizedEvent(l, !0, i);
      }
    }, e.prototype.buildDisplayedTrees = function(t) {
      var i = [], r = [], o = [];
      t.forEach(function(a) {
        switch (a.getPinned()) {
          case "left":
            i.push(a);
            break;
          case "right":
            r.push(a);
            break;
          default:
            o.push(a);
            break;
        }
      });
      var s = new IB();
      this.displayedTreeLeft = this.displayedGroupCreator.createDisplayedGroups(i, this.gridBalancedTree, s, Z.PINNED_LEFT, this.displayedTreeLeft), this.displayedTreeRight = this.displayedGroupCreator.createDisplayedGroups(r, this.gridBalancedTree, s, Z.PINNED_RIGHT, this.displayedTreeRight), this.displayedTreeCentre = this.displayedGroupCreator.createDisplayedGroups(o, this.gridBalancedTree, s, null, this.displayedTreeCentre), this.updateDisplayedMap();
    }, e.prototype.updateDisplayedMap = function() {
      var t = this;
      this.displayedColumnsAndGroupsMap = {};
      var i = function(r) {
        t.displayedColumnsAndGroupsMap[r.getUniqueId()] = r;
      };
      this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeCentre, i), this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeLeft, i), this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeRight, i);
    }, e.prototype.isDisplayed = function(t) {
      var i = this.displayedColumnsAndGroupsMap[t.getUniqueId()];
      return i === t;
    }, e.prototype.updateOpenClosedVisibilityInColumnGroups = function() {
      var t = this.getAllDisplayedTrees();
      this.columnUtils.depthFirstAllColumnTreeSearch(t, function(i) {
        if (i instanceof Qr) {
          var r = i;
          r.calculateDisplayedColumns();
        }
      });
    }, e.prototype.getGroupAutoColumns = function() {
      return this.groupAutoColumns;
    }, e.prototype.createGroupAutoColumnsIfNeeded = function() {
      if (this.autoGroupsNeedBuilding) {
        this.autoGroupsNeedBuilding = !1;
        var t = this.gridOptionsWrapper.isGroupUseEntireRow(this.pivotMode), i = this.pivotMode ? this.gridOptionsWrapper.isPivotSuppressAutoColumn() : this.gridOptionsWrapper.isGroupSuppressAutoColumn(), r = this.rowGroupColumns.length > 0 || this.usingTreeData, o = r && !i && !t;
        if (o) {
          var s = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns), a = !this.autoColsEqual(s, this.groupAutoColumns);
          (a || this.forceRecreateAutoGroups) && (this.groupAutoColumns = s);
        } else
          this.groupAutoColumns = null;
      }
    }, e.prototype.autoColsEqual = function(t, i) {
      return Cd(t, i, function(r, o) {
        return r.getColId() === o.getColId();
      });
    }, e.prototype.getWidthOfColsInList = function(t) {
      return t.reduce(function(i, r) {
        return i + r.getActualWidth();
      }, 0);
    }, e.prototype.getGridBalancedTree = function() {
      return this.gridBalancedTree;
    }, e.prototype.hasFloatingFilters = function() {
      if (!this.gridColumns)
        return !1;
      var t = this.gridColumns.some(function(i) {
        return i.getColDef().floatingFilter;
      });
      return t;
    }, e.prototype.getFirstDisplayedColumn = function() {
      var t = this.gridOptionsWrapper.isEnableRtl(), i = [
        "getDisplayedLeftColumns",
        "getDisplayedCenterColumns",
        "getDisplayedRightColumns"
      ];
      t && i.reverse();
      for (var r = 0; r < i.length; r++) {
        var o = this[i[r]]();
        if (o.length)
          return t ? Ti(o) : o[0];
      }
      return null;
    }, or([
      T("expressionService")
    ], e.prototype, "expressionService", void 0), or([
      T("columnFactory")
    ], e.prototype, "columnFactory", void 0), or([
      T("displayedGroupCreator")
    ], e.prototype, "displayedGroupCreator", void 0), or([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), or([
      T("autoWidthCalculator")
    ], e.prototype, "autoWidthCalculator", void 0), or([
      T("columnUtils")
    ], e.prototype, "columnUtils", void 0), or([
      T("columnAnimationService")
    ], e.prototype, "columnAnimationService", void 0), or([
      T("autoGroupColService")
    ], e.prototype, "autoGroupColService", void 0), or([
      fi("aggFuncService")
    ], e.prototype, "aggFuncService", void 0), or([
      fi("valueCache")
    ], e.prototype, "valueCache", void 0), or([
      fi("animationFrameService")
    ], e.prototype, "animationFrameService", void 0), or([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), or([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), or([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), or([
      T("sortController")
    ], e.prototype, "sortController", void 0), or([
      T("columnDefFactory")
    ], e.prototype, "columnDefFactory", void 0), or([
      Le
    ], e.prototype, "init", null), or([
      y$(0, Eo("loggerFactory"))
    ], e.prototype, "setBeans", null), e = or([
      qe("columnModel")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var b$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), S$ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, FB = (
  /** @class */
  function(n) {
    b$(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.calculateColMinWidth = function(t) {
      return t.minWidth != null ? t.minWidth : this.gridOptionsWrapper.getMinColWidth();
    }, e.prototype.calculateColMaxWidth = function(t) {
      return t.maxWidth != null ? t.maxWidth : this.gridOptionsWrapper.getMaxColWidth() || Number.MAX_SAFE_INTEGER;
    }, e.prototype.calculateColInitialWidth = function(t) {
      var i = this.calculateColMinWidth(t), r = this.calculateColMaxWidth(t), o, s = ca(t.width), a = ca(t.initialWidth);
      return s != null ? o = s : a != null ? o = a : o = this.gridOptionsWrapper.getColWidth(), Math.max(Math.min(o, r), i);
    }, e.prototype.getOriginalPathForColumn = function(t, i) {
      var r = [], o = !1, s = function(a, l) {
        for (var u = 0; u < a.length; u++) {
          if (o)
            return;
          var c = a[u];
          if (c instanceof gn) {
            var h = c;
            s(h.getChildren(), l + 1), r[l] = c;
          } else
            c === t && (o = !0);
        }
      };
      return s(i, 0), o ? r : null;
    }, e.prototype.depthFirstOriginalTreeSearch = function(t, i, r) {
      var o = this;
      i && i.forEach(function(s) {
        s instanceof gn && o.depthFirstOriginalTreeSearch(s, s.getChildren(), r), r(s, t);
      });
    }, e.prototype.depthFirstAllColumnTreeSearch = function(t, i) {
      var r = this;
      t && t.forEach(function(o) {
        o instanceof Qr && r.depthFirstAllColumnTreeSearch(o.getChildren(), i), i(o);
      });
    }, e.prototype.depthFirstDisplayedColumnTreeSearch = function(t, i) {
      var r = this;
      t && t.forEach(function(o) {
        o instanceof Qr && r.depthFirstDisplayedColumnTreeSearch(o.getDisplayedChildren(), i), i(o);
      });
    }, e = S$([
      qe("columnUtils")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var E$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), L$ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, kB = (
  /** @class */
  function(n) {
    E$(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.createDisplayedGroups = function(t, i, r, o, s) {
      var a = this, l = [], u, c, h = this.mapOldGroupsById(s);
      return t.forEach(function(d) {
        for (var f = a.getOriginalPathForColumn(i, d), p = [], g = !c, _ = 0; _ < f.length; _++)
          if (g || f[_] !== c[_]) {
            var m = a.createColumnGroup(f[_], r, h, o);
            p[_] = m, _ == 0 ? l.push(m) : p[_ - 1].addChild(m);
          } else
            p[_] = u[_];
        var v = p.length === 0;
        if (v)
          l.push(d);
        else {
          var C = Ti(p);
          C.addChild(d);
        }
        u = p, c = f;
      }), this.setupParentsIntoColumns(l, null), l;
    }, e.prototype.createColumnGroup = function(t, i, r, o) {
      var s = t.getGroupId(), a = i.getInstanceIdForKey(s), l = Qr.createUniqueId(s, a), u = r[l];
      return u && u.getProvidedColumnGroup() !== t && (u = null), ge(u) ? u.reset() : (u = new Qr(t, s, a, o), this.context.createBean(u)), u;
    }, e.prototype.mapOldGroupsById = function(t) {
      var i = {}, r = function(o) {
        o.forEach(function(s) {
          if (s instanceof Qr) {
            var a = s;
            i[s.getUniqueId()] = a, r(a.getChildren());
          }
        });
      };
      return t && r(t), i;
    }, e.prototype.setupParentsIntoColumns = function(t, i) {
      var r = this;
      t.forEach(function(o) {
        if (o.setParent(i), o instanceof Qr) {
          var s = o;
          r.setupParentsIntoColumns(s.getChildren(), s);
        }
      });
    }, e.prototype.getOriginalPathForColumn = function(t, i) {
      var r = [], o = !1, s = function(a, l) {
        for (var u = 0; u < a.length; u++) {
          if (o)
            return;
          var c = a[u];
          if (c instanceof gn) {
            var h = c;
            s(h.getChildren(), l + 1), r[l] = c;
          } else
            c === i && (o = !0);
        }
      };
      return s(t, 0), o ? r : (console.warn("AG Grid: could not get path"), null);
    }, e = L$([
      qe("displayedGroupCreator")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var D$ = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, R$ = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(D$(arguments[e]));
  return n;
}, Ml = (
  /** @class */
  function() {
    function n() {
    }
    return n.STRING_PROPERTIES = [
      "sortingOrder",
      "rowClass",
      "rowSelection",
      "overlayLoadingTemplate",
      "overlayNoRowsTemplate",
      "quickFilterText",
      "rowModelType",
      "editType",
      "domLayout",
      "clipboardDelimiter",
      "rowGroupPanelShow",
      "multiSortKey",
      "pivotColumnGroupTotals",
      "pivotRowTotals",
      "pivotPanelShow",
      "fillHandleDirection",
      "serverSideStoreType",
      "groupDisplayType",
      "treeDataDisplayType"
    ], n.OBJECT_PROPERTIES = [
      "components",
      "frameworkComponents",
      "rowStyle",
      "context",
      "autoGroupColumnDef",
      "localeText",
      "icons",
      "datasource",
      "serverSideDatasource",
      "viewportDatasource",
      "groupRowRendererParams",
      "aggFuncs",
      "fullWidthCellRendererParams",
      "defaultColGroupDef",
      "defaultColDef",
      "defaultExportParams",
      "defaultCsvExportParams",
      "defaultExcelExportParams",
      "columnTypes",
      "rowClassRules",
      "detailCellRendererParams",
      "loadingCellRendererParams",
      "loadingOverlayComponentParams",
      "noRowsOverlayComponentParams",
      "popupParent",
      "colResizeDefault",
      "statusBar",
      "sideBar",
      "chartThemeOverrides",
      "customChartThemes"
    ], n.ARRAY_PROPERTIES = [
      "alignedGrids",
      "rowData",
      "columnDefs",
      "excelStyles",
      "pinnedTopRowData",
      "pinnedBottomRowData",
      "chartThemes"
    ], n.NUMBER_PROPERTIES = [
      "rowHeight",
      "detailRowHeight",
      "rowBuffer",
      "colWidth",
      "headerHeight",
      "groupHeaderHeight",
      "floatingFiltersHeight",
      "pivotHeaderHeight",
      "pivotGroupHeaderHeight",
      "groupDefaultExpanded",
      "minColWidth",
      "maxColWidth",
      "viewportRowModelPageSize",
      "viewportRowModelBufferSize",
      "autoSizePadding",
      "maxBlocksInCache",
      "maxConcurrentDatasourceRequests",
      "tooltipShowDelay",
      "tooltipHideDelay",
      "cacheOverflowSize",
      "paginationPageSize",
      "cacheBlockSize",
      "infiniteInitialRowCount",
      "scrollbarWidth",
      "batchUpdateWaitMillis",
      "asyncTransactionWaitMillis",
      "blockLoadDebounceMillis",
      "keepDetailRowsCount",
      "undoRedoCellEditingLimit",
      "cellFlashDelay",
      "cellFadeDelay",
      "tabIndex"
    ], n.BOOLEAN_PROPERTIES = [
      "suppressMakeColumnVisibleAfterUnGroup",
      "suppressRowClickSelection",
      "suppressCellSelection",
      "suppressCellFocus",
      "suppressHorizontalScroll",
      "alwaysShowHorizontalScroll",
      "alwaysShowVerticalScroll",
      "debug",
      "enableBrowserTooltips",
      "enableCellExpressions",
      "angularCompileRows",
      "angularCompileFilters",
      "groupSuppressAutoColumn",
      "groupSelectsChildren",
      "groupIncludeFooter",
      "groupIncludeTotalFooter",
      "groupUseEntireRow",
      "groupSuppressBlankHeader",
      "suppressMenuHide",
      "suppressRowDeselection",
      "unSortIcon",
      "suppressMultiSort",
      "singleClickEdit",
      "suppressLoadingOverlay",
      "suppressNoRowsOverlay",
      "suppressAutoSize",
      "skipHeaderOnAutoSize",
      "suppressParentsInRowNodes",
      "suppressColumnMoveAnimation",
      "suppressMovableColumns",
      "suppressFieldDotNotation",
      "enableRangeSelection",
      "enableRangeHandle",
      "enableFillHandle",
      "suppressClearOnFillReduction",
      "deltaSort",
      "suppressTouch",
      "suppressAsyncEvents",
      "allowContextMenuWithControlKey",
      "suppressContextMenu",
      "rememberGroupStateWhenNewData",
      "enableCellChangeFlash",
      "suppressDragLeaveHidesColumns",
      "suppressMiddleClickScrolls",
      "suppressPreventDefaultOnMouseWheel",
      "suppressCopyRowsToClipboard",
      "copyHeadersToClipboard",
      "copyGroupHeadersToClipboard",
      "pivotMode",
      "suppressAggFuncInHeader",
      "suppressColumnVirtualisation",
      "suppressAggAtRootLevel",
      "suppressFocusAfterRefresh",
      "functionsPassive",
      "functionsReadOnly",
      "animateRows",
      "groupSelectsFiltered",
      "groupRemoveSingleChildren",
      "groupRemoveLowestSingleChildren",
      "enableRtl",
      "suppressClickEdit",
      "rowDragEntireRow",
      "rowDragManaged",
      "suppressRowDrag",
      "suppressMoveWhenRowDragging",
      "rowDragMultiRow",
      "enableGroupEdit",
      "embedFullWidthRows",
      "deprecatedEmbedFullWidthRows",
      "suppressPaginationPanel",
      "groupHideOpenParents",
      "groupMultiAutoColumn",
      "pagination",
      "stopEditingWhenGridLosesFocus",
      "paginationAutoPageSize",
      "suppressScrollOnNewData",
      "suppressScrollWhenPopupsAreOpen",
      "purgeClosedRowNodes",
      "cacheQuickFilter",
      "deltaRowDataMode",
      "ensureDomOrder",
      "accentedSort",
      "suppressChangeDetection",
      "valueCache",
      "valueCacheNeverExpires",
      "aggregateOnlyChangedColumns",
      "suppressAnimationFrame",
      "suppressExcelExport",
      "suppressCsvExport",
      "treeData",
      "masterDetail",
      "suppressMultiRangeSelection",
      "enterMovesDownAfterEdit",
      "enterMovesDown",
      "suppressPropertyNamesCheck",
      "rowMultiSelectWithClick",
      "suppressEnterpriseResetOnNewColumns",
      "suppressRowHoverHighlight",
      "suppressRowTransform",
      "suppressClipboardPaste",
      "suppressLastEmptyLineOnPaste",
      "serverSideSortingAlwaysResets",
      "suppressSetColumnStateEvents",
      "suppressColumnStateEvents",
      "enableCharts",
      "deltaColumnMode",
      "suppressMaintainUnsortedOrder",
      "enableCellTextSelection",
      "suppressBrowserResizeObserver",
      "suppressMaxRenderedRowRestriction",
      "excludeChildrenWhenTreeDataFiltering",
      "tooltipMouseTrack",
      "keepDetailRows",
      "paginateChildRows",
      "preventDefaultOnContextMenu",
      "undoRedoCellEditing",
      "allowDragFromColumnsToolPanel",
      "immutableData",
      "immutableColumns",
      "pivotSuppressAutoColumn",
      "suppressExpandablePivotGroups",
      "applyColumnDefOrder",
      "debounceVerticalScrollbar",
      "detailRowAutoHeight",
      "serverSideFilteringAlwaysResets",
      "suppressAggFilteredOnly",
      "showOpenedGroup",
      "suppressClipboardApi",
      "suppressModelUpdateAfterUpdateTransaction",
      "stopEditingWhenCellsLoseFocus",
      "maintainColumnOrder",
      "groupMaintainOrder",
      "columnHoverHighlight",
      "reactUi",
      "suppressReactUi",
      "readOnlyEdit",
      "suppressRowVirtualisation"
    ], n.FUNCTION_PROPERTIES = [
      "localeTextFunc",
      "groupRowInnerRenderer",
      "groupRowInnerRendererFramework",
      "groupRowRenderer",
      "groupRowRendererFramework",
      "isExternalFilterPresent",
      "getRowHeight",
      "doesExternalFilterPass",
      "getRowClass",
      "getRowStyle",
      "getContextMenuItems",
      "getMainMenuItems",
      "processRowPostCreate",
      "processCellForClipboard",
      "groupRowAggNodes",
      "getRowNodeId",
      "isFullWidthCell",
      "fullWidthCellRenderer",
      "fullWidthCellRendererFramework",
      "processSecondaryColDef",
      "processSecondaryColGroupDef",
      "getBusinessKeyForNode",
      "sendToClipboard",
      "navigateToNextHeader",
      "tabToNextHeader",
      "navigateToNextCell",
      "tabToNextCell",
      "processCellFromClipboard",
      "getDocument",
      "postProcessPopup",
      "getChildCount",
      "getDataPath",
      "loadingCellRenderer",
      "loadingCellRendererFramework",
      "loadingOverlayComponent",
      "loadingOverlayComponentFramework",
      "noRowsOverlayComponent",
      "noRowsOverlayComponentFramework",
      "detailCellRenderer",
      "detailCellRendererFramework",
      "isRowMaster",
      "isRowSelectable",
      "postSort",
      "processHeaderForClipboard",
      "processGroupHeaderForClipboard",
      "paginationNumberFormatter",
      "processDataFromClipboard",
      "getServerSideGroupKey",
      "isServerSideGroup",
      "suppressKeyboardEvent",
      "createChartContainer",
      "getChartToolbarItems",
      "fillOperation",
      "isApplyServerSideTransaction",
      "getServerSideStoreParams",
      "isServerSideGroupOpenByDefault",
      "isGroupOpenByDefault",
      "defaultGroupSortComparator",
      "defaultGroupOrderComparator",
      "loadingCellRendererSelector",
      "getRowId"
    ], n.ALL_PROPERTIES = R$(n.ARRAY_PROPERTIES, n.OBJECT_PROPERTIES, n.STRING_PROPERTIES, n.NUMBER_PROPERTIES, n.FUNCTION_PROPERTIES, n.BOOLEAN_PROPERTIES), n.FRAMEWORK_PROPERTIES = [
      "__ob__",
      "__v_skip",
      "__metadata__",
      "mappedColumnProperties",
      "hasChildColumns",
      "toColDef",
      "createColDefFromGridColumn"
    ], n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var G1 = globalThis && globalThis.__assign || function() {
  return G1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, G1.apply(this, arguments);
}, T$ = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, MM = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(T$(arguments[e]));
  return n;
}, Xc = (
  /** @class */
  function() {
    function n() {
    }
    return n.getEventCallbacks = function() {
      return n.EVENT_CALLBACKS || (n.EVENT_CALLBACKS = n.EVENTS.map(function(e) {
        return n.getCallbackForEvent(e);
      })), n.EVENT_CALLBACKS;
    }, n.copyAttributesToGridOptions = function(e, t, i) {
      typeof e != "object" && (e = {});
      var r = e, o = function(s) {
        return typeof t[s] < "u";
      };
      return MM(n.ARRAY_PROPERTIES, n.STRING_PROPERTIES, n.OBJECT_PROPERTIES, n.FUNCTION_PROPERTIES, n.getEventCallbacks()).filter(o).forEach(function(s) {
        return r[s] = t[s];
      }), n.BOOLEAN_PROPERTIES.filter(o).forEach(function(s) {
        return r[s] = n.toBoolean(t[s]);
      }), n.NUMBER_PROPERTIES.filter(o).forEach(function(s) {
        return r[s] = n.toNumber(t[s]);
      }), e;
    }, n.getCallbackForEvent = function(e) {
      return !e || e.length < 2 ? e : "on" + e[0].toUpperCase() + e.substr(1);
    }, n.processOnChange = function(e, t, i, r) {
      if (e) {
        var o = G1({}, e), s = t, a = function(c) {
          return o[c];
        };
        MM(n.ARRAY_PROPERTIES, n.OBJECT_PROPERTIES, n.STRING_PROPERTIES, n.getEventCallbacks()).filter(a).forEach(function(c) {
          return s[c] = o[c].currentValue;
        }), n.BOOLEAN_PROPERTIES.filter(a).forEach(function(c) {
          return s[c] = n.toBoolean(o[c].currentValue);
        }), n.NUMBER_PROPERTIES.filter(a).forEach(function(c) {
          return s[c] = n.toNumber(o[c].currentValue);
        }), o.enableCellTextSelection && (i.setEnableCellTextSelection(n.toBoolean(o.enableCellTextSelection.currentValue)), delete o.enableCellTextSelection), o.quickFilterText && (i.setQuickFilter(o.quickFilterText.currentValue), delete o.quickFilterText), o.autoGroupColumnDef && (i.setAutoGroupColumnDef(o.autoGroupColumnDef.currentValue, "gridOptionsChanged"), delete o.autoGroupColumnDef), o.columnDefs && (i.setColumnDefs(o.columnDefs.currentValue, "gridOptionsChanged"), delete o.columnDefs), o.defaultColDef && (i.setDefaultColDef(o.defaultColDef.currentValue, "gridOptionsChanged"), delete o.defaultColDef), o.paginationPageSize && (i.paginationSetPageSize(n.toNumber(o.paginationPageSize.currentValue)), delete o.paginationPageSize), o.pivotMode && (r.setPivotMode(n.toBoolean(o.pivotMode.currentValue)), delete o.pivotMode), o.groupRemoveSingleChildren && (i.setGroupRemoveSingleChildren(n.toBoolean(o.groupRemoveSingleChildren.currentValue)), delete o.groupRemoveSingleChildren), o.suppressRowDrag && (i.setSuppressRowDrag(n.toBoolean(o.suppressRowDrag.currentValue)), delete o.suppressRowDrag), o.suppressMoveWhenRowDragging && (i.setSuppressMoveWhenRowDragging(n.toBoolean(o.suppressMoveWhenRowDragging.currentValue)), delete o.suppressMoveWhenRowDragging), o.suppressRowClickSelection && (i.setSuppressRowClickSelection(n.toBoolean(o.suppressRowClickSelection.currentValue)), delete o.suppressRowClickSelection), o.suppressClipboardPaste && (i.setSuppressClipboardPaste(n.toBoolean(o.suppressClipboardPaste.currentValue)), delete o.suppressClipboardPaste), o.headerHeight && (i.setHeaderHeight(n.toNumber(o.headerHeight.currentValue)), delete o.headerHeight);
        var l = i;
        Object.keys(o).forEach(function(c) {
          var h = "set" + c.charAt(0).toUpperCase() + c.substring(1);
          l[h] && l[h](e[c].currentValue);
        });
        var u = {
          type: F.EVENT_COMPONENT_STATE_CHANGED,
          api: t.api,
          columnApi: t.columnApi
        };
        pi(e, function(c, h) {
          u[c] = h;
        }), i.dispatchEvent(u);
      }
    }, n.toBoolean = function(e) {
      return typeof e == "boolean" ? e : typeof e == "string" ? e.toUpperCase() === "TRUE" || e == "" : !1;
    }, n.toNumber = function(e) {
      if (typeof e == "number")
        return e;
      if (typeof e == "string")
        return Number(e);
    }, n.EVENTS = [], n.PUBLIC_EVENTS = [], n.EXCLUDED_INTERNAL_EVENTS = [], n.STRING_PROPERTIES = Ml.STRING_PROPERTIES, n.OBJECT_PROPERTIES = Ml.OBJECT_PROPERTIES, n.ARRAY_PROPERTIES = Ml.ARRAY_PROPERTIES, n.NUMBER_PROPERTIES = Ml.NUMBER_PROPERTIES, n.BOOLEAN_PROPERTIES = Ml.BOOLEAN_PROPERTIES, n.FUNCTION_PROPERTIES = Ml.FUNCTION_PROPERTIES, n.ALL_PROPERTIES = Ml.ALL_PROPERTIES, n;
  }()
);
Xc.EVENTS = ef(F);
Xc.EXCLUDED_INTERNAL_EVENTS = [
  F.EVENT_SCROLLBAR_WIDTH_CHANGED,
  F.EVENT_CHECKBOX_CHANGED,
  F.EVENT_HEIGHT_SCALE_CHANGED,
  F.EVENT_BODY_HEIGHT_CHANGED,
  F.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,
  F.EVENT_SCROLL_VISIBILITY_CHANGED,
  F.EVENT_COLUMN_HOVER_CHANGED,
  F.EVENT_FLASH_CELLS,
  F.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED,
  F.EVENT_DISPLAYED_ROWS_CHANGED,
  F.EVENT_LEFT_PINNED_WIDTH_CHANGED,
  F.EVENT_RIGHT_PINNED_WIDTH_CHANGED,
  F.EVENT_ROW_CONTAINER_HEIGHT_CHANGED,
  F.EVENT_POPUP_TO_FRONT,
  F.EVENT_KEYBOARD_FOCUS,
  F.EVENT_MOUSE_FOCUS,
  F.EVENT_STORE_UPDATED,
  F.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
  F.EVENT_COLUMN_PANEL_ITEM_DRAG_END,
  F.EVENT_FILL_START,
  F.EVENT_FILL_END
];
Xc.PUBLIC_EVENTS = Xc.EVENTS.filter(function(n) {
  return !Es(Xc.EXCLUDED_INTERNAL_EVENTS, n);
});
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var O$ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), x$ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, WB = (
  /** @class */
  function(n) {
    O$(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.componentsMappedByName = {}, t;
    }
    return e.prototype.setupComponents = function(t) {
      var i = this;
      t && t.forEach(function(r) {
        return i.addComponent(r);
      });
    }, e.prototype.addComponent = function(t) {
      var i = t.componentName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), r = i.toUpperCase();
      this.componentsMappedByName[r] = t.componentClass;
    }, e.prototype.getComponentClass = function(t) {
      return this.componentsMappedByName[t];
    }, e = x$([
      qe("agStackComponentsRegistry")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var N$ = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, I$ = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(N$(arguments[e]));
  return n;
}, U1 = (
  /** @class */
  function() {
    function n() {
    }
    return n.STRING_PROPERTIES = [
      "headerName",
      "columnGroupShow",
      "headerClass",
      "toolPanelClass",
      "headerValueGetter",
      "pivotKeys",
      "groupId",
      "colId",
      "sort",
      "initialSort",
      "field",
      "type",
      "tooltipComponent",
      "tooltipField",
      "headerTooltip",
      "cellClass",
      "showRowGroup",
      "template",
      "templateUrl",
      "filter",
      "initialAggFunc",
      "aggFunc",
      "pinned",
      "initialPinned",
      "chartDataType",
      "cellEditorPopupPosition"
    ], n.OBJECT_PROPERTIES = [
      "headerGroupComponent",
      "headerGroupComponentFramework",
      "headerGroupComponentParams",
      "cellStyle",
      "cellRenderer",
      "cellRendererParams",
      "cellRendererFramework",
      "cellEditor",
      "cellEditorFramework",
      "cellEditorParams",
      "pinnedRowCellRendererFramework",
      "pinnedRowCellRendererParams",
      "filterFramework",
      "filterParams",
      "pivotValueColumn",
      "headerComponent",
      "headerComponentFramework",
      "headerComponentParams",
      "floatingFilterComponent",
      "floatingFilterComponentParams",
      "floatingFilterComponentFramework",
      "floatingFilterFramework",
      "tooltipComponent",
      "tooltipComponentParams",
      "tooltipComponentFramework",
      "refData",
      "columnsMenuParams"
    ], n.ARRAY_PROPERTIES = [
      "children",
      "sortingOrder",
      "allowedAggFuncs",
      "menuTabs",
      "pivotTotalColumnIds",
      "cellClassRules",
      "icons"
    ], n.NUMBER_PROPERTIES = [
      "sortedAt",
      "sortIndex",
      "initialSortIndex",
      "flex",
      "initialFlex",
      "width",
      "initialWidth",
      "minWidth",
      "maxWidth",
      "rowGroupIndex",
      "initialRowGroupIndex",
      "pivotIndex",
      "initialPivotIndex"
    ], n.BOOLEAN_PROPERTIES = [
      "suppressCellFlash",
      "suppressColumnsToolPanel",
      "suppressFiltersToolPanel",
      "openByDefault",
      "marryChildren",
      "hide",
      "initialHide",
      "rowGroup",
      "initialRowGroup",
      "pivot",
      "initialPivot",
      "checkboxSelection",
      "headerCheckboxSelection",
      "headerCheckboxSelectionFilteredOnly",
      "suppressMenu",
      "suppressMovable",
      "lockPosition",
      "lockVisible",
      "lockPinned",
      "unSortIcon",
      "suppressSizeToFit",
      "suppressAutoSize",
      "enableRowGroup",
      "enablePivot",
      "enableValue",
      "editable",
      "suppressPaste",
      "suppressNavigable",
      "enableCellChangeFlash",
      "rowDrag",
      "dndSource",
      "autoHeight",
      "wrapText",
      "sortable",
      "resizable",
      "singleClickEdit",
      "floatingFilter",
      "cellEditorPopup",
      "suppressFillHandle"
    ], n.FUNCTION_PROPERTIES = [
      "dndSourceOnRowDrag",
      "valueGetter",
      "valueSetter",
      "filterValueGetter",
      "keyCreator",
      "pinnedRowCellRenderer",
      "valueFormatter",
      "pinnedRowValueFormatter",
      "valueParser",
      "comparator",
      "equals",
      "pivotComparator",
      "suppressKeyboardEvent",
      "suppressHeaderKeyboardEvent",
      "colSpan",
      "rowSpan",
      "getQuickFilterText",
      "newValueHandler",
      "onCellValueChanged",
      "onCellClicked",
      "onCellDoubleClicked",
      "onCellContextMenu",
      "rowDragText",
      "tooltipValueGetter",
      "tooltipComponent",
      "tooltipComponentFramework",
      "cellRendererSelector",
      "cellEditorSelector"
    ], n.ALL_PROPERTIES = I$(n.ARRAY_PROPERTIES, n.OBJECT_PROPERTIES, n.STRING_PROPERTIES, n.NUMBER_PROPERTIES, n.FUNCTION_PROPERTIES, n.BOOLEAN_PROPERTIES), n.FRAMEWORK_PROPERTIES = [
      "__ob__",
      "__v_skip",
      "__metadata__",
      "mappedColumnProperties",
      "hasChildColumns",
      "toColDef",
      "createColDefFromGridColumn"
    ], n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var FM = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, zf = (
  /** @class */
  function() {
    function n(e, t, i, r) {
      r === void 0 && (r = 1), this.r = Math.min(1, Math.max(0, e || 0)), this.g = Math.min(1, Math.max(0, t || 0)), this.b = Math.min(1, Math.max(0, i || 0)), this.a = Math.min(1, Math.max(0, r || 0));
    }
    return n.fromString = function(e) {
      if (e.indexOf("#") >= 0)
        return n.fromHexString(e);
      var t = n.nameToHex[e];
      if (t)
        return n.fromHexString(t);
      if (e.indexOf("rgb") >= 0)
        return n.fromRgbaString(e);
      throw new Error("Invalid color string: '" + e + "'");
    }, n.parseHex = function(e) {
      e = e.replace(/ /g, "").slice(1);
      var t;
      switch (e.length) {
        case 6:
        case 8:
          t = [];
          for (var i = 0; i < e.length; i += 2)
            t.push(parseInt("" + e[i] + e[i + 1], 16));
          break;
        case 3:
        case 4:
          t = e.split("").map(function(r) {
            return parseInt(r, 16);
          }).map(function(r) {
            return r + r * 16;
          });
          break;
      }
      if (t.length >= 3 && t.every(function(r) {
        return r >= 0;
      }))
        return t.length === 3 && t.push(255), t;
    }, n.fromHexString = function(e) {
      var t = n.parseHex(e);
      if (t) {
        var i = FM(t, 4), r = i[0], o = i[1], s = i[2], a = i[3];
        return new n(r / 255, o / 255, s / 255, a / 255);
      }
      throw new Error("Malformed hexadecimal color string: '" + e + "'");
    }, n.stringToRgba = function(e) {
      for (var t = FM([NaN, NaN], 2), i = t[0], r = t[1], o = 0; o < e.length; o++) {
        var s = e[o];
        if (!i && s === "(")
          i = o;
        else if (s === ")") {
          r = o;
          break;
        }
      }
      var a = i && r && e.substring(i + 1, r);
      if (a) {
        for (var l = a.split(","), u = [], o = 0; o < l.length; o++) {
          var c = l[o], h = parseFloat(c);
          if (isNaN(h))
            return;
          c.indexOf("%") >= 0 ? (h = Math.max(0, Math.min(100, h)), h /= 100) : o === 3 ? h = Math.max(0, Math.min(1, h)) : (h = Math.max(0, Math.min(255, h)), h /= 255), u.push(h);
        }
        return u;
      }
    }, n.fromRgbaString = function(e) {
      var t = n.stringToRgba(e);
      if (t) {
        if (t.length === 3)
          return new n(t[0], t[1], t[2]);
        if (t.length === 4)
          return new n(t[0], t[1], t[2], t[3]);
      }
      throw new Error("Malformed rgb/rgba color string: '" + e + "'");
    }, n.fromArray = function(e) {
      if (e.length === 4)
        return new n(e[0], e[1], e[2], e[3]);
      if (e.length === 3)
        return new n(e[0], e[1], e[2]);
      throw new Error("The given array should contain 3 or 4 color components (numbers).");
    }, n.fromHSB = function(e, t, i, r) {
      r === void 0 && (r = 1);
      var o = n.HSBtoRGB(e, t, i);
      return new n(o[0], o[1], o[2], r);
    }, n.padHex = function(e) {
      return e.length === 1 ? "0" + e : e;
    }, n.prototype.toHexString = function() {
      var e = "#" + n.padHex(Math.round(this.r * 255).toString(16)) + n.padHex(Math.round(this.g * 255).toString(16)) + n.padHex(Math.round(this.b * 255).toString(16));
      return this.a < 1 && (e += n.padHex(Math.round(this.a * 255).toString(16))), e;
    }, n.prototype.toRgbaString = function(e) {
      e === void 0 && (e = 3);
      var t = [
        Math.round(this.r * 255),
        Math.round(this.g * 255),
        Math.round(this.b * 255)
      ], i = Math.pow(10, e);
      return this.a !== 1 ? (t.push(Math.round(this.a * i) / i), "rgba(" + t.join(", ") + ")") : "rgb(" + t.join(", ") + ")";
    }, n.prototype.toString = function() {
      return this.a === 1 ? this.toHexString() : this.toRgbaString();
    }, n.prototype.toHSB = function() {
      return n.RGBtoHSB(this.r, this.g, this.b);
    }, n.RGBtoHSB = function(e, t, i) {
      var r = Math.min(e, t, i), o = Math.max(e, t, i), s = o !== 0 ? (o - r) / o : 0, a = NaN;
      if (r !== o) {
        var l = o - r, u = (o - e) / l, c = (o - t) / l, h = (o - i) / l;
        e === o ? a = h - c : t === o ? a = 2 + u - h : a = 4 + c - u, a /= 6, a < 0 && (a = a + 1);
      }
      return [a * 360, s, o];
    }, n.HSBtoRGB = function(e, t, i) {
      isNaN(e) && (e = 0), e = (e % 360 + 360) % 360 / 360;
      var r = 0, o = 0, s = 0;
      if (t === 0)
        r = o = s = i;
      else {
        var a = (e - Math.floor(e)) * 6, l = a - Math.floor(a), u = i * (1 - t), c = i * (1 - t * l), h = i * (1 - t * (1 - l));
        switch (a >> 0) {
          case 0:
            r = i, o = h, s = u;
            break;
          case 1:
            r = c, o = i, s = u;
            break;
          case 2:
            r = u, o = i, s = h;
            break;
          case 3:
            r = u, o = c, s = i;
            break;
          case 4:
            r = h, o = u, s = i;
            break;
          case 5:
            r = i, o = u, s = c;
            break;
        }
      }
      return [r, o, s];
    }, n.prototype.derive = function(e, t, i, r) {
      var o = n.RGBtoHSB(this.r, this.g, this.b), s = o[2];
      s == 0 && i > 1 && (s = 0.05);
      var a = ((o[0] + e) % 360 + 360) % 360, l = Math.max(Math.min(o[1] * t, 1), 0);
      s = Math.max(Math.min(s * i, 1), 0);
      var u = Math.max(Math.min(this.a * r, 1), 0), c = n.HSBtoRGB(a, l, s);
      return c.push(u), n.fromArray(c);
    }, n.prototype.brighter = function() {
      return this.derive(0, 1, 1 / 0.7, 1);
    }, n.prototype.darker = function() {
      return this.derive(0, 1, 0.7, 1);
    }, n.nameToHex = Object.freeze({
      aliceblue: "#F0F8FF",
      antiquewhite: "#FAEBD7",
      aqua: "#00FFFF",
      aquamarine: "#7FFFD4",
      azure: "#F0FFFF",
      beige: "#F5F5DC",
      bisque: "#FFE4C4",
      black: "#000000",
      blanchedalmond: "#FFEBCD",
      blue: "#0000FF",
      blueviolet: "#8A2BE2",
      brown: "#A52A2A",
      burlywood: "#DEB887",
      cadetblue: "#5F9EA0",
      chartreuse: "#7FFF00",
      chocolate: "#D2691E",
      coral: "#FF7F50",
      cornflowerblue: "#6495ED",
      cornsilk: "#FFF8DC",
      crimson: "#DC143C",
      cyan: "#00FFFF",
      darkblue: "#00008B",
      darkcyan: "#008B8B",
      darkgoldenrod: "#B8860B",
      darkgray: "#A9A9A9",
      darkgreen: "#006400",
      darkgrey: "#A9A9A9",
      darkkhaki: "#BDB76B",
      darkmagenta: "#8B008B",
      darkolivegreen: "#556B2F",
      darkorange: "#FF8C00",
      darkorchid: "#9932CC",
      darkred: "#8B0000",
      darksalmon: "#E9967A",
      darkseagreen: "#8FBC8F",
      darkslateblue: "#483D8B",
      darkslategray: "#2F4F4F",
      darkslategrey: "#2F4F4F",
      darkturquoise: "#00CED1",
      darkviolet: "#9400D3",
      deeppink: "#FF1493",
      deepskyblue: "#00BFFF",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1E90FF",
      firebrick: "#B22222",
      floralwhite: "#FFFAF0",
      forestgreen: "#228B22",
      fuchsia: "#FF00FF",
      gainsboro: "#DCDCDC",
      ghostwhite: "#F8F8FF",
      gold: "#FFD700",
      goldenrod: "#DAA520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#ADFF2F",
      grey: "#808080",
      honeydew: "#F0FFF0",
      hotpink: "#FF69B4",
      indianred: "#CD5C5C",
      indigo: "#4B0082",
      ivory: "#FFFFF0",
      khaki: "#F0E68C",
      lavender: "#E6E6FA",
      lavenderblush: "#FFF0F5",
      lawngreen: "#7CFC00",
      lemonchiffon: "#FFFACD",
      lightblue: "#ADD8E6",
      lightcoral: "#F08080",
      lightcyan: "#E0FFFF",
      lightgoldenrodyellow: "#FAFAD2",
      lightgray: "#D3D3D3",
      lightgreen: "#90EE90",
      lightgrey: "#D3D3D3",
      lightpink: "#FFB6C1",
      lightsalmon: "#FFA07A",
      lightseagreen: "#20B2AA",
      lightskyblue: "#87CEFA",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#B0C4DE",
      lightyellow: "#FFFFE0",
      lime: "#00FF00",
      limegreen: "#32CD32",
      linen: "#FAF0E6",
      magenta: "#FF00FF",
      maroon: "#800000",
      mediumaquamarine: "#66CDAA",
      mediumblue: "#0000CD",
      mediumorchid: "#BA55D3",
      mediumpurple: "#9370DB",
      mediumseagreen: "#3CB371",
      mediumslateblue: "#7B68EE",
      mediumspringgreen: "#00FA9A",
      mediumturquoise: "#48D1CC",
      mediumvioletred: "#C71585",
      midnightblue: "#191970",
      mintcream: "#F5FFFA",
      mistyrose: "#FFE4E1",
      moccasin: "#FFE4B5",
      navajowhite: "#FFDEAD",
      navy: "#000080",
      oldlace: "#FDF5E6",
      olive: "#808000",
      olivedrab: "#6B8E23",
      orange: "#FFA500",
      orangered: "#FF4500",
      orchid: "#DA70D6",
      palegoldenrod: "#EEE8AA",
      palegreen: "#98FB98",
      paleturquoise: "#AFEEEE",
      palevioletred: "#DB7093",
      papayawhip: "#FFEFD5",
      peachpuff: "#FFDAB9",
      peru: "#CD853F",
      pink: "#FFC0CB",
      plum: "#DDA0DD",
      powderblue: "#B0E0E6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#FF0000",
      rosybrown: "#BC8F8F",
      royalblue: "#4169E1",
      saddlebrown: "#8B4513",
      salmon: "#FA8072",
      sandybrown: "#F4A460",
      seagreen: "#2E8B57",
      seashell: "#FFF5EE",
      sienna: "#A0522D",
      silver: "#C0C0C0",
      skyblue: "#87CEEB",
      slateblue: "#6A5ACD",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#FFFAFA",
      springgreen: "#00FF7F",
      steelblue: "#4682B4",
      tan: "#D2B48C",
      teal: "#008080",
      thistle: "#D8BFD8",
      tomato: "#FF6347",
      turquoise: "#40E0D0",
      violet: "#EE82EE",
      wheat: "#F5DEB3",
      white: "#FFFFFF",
      whitesmoke: "#F5F5F5",
      yellow: "#FFFF00",
      yellowgreen: "#9ACD32"
    }), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function VB(n, e) {
  e === void 0 && (e = ",");
  var t = [], i = function(d) {
    return d === "\r" || d === `
`;
  }, r = !1;
  if (n === "")
    return [[""]];
  for (var o = function(d, f, p) {
    var g = n[p - 1], _ = n[p], m = n[p + 1], v = function() {
      t[d] || (t[d] = []), t[d][f] || (t[d][f] = "");
    };
    if (v(), _ === '"') {
      if (r)
        return m === '"' ? (t[d][f] += '"', p++) : r = !1, s = d, a = f, l = p, "continue";
      if (g === void 0 || g === e || i(g))
        return r = !0, s = d, a = f, l = p, "continue";
    }
    if (!r) {
      if (_ === e)
        return f++, v(), s = d, a = f, l = p, "continue";
      if (i(_))
        return f = 0, d++, v(), _ === "\r" && m === `
` && p++, s = d, a = f, l = p, "continue";
    }
    t[d][f] += _, s = d, a = f, l = p;
  }, s, a, l, u = 0, c = 0, h = 0; h < n.length; h++)
    o(u, c, h), u = s, c = a, h = l;
  return t;
}
const P$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  stringToArray: VB
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var A$ = globalThis && globalThis.__values || function(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], i = 0;
  if (t)
    return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function() {
        return n && i >= n.length && (n = void 0), { value: n && n[i++], done: !n };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, cL, hL, dL, fL, pL, gL, z1, j1;
function M$() {
  return hL === void 0 && (hL = /*@cc_on!@*/
  !!document.documentMode), hL;
}
function RS() {
  return dL === void 0 && (dL = !M$() && !!window.StyleMedia), dL;
}
function TS() {
  return cL === void 0 && (cL = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), cL;
}
function O_() {
  if (fL === void 0) {
    var n = window;
    fL = !!n.chrome && (!!n.chrome.webstore || !!n.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }
  return fL;
}
function Cx() {
  if (pL === void 0) {
    var n = window;
    pL = typeof n.InstallTrigger < "u";
  }
  return pL;
}
function Cg() {
  return gL === void 0 && (gL = (/iPad|iPhone|iPod/.test(navigator.platform) || // eslint-disable-next-line
  navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // @ts-ignore
  !window.MSStream), gL;
}
function Hw(n) {
  if (!n)
    return null;
  var e = n.tabIndex, t = n.getAttribute("tabIndex");
  return e === -1 && (t === null || t === "" && !Cx()) ? null : e.toString();
}
function BB() {
  if (!document.body)
    return -1;
  var n = 1e6, e = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9, t = document.createElement("div");
  for (document.body.appendChild(t); ; ) {
    var i = n * 2;
    if (t.style.height = i + "px", i > e || t.clientHeight !== i)
      break;
    n = i;
  }
  return document.body.removeChild(t), n;
}
function HB() {
  return j1 == null && GB(), j1;
}
function GB() {
  var n = document.body, e = document.createElement("div");
  e.style.width = e.style.height = "100px", e.style.opacity = "0", e.style.overflow = "scroll", e.style.msOverflowStyle = "scrollbar", e.style.position = "absolute", n.appendChild(e);
  var t = e.offsetWidth - e.clientWidth;
  t === 0 && e.clientWidth === 0 && (t = null), e.parentNode && e.parentNode.removeChild(e), t != null && (j1 = t, z1 = t === 0);
}
function UB() {
  return z1 == null && GB(), z1;
}
function F$() {
  var n, e, t = ["webkit", "moz", "o", "ms"], i = document.createElement("div"), r = document.getElementsByTagName("body")[0], o = !1, s;
  r.appendChild(i), i.setAttribute("style", t.map(function(c) {
    return "-" + c + "-overflow-scrolling: touch";
  }).concat("overflow-scrolling: touch").join(";"));
  var a = window.getComputedStyle(i);
  if (a.overflowScrolling === "touch" && (o = !0), !o)
    try {
      for (var l = A$(t), u = l.next(); !u.done; u = l.next())
        if (s = u.value, a[s + "OverflowScrolling"] === "touch") {
          o = !0;
          break;
        }
    } catch (c) {
      n = { error: c };
    } finally {
      try {
        u && !u.done && (e = l.return) && e.call(l);
      } finally {
        if (n)
          throw n.error;
      }
    }
  return i.parentNode && i.parentNode.removeChild(i), o;
}
function zB() {
  return document.body ? document.body.clientWidth : window.innerHeight ? window.innerWidth : document.documentElement && document.documentElement.clientWidth ? document.documentElement.clientWidth : -1;
}
function jB() {
  return document.body ? document.body.clientHeight : window.innerHeight ? window.innerHeight : document.documentElement && document.documentElement.clientHeight ? document.documentElement.clientHeight : -1;
}
const k$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getBodyHeight: jB,
  getBodyWidth: zB,
  getMaxDivHeight: BB,
  getScrollbarWidth: HB,
  getTabIndex: Hw,
  hasOverflowScrolling: F$,
  isBrowserChrome: O_,
  isBrowserEdge: RS,
  isBrowserFirefox: Cx,
  isBrowserSafari: TS,
  isIOSUserAgent: Cg,
  isInvisibleScrollbar: UB
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var FC;
function W$(n, e, t) {
  for (var i = n.parentElement, r = i && i.firstChild; r; )
    e && r.classList.toggle(e, r === n), t && r.classList.toggle(t, r !== n), r = r.nextSibling;
}
function $B(n) {
  var e = Element.prototype.matches || Element.prototype.msMatchesSelector, t = e.call(n, Z.INPUT_SELECTOR), i = e.call(n, Z.FOCUSABLE_EXCLUDE), r = wg(n), o = t && !i && r;
  return o;
}
function Bi(n, e) {
  n.classList.toggle("ag-hidden", !e);
}
function KB(n, e) {
  n.classList.toggle("ag-invisible", !e);
}
function jp(n, e) {
  var t = "disabled", i = e ? function(r) {
    return r.setAttribute(t, "");
  } : function(r) {
    return r.removeAttribute(t);
  };
  i(n), Lx(n.querySelectorAll("input"), function(r) {
    return i(r);
  });
}
function OS(n, e, t) {
  for (var i = 0; n; ) {
    if (n.classList.contains(e))
      return !0;
    if (n = n.parentElement, t && ++i > t)
      break;
  }
  return !1;
}
function yg(n) {
  var e = window.getComputedStyle(n), t = e.height, i = e.width, r = e.paddingTop, o = e.paddingRight, s = e.paddingBottom, a = e.paddingLeft, l = e.marginTop, u = e.marginRight, c = e.marginBottom, h = e.marginLeft, d = e.boxSizing;
  return {
    height: parseFloat(t),
    width: parseFloat(i),
    paddingTop: parseFloat(r),
    paddingRight: parseFloat(o),
    paddingBottom: parseFloat(s),
    paddingLeft: parseFloat(a),
    marginTop: parseFloat(l),
    marginRight: parseFloat(u),
    marginBottom: parseFloat(c),
    marginLeft: parseFloat(h),
    boxSizing: d
  };
}
function x_(n) {
  var e = yg(n);
  return e.boxSizing === "border-box" ? e.height - e.paddingTop - e.paddingBottom : e.height;
}
function xS(n) {
  var e = yg(n);
  return e.boxSizing === "border-box" ? e.width - e.paddingLeft - e.paddingRight : e.width;
}
function yx(n) {
  var e = yg(n), t = e.marginBottom + e.marginTop;
  return Math.ceil(n.offsetHeight + t);
}
function NS(n) {
  var e = yg(n), t = e.marginLeft + e.marginRight;
  return Math.ceil(n.offsetWidth + t);
}
function Gv() {
  if (typeof FC == "boolean")
    return FC;
  var n = document.createElement("div");
  return n.style.direction = "rtl", n.style.width = "1px", n.style.height = "1px", n.style.position = "fixed", n.style.top = "0px", n.style.overflow = "hidden", n.dir = "rtl", n.innerHTML = /* html */
  `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`, document.body.appendChild(n), n.scrollLeft = 1, FC = Math.floor(n.scrollLeft) === 0, document.body.removeChild(n), FC;
}
function Uv(n, e) {
  var t = n.scrollLeft;
  return e && (t = Math.abs(t), O_() && !Gv() && (t = n.scrollWidth - n.clientWidth - t)), t;
}
function Gw(n, e, t) {
  t && (Gv() ? e *= -1 : (TS() || O_()) && (e = n.scrollWidth - n.clientWidth - e)), n.scrollLeft = e;
}
function Ls(n) {
  for (; n && n.firstChild; )
    n.removeChild(n.firstChild);
}
function V$(n, e) {
  za(n.querySelector(e));
}
function za(n) {
  n && n.parentNode && n.parentNode.removeChild(n);
}
function wg(n) {
  return n.offsetParent !== null;
}
function Tr(n) {
  if (DOMParser !== null) {
    var e = new DOMParser(), t = e.parseFromString(n, "text/html");
    return t.body.firstChild;
  }
  var i = document.createElement("div");
  return i.innerHTML = (n || "").trim(), i.firstChild;
}
function B$(n, e) {
  n.lastChild ? n.insertAdjacentHTML("afterbegin", e) : n.innerHTML = e;
}
function H$(n, e) {
  if (n.attributes && n.attributes[e]) {
    var t = n.attributes[e];
    return t.value;
  }
  return null;
}
function $1(n) {
  return n && n.clientHeight ? n.clientHeight : 0;
}
function K1(n) {
  return n && n.clientWidth ? n.clientWidth : 0;
}
function wx(n, e, t) {
  t && t.nextSibling === e || (t ? t.nextSibling ? n.insertBefore(e, t.nextSibling) : n.appendChild(e) : n.firstChild && n.firstChild !== e && n.insertAdjacentElement("afterbegin", e));
}
function bx(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t], r = n.children[t];
    r !== i && n.insertBefore(i, r);
  }
}
function qB(n, e, t) {
  t ? t.insertAdjacentElement("afterend", e) : n.firstChild ? n.insertAdjacentElement("afterbegin", e) : n.appendChild(e);
}
function G$(n, e) {
  ge(n.firstChild) ? n.insertBefore(e, n.firstChild) : n.appendChild(e);
}
function Sx(n, e) {
  e && Object.keys(e).forEach(function(t) {
    var i = AB(t);
    i && (n.style[i] = e[t]);
  });
}
function q1(n) {
  return n.clientWidth < n.scrollWidth;
}
function YB(n) {
  return n.clientHeight < n.scrollHeight;
}
function N_(n, e) {
  e === "flex" ? (n.style.removeProperty("width"), n.style.removeProperty("minWidth"), n.style.removeProperty("maxWidth"), n.style.flex = "1 1 auto") : Yl(n, e);
}
function Yl(n, e) {
  e = Ex(e), n.style.width = e.toString(), n.style.maxWidth = e.toString(), n.style.minWidth = e.toString();
}
function U$(n, e) {
  e === "flex" ? (n.style.removeProperty("height"), n.style.removeProperty("minHeight"), n.style.removeProperty("maxHeight"), n.style.flex = "1 1 auto") : yd(n, e);
}
function yd(n, e) {
  e = Ex(e), n.style.height = e.toString(), n.style.maxHeight = e.toString(), n.style.minHeight = e.toString();
}
function Ex(n) {
  return typeof n == "number" ? n + "px" : n;
}
function XB(n) {
  return typeof Node == "function" ? n instanceof Node : n && typeof n == "object" && typeof n.nodeType == "number" && typeof n.nodeName == "string";
}
function ZB(n) {
  return typeof HTMLElement == "function" ? n instanceof HTMLElement : n && Up(n) && n.nodeType === 1 && typeof n.nodeName == "string";
}
function I_(n) {
  return XB(n) || ZB(n);
}
function QB(n) {
  if (n == null)
    return [];
  var e = [];
  return Lx(n, function(t) {
    return e.push(t);
  }), e;
}
function JB(n, e) {
  if (n)
    for (var t = 0; t < n.length; t++) {
      var i = n[t];
      e(i.name, i.value);
    }
}
function z$(n, e) {
  typeof e == "boolean" ? (n.checked = e, n.indeterminate = !1) : n.indeterminate = !0;
}
function lv(n, e, t) {
  t == null ? n.removeAttribute(e) : n.setAttribute(e, t.toString());
}
function Lx(n, e) {
  if (n != null)
    for (var t = 0; t < n.length; t++)
      e(n[t]);
}
const j$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addOrRemoveAttribute: lv,
  addStylesToElement: Sx,
  appendHtml: B$,
  clearElement: Ls,
  copyNodeList: QB,
  ensureDomOrder: wx,
  formatSize: Ex,
  getAbsoluteHeight: yx,
  getAbsoluteWidth: NS,
  getElementAttribute: H$,
  getElementSize: yg,
  getInnerHeight: x_,
  getInnerWidth: xS,
  getScrollLeft: Uv,
  insertWithDomOrder: qB,
  isElement: ZB,
  isElementChildOfClass: OS,
  isFocusableFormField: $B,
  isHorizontalScrollShowing: q1,
  isNode: XB,
  isNodeOrElement: I_,
  isRtlNegativeScroll: Gv,
  isVerticalScrollShowing: YB,
  isVisible: wg,
  iterateNamedNodeMap: JB,
  loadTemplate: Tr,
  nodeListForEach: Lx,
  offsetHeight: $1,
  offsetWidth: K1,
  prependDC: G$,
  radioCssClass: W$,
  removeElement: V$,
  removeFromParent: za,
  setCheckboxState: z$,
  setDisabled: jp,
  setDisplayed: Bi,
  setDomChildOrder: bx,
  setElementHeight: U$,
  setElementWidth: N_,
  setFixedHeight: yd,
  setFixedWidth: Yl,
  setScrollLeft: Gw,
  setVisible: KB
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function $$(n) {
  var e = /function (.{1,})\(/, t = n.toString(), i = e.exec(t);
  return i && i.length > 1 ? i[1] : "";
}
function K$(n) {
  var e = n.length, t = 0;
  if (e <= 1)
    return n;
  for (var i = 0; i < n.length; i++) {
    var r = n[i], o = r.toString().split("e-");
    if (o.length > 1) {
      t = Math.max(t, parseInt(o[1], 10));
      continue;
    }
    Math.floor(r) !== r && (t = Math.max(t, r.toString().split(".")[1].length));
  }
  for (var s = 0, a = 0, l = 0, u = 0, c = 0, h = 0; h < e; h++)
    c = n[h], s += h, a += c, u += h * h, l += h * c;
  for (var d = (e * l - s * a) / (e * u - s * s), f = a / e - d * s / e, p = [], h = 0; h <= e; h++)
    p.push(parseFloat((h * d + f).toFixed(t)));
  return p;
}
function q$(n) {
  if (!n)
    return "";
  var e = [];
  return pi(n, function(t, i) {
    var r = PB(t);
    e.push(r + ": " + i + ";");
  }), e.join(" ");
}
function Y$(n) {
  var e = document.createElement("div"), t = document.querySelector("#__ag__message");
  if (e.innerHTML = n, !t) {
    var i = '<div id="__ag__message" style="display: inline-block; position: absolute; top: 0px; left: 0px; color: white; background-color: black; z-index: 20; padding: 2px; border: 1px solid darkred; height: 200px; overflow-y: auto;"></div>';
    t = Tr(i), document.body && document.body.appendChild(t);
  }
  t.insertBefore(e, t.children[0]);
}
function X$(n, e) {
  n.then(function(t) {
    var i = t.getGui();
    i != null && (typeof i == "object" ? e.appendChild(i) : e.innerHTML = i);
  });
}
const Z$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindCellRendererToHtmlElement: X$,
  cssStyleObjectToMarkup: q$,
  findLineByLeastSquares: K$,
  getNameOfClass: $$,
  message: Y$
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function Wr(n, e, t) {
  n.setAttribute(eH(e), t.toString());
}
function bg(n, e) {
  n.removeAttribute(eH(e));
}
function eH(n) {
  return "aria-" + n;
}
function Do(n, e) {
  e ? n.setAttribute("role", e) : n.removeAttribute("role");
}
function tH(n) {
  var e;
  return n.isSortAscending() ? e = "ascending" : n.isSortDescending() ? e = "descending" : e = "none", e;
}
function iH(n) {
  return parseInt(n.getAttribute("aria-level"), 10);
}
function nH(n) {
  return parseInt(n.getAttribute("aria-posinset"), 10);
}
function Q$(n) {
  return n.getAttribute("aria-describedby") || "";
}
function tf(n, e) {
  var t = "label";
  e ? Wr(n, t, e) : bg(n, t);
}
function Dx(n, e) {
  var t = "labelledby";
  e ? Wr(n, t, e) : bg(n, t);
}
function IS(n, e) {
  var t = "describedby";
  e ? Wr(n, t, e) : bg(n, t);
}
function rH(n, e) {
  Wr(n, "level", e);
}
function ep(n, e) {
  Wr(n, "disabled", e);
}
function bs(n, e) {
  Wr(n, "expanded", e);
}
function J$(n) {
  bg(n, "expanded");
}
function Rx(n, e) {
  Wr(n, "setsize", e);
}
function Tx(n, e) {
  Wr(n, "posinset", e);
}
function oH(n, e) {
  Wr(n, "multiselectable", e);
}
function sH(n, e) {
  Wr(n, "rowcount", e);
}
function Ox(n, e) {
  Wr(n, "rowindex", e);
}
function aH(n, e) {
  Wr(n, "colcount", e);
}
function xx(n, e) {
  Wr(n, "colindex", e);
}
function lH(n, e) {
  Wr(n, "colspan", e);
}
function uH(n, e) {
  Wr(n, "sort", e);
}
function cH(n) {
  bg(n, "sort");
}
function $p(n, e) {
  var t = "selected";
  e ? Wr(n, t, e) : bg(n, t);
}
function hH(n, e) {
  Wr(n, "checked", e === void 0 ? "mixed" : e);
}
const eK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAriaDescribedBy: Q$,
  getAriaLevel: iH,
  getAriaPosInSet: nH,
  getAriaSortState: tH,
  removeAriaExpanded: J$,
  removeAriaSort: cH,
  setAriaChecked: hH,
  setAriaColCount: aH,
  setAriaColIndex: xx,
  setAriaColSpan: lH,
  setAriaDescribedBy: IS,
  setAriaDisabled: ep,
  setAriaExpanded: bs,
  setAriaLabel: tf,
  setAriaLabelledBy: Dx,
  setAriaLevel: rH,
  setAriaMultiSelectable: oH,
  setAriaPosInSet: Tx,
  setAriaRole: Do,
  setAriaRowCount: sH,
  setAriaRowIndex: Ox,
  setAriaSelected: $p,
  setAriaSetSize: Rx,
  setAriaSort: uH
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function Y1(n, e) {
  return n.toString().padStart(e, "0");
}
function dH(n, e) {
  for (var t = [], i = n; i <= e; i++)
    t.push(i);
  return t;
}
function Uw(n) {
  return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
}
function tK(n) {
  return typeof n == "string" && (n = parseInt(n, 10)), typeof n == "number" ? Math.floor(n) : null;
}
function iK(n, e) {
  for (var t = "", i = 0; i < e; i++)
    t += String.fromCharCode(n & 255), n >>>= 8;
  return t;
}
function nK(n, e, t) {
  return typeof n != "number" ? "" : Nx(Math.round(n * 100) / 100, e, t);
}
function Nx(n, e, t) {
  return typeof n != "number" ? "" : n.toString().replace(".", t).replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + e);
}
function rK(n) {
  return n == null ? null : n.reduce(function(e, t) {
    return e + t;
  }, 0);
}
const oK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cleanNumber: tK,
  createArrayOfNumbers: dH,
  decToHex: iK,
  formatNumberCommas: Nx,
  formatNumberTwoDecimalPlacesAndCommas: nK,
  isNumeric: Uw,
  padStartWidthZeros: Y1,
  sum: rK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var mL = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
};
function jc(n, e, t) {
  if (e === void 0 && (e = !0), t === void 0 && (t = "-"), !n)
    return null;
  var i = [n.getFullYear(), n.getMonth() + 1, n.getDate()].map(function(r) {
    return Y1(r, 2);
  }).join(t);
  return e && (i += " " + [n.getHours(), n.getMinutes(), n.getSeconds()].map(function(r) {
    return Y1(r, 2);
  }).join(":")), i;
}
function $c(n) {
  if (!n)
    return null;
  var e = mL(n.split(" "), 2), t = e[0], i = e[1];
  if (!t)
    return null;
  var r = t.split("-").map(function(p) {
    return parseInt(p, 10);
  });
  if (r.filter(function(p) {
    return !isNaN(p);
  }).length !== 3)
    return null;
  var o = mL(r, 3), s = o[0], a = o[1], l = o[2], u = new Date(s, a - 1, l);
  if (u.getFullYear() !== s || u.getMonth() !== a - 1 || u.getDate() !== l)
    return null;
  if (!i || i === "00:00:00")
    return u;
  var c = mL(i.split(":").map(function(p) {
    return parseInt(p, 10);
  }), 3), h = c[0], d = c[1], f = c[2];
  return h >= 0 && h < 24 && u.setHours(h), d >= 0 && d < 60 && u.setMinutes(d), f >= 0 && f < 60 && u.setSeconds(f), u;
}
const sK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseDateTimeFromString: $c,
  serialiseDate: jc
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function fH(n, e, t) {
  var i = {}, r = n.filter(function(o) {
    return !e.some(function(s) {
      return s === o;
    });
  });
  return r.length > 0 && r.forEach(function(o) {
    return i[o] = pH(o, t);
  }), i;
}
function pH(n, e, t, i) {
  var r = i ? mH : gH, o = e.map(function(s) {
    return {
      value: s,
      relevance: r(n.toLowerCase(), s.toLocaleLowerCase())
    };
  });
  return o.sort(function(s, a) {
    return a.relevance - s.relevance;
  }), t && (o = o.filter(function(s) {
    return s.relevance !== 0;
  })), o.map(function(s) {
    return s.value;
  });
}
function X1(n) {
  var e = n.toLowerCase(), t = new Array(e.length - 1), i, r, o;
  for (i = r = 0, o = t.length; r <= o; i = r += 1)
    t[i] = e.slice(i, i + 2);
  return t;
}
function gH(n, e) {
  if (n.length === 0 && e.length === 0)
    return 0;
  var t = X1(n), i = X1(e), r = t.length + i.length, o = 0, s, a;
  for (s = 0, a = t.length; s < a; s++) {
    var l = t[s], u = void 0, c = void 0;
    for (u = 0, c = i.length; u < c; u++) {
      var h = i[u];
      l === h && o++;
    }
  }
  return o > 0 ? 2 * o / r : 0;
}
function mH(n, e) {
  for (var t = n.replace(/\s/g, ""), i = e.replace(/\s/g, ""), r = 0, o = 0, s = 0; s < t.length; s++) {
    var a = i.indexOf(t[s], o);
    a !== -1 && (o = a, r += 100 - o * 100 / 1e4 * 100);
  }
  return r;
}
const aK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fuzzyCheckStrings: fH,
  fuzzySuggestions: pH,
  get_bigrams: X1,
  string_distances: gH,
  string_weighted_distances: mH
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var vH = {
  // header column group shown when expanded (click to contract)
  columnGroupOpened: "expanded",
  // header column group shown when contracted (click to expand)
  columnGroupClosed: "contracted",
  // tool panel column group contracted (click to expand)
  columnSelectClosed: "tree-closed",
  // tool panel column group expanded (click to contract)
  columnSelectOpen: "tree-open",
  // column tool panel header expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  columnSelectIndeterminate: "tree-indeterminate",
  // shown on ghost icon while dragging column to the side of the grid to pin
  columnMovePin: "pin",
  // shown on ghost icon while dragging over part of the page that is not a drop zone
  columnMoveHide: "eye-slash",
  // shown on ghost icon while dragging columns to reorder
  columnMoveMove: "arrows",
  // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
  columnMoveLeft: "left",
  // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
  columnMoveRight: "right",
  // shown on ghost icon while dragging over Row Groups drop zone
  columnMoveGroup: "group",
  // shown on ghost icon while dragging over Values drop zone
  columnMoveValue: "aggregation",
  // shown on ghost icon while dragging over pivot drop zone
  columnMovePivot: "pivot",
  // shown on ghost icon while dragging over drop zone that doesn't support it, e.g.
  //     string column over aggregation drop zone
  dropNotAllowed: "not-allowed",
  // shown on row group when contracted (click to expand)
  groupContracted: "tree-closed",
  // shown on row group when expanded (click to contract)
  groupExpanded: "tree-open",
  // context menu chart item
  chart: "chart",
  // chart window title bar
  close: "cross",
  // X (remove) on column 'pill' after adding it to a drop zone list
  cancel: "cancel",
  // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
  check: "tick",
  // "go to first" button in pagination controls
  first: "first",
  // "go to previous" button in pagination controls
  previous: "previous",
  // "go to next" button in pagination controls
  next: "next",
  // "go to last" button in pagination controls
  last: "last",
  // shown on top right of chart when chart is linked to range data (click to unlink)
  linked: "linked",
  // shown on top right of chart when chart is not linked to range data (click to link)
  unlinked: "unlinked",
  // "Choose colour" button on chart settings tab
  colorPicker: "color-picker",
  // rotating spinner shown by the loading cell renderer
  groupLoading: "loading",
  // button to launch enterprise column menu
  menu: "menu",
  // filter tool panel tab
  filter: "filter",
  // column tool panel tab
  columns: "columns",
  // button in chart regular size window title bar (click to maximise)
  maximize: "maximize",
  // button in chart maximised window title bar (click to make regular size)
  minimize: "minimize",
  // "Pin column" item in column header menu
  menuPin: "pin",
  // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
  menuValue: "aggregation",
  // "Group by {column-name}" item in column header menu
  menuAddRowGroup: "group",
  // "Un-Group by {column-name}" item in column header menu
  menuRemoveRowGroup: "group",
  // context menu copy item
  clipboardCopy: "copy",
  // context menu paste item
  clipboardPaste: "paste",
  // identifies the pivot drop zone
  pivotPanel: "pivot",
  // "Row groups" drop zone in column tool panel
  rowGroupPanel: "group",
  // columns tool panel Values drop zone
  valuePanel: "aggregation",
  // drag handle used to pick up draggable columns
  columnDrag: "grip",
  // drag handle used to pick up draggable rows
  rowDrag: "grip",
  // context menu export item
  save: "save",
  // csv export
  csvExport: "csv",
  // excel export,
  excelExport: "excel",
  // icon on dropdown editors
  smallDown: "small-down",
  // version of small-right used in RTL mode
  smallLeft: "small-left",
  // separater between column 'pills' when you add multiple columns to the header drop zone
  smallRight: "small-right",
  smallUp: "small-up",
  // show on column header when column is sorted ascending
  sortAscending: "asc",
  // show on column header when column is sorted descending
  sortDescending: "desc",
  // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
  sortUnSort: "none"
};
function ra(n, e, t) {
  var i = Yn(n, e, t);
  if (i && i.className.indexOf("ag-icon") > -1)
    return i;
  var r = document.createElement("span");
  return r.appendChild(i), r;
}
function Yn(n, e, t, i) {
  var r = null, o = t && t.getColDef().icons;
  if (o && (r = o[n]), e && !r) {
    var s = e.getIcons();
    s && (r = s[n]);
  }
  if (r) {
    var a = void 0;
    if (typeof r == "function")
      a = r();
    else if (typeof r == "string")
      a = r;
    else
      throw new Error("icon from grid options needs to be a string or a function");
    if (typeof a == "string")
      return Tr(a);
    if (I_(a))
      return a;
    console.warn("AG Grid: iconRenderer should return back a string or a dom object");
  } else {
    var l = document.createElement("span"), u = vH[n];
    return u || (i ? u = n : (console.warn("AG Grid: Did not find icon " + n), u = "")), l.setAttribute("class", "ag-icon ag-icon-" + u), l.setAttribute("unselectable", "on"), Do(l, "presentation"), l;
  }
}
const lK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createIcon: ra,
  createIconNoSpan: Yn,
  iconNameClassMap: vH
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var uK = "Del", cK = 46;
function _H(n) {
  if (n.altKey || n.ctrlKey || n.metaKey)
    return !1;
  var e = n.key.length === 1, t = hK(n);
  return e || t;
}
function zw(n, e, t, i, r) {
  var o = n.getSuppressKeyboardEventFunc(), s = i ? i.getColDef().suppressKeyboardEvent : void 0;
  if (!o && !s)
    return !1;
  var a = {
    event: e,
    editing: r,
    column: i,
    api: n.getApi(),
    node: t,
    data: t.data,
    colDef: i.getColDef(),
    context: n.getContext(),
    columnApi: n.getColumnApi()
  };
  if (s) {
    var l = s(a);
    if (l)
      return !0;
  }
  return o ? o(a) : !1;
}
function CH(n, e, t, i) {
  var r = i.getDefinition(), o = r && r.suppressHeaderKeyboardEvent;
  if (!ge(o))
    return !1;
  var s = {
    api: n.getApi(),
    columnApi: n.getColumnApi(),
    context: n.getContext(),
    colDef: r,
    column: i,
    headerRowIndex: t,
    event: e
  };
  return !!o(s);
}
function hK(n) {
  return RS() && n.key === uK && n.charCode === cK;
}
const dK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isEventFromPrintableCharacter: _H,
  isUserSuppressingHeaderKeyboardEvent: CH,
  isUserSuppressingKeyboardEvent: zw
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function Ix(n, e, t) {
  if (t === 0)
    return !1;
  var i = Math.abs(n.clientX - e.clientX), r = Math.abs(n.clientY - e.clientY);
  return Math.max(i, r) <= t;
}
const fK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  areEventsNear: Ix
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function pK(n, e) {
  if (n) {
    for (var t = function(a, l) {
      var u = e[a.id], c = e[l.id], h = u !== void 0, d = c !== void 0, f = h && d, p = !h && !d;
      return f ? u - c : p ? a.__objectId - l.__objectId : h ? 1 : -1;
    }, i, r, o = !1, s = 0; s < n.length - 1; s++)
      if (i = n[s], r = n[s + 1], t(i, r) > 0) {
        o = !0;
        break;
      }
    o && n.sort(t);
  }
}
function gK(n, e) {
  var t = [];
  i(n);
  function i(r) {
    r && r.forEach(function(o) {
      if (o.group || o.hasChildren()) {
        t.push(o.key);
        var s = t.join("|");
        e(o, s), i(o.childrenAfterGroup), t.pop();
      }
    });
  }
}
const mK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sortRowNodesByOrder: pK,
  traverseNodesWithKey: gK
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function Px(n) {
  var e = /* @__PURE__ */ new Set();
  return n.forEach(function(t) {
    return e.add(t);
  }), e;
}
const vK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  convertToSet: Px
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Sn = globalThis && globalThis.__assign || function() {
  return Sn = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, Sn.apply(this, arguments);
}, _K = Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn(Sn({}, Z$), eK), n$), k$), P$), sK), j$), u$), $j), aK), Mj), lK), dK), _$), fK), oK), Hj), mK), vK), g$), Ad = _K;
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var PS = (
  /** @class */
  function() {
    function n(e, t) {
      e === void 0 && (e = 0), t === void 0 && (t = 1), this.nextValue = e, this.step = t;
    }
    return n.prototype.next = function() {
      var e = this.nextValue;
      return this.nextValue += this.step, e;
    }, n.prototype.peek = function() {
      return this.nextValue;
    }, n.prototype.skip = function(e) {
      this.nextValue += e;
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var od;
(function(n) {
  n[n.IN_PROGRESS = 0] = "IN_PROGRESS", n[n.RESOLVED = 1] = "RESOLVED";
})(od || (od = {}));
var Bo = (
  /** @class */
  function() {
    function n(e) {
      var t = this;
      this.status = od.IN_PROGRESS, this.resolution = null, this.waiters = [], e(function(i) {
        return t.onDone(i);
      }, function(i) {
        return t.onReject(i);
      });
    }
    return n.all = function(e) {
      return new n(function(t) {
        var i = e.length, r = new Array(i);
        e.forEach(function(o, s) {
          o.then(function(a) {
            r[s] = a, i--, i === 0 && t(r);
          });
        });
      });
    }, n.resolve = function(e) {
      return e === void 0 && (e = null), new n(function(t) {
        return t(e);
      });
    }, n.prototype.then = function(e) {
      var t = this;
      return new n(function(i) {
        t.status === od.RESOLVED ? i(e(t.resolution)) : t.waiters.push(function(r) {
          return i(e(r));
        });
      });
    }, n.prototype.resolveNow = function(e, t) {
      return this.status === od.RESOLVED ? t(this.resolution) : e;
    }, n.prototype.onDone = function(e) {
      this.status = od.RESOLVED, this.resolution = e, this.waiters.forEach(function(t) {
        return t(e);
      });
    }, n.prototype.onReject = function(e) {
      console.warn("TBI");
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var CK = (
  /** @class */
  function() {
    function n() {
      this.timestamp = (/* @__PURE__ */ new Date()).getTime();
    }
    return n.prototype.print = function(e) {
      var t = (/* @__PURE__ */ new Date()).getTime() - this.timestamp;
      console.info(e + " = " + t), this.timestamp = (/* @__PURE__ */ new Date()).getTime();
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var yK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Z1 = globalThis && globalThis.__assign || function() {
  return Z1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, Z1.apply(this, arguments);
}, cm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Na;
(function(n) {
  n[n.NOTHING = 0] = "NOTHING", n[n.WAITING_TO_SHOW = 1] = "WAITING_TO_SHOW", n[n.SHOWING = 2] = "SHOWING";
})(Na || (Na = {}));
var AS = (
  /** @class */
  function(n) {
    yK(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.DEFAULT_SHOW_TOOLTIP_DELAY = 2e3, i.DEFAULT_HIDE_TOOLTIP_DELAY = 1e4, i.SHOW_QUICK_TOOLTIP_DIFF = 1e3, i.FADE_OUT_TOOLTIP_TIMEOUT = 1e3, i.state = Na.NOTHING, i.tooltipInstanceCount = 0, i.tooltipMouseTrack = !1, i.parentComp = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.tooltipShowDelay = this.gridOptionsWrapper.getTooltipDelay("show") || this.DEFAULT_SHOW_TOOLTIP_DELAY, this.tooltipHideDelay = this.gridOptionsWrapper.getTooltipDelay("hide") || this.DEFAULT_HIDE_TOOLTIP_DELAY, this.tooltipMouseTrack = this.gridOptionsWrapper.isTooltipMouseTrack();
      var t = this.parentComp.getGui();
      this.addManagedListener(t, "mouseenter", this.onMouseEnter.bind(this)), this.addManagedListener(t, "mouseleave", this.onMouseLeave.bind(this)), this.addManagedListener(t, "mousemove", this.onMouseMove.bind(this)), this.addManagedListener(t, "mousedown", this.onMouseDown.bind(this)), this.addManagedListener(t, "keydown", this.onKeyDown.bind(this));
    }, e.prototype.destroy = function() {
      this.setToDoNothing(), n.prototype.destroy.call(this);
    }, e.prototype.onMouseEnter = function(t) {
      if (!Cg() && this.state == Na.NOTHING) {
        var i = this.isLastTooltipHiddenRecently() ? 200 : this.tooltipShowDelay;
        this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), i), this.lastMouseEvent = t, this.state = Na.WAITING_TO_SHOW;
      }
    }, e.prototype.onMouseLeave = function() {
      this.setToDoNothing();
    }, e.prototype.onKeyDown = function() {
      this.setToDoNothing();
    }, e.prototype.setToDoNothing = function() {
      this.state === Na.SHOWING && this.hideTooltip(), this.clearTimeouts(), this.state = Na.NOTHING;
    }, e.prototype.onMouseMove = function(t) {
      this.lastMouseEvent = t, this.tooltipMouseTrack && this.state === Na.SHOWING && this.tooltipComp && this.positionTooltipUnderLastMouseEvent();
    }, e.prototype.onMouseDown = function() {
      this.setToDoNothing();
    }, e.prototype.hideTooltip = function() {
      this.tooltipComp && (this.destroyTooltipComp(), e.lastTooltipHideTime = (/* @__PURE__ */ new Date()).getTime()), this.state = Na.NOTHING;
    }, e.prototype.destroyTooltipComp = function() {
      var t = this;
      this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
      var i = this.tooltipPopupDestroyFunc, r = this.tooltipComp;
      window.setTimeout(function() {
        i(), t.getContext().destroyBean(r);
      }, this.FADE_OUT_TOOLTIP_TIMEOUT), this.tooltipPopupDestroyFunc = void 0, this.tooltipComp = void 0;
    }, e.prototype.isLastTooltipHiddenRecently = function() {
      var t = (/* @__PURE__ */ new Date()).getTime(), i = e.lastTooltipHideTime;
      return t - i < this.SHOW_QUICK_TOOLTIP_DIFF;
    }, e.prototype.showTooltip = function() {
      var t = Z1({ api: this.gridApi, columnApi: this.columnApi, context: this.gridOptionsWrapper.getContext() }, this.parentComp.getTooltipParams());
      if (!ge(t.value)) {
        this.setToDoNothing();
        return;
      }
      this.state = Na.SHOWING, this.tooltipInstanceCount++;
      var i = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount), r = this.userComponentFactory.getTooltipCompDetails(t);
      r.newAgStackInstance().then(i);
    }, e.prototype.newTooltipComponentCallback = function(t, i) {
      var r = this.state !== Na.SHOWING || this.tooltipInstanceCount !== t;
      if (r) {
        this.getContext().destroyBean(i);
        return;
      }
      var o = i.getGui();
      this.tooltipComp = i, o.classList.contains("ag-tooltip") || o.classList.add("ag-tooltip-custom");
      var s = this.gridOptionsWrapper.getLocaleTextFunc(), a = this.popupService.addPopup({
        eChild: o,
        ariaLabel: s("ariaLabelTooltip", "Tooltip")
      });
      a && (this.tooltipPopupDestroyFunc = a.hideFunc), this.positionTooltipUnderLastMouseEvent(), this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.tooltipHideDelay);
    }, e.prototype.positionTooltipUnderLastMouseEvent = function() {
      this.popupService.positionPopupUnderMouseEvent({
        type: "tooltip",
        mouseEvent: this.lastMouseEvent,
        ePopup: this.tooltipComp.getGui(),
        nudgeY: 18
      });
    }, e.prototype.clearTimeouts = function() {
      this.showTooltipTimeoutId && (window.clearTimeout(this.showTooltipTimeoutId), this.showTooltipTimeoutId = void 0), this.hideTooltipTimeoutId && (window.clearTimeout(this.hideTooltipTimeoutId), this.hideTooltipTimeoutId = void 0);
    }, cm([
      T("popupService")
    ], e.prototype, "popupService", void 0), cm([
      T("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), cm([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), cm([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), cm([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var wK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), vL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, bK = new PS(), yH = (
  /** @class */
  function() {
    function n(e) {
      this.cssClassStates = {}, this.getGui = e;
    }
    return n.prototype.addCssClass = function(e) {
      var t = this.cssClassStates[e] !== !0;
      t && e.length && (this.getGui().classList.add(e), this.cssClassStates[e] = !0);
    }, n.prototype.removeCssClass = function(e) {
      var t = this.cssClassStates[e] !== !1;
      t && e.length && (this.getGui().classList.remove(e), this.cssClassStates[e] = !1);
    }, n.prototype.containsCssClass = function(e) {
      return this.getGui().classList.contains(e);
    }, n.prototype.addOrRemoveCssClass = function(e, t) {
      var i = this.cssClassStates[e] !== t;
      i && e.length && (this.getGui().classList.toggle(e, t), this.cssClassStates[e] = t);
    }, n;
  }()
), Et = (
  /** @class */
  function(n) {
    wK(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.displayed = !0, i.visible = !0, i.compId = bK.next(), i.cssClassManager = new yH(function() {
        return i.eGui;
      }), t && i.setTemplate(t), i;
    }
    return e.prototype.preConstructOnComponent = function() {
      this.usingBrowserTooltips = this.gridOptionsWrapper.isEnableBrowserTooltips();
    }, e.prototype.getCompId = function() {
      return this.compId;
    }, e.prototype.getTooltipParams = function() {
      return {
        value: this.tooltipText,
        location: "UNKNOWN"
      };
    }, e.prototype.setTooltip = function(t) {
      var i = this, r = function() {
        i.usingBrowserTooltips ? i.getGui().removeAttribute("title") : i.tooltipFeature = i.destroyBean(i.tooltipFeature);
      }, o = function() {
        i.usingBrowserTooltips ? i.getGui().setAttribute("title", i.tooltipText) : i.tooltipFeature = i.createBean(new AS(i));
      };
      this.tooltipText != t && (this.tooltipText && r(), t != null && (this.tooltipText = t, this.tooltipText && o()));
    }, e.prototype.createChildComponentsFromTags = function(t, i) {
      var r = this, o = QB(t.childNodes);
      o.forEach(function(s) {
        if (s instanceof HTMLElement) {
          var a = r.createComponentFromElement(s, function(u) {
            var c = u.getGui();
            c && r.copyAttributesFromNode(s, u.getGui());
          }, i);
          if (a) {
            if (a.addItems && s.children.length) {
              r.createChildComponentsFromTags(s, i);
              var l = Array.prototype.slice.call(s.children);
              a.addItems(l);
            }
            r.swapComponentForNode(a, t, s);
          } else
            s.childNodes && r.createChildComponentsFromTags(s, i);
        }
      });
    }, e.prototype.createComponentFromElement = function(t, i, r) {
      var o = t.nodeName, s = r ? r[t.getAttribute("ref")] : void 0, a = this.agStackComponentsRegistry.getComponentClass(o);
      if (a) {
        e.elementGettingCreated = t;
        var l = new a(s);
        return l.setParentComponent(this), this.createBean(l, null, i), l;
      }
      return null;
    }, e.prototype.copyAttributesFromNode = function(t, i) {
      JB(t.attributes, function(r, o) {
        return i.setAttribute(r, o);
      });
    }, e.prototype.swapComponentForNode = function(t, i, r) {
      var o = t.getGui();
      i.replaceChild(o, r), i.insertBefore(document.createComment(r.nodeName), o), this.addDestroyFunc(this.destroyBean.bind(this, t)), this.swapInComponentForQuerySelectors(t, r);
    }, e.prototype.swapInComponentForQuerySelectors = function(t, i) {
      var r = this;
      this.iterateOverQuerySelectors(function(o) {
        r[o.attributeName] === i && (r[o.attributeName] = t);
      });
    }, e.prototype.iterateOverQuerySelectors = function(t) {
      for (var i = Object.getPrototypeOf(this); i != null; ) {
        var r = i.__agComponentMetaData, o = DS(i.constructor);
        r && r[o] && r[o].querySelectors && r[o].querySelectors.forEach(function(s) {
          return t(s);
        }), i = Object.getPrototypeOf(i);
      }
    }, e.prototype.setTemplate = function(t, i) {
      var r = Tr(t);
      this.setTemplateFromElement(r, i);
    }, e.prototype.setTemplateFromElement = function(t, i) {
      this.eGui = t, this.eGui.__agComponent = this, this.wireQuerySelectors(), this.getContext() && this.createChildComponentsFromTags(this.getGui(), i);
    }, e.prototype.createChildComponentsPreConstruct = function() {
      this.getGui() && this.createChildComponentsFromTags(this.getGui());
    }, e.prototype.wireQuerySelectors = function() {
      var t = this;
      if (this.eGui) {
        var i = this;
        this.iterateOverQuerySelectors(function(r) {
          var o = function(l) {
            return i[r.attributeName] = l;
          }, s = r.refSelector && t.eGui.getAttribute("ref") === r.refSelector;
          if (s)
            o(t.eGui);
          else {
            var a = t.eGui.querySelector(r.querySelector);
            a && o(a.__agComponent || a);
          }
        });
      }
    }, e.prototype.getGui = function() {
      return this.eGui;
    }, e.prototype.getFocusableElement = function() {
      return this.eGui;
    }, e.prototype.setParentComponent = function(t) {
      this.parentComponent = t;
    }, e.prototype.getParentComponent = function() {
      return this.parentComponent;
    }, e.prototype.setGui = function(t) {
      this.eGui = t;
    }, e.prototype.queryForHtmlElement = function(t) {
      return this.eGui.querySelector(t);
    }, e.prototype.queryForHtmlInputElement = function(t) {
      return this.eGui.querySelector(t);
    }, e.prototype.appendChild = function(t, i) {
      if (i || (i = this.eGui), t != null)
        if (I_(t))
          i.appendChild(t);
        else {
          var r = t;
          i.appendChild(r.getGui()), this.addDestroyFunc(this.destroyBean.bind(this, r));
        }
    }, e.prototype.isDisplayed = function() {
      return this.displayed;
    }, e.prototype.setVisible = function(t) {
      t !== this.visible && (this.visible = t, KB(this.eGui, t));
    }, e.prototype.setDisplayed = function(t) {
      if (t !== this.displayed) {
        this.displayed = t, Bi(this.eGui, t);
        var i = {
          type: e.EVENT_DISPLAYED_CHANGED,
          visible: this.displayed
        };
        this.dispatchEvent(i);
      }
    }, e.prototype.destroy = function() {
      this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), n.prototype.destroy.call(this);
    }, e.prototype.addGuiEventListener = function(t, i) {
      var r = this;
      this.eGui.addEventListener(t, i), this.addDestroyFunc(function() {
        return r.eGui.removeEventListener(t, i);
      });
    }, e.prototype.addCssClass = function(t) {
      this.cssClassManager.addCssClass(t);
    }, e.prototype.removeCssClass = function(t) {
      this.cssClassManager.removeCssClass(t);
    }, e.prototype.containsCssClass = function(t) {
      return this.cssClassManager.containsCssClass(t);
    }, e.prototype.addOrRemoveCssClass = function(t, i) {
      this.cssClassManager.addOrRemoveCssClass(t, i);
    }, e.prototype.getAttribute = function(t) {
      var i = this.eGui;
      return i ? i.getAttribute(t) : null;
    }, e.prototype.getRefElement = function(t) {
      return this.queryForHtmlElement('[ref="' + t + '"]');
    }, e.EVENT_DISPLAYED_CHANGED = "displayedChanged", vL([
      T("agStackComponentsRegistry")
    ], e.prototype, "agStackComponentsRegistry", void 0), vL([
      W1
    ], e.prototype, "preConstructOnComponent", null), vL([
      W1
    ], e.prototype, "createChildComponentsPreConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function SK(n) {
  return wH.bind(this, n, void 0);
}
function ve(n) {
  return wH.bind(this, "[ref=" + n + "]", n);
}
function wH(n, e, t, i, r) {
  if (n === null) {
    console.error("AG Grid: QuerySelector selector should not be null");
    return;
  }
  if (typeof r == "number") {
    console.error("AG Grid: QuerySelector should be on an attribute");
    return;
  }
  EK(t, "querySelectors", {
    attributeName: i,
    querySelector: n,
    refSelector: e
  });
}
function EK(n, e, t) {
  var i = LK(n, DS(n.constructor));
  i[e] || (i[e] = []), i[e].push(t);
}
function LK(n, e) {
  return n.__agComponentMetaData || (n.__agComponentMetaData = {}), n.__agComponentMetaData[e] || (n.__agComponentMetaData[e] = {}), n.__agComponentMetaData[e];
}
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var DK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), kM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, RK = (
  /** @class */
  function(n) {
    DK(e, n);
    function e() {
      return n.call(
        this,
        /* html */
        `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eFloatingFilterText"></ag-input-text-field>
            </div>`
      ) || this;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.init = function(t) {
      this.params = t;
      var i = this.columnModel.getDisplayNameForColumn(t.column, "header", !0), r = this.gridOptionsWrapper.getLocaleTextFunc();
      this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(i + " " + r("ariaFilterInput", "Filter Input"));
    }, e.prototype.onParentModelChanged = function(t) {
      var i = this;
      if (!t) {
        this.eFloatingFilterText.setValue("");
        return;
      }
      this.params.parentFilterInstance(function(r) {
        if (r.getModelAsString) {
          var o = r.getModelAsString(t);
          i.eFloatingFilterText.setValue(o);
        }
      });
    }, kM([
      ve("eFloatingFilterText")
    ], e.prototype, "eFloatingFilterText", void 0), kM([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var bH = (
  /** @class */
  function() {
    function n(e, t, i, r) {
      var o = this;
      this.alive = !0, this.context = e, this.eParent = r;
      var s = t.getDateCompDetails(i), a = s.newAgStackInstance();
      a.then(function(l) {
        if (!o.alive) {
          e.destroyBean(l);
          return;
        }
        o.dateComp = l, l && (r.appendChild(l.getGui()), l.afterGuiAttached && l.afterGuiAttached(), o.tempValue && l.setDate(o.tempValue), o.disabled != null && o.setDateCompDisabled(o.disabled));
      });
    }
    return n.prototype.destroy = function() {
      this.alive = !1, this.dateComp = this.context.destroyBean(this.dateComp);
    }, n.prototype.getDate = function() {
      return this.dateComp ? this.dateComp.getDate() : this.tempValue;
    }, n.prototype.setDate = function(e) {
      this.dateComp ? this.dateComp.setDate(e) : this.tempValue = e;
    }, n.prototype.setDisabled = function(e) {
      this.dateComp ? this.setDateCompDisabled(e) : this.disabled = e;
    }, n.prototype.setDisplayed = function(e) {
      Bi(this.eParent, e);
    }, n.prototype.setInputPlaceholder = function(e) {
      this.dateComp && this.dateComp.setInputPlaceholder && this.dateComp.setInputPlaceholder(e);
    }, n.prototype.setInputAriaLabel = function(e) {
      this.dateComp && this.dateComp.setInputAriaLabel && this.dateComp.setInputAriaLabel(e);
    }, n.prototype.afterGuiAttached = function(e) {
      this.dateComp && typeof this.dateComp.afterGuiAttached == "function" && this.dateComp.afterGuiAttached(e);
    }, n.prototype.setDateCompDisabled = function(e) {
      this.dateComp != null && this.dateComp.setDisabled != null && this.dateComp.setDisabled(e);
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Q1 = globalThis && globalThis.__assign || function() {
  return Q1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, Q1.apply(this, arguments);
}, SH = (
  /** @class */
  function() {
    function n() {
      this.customFilterOptions = {};
    }
    return n.prototype.init = function(e, t) {
      this.filterOptions = e.filterOptions || t, this.mapCustomOptions(), this.selectDefaultItem(e), this.checkForDeprecatedParams();
    }, n.prototype.checkForDeprecatedParams = function() {
      this.filterOptions.some(function(e) {
        return typeof e != "string" && e.test != null;
      }) && console.warn("AG Grid: [IFilterOptionDef] since v26.2.0, test() has been replaced with predicate()."), this.filterOptions.some(function(e) {
        return typeof e != "string" && e.hideFilterInput != null;
      }) && console.warn("AG Grid: [IFilterOptionDef] since v26.2.0, useOfHideFilterInput has been replaced with numberOfInputs.");
    }, n.prototype.getFilterOptions = function() {
      return this.filterOptions;
    }, n.prototype.mapCustomOptions = function() {
      var e = this;
      this.filterOptions && this.filterOptions.forEach(function(t) {
        if (typeof t != "string") {
          var i = [["displayKey"], ["displayName"], ["predicate", "test"]], r = function(a) {
            return a.some(function(l) {
              return t[l] != null;
            }) ? !0 : (console.warn("AG Grid: ignoring FilterOptionDef as it doesn't contain one of '" + a + "'"), !1);
          };
          if (!i.every(r)) {
            e.filterOptions = e.filterOptions.filter(function(a) {
              return a === t;
            }) || [];
            return;
          }
          var o = t.test, s = Q1({}, t);
          o != null && t.predicate == null && (s.predicate = function(a, l) {
            return o(a[0], l);
          }, delete s.test), s.hideFilterInput && s.numberOfInputs == null && (s.numberOfInputs = 0, delete s.hideFilterInput), e.customFilterOptions[t.displayKey] = s;
        }
      });
    }, n.prototype.selectDefaultItem = function(e) {
      if (e.defaultOption)
        this.defaultOption = e.defaultOption;
      else if (this.filterOptions.length >= 1) {
        var t = this.filterOptions[0];
        typeof t == "string" ? this.defaultOption = t : t.displayKey ? this.defaultOption = t.displayKey : console.warn("AG Grid: invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'");
      } else
        console.warn("AG Grid: no filter options for filter");
    }, n.prototype.getDefaultOption = function() {
      return this.defaultOption;
    }, n.prototype.getCustomOption = function(e) {
      return this.customFilterOptions[e];
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var TK = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose One",
  equals: "Equals",
  notEqual: "Not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "In range",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equals",
  greaterThanOrEqual: "Greater than or equals",
  contains: "Contains",
  notContains: "Not contains",
  startsWith: "Starts with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd"
};
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var _e = (
  /** @class */
  function() {
    function n() {
    }
    return n.BACKSPACE = "Backspace", n.TAB = "Tab", n.ENTER = "Enter", n.ESCAPE = "Escape", n.SPACE = " ", n.LEFT = "ArrowLeft", n.UP = "ArrowUp", n.RIGHT = "ArrowRight", n.DOWN = "ArrowDown", n.DELETE = "Delete", n.A = "A", n.C = "C", n.V = "V", n.D = "D", n.Z = "Z", n.Y = "Y", n.F2 = "F2", n.PAGE_UP = "PageUp", n.PAGE_DOWN = "PageDown", n.PAGE_HOME = "Home", n.PAGE_END = "End", n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var OK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), J1 = globalThis && globalThis.__assign || function() {
  return J1 = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, J1.apply(this, arguments);
}, WM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, nc = (
  /** @class */
  function(n) {
    OK(e, n);
    function e(t, i) {
      i === void 0 && (i = {});
      var r = n.call(this) || this;
      return r.eFocusableElement = t, r.callbacks = i, r.callbacks = J1({ shouldStopEventPropagation: function() {
        return !1;
      }, onTabKeyDown: function(o) {
        if (!o.defaultPrevented) {
          var s = r.focusService.findNextFocusableElement(r.eFocusableElement, !1, o.shiftKey);
          s && (s.focus(), o.preventDefault());
        }
      } }, i), r;
    }
    return e.prototype.postConstruct = function() {
      this.eFocusableElement.classList.add(e.FOCUS_MANAGED_CLASS), this.addKeyDownListeners(this.eFocusableElement), this.callbacks.onFocusIn && this.addManagedListener(this.eFocusableElement, "focusin", this.callbacks.onFocusIn), this.callbacks.onFocusOut && this.addManagedListener(this.eFocusableElement, "focusout", this.callbacks.onFocusOut);
    }, e.prototype.addKeyDownListeners = function(t) {
      var i = this;
      this.addManagedListener(t, "keydown", function(r) {
        if (!(r.defaultPrevented || Hl(r))) {
          if (i.callbacks.shouldStopEventPropagation(r)) {
            zp(r);
            return;
          }
          r.key === _e.TAB ? i.callbacks.onTabKeyDown(r) : i.callbacks.handleKeyDown && i.callbacks.handleKeyDown(r);
        }
      });
    }, e.FOCUS_MANAGED_CLASS = "ag-focus-managed", WM([
      T("focusService")
    ], e.prototype, "focusService", void 0), WM([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var xK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _L = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, zv = (
  /** @class */
  function(n) {
    xK(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.filterNameKey = t, i.applyActive = !1, i.hidePopup = null, i.appliedModel = null, i;
    }
    return e.prototype.postConstruct = function() {
      this.resetTemplate(), this.createManagedBean(new nc(this.getFocusableElement(), {
        handleKeyDown: this.handleKeyDown.bind(this)
      }));
    }, e.prototype.handleKeyDown = function(t) {
    }, e.prototype.getFilterTitle = function() {
      return this.translate(this.filterNameKey);
    }, e.prototype.isFilterActive = function() {
      return !!this.appliedModel;
    }, e.prototype.resetTemplate = function(t) {
      var i = (
        /* html */
        `
            <div class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-` + this.getCssIdentifier() + `-body-wrapper">
                    ` + this.createBodyTemplate() + `
                </div>
            </div>`
      );
      this.setTemplate(i, t);
    }, e.prototype.isReadOnly = function() {
      return !!this.providedFilterParams.readOnly;
    }, e.prototype.init = function(t) {
      var i = this;
      this.setParams(t), this.resetUiToDefaults(!0).then(function() {
        i.updateUiVisibility(), i.setupOnBtApplyDebounce();
      });
    }, e.prototype.setParams = function(t) {
      this.providedFilterParams = t, this.applyActive = e.isUseApplyButton(t), this.createButtonPanel();
    }, e.prototype.createButtonPanel = function() {
      var t = this, i = this.providedFilterParams.buttons;
      if (!(!i || i.length < 1 || this.isReadOnly())) {
        var r = document.createElement("div");
        r.classList.add("ag-filter-apply-panel");
        var o = function(s) {
          var a, l;
          switch (s) {
            case "apply":
              a = t.translate("applyFilter"), l = function(c) {
                return t.onBtApply(!1, !1, c);
              };
              break;
            case "clear":
              a = t.translate("clearFilter"), l = function() {
                return t.onBtClear();
              };
              break;
            case "reset":
              a = t.translate("resetFilter"), l = function() {
                return t.onBtReset();
              };
              break;
            case "cancel":
              a = t.translate("cancelFilter"), l = function(c) {
                t.onBtCancel(c);
              };
              break;
            default:
              console.warn("AG Grid: Unknown button type specified");
              return;
          }
          var u = Tr(
            /* html */
            `<button
                    type="button"
                    ref="` + s + `FilterButton"
                    class="ag-standard-button ag-filter-apply-panel-button"
                >` + a + `
                </button>`
          );
          r.appendChild(u), t.addManagedListener(u, "click", l);
        };
        Px(i).forEach(function(s) {
          return o(s);
        }), this.getGui().appendChild(r);
      }
    }, e.prototype.getDefaultDebounceMs = function() {
      return 0;
    }, e.prototype.setupOnBtApplyDebounce = function() {
      var t = e.getDebounceMs(this.providedFilterParams, this.getDefaultDebounceMs());
      this.onBtApplyDebounce = lh(this.onBtApply.bind(this), t);
    }, e.prototype.getModel = function() {
      return this.appliedModel ? this.appliedModel : null;
    }, e.prototype.setModel = function(t) {
      var i = this, r = t != null ? this.setModelIntoUi(t) : this.resetUiToDefaults();
      return r.then(function() {
        i.updateUiVisibility(), i.applyModel();
      });
    }, e.prototype.onBtCancel = function(t) {
      var i = this, r = this.getModel(), o = function() {
        i.onUiChanged(!1, "prevent"), i.providedFilterParams.closeOnApply && i.close(t);
      };
      r != null ? this.setModelIntoUi(r).then(o) : this.resetUiToDefaults().then(o);
    }, e.prototype.onBtClear = function() {
      var t = this;
      this.resetUiToDefaults().then(function() {
        return t.onUiChanged();
      });
    }, e.prototype.onBtReset = function() {
      this.onBtClear(), this.onBtApply();
    }, e.prototype.applyModel = function() {
      var t = this.getModelFromUi();
      if (!this.isModelValid(t))
        return !1;
      var i = this.appliedModel;
      return this.appliedModel = t, !this.areModelsEqual(i, t);
    }, e.prototype.isModelValid = function(t) {
      return !0;
    }, e.prototype.onBtApply = function(t, i, r) {
      t === void 0 && (t = !1), i === void 0 && (i = !1), this.applyModel() && this.providedFilterParams.filterChangedCallback({ afterFloatingFilter: t, afterDataChange: i });
      var o = this.providedFilterParams.closeOnApply;
      o && this.applyActive && !t && !i && this.close(r);
    }, e.prototype.onNewRowsLoaded = function() {
    }, e.prototype.close = function(t) {
      if (this.hidePopup) {
        var i = t, r = i && i.key, o;
        (r === "Enter" || r === "Space") && (o = { keyboardEvent: i }), this.hidePopup(o), this.hidePopup = null;
      }
    }, e.prototype.onUiChanged = function(t, i) {
      if (t === void 0 && (t = !1), this.updateUiVisibility(), this.providedFilterParams.filterModifiedCallback(), this.applyActive && !this.isReadOnly) {
        var r = this.isModelValid(this.getModelFromUi());
        jp(this.getRefElement("applyFilterButton"), !r);
      }
      t && !i || i === "immediately" ? this.onBtApply(t) : (!this.applyActive && !i || i === "debounce") && this.onBtApplyDebounce();
    }, e.prototype.afterGuiAttached = function(t) {
      t != null && (this.hidePopup = t.hidePopup);
    }, e.getDebounceMs = function(t, i) {
      return e.isUseApplyButton(t) ? (t.debounceMs != null && console.warn("AG Grid: debounceMs is ignored when apply button is present"), 0) : t.debounceMs != null ? t.debounceMs : i;
    }, e.isUseApplyButton = function(t) {
      return !!t.buttons && t.buttons.indexOf("apply") >= 0;
    }, e.prototype.destroy = function() {
      this.hidePopup = null, n.prototype.destroy.call(this);
    }, e.prototype.translate = function(t) {
      var i = this.gridOptionsWrapper.getLocaleTextFunc();
      return i(t, TK[t]);
    }, e.prototype.getCellValue = function(t) {
      var i = this.providedFilterParams, r = i.api, o = i.colDef, s = i.column, a = i.columnApi, l = i.context;
      return this.providedFilterParams.valueGetter({
        api: r,
        colDef: o,
        column: s,
        columnApi: a,
        context: l,
        data: t.data,
        getValue: function(u) {
          return t.data[u];
        },
        node: t
      });
    }, _L([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), _L([
      T("valueService")
    ], e.prototype, "valueService", void 0), _L([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var NK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), IK = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Ax = (
  /** @class */
  function(n) {
    NK(e, n);
    function e(t, i) {
      var r = n.call(this, i) || this;
      return r.labelSeparator = "", r.labelAlignment = "left", r.label = "", r.config = t || {}, r;
    }
    return e.prototype.postConstruct = function() {
      this.addCssClass("ag-labeled"), this.eLabel.classList.add("ag-label");
      var t = this.config, i = t.labelSeparator, r = t.label, o = t.labelWidth, s = t.labelAlignment;
      i != null && this.setLabelSeparator(i), r != null && this.setLabel(r), o != null && this.setLabelWidth(o), this.setLabelAlignment(s || this.labelAlignment), this.refreshLabel();
    }, e.prototype.refreshLabel = function() {
      Ls(this.eLabel), typeof this.label == "string" ? this.eLabel.innerText = this.label + this.labelSeparator : this.label && this.eLabel.appendChild(this.label), this.label === "" ? (this.eLabel.classList.add("ag-hidden"), Do(this.eLabel, "presentation")) : (this.eLabel.classList.remove("ag-hidden"), Do(this.eLabel, null));
    }, e.prototype.setLabelSeparator = function(t) {
      return this.labelSeparator === t ? this : (this.labelSeparator = t, this.label != null && this.refreshLabel(), this);
    }, e.prototype.getLabelId = function() {
      return this.eLabel.id = this.eLabel.id || "ag-" + this.getCompId() + "-label", this.eLabel.id;
    }, e.prototype.getLabel = function() {
      return this.label;
    }, e.prototype.setLabel = function(t) {
      return this.label === t ? this : (this.label = t, this.refreshLabel(), this);
    }, e.prototype.setLabelAlignment = function(t) {
      var i = this.getGui(), r = i.classList;
      return r.toggle("ag-label-align-left", t === "left"), r.toggle("ag-label-align-right", t === "right"), r.toggle("ag-label-align-top", t === "top"), this;
    }, e.prototype.setLabelWidth = function(t) {
      return this.label == null ? this : (N_(this.eLabel, t), this);
    }, IK([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var PK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Gl = (
  /** @class */
  function(n) {
    PK(e, n);
    function e(t, i, r) {
      var o = n.call(this, t, i) || this;
      return o.className = r, o.disabled = !1, o;
    }
    return e.prototype.postConstruct = function() {
      n.prototype.postConstruct.call(this), this.className && this.addCssClass(this.className);
    }, e.prototype.onValueChange = function(t) {
      var i = this;
      return this.addManagedListener(this, e.EVENT_CHANGED, function() {
        return t(i.getValue());
      }), this;
    }, e.prototype.getWidth = function() {
      return this.getGui().clientWidth;
    }, e.prototype.setWidth = function(t) {
      return Yl(this.getGui(), t), this;
    }, e.prototype.getPreviousValue = function() {
      return this.previousValue;
    }, e.prototype.getValue = function() {
      return this.value;
    }, e.prototype.setValue = function(t, i) {
      return this.value === t ? this : (this.previousValue = this.value, this.value = t, i || this.dispatchEvent({ type: e.EVENT_CHANGED }), this);
    }, e.prototype.setDisabled = function(t) {
      t = !!t;
      var i = this.getGui();
      return jp(i, t), i.classList.toggle("ag-disabled", t), this.disabled = t, this;
    }, e.prototype.isDisabled = function() {
      return !!this.disabled;
    }, e.EVENT_CHANGED = "valueChange", e;
  }(Ax)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var AK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), kC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, EH = (
  /** @class */
  function(n) {
    AK(e, n);
    function e(t, i, r, o) {
      var s = n.call(
        this,
        t,
        /* html */
        `<div class="ag-picker-field" role="presentation">
                <div ref="eLabel"></div>
                <div ref="eWrapper"
                    class="ag-wrapper ag-picker-field-wrapper"
                    tabIndex="-1"
                    aria-expanded="false"
                    ` + (o ? 'role="' + o + '"' : "") + `
                >
                    <div ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`,
        i
      ) || this;
      return s.pickerIcon = r, s.isPickerDisplayed = !1, s.isDestroyingPicker = !1, s.skipClick = !1, s;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      n.prototype.postConstruct.call(this);
      var i = this.getCompId() + "-display";
      this.eDisplayField.setAttribute("id", i), IS(this.eWrapper, i);
      var r = function() {
        if (t.skipClick) {
          t.skipClick = !1;
          return;
        }
        t.isDisabled() || (t.pickerComponent = t.showPicker());
      }, o = this.getGui();
      if (this.addManagedListener(o, "mousedown", function(a) {
        !t.skipClick && t.pickerComponent && t.pickerComponent.isAlive() && wg(t.pickerComponent.getGui()) && o.contains(a.target) && (t.skipClick = !0);
      }), this.addManagedListener(o, "keydown", function(a) {
        switch (a.key) {
          case _e.UP:
          case _e.DOWN:
          case _e.ENTER:
          case _e.SPACE:
            r();
          case _e.ESCAPE:
            t.isPickerDisplayed && a.preventDefault();
            break;
        }
      }), this.addManagedListener(this.eWrapper, "click", r), this.addManagedListener(this.eLabel, "click", r), this.pickerIcon) {
        var s = Yn(this.pickerIcon, this.gridOptionsWrapper);
        s && this.eIcon.appendChild(s);
      }
    }, e.prototype.refreshLabel = function() {
      ge(this.getLabel()) ? Dx(this.eWrapper, this.getLabelId()) : this.eWrapper.removeAttribute("aria-labelledby"), n.prototype.refreshLabel.call(this);
    }, e.prototype.setAriaLabel = function(t) {
      return tf(this.eWrapper, t), this;
    }, e.prototype.setInputWidth = function(t) {
      return N_(this.eWrapper, t), this;
    }, e.prototype.getFocusableElement = function() {
      return this.eWrapper;
    }, kC([
      ve("eLabel")
    ], e.prototype, "eLabel", void 0), kC([
      ve("eWrapper")
    ], e.prototype, "eWrapper", void 0), kC([
      ve("eDisplayField")
    ], e.prototype, "eDisplayField", void 0), kC([
      ve("eIcon")
    ], e.prototype, "eIcon", void 0), e;
  }(Gl)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var MK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), FK = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, VM = (
  /** @class */
  function(n) {
    MK(e, n);
    function e(t) {
      t === void 0 && (t = "default");
      var i = n.call(
        this,
        /* html */
        '<div class="ag-list ag-' + t + '-list" role="listbox"></div>'
      ) || this;
      return i.cssIdentifier = t, i.options = [], i.itemEls = [], i;
    }
    return e.prototype.init = function() {
      this.addManagedListener(this.getGui(), "keydown", this.handleKeyDown.bind(this));
    }, e.prototype.handleKeyDown = function(t) {
      var i = t.key;
      switch (i) {
        case _e.ENTER:
          if (!this.highlightedEl)
            this.setValue(this.getValue());
          else {
            var r = this.itemEls.indexOf(this.highlightedEl);
            this.setValueByIndex(r);
          }
          break;
        case _e.DOWN:
        case _e.UP:
          var o = i === _e.DOWN, s = void 0;
          if (t.preventDefault(), !this.highlightedEl)
            s = this.itemEls[o ? 0 : this.itemEls.length - 1];
          else {
            var a = this.itemEls.indexOf(this.highlightedEl), l = a + (o ? 1 : -1);
            l = Math.min(Math.max(l, 0), this.itemEls.length - 1), s = this.itemEls[l];
          }
          this.highlightItem(s);
          break;
      }
    }, e.prototype.addOptions = function(t) {
      var i = this;
      return t.forEach(function(r) {
        return i.addOption(r);
      }), this;
    }, e.prototype.addOption = function(t) {
      var i = t.value, r = t.text, o = ql(r || i);
      return this.options.push({ value: i, text: o }), this.renderOption(i, o), this.updateIndices(), this;
    }, e.prototype.updateIndices = function() {
      var t = this.getGui().querySelectorAll(".ag-list-item");
      t.forEach(function(i, r) {
        Tx(i, r + 1), Rx(i, t.length);
      });
    }, e.prototype.renderOption = function(t, i) {
      var r = this, o = document.createElement("div");
      Do(o, "option"), o.classList.add("ag-list-item", "ag-" + this.cssIdentifier + "-list-item"), o.innerHTML = "<span>" + i + "</span>", o.tabIndex = -1, this.itemEls.push(o), this.addManagedListener(o, "mouseover", function() {
        return r.highlightItem(o);
      }), this.addManagedListener(o, "mouseleave", function() {
        return r.clearHighlighted();
      }), this.addManagedListener(o, "click", function() {
        return r.setValue(t);
      }), this.getGui().appendChild(o);
    }, e.prototype.setValue = function(t, i) {
      if (this.value === t)
        return this.fireItemSelected(), this;
      if (t == null)
        return this.reset(), this;
      var r = this.options.findIndex(function(s) {
        return s.value === t;
      });
      if (r !== -1) {
        var o = this.options[r];
        this.value = o.value, this.displayValue = o.text != null ? o.text : o.value, this.highlightItem(this.itemEls[r]), i || this.fireChangeEvent();
      }
      return this;
    }, e.prototype.setValueByIndex = function(t) {
      return this.setValue(this.options[t].value);
    }, e.prototype.getValue = function() {
      return this.value;
    }, e.prototype.getDisplayValue = function() {
      return this.displayValue;
    }, e.prototype.refreshHighlighted = function() {
      var t = this;
      this.clearHighlighted();
      var i = this.options.findIndex(function(r) {
        return r.value === t.value;
      });
      i !== -1 && this.highlightItem(this.itemEls[i]);
    }, e.prototype.reset = function() {
      this.value = null, this.displayValue = null, this.clearHighlighted(), this.fireChangeEvent();
    }, e.prototype.highlightItem = function(t) {
      t.offsetParent && (this.clearHighlighted(), this.highlightedEl = t, this.highlightedEl.classList.add(e.ACTIVE_CLASS), $p(this.highlightedEl, !0), this.highlightedEl.focus());
    }, e.prototype.clearHighlighted = function() {
      !this.highlightedEl || !this.highlightedEl.offsetParent || (this.highlightedEl.classList.remove(e.ACTIVE_CLASS), $p(this.highlightedEl, !1), this.highlightedEl = null);
    }, e.prototype.fireChangeEvent = function() {
      this.dispatchEvent({ type: Gl.EVENT_CHANGED }), this.fireItemSelected();
    }, e.prototype.fireItemSelected = function() {
      this.dispatchEvent({ type: e.EVENT_ITEM_SELECTED });
    }, e.EVENT_ITEM_SELECTED = "selectedItem", e.ACTIVE_CLASS = "ag-active-item", FK([
      Le
    ], e.prototype, "init", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var kK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), BM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Mx = (
  /** @class */
  function(n) {
    kK(e, n);
    function e(t) {
      return n.call(this, t, "ag-select", "smallDown", "listbox") || this;
    }
    return e.prototype.init = function() {
      var t = this;
      this.listComponent = this.createBean(new VM("select")), this.listComponent.setParentComponent(this), this.eWrapper.tabIndex = 0, this.listComponent.addManagedListener(this.listComponent, VM.EVENT_ITEM_SELECTED, function() {
        t.hideList && t.hideList();
      }), this.listComponent.addManagedListener(this.listComponent, Gl.EVENT_CHANGED, function() {
        t.setValue(t.listComponent.getValue(), !1, !0), t.hideList && t.hideList();
      });
    }, e.prototype.showPicker = function() {
      var t = this, i = this.listComponent.getGui(), r = this.gridOptionsWrapper.getDocument(), o = this.addManagedListener(r.body, "wheel", function(u) {
        !i.contains(u.target) && t.hideList && t.hideList();
      }), s = this.addManagedListener(i, "focusout", function(u) {
        !i.contains(u.relatedTarget) && t.hideList && t.hideList();
      }), a = this.gridOptionsWrapper.getLocaleTextFunc(), l = this.popupService.addPopup({
        modal: !0,
        eChild: i,
        closeOnEsc: !0,
        closedCallback: function() {
          t.hideList = null, t.isPickerDisplayed = !1, s(), o(), t.isAlive() && (bs(t.eWrapper, !1), t.getFocusableElement().focus());
        },
        ariaLabel: a("ariaLabelSelectField", "Select Field")
      });
      return l && (this.hideList = l.hideFunc), this.isPickerDisplayed = !0, N_(i, NS(this.eWrapper)), bs(this.eWrapper, !0), i.style.maxHeight = x_(this.popupService.getPopupParent()) + "px", i.style.position = "absolute", this.popupService.positionPopupUnderComponent({
        type: "ag-list",
        eventSource: this.eWrapper,
        ePopup: i,
        keepWithinBounds: !0
      }), this.listComponent.refreshHighlighted(), this.listComponent;
    }, e.prototype.addOptions = function(t) {
      var i = this;
      return t.forEach(function(r) {
        return i.addOption(r);
      }), this;
    }, e.prototype.addOption = function(t) {
      return this.listComponent.addOption(t), this;
    }, e.prototype.setValue = function(t, i, r) {
      if (this.value === t)
        return this;
      r || this.listComponent.setValue(t, !0);
      var o = this.listComponent.getValue();
      return o === this.getValue() ? this : (this.eDisplayField.innerHTML = this.listComponent.getDisplayValue(), n.prototype.setValue.call(this, t, i));
    }, e.prototype.destroy = function() {
      this.hideList && this.hideList(), this.destroyBean(this.listComponent), n.prototype.destroy.call(this);
    }, BM([
      T("popupService")
    ], e.prototype, "popupService", void 0), BM([
      Le
    ], e.prototype, "init", null), e;
  }(EH)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var WK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), CL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Hu = (
  /** @class */
  function(n) {
    WK(e, n);
    function e(t, i, r, o) {
      r === void 0 && (r = "text"), o === void 0 && (o = "input");
      var s = n.call(
        this,
        t,
        /* html */
        `
            <div role="presentation">
                <div ref="eLabel" class="ag-input-field-label"></div>
                <div ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <` + o + ' ref="eInput" class="ag-input-field-input"></' + o + `>
                </div>
            </div>`,
        i
      ) || this;
      return s.inputType = r, s.displayFieldTag = o, s;
    }
    return e.prototype.postConstruct = function() {
      n.prototype.postConstruct.call(this), this.setInputType(), this.eLabel.classList.add(this.className + "-label"), this.eWrapper.classList.add(this.className + "-input-wrapper"), this.eInput.classList.add(this.className + "-input"), this.addCssClass("ag-input-field"), this.eInput.id = this.eInput.id || "ag-" + this.getCompId() + "-input";
      var t = this.config, i = t.width, r = t.value;
      i != null && this.setWidth(i), r != null && this.setValue(r), this.addInputListeners();
    }, e.prototype.refreshLabel = function() {
      ge(this.getLabel()) ? Dx(this.eInput, this.getLabelId()) : this.eInput.removeAttribute("aria-labelledby"), n.prototype.refreshLabel.call(this);
    }, e.prototype.addInputListeners = function() {
      var t = this;
      this.addManagedListener(this.eInput, "input", function(i) {
        return t.setValue(i.target.value);
      });
    }, e.prototype.setInputType = function() {
      this.displayFieldTag === "input" && this.eInput.setAttribute("type", this.inputType);
    }, e.prototype.getInputElement = function() {
      return this.eInput;
    }, e.prototype.setInputWidth = function(t) {
      return N_(this.eWrapper, t), this;
    }, e.prototype.setInputName = function(t) {
      return this.getInputElement().setAttribute("name", t), this;
    }, e.prototype.getFocusableElement = function() {
      return this.eInput;
    }, e.prototype.setMaxLength = function(t) {
      var i = this.eInput;
      return i.maxLength = t, this;
    }, e.prototype.setInputPlaceholder = function(t) {
      return lv(this.eInput, "placeholder", t), this;
    }, e.prototype.setInputAriaLabel = function(t) {
      return tf(this.eInput, t), this;
    }, e.prototype.setDisabled = function(t) {
      return jp(this.eInput, t), n.prototype.setDisabled.call(this, t);
    }, CL([
      ve("eLabel")
    ], e.prototype, "eLabel", void 0), CL([
      ve("eWrapper")
    ], e.prototype, "eWrapper", void 0), CL([
      ve("eInput")
    ], e.prototype, "eInput", void 0), e;
  }(Gl)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var VK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Fh = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, qr;
(function(n) {
  n[n.One = 0] = "One", n[n.Two = 1] = "Two";
})(qr || (qr = {}));
var En = (
  /** @class */
  function(n) {
    VK(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getNumberOfInputs = function(t) {
      var i = this.optionsFactory.getCustomOption(t);
      if (i) {
        var r = i.numberOfInputs;
        return r ?? 1;
      }
      var o = [
        e.EMPTY,
        e.NOT_BLANK,
        e.BLANK
      ];
      return t && o.indexOf(t) >= 0 ? 0 : t === e.IN_RANGE ? 2 : 1;
    }, e.prototype.onFloatingFilterChanged = function(t, i) {
      this.setTypeFromFloatingFilter(t), this.setValueFromFloatingFilter(i), this.onUiChanged(!0);
    }, e.prototype.setTypeFromFloatingFilter = function(t) {
      this.eType1.setValue(t), this.eType2.setValue(this.optionsFactory.getDefaultOption()), (this.isDefaultOperator("AND") ? this.eJoinOperatorAnd : this.eJoinOperatorOr).setValue(!0);
    }, e.prototype.getModelFromUi = function() {
      return this.isConditionUiComplete(qr.One) ? this.isAllowTwoConditions() && this.isConditionUiComplete(qr.Two) ? {
        filterType: this.getFilterType(),
        operator: this.getJoinOperator(),
        condition1: this.createCondition(qr.One),
        condition2: this.createCondition(qr.Two)
      } : this.createCondition(qr.One) : null;
    }, e.prototype.getConditionTypes = function() {
      return [
        this.eType1.getValue(),
        this.eType2.getValue()
      ];
    }, e.prototype.getJoinOperator = function() {
      return this.eJoinOperatorOr.getValue() === !0 ? "OR" : "AND";
    }, e.prototype.areModelsEqual = function(t, i) {
      if (!t && !i)
        return !0;
      if (!t && i || t && !i)
        return !1;
      var r = !t.operator, o = !i.operator, s = !r && o || r && !o;
      if (s)
        return !1;
      var a;
      if (r) {
        var l = t, u = i;
        a = this.areSimpleModelsEqual(l, u);
      } else {
        var c = t, h = i;
        a = c.operator === h.operator && this.areSimpleModelsEqual(c.condition1, h.condition1) && this.areSimpleModelsEqual(c.condition2, h.condition2);
      }
      return a;
    }, e.prototype.setModelIntoUi = function(t) {
      var i = t.operator;
      if (i) {
        var r = t, o = r.operator === "OR";
        this.eJoinOperatorAnd.setValue(!o), this.eJoinOperatorOr.setValue(o), this.eType1.setValue(r.condition1.type), this.eType2.setValue(r.condition2.type), this.setConditionIntoUi(r.condition1, qr.One), this.setConditionIntoUi(r.condition2, qr.Two);
      } else {
        var s = t;
        this.eJoinOperatorAnd.setValue(this.isDefaultOperator("AND")), this.eJoinOperatorOr.setValue(this.isDefaultOperator("OR")), this.eType1.setValue(s.type), this.eType2.setValue(this.optionsFactory.getDefaultOption()), this.setConditionIntoUi(s, qr.One), this.setConditionIntoUi(null, qr.Two);
      }
      return Bo.resolve();
    }, e.prototype.doesFilterPass = function(t) {
      var i = this, r = this.getModel();
      if (r == null)
        return !0;
      var o = r.operator, s = [];
      if (o) {
        var a = r;
        s.push(a.condition1, a.condition2);
      } else
        s.push(r);
      var l = o && o === "OR" ? "some" : "every";
      return s[l](function(u) {
        return i.individualConditionPasses(t, u);
      });
    }, e.prototype.setParams = function(t) {
      n.prototype.setParams.call(this, t), this.optionsFactory = new SH(), this.optionsFactory.init(t, this.getDefaultFilterOptions()), this.allowTwoConditions = !t.suppressAndOrCondition, this.alwaysShowBothConditions = !!t.alwaysShowBothConditions, this.defaultJoinOperator = this.getDefaultJoinOperator(t.defaultJoinOperator), this.putOptionsIntoDropdown(), this.addChangedListeners();
    }, e.prototype.getDefaultJoinOperator = function(t) {
      return Es(["AND", "OR"], t) ? t : "AND";
    }, e.prototype.putOptionsIntoDropdown = function() {
      var t = this, i = this.optionsFactory.getFilterOptions(), r = [this.eType1, this.eType2];
      i.forEach(function(o) {
        var s = typeof o == "string" ? t.createBoilerplateListOption(o) : t.createCustomListOption(o);
        r.forEach(function(a) {
          return a.addOption(s);
        });
      }), r.forEach(function(o) {
        return o.setDisabled(i.length <= 1);
      });
    }, e.prototype.createBoilerplateListOption = function(t) {
      return { value: t, text: this.translate(t) };
    }, e.prototype.createCustomListOption = function(t) {
      var i = t.displayKey, r = this.optionsFactory.getCustomOption(t.displayKey);
      return {
        value: i,
        text: r ? this.gridOptionsWrapper.getLocaleTextFunc()(r.displayKey, r.displayName) : this.translate(i)
      };
    }, e.prototype.isAllowTwoConditions = function() {
      return this.allowTwoConditions;
    }, e.prototype.createBodyTemplate = function() {
      return (
        /* html */
        `
            <ag-select class="ag-filter-select" ref="eOptions1"></ag-select>
            ` + this.createValueTemplate(qr.One) + `
            <div class="ag-filter-condition" ref="eJoinOperatorPanel">
               <ag-radio-button ref="eJoinOperatorAnd" class="ag-filter-condition-operator ag-filter-condition-operator-and"></ag-radio-button>
               <ag-radio-button ref="eJoinOperatorOr" class="ag-filter-condition-operator ag-filter-condition-operator-or"></ag-radio-button>
            </div>
            <ag-select class="ag-filter-select" ref="eOptions2"></ag-select>
            ` + this.createValueTemplate(qr.Two)
      );
    }, e.prototype.getCssIdentifier = function() {
      return "simple-filter";
    }, e.prototype.updateUiVisibility = function() {
      var t = this, i = [
        [this.eType1],
        [this.eType2, this.eJoinOperatorPanel, this.eJoinOperatorAnd, this.eJoinOperatorOr]
      ], r = [this.eCondition1Body, this.eCondition2Body];
      i.forEach(function(o, s) {
        var a = t.isConditionVisible(s), l = t.isConditionDisabled(s);
        o.forEach(function(u) {
          u instanceof Hu || u instanceof Mx ? (u.setDisabled(l), u.setDisplayed(a)) : (jp(u, l), Bi(u, a));
        });
      }), r.forEach(function(o, s) {
        Bi(o, t.isConditionBodyVisible(s));
      }), this.forEachInput(function(o, s, a, l) {
        t.setElementDisplayed(o, s < l), t.setElementDisabled(o, t.isConditionDisabled(a));
      }), this.resetPlaceholder();
    }, e.prototype.afterGuiAttached = function(t) {
      if (n.prototype.afterGuiAttached.call(this, t), this.resetPlaceholder(), !t || !t.suppressFocus && !this.isReadOnly()) {
        var i = this.getInputs()[0][0];
        if (!i)
          return;
        i instanceof Hu && i.getInputElement().focus();
      }
    }, e.prototype.resetPlaceholder = function() {
      var t = this, i = this.gridOptionsWrapper.getLocaleTextFunc();
      this.forEachInput(function(r, o, s, a) {
        if (r instanceof Hu) {
          var l = o === 0 && a > 1 ? "inRangeStart" : o === 0 ? "filterOoo" : "inRangeEnd", u = o === 0 && a > 1 ? i("ariaFilterFromValue", "Filter from value") : o === 0 ? i("ariaFilterValue", "Filter Value") : i("ariaFilterToValue", "Filter to Value");
          r.setInputPlaceholder(t.translate(l)), r.setInputAriaLabel(u);
        }
      });
    }, e.prototype.setElementValue = function(t, i, r) {
      t instanceof Hu && t.setValue(i != null ? String(i) : null, r);
    }, e.prototype.setElementDisplayed = function(t, i) {
      t instanceof Et && Bi(t.getGui(), i);
    }, e.prototype.setElementDisabled = function(t, i) {
      t instanceof Et && jp(t.getGui(), i);
    }, e.prototype.attachElementOnChange = function(t, i) {
      t instanceof Hu && t.onValueChange(i);
    }, e.prototype.forEachInput = function(t) {
      var i = this, r = this.getInputs();
      this.getConditionTypes().forEach(function(o, s) {
        for (var a = i.getNumberOfInputs(o), l = 0; l < r[s].length; l++) {
          var u = r[s][l];
          u != null && t(u, l, s, a);
        }
      });
    }, e.prototype.isConditionVisible = function(t) {
      return t === 0 ? !0 : this.allowTwoConditions ? this.isReadOnly() ? this.isConditionUiComplete(t) : this.alwaysShowBothConditions ? !0 : this.isConditionUiComplete(t - 1) : !1;
    }, e.prototype.isConditionDisabled = function(t) {
      return this.isReadOnly() || !this.isConditionVisible(t) ? !0 : t === 0 ? !1 : !this.isConditionUiComplete(t - 1);
    }, e.prototype.isConditionBodyVisible = function(t) {
      if (!this.isConditionVisible(t))
        return !1;
      var i = this.getConditionTypes()[t], r = this.getNumberOfInputs(i);
      return r > 0;
    }, e.prototype.isConditionUiComplete = function(t) {
      var i = this.getConditionTypes()[t];
      return !(i === e.EMPTY || this.getValues(t).some(function(r) {
        return r == null;
      }));
    }, e.prototype.resetUiToDefaults = function(t) {
      var i = this, r = this.gridOptionsWrapper.getLocaleTextFunc(), o = r("ariaFilteringOperator", "Filtering operator"), s = "ag-simple-filter-and-or-" + this.getCompId(), a = this.optionsFactory.getDefaultOption();
      return this.eType1.setValue(a, t).setAriaLabel(o).setDisabled(this.isReadOnly()), this.eType2.setValue(this.optionsFactory.getDefaultOption(), t).setAriaLabel(o).setDisabled(this.isReadOnly()), this.eJoinOperatorAnd.setValue(this.isDefaultOperator("AND"), t).setName(s).setLabel(this.translate("andCondition")).setDisabled(this.isReadOnly()), this.eJoinOperatorOr.setValue(this.isDefaultOperator("OR"), t).setName(s).setLabel(this.translate("orCondition")).setDisabled(this.isReadOnly()), this.forEachInput(function(l) {
        i.setElementValue(l, null, t), i.setElementDisabled(l, i.isReadOnly());
      }), this.resetPlaceholder(), Bo.resolve();
    }, e.prototype.setConditionIntoUi = function(t, i) {
      var r = this, o = this.mapValuesFromModel(t);
      this.forEachInput(function(s, a, l, u) {
        l === i && r.setElementValue(s, o[a] != null ? o[a] : null);
      });
    }, e.prototype.setValueFromFloatingFilter = function(t) {
      var i = this;
      this.forEachInput(function(r, o, s, a) {
        i.setElementValue(r, o === 0 && s === 0 ? t : null);
      });
    }, e.prototype.isDefaultOperator = function(t) {
      return t === this.defaultJoinOperator;
    }, e.prototype.addChangedListeners = function() {
      var t = this;
      if (!this.isReadOnly()) {
        var i = function() {
          return t.onUiChanged();
        };
        this.eType1.onValueChange(i), this.eType2.onValueChange(i), this.eJoinOperatorOr.onValueChange(i), this.eJoinOperatorAnd.onValueChange(i), this.forEachInput(function(r) {
          t.attachElementOnChange(r, i);
        });
      }
    }, e.prototype.individualConditionPasses = function(t, i) {
      var r = this.getCellValue(t.node), o = this.mapValuesFromModel(i), s = this.optionsFactory.getCustomOption(i.type), a = this.evaluateCustomFilter(s, o, r);
      return a ?? (r == null ? this.evaluateNullValue(i.type) : this.evaluateNonNullValue(o, r, i, t));
    }, e.prototype.evaluateCustomFilter = function(t, i, r) {
      if (t != null) {
        var o = t.predicate;
        if (o != null && !i.some(function(s) {
          return s == null;
        }))
          return o(i, r);
      }
    }, e.prototype.isBlank = function(t) {
      return t == null || typeof t == "string" && t.trim().length === 0;
    }, e.EMPTY = "empty", e.BLANK = "blank", e.NOT_BLANK = "notBlank", e.EQUALS = "equals", e.NOT_EQUAL = "notEqual", e.LESS_THAN = "lessThan", e.LESS_THAN_OR_EQUAL = "lessThanOrEqual", e.GREATER_THAN = "greaterThan", e.GREATER_THAN_OR_EQUAL = "greaterThanOrEqual", e.IN_RANGE = "inRange", e.CONTAINS = "contains", e.NOT_CONTAINS = "notContains", e.STARTS_WITH = "startsWith", e.ENDS_WITH = "endsWith", Fh([
      ve("eOptions1")
    ], e.prototype, "eType1", void 0), Fh([
      ve("eOptions2")
    ], e.prototype, "eType2", void 0), Fh([
      ve("eJoinOperatorPanel")
    ], e.prototype, "eJoinOperatorPanel", void 0), Fh([
      ve("eJoinOperatorAnd")
    ], e.prototype, "eJoinOperatorAnd", void 0), Fh([
      ve("eJoinOperatorOr")
    ], e.prototype, "eJoinOperatorOr", void 0), Fh([
      ve("eCondition1Body")
    ], e.prototype, "eCondition1Body", void 0), Fh([
      ve("eCondition2Body")
    ], e.prototype, "eCondition2Body", void 0), e;
  }(zv)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var BK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), hr = (
  /** @class */
  function(n) {
    BK(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setParams = function(t) {
      n.prototype.setParams.call(this, t), this.scalarFilterParams = t;
    }, e.prototype.evaluateNullValue = function(t) {
      switch (t) {
        case e.EQUALS:
        case e.NOT_EQUAL:
          if (this.scalarFilterParams.includeBlanksInEquals)
            return !0;
          break;
        case e.GREATER_THAN:
        case e.GREATER_THAN_OR_EQUAL:
          if (this.scalarFilterParams.includeBlanksInGreaterThan)
            return !0;
          break;
        case e.LESS_THAN:
        case e.LESS_THAN_OR_EQUAL:
          if (this.scalarFilterParams.includeBlanksInLessThan)
            return !0;
          break;
        case e.IN_RANGE:
          if (this.scalarFilterParams.includeBlanksInRange)
            return !0;
          break;
        case e.BLANK:
          return !0;
        case e.NOT_BLANK:
          return !1;
      }
      return !1;
    }, e.prototype.evaluateNonNullValue = function(t, i, r) {
      var o = this.comparator(), s = t[0] != null ? o(t[0], i) : 0;
      switch (r.type) {
        case e.EQUALS:
          return s === 0;
        case e.NOT_EQUAL:
          return s !== 0;
        case e.GREATER_THAN:
          return s > 0;
        case e.GREATER_THAN_OR_EQUAL:
          return s >= 0;
        case e.LESS_THAN:
          return s < 0;
        case e.LESS_THAN_OR_EQUAL:
          return s <= 0;
        case e.IN_RANGE: {
          var a = o(t[1], i);
          return this.scalarFilterParams.inRangeInclusive ? s >= 0 && a <= 0 : s > 0 && a < 0;
        }
        case e.BLANK:
          return this.isBlank(i);
        case e.NOT_BLANK:
          return !this.isBlank(i);
        default:
          return console.warn('AG Grid: Unexpected type of filter "' + r.type + '", it looks like the filter was configured with incorrect Filter Options'), !0;
      }
    }, e;
  }(En)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var HK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), eR = globalThis && globalThis.__assign || function() {
  return eR = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, eR.apply(this, arguments);
}, hm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, HM = 1e3, GM = 1 / 0, Fx = (
  /** @class */
  function(n) {
    HK(e, n);
    function e() {
      var t = n.call(this, "dateFilter") || this;
      return t.minValidYear = HM, t.maxValidYear = GM, t;
    }
    return e.prototype.afterGuiAttached = function(t) {
      n.prototype.afterGuiAttached.call(this, t), this.dateCondition1FromComp.afterGuiAttached(t);
    }, e.prototype.mapValuesFromModel = function(t) {
      var i = t || {}, r = i.dateFrom, o = i.dateTo, s = i.type;
      return [
        r && $c(r) || null,
        o && $c(o) || null
      ].slice(0, this.getNumberOfInputs(s));
    }, e.prototype.comparator = function() {
      return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this);
    }, e.prototype.defaultComparator = function(t, i) {
      var r = i;
      return i == null || r < t ? -1 : r > t ? 1 : 0;
    }, e.prototype.setParams = function(t) {
      n.prototype.setParams.call(this, t), this.dateFilterParams = t;
      var i = function(r, o) {
        if (t[r] != null)
          if (isNaN(t[r]))
            console.warn("AG Grid: DateFilter " + r + " is not a number");
          else
            return t[r] == null ? o : Number(t[r]);
        return o;
      };
      this.minValidYear = i("minValidYear", HM), this.maxValidYear = i("maxValidYear", GM), this.minValidYear > this.maxValidYear && console.warn("AG Grid: DateFilter minValidYear should be <= maxValidYear"), this.createDateComponents();
    }, e.prototype.createDateComponents = function() {
      var t = this, i = function(r) {
        return new bH(t.getContext(), t.userComponentFactory, {
          onDateChanged: function() {
            return t.onUiChanged();
          },
          filterParams: t.dateFilterParams
        }, r);
      };
      this.dateCondition1FromComp = i(this.eCondition1PanelFrom), this.dateCondition1ToComp = i(this.eCondition1PanelTo), this.dateCondition2FromComp = i(this.eCondition2PanelFrom), this.dateCondition2ToComp = i(this.eCondition2PanelTo), this.addDestroyFunc(function() {
        t.forEachInput(function(r) {
          return r.destroy();
        });
      });
    }, e.prototype.setElementValue = function(t, i, r) {
      t.setDate(i);
    }, e.prototype.setElementDisplayed = function(t, i) {
      t.setDisplayed(i);
    }, e.prototype.setElementDisabled = function(t, i) {
      t.setDisabled(i);
    }, e.prototype.getDefaultFilterOptions = function() {
      return e.DEFAULT_FILTER_OPTIONS;
    }, e.prototype.createValueTemplate = function(t) {
      var i = t === qr.One ? "1" : "2";
      return (
        /* html */
        `
            <div class="ag-filter-body" ref="eCondition` + i + `Body">
                <div class="ag-filter-from ag-filter-date-from" ref="eCondition` + i + `PanelFrom"></div>
                <div class="ag-filter-to ag-filter-date-to" ref="eCondition` + i + `PanelTo"></div>
            </div>`
      );
    }, e.prototype.isConditionUiComplete = function(t) {
      var i = this;
      if (!n.prototype.isConditionUiComplete.call(this, t))
        return !1;
      var r = function(s) {
        return s != null && s.getUTCFullYear() >= i.minValidYear && s.getUTCFullYear() <= i.maxValidYear;
      }, o = !0;
      return this.forEachInput(function(s, a, l, u) {
        l !== t || !o || a >= u || (o = o && r(s.getDate()));
      }), o;
    }, e.prototype.areSimpleModelsEqual = function(t, i) {
      return t.dateFrom === i.dateFrom && t.dateTo === i.dateTo && t.type === i.type;
    }, e.prototype.getFilterType = function() {
      return "date";
    }, e.prototype.createCondition = function(t) {
      var i = this.getConditionTypes()[t], r = {}, o = this.getValues(t);
      return o.length > 0 && (r.dateFrom = jc(o[0])), o.length > 1 && (r.dateTo = jc(o[1])), eR({ dateFrom: null, dateTo: null, filterType: this.getFilterType(), type: i }, r);
    }, e.prototype.resetPlaceholder = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = this.translate("dateFormatOoo"), r = t("ariaFilterValue", "Filter Value");
      this.forEachInput(function(o) {
        o.setInputPlaceholder(i), o.setInputAriaLabel(r);
      });
    }, e.prototype.getInputs = function() {
      return [
        [this.dateCondition1FromComp, this.dateCondition1ToComp],
        [this.dateCondition2FromComp, this.dateCondition2ToComp]
      ];
    }, e.prototype.getValues = function(t) {
      var i = [];
      return this.forEachInput(function(r, o, s, a) {
        t === s && o < a && i.push(r.getDate());
      }), i;
    }, e.DEFAULT_FILTER_OPTIONS = [
      hr.EQUALS,
      hr.GREATER_THAN,
      hr.LESS_THAN,
      hr.NOT_EQUAL,
      hr.IN_RANGE,
      hr.BLANK,
      hr.NOT_BLANK
    ], hm([
      ve("eCondition1PanelFrom")
    ], e.prototype, "eCondition1PanelFrom", void 0), hm([
      ve("eCondition1PanelTo")
    ], e.prototype, "eCondition1PanelTo", void 0), hm([
      ve("eCondition2PanelFrom")
    ], e.prototype, "eCondition2PanelFrom", void 0), hm([
      ve("eCondition2PanelTo")
    ], e.prototype, "eCondition2PanelTo", void 0), hm([
      T("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), e;
  }(hr)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var GK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), LH = (
  /** @class */
  function(n) {
    GK(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getDefaultDebounceMs = function() {
      return 0;
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.getTextFromModel = function(t) {
      if (!t)
        return null;
      var i = t.operator != null;
      if (i) {
        var r = t, o = r || {}, s = o.condition1, a = o.condition2, l = this.optionsFactory.getCustomOption(s.type), u = this.optionsFactory.getCustomOption(a.type);
        return [
          this.conditionToString(s, l),
          r.operator,
          this.conditionToString(a, u)
        ].join(" ");
      } else {
        var c = t, h = this.optionsFactory.getCustomOption(c.type), d = h || {}, f = d.displayKey, p = d.displayName, g = d.numberOfInputs;
        return f && p && g === 0 ? (this.gridOptionsWrapper.getLocaleTextFunc()(f, p), p) : this.conditionToString(c, h);
      }
    }, e.prototype.isEventFromFloatingFilter = function(t) {
      return t && t.afterFloatingFilter;
    }, e.prototype.getLastType = function() {
      return this.lastType;
    }, e.prototype.isReadOnly = function() {
      return this.readOnly;
    }, e.prototype.setLastTypeFromModel = function(t) {
      if (!t) {
        this.lastType = this.optionsFactory.getDefaultOption();
        return;
      }
      var i = t.operator, r;
      if (i) {
        var o = t;
        r = o.condition1;
      } else
        r = t;
      this.lastType = r.type;
    }, e.prototype.canWeEditAfterModelFromParentFilter = function(t) {
      if (!t)
        return this.isTypeEditable(this.lastType);
      var i = t.operator;
      if (i)
        return !1;
      var r = t;
      return this.isTypeEditable(r.type);
    }, e.prototype.init = function(t) {
      this.optionsFactory = new SH(), this.optionsFactory.init(t.filterParams, this.getDefaultFilterOptions()), this.lastType = this.optionsFactory.getDefaultOption(), this.readOnly = !!t.filterParams.readOnly;
      var i = this.isTypeEditable(this.lastType);
      this.setEditable(i);
    }, e.prototype.doesFilterHaveSingleInput = function(t) {
      var i = this.optionsFactory.getCustomOption(t), r = (i || {}).numberOfInputs;
      return r == null || r == 1;
    }, e.prototype.isTypeEditable = function(t) {
      var i = [
        En.IN_RANGE,
        En.EMPTY,
        En.BLANK,
        En.NOT_BLANK
      ];
      return !!t && !this.isReadOnly() && this.doesFilterHaveSingleInput(t) && i.indexOf(t) < 0;
    }, e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var UK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), yL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, zK = (
  /** @class */
  function(n) {
    UK(e, n);
    function e() {
      return n.call(
        this,
        /* html */
        `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eReadOnlyText"></ag-input-text-field>
                <div ref="eDateWrapper" style="display: flex;"></div>
            </div>`
      ) || this;
    }
    return e.prototype.getDefaultFilterOptions = function() {
      return Fx.DEFAULT_FILTER_OPTIONS;
    }, e.prototype.conditionToString = function(t, i) {
      var r = t.type, o = (i || {}).numberOfInputs, s = r == En.IN_RANGE || o === 2, a = $c(t.dateFrom), l = $c(t.dateTo);
      return s ? jc(a, !1) + "-" + jc(l, !1) : a != null ? "" + jc(a, !1) : "" + r;
    }, e.prototype.init = function(t) {
      n.prototype.init.call(this, t), this.params = t, this.createDateComponent();
      var i = this.gridOptionsWrapper.getLocaleTextFunc();
      this.eReadOnlyText.setDisabled(!0).setInputAriaLabel(i("ariaDateFilterInput", "Date Filter Input"));
    }, e.prototype.setEditable = function(t) {
      Bi(this.eDateWrapper, t), Bi(this.eReadOnlyText.getGui(), !t);
    }, e.prototype.onParentModelChanged = function(t, i) {
      if (!this.isEventFromFloatingFilter(i)) {
        n.prototype.setLastTypeFromModel.call(this, t);
        var r = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(t);
        if (this.setEditable(r), r) {
          if (t) {
            var o = t;
            this.dateComp.setDate($c(o.dateFrom));
          } else
            this.dateComp.setDate(null);
          this.eReadOnlyText.setValue("");
        } else
          this.eReadOnlyText.setValue(this.getTextFromModel(t)), this.dateComp.setDate(null);
      }
    }, e.prototype.onDateChanged = function() {
      var t = this, i = this.dateComp.getDate(), r = jc(i);
      this.params.parentFilterInstance(function(o) {
        if (o) {
          var s = $c(r);
          o.onFloatingFilterChanged(t.getLastType() || null, s);
        }
      });
    }, e.prototype.createDateComponent = function() {
      var t = this, i = zv.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs()), r = {
        onDateChanged: lh(this.onDateChanged.bind(this), i),
        filterParams: this.params.column.getColDef().filterParams
      };
      this.dateComp = new bH(this.getContext(), this.userComponentFactory, r, this.eDateWrapper), this.addDestroyFunc(function() {
        return t.dateComp.destroy();
      });
    }, yL([
      T("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), yL([
      ve("eReadOnlyText")
    ], e.prototype, "eReadOnlyText", void 0), yL([
      ve("eDateWrapper")
    ], e.prototype, "eDateWrapper", void 0), e;
  }(LH)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var jK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), $K = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, KK = (
  /** @class */
  function(n) {
    jK(e, n);
    function e() {
      return n.call(
        this,
        /* html */
        `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" ref="eDateInput"></ag-input-text-field>
            </div>`
      ) || this;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.init = function(t) {
      var i = this, r = this.gridOptionsWrapper.getDocument(), o = this.eDateInput.getInputElement();
      this.shouldUseBrowserDatePicker(t) && (o.type = "date"), this.addManagedListener(o, "mousedown", function() {
        i.eDateInput.isDisabled() || o.focus();
      }), this.addManagedListener(o, "input", function(u) {
        u.target === r.activeElement && (i.eDateInput.isDisabled() || t.onDateChanged());
      });
      var s = t.filterParams || {}, a = s.minValidYear, l = s.maxValidYear;
      a && (o.min = a + "-01-01"), l && (o.max = l + "-12-31");
    }, e.prototype.getDate = function() {
      return $c(this.eDateInput.getValue());
    }, e.prototype.setDate = function(t) {
      this.eDateInput.setValue(jc(t, !1));
    }, e.prototype.setInputPlaceholder = function(t) {
      this.eDateInput.setInputPlaceholder(t);
    }, e.prototype.setDisabled = function(t) {
      this.eDateInput.setDisabled(t);
    }, e.prototype.afterGuiAttached = function(t) {
      (!t || !t.suppressFocus) && this.eDateInput.getInputElement().focus();
    }, e.prototype.shouldUseBrowserDatePicker = function(t) {
      return t.filterParams && t.filterParams.browserDatePicker != null ? t.filterParams.browserDatePicker : O_() || Cx();
    }, $K([
      ve("eDateInput")
    ], e.prototype, "eDateInput", void 0), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var qK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), WC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, kx = (
  /** @class */
  function(n) {
    qK(e, n);
    function e() {
      return n.call(this, "numberFilter") || this;
    }
    return e.prototype.mapValuesFromModel = function(t) {
      var i = t || {}, r = i.filter, o = i.filterTo, s = i.type;
      return [
        r ?? null,
        o ?? null
      ].slice(0, this.getNumberOfInputs(s));
    }, e.prototype.getDefaultDebounceMs = function() {
      return 500;
    }, e.prototype.comparator = function() {
      return function(t, i) {
        return t === i ? 0 : t < i ? 1 : -1;
      };
    }, e.prototype.setParams = function(t) {
      this.numberFilterParams = t;
      var i = this.getAllowedCharPattern();
      if (i) {
        var r = { allowedCharPattern: i };
        this.resetTemplate({
          "eValue-index0-1": r,
          "eValue-index1-1": r,
          "eValue-index0-2": r,
          "eValue-index1-2": r
        });
      }
      n.prototype.setParams.call(this, t);
    }, e.prototype.getDefaultFilterOptions = function() {
      return e.DEFAULT_FILTER_OPTIONS;
    }, e.prototype.createValueTemplate = function(t) {
      var i = t === qr.One ? "1" : "2", r = this.getAllowedCharPattern(), o = r ? "ag-input-text-field" : "ag-input-number-field";
      return (
        /* html */
        `
            <div class="ag-filter-body" ref="eCondition` + i + `Body" role="presentation">
                <` + o + ' class="ag-filter-from ag-filter-filter" ref="eValue-index0-' + i + '"></' + o + `>
                <` + o + ' class="ag-filter-to ag-filter-filter" ref="eValue-index1-' + i + '"></' + o + `>
            </div>`
      );
    }, e.prototype.getValues = function(t) {
      var i = this, r = [];
      return this.forEachInput(function(o, s, a, l) {
        t === a && s < l && r.push(i.stringToFloat(o.getValue()));
      }), r;
    }, e.prototype.areSimpleModelsEqual = function(t, i) {
      return t.filter === i.filter && t.filterTo === i.filterTo && t.type === i.type;
    }, e.prototype.getFilterType = function() {
      return "number";
    }, e.prototype.stringToFloat = function(t) {
      if (typeof t == "number")
        return t;
      var i = vp(t);
      return i != null && i.trim() === "" && (i = null), this.numberFilterParams.numberParser ? this.numberFilterParams.numberParser(i) : i == null || i.trim() === "-" ? null : parseFloat(i);
    }, e.prototype.createCondition = function(t) {
      var i = this.getConditionTypes()[t], r = {
        filterType: this.getFilterType(),
        type: i
      }, o = this.getValues(t);
      return o.length > 0 && (r.filter = o[0]), o.length > 1 && (r.filterTo = o[1]), r;
    }, e.prototype.getInputs = function() {
      return [
        [this.eValueFrom1, this.eValueTo1],
        [this.eValueFrom2, this.eValueTo2]
      ];
    }, e.prototype.getAllowedCharPattern = function() {
      var t = (this.numberFilterParams || {}).allowedCharPattern;
      return t || (!O_() && !RS() ? "\\d\\-\\." : null);
    }, e.DEFAULT_FILTER_OPTIONS = [
      hr.EQUALS,
      hr.NOT_EQUAL,
      hr.LESS_THAN,
      hr.LESS_THAN_OR_EQUAL,
      hr.GREATER_THAN,
      hr.GREATER_THAN_OR_EQUAL,
      hr.IN_RANGE,
      hr.BLANK,
      hr.NOT_BLANK
    ], WC([
      ve("eValue-index0-1")
    ], e.prototype, "eValueFrom1", void 0), WC([
      ve("eValue-index1-1")
    ], e.prototype, "eValueTo1", void 0), WC([
      ve("eValue-index0-2")
    ], e.prototype, "eValueFrom2", void 0), WC([
      ve("eValue-index1-2")
    ], e.prototype, "eValueTo2", void 0), e;
  }(hr)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var YK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), jw = globalThis && globalThis.__assign || function() {
  return jw = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, jw.apply(this, arguments);
}, VC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, MS = (
  /** @class */
  function(n) {
    YK(e, n);
    function e() {
      return n.call(this, "textFilter") || this;
    }
    return e.trimInput = function(t) {
      var i = t && t.trim();
      return i === "" ? t : i;
    }, e.prototype.getDefaultDebounceMs = function() {
      return 500;
    }, e.prototype.setParams = function(t) {
      n.prototype.setParams.call(this, t), this.textFilterParams = t, this.matcher = this.getTextMatcher(), this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? e.DEFAULT_FORMATTER : e.DEFAULT_LOWERCASE_FORMATTER);
    }, e.prototype.getTextMatcher = function() {
      var t = this.textFilterParams.textCustomComparator;
      return t ? (Ad.doOnce(function() {
        return console.warn("AG Grid - textCustomComparator is deprecated, use textMatcher instead.");
      }, "textCustomComparator.deprecated"), function(i) {
        var r = i.filterOption, o = i.value, s = i.filterText;
        return t(r, o, s);
      }) : this.textFilterParams.textMatcher || e.DEFAULT_MATCHER;
    }, e.prototype.createCondition = function(t) {
      var i = this.getConditionTypes()[t], r = {
        filterType: this.getFilterType(),
        type: i
      }, o = this.getValues(t);
      return o.length > 0 && (r.filter = o[0]), o.length > 1 && (r.filterTo = o[1]), r;
    }, e.prototype.getFilterType = function() {
      return "text";
    }, e.prototype.areSimpleModelsEqual = function(t, i) {
      return t.filter === i.filter && t.filterTo === i.filterTo && t.type === i.type;
    }, e.prototype.getInputs = function() {
      return [
        [this.eValueFrom1, this.eValueTo1],
        [this.eValueFrom2, this.eValueTo2]
      ];
    }, e.prototype.getValues = function(t) {
      var i = this, r = [];
      return this.forEachInput(function(o, s, a, l) {
        if (t === a && s < l) {
          var u = vp(o.getValue()), c = (i.textFilterParams.trimInput ? e.trimInput(u) : u) || null;
          r.push(c), o.setValue(c, !0);
        }
      }), r;
    }, e.prototype.getDefaultFilterOptions = function() {
      return e.DEFAULT_FILTER_OPTIONS;
    }, e.prototype.createValueTemplate = function(t) {
      var i = t === qr.One ? "1" : "2";
      return (
        /* html */
        `
            <div class="ag-filter-body" ref="eCondition` + i + `Body" role="presentation">
                <ag-input-text-field class=".ag-filter-from ag-filter-filter" ref="eValue-index0-` + i + `"></ag-input-text-field>
                <ag-input-text-field class="ag-filter-to ag-filter-filter" ref="eValue-index1-` + i + `"></ag-input-text-field>
            </div>`
      );
    }, e.prototype.mapValuesFromModel = function(t) {
      var i = t || {}, r = i.filter, o = i.filterTo, s = i.type;
      return [
        r || null,
        o || null
      ].slice(0, this.getNumberOfInputs(s));
    }, e.prototype.evaluateNullValue = function(t) {
      var i = [
        En.NOT_EQUAL,
        En.NOT_CONTAINS,
        En.BLANK
      ];
      return t ? i.indexOf(t) >= 0 : !1;
    }, e.prototype.evaluateNonNullValue = function(t, i, r, o) {
      var s = this, a = t.map(function(m) {
        return s.formatter(m);
      }) || [], l = this.formatter(i), u = this.textFilterParams, c = u.api, h = u.colDef, d = u.column, f = u.columnApi, p = u.context, g = u.textFormatter;
      if (r.type === En.BLANK)
        return this.isBlank(i);
      if (r.type === En.NOT_BLANK)
        return !this.isBlank(i);
      var _ = {
        api: c,
        colDef: h,
        column: d,
        columnApi: f,
        context: p,
        node: o.node,
        data: o.data,
        filterOption: r.type,
        value: l,
        textFormatter: g
      };
      return a.some(function(m) {
        return s.matcher(jw(jw({}, _), { filterText: m }));
      });
    }, e.DEFAULT_FILTER_OPTIONS = [
      En.CONTAINS,
      En.NOT_CONTAINS,
      En.EQUALS,
      En.NOT_EQUAL,
      En.STARTS_WITH,
      En.ENDS_WITH,
      En.BLANK,
      En.NOT_BLANK
    ], e.DEFAULT_FORMATTER = function(t) {
      return t;
    }, e.DEFAULT_LOWERCASE_FORMATTER = function(t) {
      return t == null ? null : t.toString().toLowerCase();
    }, e.DEFAULT_MATCHER = function(t) {
      var i = t.filterOption, r = t.value, o = t.filterText;
      if (o == null)
        return !1;
      switch (i) {
        case e.CONTAINS:
          return r.indexOf(o) >= 0;
        case e.NOT_CONTAINS:
          return r.indexOf(o) < 0;
        case e.EQUALS:
          return r === o;
        case e.NOT_EQUAL:
          return r != o;
        case e.STARTS_WITH:
          return r.indexOf(o) === 0;
        case e.ENDS_WITH:
          var s = r.lastIndexOf(o);
          return s >= 0 && s === r.length - o.length;
        default:
          return !1;
      }
    }, VC([
      ve("eValue-index0-1")
    ], e.prototype, "eValueFrom1", void 0), VC([
      ve("eValue-index1-1")
    ], e.prototype, "eValueTo1", void 0), VC([
      ve("eValue-index0-2")
    ], e.prototype, "eValueFrom2", void 0), VC([
      ve("eValue-index1-2")
    ], e.prototype, "eValueTo2", void 0), e;
  }(En)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var XK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, DH = (
  /** @class */
  function(n) {
    XK(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      this.resetTemplate();
    }, e.prototype.resetTemplate = function(t) {
      this.setTemplate(
        /* html */
        `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eFloatingFilterInput"></ag-input-text-field>
            </div>
        `,
        t
      );
    }, e.prototype.getDefaultDebounceMs = function() {
      return 500;
    }, e.prototype.onParentModelChanged = function(t, i) {
      this.isEventFromFloatingFilter(i) || (this.setLastTypeFromModel(t), this.eFloatingFilterInput.setValue(this.getTextFromModel(t)), this.setEditable(this.canWeEditAfterModelFromParentFilter(t)));
    }, e.prototype.init = function(t) {
      n.prototype.init.call(this, t), this.params = t, this.applyActive = zv.isUseApplyButton(this.params.filterParams);
      var i = this.params.filterParams.allowedCharPattern;
      if (i != null && this.resetTemplate({ eFloatingFilterInput: { allowedCharPattern: i } }), !this.isReadOnly()) {
        var r = zv.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs()), o = lh(this.syncUpWithParentFilter.bind(this), r), s = this.eFloatingFilterInput.getGui();
        this.addManagedListener(s, "input", o), this.addManagedListener(s, "keypress", o), this.addManagedListener(s, "keydown", o);
      }
      var a = t.column.getDefinition();
      (this.isReadOnly() || a.filterParams && a.filterParams.filterOptions && a.filterParams.filterOptions.length === 1 && a.filterParams.filterOptions[0] === "inRange") && this.eFloatingFilterInput.setDisabled(!0);
      var l = this.columnModel.getDisplayNameForColumn(t.column, "header", !0), u = this.gridOptionsWrapper.getLocaleTextFunc();
      this.eFloatingFilterInput.setInputAriaLabel(l + " " + u("ariaFilterInput", "Filter Input"));
    }, e.prototype.syncUpWithParentFilter = function(t) {
      var i = this, r = t.key === _e.ENTER;
      if (!(this.applyActive && !r)) {
        var o = this.eFloatingFilterInput.getValue();
        this.params.filterParams.trimInput && (o = MS.trimInput(o), this.eFloatingFilterInput.setValue(o, !0)), this.params.parentFilterInstance(function(s) {
          s && s.onFloatingFilterChanged(i.getLastType() || null, o || null);
        });
      }
    }, e.prototype.conditionToString = function(t, i) {
      var r = (i || {}).numberOfInputs, o = t.type == En.IN_RANGE || r === 2;
      return o ? t.filter + "-" + t.filterTo : t.filter != null ? "" + t.filter : "" + t.type;
    }, e.prototype.setEditable = function(t) {
      this.eFloatingFilterInput.setDisabled(!t);
    }, wL([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), wL([
      ve("eFloatingFilterInput")
    ], e.prototype, "eFloatingFilterInput", void 0), wL([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(LH)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var ZK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), QK = (
  /** @class */
  function(n) {
    ZK(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getDefaultFilterOptions = function() {
      return kx.DEFAULT_FILTER_OPTIONS;
    }, e;
  }(DH)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var JK = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), RH = (
  /** @class */
  function(n) {
    JK(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getDefaultFilterOptions = function() {
      return MS.DEFAULT_FILTER_OPTIONS;
    }, e;
  }(DH)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var da = (
  /** @class */
  function() {
    function n(e, t) {
      var i = this;
      t === void 0 && (t = !1), this.destroyFuncs = [], this.touching = !1, this.eventService = new ic(), this.eElement = e, this.preventMouseClick = t;
      var r = this.onTouchStart.bind(this), o = this.onTouchMove.bind(this), s = this.onTouchEnd.bind(this);
      this.eElement.addEventListener("touchstart", r, { passive: !0 }), this.eElement.addEventListener("touchmove", o, { passive: !0 }), this.eElement.addEventListener("touchend", s, { passive: !1 }), this.destroyFuncs.push(function() {
        i.eElement.removeEventListener("touchstart", r, { passive: !0 }), i.eElement.removeEventListener("touchmove", o, { passive: !0 }), i.eElement.removeEventListener("touchend", s, { passive: !1 });
      });
    }
    return n.prototype.getActiveTouch = function(e) {
      for (var t = 0; t < e.length; t++) {
        var i = e[t].identifier === this.touchStart.identifier;
        if (i)
          return e[t];
      }
      return null;
    }, n.prototype.addEventListener = function(e, t) {
      this.eventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.eventService.removeEventListener(e, t);
    }, n.prototype.onTouchStart = function(e) {
      var t = this;
      if (!this.touching) {
        this.touchStart = e.touches[0], this.touching = !0, this.moved = !1;
        var i = this.touchStart;
        window.setTimeout(function() {
          var r = t.touchStart === i;
          if (t.touching && r && !t.moved) {
            t.moved = !0;
            var o = {
              type: n.EVENT_LONG_TAP,
              touchStart: t.touchStart,
              touchEvent: e
            };
            t.eventService.dispatchEvent(o);
          }
        }, 500);
      }
    }, n.prototype.onTouchMove = function(e) {
      if (this.touching) {
        var t = this.getActiveTouch(e.touches);
        if (t) {
          var i = !Ix(t, this.touchStart, 4);
          i && (this.moved = !0);
        }
      }
    }, n.prototype.onTouchEnd = function(e) {
      if (this.touching) {
        if (!this.moved) {
          var t = {
            type: n.EVENT_TAP,
            touchStart: this.touchStart
          };
          this.eventService.dispatchEvent(t), this.checkForDoubleTap();
        }
        this.preventMouseClick && e.preventDefault(), this.touching = !1;
      }
    }, n.prototype.checkForDoubleTap = function() {
      var e = (/* @__PURE__ */ new Date()).getTime();
      if (this.lastTapTime && this.lastTapTime > 0) {
        var t = e - this.lastTapTime;
        if (t > n.DOUBLE_TAP_MILLIS) {
          var i = {
            type: n.EVENT_DOUBLE_TAP,
            touchStart: this.touchStart
          };
          this.eventService.dispatchEvent(i), this.lastTapTime = null;
        } else
          this.lastTapTime = e;
      } else
        this.lastTapTime = e;
    }, n.prototype.destroy = function() {
      this.destroyFuncs.forEach(function(e) {
        return e();
      });
    }, n.EVENT_TAP = "tap", n.EVENT_DOUBLE_TAP = "doubleTap", n.EVENT_LONG_TAP = "longTap", n.DOUBLE_TAP_MILLIS = 500, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var eq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Ll = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, tq = (
  /** @class */
  function(n) {
    eq(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.lastMovingChanged = 0, t;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.refresh = function(t) {
      return this.params = t, this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || this.workOutSort() != this.currentSort ? !1 : (this.setDisplayName(t), !0);
    }, e.prototype.workOutTemplate = function() {
      var t = DB(this.params.template, e.TEMPLATE);
      return t = t && t.trim ? t.trim() : t, t;
    }, e.prototype.init = function(t) {
      this.params = t, this.currentTemplate = this.workOutTemplate(), this.setTemplate(this.currentTemplate), this.setupTap(), this.setupIcons(t.column), this.setMenu(), this.setupSort(), this.setupFilterIcon(), this.setDisplayName(t);
    }, e.prototype.setDisplayName = function(t) {
      if (this.currentDisplayName != t.displayName) {
        this.currentDisplayName = t.displayName;
        var i = ql(this.currentDisplayName);
        this.eText && (this.eText.innerHTML = i);
      }
    }, e.prototype.setupIcons = function(t) {
      this.addInIcon("sortAscending", this.eSortAsc, t), this.addInIcon("sortDescending", this.eSortDesc, t), this.addInIcon("sortUnSort", this.eSortNone, t), this.addInIcon("menu", this.eMenu, t), this.addInIcon("filter", this.eFilter, t);
    }, e.prototype.addInIcon = function(t, i, r) {
      if (i != null) {
        var o = Yn(t, this.gridOptionsWrapper, r);
        o && i.appendChild(o);
      }
    }, e.prototype.setupTap = function() {
      var t = this, i = this.gridOptionsWrapper;
      if (!i.isSuppressTouch()) {
        var r = new da(this.getGui(), !0), o = i.isSuppressMenuHide(), s = o && ge(this.eMenu), a = s ? new da(this.eMenu, !0) : r;
        if (this.params.enableMenu) {
          var l = s ? "EVENT_TAP" : "EVENT_LONG_TAP", u = function(h) {
            i.getApi().showColumnMenuAfterMouseClick(t.params.column, h.touchStart);
          };
          this.addManagedListener(a, da[l], u);
        }
        if (this.params.enableSorting) {
          var c = function(h) {
            var d = h.touchStart.target;
            o && t.eMenu.contains(d) || t.sortController.progressSort(t.params.column, !1, "uiColumnSorted");
          };
          this.addManagedListener(r, da.EVENT_TAP, c);
        }
        this.addDestroyFunc(function() {
          return r.destroy();
        }), s && this.addDestroyFunc(function() {
          return a.destroy();
        });
      }
    }, e.prototype.workOutShowMenu = function() {
      var t = !this.gridOptionsWrapper.isSuppressMenuHide(), i = Cg() && t, r = this.params.enableMenu && !i;
      return r;
    }, e.prototype.setMenu = function() {
      var t = this;
      if (this.eMenu) {
        if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) {
          za(this.eMenu);
          return;
        }
        var i = this.gridOptionsWrapper.isSuppressMenuHide();
        this.addManagedListener(this.eMenu, "click", function() {
          return t.showMenu(t.eMenu);
        }), this.eMenu.classList.toggle("ag-header-menu-always-show", i);
      }
    }, e.prototype.showMenu = function(t) {
      t || (t = this.eMenu), this.menuFactory.showMenuAfterButtonClick(this.params.column, t, "columnMenu");
    }, e.prototype.removeSortIcons = function() {
      za(this.eSortAsc), za(this.eSortDesc), za(this.eSortNone), za(this.eSortOrder);
    }, e.prototype.workOutSort = function() {
      return this.params.enableSorting;
    }, e.prototype.setupSort = function() {
      var t = this;
      if (this.currentSort = this.params.enableSorting, !this.currentSort) {
        this.removeSortIcons();
        return;
      }
      var i = this.gridOptionsWrapper.isMultiSortKeyCtrl();
      this.addManagedListener(this.params.column, Gt.EVENT_MOVING_CHANGED, function() {
        t.lastMovingChanged = (/* @__PURE__ */ new Date()).getTime();
      }), this.eLabel && this.addManagedListener(this.eLabel, "click", function(r) {
        var o = t.params.column.isMoving(), s = (/* @__PURE__ */ new Date()).getTime(), a = s - t.lastMovingChanged < 50, l = o || a;
        if (!l) {
          var u = i ? r.ctrlKey || r.metaKey : r.shiftKey;
          t.params.progressSort(u);
        }
      }), this.addManagedListener(this.params.column, Gt.EVENT_SORT_CHANGED, this.onSortChanged.bind(this)), this.onSortChanged(), this.addManagedListener(this.eventService, F.EVENT_SORT_CHANGED, this.setMultiSortOrder.bind(this)), this.setMultiSortOrder();
    }, e.prototype.onSortChanged = function() {
      if (this.addOrRemoveCssClass("ag-header-cell-sorted-asc", this.params.column.isSortAscending()), this.addOrRemoveCssClass("ag-header-cell-sorted-desc", this.params.column.isSortDescending()), this.addOrRemoveCssClass("ag-header-cell-sorted-none", this.params.column.isSortNone()), this.eSortAsc && this.eSortAsc.classList.toggle("ag-hidden", !this.params.column.isSortAscending()), this.eSortDesc && this.eSortDesc.classList.toggle("ag-hidden", !this.params.column.isSortDescending()), this.eSortNone) {
        var t = !this.params.column.getColDef().unSortIcon && !this.gridOptionsWrapper.isUnSortIcon();
        this.eSortNone.classList.toggle("ag-hidden", t || !this.params.column.isSortNone());
      }
    }, e.prototype.setMultiSortOrder = function() {
      if (this.eSortOrder) {
        var t = this.params.column, i = this.sortController.getColumnsWithSortingOrdered(), r = i.indexOf(t), o = i.length > 1, s = t.isSorting() && o;
        Bi(this.eSortOrder, s), r >= 0 ? this.eSortOrder.innerHTML = (r + 1).toString() : Ls(this.eSortOrder);
      }
    }, e.prototype.setupFilterIcon = function() {
      this.eFilter && (this.addManagedListener(this.params.column, Gt.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.onFilterChanged());
    }, e.prototype.onFilterChanged = function() {
      var t = this.params.column.isFilterActive();
      this.eFilter.classList.toggle("ag-hidden", !t);
    }, e.TEMPLATE = `<div class="ag-cell-label-container" role="presentation">
            <span ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
            <div ref="eLabel" class="ag-header-cell-label" role="presentation">
                <span ref="eText" class="ag-header-cell-text"></span>
                <span ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
                <span ref="eSortOrder" class="ag-header-icon ag-header-label-icon ag-sort-order" aria-hidden="true"></span>
                <span ref="eSortAsc" class="ag-header-icon ag-header-label-icon ag-sort-ascending-icon" aria-hidden="true"></span>
                <span ref="eSortDesc" class="ag-header-icon ag-header-label-icon ag-sort-descending-icon" aria-hidden="true"></span>
                <span ref="eSortNone" class="ag-header-icon ag-header-label-icon ag-sort-none-icon" aria-hidden="true"></span>
            </div>
        </div>`, Ll([
      T("sortController")
    ], e.prototype, "sortController", void 0), Ll([
      T("menuFactory")
    ], e.prototype, "menuFactory", void 0), Ll([
      ve("eFilter")
    ], e.prototype, "eFilter", void 0), Ll([
      ve("eSortAsc")
    ], e.prototype, "eSortAsc", void 0), Ll([
      ve("eSortDesc")
    ], e.prototype, "eSortDesc", void 0), Ll([
      ve("eSortNone")
    ], e.prototype, "eSortNone", void 0), Ll([
      ve("eSortOrder")
    ], e.prototype, "eSortOrder", void 0), Ll([
      ve("eMenu")
    ], e.prototype, "eMenu", void 0), Ll([
      ve("eLabel")
    ], e.prototype, "eLabel", void 0), Ll([
      ve("eText")
    ], e.prototype, "eText", void 0), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var iq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), bL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, nq = (
  /** @class */
  function(n) {
    iq(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.init = function(t) {
      this.params = t, this.checkWarnings(), this.setupLabel(), this.addGroupExpandIcon(), this.setupExpandIcons();
    }, e.prototype.checkWarnings = function() {
      var t = this.params;
      if (t.template) {
        var i = "AG Grid: A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)";
        mi(function() {
          return console.warn(i);
        }, "HeaderGroupComp.templateNotSupported");
      }
    }, e.prototype.setupExpandIcons = function() {
      var t = this;
      this.addInIcon("columnGroupOpened", "agOpened"), this.addInIcon("columnGroupClosed", "agClosed");
      var i = function(s) {
        if (!Hl(s)) {
          var a = !t.params.columnGroup.isExpanded();
          t.columnModel.setColumnGroupOpened(t.params.columnGroup.getProvidedColumnGroup(), a, "uiColumnExpanded");
        }
      };
      this.addTouchAndClickListeners(this.eCloseIcon, i), this.addTouchAndClickListeners(this.eOpenIcon, i);
      var r = function(s) {
        zp(s);
      };
      this.addManagedListener(this.eCloseIcon, "dblclick", r), this.addManagedListener(this.eOpenIcon, "dblclick", r), this.addManagedListener(this.getGui(), "dblclick", i), this.updateIconVisibility();
      var o = this.params.columnGroup.getProvidedColumnGroup();
      this.addManagedListener(o, gn.EVENT_EXPANDED_CHANGED, this.updateIconVisibility.bind(this)), this.addManagedListener(o, gn.EVENT_EXPANDABLE_CHANGED, this.updateIconVisibility.bind(this));
    }, e.prototype.addTouchAndClickListeners = function(t, i) {
      var r = new da(t, !0);
      this.addManagedListener(r, da.EVENT_TAP, i), this.addDestroyFunc(function() {
        return r.destroy();
      }), this.addManagedListener(t, "click", i);
    }, e.prototype.updateIconVisibility = function() {
      var t = this.params.columnGroup;
      if (t.isExpandable()) {
        var i = this.params.columnGroup.isExpanded();
        Bi(this.eOpenIcon, i), Bi(this.eCloseIcon, !i);
      } else
        Bi(this.eOpenIcon, !1), Bi(this.eCloseIcon, !1);
    }, e.prototype.addInIcon = function(t, i) {
      var r = Yn(t, this.gridOptionsWrapper, null);
      r && this.getRefElement(i).appendChild(r);
    }, e.prototype.addGroupExpandIcon = function() {
      if (!this.params.columnGroup.isExpandable()) {
        Bi(this.eOpenIcon, !1), Bi(this.eCloseIcon, !1);
        return;
      }
    }, e.prototype.setupLabel = function() {
      var t = this.params.displayName;
      if (ge(t)) {
        var i = ql(t);
        this.getRefElement("agLabel").innerHTML = i;
      }
    }, e.TEMPLATE = `<div class="ag-header-group-cell-label" ref="agContainer" role="presentation">
            <span ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`, bL([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), bL([
      ve("agOpened")
    ], e.prototype, "eOpenIcon", void 0), bL([
      ve("agClosed")
    ], e.prototype, "eCloseIcon", void 0), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var rq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Sg = (
  /** @class */
  function(n) {
    rq(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.isPopup = function() {
      return !0;
    }, e.prototype.setParentComponent = function(t) {
      t.addCssClass("ag-has-popup"), n.prototype.setParentComponent.call(this, t);
    }, e.prototype.destroy = function() {
      var t = this.parentComponent, i = t && t.isAlive();
      i && t.getGui().classList.remove("ag-has-popup"), n.prototype.destroy.call(this);
    }, e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var oq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), sq = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, TH = (
  /** @class */
  function(n) {
    oq(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.init = function(t) {
      this.params = t, this.focusAfterAttached = t.cellStartedEdit, this.eTextArea.setMaxLength(t.maxLength || 200).setCols(t.cols || 60).setRows(t.rows || 10), ge(t.value) && this.eTextArea.setValue(t.value.toString(), !0), this.addGuiEventListener("keydown", this.onKeyDown.bind(this));
    }, e.prototype.onKeyDown = function(t) {
      var i = t.key;
      (i === _e.LEFT || i === _e.UP || i === _e.RIGHT || i === _e.DOWN || t.shiftKey && i === _e.ENTER) && t.stopPropagation();
    }, e.prototype.afterGuiAttached = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc();
      this.eTextArea.setInputAriaLabel(t("ariaInputEditor", "Input Editor")), this.focusAfterAttached && this.eTextArea.getFocusableElement().focus();
    }, e.prototype.getValue = function() {
      return this.params.parseValue(this.eTextArea.getValue());
    }, e.TEMPLATE = `<div class="ag-large-text" tabindex="0">
            <ag-input-text-area ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`, sq([
      ve("eTextArea")
    ], e.prototype, "eTextArea", void 0), e;
  }(Sg)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var aq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), UM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Wx = (
  /** @class */
  function(n) {
    aq(e, n);
    function e() {
      var t = n.call(this, '<div class="ag-cell-edit-wrapper"><ag-select class="ag-cell-editor" ref="eSelect"></ag-select></div>') || this;
      return t.startedByEnter = !1, t;
    }
    return e.prototype.init = function(t) {
      var i = this;
      if (this.focusAfterAttached = t.cellStartedEdit, Je(t.values)) {
        console.warn("AG Grid: no values found for select cellEditor");
        return;
      }
      this.startedByEnter = t.eventKey != null ? t.eventKey === _e.ENTER : !1;
      var r = !1;
      t.values.forEach(function(o) {
        var s = { value: o }, a = i.valueFormatterService.formatValue(t.column, null, null, o), l = a != null;
        s.text = l ? a : o, i.eSelect.addOption(s), r = r || t.value === o;
      }), r ? this.eSelect.setValue(t.value, !0) : t.values.length && this.eSelect.setValue(t.values[0], !0), this.gridOptionsWrapper.isFullRowEdit() || this.eSelect.onValueChange(function() {
        return t.stopEditing();
      });
    }, e.prototype.afterGuiAttached = function() {
      this.focusAfterAttached && this.eSelect.getFocusableElement().focus(), this.startedByEnter && this.eSelect.showPicker();
    }, e.prototype.focusIn = function() {
      this.eSelect.getFocusableElement().focus();
    }, e.prototype.getValue = function() {
      return this.eSelect.getValue();
    }, e.prototype.isPopup = function() {
      return !1;
    }, UM([
      T("valueFormatterService")
    ], e.prototype, "valueFormatterService", void 0), UM([
      ve("eSelect")
    ], e.prototype, "eSelect", void 0), e;
  }(Sg)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var lq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), OH = (
  /** @class */
  function(n) {
    lq(e, n);
    function e() {
      var t = n.call(this) || this;
      return mi(function() {
        return console.warn('AG Grid: The PopupSelectCellEditor (agPopupSelectCellEditor) is deprecated. Instead use {cellEditor: "agSelectCellEditor", cellEditorPopup: true} ');
      }, "PopupSelectCellEditor.deprecated"), t;
    }
    return e.prototype.isPopup = function() {
      return !0;
    }, e;
  }(Wx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var uq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), cq = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, $w = (
  /** @class */
  function(n) {
    uq(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.init = function(t) {
      this.params = t;
      var i = this.eInput, r;
      t.cellStartedEdit ? (this.focusAfterAttached = !0, t.eventKey === _e.BACKSPACE || t.eventKey === _e.DELETE ? r = "" : t.charPress ? r = t.charPress : (r = this.getStartValue(t), t.eventKey !== _e.F2 && (this.highlightAllOnFocus = !0))) : (this.focusAfterAttached = !1, r = this.getStartValue(t)), r != null && i.setValue(r, !0), this.addManagedListener(i.getGui(), "keydown", function(o) {
        var s = o.key;
        (s === _e.PAGE_UP || s === _e.PAGE_DOWN) && o.preventDefault();
      });
    }, e.prototype.afterGuiAttached = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = this.eInput;
      if (i.setInputAriaLabel(t("ariaInputEditor", "Input Editor")), !!this.focusAfterAttached) {
        TS() || i.getFocusableElement().focus();
        var r = i.getInputElement();
        if (this.highlightAllOnFocus)
          r.select();
        else {
          var o = i.getValue(), s = ge(o) && o.length || 0;
          s && r.setSelectionRange(s, s);
        }
      }
    }, e.prototype.focusIn = function() {
      var t = this.eInput, i = t.getFocusableElement(), r = t.getInputElement();
      i.focus(), r.select();
    }, e.prototype.getValue = function() {
      var t = this.eInput;
      return this.params.parseValue(t.getValue());
    }, e.prototype.getStartValue = function(t) {
      var i = t.useFormatter || t.column.getColDef().refData;
      return i ? t.formatValue(t.value) : t.value;
    }, e.prototype.isPopup = function() {
      return !1;
    }, e.TEMPLATE = '<div class="ag-cell-edit-wrapper"><ag-input-text-field class="ag-cell-editor" ref="eInput"></ag-input-text-field></div>', cq([
      ve("eInput")
    ], e.prototype, "eInput", void 0), e;
  }(Sg)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var hq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), xH = (
  /** @class */
  function(n) {
    hq(e, n);
    function e() {
      var t = n.call(this) || this;
      return mi(function() {
        return console.warn('AG Grid: The PopupTextCellEditor (agPopupTextCellEditor) is deprecated. Instead use {cellEditor: "agTextCellEditor", cellEditorPopup: true} ');
      }, "PopupTextCellEditor.deprecated"), t;
    }
    return e.prototype.isPopup = function() {
      return !0;
    }, e;
  }($w)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var dq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), fq = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, pq = "", gq = "", NH = (
  /** @class */
  function(n) {
    dq(e, n);
    function e() {
      var t = n.call(this, e.TEMPLATE) || this;
      return t.refreshCount = 0, t;
    }
    return e.prototype.init = function(t) {
      this.eValue = this.queryForHtmlElement(".ag-value-change-value"), this.eDelta = this.queryForHtmlElement(".ag-value-change-delta"), this.refresh(t);
    }, e.prototype.showDelta = function(t, i) {
      var r = Math.abs(i), o = t.formatValue(r), s = ge(o) ? o : r, a = i >= 0;
      a ? this.eDelta.innerHTML = pq + s : this.eDelta.innerHTML = gq + s, this.eDelta.classList.toggle("ag-value-change-delta-up", a), this.eDelta.classList.toggle("ag-value-change-delta-down", !a);
    }, e.prototype.setTimerToRemoveDelta = function() {
      var t = this;
      this.refreshCount++;
      var i = this.refreshCount;
      window.setTimeout(function() {
        i === t.refreshCount && t.hideDeltaValue();
      }, 2e3);
    }, e.prototype.hideDeltaValue = function() {
      this.eValue.classList.remove("ag-value-change-value-highlight"), Ls(this.eDelta);
    }, e.prototype.refresh = function(t) {
      var i = t.value;
      if (i === this.lastValue || (ge(t.valueFormatted) ? this.eValue.innerHTML = t.valueFormatted : ge(t.value) ? this.eValue.innerHTML = i : Ls(this.eValue), this.filterManager.isSuppressFlashingCellsBecauseFiltering()))
        return !1;
      if (typeof i == "number" && typeof this.lastValue == "number") {
        var r = i - this.lastValue;
        this.showDelta(t, r);
      }
      return this.lastValue && this.eValue.classList.add("ag-value-change-value-highlight"), this.setTimerToRemoveDelta(), this.lastValue = i, !0;
    }, e.TEMPLATE = '<span><span class="ag-value-change-delta"></span><span class="ag-value-change-value"></span></span>', fq([
      T("filterManager")
    ], e.prototype, "filterManager", void 0), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var mq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), vq = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, IH = (
  /** @class */
  function(n) {
    mq(e, n);
    function e() {
      var t = n.call(this, e.TEMPLATE) || this;
      return t.refreshCount = 0, t.eCurrent = t.queryForHtmlElement(".ag-value-slide-current"), t;
    }
    return e.prototype.init = function(t) {
      this.refresh(t);
    }, e.prototype.addSlideAnimation = function() {
      var t = this;
      this.refreshCount++;
      var i = this.refreshCount;
      this.ePrevious && this.getGui().removeChild(this.ePrevious), this.ePrevious = Tr('<span class="ag-value-slide-previous ag-value-slide-out"></span>'), this.ePrevious.innerHTML = this.eCurrent.innerHTML, this.getGui().insertBefore(this.ePrevious, this.eCurrent), window.setTimeout(function() {
        i === t.refreshCount && t.ePrevious.classList.add("ag-value-slide-out-end");
      }, 50), window.setTimeout(function() {
        i === t.refreshCount && (t.getGui().removeChild(t.ePrevious), t.ePrevious = null);
      }, 3e3);
    }, e.prototype.refresh = function(t) {
      var i = t.value;
      return Je(i) && (i = ""), i === this.lastValue || this.filterManager.isSuppressFlashingCellsBecauseFiltering() ? !1 : (this.addSlideAnimation(), this.lastValue = i, ge(t.valueFormatted) ? this.eCurrent.innerHTML = t.valueFormatted : ge(t.value) ? this.eCurrent.innerHTML = i : Ls(this.eCurrent), !0);
    }, e.TEMPLATE = `<span>
            <span class="ag-value-slide-current"></span>
        </span>`, vq([
      T("filterManager")
    ], e.prototype, "filterManager", void 0), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Md;
(function(n) {
  n[n.Above = 0] = "Above", n[n.Below = 1] = "Below";
})(Md || (Md = {}));
var Wt = (
  /** @class */
  function() {
    function n(e) {
      this.rowIndex = null, this.key = null, this.childrenMapped = {}, this.displayed = !1, this.rowTop = null, this.oldRowTop = null, this.selectable = !0, this.__objectId = n.OBJECT_ID_SEQUENCE++, this.__autoHeights = {}, this.alreadyRendered = !1, this.highlighted = null, this.selected = !1, this.beans = e;
    }
    return n.prototype.setData = function(e) {
      this.setDataCommon(e, !1);
    }, n.prototype.updateData = function(e) {
      this.setDataCommon(e, !0);
    }, n.prototype.setDataCommon = function(e, t) {
      var i = this.data;
      this.data = e, this.beans.valueCache.onDataChanged(), this.updateDataOnDetailNode(), this.checkRowSelectable();
      var r = this.createDataChangedEvent(e, i, t);
      this.dispatchLocalEvent(r);
    }, n.prototype.updateDataOnDetailNode = function() {
      this.detailNode && (this.detailNode.data = this.data);
    }, n.prototype.createDataChangedEvent = function(e, t, i) {
      return {
        type: n.EVENT_DATA_CHANGED,
        node: this,
        oldData: t,
        newData: e,
        update: i
      };
    }, n.prototype.createLocalRowEvent = function(e) {
      return {
        type: e,
        node: this
      };
    }, n.prototype.getRowIndexString = function() {
      return this.rowPinned === Z.PINNED_TOP ? "t-" + this.rowIndex : this.rowPinned === Z.PINNED_BOTTOM ? "b-" + this.rowIndex : this.rowIndex.toString();
    }, n.prototype.createDaemonNode = function() {
      var e = new n(this.beans);
      return e.id = this.id, e.data = this.data, e.daemon = !0, e.selected = this.selected, e.level = this.level, e;
    }, n.prototype.setDataAndId = function(e, t) {
      var i = ge(this.id) ? this.createDaemonNode() : null, r = this.data;
      this.data = e, this.updateDataOnDetailNode(), this.setId(t), this.beans.selectionService.syncInRowNode(this, i), this.checkRowSelectable();
      var o = this.createDataChangedEvent(e, r, !1);
      this.dispatchLocalEvent(o);
    }, n.prototype.checkRowSelectable = function() {
      var e = this.beans.gridOptionsWrapper.getIsRowSelectableFunc();
      this.setRowSelectable(e ? e(this) : !0);
    }, n.prototype.setRowSelectable = function(e) {
      this.selectable !== e && (this.selectable = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_SELECTABLE_CHANGED)));
    }, n.prototype.setId = function(e) {
      var t = this.beans.gridOptionsWrapper.getRowIdFunc();
      if (t)
        if (this.data) {
          var i = this.getGroupKeys(!0);
          this.id = t({
            api: this.beans.gridApi,
            columnApi: this.beans.columnApi,
            data: this.data,
            parentKeys: i.length > 0 ? i : void 0,
            level: this.level
          }), this.id !== null && typeof this.id == "string" && this.id.startsWith(n.ID_PREFIX_ROW_GROUP) && console.error("AG Grid: Row IDs cannot start with " + n.ID_PREFIX_ROW_GROUP + ", this is a reserved prefix for AG Grid's row grouping feature."), this.id !== null && typeof this.id != "string" && (this.id = "" + this.id);
        } else
          this.id = void 0;
      else
        this.id = e;
    }, n.prototype.getGroupKeys = function(e) {
      e === void 0 && (e = !1);
      var t = [], i = this;
      for (e && (i = i.parent); i && i.level >= 0; )
        t.push(i.key), i = i.parent;
      return t.reverse(), t;
    }, n.prototype.isPixelInRange = function(e) {
      return !ge(this.rowTop) || !ge(this.rowHeight) ? !1 : e >= this.rowTop && e < this.rowTop + this.rowHeight;
    }, n.prototype.setFirstChild = function(e) {
      this.firstChild !== e && (this.firstChild = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_FIRST_CHILD_CHANGED)));
    }, n.prototype.setLastChild = function(e) {
      this.lastChild !== e && (this.lastChild = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_LAST_CHILD_CHANGED)));
    }, n.prototype.setChildIndex = function(e) {
      this.childIndex !== e && (this.childIndex = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_CHILD_INDEX_CHANGED)));
    }, n.prototype.setRowTop = function(e) {
      this.oldRowTop = this.rowTop, this.rowTop !== e && (this.rowTop = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_TOP_CHANGED)), this.setDisplayed(e !== null));
    }, n.prototype.clearRowTopAndRowIndex = function() {
      this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null);
    }, n.prototype.setDisplayed = function(e) {
      this.displayed !== e && (this.displayed = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_DISPLAYED_CHANGED)));
    }, n.prototype.setDragging = function(e) {
      this.dragging !== e && (this.dragging = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_DRAGGING_CHANGED)));
    }, n.prototype.setHighlighted = function(e) {
      e !== this.highlighted && (this.highlighted = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_HIGHLIGHT_CHANGED)));
    }, n.prototype.setAllChildrenCount = function(e) {
      this.allChildrenCount !== e && (this.allChildrenCount = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_ALL_CHILDREN_COUNT_CHANGED)));
    }, n.prototype.setMaster = function(e) {
      this.master !== e && (this.master && !e && (this.expanded = !1), this.master = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_MASTER_CHANGED)));
    }, n.prototype.setGroup = function(e) {
      this.group !== e && (this.group && !e && (this.expanded = !1), this.group = e, this.updateHasChildren(), this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_GROUP_CHANGED)));
    }, n.prototype.setRowHeight = function(e, t) {
      t === void 0 && (t = !1), this.rowHeight = e, this.rowHeightEstimated = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_HEIGHT_CHANGED));
    }, n.prototype.setRowAutoHeight = function(e, t) {
      this.__autoHeights || (this.__autoHeights = {});
      var i = this.__autoHeights;
      i[t.getId()] = e, e != null && (this.checkAutoHeightsDebounced == null && (this.checkAutoHeightsDebounced = lh(this.checkAutoHeights.bind(this), 1)), this.checkAutoHeightsDebounced());
    }, n.prototype.checkAutoHeights = function() {
      var e = !1, t = !0, i = 0, r = this.__autoHeights;
      if (r != null) {
        var o = this.beans.columnModel.getAllDisplayedAutoHeightCols();
        if (o.forEach(function(a) {
          var l = r[a.getId()];
          if (l == null) {
            e = !0;
            return;
          }
          t = !1, l > i && (i = l);
        }), !e && ((t || i < 10) && (i = this.beans.gridOptionsWrapper.getRowHeightForNode(this).height), i != this.rowHeight)) {
          this.setRowHeight(i);
          var s = this.beans.rowModel;
          s.onRowHeightChanged && s.onRowHeightChanged();
        }
      }
    }, n.prototype.setRowIndex = function(e) {
      this.rowIndex !== e && (this.rowIndex = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_ROW_INDEX_CHANGED)));
    }, n.prototype.setUiLevel = function(e) {
      this.uiLevel !== e && (this.uiLevel = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_UI_LEVEL_CHANGED)));
    }, n.prototype.setExpanded = function(e) {
      if (this.expanded !== e) {
        this.expanded = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_EXPANDED_CHANGED));
        var t = Object.assign({}, this.createGlobalRowEvent(F.EVENT_ROW_GROUP_OPENED), {
          expanded: e
        });
        this.beans.rowNodeEventThrottle.dispatchExpanded(t), this.beans.gridOptionsWrapper.isGroupIncludeFooter() && this.beans.rowRenderer.refreshCells({ rowNodes: [this] });
      }
    }, n.prototype.createGlobalRowEvent = function(e) {
      return {
        type: e,
        node: this,
        data: this.data,
        rowIndex: this.rowIndex,
        rowPinned: this.rowPinned,
        context: this.beans.gridOptionsWrapper.getContext(),
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi()
      };
    }, n.prototype.dispatchLocalEvent = function(e) {
      this.eventService && this.eventService.dispatchEvent(e);
    }, n.prototype.setDataValue = function(e, t, i) {
      var r = this.beans.columnModel.getPrimaryColumn(e), o = this.beans.valueService.getValue(r, this);
      this.beans.valueService.setValue(this, r, t, i), this.dispatchCellChangedEvent(r, t, o);
    }, n.prototype.setGroupValue = function(e, t) {
      var i = this.beans.columnModel.getGridColumn(e);
      Je(this.groupData) && (this.groupData = {});
      var r = i.getColId(), o = this.groupData[r];
      o !== t && (this.groupData[r] = t, this.dispatchCellChangedEvent(i, t, o));
    }, n.prototype.setAggData = function(e) {
      var t = this, i = vB([this.aggData, e]), r = this.aggData;
      this.aggData = e, this.eventService && i.forEach(function(o) {
        var s = t.beans.columnModel.getGridColumn(o), a = t.aggData ? t.aggData[o] : void 0, l = r ? r[o] : void 0;
        t.dispatchCellChangedEvent(s, a, l);
      });
    }, n.prototype.updateHasChildren = function() {
      var e = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
      e !== this.__hasChildren && (this.__hasChildren = !!e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(n.EVENT_HAS_CHILDREN_CHANGED)));
    }, n.prototype.hasChildren = function() {
      return this.__hasChildren == null && this.updateHasChildren(), this.__hasChildren;
    }, n.prototype.isEmptyRowGroupNode = function() {
      return this.group && ms(this.childrenAfterGroup);
    }, n.prototype.dispatchCellChangedEvent = function(e, t, i) {
      var r = {
        type: n.EVENT_CELL_CHANGED,
        node: this,
        column: e,
        newValue: t,
        oldValue: i
      };
      this.dispatchLocalEvent(r);
    }, n.prototype.resetQuickFilterAggregateText = function() {
      this.quickFilterAggregateText = null;
    }, n.prototype.isExpandable = function() {
      return !!(this.hasChildren() && !this.footer || this.master);
    }, n.prototype.isSelected = function() {
      return this.footer ? this.sibling.isSelected() : this.selected;
    }, n.prototype.depthFirstSearch = function(e) {
      this.childrenAfterGroup && this.childrenAfterGroup.forEach(function(t) {
        return t.depthFirstSearch(e);
      }), e(this);
    }, n.prototype.calculateSelectedFromChildren = function() {
      var e = !1, t = !1, i = !1, r;
      if (this.childrenAfterGroup)
        for (var o = 0; o < this.childrenAfterGroup.length; o++) {
          var s = this.childrenAfterGroup[o];
          if (s.selectable) {
            var a = s.isSelected();
            switch (a) {
              case !0:
                e = !0;
                break;
              case !1:
                t = !0;
                break;
              default:
                i = !0;
                break;
            }
          }
        }
      i ? r = void 0 : e && !t ? r = !0 : !e && t ? r = !1 : r = void 0, this.selectThisNode(r);
    }, n.prototype.setSelectedInitialValue = function(e) {
      this.selected = e;
    }, n.prototype.setSelected = function(e, t, i) {
      t === void 0 && (t = !1), i === void 0 && (i = !1), this.setSelectedParams({
        newValue: e,
        clearSelection: t,
        suppressFinishActions: i,
        rangeSelect: !1
      });
    }, n.prototype.isRowPinned = function() {
      return this.rowPinned === Z.PINNED_TOP || this.rowPinned === Z.PINNED_BOTTOM;
    }, n.prototype.setSelectedParams = function(e) {
      var t = this.beans.gridOptionsWrapper.isGroupSelectsChildren(), i = e.newValue === !0, r = e.clearSelection === !0, o = e.suppressFinishActions === !0, s = e.rangeSelect === !0, a = t && e.groupSelectsFiltered === !0;
      if (this.id === void 0)
        return console.warn("AG Grid: cannot select node until id for node is known"), 0;
      if (this.rowPinned)
        return console.warn("AG Grid: cannot select pinned rows"), 0;
      if (this.footer)
        return this.sibling.setSelectedParams(e);
      if (s && this.beans.selectionService.getLastSelectedNode()) {
        var l = this.beans.selectionService.getLastSelectedNode() !== this, u = this.beans.gridOptionsWrapper.isRowSelectionMulti();
        if (l && u) {
          var c = this.doRowRangeSelection(e.newValue);
          return this.beans.selectionService.setLastSelectedNode(this), c;
        }
      }
      var h = 0, d = a && this.group;
      if (!d) {
        var f = this.selectThisNode(i);
        f && h++;
      }
      if (t && this.group && (h += this.selectChildNodes(i, a)), !o) {
        var p = i && (r || !this.beans.gridOptionsWrapper.isRowSelectionMulti());
        if (p && (h += this.beans.selectionService.clearOtherNodes(this)), h > 0) {
          this.beans.selectionService.updateGroupsFromChildrenSelections();
          var g = {
            type: F.EVENT_SELECTION_CHANGED,
            api: this.beans.gridApi,
            columnApi: this.beans.columnApi
          };
          this.beans.eventService.dispatchEvent(g);
        }
        i && this.beans.selectionService.setLastSelectedNode(this);
      }
      return h;
    }, n.prototype.doRowRangeSelection = function(e) {
      var t = this;
      e === void 0 && (e = !0);
      var i = this.beans.gridOptionsWrapper.isGroupSelectsChildren(), r = this.beans.selectionService.getLastSelectedNode(), o = this.beans.rowModel.getNodesInRangeForSelection(this, r), s = 0;
      o.forEach(function(l) {
        if (!(l.group && i || e === !1 && t === l)) {
          var u = l.selectThisNode(e);
          u && s++;
        }
      }), this.beans.selectionService.updateGroupsFromChildrenSelections();
      var a = {
        type: F.EVENT_SELECTION_CHANGED,
        api: this.beans.gridApi,
        columnApi: this.beans.columnApi
      };
      return this.beans.eventService.dispatchEvent(a), s;
    }, n.prototype.isParentOfNode = function(e) {
      for (var t = this.parent; t; ) {
        if (t === e)
          return !0;
        t = t.parent;
      }
      return !1;
    }, n.prototype.selectThisNode = function(e) {
      var t = !this.selectable && e, i = this.selected === e;
      if (t || i)
        return !1;
      this.selected = e, this.eventService && this.dispatchLocalEvent(this.createLocalRowEvent(n.EVENT_ROW_SELECTED));
      var r = this.createGlobalRowEvent(F.EVENT_ROW_SELECTED);
      return this.beans.eventService.dispatchEvent(r), !0;
    }, n.prototype.selectChildNodes = function(e, t) {
      var i = t ? this.childrenAfterFilter : this.childrenAfterGroup;
      if (Je(i))
        return 0;
      for (var r = 0, o = 0; o < i.length; o++)
        r += i[o].setSelectedParams({
          newValue: e,
          clearSelection: !1,
          suppressFinishActions: !0,
          groupSelectsFiltered: t
        });
      return r;
    }, n.prototype.addEventListener = function(e, t) {
      this.eventService || (this.eventService = new ic()), this.eventService.addEventListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      this.eventService && (this.eventService.removeEventListener(e, t), this.eventService.noRegisteredListenersExist() && (this.eventService = null));
    }, n.prototype.onMouseEnter = function() {
      this.dispatchLocalEvent(this.createLocalRowEvent(n.EVENT_MOUSE_ENTER));
    }, n.prototype.onMouseLeave = function() {
      this.dispatchLocalEvent(this.createLocalRowEvent(n.EVENT_MOUSE_LEAVE));
    }, n.prototype.getFirstChildOfFirstChild = function(e) {
      for (var t = this, i = !0, r = !1, o = null; i && !r; ) {
        var s = t.parent, a = ge(s) && t.firstChild;
        a ? s.rowGroupColumn === e && (r = !0, o = s) : i = !1, t = s;
      }
      return r ? o : null;
    }, n.prototype.isFullWidthCell = function() {
      var e = this.beans.gridOptionsWrapper.getIsFullWidthCellFunc();
      return e ? e(this) : !1;
    }, n.prototype.getRoute = function() {
      if (this.key != null) {
        for (var e = [], t = this; t.key != null; )
          e.push(t.key), t = t.parent;
        return e.reverse();
      }
    }, n.ID_PREFIX_ROW_GROUP = "row-group-", n.ID_PREFIX_TOP_PINNED = "t-", n.ID_PREFIX_BOTTOM_PINNED = "b-", n.OBJECT_ID_SEQUENCE = 0, n.EVENT_ROW_SELECTED = "rowSelected", n.EVENT_DATA_CHANGED = "dataChanged", n.EVENT_CELL_CHANGED = "cellChanged", n.EVENT_ALL_CHILDREN_COUNT_CHANGED = "allChildrenCountChanged", n.EVENT_MASTER_CHANGED = "masterChanged", n.EVENT_GROUP_CHANGED = "groupChanged", n.EVENT_MOUSE_ENTER = "mouseEnter", n.EVENT_MOUSE_LEAVE = "mouseLeave", n.EVENT_HEIGHT_CHANGED = "heightChanged", n.EVENT_TOP_CHANGED = "topChanged", n.EVENT_DISPLAYED_CHANGED = "displayedChanged", n.EVENT_FIRST_CHILD_CHANGED = "firstChildChanged", n.EVENT_LAST_CHILD_CHANGED = "lastChildChanged", n.EVENT_CHILD_INDEX_CHANGED = "childIndexChanged", n.EVENT_ROW_INDEX_CHANGED = "rowIndexChanged", n.EVENT_EXPANDED_CHANGED = "expandedChanged", n.EVENT_HAS_CHILDREN_CHANGED = "hasChildrenChanged", n.EVENT_SELECTABLE_CHANGED = "selectableChanged", n.EVENT_UI_LEVEL_CHANGED = "uiLevelChanged", n.EVENT_HIGHLIGHT_CHANGED = "rowHighlightChanged", n.EVENT_DRAGGING_CHANGED = "draggingChanged", n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var _q = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), zM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Vx = (
  /** @class */
  function(n) {
    _q(e, n);
    function e() {
      return n.call(
        this,
        /* html*/
        `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
            </div>`
      ) || this;
    }
    return e.prototype.postConstruct = function() {
      this.eCheckbox.setPassive(!0);
    }, e.prototype.getCheckboxId = function() {
      return this.eCheckbox.getInputElement().id;
    }, e.prototype.onDataChanged = function() {
      this.onSelectionChanged();
    }, e.prototype.onSelectableChanged = function() {
      this.showOrHideSelect();
    }, e.prototype.onSelectionChanged = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = this.rowNode.isSelected(), r = i === void 0 ? t("ariaIndeterminate", "indeterminate") : i === !0 ? t("ariaChecked", "checked") : t("ariaUnchecked", "unchecked"), o = t("ariaRowToggleSelection", "Press Space to toggle row selection");
      this.eCheckbox.setValue(i, !0), this.eCheckbox.setInputAriaLabel(o + " (" + r + ")");
    }, e.prototype.onCheckedClicked = function(t) {
      var i = this.gridOptionsWrapper.isGroupSelectsFiltered(), r = this.rowNode.setSelectedParams({ newValue: !1, rangeSelect: t.shiftKey, groupSelectsFiltered: i });
      return r;
    }, e.prototype.onUncheckedClicked = function(t) {
      var i = this.gridOptionsWrapper.isGroupSelectsFiltered(), r = this.rowNode.setSelectedParams({ newValue: !0, rangeSelect: t.shiftKey, groupSelectsFiltered: i });
      return r;
    }, e.prototype.init = function(t) {
      var i = this;
      this.rowNode = t.rowNode, this.column = t.column, this.onSelectionChanged(), this.addGuiEventListener("click", function(a) {
        return zp(a);
      }), this.addGuiEventListener("dblclick", function(a) {
        return zp(a);
      }), this.addManagedListener(this.eCheckbox.getInputElement(), "click", function(a) {
        var l = i.eCheckbox.getValue(), u = i.eCheckbox.getPreviousValue();
        if (u === void 0 || l === void 0) {
          var c = i.onUncheckedClicked(a || {});
          c === 0 && i.onCheckedClicked(a);
        } else
          l ? i.onCheckedClicked(a) : i.onUncheckedClicked(a || {});
      }), this.addManagedListener(this.rowNode, Wt.EVENT_ROW_SELECTED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_DATA_CHANGED, this.onDataChanged.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_SELECTABLE_CHANGED, this.onSelectableChanged.bind(this));
      var r = this.gridOptionsWrapper.getIsRowSelectableFunc(), o = r || this.checkboxCallbackExists();
      if (o) {
        var s = this.showOrHideSelect.bind(this);
        this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, s), this.addManagedListener(this.rowNode, Wt.EVENT_DATA_CHANGED, s), this.addManagedListener(this.rowNode, Wt.EVENT_CELL_CHANGED, s), this.showOrHideSelect();
      }
      this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
    }, e.prototype.showOrHideSelect = function() {
      var t = this.rowNode.selectable;
      t && this.checkboxCallbackExists() && (t = this.column.isCellCheckboxSelection(this.rowNode)), this.setVisible(t);
    }, e.prototype.checkboxCallbackExists = function() {
      var t = this.column ? this.column.getColDef() : null;
      return !!t && typeof t.checkboxSelection == "function";
    }, zM([
      ve("eCheckbox")
    ], e.prototype, "eCheckbox", void 0), zM([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Cq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), kh = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, jM = globalThis && globalThis.__values || function(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], i = 0;
  if (t)
    return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function() {
        return n && i >= n.length && (n = void 0), { value: n && n[i++], done: !n };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Ds;
(function(n) {
  n[n.ToolPanel = 0] = "ToolPanel", n[n.HeaderCell = 1] = "HeaderCell", n[n.RowDrag = 2] = "RowDrag", n[n.ChartPanel = 3] = "ChartPanel";
})(Ds || (Ds = {}));
var Fd;
(function(n) {
  n[n.Up = 0] = "Up", n[n.Down = 1] = "Down";
})(Fd || (Fd = {}));
var Ba;
(function(n) {
  n[n.Left = 0] = "Left", n[n.Right = 1] = "Right";
})(Ba || (Ba = {}));
var wo = (
  /** @class */
  function(n) {
    Cq(e, n);
    function e() {
      var i = n !== null && n.apply(this, arguments) || this;
      return i.dragSourceAndParamsList = [], i.dropTargets = [], i;
    }
    t = e, e.prototype.init = function() {
      this.ePinnedIcon = ra("columnMovePin", this.gridOptionsWrapper, null), this.eHideIcon = ra("columnMoveHide", this.gridOptionsWrapper, null), this.eMoveIcon = ra("columnMoveMove", this.gridOptionsWrapper, null), this.eLeftIcon = ra("columnMoveLeft", this.gridOptionsWrapper, null), this.eRightIcon = ra("columnMoveRight", this.gridOptionsWrapper, null), this.eGroupIcon = ra("columnMoveGroup", this.gridOptionsWrapper, null), this.eAggregateIcon = ra("columnMoveValue", this.gridOptionsWrapper, null), this.ePivotIcon = ra("columnMovePivot", this.gridOptionsWrapper, null), this.eDropNotAllowedIcon = ra("dropNotAllowed", this.gridOptionsWrapper, null);
    }, e.prototype.addDragSource = function(i, r) {
      r === void 0 && (r = !1);
      var o = {
        eElement: i.eElement,
        dragStartPixels: i.dragStartPixels,
        onDragStart: this.onDragStart.bind(this, i),
        onDragStop: this.onDragStop.bind(this),
        onDragging: this.onDragging.bind(this)
      };
      this.dragSourceAndParamsList.push({ params: o, dragSource: i }), this.dragService.addDragSource(o, r);
    }, e.prototype.removeDragSource = function(i) {
      var r = this.dragSourceAndParamsList.find(function(o) {
        return o.dragSource === i;
      });
      r && (this.dragService.removeDragSource(r.params), Zr(this.dragSourceAndParamsList, r));
    }, e.prototype.clearDragSourceParamsList = function() {
      var i = this;
      this.dragSourceAndParamsList.forEach(function(r) {
        return i.dragService.removeDragSource(r.params);
      }), this.dragSourceAndParamsList.length = 0;
    }, e.prototype.nudge = function() {
      this.dragging && this.onDragging(this.eventLastTime, !0);
    }, e.prototype.onDragStart = function(i, r) {
      this.dragging = !0, this.dragSource = i, this.eventLastTime = r, this.dragItem = this.dragSource.getDragItem(), this.lastDropTarget = this.dragSource.dragSourceDropTarget, this.dragSource.onDragStarted && this.dragSource.onDragStarted(), this.createGhost();
    }, e.prototype.onDragStop = function(i) {
      if (this.eventLastTime = null, this.dragging = !1, this.dragSource.onDragStopped && this.dragSource.onDragStopped(), this.lastDropTarget && this.lastDropTarget.onDragStop) {
        var r = this.createDropTargetEvent(this.lastDropTarget, i, null, null, !1);
        this.lastDropTarget.onDragStop(r);
      }
      this.lastDropTarget = null, this.dragItem = null, this.removeGhost();
    }, e.prototype.onDragging = function(i, r) {
      var o = this, s = this.getHorizontalDirection(i), a = this.getVerticalDirection(i);
      this.eventLastTime = i, this.positionGhost(i);
      var l = this.dropTargets.filter(function(d) {
        return o.isMouseOnDropTarget(i, d);
      }), u = l.length, c = null;
      if (u > 0 && (c = u === 1 ? l[0] : l.reduce(function(d, f) {
        if (!d)
          return f;
        var p = d.getContainer(), g = f.getContainer();
        return p.contains(g) ? f : d;
      })), c !== this.lastDropTarget)
        this.leaveLastTargetIfExists(i, s, a, r), this.enterDragTargetIfExists(c, i, s, a, r), this.lastDropTarget = c;
      else if (c && c.onDragging) {
        var h = this.createDropTargetEvent(c, i, s, a, r);
        c.onDragging(h);
      }
    }, e.prototype.enterDragTargetIfExists = function(i, r, o, s, a) {
      if (i) {
        if (i.onDragEnter) {
          var l = this.createDropTargetEvent(i, r, o, s, a);
          i.onDragEnter(l);
        }
        this.setGhostIcon(i.getIconName ? i.getIconName() : null);
      }
    }, e.prototype.leaveLastTargetIfExists = function(i, r, o, s) {
      if (this.lastDropTarget) {
        if (this.lastDropTarget.onDragLeave) {
          var a = this.createDropTargetEvent(this.lastDropTarget, i, r, o, s);
          this.lastDropTarget.onDragLeave(a);
        }
        this.setGhostIcon(null);
      }
    }, e.prototype.getAllContainersFromDropTarget = function(i) {
      var r = i.getSecondaryContainers ? i.getSecondaryContainers() : null, o = [[i.getContainer()]];
      return r ? o.concat(r) : o;
    }, e.prototype.allContainersIntersect = function(i, r) {
      var o, s;
      try {
        for (var a = jM(r), l = a.next(); !l.done; l = a.next()) {
          var u = l.value, c = u.getBoundingClientRect();
          if (c.width === 0 || c.height === 0)
            return !1;
          var h = i.clientX >= c.left && i.clientX < c.right, d = i.clientY >= c.top && i.clientY < c.bottom;
          if (!h || !d)
            return !1;
        }
      } catch (f) {
        o = { error: f };
      } finally {
        try {
          l && !l.done && (s = a.return) && s.call(a);
        } finally {
          if (o)
            throw o.error;
        }
      }
      return !0;
    }, e.prototype.isMouseOnDropTarget = function(i, r) {
      var o, s, a = this.getAllContainersFromDropTarget(r), l = !1;
      try {
        for (var u = jM(a), c = u.next(); !c.done; c = u.next()) {
          var h = c.value;
          if (this.allContainersIntersect(i, h)) {
            l = !0;
            break;
          }
        }
      } catch (d) {
        o = { error: d };
      } finally {
        try {
          c && !c.done && (s = u.return) && s.call(u);
        } finally {
          if (o)
            throw o.error;
        }
      }
      return l && r.isInterestedIn(this.dragSource.type);
    }, e.prototype.addDropTarget = function(i) {
      this.dropTargets.push(i);
    }, e.prototype.removeDropTarget = function(i) {
      this.dropTargets = this.dropTargets.filter(function(r) {
        return r.getContainer() !== i.getContainer();
      });
    }, e.prototype.hasExternalDropZones = function() {
      return this.dropTargets.some(function(i) {
        return i.external;
      });
    }, e.prototype.findExternalZone = function(i) {
      var r = this.dropTargets.filter(function(o) {
        return o.external;
      });
      return r.find(function(o) {
        return o.getContainer() === i.getContainer();
      }) || null;
    }, e.prototype.getHorizontalDirection = function(i) {
      var r = this.eventLastTime && this.eventLastTime.clientX, o = i.clientX;
      return r === o ? null : r > o ? Ba.Left : Ba.Right;
    }, e.prototype.getVerticalDirection = function(i) {
      var r = this.eventLastTime && this.eventLastTime.clientY, o = i.clientY;
      return r === o ? null : r > o ? Fd.Up : Fd.Down;
    }, e.prototype.createDropTargetEvent = function(i, r, o, s, a) {
      var l = i.getContainer(), u = l.getBoundingClientRect(), c = this, h = c.gridApi, d = c.columnApi, f = c.dragItem, p = c.dragSource, g = r.clientX - u.left, _ = r.clientY - u.top;
      return { event: r, x: g, y: _, vDirection: s, hDirection: o, dragSource: p, fromNudge: a, dragItem: f, api: h, columnApi: d, dropZoneTarget: l };
    }, e.prototype.positionGhost = function(i) {
      var r = this.eGhost;
      if (r) {
        var o = r.getBoundingClientRect(), s = o.height, a = zB() - 2, l = jB() - 2, u = i.pageY - s / 2, c = i.pageX - 10, h = this.gridOptionsWrapper.getDocument(), d = h.defaultView || window, f = d.pageYOffset || h.documentElement.scrollTop, p = d.pageXOffset || h.documentElement.scrollLeft;
        a > 0 && c + r.clientWidth > a + p && (c = a + p - r.clientWidth), c < 0 && (c = 0), l > 0 && u + r.clientHeight > l + f && (u = l + f - r.clientHeight), u < 0 && (u = 0), r.style.left = c + "px", r.style.top = u + "px";
      }
    }, e.prototype.removeGhost = function() {
      this.eGhost && this.eGhostParent && this.eGhostParent.removeChild(this.eGhost), this.eGhost = null;
    }, e.prototype.createGhost = function() {
      this.eGhost = Tr(t.GHOST_TEMPLATE);
      var i = this.environment.getTheme().theme;
      i && this.eGhost.classList.add(i), this.eGhostIcon = this.eGhost.querySelector(".ag-dnd-ghost-icon"), this.setGhostIcon(null);
      var r = this.eGhost.querySelector(".ag-dnd-ghost-label"), o = this.dragSource.dragItemName;
      px(o) && (o = o()), r.innerHTML = ql(o) || "", this.eGhost.style.height = "25px", this.eGhost.style.top = "20px", this.eGhost.style.left = "20px";
      var s = this.gridOptionsWrapper.getDocument(), a = null;
      try {
        a = s.fullscreenElement;
      } catch {
      } finally {
        a || (a = s.querySelector("body"));
      }
      this.eGhostParent = a, this.eGhostParent ? this.eGhostParent.appendChild(this.eGhost) : console.warn("AG Grid: could not find document body, it is needed for dragging columns");
    }, e.prototype.setGhostIcon = function(i, r) {
      r === void 0 && (r = !1), Ls(this.eGhostIcon);
      var o = null;
      switch (i || (i = this.dragSource.defaultIconName || t.ICON_NOT_ALLOWED), i) {
        case t.ICON_PINNED:
          o = this.ePinnedIcon;
          break;
        case t.ICON_MOVE:
          o = this.eMoveIcon;
          break;
        case t.ICON_LEFT:
          o = this.eLeftIcon;
          break;
        case t.ICON_RIGHT:
          o = this.eRightIcon;
          break;
        case t.ICON_GROUP:
          o = this.eGroupIcon;
          break;
        case t.ICON_AGGREGATE:
          o = this.eAggregateIcon;
          break;
        case t.ICON_PIVOT:
          o = this.ePivotIcon;
          break;
        case t.ICON_NOT_ALLOWED:
          o = this.eDropNotAllowedIcon;
          break;
        case t.ICON_HIDE:
          o = this.eHideIcon;
          break;
      }
      this.eGhostIcon.classList.toggle("ag-shake-left-to-right", r), !(o === this.eHideIcon && this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns()) && o && this.eGhostIcon.appendChild(o);
    };
    var t;
    return e.ICON_PINNED = "pinned", e.ICON_MOVE = "move", e.ICON_LEFT = "left", e.ICON_RIGHT = "right", e.ICON_GROUP = "group", e.ICON_AGGREGATE = "aggregate", e.ICON_PIVOT = "pivot", e.ICON_NOT_ALLOWED = "notAllowed", e.ICON_HIDE = "hide", e.GHOST_TEMPLATE = `<div class="ag-dnd-ghost ag-unselectable">
            <span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
            <div class="ag-dnd-ghost-label"></div>
        </div>`, kh([
      T("dragService")
    ], e.prototype, "dragService", void 0), kh([
      T("environment")
    ], e.prototype, "environment", void 0), kh([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), kh([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), kh([
      Le
    ], e.prototype, "init", null), kh([
      To
    ], e.prototype, "clearDragSourceParamsList", null), e = t = kh([
      qe("dragAndDropService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var FS = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), uv = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Kw = (
  /** @class */
  function(n) {
    FS(e, n);
    function e(t, i, r, o, s, a) {
      var l = n.call(this) || this;
      return l.cellValueFn = t, l.rowNode = i, l.column = r, l.customGui = o, l.dragStartPixels = s, l.suppressVisibilityChange = a, l.dragSource = null, l;
    }
    return e.prototype.isCustomGui = function() {
      return this.customGui != null;
    }, e.prototype.postConstruct = function() {
      if (this.customGui ? this.setDragElement(this.customGui, this.dragStartPixels) : (this.setTemplate(
        /* html */
        '<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>'
      ), this.getGui().appendChild(Yn("rowDrag", this.beans.gridOptionsWrapper, null)), this.addDragSource()), this.checkCompatibility(), !this.suppressVisibilityChange) {
        var t = this.beans.gridOptionsWrapper.isRowDragManaged() ? new wq(this, this.beans, this.rowNode, this.column) : new yq(this, this.beans, this.rowNode, this.column);
        this.createManagedBean(t, this.beans.context);
      }
    }, e.prototype.setDragElement = function(t, i) {
      this.setTemplateFromElement(t), this.addDragSource(i);
    }, e.prototype.getSelectedCount = function() {
      var t = this.beans.gridOptionsWrapper.isRowDragMultiRow();
      if (!t)
        return 1;
      var i = this.beans.selectionService.getSelectedNodes();
      return i.indexOf(this.rowNode) !== -1 ? i.length : 1;
    }, e.prototype.checkCompatibility = function() {
      var t = this.beans.gridOptionsWrapper.isRowDragManaged(), i = this.beans.gridOptionsWrapper.isTreeData();
      i && t && mi(function() {
        return console.warn("AG Grid: If using row drag with tree data, you cannot have rowDragManaged=true");
      }, "RowDragComp.managedAndTreeData");
    }, e.prototype.addDragSource = function(t) {
      var i = this;
      t === void 0 && (t = 4), this.dragSource && this.removeDragSource();
      var r = {
        rowNode: this.rowNode,
        columns: this.column ? [this.column] : void 0,
        defaultTextValue: this.cellValueFn()
      }, o = this.column && this.column.getColDef().rowDragText, s = this.gridOptionsWrapper.getLocaleTextFunc();
      this.dragSource = {
        type: Ds.RowDrag,
        eElement: this.getGui(),
        dragItemName: function() {
          var a = i.getSelectedCount();
          return o ? o(r, a) : a === 1 ? i.cellValueFn() : a + " " + s("rowDragRows", "rows");
        },
        getDragItem: function() {
          return r;
        },
        dragStartPixels: t,
        dragSourceDomDataKey: this.beans.gridOptionsWrapper.getDomDataKey()
      }, this.beans.dragAndDropService.addDragSource(this.dragSource, !0);
    }, e.prototype.removeDragSource = function() {
      this.dragSource && this.beans.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null;
    }, uv([
      T("beans")
    ], e.prototype, "beans", void 0), uv([
      Le
    ], e.prototype, "postConstruct", null), uv([
      To
    ], e.prototype, "removeDragSource", null), e;
  }(Et)
), PH = (
  /** @class */
  function(n) {
    FS(e, n);
    function e(t, i, r) {
      var o = n.call(this) || this;
      return o.parent = t, o.rowNode = i, o.column = r, o;
    }
    return e.prototype.setDisplayedOrVisible = function(t) {
      if (t)
        this.parent.setDisplayed(!1);
      else {
        var i = !0, r = !1;
        this.column && (i = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui(), r = px(this.column.getColDef().rowDrag)), r ? (this.parent.setDisplayed(!0), this.parent.setVisible(i)) : (this.parent.setDisplayed(i), this.parent.setVisible(!0));
      }
    }, e;
  }(Se)
), yq = (
  /** @class */
  function(n) {
    FS(e, n);
    function e(t, i, r, o) {
      var s = n.call(this, t, r, o) || this;
      return s.beans = i, s;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.beans.gridOptionsWrapper, "suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, F.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this)), this.workOutVisibility();
    }, e.prototype.onSuppressRowDrag = function() {
      this.workOutVisibility();
    }, e.prototype.workOutVisibility = function() {
      var t = this.beans.gridOptionsWrapper.isSuppressRowDrag();
      this.setDisplayedOrVisible(t);
    }, uv([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(PH)
), wq = (
  /** @class */
  function(n) {
    FS(e, n);
    function e(t, i, r, o) {
      var s = n.call(this, t, r, o) || this;
      return s.beans = i, s;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.beans.eventService, F.EVENT_SORT_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, F.EVENT_FILTER_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, F.EVENT_COLUMN_ROW_GROUP_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, F.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.gridOptionsWrapper, "suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.workOutVisibility();
    }, e.prototype.onSuppressRowDrag = function() {
      this.workOutVisibility();
    }, e.prototype.workOutVisibility = function() {
      var t = this.beans.ctrlsService.getGridBodyCtrl(), i = t.getRowDragFeature(), r = i && i.shouldPreventRowMove(), o = this.beans.gridOptionsWrapper.isSuppressRowDrag(), s = this.beans.dragAndDropService.hasExternalDropZones(), a = r && !s || o;
      this.setDisplayedOrVisible(a);
    }, uv([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(PH)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var bq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), qw = globalThis && globalThis.__assign || function() {
  return qw = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, qw.apply(this, arguments);
}, dm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, AH = (
  /** @class */
  function(n) {
    bq(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t, i, r, o, s, a, l) {
      this.params = l, this.eGui = i, this.eCheckbox = r, this.eExpanded = o, this.eContracted = s, this.comp = t, this.compClass = a;
      var u = this.isTopLevelFooter(), c = this.isEmbeddedRowMismatch(), h = l.value == null, d = !1;
      if (this.gridOptionsWrapper.isGroupIncludeFooter() && this.gridOptionsWrapper.isGroupHideOpenParents()) {
        var f = l.node;
        if (f.footer) {
          var p = l.colDef && l.colDef.showRowGroup, g = f.rowGroupColumn && f.rowGroupColumn.getColId();
          d = p !== g;
        }
      }
      this.cellIsBlank = u ? !1 : c || h || d, !this.cellIsBlank && (this.setupShowingValueForOpenedParent(), this.findDisplayedGroupNode(), this.addFullWidthRowDraggerIfNeeded(), this.addExpandAndContract(), this.addCheckboxIfNeeded(), this.addValueElement(), this.setupIndent());
    }, e.prototype.isTopLevelFooter = function() {
      if (!this.gridOptionsWrapper.isGroupIncludeTotalFooter() || this.params.value != null || this.params.node.level != -1)
        return !1;
      var t = this.params.colDef, i = t == null;
      if (i || t.showRowGroup === !0)
        return !0;
      var r = this.columnModel.getRowGroupColumns();
      if (!r || r.length === 0)
        return !0;
      var o = r[0];
      return o.getId() === t.showRowGroup;
    }, e.prototype.isEmbeddedRowMismatch = function() {
      if (!this.params.fullWidth || !this.gridOptionsWrapper.isEmbedFullWidthRows())
        return !1;
      var t = this.params.pinned === Z.PINNED_LEFT, i = this.params.pinned === Z.PINNED_RIGHT, r = !t && !i;
      return this.gridOptionsWrapper.isEnableRtl() ? this.columnModel.isPinningLeft() ? !i : !r : this.columnModel.isPinningLeft() ? !t : !r;
    }, e.prototype.findDisplayedGroupNode = function() {
      var t = this.params.column, i = this.params.node;
      if (this.showingValueForOpenedParent)
        for (var r = i.parent; r != null; ) {
          if (r.rowGroupColumn && t.isRowGroupDisplayed(r.rowGroupColumn.getId())) {
            this.displayedGroupNode = r;
            break;
          }
          r = r.parent;
        }
      Je(this.displayedGroupNode) && (this.displayedGroupNode = i);
    }, e.prototype.setupShowingValueForOpenedParent = function() {
      var t = this.params.node, i = this.params.column;
      if (!this.gridOptionsWrapper.isGroupHideOpenParents()) {
        this.showingValueForOpenedParent = !1;
        return;
      }
      if (!t.groupData) {
        this.showingValueForOpenedParent = !1;
        return;
      }
      var r = t.rowGroupColumn != null;
      if (r) {
        var o = t.rowGroupColumn.getId(), s = i.isRowGroupDisplayed(o);
        if (s) {
          this.showingValueForOpenedParent = !1;
          return;
        }
      }
      var a = t.groupData[i.getId()] != null;
      this.showingValueForOpenedParent = a;
    }, e.prototype.addValueElement = function() {
      this.displayedGroupNode.footer ? this.addFooterValue() : (this.addGroupValue(), this.addChildCount());
    }, e.prototype.addGroupValue = function() {
      var t = this.adjustParamsWithDetailsFromRelatedColumn(), i = this.getInnerCompDetails(t), r = t.valueFormatted, o = t.value, s = r ?? o;
      this.comp.setInnerRenderer(i, s);
    }, e.prototype.adjustParamsWithDetailsFromRelatedColumn = function() {
      var t = this.displayedGroupNode.rowGroupColumn, i = this.params.column;
      if (!t)
        return this.params;
      var r = i != null;
      if (r) {
        var o = i.isRowGroupDisplayed(t.getId());
        if (!o)
          return this.params;
      }
      var s = this.params, a = this.params, l = a.value, u = a.scope, c = a.node, h = this.valueFormatterService.formatValue(t, c, u, l), d = qw(qw({}, s), { valueFormatted: h });
      return d;
    }, e.prototype.addFooterValue = function() {
      var t = this.params.footerValueGetter, i = "";
      if (t) {
        var r = fx(this.params);
        r.value = this.params.value, typeof t == "function" ? i = t(r) : typeof t == "string" ? i = this.expressionService.evaluate(t, r) : console.warn("AG Grid: footerValueGetter should be either a function or a string (expression)");
      } else
        i = "Total " + (this.params.value != null ? this.params.value : "");
      var o = this.getInnerCompDetails(this.params);
      this.comp.setInnerRenderer(o, i);
    }, e.prototype.getInnerCompDetails = function(t) {
      var i = this;
      if (t.fullWidth)
        return this.userComponentFactory.getFullWidthGroupRowInnerCellRenderer(this.gridOptions.groupRowRendererParams, t);
      var r = this.userComponentFactory.getInnerRendererDetails(t, t), o = function(c) {
        return c && c.componentClass == i.compClass;
      };
      if (r && !o(r))
        return r;
      var s = this.displayedGroupNode.rowGroupColumn, a = s ? s.getColDef() : void 0;
      if (a) {
        var l = this.userComponentFactory.getCellRendererDetails(a, t);
        if (l && !o(l))
          return l;
        if (o(l) && a.cellRendererParams && a.cellRendererParams.innerRenderer) {
          var u = this.userComponentFactory.getInnerRendererDetails(a.cellRendererParams, t);
          return u;
        }
      }
    }, e.prototype.addChildCount = function() {
      this.params.suppressCount || (this.addManagedListener(this.displayedGroupNode, Wt.EVENT_ALL_CHILDREN_COUNT_CHANGED, this.updateChildCount.bind(this)), this.updateChildCount());
    }, e.prototype.updateChildCount = function() {
      var t = this.displayedGroupNode.allChildrenCount, i = this.isShowRowGroupForThisRow(), r = i && t != null && t >= 0, o = r ? "(" + t + ")" : "";
      this.comp.setChildCount(o);
    }, e.prototype.isShowRowGroupForThisRow = function() {
      if (this.gridOptionsWrapper.isTreeData())
        return !0;
      var t = this.displayedGroupNode.rowGroupColumn;
      if (!t)
        return !1;
      var i = this.params.column, r = i == null || i.isRowGroupDisplayed(t.getId());
      return r;
    }, e.prototype.addExpandAndContract = function() {
      var t = this.params, i = Yn("groupExpanded", this.gridOptionsWrapper, null), r = Yn("groupContracted", this.gridOptionsWrapper, null);
      i && this.eExpanded.appendChild(i), r && this.eContracted.appendChild(r);
      var o = t.eGridCell;
      !this.gridOptionsWrapper.isEnableGroupEdit() && this.isExpandable() && !t.suppressDoubleClickExpand && this.addManagedListener(o, "dblclick", this.onCellDblClicked.bind(this)), this.addManagedListener(this.eExpanded, "click", this.onExpandClicked.bind(this)), this.addManagedListener(this.eContracted, "click", this.onExpandClicked.bind(this)), this.addManagedListener(o, "keydown", this.onKeyDown.bind(this)), this.addManagedListener(t.node, Wt.EVENT_EXPANDED_CHANGED, this.showExpandAndContractIcons.bind(this)), this.showExpandAndContractIcons();
      var s = this.onRowNodeIsExpandableChanged.bind(this);
      this.addManagedListener(this.displayedGroupNode, Wt.EVENT_ALL_CHILDREN_COUNT_CHANGED, s), this.addManagedListener(this.displayedGroupNode, Wt.EVENT_MASTER_CHANGED, s), this.addManagedListener(this.displayedGroupNode, Wt.EVENT_GROUP_CHANGED, s), this.addManagedListener(this.displayedGroupNode, Wt.EVENT_HAS_CHILDREN_CHANGED, s);
    }, e.prototype.onExpandClicked = function(t) {
      Hl(t) || (zp(t), this.onExpandOrContract());
    }, e.prototype.onExpandOrContract = function() {
      var t = this.displayedGroupNode, i = !t.expanded;
      t.setExpanded(i);
    }, e.prototype.isExpandable = function() {
      if (this.showingValueForOpenedParent)
        return !0;
      var t = this.displayedGroupNode, i = this.columnModel.isPivotMode() && t.leafGroup, r = t.isExpandable() && !t.footer && !i;
      if (!r)
        return !1;
      var o = this.params.column, s = o != null && typeof o.getColDef().showRowGroup == "string";
      if (s) {
        var a = this.isShowRowGroupForThisRow();
        return a;
      }
      return !0;
    }, e.prototype.showExpandAndContractIcons = function() {
      var t = this, i = t.params, r = t.displayedGroupNode, o = t.columnModel, s = i.node, a = this.isExpandable();
      if (a) {
        var l = this.showingValueForOpenedParent ? !0 : s.expanded;
        this.comp.setExpandedDisplayed(l), this.comp.setContractedDisplayed(!l);
      } else
        this.comp.setExpandedDisplayed(!1), this.comp.setContractedDisplayed(!1);
      var u = o.isPivotMode(), c = u && r.leafGroup, h = a && !c, d = s.footer && s.level === -1;
      this.comp.addOrRemoveCssClass("ag-cell-expandable", h), this.comp.addOrRemoveCssClass("ag-row-group", h), u ? this.comp.addOrRemoveCssClass("ag-pivot-leaf-group", c) : d || this.comp.addOrRemoveCssClass("ag-row-group-leaf-indent", !h);
    }, e.prototype.onRowNodeIsExpandableChanged = function() {
      this.showExpandAndContractIcons(), this.setIndent();
    }, e.prototype.setupIndent = function() {
      var t = this.params.node, i = this.params.suppressPadding;
      i || (this.addManagedListener(t, Wt.EVENT_UI_LEVEL_CHANGED, this.setIndent.bind(this)), this.setIndent());
    }, e.prototype.setIndent = function() {
      if (!this.gridOptionsWrapper.isGroupHideOpenParents()) {
        var t = this.params, i = t.node, r = !!t.colDef, o = this.gridOptionsWrapper.isTreeData(), s = !r || o || t.colDef.showRowGroup === !0, a = s ? i.uiLevel : 0, l = t.padding >= 0;
        l && mi(function() {
          return console.warn("AG Grid: cellRendererParams.padding no longer works, it was deprecated in since v14.2 and removed in v26, configuring padding for groupCellRenderer should be done with Sass variables and themes. Please see the AG Grid documentation page for Themes, in particular the property $row-group-indent-size.");
        }, "groupCellRenderer->doDeprecatedWay"), this.indentClass && this.comp.addOrRemoveCssClass(this.indentClass, !1), this.indentClass = "ag-row-group-indent-" + a, this.comp.addOrRemoveCssClass(this.indentClass, !0);
      }
    }, e.prototype.addFullWidthRowDraggerIfNeeded = function() {
      var t = this;
      if (!(!this.params.fullWidth || !this.params.rowDrag)) {
        var i = new Kw(function() {
          return t.params.value;
        }, this.params.node);
        this.createManagedBean(i, this.context), this.eGui.insertAdjacentElement("afterbegin", i.getGui());
      }
    }, e.prototype.isUserWantsSelected = function() {
      var t = this.params.checkbox;
      return typeof t == "function" ? t(this.params) : t === !0;
    }, e.prototype.addCheckboxIfNeeded = function() {
      var t = this, i = this.displayedGroupNode, r = this.isUserWantsSelected() && // footers cannot be selected
      !i.footer && // pinned rows cannot be selected
      !i.rowPinned && // details cannot be selected
      !i.detail;
      if (r) {
        var o = new Vx();
        this.getContext().createBean(o), o.init({ rowNode: i, column: this.params.column }), this.eCheckbox.appendChild(o.getGui()), this.addDestroyFunc(function() {
          return t.getContext().destroyBean(o);
        });
      }
      this.comp.setCheckboxVisible(r);
    }, e.prototype.onKeyDown = function(t) {
      var i = t.key === _e.ENTER;
      if (!(!i || this.params.suppressEnterExpand)) {
        var r = this.params.column && this.params.column.isCellEditable(this.params.node);
        r || this.onExpandOrContract();
      }
    }, e.prototype.onCellDblClicked = function(t) {
      if (!Hl(t)) {
        var i = Bw(this.eExpanded, t) || Bw(this.eContracted, t);
        i || this.onExpandOrContract();
      }
    }, dm([
      T("expressionService")
    ], e.prototype, "expressionService", void 0), dm([
      T("valueFormatterService")
    ], e.prototype, "valueFormatterService", void 0), dm([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), dm([
      T("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), dm([
      T("gridOptions")
    ], e.prototype, "gridOptions", void 0), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Sq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), fm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, tR = (
  /** @class */
  function(n) {
    Sq(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.init = function(t) {
      var i = this, r = {
        setInnerRenderer: function(l, u) {
          return i.setRenderDetails(l, u);
        },
        setChildCount: function(l) {
          return i.eChildCount.innerHTML = l;
        },
        addOrRemoveCssClass: function(l, u) {
          return i.addOrRemoveCssClass(l, u);
        },
        setContractedDisplayed: function(l) {
          return Bi(i.eContracted, l);
        },
        setExpandedDisplayed: function(l) {
          return Bi(i.eExpanded, l);
        },
        setCheckboxVisible: function(l) {
          return i.eCheckbox.classList.toggle("ag-invisible", !l);
        }
      }, o = this.createManagedBean(new AH()), s = !t.colDef, a = this.getGui();
      o.init(r, a, this.eCheckbox, this.eExpanded, this.eContracted, this.constructor, t), s && Do(a, "gridcell");
    }, e.prototype.setRenderDetails = function(t, i) {
      var r = this;
      if (t) {
        var o = t.newAgStackInstance();
        if (!o)
          return;
        o.then(function(s) {
          if (s) {
            var a = function() {
              return r.context.destroyBean(s);
            };
            r.isAlive() ? (r.eValue.appendChild(s.getGui()), r.addDestroyFunc(a)) : a();
          }
        });
      } else
        this.eValue.innerText = i;
    }, e.prototype.destroy = function() {
      this.getContext().destroyBean(this.innerCellRenderer), n.prototype.destroy.call(this);
    }, e.prototype.refresh = function() {
      return !1;
    }, e.TEMPLATE = `<span class="ag-cell-wrapper">
            <span class="ag-group-expanded" ref="eExpanded"></span>
            <span class="ag-group-contracted" ref="eContracted"></span>
            <span class="ag-group-checkbox ag-invisible" ref="eCheckbox"></span>
            <span class="ag-group-value" ref="eValue"></span>
            <span class="ag-group-child-count" ref="eChildCount"></span>
        </span>`, fm([
      ve("eExpanded")
    ], e.prototype, "eExpanded", void 0), fm([
      ve("eContracted")
    ], e.prototype, "eContracted", void 0), fm([
      ve("eCheckbox")
    ], e.prototype, "eCheckbox", void 0), fm([
      ve("eValue")
    ], e.prototype, "eValue", void 0), fm([
      ve("eChildCount")
    ], e.prototype, "eChildCount", void 0), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Eq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), $M = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Lq = (
  /** @class */
  function(n) {
    Eq(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.init = function(t) {
      t.node.failedLoad ? this.setupFailed() : this.setupLoading();
    }, e.prototype.setupFailed = function() {
      this.eLoadingText.innerText = "ERR";
    }, e.prototype.setupLoading = function() {
      var t = Yn("groupLoading", this.gridOptionsWrapper, null);
      t && this.eLoadingIcon.appendChild(t);
      var i = this.gridOptionsWrapper.getLocaleTextFunc();
      this.eLoadingText.innerText = i("loadingOoo", "Loading");
    }, e.prototype.refresh = function(t) {
      return !1;
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.TEMPLATE = `<div class="ag-loading">
            <span class="ag-loading-icon" ref="eLoadingIcon"></span>
            <span class="ag-loading-text" ref="eLoadingText"></span>
        </div>`, $M([
      ve("eLoadingIcon")
    ], e.prototype, "eLoadingIcon", void 0), $M([
      ve("eLoadingText")
    ], e.prototype, "eLoadingText", void 0), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Dq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Rq = (
  /** @class */
  function(n) {
    Dq(e, n);
    function e() {
      return n.call(this) || this;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.init = function(t) {
      var i = this.gridOptionsWrapper.getOverlayLoadingTemplate() ? this.gridOptionsWrapper.getOverlayLoadingTemplate() : e.DEFAULT_LOADING_OVERLAY_TEMPLATE, r = this.gridOptionsWrapper.getLocaleTextFunc(), o = i.replace("[LOADING...]", r("loadingOoo", "Loading..."));
      this.setTemplate(o);
    }, e.DEFAULT_LOADING_OVERLAY_TEMPLATE = '<span class="ag-overlay-loading-center">[LOADING...]</span>', e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Tq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Oq = (
  /** @class */
  function(n) {
    Tq(e, n);
    function e() {
      return n.call(this) || this;
    }
    return e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.init = function(t) {
      var i = this.gridOptionsWrapper.getOverlayNoRowsTemplate() ? this.gridOptionsWrapper.getOverlayNoRowsTemplate() : e.DEFAULT_NO_ROWS_TEMPLATE, r = this.gridOptionsWrapper.getLocaleTextFunc(), o = i.replace("[NO_ROWS_TO_SHOW]", r("noRowsToShow", "No Rows To Show"));
      this.setTemplate(o);
    }, e.DEFAULT_NO_ROWS_TEMPLATE = '<span class="ag-overlay-no-rows-center">[NO_ROWS_TO_SHOW]</span>', e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var xq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Nq = (
  /** @class */
  function(n) {
    xq(e, n);
    function e() {
      return n.call(
        this,
        /* html */
        '<div class="ag-tooltip"></div>'
      ) || this;
    }
    return e.prototype.init = function(t) {
      var i = t.value;
      this.getGui().innerHTML = ql(i);
    }, e;
  }(Sg)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Iq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), BC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, MH = (
  /** @class */
  function(n) {
    Iq(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.agGridDefaults = {
        //date
        agDateInput: KK,
        //header
        agColumnHeader: tq,
        agColumnGroupHeader: nq,
        //floating filters
        agTextColumnFloatingFilter: RH,
        agNumberColumnFloatingFilter: QK,
        agDateColumnFloatingFilter: zK,
        agReadOnlyFloatingFilter: RK,
        // renderers
        agAnimateShowChangeCellRenderer: NH,
        agAnimateSlideCellRenderer: IH,
        agGroupCellRenderer: tR,
        agGroupRowRenderer: tR,
        agLoadingCellRenderer: Lq,
        //editors
        agCellEditor: $w,
        agTextCellEditor: $w,
        agSelectCellEditor: Wx,
        agPopupTextCellEditor: xH,
        agPopupSelectCellEditor: OH,
        agLargeTextCellEditor: TH,
        //filter
        agTextColumnFilter: MS,
        agNumberColumnFilter: kx,
        agDateColumnFilter: Fx,
        //overlays
        agLoadingOverlay: Rq,
        agNoRowsOverlay: Oq,
        // tooltips
        agTooltipComponent: Nq
      }, t.agDeprecatedNames = {
        set: {
          newComponentName: "agSetColumnFilter",
          propertyHolder: "filter"
        },
        text: {
          newComponentName: "agTextColumnFilter",
          propertyHolder: "filter"
        },
        number: {
          newComponentName: "agNumberColumnFilter",
          propertyHolder: "filter"
        },
        date: {
          newComponentName: "agDateColumnFilter",
          propertyHolder: "filter"
        },
        group: {
          newComponentName: "agGroupCellRenderer",
          propertyHolder: "cellRenderer"
        },
        animateShowChange: {
          newComponentName: "agAnimateShowChangeCellRenderer",
          propertyHolder: "cellRenderer"
        },
        animateSlide: {
          newComponentName: "agAnimateSlideCellRenderer",
          propertyHolder: "cellRenderer"
        },
        select: {
          newComponentName: "agSelectCellEditor",
          propertyHolder: "cellEditor"
        },
        largeText: {
          newComponentName: "agLargeTextCellEditor",
          propertyHolder: "cellEditor"
        },
        popupSelect: {
          newComponentName: "agPopupSelectCellEditor",
          propertyHolder: "cellEditor"
        },
        popupText: {
          newComponentName: "agPopupTextCellEditor",
          propertyHolder: "cellEditor"
        },
        richSelect: {
          newComponentName: "agRichSelectCellEditor",
          propertyHolder: "cellEditor"
        },
        headerComponent: {
          newComponentName: "agColumnHeader",
          propertyHolder: "headerComponent"
        }
      }, t.jsComps = {}, t.fwComps = {}, t;
    }
    return e.prototype.init = function() {
      var t = this;
      this.gridOptions.components != null && pi(this.gridOptions.components, function(i, r) {
        return t.registerJsComponent(i, r);
      }), this.gridOptions.frameworkComponents != null && pi(this.gridOptions.frameworkComponents, function(i, r) {
        return t.registerFwComponent(i, r);
      });
    }, e.prototype.registerDefaultComponent = function(t, i) {
      var r = this.translateIfDeprecated(t);
      if (this.agGridDefaults[r]) {
        console.error("Trying to overwrite a default component. You should call registerComponent");
        return;
      }
      this.agGridDefaults[r] = i;
    }, e.prototype.registerJsComponent = function(t, i) {
      var r = this.translateIfDeprecated(t);
      if (this.fwComps[r]) {
        console.error("Trying to register a component that you have already registered for frameworks: " + r);
        return;
      }
      this.jsComps[r] = i;
    }, e.prototype.registerFwComponent = function(t, i) {
      var r = "AG Grid: As of v27, registering components via grid property frameworkComponents is deprecated. Instead register both JavaScript AND Framework Components via the components property.";
      mi(function() {
        return console.warn(r);
      }, "UserComponentRegistry.frameworkComponentsDeprecated");
      var o = this.translateIfDeprecated(t);
      this.fwComps[o] = i;
    }, e.prototype.retrieve = function(t) {
      var i = this.translateIfDeprecated(t), r = function(c, h) {
        return { componentFromFramework: h, component: c };
      }, o = this.getFrameworkOverrides().frameworkComponent(i);
      if (o != null)
        return r(o, !0);
      var s = this.fwComps[i];
      if (s)
        return r(s, !0);
      var a = this.jsComps[i];
      if (a) {
        var l = this.getFrameworkOverrides().isFrameworkComponent(a);
        return r(a, l);
      }
      var u = this.agGridDefaults[i];
      return u ? r(u, !1) : (Object.keys(this.agGridDefaults).indexOf(i) < 0 && console.warn("AG Grid: Looking for component [" + i + "] but it wasn't found."), null);
    }, e.prototype.translateIfDeprecated = function(t) {
      var i = this.agDeprecatedNames[t];
      return i != null ? (mi(function() {
        console.warn("ag-grid. Since v15.0 component names have been renamed to be namespaced. You should rename " + i.propertyHolder + ":" + t + " to " + i.propertyHolder + ":" + i.newComponentName);
      }, "DEPRECATE_COMPONENT_" + t), i.newComponentName) : t;
    }, BC([
      T("gridOptions")
    ], e.prototype, "gridOptions", void 0), BC([
      T("agComponentUtils")
    ], e.prototype, "agComponentUtils", void 0), BC([
      Le
    ], e.prototype, "init", null), e = BC([
      qe("userComponentRegistry")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Pq = {
  propertyName: "dateComponent",
  cellRenderer: !1
}, Aq = {
  propertyName: "headerComponent",
  cellRenderer: !1
}, Mq = {
  propertyName: "headerGroupComponent",
  cellRenderer: !1
}, KM = {
  propertyName: "cellRenderer",
  cellRenderer: !0
}, Fq = {
  propertyName: "cellEditor",
  cellRenderer: !1
}, qM = {
  propertyName: "innerRenderer",
  cellRenderer: !0
}, kq = {
  propertyName: "loadingOverlayComponent",
  cellRenderer: !1
}, Wq = {
  propertyName: "noRowsOverlayComponent",
  cellRenderer: !1
}, Vq = {
  propertyName: "tooltipComponent",
  cellRenderer: !1
}, iR = {
  propertyName: "filter",
  cellRenderer: !1
}, Bq = {
  propertyName: "floatingFilterComponent",
  cellRenderer: !1
}, Hq = {
  propertyName: "toolPanel",
  cellRenderer: !1
}, Gq = {
  propertyName: "statusPanel",
  cellRenderer: !1
}, Uq = {
  propertyName: "fullWidthCellRenderer",
  cellRenderer: !0
}, zq = {
  propertyName: "loadingCellRenderer",
  cellRenderer: !0
}, jq = {
  propertyName: "groupRowRenderer",
  cellRenderer: !0
}, $q = {
  propertyName: "detailCellRenderer",
  cellRenderer: !0
};
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var FH = (
  /** @class */
  function() {
    function n() {
    }
    return n.getFloatingFilterType = function(e) {
      return this.filterToFloatingFilterMapping[e];
    }, n.filterToFloatingFilterMapping = {
      set: "agSetColumnFloatingFilter",
      agSetColumnFilter: "agSetColumnFloatingFilter",
      multi: "agMultiColumnFloatingFilter",
      agMultiColumnFilter: "agMultiColumnFloatingFilter",
      number: "agNumberColumnFloatingFilter",
      agNumberColumnFilter: "agNumberColumnFloatingFilter",
      date: "agDateColumnFloatingFilter",
      agDateColumnFilter: "agDateColumnFloatingFilter",
      text: "agTextColumnFloatingFilter",
      agTextColumnFilter: "agTextColumnFloatingFilter"
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Kq = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Sf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, kH = (
  /** @class */
  function(n) {
    Kq(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getHeaderCompDetails = function(t, i) {
      return this.getCompDetails(t, Aq, "agColumnHeader", i);
    }, e.prototype.getHeaderGroupCompDetails = function(t) {
      var i = t.columnGroup.getColGroupDef();
      return this.getCompDetails(i, Mq, "agColumnGroupHeader", t);
    }, e.prototype.getFullWidthCellRendererDetails = function(t) {
      return this.getCompDetails(this.gridOptions, Uq, null, t, !0);
    }, e.prototype.getFullWidthLoadingCellRendererDetails = function(t) {
      return this.getCompDetails(this.gridOptions, zq, "agLoadingCellRenderer", t, !0);
    }, e.prototype.getFullWidthGroupCellRendererDetails = function(t) {
      return this.getCompDetails(this.gridOptions, jq, "agGroupRowRenderer", t, !0);
    }, e.prototype.getFullWidthDetailCellRendererDetails = function(t) {
      return this.getCompDetails(this.gridOptions, $q, "agDetailCellRenderer", t, !0);
    }, e.prototype.getInnerRendererDetails = function(t, i) {
      return this.getCompDetails(t, qM, null, i);
    }, e.prototype.getFullWidthGroupRowInnerCellRenderer = function(t, i) {
      return this.getCompDetails(t, qM, null, i);
    }, e.prototype.getCellRendererDetails = function(t, i) {
      return this.getCompDetails(t, KM, null, i);
    }, e.prototype.getCellEditorDetails = function(t, i) {
      return this.getCompDetails(t, Fq, "agCellEditor", i, !0);
    }, e.prototype.getFilterDetails = function(t, i, r) {
      return this.getCompDetails(t, iR, r, i, !0);
    }, e.prototype.getDateCompDetails = function(t) {
      return this.getCompDetails(this.gridOptions, Pq, "agDateInput", t, !0);
    }, e.prototype.getLoadingOverlayCompDetails = function(t) {
      return this.getCompDetails(this.gridOptions, kq, "agLoadingOverlay", t, !0);
    }, e.prototype.getNoRowsOverlayCompDetails = function(t) {
      return this.getCompDetails(this.gridOptions, Wq, "agNoRowsOverlay", t, !0);
    }, e.prototype.getTooltipCompDetails = function(t) {
      return this.getCompDetails(t.colDef, Vq, "agTooltipComponent", t, !0);
    }, e.prototype.getSetFilterCellRendererDetails = function(t, i) {
      return this.getCompDetails(t, KM, null, i);
    }, e.prototype.getFloatingFilterCompDetails = function(t, i, r) {
      return this.getCompDetails(t, Bq, r, i);
    }, e.prototype.getToolPanelCompDetails = function(t, i) {
      return this.getCompDetails(t, Hq, null, i, !0);
    }, e.prototype.getStatusPanelCompDetails = function(t, i) {
      return this.getCompDetails(t, Gq, null, i, !0);
    }, e.prototype.getCompDetails = function(t, i, r, o, s) {
      var a = this;
      s === void 0 && (s = !1);
      var l = i.propertyName, u = i.cellRenderer, c = this.getCompKeys(t, i, o), h = c.compName, d = c.jsComp, f = c.fwComp, p = c.paramsFromSelector, g = c.popupFromSelector, _ = c.popupPositionFromSelector, m = function(w) {
        var L = a.userComponentRegistry.retrieve(w);
        L && (d = L.componentFromFramework ? void 0 : L.component, f = L.componentFromFramework ? L.component : void 0);
      };
      if (h != null && m(h), d == null && f == null && r != null && m(r), d && u && !this.agComponentUtils.doesImplementIComponent(d) && (d = this.agComponentUtils.adaptFunction(l, d)), !d && !f) {
        s && console.error("Could not find component " + h + ", did you forget to configure this component?");
        return;
      }
      var v = this.mergeParamsWithApplicationProvidedParams(t, i, o, p), C = d == null, y = d || f;
      return {
        componentFromFramework: C,
        componentClass: y,
        params: v,
        type: i,
        popupFromSelector: g,
        popupPositionFromSelector: _,
        newAgStackInstance: function() {
          return a.newAgStackInstance(y, C, v, i);
        }
      };
    }, e.prototype.getCompKeys = function(t, i, r) {
      var o = this, s = i.propertyName, a, l, u, c, h, d;
      if (t) {
        var f = t, p = f[s + "Selector"], g = p ? p(r) : null, _ = function(v, C) {
          var y = function() {
            var L = "AG Grid: As of v27, the property " + s + "Framework is deprecated. The property " + s + " can now be used for JavaScript AND Framework Components.";
            mi(function() {
              return console.warn(L);
            }, "UserComponentFactory." + s + "FrameworkDeprecated");
          };
          if (typeof v == "string")
            a = v;
          else if (typeof C == "string")
            y(), a = C;
          else if (v != null && v !== !0) {
            var w = o.getFrameworkOverrides().isFrameworkComponent(v);
            w ? u = v : l = v;
          } else
            C != null && (y(), u = C);
        };
        if (g) {
          if (g.frameworkComponent != null) {
            var m = "AG Grid: As of v27, the return for " + s + "Selector has attributes [component, params] only. The attribute frameworkComponent is deprecated. You should now return back Framework Components using the 'component' attribute and the grid works out if it's a framework component or not.";
            mi(function() {
              return console.warn(m);
            }, "UserComponentFactory." + s + "FrameworkSelectorDeprecated"), _(g.frameworkComponent, void 0);
          } else
            _(g.component, void 0);
          c = g.params, h = g.popup, d = g.popupPosition;
        } else
          _(f[s], f[s + "Framework"]);
      }
      return { compName: a, jsComp: l, fwComp: u, paramsFromSelector: c, popupFromSelector: h, popupPositionFromSelector: d };
    }, e.prototype.newAgStackInstance = function(t, i, r, o) {
      var s = o.propertyName, a = !i, l;
      if (a)
        l = new t();
      else {
        var u = this.componentMetadataProvider.retrieve(s);
        l = this.frameworkComponentWrapper.wrap(t, u.mandatoryMethodList, u.optionalMethodList, o);
      }
      var c = this.initComponent(l, r);
      return c == null ? Bo.resolve(l) : c.then(function() {
        return l;
      });
    }, e.prototype.mergeParamsWithApplicationProvidedParams = function(t, i, r, o) {
      o === void 0 && (o = null);
      var s = {};
      ha(s, r);
      var a = t, l = a && a[i.propertyName + "Params"];
      if (typeof l == "function") {
        var u = l(r);
        ha(s, u);
      } else
        typeof l == "object" && ha(s, l);
      return ha(s, o), s;
    }, e.prototype.initComponent = function(t, i) {
      if (this.context.createBean(t), t.init != null)
        return t.init(i);
    }, e.prototype.getDefaultFloatingFilterType = function(t) {
      if (t == null)
        return null;
      var i = null, r = this.getCompKeys(t, iR), o = r.compName, s = r.jsComp, a = r.fwComp;
      if (o)
        i = FH.getFloatingFilterType(o);
      else {
        var l = s == null && a == null && t.filter === !0;
        if (l) {
          var u = gt.isRegistered(ht.SetFilterModule);
          i = u ? "agSetColumnFloatingFilter" : "agTextColumnFloatingFilter";
        }
      }
      return i;
    }, Sf([
      T("gridOptions")
    ], e.prototype, "gridOptions", void 0), Sf([
      T("agComponentUtils")
    ], e.prototype, "agComponentUtils", void 0), Sf([
      T("componentMetadataProvider")
    ], e.prototype, "componentMetadataProvider", void 0), Sf([
      T("userComponentRegistry")
    ], e.prototype, "userComponentRegistry", void 0), Sf([
      fi("frameworkComponentWrapper")
    ], e.prototype, "frameworkComponentWrapper", void 0), e = Sf([
      qe("userComponentFactory")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var WH = (
  /** @class */
  function() {
    function n() {
    }
    return n.parse = function(e) {
      if (!e)
        return null;
      if (e === !0)
        return {
          toolPanels: [
            n.DEFAULT_COLUMN_COMP,
            n.DEFAULT_FILTER_COMP
          ],
          defaultToolPanel: "columns"
        };
      if (typeof e == "string")
        return n.parse([e]);
      if (Array.isArray(e)) {
        var t = [];
        return e.forEach(function(r) {
          var o = n.DEFAULT_BY_KEY[r];
          if (!o) {
            console.warn("AG Grid: the key " + r + " is not a valid key for specifying a tool panel, valid keys are: " + Object.keys(n.DEFAULT_BY_KEY).join(","));
            return;
          }
          t.push(o);
        }), t.length === 0 ? null : {
          toolPanels: t,
          defaultToolPanel: t[0].id
        };
      }
      var i = {
        toolPanels: n.parseComponents(e.toolPanels),
        defaultToolPanel: e.defaultToolPanel,
        hiddenByDefault: e.hiddenByDefault,
        position: e.position
      };
      return i;
    }, n.parseComponents = function(e) {
      var t = [];
      return e && e.forEach(function(i) {
        var r = null;
        if (typeof i == "string") {
          var o = n.DEFAULT_BY_KEY[i];
          if (!o) {
            console.warn("AG Grid: the key " + i + " is not a valid key for specifying a tool panel, valid keys are: " + Object.keys(n.DEFAULT_BY_KEY).join(","));
            return;
          }
          r = o;
        } else
          r = i;
        t.push(r);
      }), t;
    }, n.DEFAULT_COLUMN_COMP = {
      id: "columns",
      labelDefault: "Columns",
      labelKey: "columns",
      iconKey: "columns",
      toolPanel: "agColumnsToolPanel"
    }, n.DEFAULT_FILTER_COMP = {
      id: "filters",
      labelDefault: "Filters",
      labelKey: "filters",
      iconKey: "filter",
      toolPanel: "agFiltersToolPanel"
    }, n.DEFAULT_BY_KEY = {
      columns: n.DEFAULT_COLUMN_COMP,
      filters: n.DEFAULT_FILTER_COMP
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var wc = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, YM = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, qq = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, SL = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(qq(arguments[e]));
  return n;
}, Yq = 25, Xq = 300, Zq = 5, Qq = 5, Jq = 10;
function de(n) {
  return n === !0 || n === "true";
}
function EL(n) {
  if (typeof n == "number")
    return n;
  if (typeof n == "string")
    return parseInt(n, 10);
}
function eY(n, e) {
  return n >= 0 ? n : e;
}
function XM(n, e) {
  var t = parseInt(n, 10);
  return Uw(t) && t > 0 ? t : e;
}
var He = (
  /** @class */
  function() {
    function n() {
      this.propertyEventService = new ic(), this.domDataKey = "__AG_" + Math.random().toString(), this.destroyed = !1;
    }
    e = n, n.prototype.agWire = function(t, i) {
      this.gridOptions.api = t, this.gridOptions.columnApi = i, this.checkForDeprecated(), this.checkForViolations();
    }, n.prototype.destroy = function() {
      this.gridOptions.api = null, this.gridOptions.columnApi = null, this.destroyed = !0;
    }, n.prototype.init = function() {
      var t = this;
      this.gridOptions.suppressPropertyNamesCheck !== !0 && (this.checkGridOptionsProperties(), this.checkColumnDefProperties()), this.gridOptions.sideBar != null && (this.gridOptions.sideBar = WH.parse(this.gridOptions.sideBar));
      var i = this.useAsyncEvents();
      if (this.eventService.addGlobalListener(this.globalEventHandler.bind(this), i), this.isGroupSelectsChildren() && this.isSuppressParentsInRowNodes() && console.warn("AG Grid: 'groupSelectsChildren' does not work with 'suppressParentsInRowNodes', this selection method needs the part in rowNode to work"), this.isGroupSelectsChildren() && (this.isRowSelectionMulti() || console.warn("AG Grid: rowSelection must be 'multiple' for groupSelectsChildren to make sense"), this.isRowModelServerSide() && console.warn("AG Grid: group selects children is NOT support for Server Side Row Model. This is because the rows are lazy loaded, so selecting a group is not possible asthe grid has no way of knowing what the children are.")), this.isGroupRemoveSingleChildren() && this.isGroupHideOpenParents() && console.warn("AG Grid: groupRemoveSingleChildren and groupHideOpenParents do not work with each other, you need to pick one. And don't ask us how to us these together on our support forum either you will get the same answer!"), this.isRowModelServerSide()) {
        var r = function(s) {
          return "AG Grid: '" + s + "' is not supported on the Server-Side Row Model";
        };
        ge(this.gridOptions.groupDefaultExpanded) && console.warn(r("groupDefaultExpanded")), ge(this.gridOptions.groupDefaultExpanded) && console.warn(r("groupIncludeFooter")), ge(this.gridOptions.groupDefaultExpanded) && console.warn(r("groupIncludeTotalFooter"));
      }
      this.isEnableRangeSelection() && gt.assertRegistered(ht.RangeSelectionModule, "enableRangeSelection"), !this.isEnableRangeSelection() && (this.isEnableRangeHandle() || this.isEnableFillHandle()) && console.warn("AG Grid: 'enableRangeHandle' and 'enableFillHandle' will not work unless 'enableRangeSelection' is set to true");
      var o = function(s) {
        t.gridOptions.icons && t.gridOptions.icons[s] && console.warn("gridOptions.icons." + s + " is no longer supported. For information on how to style checkboxes and radio buttons, see https://www.ag-grid.com/javascript-grid-icons/");
      };
      o("radioButtonOff"), o("radioButtonOn"), o("checkboxChecked"), o("checkboxUnchecked"), o("checkboxIndeterminate"), this.getScrollbarWidth();
    }, n.prototype.checkColumnDefProperties = function() {
      var t = this;
      this.gridOptions.columnDefs != null && this.gridOptions.columnDefs.forEach(function(i) {
        var r = Object.getOwnPropertyNames(i), o = SL(U1.ALL_PROPERTIES, U1.FRAMEWORK_PROPERTIES);
        t.checkProperties(r, o, o, "colDef", "https://www.ag-grid.com/javascript-grid-column-properties/");
      });
    }, n.prototype.checkGridOptionsProperties = function() {
      var t = Object.getOwnPropertyNames(this.gridOptions), i = SL(Ml.ALL_PROPERTIES, Ml.FRAMEWORK_PROPERTIES, ef(F).map(function(o) {
        return Xc.getCallbackForEvent(o);
      })), r = SL(i, ["api", "columnApi"]);
      this.checkProperties(t, r, i, "gridOptions", "https://www.ag-grid.com/javascript-grid-properties/");
    }, n.prototype.checkProperties = function(t, i, r, o, s) {
      var a = fH(t, i, r);
      pi(a, function(l, u) {
        console.warn("ag-grid: invalid " + o + " property '" + l + "' did you mean any of these: " + u.slice(0, 8).join(", "));
      }), Object.keys(a).length > 0 && console.warn("ag-grid: to see all the valid " + o + " properties please check: " + s);
    }, n.prototype.getDomDataKey = function() {
      return this.domDataKey;
    }, n.prototype.getDomData = function(t, i) {
      var r = t[this.getDomDataKey()];
      return r ? r[i] : void 0;
    }, n.prototype.setDomData = function(t, i, r) {
      var o = this.getDomDataKey(), s = t[o];
      Je(s) && (s = {}, t[o] = s), s[i] = r;
    }, n.prototype.isRowSelection = function() {
      return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple";
    }, n.prototype.isSuppressRowDeselection = function() {
      return de(this.gridOptions.suppressRowDeselection);
    }, n.prototype.isRowSelectionMulti = function() {
      return this.gridOptions.rowSelection === "multiple";
    }, n.prototype.isRowMultiSelectWithClick = function() {
      return de(this.gridOptions.rowMultiSelectWithClick);
    }, n.prototype.getContext = function() {
      return this.gridOptions.context;
    }, n.prototype.isPivotMode = function() {
      return de(this.gridOptions.pivotMode);
    }, n.prototype.isSuppressExpandablePivotGroups = function() {
      return de(this.gridOptions.suppressExpandablePivotGroups);
    }, n.prototype.getPivotColumnGroupTotals = function() {
      return this.gridOptions.pivotColumnGroupTotals;
    }, n.prototype.getPivotRowTotals = function() {
      return this.gridOptions.pivotRowTotals;
    }, n.prototype.isRowModelInfinite = function() {
      return this.gridOptions.rowModelType === Z.ROW_MODEL_TYPE_INFINITE;
    }, n.prototype.isRowModelViewport = function() {
      return this.gridOptions.rowModelType === Z.ROW_MODEL_TYPE_VIEWPORT;
    }, n.prototype.isRowModelServerSide = function() {
      return this.gridOptions.rowModelType === Z.ROW_MODEL_TYPE_SERVER_SIDE;
    }, n.prototype.isRowModelDefault = function() {
      return Je(this.gridOptions.rowModelType) || this.gridOptions.rowModelType === Z.ROW_MODEL_TYPE_CLIENT_SIDE;
    }, n.prototype.isFullRowEdit = function() {
      return this.gridOptions.editType === "fullRow";
    }, n.prototype.isSuppressFocusAfterRefresh = function() {
      return de(this.gridOptions.suppressFocusAfterRefresh);
    }, n.prototype.isSuppressBrowserResizeObserver = function() {
      return de(this.gridOptions.suppressBrowserResizeObserver);
    }, n.prototype.isSuppressMaintainUnsortedOrder = function() {
      return de(this.gridOptions.suppressMaintainUnsortedOrder);
    }, n.prototype.isSuppressClearOnFillReduction = function() {
      return de(this.gridOptions.suppressClearOnFillReduction);
    }, n.prototype.isShowToolPanel = function() {
      return de(this.gridOptions.sideBar && Array.isArray(this.getSideBar().toolPanels));
    }, n.prototype.getSideBar = function() {
      return this.gridOptions.sideBar;
    }, n.prototype.isSuppressTouch = function() {
      return de(this.gridOptions.suppressTouch);
    }, n.prototype.isMaintainColumnOrder = function() {
      return de(this.gridOptions.maintainColumnOrder);
    }, n.prototype.isSuppressRowTransform = function() {
      return de(this.gridOptions.suppressRowTransform);
    }, n.prototype.isSuppressColumnStateEvents = function() {
      return de(this.gridOptions.suppressColumnStateEvents);
    }, n.prototype.isAllowDragFromColumnsToolPanel = function() {
      return de(this.gridOptions.allowDragFromColumnsToolPanel);
    }, n.prototype.useAsyncEvents = function() {
      return !de(this.gridOptions.suppressAsyncEvents);
    }, n.prototype.isEnableCellChangeFlash = function() {
      return de(this.gridOptions.enableCellChangeFlash);
    }, n.prototype.getCellFlashDelay = function() {
      return this.gridOptions.cellFlashDelay || 500;
    }, n.prototype.getCellFadeDelay = function() {
      return this.gridOptions.cellFadeDelay || 1e3;
    }, n.prototype.isGroupSelectsChildren = function() {
      var t = de(this.gridOptions.groupSelectsChildren);
      return t && this.isTreeData() ? (console.warn("AG Grid: groupSelectsChildren does not work with tree data"), !1) : t;
    }, n.prototype.isSuppressRowHoverHighlight = function() {
      return de(this.gridOptions.suppressRowHoverHighlight);
    }, n.prototype.isColumnHoverHighlight = function() {
      return de(this.gridOptions.columnHoverHighlight);
    }, n.prototype.isGroupSelectsFiltered = function() {
      return de(this.gridOptions.groupSelectsFiltered);
    }, n.prototype.isGroupHideOpenParents = function() {
      return de(this.gridOptions.groupHideOpenParents);
    }, n.prototype.isGroupMaintainOrder = function() {
      return de(this.gridOptions.groupMaintainOrder);
    }, n.prototype.getAutoGroupColumnDef = function() {
      return this.gridOptions.autoGroupColumnDef;
    }, n.prototype.isGroupMultiAutoColumn = function() {
      return this.gridOptions.groupDisplayType ? this.matchesGroupDisplayType("multipleColumns", this.gridOptions.groupDisplayType) : de(this.gridOptions.groupHideOpenParents);
    }, n.prototype.isGroupUseEntireRow = function(t) {
      return t ? !1 : this.gridOptions.groupDisplayType ? this.matchesGroupDisplayType("groupRows", this.gridOptions.groupDisplayType) : !1;
    }, n.prototype.isGroupSuppressAutoColumn = function() {
      var t = this.gridOptions.groupDisplayType ? this.matchesGroupDisplayType("custom", this.gridOptions.groupDisplayType) : !1;
      return t ? !0 : this.gridOptions.treeDataDisplayType ? this.matchesTreeDataDisplayType("custom", this.gridOptions.treeDataDisplayType) : !1;
    }, n.prototype.isGroupRemoveSingleChildren = function() {
      return de(this.gridOptions.groupRemoveSingleChildren);
    }, n.prototype.isGroupRemoveLowestSingleChildren = function() {
      return de(this.gridOptions.groupRemoveLowestSingleChildren);
    }, n.prototype.isGroupIncludeFooter = function() {
      return de(this.gridOptions.groupIncludeFooter);
    }, n.prototype.isGroupIncludeTotalFooter = function() {
      return de(this.gridOptions.groupIncludeTotalFooter);
    }, n.prototype.isGroupSuppressBlankHeader = function() {
      return de(this.gridOptions.groupSuppressBlankHeader);
    }, n.prototype.isSuppressRowClickSelection = function() {
      return de(this.gridOptions.suppressRowClickSelection);
    }, n.prototype.isSuppressCellFocus = function() {
      return de(this.gridOptions.suppressCellFocus);
    }, n.prototype.isSuppressMultiSort = function() {
      return de(this.gridOptions.suppressMultiSort);
    }, n.prototype.isMultiSortKeyCtrl = function() {
      return this.gridOptions.multiSortKey === "ctrl";
    }, n.prototype.isPivotSuppressAutoColumn = function() {
      return de(this.gridOptions.pivotSuppressAutoColumn);
    }, n.prototype.isSuppressDragLeaveHidesColumns = function() {
      return de(this.gridOptions.suppressDragLeaveHidesColumns);
    }, n.prototype.isSuppressScrollOnNewData = function() {
      return de(this.gridOptions.suppressScrollOnNewData);
    }, n.prototype.isSuppressScrollWhenPopupsAreOpen = function() {
      return de(this.gridOptions.suppressScrollWhenPopupsAreOpen);
    }, n.prototype.isRowDragEntireRow = function() {
      return de(this.gridOptions.rowDragEntireRow);
    }, n.prototype.isSuppressRowDrag = function() {
      return de(this.gridOptions.suppressRowDrag);
    }, n.prototype.isRowDragManaged = function() {
      return de(this.gridOptions.rowDragManaged);
    }, n.prototype.isSuppressMoveWhenRowDragging = function() {
      return de(this.gridOptions.suppressMoveWhenRowDragging);
    }, n.prototype.isRowDragMultiRow = function() {
      return de(this.gridOptions.rowDragMultiRow);
    }, n.prototype.getDomLayout = function() {
      var t = this.gridOptions.domLayout || Z.DOM_LAYOUT_NORMAL, i = [
        Z.DOM_LAYOUT_PRINT,
        Z.DOM_LAYOUT_AUTO_HEIGHT,
        Z.DOM_LAYOUT_NORMAL
      ];
      return i.indexOf(t) === -1 ? (mi(function() {
        return console.warn("AG Grid: " + t + " is not valid for DOM Layout, valid values are " + Z.DOM_LAYOUT_NORMAL + ", " + Z.DOM_LAYOUT_AUTO_HEIGHT + " and " + Z.DOM_LAYOUT_PRINT);
      }, "warn about dom layout values"), Z.DOM_LAYOUT_NORMAL) : t;
    }, n.prototype.isSuppressHorizontalScroll = function() {
      return de(this.gridOptions.suppressHorizontalScroll);
    }, n.prototype.isSuppressMaxRenderedRowRestriction = function() {
      return de(this.gridOptions.suppressMaxRenderedRowRestriction);
    }, n.prototype.isExcludeChildrenWhenTreeDataFiltering = function() {
      return de(this.gridOptions.excludeChildrenWhenTreeDataFiltering);
    }, n.prototype.isAlwaysShowHorizontalScroll = function() {
      return de(this.gridOptions.alwaysShowHorizontalScroll);
    }, n.prototype.isAlwaysShowVerticalScroll = function() {
      return de(this.gridOptions.alwaysShowVerticalScroll);
    }, n.prototype.isDebounceVerticalScrollbar = function() {
      return de(this.gridOptions.debounceVerticalScrollbar);
    }, n.prototype.isSuppressLoadingOverlay = function() {
      return de(this.gridOptions.suppressLoadingOverlay);
    }, n.prototype.isSuppressNoRowsOverlay = function() {
      return de(this.gridOptions.suppressNoRowsOverlay);
    }, n.prototype.isSuppressFieldDotNotation = function() {
      return de(this.gridOptions.suppressFieldDotNotation);
    }, n.prototype.getPinnedTopRowData = function() {
      return this.gridOptions.pinnedTopRowData;
    }, n.prototype.getPinnedBottomRowData = function() {
      return this.gridOptions.pinnedBottomRowData;
    }, n.prototype.isFunctionsPassive = function() {
      return de(this.gridOptions.functionsPassive);
    }, n.prototype.isSuppressChangeDetection = function() {
      return de(this.gridOptions.suppressChangeDetection);
    }, n.prototype.isSuppressAnimationFrame = function() {
      return de(this.gridOptions.suppressAnimationFrame);
    }, n.prototype.getQuickFilterText = function() {
      return this.gridOptions.quickFilterText;
    }, n.prototype.isCacheQuickFilter = function() {
      return de(this.gridOptions.cacheQuickFilter);
    }, n.prototype.isUnSortIcon = function() {
      return de(this.gridOptions.unSortIcon);
    }, n.prototype.isSuppressMenuHide = function() {
      return de(this.gridOptions.suppressMenuHide);
    }, n.prototype.isEnterMovesDownAfterEdit = function() {
      return de(this.gridOptions.enterMovesDownAfterEdit);
    }, n.prototype.isEnterMovesDown = function() {
      return de(this.gridOptions.enterMovesDown);
    }, n.prototype.isUndoRedoCellEditing = function() {
      return de(this.gridOptions.undoRedoCellEditing);
    }, n.prototype.getUndoRedoCellEditingLimit = function() {
      return EL(this.gridOptions.undoRedoCellEditingLimit);
    }, n.prototype.getRowStyle = function() {
      return this.gridOptions.rowStyle;
    }, n.prototype.getRowClass = function() {
      return this.gridOptions.rowClass;
    }, n.prototype.getRowStyleFunc = function() {
      return this.gridOptions.getRowStyle;
    }, n.prototype.getRowClassFunc = function() {
      return this.gridOptions.getRowClass;
    }, n.prototype.rowClassRules = function() {
      return this.gridOptions.rowClassRules;
    }, n.prototype.getServerSideStoreType = function() {
      return this.gridOptions.serverSideStoreType;
    }, n.prototype.getServerSideStoreParamsFunc = function() {
      return this.gridOptions.getServerSideStoreParams;
    }, n.prototype.getCreateChartContainerFunc = function() {
      return this.gridOptions.createChartContainer;
    }, n.prototype.getPopupParent = function() {
      return this.gridOptions.popupParent;
    }, n.prototype.getBlockLoadDebounceMillis = function() {
      return this.gridOptions.blockLoadDebounceMillis;
    }, n.prototype.getPostProcessPopupFunc = function() {
      return this.gridOptions.postProcessPopup;
    }, n.prototype.getPaginationNumberFormatterFunc = function() {
      return this.gridOptions.paginationNumberFormatter;
    }, n.prototype.getChildCountFunc = function() {
      return this.gridOptions.getChildCount;
    }, n.prototype.getIsApplyServerSideTransactionFunc = function() {
      return this.gridOptions.isApplyServerSideTransaction;
    }, n.prototype.getDefaultGroupOrderComparator = function() {
      return this.gridOptions.defaultGroupOrderComparator;
    }, n.prototype.getIsFullWidthCellFunc = function() {
      return this.gridOptions.isFullWidthCell;
    }, n.prototype.getFullWidthCellRendererParams = function() {
      return this.gridOptions.fullWidthCellRendererParams;
    }, n.prototype.isEmbedFullWidthRows = function() {
      return de(this.gridOptions.embedFullWidthRows) || de(this.gridOptions.deprecatedEmbedFullWidthRows);
    }, n.prototype.isDetailRowAutoHeight = function() {
      return de(this.gridOptions.detailRowAutoHeight);
    }, n.prototype.getSuppressKeyboardEventFunc = function() {
      return this.gridOptions.suppressKeyboardEvent;
    }, n.prototype.getBusinessKeyForNodeFunc = function() {
      return this.gridOptions.getBusinessKeyForNode;
    }, n.prototype.getApi = function() {
      return this.gridOptions.api;
    }, n.prototype.getColumnApi = function() {
      return this.gridOptions.columnApi;
    }, n.prototype.isReadOnlyEdit = function() {
      return de(this.gridOptions.readOnlyEdit);
    }, n.prototype.isImmutableData = function() {
      return this.gridOptions.getRowId != null || de(this.gridOptions.immutableData);
    }, n.prototype.isEnsureDomOrder = function() {
      return de(this.gridOptions.ensureDomOrder);
    }, n.prototype.isEnableCharts = function() {
      return de(this.gridOptions.enableCharts) ? gt.assertRegistered(ht.GridChartsModule, "enableCharts") : !1;
    }, n.prototype.getColResizeDefault = function() {
      return this.gridOptions.colResizeDefault;
    }, n.prototype.isSingleClickEdit = function() {
      return de(this.gridOptions.singleClickEdit);
    }, n.prototype.isSuppressClickEdit = function() {
      return de(this.gridOptions.suppressClickEdit);
    }, n.prototype.isStopEditingWhenCellsLoseFocus = function() {
      return de(this.gridOptions.stopEditingWhenCellsLoseFocus);
    }, n.prototype.getGroupDefaultExpanded = function() {
      return this.gridOptions.groupDefaultExpanded;
    }, n.prototype.getMaxConcurrentDatasourceRequests = function() {
      var t = EL(this.gridOptions.maxConcurrentDatasourceRequests);
      if (t == null)
        return 2;
      if (!(t <= 0))
        return t;
    }, n.prototype.getMaxBlocksInCache = function() {
      return this.gridOptions.maxBlocksInCache;
    }, n.prototype.getCacheOverflowSize = function() {
      return this.gridOptions.cacheOverflowSize;
    }, n.prototype.getPaginationPageSize = function() {
      return EL(this.gridOptions.paginationPageSize);
    }, n.prototype.isPaginateChildRows = function() {
      var t = this.isGroupRemoveSingleChildren() || this.isGroupRemoveLowestSingleChildren();
      return t ? !0 : de(this.gridOptions.paginateChildRows);
    }, n.prototype.getCacheBlockSize = function() {
      return XM(this.gridOptions.cacheBlockSize);
    }, n.prototype.getInfiniteInitialRowCount = function() {
      return this.gridOptions.infiniteInitialRowCount;
    }, n.prototype.isPurgeClosedRowNodes = function() {
      return de(this.gridOptions.purgeClosedRowNodes);
    }, n.prototype.isSuppressPaginationPanel = function() {
      return de(this.gridOptions.suppressPaginationPanel);
    }, n.prototype.getRowData = function() {
      return this.gridOptions.rowData;
    }, n.prototype.isEnableRtl = function() {
      return de(this.gridOptions.enableRtl);
    }, n.prototype.getRowGroupPanelShow = function() {
      return this.gridOptions.rowGroupPanelShow;
    }, n.prototype.getPivotPanelShow = function() {
      return this.gridOptions.pivotPanelShow;
    }, n.prototype.isAngularCompileRows = function() {
      return de(this.gridOptions.angularCompileRows);
    }, n.prototype.isAngularCompileFilters = function() {
      return de(this.gridOptions.angularCompileFilters);
    }, n.prototype.isDebug = function() {
      return de(this.gridOptions.debug);
    }, n.prototype.getColumnDefs = function() {
      return this.gridOptions.columnDefs;
    }, n.prototype.getColumnTypes = function() {
      return this.gridOptions.columnTypes;
    }, n.prototype.getDatasource = function() {
      return this.gridOptions.datasource;
    }, n.prototype.getViewportDatasource = function() {
      return this.gridOptions.viewportDatasource;
    }, n.prototype.getServerSideDatasource = function() {
      return this.gridOptions.serverSideDatasource;
    }, n.prototype.isAccentedSort = function() {
      return de(this.gridOptions.accentedSort);
    }, n.prototype.isEnableBrowserTooltips = function() {
      return de(this.gridOptions.enableBrowserTooltips);
    }, n.prototype.isEnableCellExpressions = function() {
      return de(this.gridOptions.enableCellExpressions);
    }, n.prototype.isEnableGroupEdit = function() {
      return de(this.gridOptions.enableGroupEdit);
    }, n.prototype.isSuppressMiddleClickScrolls = function() {
      return de(this.gridOptions.suppressMiddleClickScrolls);
    }, n.prototype.isPreventDefaultOnContextMenu = function() {
      return de(this.gridOptions.preventDefaultOnContextMenu);
    }, n.prototype.isSuppressPreventDefaultOnMouseWheel = function() {
      return de(this.gridOptions.suppressPreventDefaultOnMouseWheel);
    }, n.prototype.isSuppressColumnVirtualisation = function() {
      return de(this.gridOptions.suppressColumnVirtualisation);
    }, n.prototype.isSuppressRowVirtualisation = function() {
      return de(this.gridOptions.suppressRowVirtualisation);
    }, n.prototype.isSuppressContextMenu = function() {
      return de(this.gridOptions.suppressContextMenu);
    }, n.prototype.isAllowContextMenuWithControlKey = function() {
      return de(this.gridOptions.allowContextMenuWithControlKey);
    }, n.prototype.isSuppressCopyRowsToClipboard = function() {
      return de(this.gridOptions.suppressCopyRowsToClipboard);
    }, n.prototype.isCopyHeadersToClipboard = function() {
      return de(this.gridOptions.copyHeadersToClipboard);
    }, n.prototype.isCopyGroupHeadersToClipboard = function() {
      return de(this.gridOptions.copyGroupHeadersToClipboard);
    }, n.prototype.isSuppressClipboardPaste = function() {
      return de(this.gridOptions.suppressClipboardPaste);
    }, n.prototype.isSuppressLastEmptyLineOnPaste = function() {
      return de(this.gridOptions.suppressLastEmptyLineOnPaste);
    }, n.prototype.isPagination = function() {
      return de(this.gridOptions.pagination);
    }, n.prototype.isSuppressEnterpriseResetOnNewColumns = function() {
      return de(this.gridOptions.suppressEnterpriseResetOnNewColumns);
    }, n.prototype.getProcessDataFromClipboardFunc = function() {
      return this.gridOptions.processDataFromClipboard;
    }, n.prototype.getAsyncTransactionWaitMillis = function() {
      return ge(this.gridOptions.asyncTransactionWaitMillis) ? this.gridOptions.asyncTransactionWaitMillis : Z.BATCH_WAIT_MILLIS;
    }, n.prototype.isSuppressMovableColumns = function() {
      return de(this.gridOptions.suppressMovableColumns);
    }, n.prototype.isAnimateRows = function() {
      return this.isEnsureDomOrder() ? !1 : de(this.gridOptions.animateRows);
    }, n.prototype.isSuppressColumnMoveAnimation = function() {
      return de(this.gridOptions.suppressColumnMoveAnimation);
    }, n.prototype.isSuppressAggFuncInHeader = function() {
      return de(this.gridOptions.suppressAggFuncInHeader);
    }, n.prototype.isSuppressAggAtRootLevel = function() {
      return de(this.gridOptions.suppressAggAtRootLevel);
    }, n.prototype.isSuppressAggFilteredOnly = function() {
      return de(this.gridOptions.suppressAggFilteredOnly);
    }, n.prototype.isShowOpenedGroup = function() {
      return de(this.gridOptions.showOpenedGroup);
    }, n.prototype.isReactUi = function() {
      return de(this.gridOptions.reactUi);
    }, n.prototype.isSuppressReactUi = function() {
      return de(this.gridOptions.suppressReactUi);
    }, n.prototype.isEnableRangeSelection = function() {
      return gt.isRegistered(ht.RangeSelectionModule) && de(this.gridOptions.enableRangeSelection);
    }, n.prototype.isEnableRangeHandle = function() {
      return de(this.gridOptions.enableRangeHandle);
    }, n.prototype.isEnableFillHandle = function() {
      return de(this.gridOptions.enableFillHandle);
    }, n.prototype.getFillHandleDirection = function() {
      var t = this.gridOptions.fillHandleDirection;
      return t ? t !== "x" && t !== "y" && t !== "xy" ? (mi(function() {
        return console.warn("AG Grid: valid values for fillHandleDirection are 'x', 'y' and 'xy'. Default to 'xy'.");
      }, "warn invalid fill direction"), "xy") : t : "xy";
    }, n.prototype.getFillOperation = function() {
      return this.gridOptions.fillOperation;
    }, n.prototype.isSuppressMultiRangeSelection = function() {
      return de(this.gridOptions.suppressMultiRangeSelection);
    }, n.prototype.isPaginationAutoPageSize = function() {
      return de(this.gridOptions.paginationAutoPageSize);
    }, n.prototype.isRememberGroupStateWhenNewData = function() {
      return de(this.gridOptions.rememberGroupStateWhenNewData);
    }, n.prototype.getIcons = function() {
      return this.gridOptions.icons;
    }, n.prototype.getAggFuncs = function() {
      return this.gridOptions.aggFuncs;
    }, n.prototype.getSortingOrder = function() {
      return this.gridOptions.sortingOrder;
    }, n.prototype.getAlignedGrids = function() {
      return this.gridOptions.alignedGrids;
    }, n.prototype.isMasterDetail = function() {
      var t = de(this.gridOptions.masterDetail);
      return t ? gt.assertRegistered(ht.MasterDetailModule, "masterDetail") : !1;
    }, n.prototype.isKeepDetailRows = function() {
      return de(this.gridOptions.keepDetailRows);
    }, n.prototype.getKeepDetailRowsCount = function() {
      var t = this.gridOptions.keepDetailRowsCount;
      return ge(t) && t > 0 ? this.gridOptions.keepDetailRowsCount : Jq;
    }, n.prototype.getIsRowMasterFunc = function() {
      return this.gridOptions.isRowMaster;
    }, n.prototype.getIsRowSelectableFunc = function() {
      return this.gridOptions.isRowSelectable;
    }, n.prototype.getGroupRowRendererParams = function() {
      return this.gridOptions.groupRowRendererParams;
    }, n.prototype.getOverlayLoadingTemplate = function() {
      return this.gridOptions.overlayLoadingTemplate;
    }, n.prototype.getOverlayNoRowsTemplate = function() {
      return this.gridOptions.overlayNoRowsTemplate;
    }, n.prototype.isSuppressAutoSize = function() {
      return de(this.gridOptions.suppressAutoSize);
    }, n.prototype.isEnableCellTextSelection = function() {
      return de(this.gridOptions.enableCellTextSelection);
    }, n.prototype.isSuppressParentsInRowNodes = function() {
      return de(this.gridOptions.suppressParentsInRowNodes);
    }, n.prototype.isSuppressClipboardApi = function() {
      return de(this.gridOptions.suppressClipboardApi);
    }, n.prototype.isFunctionsReadOnly = function() {
      return de(this.gridOptions.functionsReadOnly);
    }, n.prototype.isEnableCellTextSelect = function() {
      return de(this.gridOptions.enableCellTextSelection);
    }, n.prototype.getDefaultColDef = function() {
      return this.gridOptions.defaultColDef;
    }, n.prototype.getDefaultColGroupDef = function() {
      return this.gridOptions.defaultColGroupDef;
    }, n.prototype.getDefaultExportParams = function(t) {
      if (this.gridOptions.defaultExportParams)
        return console.warn("AG Grid: Since v25.2 `defaultExportParams`  has been replaced by `default" + H1(t) + "ExportParams`'"), t === "csv" ? this.gridOptions.defaultExportParams : this.gridOptions.defaultExportParams;
      if (t === "csv" && this.gridOptions.defaultCsvExportParams)
        return this.gridOptions.defaultCsvExportParams;
      if (t === "excel" && this.gridOptions.defaultExcelExportParams)
        return this.gridOptions.defaultExcelExportParams;
    }, n.prototype.isSuppressCsvExport = function() {
      return de(this.gridOptions.suppressCsvExport);
    }, n.prototype.isAllowShowChangeAfterFilter = function() {
      return de(this.gridOptions.allowShowChangeAfterFilter);
    }, n.prototype.isSuppressExcelExport = function() {
      return de(this.gridOptions.suppressExcelExport);
    }, n.prototype.isSuppressMakeColumnVisibleAfterUnGroup = function() {
      return de(this.gridOptions.suppressMakeColumnVisibleAfterUnGroup);
    }, n.prototype.getDataPathFunc = function() {
      return this.gridOptions.getDataPath;
    }, n.prototype.getIsServerSideGroupFunc = function() {
      return this.gridOptions.isServerSideGroup;
    }, n.prototype.getIsServerSideGroupOpenByDefaultFunc = function() {
      return this.gridOptions.isServerSideGroupOpenByDefault;
    }, n.prototype.getIsGroupOpenByDefaultFunc = function() {
      return this.gridOptions.isGroupOpenByDefault;
    }, n.prototype.getServerSideGroupKeyFunc = function() {
      return this.gridOptions.getServerSideGroupKey;
    }, n.prototype.getGroupRowAggNodesFunc = function() {
      return this.gridOptions.groupRowAggNodes;
    }, n.prototype.getContextMenuItemsFunc = function() {
      return this.gridOptions.getContextMenuItems;
    }, n.prototype.getMainMenuItemsFunc = function() {
      return this.gridOptions.getMainMenuItems;
    }, n.prototype.getRowIdFunc = function() {
      var t = this.gridOptions, i = t.getRowId, r = t.getRowNodeId;
      if (i)
        return i;
      if (r)
        return function(o) {
          return r(o.data);
        };
    }, n.prototype.getNavigateToNextHeaderFunc = function() {
      return this.gridOptions.navigateToNextHeader;
    }, n.prototype.getTabToNextHeaderFunc = function() {
      return this.gridOptions.tabToNextHeader;
    }, n.prototype.getNavigateToNextCellFunc = function() {
      return this.gridOptions.navigateToNextCell;
    }, n.prototype.getTabToNextCellFunc = function() {
      return this.gridOptions.tabToNextCell;
    }, n.prototype.getGridTabIndex = function() {
      return (this.gridOptions.tabIndex || 0).toString();
    }, n.prototype.isTreeData = function() {
      var t = de(this.gridOptions.treeData);
      return t ? gt.assertRegistered(ht.RowGroupingModule, "Tree Data") : !1;
    }, n.prototype.isValueCache = function() {
      return de(this.gridOptions.valueCache);
    }, n.prototype.isValueCacheNeverExpires = function() {
      return de(this.gridOptions.valueCacheNeverExpires);
    }, n.prototype.isDeltaSort = function() {
      return de(this.gridOptions.deltaSort);
    }, n.prototype.isAggregateOnlyChangedColumns = function() {
      return de(this.gridOptions.aggregateOnlyChangedColumns);
    }, n.prototype.getProcessSecondaryColDefFunc = function() {
      return this.gridOptions.processSecondaryColDef;
    }, n.prototype.getProcessSecondaryColGroupDefFunc = function() {
      return this.gridOptions.processSecondaryColGroupDef;
    }, n.prototype.getSendToClipboardFunc = function() {
      return this.gridOptions.sendToClipboard;
    }, n.prototype.getProcessRowPostCreateFunc = function() {
      return this.gridOptions.processRowPostCreate;
    }, n.prototype.getProcessCellForClipboardFunc = function() {
      return this.gridOptions.processCellForClipboard;
    }, n.prototype.getProcessHeaderForClipboardFunc = function() {
      return this.gridOptions.processHeaderForClipboard;
    }, n.prototype.getProcessGroupHeaderForClipboardFunc = function() {
      return this.gridOptions.processGroupHeaderForClipboard;
    }, n.prototype.getProcessCellFromClipboardFunc = function() {
      return this.gridOptions.processCellFromClipboard;
    }, n.prototype.getViewportRowModelPageSize = function() {
      return XM(this.gridOptions.viewportRowModelPageSize, Zq);
    }, n.prototype.getViewportRowModelBufferSize = function() {
      return eY(this.gridOptions.viewportRowModelBufferSize, Qq);
    }, n.prototype.isServerSideSortingAlwaysResets = function() {
      return de(this.gridOptions.serverSideSortingAlwaysResets);
    }, n.prototype.isServerSideFilteringAlwaysResets = function() {
      return de(this.gridOptions.serverSideFilteringAlwaysResets);
    }, n.prototype.getPostSortFunc = function() {
      return this.gridOptions.postSort;
    }, n.prototype.getChartToolbarItemsFunc = function() {
      return this.gridOptions.getChartToolbarItems;
    }, n.prototype.getChartThemeOverrides = function() {
      return this.gridOptions.chartThemeOverrides;
    }, n.prototype.getCustomChartThemes = function() {
      return this.gridOptions.customChartThemes;
    }, n.prototype.getChartThemes = function() {
      return this.gridOptions.chartThemes || ["ag-default", "ag-material", "ag-pastel", "ag-vivid", "ag-solar"];
    }, n.prototype.getClipboardDelimiter = function() {
      return ge(this.gridOptions.clipboardDelimiter) ? this.gridOptions.clipboardDelimiter : "	";
    }, n.prototype.setProperty = function(t, i, r) {
      r === void 0 && (r = !1);
      var o = this.gridOptions, s = o[t];
      if (r || s !== i) {
        o[t] = i;
        var a = {
          type: t,
          currentValue: i,
          previousValue: s
        };
        this.propertyEventService.dispatchEvent(a);
      }
    }, n.prototype.addEventListener = function(t, i) {
      this.propertyEventService.addEventListener(t, i);
    }, n.prototype.removeEventListener = function(t, i) {
      this.propertyEventService.removeEventListener(t, i);
    }, n.prototype.isSkipHeaderOnAutoSize = function() {
      return !!this.gridOptions.skipHeaderOnAutoSize;
    }, n.prototype.getAutoSizePadding = function() {
      var t = this.gridOptions.autoSizePadding;
      return t != null && t >= 0 ? t : 20;
    }, n.prototype.getHeaderHeight = function() {
      return typeof this.gridOptions.headerHeight == "number" ? this.gridOptions.headerHeight : this.getFromTheme(25, "headerHeight");
    }, n.prototype.getFloatingFiltersHeight = function() {
      return typeof this.gridOptions.floatingFiltersHeight == "number" ? this.gridOptions.floatingFiltersHeight : this.getFromTheme(25, "headerHeight");
    }, n.prototype.getGroupHeaderHeight = function() {
      return typeof this.gridOptions.groupHeaderHeight == "number" ? this.gridOptions.groupHeaderHeight : this.getHeaderHeight();
    }, n.prototype.getPivotHeaderHeight = function() {
      return typeof this.gridOptions.pivotHeaderHeight == "number" ? this.gridOptions.pivotHeaderHeight : this.getHeaderHeight();
    }, n.prototype.getPivotGroupHeaderHeight = function() {
      return typeof this.gridOptions.pivotGroupHeaderHeight == "number" ? this.gridOptions.pivotGroupHeaderHeight : this.getGroupHeaderHeight();
    }, n.prototype.isExternalFilterPresent = function() {
      return typeof this.gridOptions.isExternalFilterPresent == "function" ? this.gridOptions.isExternalFilterPresent() : !1;
    }, n.prototype.doesExternalFilterPass = function(t) {
      return typeof this.gridOptions.doesExternalFilterPass == "function" ? this.gridOptions.doesExternalFilterPass(t) : !1;
    }, n.prototype.getTooltipDelay = function(t) {
      var i = this.gridOptions, r = i.tooltipShowDelay, o = i.tooltipHideDelay, s = t === "show" ? r : o, a = H1(t);
      return ge(s) ? (s < 0 && mi(function() {
        return console.warn("ag-grid: tooltip" + a + "Delay should not be lower than 0");
      }, "tooltip" + a + "DelayWarn"), Math.max(200, s)) : null;
    }, n.prototype.isTooltipMouseTrack = function() {
      return de(this.gridOptions.tooltipMouseTrack);
    }, n.prototype.isSuppressModelUpdateAfterUpdateTransaction = function() {
      return de(this.gridOptions.suppressModelUpdateAfterUpdateTransaction);
    }, n.prototype.getDocument = function() {
      var t = null;
      return this.gridOptions.getDocument && ge(this.gridOptions.getDocument) ? t = this.gridOptions.getDocument() : this.eGridDiv && (t = this.eGridDiv.ownerDocument), t && ge(t) ? t : document;
    }, n.prototype.getMinColWidth = function() {
      var t = this.gridOptions.minColWidth;
      if (ge(t) && t > e.MIN_COL_WIDTH)
        return this.gridOptions.minColWidth;
      var i = this.getFromTheme(null, "headerCellMinWidth");
      return ge(i) ? Math.max(i, e.MIN_COL_WIDTH) : e.MIN_COL_WIDTH;
    }, n.prototype.getMaxColWidth = function() {
      return this.gridOptions.maxColWidth && this.gridOptions.maxColWidth > e.MIN_COL_WIDTH ? this.gridOptions.maxColWidth : null;
    }, n.prototype.getColWidth = function() {
      return typeof this.gridOptions.colWidth != "number" || this.gridOptions.colWidth < e.MIN_COL_WIDTH ? 200 : this.gridOptions.colWidth;
    }, n.prototype.getRowBuffer = function() {
      var t = this.gridOptions.rowBuffer;
      return typeof t == "number" ? t < 0 && (mi(function() {
        return console.warn("AG Grid: rowBuffer should not be negative");
      }, "warn rowBuffer negative"), this.gridOptions.rowBuffer = t = 0) : t = Z.ROW_BUFFER_SIZE, t;
    }, n.prototype.getRowBufferInPixels = function() {
      var t = this.getRowBuffer(), i = this.getRowHeightAsNumber();
      return t * i;
    }, n.prototype.getScrollbarWidth = function() {
      if (this.scrollbarWidth == null) {
        var t = typeof this.gridOptions.scrollbarWidth == "number" && this.gridOptions.scrollbarWidth >= 0, i = t ? this.gridOptions.scrollbarWidth : HB();
        i != null && (this.scrollbarWidth = i, this.eventService.dispatchEvent({
          type: F.EVENT_SCROLLBAR_WIDTH_CHANGED
        }));
      }
      return this.scrollbarWidth;
    }, n.prototype.checkForDeprecated = function() {
      var t = this.gridOptions;
      t.deprecatedEmbedFullWidthRows && console.warn("AG Grid: since v21.2, deprecatedEmbedFullWidthRows has been replaced with embedFullWidthRows."), t.rowDeselection && console.warn("AG Grid: since v24.x, rowDeselection is deprecated and the behaviour is true by default. Please use `suppressRowDeselection` to prevent rows from being deselected."), t.enableMultiRowDragging && (t.rowDragMultiRow = !0, delete t.enableMultiRowDragging, console.warn("AG Grid: since v26.1, `enableMultiRowDragging` is deprecated. Please use `rowDragMultiRow`."));
      var i = function(s, a, l) {
        t[s] != null && (console.warn("ag-grid: since version " + l + ", '" + s + "' is deprecated / renamed, please use the new property name '" + a + "' instead."), t[a] == null && (t[a] = t[s]));
      };
      if (i("batchUpdateWaitMillis", "asyncTransactionWaitMillis", "23.1.x"), i("deltaRowDataMode", "immutableData", "23.1.x"), (t.immutableColumns || t.deltaColumnMode) && console.warn("AG Grid: since v24.0, immutableColumns and deltaColumnMode properties are gone. The grid now works like this as default. To keep column order maintained, set grid property applyColumnDefOrder=true"), i("suppressSetColumnStateEvents", "suppressColumnStateEvents", "24.0.x"), t.groupRowInnerRenderer || t.groupRowInnerRendererParams || t.groupRowInnerRendererFramework) {
        console.warn("AG Grid: since v24.0, grid properties groupRowInnerRenderer, groupRowInnerRendererFramework and groupRowInnerRendererParams are no longer used."), console.warn("  Instead use the grid properties groupRowRendererParams.innerRenderer, groupRowRendererParams.innerRendererFramework and groupRowRendererParams.innerRendererParams."), console.warn("  For example instead of this:"), console.warn('    groupRowInnerRenderer: "myRenderer"'), console.warn("    groupRowInnerRendererParams: {x: a}"), console.warn("  Replace with this:"), console.warn("    groupRowRendererParams: {"), console.warn('      innerRenderer: "myRenderer",'), console.warn("      innerRendererParams: {x: a}"), console.warn("    }"), console.warn("  We have copied the properties over for you. However to stop this error message, please change your application code."), t.groupRowRendererParams || (t.groupRowRendererParams = {});
        var r = t.groupRowRendererParams;
        t.groupRowInnerRenderer && (r.innerRenderer = t.groupRowInnerRenderer), t.groupRowInnerRendererParams && (r.innerRendererParams = t.groupRowInnerRendererParams), t.groupRowInnerRendererFramework && (r.innerRendererFramework = t.groupRowInnerRendererFramework);
      }
      if (t.rememberGroupStateWhenNewData && console.warn("AG Grid: since v24.0, grid property rememberGroupStateWhenNewData is deprecated. This feature was provided before Transaction Updates worked (which keep group state). Now that transaction updates are possible and they keep group state, this feature is no longer needed."), t.detailCellRendererParams && t.detailCellRendererParams.autoHeight && (console.warn("AG Grid: since v24.1, grid property detailCellRendererParams.autoHeight is replaced with grid property detailRowAutoHeight. This allows this feature to work when you provide a custom DetailCellRenderer"), t.detailRowAutoHeight = !0), t.suppressKeyboardEvent && console.warn(`AG Grid: since v24.1 suppressKeyboardEvent in the gridOptions has been deprecated and will be removed in
                 future versions of AG Grid. If you need this to be set for every column use the defaultColDef property.`), t.suppressEnterpriseResetOnNewColumns && console.warn("AG Grid: since v25, grid property suppressEnterpriseResetOnNewColumns is deprecated. This was a temporary property to allow changing columns in Server Side Row Model without triggering a reload. Now that it is possible to dynamically change columns in the grid, this is no longer needed."), t.suppressColumnStateEvents && console.warn('AG Grid: since v25, grid property suppressColumnStateEvents no longer works due to a refactor that we did. It should be possible to achieve similar using event.source, which would be "api" if the event was due to setting column state via the API'), t.defaultExportParams && console.warn("AG Grid: since v25.2, the grid property `defaultExportParams` has been replaced by `defaultCsvExportParams` and `defaultExcelExportParams`."), t.stopEditingWhenGridLosesFocus && (console.warn("AG Grid: since v25.2.2, the grid property `stopEditingWhenGridLosesFocus` has been replaced by `stopEditingWhenCellsLoseFocus`."), t.stopEditingWhenCellsLoseFocus = !0), t.applyColumnDefOrder && console.warn("AG Grid: since v26.0, the grid property `applyColumnDefOrder` is no longer needed, as this is the default behaviour. To turn this behaviour off, set maintainColumnOrder=true"), t.groupMultiAutoColumn && (console.warn("AG Grid: since v26.0, the grid property `groupMultiAutoColumn` has been replaced by `groupDisplayType = 'multipleColumns'`"), t.groupDisplayType = "multipleColumns"), t.groupUseEntireRow && (console.warn("AG Grid: since v26.0, the grid property `groupUseEntireRow` has been replaced by `groupDisplayType = 'groupRows'`"), t.groupDisplayType = "groupRows"), t.groupSuppressAutoColumn) {
        var o = t.treeData ? "treeDataDisplayType" : "groupDisplayType";
        console.warn("AG Grid: since v26.0, the grid property `groupSuppressAutoColumn` has been replaced by `" + o + " = 'custom'`"), t.groupDisplayType = "custom";
      }
      t.defaultGroupSortComparator && (console.warn("AG Grid: since v26.0, the grid property `defaultGroupSortComparator` has been replaced by `defaultGroupOrderComparator`"), t.defaultGroupOrderComparator = t.defaultGroupSortComparator), t.colWidth && console.warn("AG Grid: since v26.1, the grid property `colWidth` is deprecated and should be set via `defaultColDef.width`."), t.minColWidth && console.warn("AG Grid: since v26.1, the grid property `minColWidth` is deprecated and should be set via `defaultColDef.minWidth`."), t.maxColWidth && console.warn("AG Grid: since v26.1, the grid property `maxColWidth` is deprecated and should be set via `defaultColDef.maxWidth`."), t.reactUi && console.warn("AG Grid: since v27.0, React UI is on by default, so no need for reactUi=true. To turn it off, set suppressReactUi=true."), t.suppressReactUi && console.warn("AG Grid: The legacy React rendering engine is deprecated and will be removed in the next major version of the grid."), t.suppressCellSelection && (console.warn("AG Grid: since v27.0, `suppressCellSelection` has been replaced by `suppressCellFocus`."), t.suppressCellFocus = t.suppressCellSelection), t.getRowNodeId && console.warn("AG Grid: since v27.1, `getRowNodeId` is deprecate and has been replaced by `getRowId`. The difference is if getRowId() is implemented, immutable data is on by default."), t.immutableData && console.warn("AG Grid: since v27.1, `immutableData` is deprecated. To turn on, implement `getRowId` has been replaced by `getRowId`. The difference is if getRowId() is implemented, immutable data is on by default."), t.clipboardDeliminator && (console.warn("AG Grid: since v27.1, `clipboardDeliminator` has been replaced by `clipboardDelimiter`."), t.clipboardDelimiter = t.clipboardDeliminator);
    }, n.prototype.checkForViolations = function() {
      this.isTreeData() && this.treeDataViolations();
    }, n.prototype.treeDataViolations = function() {
      this.isRowModelDefault() && Je(this.getDataPathFunc()) && console.warn("AG Grid: property usingTreeData=true with rowModel=clientSide, but you did not provide getDataPath function, please provide getDataPath function if using tree data."), this.isRowModelServerSide() && (Je(this.getIsServerSideGroupFunc()) && console.warn("AG Grid: property usingTreeData=true with rowModel=serverSide, but you did not provide isServerSideGroup function, please provide isServerSideGroup function if using tree data."), Je(this.getServerSideGroupKeyFunc()) && console.warn("AG Grid: property usingTreeData=true with rowModel=serverSide, but you did not provide getServerSideGroupKey function, please provide getServerSideGroupKey function if using tree data."));
    }, n.prototype.getLocaleTextFunc = function() {
      if (this.gridOptions.localeTextFunc)
        return this.gridOptions.localeTextFunc;
      var t = this.gridOptions.localeText;
      return function(i, r) {
        var o = t && t[i];
        return o ?? r;
      };
    }, n.prototype.globalEventHandler = function(t, i) {
      if (!this.destroyed) {
        var r = Xc.getCallbackForEvent(t);
        typeof this.gridOptions[r] == "function" && this.gridOptions[r](i);
      }
    }, n.prototype.setRowHeightVariable = function(t) {
      var i = this.eGridDiv.style.getPropertyValue("--ag-row-height").trim(), r = t + "px";
      i != r && this.eGridDiv.style.setProperty("--ag-row-height", r);
    }, n.prototype.getRowHeightAsNumber = function() {
      if (!this.gridOptions.rowHeight || Je(this.gridOptions.rowHeight))
        return this.getDefaultRowHeight();
      var t = this.gridOptions.rowHeight;
      return t && this.isNumeric(t) ? (this.setRowHeightVariable(t), t) : (console.warn("AG Grid row height must be a number if not using standard row model"), this.getDefaultRowHeight());
    }, n.prototype.isGetRowHeightFunction = function() {
      return typeof this.gridOptions.getRowHeight == "function";
    }, n.prototype.getRowHeightForNode = function(t, i, r) {
      if (i === void 0 && (i = !1), r == null && (r = this.getDefaultRowHeight()), this.isGetRowHeightFunction()) {
        if (i)
          return { height: r, estimated: !0 };
        var o = {
          node: t,
          data: t.data,
          api: this.gridOptions.api,
          context: this.gridOptions.context
        }, s = this.gridOptions.getRowHeight(o);
        if (this.isNumeric(s))
          return s === 0 && mi(function() {
            return console.warn("AG Grid: The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead.");
          }, "invalidRowHeight"), { height: Math.max(1, s), estimated: !1 };
      }
      if (t.detail && this.isMasterDetail())
        return this.isDetailRowAutoHeight() ? { height: 1, estimated: !1 } : this.isNumeric(this.gridOptions.detailRowHeight) ? { height: this.gridOptions.detailRowHeight, estimated: !1 } : { height: Xq, estimated: !1 };
      var a = this.gridOptions.rowHeight && this.isNumeric(this.gridOptions.rowHeight) ? this.gridOptions.rowHeight : r;
      return { height: a, estimated: !1 };
    }, n.prototype.isDynamicRowHeight = function() {
      return typeof this.gridOptions.getRowHeight == "function";
    }, n.prototype.getListItemHeight = function() {
      return this.getFromTheme(20, "listItemHeight");
    }, n.prototype.chartMenuPanelWidth = function() {
      return this.environment.chartMenuPanelWidth();
    }, n.prototype.isNumeric = function(t) {
      return !isNaN(t) && typeof t == "number" && isFinite(t);
    }, n.prototype.getFromTheme = function(t, i) {
      var r = this.environment.getTheme().theme;
      return r && r.indexOf("ag-theme") === 0 ? this.environment.getSassVariable(r, i) : t;
    }, n.prototype.getDefaultRowHeight = function() {
      return this.getFromTheme(Yq, "rowHeight");
    }, n.prototype.matchesGroupDisplayType = function(t, i) {
      var r = ["groupRows", "multipleColumns", "custom", "singleColumn"];
      return r.indexOf(i) < 0 ? (console.warn("AG Grid: '" + i + "' is not a valid groupDisplayType value - possible values are: '" + r.join("', '") + "'"), !1) : i === t;
    }, n.prototype.matchesTreeDataDisplayType = function(t, i) {
      var r = ["auto", "custom"];
      return r.indexOf(i) < 0 ? (console.warn("AG Grid: '" + i + "' is not a valid treeDataDisplayType value - possible values are: '" + r.join("', '") + "'"), !1) : i === t;
    };
    var e;
    return n.MIN_COL_WIDTH = 10, n.PROP_HEADER_HEIGHT = "headerHeight", n.PROP_GROUP_REMOVE_SINGLE_CHILDREN = "groupRemoveSingleChildren", n.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN = "groupRemoveLowestSingleChildren", n.PROP_PIVOT_HEADER_HEIGHT = "pivotHeaderHeight", n.PROP_SUPPRESS_CLIPBOARD_PASTE = "suppressClipboardPaste", n.PROP_GROUP_HEADER_HEIGHT = "groupHeaderHeight", n.PROP_PIVOT_GROUP_HEADER_HEIGHT = "pivotGroupHeaderHeight", n.PROP_NAVIGATE_TO_NEXT_CELL = "navigateToNextCell", n.PROP_TAB_TO_NEXT_CELL = "tabToNextCell", n.PROP_NAVIGATE_TO_NEXT_HEADER = "navigateToNextHeader", n.PROP_TAB_TO_NEXT_HEADER = "tabToNextHeader", n.PROP_IS_EXTERNAL_FILTER_PRESENT = "isExternalFilterPresent", n.PROP_DOES_EXTERNAL_FILTER_PASS = "doesExternalFilterPass", n.PROP_FLOATING_FILTERS_HEIGHT = "floatingFiltersHeight", n.PROP_SUPPRESS_ROW_CLICK_SELECTION = "suppressRowClickSelection", n.PROP_SUPPRESS_ROW_DRAG = "suppressRowDrag", n.PROP_SUPPRESS_MOVE_WHEN_ROW_DRAG = "suppressMoveWhenRowDragging", n.PROP_GET_ROW_CLASS = "getRowClass", n.PROP_GET_ROW_STYLE = "getRowStyle", n.PROP_GET_ROW_HEIGHT = "getRowHeight", n.PROP_POPUP_PARENT = "popupParent", n.PROP_DOM_LAYOUT = "domLayout", n.PROP_FILL_HANDLE_DIRECTION = "fillHandleDirection", n.PROP_GROUP_ROW_AGG_NODES = "groupRowAggNodes", n.PROP_GET_BUSINESS_KEY_FOR_NODE = "getBusinessKeyForNode", n.PROP_GET_CHILD_COUNT = "getChildCount", n.PROP_PROCESS_ROW_POST_CREATE = "processRowPostCreate", n.PROP_GET_ROW_NODE_ID = "getRowNodeId", n.PROP_IS_FULL_WIDTH_CELL = "isFullWidthCell", n.PROP_IS_ROW_SELECTABLE = "isRowSelectable", n.PROP_IS_ROW_MASTER = "isRowMaster", n.PROP_POST_SORT = "postSort", n.PROP_GET_DOCUMENT = "getDocument", n.PROP_POST_PROCESS_POPUP = "postProcessPopup", n.PROP_DEFAULT_GROUP_ORDER_COMPARATOR = "defaultGroupOrderComparator", n.PROP_PAGINATION_NUMBER_FORMATTER = "paginationNumberFormatter", n.PROP_GET_CONTEXT_MENU_ITEMS = "getContextMenuItems", n.PROP_GET_MAIN_MENU_ITEMS = "getMainMenuItems", n.PROP_PROCESS_CELL_FOR_CLIPBOARD = "processCellForClipboard", n.PROP_PROCESS_CELL_FROM_CLIPBOARD = "processCellFromClipboard", n.PROP_SEND_TO_CLIPBOARD = "sendToClipboard", n.PROP_PROCESS_TO_SECONDARY_COLDEF = "processSecondaryColDef", n.PROP_PROCESS_SECONDARY_COL_GROUP_DEF = "processSecondaryColGroupDef", n.PROP_GET_CHART_TOOLBAR_ITEMS = "getChartToolbarItems", n.PROP_GET_SERVER_SIDE_STORE_PARAMS = "getServerSideStoreParams", n.PROP_IS_SERVER_SIDE_GROUPS_OPEN_BY_DEFAULT = "isServerSideGroupOpenByDefault", n.PROP_IS_APPLY_SERVER_SIDE_TRANSACTION = "isApplyServerSideTransaction", n.PROP_IS_SERVER_SIDE_GROUP = "isServerSideGroup", n.PROP_GET_SERVER_SIDE_GROUP_KEY = "getServerSideGroupKey", wc([
      T("gridOptions")
    ], n.prototype, "gridOptions", void 0), wc([
      T("eventService")
    ], n.prototype, "eventService", void 0), wc([
      T("environment")
    ], n.prototype, "environment", void 0), wc([
      T("eGridDiv")
    ], n.prototype, "eGridDiv", void 0), wc([
      YM(0, Eo("gridApi")),
      YM(1, Eo("columnApi"))
    ], n.prototype, "agWire", null), wc([
      To
    ], n.prototype, "destroy", null), wc([
      Le
    ], n.prototype, "init", null), n = e = wc([
      qe("gridOptionsWrapper")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Bx = (
  /** @class */
  function() {
    function n(e, t) {
      this.active = !0, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = {
        rowNode: t,
        children: null
      }, this.mapToItems[t.id] = this.pathRoot;
    }
    return n.prototype.setInactive = function() {
      this.active = !1;
    }, n.prototype.isActive = function() {
      return this.active;
    }, n.prototype.depthFirstSearchChangedPath = function(e, t) {
      if (e.children)
        for (var i = 0; i < e.children.length; i++)
          this.depthFirstSearchChangedPath(e.children[i], t);
      t(e.rowNode);
    }, n.prototype.depthFirstSearchEverything = function(e, t, i) {
      if (e.childrenAfterGroup)
        for (var r = 0; r < e.childrenAfterGroup.length; r++) {
          var o = e.childrenAfterGroup[r];
          o.childrenAfterGroup ? this.depthFirstSearchEverything(e.childrenAfterGroup[r], t, i) : i && t(o);
        }
      t(e);
    }, n.prototype.forEachChangedNodeDepthFirst = function(e, t) {
      t === void 0 && (t = !1), this.active ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t);
    }, n.prototype.executeFromRootNode = function(e) {
      e(this.pathRoot.rowNode);
    }, n.prototype.createPathItems = function(e) {
      for (var t = e, i = 0; !this.mapToItems[t.id]; ) {
        var r = {
          rowNode: t,
          children: null
        };
        this.mapToItems[t.id] = r, i++, t = t.parent;
      }
      return i;
    }, n.prototype.populateColumnsMap = function(e, t) {
      var i = this;
      if (!(!this.keepingColumns || !t))
        for (var r = e; r; )
          this.nodeIdsToColumns[r.id] || (this.nodeIdsToColumns[r.id] = {}), t.forEach(function(o) {
            return i.nodeIdsToColumns[r.id][o.getId()] = !0;
          }), r = r.parent;
    }, n.prototype.linkPathItems = function(e, t) {
      for (var i = e, r = 0; r < t; r++) {
        var o = this.mapToItems[i.id], s = this.mapToItems[i.parent.id];
        s.children || (s.children = []), s.children.push(o), i = i.parent;
      }
    }, n.prototype.addParentNode = function(e, t) {
      if (!(!e || e.isRowPinned())) {
        var i = this.createPathItems(e);
        this.linkPathItems(e, i), this.populateColumnsMap(e, t);
      }
    }, n.prototype.canSkip = function(e) {
      return this.active && !this.mapToItems[e.id];
    }, n.prototype.getValueColumnsForNode = function(e, t) {
      if (!this.keepingColumns)
        return t;
      var i = this.nodeIdsToColumns[e.id], r = t.filter(function(o) {
        return i[o.getId()];
      });
      return r;
    }, n.prototype.getNotValueColumnsForNode = function(e, t) {
      if (!this.keepingColumns)
        return null;
      var i = this.nodeIdsToColumns[e.id], r = t.filter(function(o) {
        return !i[o.getId()];
      });
      return r;
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var tY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Ef = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, iY = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, VH = (
  /** @class */
  function(n) {
    tY(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setBeans = function(t) {
      this.logger = t.create("selectionService"), this.reset(), this.gridOptionsWrapper.isRowModelDefault() && this.addManagedListener(this.eventService, F.EVENT_ROW_DATA_CHANGED, this.reset.bind(this));
    }, e.prototype.init = function() {
      this.groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren(), this.addManagedListener(this.eventService, F.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));
    }, e.prototype.setLastSelectedNode = function(t) {
      this.lastSelectedNode = t;
    }, e.prototype.getLastSelectedNode = function() {
      return this.lastSelectedNode;
    }, e.prototype.getSelectedNodes = function() {
      var t = [];
      return pi(this.selectedNodes, function(i, r) {
        r && t.push(r);
      }), t;
    }, e.prototype.getSelectedRows = function() {
      var t = [];
      return pi(this.selectedNodes, function(i, r) {
        r && r.data && t.push(r.data);
      }), t;
    }, e.prototype.removeGroupsFromSelection = function() {
      var t = this;
      pi(this.selectedNodes, function(i, r) {
        r && r.group && (t.selectedNodes[r.id] = void 0);
      });
    }, e.prototype.updateGroupsFromChildrenSelections = function(t) {
      if (this.gridOptionsWrapper.isGroupSelectsChildren() && this.rowModel.getType() === Z.ROW_MODEL_TYPE_CLIENT_SIDE) {
        var i = this.rowModel, r = i.getRootNode();
        t || (t = new Bx(!0, r), t.setInactive()), t.forEachChangedNodeDepthFirst(function(o) {
          o !== r && o.calculateSelectedFromChildren();
        });
      }
    }, e.prototype.getNodeForIdIfSelected = function(t) {
      return this.selectedNodes[t];
    }, e.prototype.clearOtherNodes = function(t) {
      var i = this, r = {}, o = 0;
      return pi(this.selectedNodes, function(s, a) {
        if (a && a.id !== t.id) {
          var l = i.selectedNodes[a.id];
          o += l.setSelectedParams({
            newValue: !1,
            clearSelection: !1,
            suppressFinishActions: !0
          }), i.groupSelectsChildren && a.parent && (r[a.parent.id] = a.parent);
        }
      }), pi(r, function(s, a) {
        a.calculateSelectedFromChildren();
      }), o;
    }, e.prototype.onRowSelected = function(t) {
      var i = t.node;
      this.groupSelectsChildren && i.group || (i.isSelected() ? this.selectedNodes[i.id] = i : this.selectedNodes[i.id] = void 0);
    }, e.prototype.syncInRowNode = function(t, i) {
      this.syncInOldRowNode(t, i), this.syncInNewRowNode(t);
    }, e.prototype.syncInOldRowNode = function(t, i) {
      var r = ge(i) && t.id !== i.id;
      if (r && i) {
        var o = i.id, s = this.selectedNodes[o] == t;
        s && (this.selectedNodes[i.id] = i);
      }
    }, e.prototype.syncInNewRowNode = function(t) {
      ge(this.selectedNodes[t.id]) ? (t.setSelectedInitialValue(!0), this.selectedNodes[t.id] = t) : t.setSelectedInitialValue(!1);
    }, e.prototype.reset = function() {
      this.logger.log("reset"), this.selectedNodes = {}, this.lastSelectedNode = null;
    }, e.prototype.getBestCostNodeSelection = function() {
      if (this.rowModel.getType() !== Z.ROW_MODEL_TYPE_CLIENT_SIDE) {
        console.warn("AG Grid: `getBestCostNodeSelection` is only available when using normal row model");
        return;
      }
      var t = this.rowModel, i = t.getTopLevelNodes();
      if (i === null) {
        console.warn("AG Grid: `selectAll` not available doing `rowModel=virtual`");
        return;
      }
      var r = [];
      function o(s) {
        for (var a = 0, l = s.length; a < l; a++) {
          var u = s[a];
          if (u.isSelected())
            r.push(u);
          else {
            var c = u;
            c.group && c.children && o(c.children);
          }
        }
      }
      return o(i), r;
    }, e.prototype.setRowModel = function(t) {
      this.rowModel = t;
    }, e.prototype.isEmpty = function() {
      var t = 0;
      return pi(this.selectedNodes, function(i, r) {
        r && t++;
      }), t === 0;
    }, e.prototype.deselectAllRowNodes = function(t) {
      t === void 0 && (t = !1);
      var i = function(a) {
        return a.selectThisNode(!1);
      }, r = this.rowModel.getType() === Z.ROW_MODEL_TYPE_CLIENT_SIDE;
      if (t) {
        if (!r) {
          console.error("AG Grid: selecting just filtered only works with In Memory Row Model");
          return;
        }
        var o = this.rowModel;
        o.forEachNodeAfterFilter(i);
      } else
        pi(this.selectedNodes, function(a, l) {
          l && i(l);
        }), this.reset();
      r && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections();
      var s = {
        type: F.EVENT_SELECTION_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(s);
    }, e.prototype.selectAllRowNodes = function(t) {
      if (t === void 0 && (t = !1), this.rowModel.getType() !== Z.ROW_MODEL_TYPE_CLIENT_SIDE)
        throw new Error("selectAll only available with normal row model, ie not " + this.rowModel.getType());
      var i = this.rowModel, r = function(s) {
        return s.selectThisNode(!0);
      };
      t ? i.forEachNodeAfterFilter(r) : i.forEachNode(r), this.rowModel.getType() === Z.ROW_MODEL_TYPE_CLIENT_SIDE && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections();
      var o = {
        type: F.EVENT_SELECTION_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(o);
    }, e.prototype.selectNode = function(t, i) {
      t && t.setSelectedParams({ newValue: !0, clearSelection: !i });
    }, e.prototype.deselectIndex = function(t) {
      var i = this.rowModel.getRow(t);
      this.deselectNode(i);
    }, e.prototype.deselectNode = function(t) {
      t && t.setSelectedParams({ newValue: !1, clearSelection: !1 });
    }, e.prototype.selectIndex = function(t, i) {
      var r = this.rowModel.getRow(t);
      this.selectNode(r, i);
    }, Ef([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), Ef([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), Ef([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Ef([
      iY(0, Eo("loggerFactory"))
    ], e.prototype, "setBeans", null), Ef([
      Le
    ], e.prototype, "init", null), e = Ef([
      qe("selectionService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var LL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, BH = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.sizeColumnsToFit = function(e) {
      typeof e > "u" && console.error("AG Grid: missing parameter to columnApi.sizeColumnsToFit(gridWidth)"), this.columnModel.sizeColumnsToFit(e, "api");
    }, n.prototype.setColumnGroupOpened = function(e, t) {
      this.columnModel.setColumnGroupOpened(e, t, "api");
    }, n.prototype.getColumnGroup = function(e, t) {
      return this.columnModel.getColumnGroup(e, t);
    }, n.prototype.getProvidedColumnGroup = function(e) {
      return this.columnModel.getProvidedColumnGroup(e);
    }, n.prototype.getDisplayNameForColumn = function(e, t) {
      return this.columnModel.getDisplayNameForColumn(e, t) || "";
    }, n.prototype.getDisplayNameForColumnGroup = function(e, t) {
      return this.columnModel.getDisplayNameForColumnGroup(e, t) || "";
    }, n.prototype.getColumn = function(e) {
      return this.columnModel.getPrimaryColumn(e);
    }, n.prototype.applyColumnState = function(e) {
      return this.columnModel.applyColumnState(e, "api");
    }, n.prototype.getColumnState = function() {
      return this.columnModel.getColumnState();
    }, n.prototype.resetColumnState = function() {
      this.columnModel.resetColumnState("api");
    }, n.prototype.getColumnGroupState = function() {
      return this.columnModel.getColumnGroupState();
    }, n.prototype.setColumnGroupState = function(e) {
      this.columnModel.setColumnGroupState(e, "api");
    }, n.prototype.resetColumnGroupState = function() {
      this.columnModel.resetColumnGroupState("api");
    }, n.prototype.isPinning = function() {
      return this.columnModel.isPinningLeft() || this.columnModel.isPinningRight();
    }, n.prototype.isPinningLeft = function() {
      return this.columnModel.isPinningLeft();
    }, n.prototype.isPinningRight = function() {
      return this.columnModel.isPinningRight();
    }, n.prototype.getDisplayedColAfter = function(e) {
      return this.columnModel.getDisplayedColAfter(e);
    }, n.prototype.getDisplayedColBefore = function(e) {
      return this.columnModel.getDisplayedColBefore(e);
    }, n.prototype.setColumnVisible = function(e, t) {
      this.columnModel.setColumnVisible(e, t, "api");
    }, n.prototype.setColumnsVisible = function(e, t) {
      this.columnModel.setColumnsVisible(e, t, "api");
    }, n.prototype.setColumnPinned = function(e, t) {
      this.columnModel.setColumnPinned(e, t, "api");
    }, n.prototype.setColumnsPinned = function(e, t) {
      this.columnModel.setColumnsPinned(e, t, "api");
    }, n.prototype.getAllColumns = function() {
      return this.columnModel.getAllPrimaryColumns();
    }, n.prototype.getAllGridColumns = function() {
      return this.columnModel.getAllGridColumns();
    }, n.prototype.getDisplayedLeftColumns = function() {
      return this.columnModel.getDisplayedLeftColumns();
    }, n.prototype.getDisplayedCenterColumns = function() {
      return this.columnModel.getDisplayedCenterColumns();
    }, n.prototype.getDisplayedRightColumns = function() {
      return this.columnModel.getDisplayedRightColumns();
    }, n.prototype.getAllDisplayedColumns = function() {
      return this.columnModel.getAllDisplayedColumns();
    }, n.prototype.getAllDisplayedVirtualColumns = function() {
      return this.columnModel.getViewportColumns();
    }, n.prototype.moveColumn = function(e, t) {
      typeof e == "number" ? (console.warn("AG Grid: you are using moveColumn(fromIndex, toIndex) - moveColumn takes a column key and a destination index, not two indexes, to move with indexes use moveColumnByIndex(from,to) instead"), this.columnModel.moveColumnByIndex(e, t, "api")) : this.columnModel.moveColumn(e, t, "api");
    }, n.prototype.moveColumnByIndex = function(e, t) {
      this.columnModel.moveColumnByIndex(e, t, "api");
    }, n.prototype.moveColumns = function(e, t) {
      this.columnModel.moveColumns(e, t, "api");
    }, n.prototype.moveRowGroupColumn = function(e, t) {
      this.columnModel.moveRowGroupColumn(e, t);
    }, n.prototype.setColumnAggFunc = function(e, t) {
      this.columnModel.setColumnAggFunc(e, t);
    }, n.prototype.setColumnWidth = function(e, t, i, r) {
      i === void 0 && (i = !0), this.columnModel.setColumnWidths([{ key: e, newWidth: t }], !1, i, r);
    }, n.prototype.setColumnWidths = function(e, t, i) {
      t === void 0 && (t = !0), this.columnModel.setColumnWidths(e, !1, t, i);
    }, n.prototype.setPivotMode = function(e) {
      this.columnModel.setPivotMode(e);
    }, n.prototype.isPivotMode = function() {
      return this.columnModel.isPivotMode();
    }, n.prototype.getSecondaryPivotColumn = function(e, t) {
      return this.columnModel.getSecondaryPivotColumn(e, t);
    }, n.prototype.setValueColumns = function(e) {
      this.columnModel.setValueColumns(e, "api");
    }, n.prototype.getValueColumns = function() {
      return this.columnModel.getValueColumns();
    }, n.prototype.removeValueColumn = function(e) {
      this.columnModel.removeValueColumn(e, "api");
    }, n.prototype.removeValueColumns = function(e) {
      this.columnModel.removeValueColumns(e, "api");
    }, n.prototype.addValueColumn = function(e) {
      this.columnModel.addValueColumn(e, "api");
    }, n.prototype.addValueColumns = function(e) {
      this.columnModel.addValueColumns(e, "api");
    }, n.prototype.setRowGroupColumns = function(e) {
      this.columnModel.setRowGroupColumns(e, "api");
    }, n.prototype.removeRowGroupColumn = function(e) {
      this.columnModel.removeRowGroupColumn(e, "api");
    }, n.prototype.removeRowGroupColumns = function(e) {
      this.columnModel.removeRowGroupColumns(e, "api");
    }, n.prototype.addRowGroupColumn = function(e) {
      this.columnModel.addRowGroupColumn(e, "api");
    }, n.prototype.addRowGroupColumns = function(e) {
      this.columnModel.addRowGroupColumns(e, "api");
    }, n.prototype.getRowGroupColumns = function() {
      return this.columnModel.getRowGroupColumns();
    }, n.prototype.setPivotColumns = function(e) {
      this.columnModel.setPivotColumns(e, "api");
    }, n.prototype.removePivotColumn = function(e) {
      this.columnModel.removePivotColumn(e, "api");
    }, n.prototype.removePivotColumns = function(e) {
      this.columnModel.removePivotColumns(e, "api");
    }, n.prototype.addPivotColumn = function(e) {
      this.columnModel.addPivotColumn(e, "api");
    }, n.prototype.addPivotColumns = function(e) {
      this.columnModel.addPivotColumns(e, "api");
    }, n.prototype.getPivotColumns = function() {
      return this.columnModel.getPivotColumns();
    }, n.prototype.getLeftDisplayedColumnGroups = function() {
      return this.columnModel.getDisplayedTreeLeft();
    }, n.prototype.getCenterDisplayedColumnGroups = function() {
      return this.columnModel.getDisplayedTreeCentre();
    }, n.prototype.getRightDisplayedColumnGroups = function() {
      return this.columnModel.getDisplayedTreeRight();
    }, n.prototype.getAllDisplayedColumnGroups = function() {
      return this.columnModel.getAllDisplayedTrees();
    }, n.prototype.autoSizeColumn = function(e, t) {
      return this.columnModel.autoSizeColumn(e, t, "api");
    }, n.prototype.autoSizeColumns = function(e, t) {
      this.columnModel.autoSizeColumns({ columns: e, skipHeader: t });
    }, n.prototype.autoSizeAllColumns = function(e) {
      this.columnModel.autoSizeAllColumns(e, "api");
    }, n.prototype.setSecondaryColumns = function(e) {
      this.columnModel.setSecondaryColumns(e, "api");
    }, n.prototype.getSecondaryColumns = function() {
      return this.columnModel.getSecondaryColumns();
    }, n.prototype.getPrimaryColumns = function() {
      return this.columnModel.getAllPrimaryColumns();
    }, n.prototype.cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid = function() {
      setTimeout(Ad.removeAllReferences.bind(window, this, "Column API"), 100);
    }, n.prototype.columnGroupOpened = function(e, t) {
      console.error("AG Grid: columnGroupOpened no longer exists, use setColumnGroupOpened"), this.setColumnGroupOpened(e, t);
    }, n.prototype.hideColumns = function(e, t) {
      console.error("AG Grid: hideColumns is deprecated, use setColumnsVisible"), this.columnModel.setColumnsVisible(e, !t, "api");
    }, n.prototype.hideColumn = function(e, t) {
      console.error("AG Grid: hideColumn is deprecated, use setColumnVisible"), this.columnModel.setColumnVisible(e, !t, "api");
    }, n.prototype.setState = function(e) {
      return console.error("AG Grid: setState is deprecated, use setColumnState"), this.setColumnState(e);
    }, n.prototype.getState = function() {
      return console.error("AG Grid: getState is deprecated, use getColumnState"), this.getColumnState();
    }, n.prototype.resetState = function() {
      console.error("AG Grid: resetState is deprecated, use resetColumnState"), this.resetColumnState();
    }, n.prototype.getAggregationColumns = function() {
      return console.error("AG Grid: getAggregationColumns is deprecated, use getValueColumns"), this.columnModel.getValueColumns();
    }, n.prototype.removeAggregationColumn = function(e) {
      console.error("AG Grid: removeAggregationColumn is deprecated, use removeValueColumn"), this.columnModel.removeValueColumn(e, "api");
    }, n.prototype.removeAggregationColumns = function(e) {
      console.error("AG Grid: removeAggregationColumns is deprecated, use removeValueColumns"), this.columnModel.removeValueColumns(e, "api");
    }, n.prototype.addAggregationColumn = function(e) {
      console.error("AG Grid: addAggregationColumn is deprecated, use addValueColumn"), this.columnModel.addValueColumn(e, "api");
    }, n.prototype.addAggregationColumns = function(e) {
      console.error("AG Grid: addAggregationColumns is deprecated, use addValueColumns"), this.columnModel.addValueColumns(e, "api");
    }, n.prototype.setColumnAggFunction = function(e, t) {
      console.error("AG Grid: setColumnAggFunction is deprecated, use setColumnAggFunc"), this.columnModel.setColumnAggFunc(e, t, "api");
    }, n.prototype.getDisplayNameForCol = function(e) {
      return console.error("AG Grid: getDisplayNameForCol is deprecated, use getDisplayNameForColumn"), this.getDisplayNameForColumn(e, null);
    }, n.prototype.setColumnState = function(e) {
      return console.error("AG Grid: setColumnState is deprecated, use applyColumnState"), this.columnModel.applyColumnState({ state: e, applyOrder: !0 }, "api");
    }, n.prototype.getOriginalColumnGroup = function(e) {
      return console.error("AG Grid: getOriginalColumnGroup is deprecated, use getProvidedColumnGroup"), this.columnModel.getProvidedColumnGroup(e);
    }, LL([
      T("columnModel")
    ], n.prototype, "columnModel", void 0), LL([
      To
    ], n.prototype, "cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid", null), n = LL([
      qe("columnApi")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var jv;
(function(n) {
  n[n.FILL = 0] = "FILL", n[n.RANGE = 1] = "RANGE";
})(jv || (jv = {}));
var sd;
(function(n) {
  n[n.VALUE = 0] = "VALUE", n[n.DIMENSION = 1] = "DIMENSION";
})(sd || (sd = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var pm = "ag-cell-range-selected", nY = "ag-cell-range-chart", rY = "ag-cell-range-single-cell", oY = "ag-cell-range-chart-category", sY = "ag-cell-range-handle", aY = "ag-cell-range-top", lY = "ag-cell-range-right", uY = "ag-cell-range-bottom", cY = "ag-cell-range-left", hY = (
  /** @class */
  function() {
    function n(e, t) {
      this.beans = e, this.cellCtrl = t;
    }
    return n.prototype.setComp = function(e, t) {
      this.cellComp = e, this.eGui = t, this.onRangeSelectionChanged();
    }, n.prototype.onRangeSelectionChanged = function() {
      this.cellComp && (this.rangeCount = this.beans.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()), this.hasChartRange = this.getHasChartRange(), this.cellComp.addOrRemoveCssClass(pm, this.rangeCount !== 0), this.cellComp.addOrRemoveCssClass(pm + "-1", this.rangeCount === 1), this.cellComp.addOrRemoveCssClass(pm + "-2", this.rangeCount === 2), this.cellComp.addOrRemoveCssClass(pm + "-3", this.rangeCount === 3), this.cellComp.addOrRemoveCssClass(pm + "-4", this.rangeCount >= 4), this.cellComp.addOrRemoveCssClass(nY, this.hasChartRange), $p(this.eGui, this.rangeCount > 0 ? !0 : void 0), this.cellComp.addOrRemoveCssClass(rY, this.isSingleCell()), this.updateRangeBorders(), this.refreshHandle());
    }, n.prototype.updateRangeBorders = function() {
      var e = this.getRangeBorders(), t = this.isSingleCell(), i = !t && e.top, r = !t && e.right, o = !t && e.bottom, s = !t && e.left;
      this.cellComp.addOrRemoveCssClass(aY, i), this.cellComp.addOrRemoveCssClass(lY, r), this.cellComp.addOrRemoveCssClass(uY, o), this.cellComp.addOrRemoveCssClass(cY, s);
    }, n.prototype.isSingleCell = function() {
      var e = this.beans.rangeService;
      return this.rangeCount === 1 && e && !e.isMoreThanOneCell();
    }, n.prototype.getHasChartRange = function() {
      var e = this.beans.rangeService;
      if (!this.rangeCount || !e)
        return !1;
      var t = e.getCellRanges();
      return t.length > 0 && t.every(function(i) {
        return Es([sd.DIMENSION, sd.VALUE], i.type);
      });
    }, n.prototype.updateRangeBordersIfRangeCount = function() {
      this.rangeCount > 0 && (this.updateRangeBorders(), this.refreshHandle());
    }, n.prototype.getRangeBorders = function() {
      var e = this, t = this.beans.gridOptionsWrapper.isEnableRtl(), i = !1, r = !1, o = !1, s = !1, a = this.cellCtrl.getCellPosition().column, l = this.beans, u = l.rangeService, c = l.columnModel, h, d;
      t ? (h = c.getDisplayedColAfter(a), d = c.getDisplayedColBefore(a)) : (h = c.getDisplayedColBefore(a), d = c.getDisplayedColAfter(a));
      var f = u.getCellRanges().filter(function(v) {
        return u.isCellInSpecificRange(e.cellCtrl.getCellPosition(), v);
      });
      h || (s = !0), d || (r = !0);
      for (var p = 0; p < f.length && !(i && r && o && s); p++) {
        var g = f[p], _ = u.getRangeStartRow(g), m = u.getRangeEndRow(g);
        !i && this.beans.rowPositionUtils.sameRow(_, this.cellCtrl.getCellPosition()) && (i = !0), !o && this.beans.rowPositionUtils.sameRow(m, this.cellCtrl.getCellPosition()) && (o = !0), !s && h && g.columns.indexOf(h) < 0 && (s = !0), !r && d && g.columns.indexOf(d) < 0 && (r = !0);
      }
      return { top: i, right: r, bottom: o, left: s };
    }, n.prototype.refreshHandle = function() {
      if (this.beans.rangeService) {
        var e = this.shouldHaveSelectionHandle();
        this.selectionHandle && !e && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), e && this.addSelectionHandle(), this.cellComp.addOrRemoveCssClass(sY, !!this.selectionHandle);
      }
    }, n.prototype.shouldHaveSelectionHandle = function() {
      var e = this.beans, t = e.gridOptionsWrapper, i = e.rangeService, r = i.getCellRanges(), o = r.length;
      if (this.rangeCount < 1 || o < 1)
        return !1;
      var s = Ti(r), a = this.cellCtrl.getCellPosition(), l = t.isEnableFillHandle() && !this.cellCtrl.isSuppressFillHandle(), u = t.isEnableRangeHandle(), c = o === 1 && !this.cellCtrl.isEditing() && (l || u);
      if (this.hasChartRange) {
        var h = r[0].type === sd.DIMENSION, d = h && i.isCellInSpecificRange(a, r[0]);
        this.cellComp.addOrRemoveCssClass(oY, d), c = s.type === sd.VALUE;
      }
      return c && s.endRow != null && i.isContiguousRange(s) && i.isBottomRightCell(s, a);
    }, n.prototype.addSelectionHandle = function() {
      var e = this.beans, t = e.gridOptionsWrapper, i = e.rangeService, r = Ti(i.getCellRanges()).type, o = t.isEnableFillHandle() && Je(r), s = o ? jv.FILL : jv.RANGE;
      this.selectionHandle && this.selectionHandle.getType() !== s && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), this.selectionHandle || (this.selectionHandle = this.beans.selectionHandleFactory.createSelectionHandle(s)), this.selectionHandle.refresh(this.cellCtrl);
    }, n.prototype.destroy = function() {
      this.beans.context.destroyBean(this.selectionHandle);
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var dY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), fY = (
  /** @class */
  function(n) {
    dY(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.cellCtrl = t, r.beans = i, r.column = t.getColumn(), r.rowNode = t.getRowNode(), r.setupColSpan(), r.setupRowSpan(), r;
    }
    return e.prototype.setupRowSpan = function() {
      this.rowSpan = this.column.getRowSpan(this.rowNode);
    }, e.prototype.setComp = function(t) {
      this.eGui = t, this.onLeftChanged(), this.onWidthChanged(), this.applyRowSpan();
    }, e.prototype.onDisplayColumnsChanged = function() {
      var t = this.getColSpanningList();
      Cd(this.colsSpanning, t) || (this.colsSpanning = t, this.onWidthChanged(), this.onLeftChanged());
    }, e.prototype.setupColSpan = function() {
      this.column.getColDef().colSpan != null && (this.colsSpanning = this.getColSpanningList(), this.addManagedListener(this.beans.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this)), this.addManagedListener(this.beans.eventService, F.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this)));
    }, e.prototype.onWidthChanged = function() {
      if (this.eGui) {
        var t = this.getCellWidth();
        this.eGui.style.width = t + "px";
      }
    }, e.prototype.getCellWidth = function() {
      return this.colsSpanning ? this.colsSpanning.reduce(function(t, i) {
        return t + i.getActualWidth();
      }, 0) : this.column.getActualWidth();
    }, e.prototype.getColSpanningList = function() {
      var t = this.column.getColSpan(this.rowNode), i = [];
      if (t === 1)
        i.push(this.column);
      else
        for (var r = this.column, o = this.column.getPinned(), s = 0; r && s < t && (i.push(r), r = this.beans.columnModel.getDisplayedColAfter(r), !(!r || Je(r) || o !== r.getPinned())); s++)
          ;
      return i;
    }, e.prototype.onLeftChanged = function() {
      if (this.eGui) {
        var t = this.modifyLeftForPrintLayout(this.getCellLeft());
        this.eGui.style.left = t + "px";
      }
    }, e.prototype.getCellLeft = function() {
      var t;
      return this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning ? t = Ti(this.colsSpanning) : t = this.column, t.getLeft();
    }, e.prototype.modifyLeftForPrintLayout = function(t) {
      if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === Z.PINNED_LEFT)
        return t;
      var i = this.beans.columnModel.getDisplayedColumnsLeftWidth();
      if (this.column.getPinned() === Z.PINNED_RIGHT) {
        var r = this.beans.columnModel.getBodyContainerWidth();
        return i + r + (t || 0);
      }
      return i + (t || 0);
    }, e.prototype.applyRowSpan = function() {
      if (this.rowSpan !== 1) {
        var t = this.beans.gridOptionsWrapper.getRowHeightAsNumber(), i = t * this.rowSpan;
        this.eGui.style.height = i + "px", this.eGui.style.zIndex = "1";
      }
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var pY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), gY = (
  /** @class */
  function(n) {
    pY(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.staticClasses = [], r.cellCtrl = t, r.beans = i, r.column = t.getColumn(), r.rowNode = t.getRowNode(), r;
    }
    return e.prototype.setComp = function(t, i) {
      this.cellComp = t, this.scope = i, this.applyUserStyles(), this.applyCellClassRules(), this.applyClassesFromColDef();
    }, e.prototype.applyCellClassRules = function() {
      var t = this, i = this.column.getColDef(), r = {
        value: this.cellCtrl.getValue(),
        data: this.rowNode.data,
        node: this.rowNode,
        colDef: i,
        rowIndex: this.rowNode.rowIndex,
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        $scope: this.scope,
        context: this.beans.gridOptionsWrapper.getContext()
      };
      this.beans.stylingService.processClassRules(i.cellClassRules, r, function(o) {
        return t.cellComp.addOrRemoveCssClass(o, !0);
      }, function(o) {
        return t.cellComp.addOrRemoveCssClass(o, !1);
      });
    }, e.prototype.applyUserStyles = function() {
      var t = this.column.getColDef();
      if (t.cellStyle) {
        var i;
        if (typeof t.cellStyle == "function") {
          var r = {
            column: this.column,
            value: this.cellCtrl.getValue(),
            colDef: t,
            data: this.rowNode.data,
            node: this.rowNode,
            rowIndex: this.rowNode.rowIndex,
            $scope: this.scope,
            api: this.beans.gridOptionsWrapper.getApi(),
            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
            context: this.beans.gridOptionsWrapper.getContext()
          }, o = t.cellStyle;
          i = o(r);
        } else
          i = t.cellStyle;
        this.cellComp.setUserStyles(i);
      }
    }, e.prototype.applyClassesFromColDef = function() {
      var t = this, i = this.column.getColDef(), r = {
        value: this.cellCtrl.getValue(),
        data: this.rowNode.data,
        node: this.rowNode,
        colDef: i,
        rowIndex: this.rowNode.rowIndex,
        $scope: this.scope,
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        context: this.beans.gridOptionsWrapper.getContext()
      };
      this.staticClasses.length && this.staticClasses.forEach(function(o) {
        return t.cellComp.addOrRemoveCssClass(o, !1);
      }), this.staticClasses = this.beans.stylingService.getStaticCellClasses(i, r), this.staticClasses.length && this.staticClasses.forEach(function(o) {
        return t.cellComp.addOrRemoveCssClass(o, !0);
      });
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var mY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Hx = (
  /** @class */
  function(n) {
    mY(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.ctrl = t, r.beans = i, r;
    }
    return e.prototype.setComp = function(t) {
      this.comp = t, this.setupTooltip();
    }, e.prototype.setupTooltip = function() {
      this.browserTooltips = this.beans.gridOptionsWrapper.isEnableBrowserTooltips(), this.updateTooltipText(), this.browserTooltips ? this.comp.setTitle(this.tooltip != null ? this.tooltip : void 0) : this.createTooltipFeatureIfNeeded();
    }, e.prototype.updateTooltipText = function() {
      this.tooltip = this.ctrl.getTooltipValue();
    }, e.prototype.createTooltipFeatureIfNeeded = function() {
      var t = this;
      if (this.genericTooltipFeature == null) {
        var i = {
          getTooltipParams: function() {
            return t.getTooltipParams();
          },
          getGui: function() {
            return t.ctrl.getGui();
          }
        };
        this.genericTooltipFeature = this.createManagedBean(new AS(i), this.beans.context);
      }
    }, e.prototype.refreshToolTip = function() {
      this.updateTooltipText(), this.browserTooltips && this.comp.setTitle(this.tooltip != null ? this.tooltip : void 0);
    }, e.prototype.getTooltipParams = function() {
      var t = this.ctrl, i = t.getColumn ? t.getColumn() : void 0, r = t.getColDef ? t.getColDef() : void 0, o = t.getRowNode ? t.getRowNode() : void 0;
      return {
        location: t.getLocation(),
        colDef: r,
        column: i,
        rowIndex: t.getRowIndex ? t.getRowIndex() : void 0,
        node: o,
        data: o ? o.data : void 0,
        value: this.getTooltipText(),
        valueFormatted: t.getValueFormatted ? t.getValueFormatted() : void 0
      };
    }, e.prototype.getTooltipText = function() {
      return this.tooltip;
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var _t = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Gx = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.postConstruct = function() {
      this.doingMasterDetail = this.gridOptionsWrapper.isMasterDetail(), this.gridOptionsWrapper.isRowModelDefault() && (this.clientSideRowModel = this.rowModel), this.gridOptionsWrapper.isRowModelServerSide() && (this.serverSideRowModel = this.rowModel);
    }, _t([
      T("resizeObserverService")
    ], n.prototype, "resizeObserverService", void 0), _t([
      T("paginationProxy")
    ], n.prototype, "paginationProxy", void 0), _t([
      T("context")
    ], n.prototype, "context", void 0), _t([
      T("columnApi")
    ], n.prototype, "columnApi", void 0), _t([
      T("gridApi")
    ], n.prototype, "gridApi", void 0), _t([
      T("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), _t([
      T("expressionService")
    ], n.prototype, "expressionService", void 0), _t([
      T("rowRenderer")
    ], n.prototype, "rowRenderer", void 0), _t([
      T("$compile")
    ], n.prototype, "$compile", void 0), _t([
      T("templateService")
    ], n.prototype, "templateService", void 0), _t([
      T("valueService")
    ], n.prototype, "valueService", void 0), _t([
      T("eventService")
    ], n.prototype, "eventService", void 0), _t([
      T("columnModel")
    ], n.prototype, "columnModel", void 0), _t([
      T("headerNavigationService")
    ], n.prototype, "headerNavigationService", void 0), _t([
      T("navigationService")
    ], n.prototype, "navigationService", void 0), _t([
      T("columnAnimationService")
    ], n.prototype, "columnAnimationService", void 0), _t([
      fi("rangeService")
    ], n.prototype, "rangeService", void 0), _t([
      T("focusService")
    ], n.prototype, "focusService", void 0), _t([
      fi("contextMenuFactory")
    ], n.prototype, "contextMenuFactory", void 0), _t([
      T("popupService")
    ], n.prototype, "popupService", void 0), _t([
      T("valueFormatterService")
    ], n.prototype, "valueFormatterService", void 0), _t([
      T("stylingService")
    ], n.prototype, "stylingService", void 0), _t([
      T("columnHoverService")
    ], n.prototype, "columnHoverService", void 0), _t([
      T("userComponentFactory")
    ], n.prototype, "userComponentFactory", void 0), _t([
      T("userComponentRegistry")
    ], n.prototype, "userComponentRegistry", void 0), _t([
      T("animationFrameService")
    ], n.prototype, "animationFrameService", void 0), _t([
      T("dragAndDropService")
    ], n.prototype, "dragAndDropService", void 0), _t([
      T("sortController")
    ], n.prototype, "sortController", void 0), _t([
      T("filterManager")
    ], n.prototype, "filterManager", void 0), _t([
      T("rowContainerHeightService")
    ], n.prototype, "rowContainerHeightService", void 0), _t([
      T("frameworkOverrides")
    ], n.prototype, "frameworkOverrides", void 0), _t([
      T("cellPositionUtils")
    ], n.prototype, "cellPositionUtils", void 0), _t([
      T("rowPositionUtils")
    ], n.prototype, "rowPositionUtils", void 0), _t([
      T("selectionService")
    ], n.prototype, "selectionService", void 0), _t([
      fi("selectionHandleFactory")
    ], n.prototype, "selectionHandleFactory", void 0), _t([
      T("rowCssClassCalculator")
    ], n.prototype, "rowCssClassCalculator", void 0), _t([
      T("rowModel")
    ], n.prototype, "rowModel", void 0), _t([
      T("ctrlsService")
    ], n.prototype, "ctrlsService", void 0), _t([
      T("ctrlsFactory")
    ], n.prototype, "ctrlsFactory", void 0), _t([
      T("agStackComponentsRegistry")
    ], n.prototype, "agStackComponentsRegistry", void 0), _t([
      T("valueCache")
    ], n.prototype, "valueCache", void 0), _t([
      T("rowNodeEventThrottle")
    ], n.prototype, "rowNodeEventThrottle", void 0), _t([
      Le
    ], n.prototype, "postConstruct", null), n = _t([
      qe("beans")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var vY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _Y = (
  /** @class */
  function(n) {
    vY(e, n);
    function e(t, i, r) {
      var o = n.call(this) || this;
      return o.cellCtrl = t, o.beans = i, o.column = r, o;
    }
    return e.prototype.onMouseEvent = function(t, i) {
      if (!Hl(i))
        switch (t) {
          case "click":
            this.onCellClicked(i);
            break;
          case "mousedown":
          case "touchstart":
            this.onMouseDown(i);
            break;
          case "dblclick":
            this.onCellDoubleClicked(i);
            break;
          case "mouseout":
            this.onMouseOut(i);
            break;
          case "mouseover":
            this.onMouseOver(i);
            break;
        }
    }, e.prototype.onCellClicked = function(t) {
      if (this.isDoubleClickOnIPad()) {
        this.onCellDoubleClicked(t), t.preventDefault();
        return;
      }
      var i = this.beans, r = i.eventService, o = i.gridOptionsWrapper, s = this.cellCtrl.createEvent(t, F.EVENT_CELL_CLICKED);
      r.dispatchEvent(s);
      var a = this.column.getColDef();
      a.onCellClicked && window.setTimeout(function() {
        return a.onCellClicked(s);
      }, 0);
      var l = (o.isSingleClickEdit() || a.singleClickEdit) && !o.isSuppressClickEdit();
      l && this.cellCtrl.startRowOrCellEdit();
    }, e.prototype.isDoubleClickOnIPad = function() {
      if (!Cg() || mx("dblclick"))
        return !1;
      var t = (/* @__PURE__ */ new Date()).getTime(), i = t - this.lastIPadMouseClickEvent < 200;
      return this.lastIPadMouseClickEvent = t, i;
    }, e.prototype.onCellDoubleClicked = function(t) {
      var i = this.column.getColDef(), r = this.cellCtrl.createEvent(t, F.EVENT_CELL_DOUBLE_CLICKED);
      this.beans.eventService.dispatchEvent(r), typeof i.onCellDoubleClicked == "function" && window.setTimeout(function() {
        return i.onCellDoubleClicked(r);
      }, 0);
      var o = !this.beans.gridOptionsWrapper.isSingleClickEdit() && !this.beans.gridOptionsWrapper.isSuppressClickEdit();
      o && this.cellCtrl.startRowOrCellEdit(null, null, t);
    }, e.prototype.onMouseDown = function(t) {
      var i = t.ctrlKey, r = t.metaKey, o = t.shiftKey, s = t.target, a = this.beans, l = a.eventService, u = a.rangeService;
      if (!this.isRightClickInExistingRange(t)) {
        var c = u && u.getCellRanges().length != 0;
        if (!o || !c) {
          var h = RS() && !this.cellCtrl.isEditing() && !$B(s);
          this.cellCtrl.focusCell(h);
        }
        if (o && c && t.preventDefault(), !this.containsWidget(s)) {
          if (u) {
            var d = this.cellCtrl.getCellPosition();
            if (o)
              u.extendLatestRangeToCell(d);
            else {
              var f = i || r;
              u.setRangeToCell(d, f);
            }
          }
          l.dispatchEvent(this.cellCtrl.createEvent(t, F.EVENT_CELL_MOUSE_DOWN));
        }
      }
    }, e.prototype.isRightClickInExistingRange = function(t) {
      var i = this.beans.rangeService;
      if (i) {
        var r = i.isCellInAnyRange(this.cellCtrl.getCellPosition());
        if (r && t.button === 2)
          return !0;
      }
      return !1;
    }, e.prototype.containsWidget = function(t) {
      return OS(t, "ag-selection-checkbox", 3);
    }, e.prototype.onMouseOut = function(t) {
      if (!this.mouseStayingInsideCell(t)) {
        var i = this.cellCtrl.createEvent(t, F.EVENT_CELL_MOUSE_OUT);
        this.beans.eventService.dispatchEvent(i), this.beans.columnHoverService.clearMouseOver();
      }
    }, e.prototype.onMouseOver = function(t) {
      if (!this.mouseStayingInsideCell(t)) {
        var i = this.cellCtrl.createEvent(t, F.EVENT_CELL_MOUSE_OVER);
        this.beans.eventService.dispatchEvent(i), this.beans.columnHoverService.setMouseOver([this.column]);
      }
    }, e.prototype.mouseStayingInsideCell = function(t) {
      if (!t.target || !t.relatedTarget)
        return !1;
      var i = this.cellCtrl.getGui(), r = i.contains(t.target), o = i.contains(t.relatedTarget);
      return r && o;
    }, e.prototype.destroy = function() {
    }, e;
  }(Gx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var CY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), yY = (
  /** @class */
  function(n) {
    CY(e, n);
    function e(t, i, r, o, s, a) {
      var l = n.call(this) || this;
      return l.cellCtrl = t, l.beans = i, l.rowNode = o, l.rowCtrl = a, l;
    }
    return e.prototype.setComp = function(t) {
      this.eGui = t;
    }, e.prototype.onKeyDown = function(t) {
      var i = t.key;
      switch (i) {
        case _e.ENTER:
          this.onEnterKeyDown(t);
          break;
        case _e.F2:
          this.onF2KeyDown(t);
          break;
        case _e.ESCAPE:
          this.onEscapeKeyDown(t);
          break;
        case _e.TAB:
          this.onTabKeyDown(t);
          break;
        case _e.BACKSPACE:
        case _e.DELETE:
          this.onBackspaceOrDeleteKeyPressed(i, t);
          break;
        case _e.DOWN:
        case _e.UP:
        case _e.RIGHT:
        case _e.LEFT:
          this.onNavigationKeyPressed(t, i);
          break;
      }
    }, e.prototype.onNavigationKeyPressed = function(t, i) {
      this.cellCtrl.isEditing() || (t.shiftKey && this.cellCtrl.isRangeSelectionEnabled() ? this.onShiftRangeSelect(i) : this.beans.navigationService.navigateToNextCell(t, i, this.cellCtrl.getCellPosition(), !0), t.preventDefault());
    }, e.prototype.onShiftRangeSelect = function(t) {
      if (this.beans.rangeService) {
        var i = this.beans.rangeService.extendLatestRangeInDirection(t);
        i && this.beans.navigationService.ensureCellVisible(i);
      }
    }, e.prototype.onTabKeyDown = function(t) {
      this.beans.navigationService.onTabKeyDown(this.cellCtrl, t);
    }, e.prototype.onBackspaceOrDeleteKeyPressed = function(t, i) {
      this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(t, void 0, i);
    }, e.prototype.onEnterKeyDown = function(t) {
      this.cellCtrl.isEditing() || this.rowCtrl.isEditing() ? this.cellCtrl.stopEditingAndFocus() : this.beans.gridOptionsWrapper.isEnterMovesDown() ? this.beans.navigationService.navigateToNextCell(null, _e.DOWN, this.cellCtrl.getCellPosition(), !1) : (this.cellCtrl.startRowOrCellEdit(_e.ENTER, void 0, t), this.cellCtrl.isEditing() && t.preventDefault());
    }, e.prototype.onF2KeyDown = function(t) {
      this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(_e.F2, void 0, t);
    }, e.prototype.onEscapeKeyDown = function(t) {
      this.cellCtrl.isEditing() && (this.cellCtrl.stopRowOrCellEdit(!0), this.cellCtrl.focusCell(!0));
    }, e.prototype.onKeyPress = function(t) {
      var i = t.target, r = i !== this.eGui;
      if (!(r || this.cellCtrl.isEditing())) {
        var o = String.fromCharCode(t.charCode);
        o === " " ? this.onSpaceKeyPressed(t) : _H(t) && (this.cellCtrl.startRowOrCellEdit(null, o, t), t.preventDefault());
      }
    }, e.prototype.onSpaceKeyPressed = function(t) {
      var i = this.beans.gridOptionsWrapper;
      if (!this.cellCtrl.isEditing() && i.isRowSelection()) {
        var r = this.rowNode.isSelected(), o = !r;
        if (o || !i.isSuppressRowDeselection()) {
          var s = this.beans.gridOptionsWrapper.isGroupSelectsFiltered(), a = this.rowNode.setSelectedParams({
            newValue: o,
            rangeSelect: t.shiftKey,
            groupSelectsFiltered: s
          });
          r === void 0 && a === 0 && this.rowNode.setSelectedParams({
            newValue: !1,
            rangeSelect: t.shiftKey,
            groupSelectsFiltered: s
          });
        }
      }
      t.preventDefault();
    }, e.prototype.destroy = function() {
    }, e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var wY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), bY = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, SY = (
  /** @class */
  function(n) {
    wY(e, n);
    function e(t, i, r, o) {
      var s = n.call(this, '<div class="ag-drag-handle ag-row-drag" draggable="true"></div>') || this;
      return s.rowNode = t, s.column = i, s.beans = r, s.eCell = o, s;
    }
    return e.prototype.postConstruct = function() {
      var t = this.getGui();
      t.appendChild(Yn("rowDrag", this.beans.gridOptionsWrapper, null)), this.addGuiEventListener("mousedown", function(i) {
        i.stopPropagation();
      }), this.addDragSource(), this.checkVisibility();
    }, e.prototype.addDragSource = function() {
      this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
    }, e.prototype.onDragStart = function(t) {
      var i = this, r = this.column.getColDef().dndSourceOnRowDrag;
      t.dataTransfer.setDragImage(this.eCell, 0, 0);
      var o = function() {
        try {
          var s = JSON.stringify(i.rowNode.data);
          t.dataTransfer.setData("application/json", s), t.dataTransfer.setData("text/plain", s);
        } catch {
        }
      };
      r ? r({ rowNode: this.rowNode, dragEvent: t }) : o();
    }, e.prototype.checkVisibility = function() {
      var t = this.column.isDndSource(this.rowNode);
      this.setDisplayed(t);
    }, bY([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var EY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Yw = globalThis && globalThis.__assign || function() {
  return Yw = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, Yw.apply(this, arguments);
}, LY = "ag-cell", DY = "ag-cell-auto-height", RY = "ag-cell-normal-height", TY = "ag-cell-focus", OY = "ag-cell-first-right-pinned", xY = "ag-cell-last-left-pinned", ZM = "ag-cell-not-inline-editing", NY = "ag-cell-inline-editing", IY = "ag-cell-popup-editing", PY = "ag-column-hover", AY = "ag-cell-wrap-text", MY = 0, Zc = (
  /** @class */
  function(n) {
    EY(e, n);
    function e(t, i, r, o) {
      var s = n.call(this) || this;
      return s.suppressRefreshCell = !1, s.column = t, s.rowNode = i, s.beans = r, s.rowCtrl = o, s.instanceId = t.getId() + "-" + MY++, s.createCellPosition(), s.addFeatures(), s;
    }
    return e.prototype.addFeatures = function() {
      var t = this;
      this.cellPositionFeature = new fY(this, this.beans), this.addDestroyFunc(function() {
        return t.cellPositionFeature.destroy();
      }), this.cellCustomStyleFeature = new gY(this, this.beans), this.addDestroyFunc(function() {
        return t.cellCustomStyleFeature.destroy();
      }), this.cellMouseListenerFeature = new _Y(this, this.beans, this.column), this.addDestroyFunc(function() {
        return t.cellMouseListenerFeature.destroy();
      }), this.cellKeyboardListenerFeature = new yY(this, this.beans, this.column, this.rowNode, this.scope, this.rowCtrl), this.addDestroyFunc(function() {
        return t.cellKeyboardListenerFeature.destroy();
      });
      var i = this.beans.rangeService && this.beans.gridOptionsWrapper.isEnableRangeSelection();
      i && (this.cellRangeFeature = new hY(this.beans, this), this.addDestroyFunc(function() {
        return t.cellRangeFeature.destroy();
      })), this.addTooltipFeature();
    }, e.prototype.addTooltipFeature = function() {
      var t = this, i = function() {
        var o = t.column.getColDef(), s = t.rowNode.data;
        if (o.tooltipField && ge(s))
          return Ww(s, o.tooltipField, t.column.isTooltipFieldContainsDots());
        var a = o.tooltipValueGetter;
        return a ? a({
          location: "cell",
          api: t.beans.gridOptionsWrapper.getApi(),
          columnApi: t.beans.gridOptionsWrapper.getColumnApi(),
          context: t.beans.gridOptionsWrapper.getContext(),
          colDef: t.column.getColDef(),
          column: t.column,
          rowIndex: t.cellPosition.rowIndex,
          node: t.rowNode,
          data: t.rowNode.data,
          value: t.value,
          valueFormatted: t.valueFormatted
        }) : null;
      }, r = {
        getColumn: function() {
          return t.column;
        },
        getColDef: function() {
          return t.column.getColDef();
        },
        getRowIndex: function() {
          return t.cellPosition.rowIndex;
        },
        getRowNode: function() {
          return t.rowNode;
        },
        getGui: function() {
          return t.getGui();
        },
        getLocation: function() {
          return "cell";
        },
        getTooltipValue: i,
        // this makes no sense, why is the cell formatted value passed to the tooltip???
        getValueFormatted: function() {
          return t.valueFormatted;
        }
      };
      this.tooltipFeature = new Hx(r, this.beans), this.addDestroyFunc(function() {
        return t.tooltipFeature.destroy();
      });
    }, e.prototype.setComp = function(t, i, r, o, s, a) {
      this.cellComp = t, this.gow = this.beans.gridOptionsWrapper, this.scope = i, this.eGui = r, this.eCellWrapper = o, this.printLayout = s, this.updateAndFormatValue(!0), this.addDomData(), this.onCellFocused(), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), this.setupAriaExpanded(), this.setupAutoHeight(), this.setAriaColIndex(), this.gow.isSuppressCellFocus() || this.cellComp.setTabIndex(-1);
      var l = ql(this.column.getId());
      this.cellComp.setColId(l), this.cellComp.setRole("gridcell"), this.cellPositionFeature.setComp(r), this.cellCustomStyleFeature.setComp(t, i), this.tooltipFeature.setComp(t), this.cellKeyboardListenerFeature.setComp(this.eGui), this.cellRangeFeature && this.cellRangeFeature.setComp(t, r), a && this.isCellEditable() ? this.startEditing() : this.showValue();
    }, e.prototype.setupAutoHeight = function() {
      var t = this;
      if (this.column.isAutoHeight()) {
        var i = this.eCellWrapper, r = i.parentElement, o = this.beans.gridOptionsWrapper.getRowHeightAsNumber(), s = function(u) {
          if (!t.editing) {
            var c = t.beans.gridOptionsWrapper.getDocument();
            if ((!c || !c.contains(i)) && u < 5) {
              t.beans.frameworkOverrides.setTimeout(function() {
                return s(u + 1);
              }, 0);
              return;
            }
            var h = yg(r), d = h.paddingTop, f = h.paddingBottom, p = i.offsetHeight, g = p + d + f, _ = Math.max(g, o);
            t.rowNode.setRowAutoHeight(_, t.column);
          }
        }, a = function() {
          return s(0);
        };
        a();
        var l = this.beans.resizeObserverService.observeResize(i, a);
        this.addDestroyFunc(function() {
          l(), t.rowNode.setRowAutoHeight(void 0, t.column);
        });
      }
    }, e.prototype.getInstanceId = function() {
      return this.instanceId;
    }, e.prototype.showValue = function(t) {
      t === void 0 && (t = !1);
      var i = this.valueFormatted != null ? this.valueFormatted : this.value, r = this.createCellRendererParams(), o = this.beans.userComponentFactory.getCellRendererDetails(this.column.getColDef(), r);
      this.cellComp.setRenderDetails(o, i, t), this.refreshHandle();
    }, e.prototype.setupControlComps = function() {
      var t = this.column.getColDef();
      this.includeSelection = this.isIncludeControl(t.checkboxSelection), this.includeRowDrag = this.isIncludeControl(t.rowDrag), this.includeDndSource = this.isIncludeControl(t.dndSource), this.cellComp.setIncludeSelection(this.includeSelection), this.cellComp.setIncludeDndSource(this.includeDndSource), this.cellComp.setIncludeRowDrag(this.includeRowDrag);
    }, e.prototype.isForceWrapper = function() {
      var t = this.beans.gridOptionsWrapper.isEnableCellTextSelection() || this.column.isAutoHeight();
      return t;
    }, e.prototype.isIncludeControl = function(t) {
      var i = this.rowNode.rowPinned != null, r = typeof t == "function", o = i ? !1 : r || t === !0;
      return o;
    }, e.prototype.setupAriaExpanded = function() {
      var t = this, i = this.column.getColDef();
      if (this.rowNode.isExpandable()) {
        var r = i.showRowGroup, o = this.rowNode.rowGroupColumn, s = r === !0, a = o && o.getColId() === r, l = s || a;
        if (l) {
          var u = function() {
            bs(t.eGui, !!t.rowNode.expanded);
          };
          this.addManagedListener(this.rowNode, Wt.EVENT_EXPANDED_CHANGED, u), u();
        }
      }
    }, e.prototype.refreshShouldDestroy = function() {
      var t = this.column.getColDef(), i = this.includeSelection != this.isIncludeControl(t.checkboxSelection), r = this.includeRowDrag != this.isIncludeControl(t.rowDrag), o = this.includeDndSource != this.isIncludeControl(t.dndSource);
      return i || r || o;
    }, e.prototype.startEditing = function(t, i, r, o) {
      t === void 0 && (t = null), i === void 0 && (i = null), r === void 0 && (r = !1), o === void 0 && (o = null);
      var s, a;
      if (!(!this.isCellEditable() || this.editing)) {
        var l = this.createCellEditorParams(t, i, r), u = this.column.getColDef(), c = this.beans.userComponentFactory.getCellEditorDetails(u, l), h = ((s = c) === null || s === void 0 ? void 0 : s.popupFromSelector) != null ? c.popupFromSelector : !!u.cellEditorPopup, d = ((a = c) === null || a === void 0 ? void 0 : a.popupPositionFromSelector) != null ? c.popupPositionFromSelector : u.cellEditorPopupPosition;
        this.setEditing(!0, h), this.cellComp.setEditDetails(c, h, d);
        var f = this.createEvent(o, F.EVENT_CELL_EDITING_STARTED);
        this.beans.eventService.dispatchEvent(f);
      }
    }, e.prototype.setEditing = function(t, i) {
      i === void 0 && (i = !1), this.editing !== t && (this.editing = t, this.editingInPopup = i, this.setInlineEditingClass());
    }, e.prototype.stopRowOrCellEdit = function(t) {
      t === void 0 && (t = !1), this.beans.gridOptionsWrapper.isFullRowEdit() ? this.rowCtrl.stopRowEditing(t) : this.stopEditing(t);
    }, e.prototype.onPopupEditorClosed = function() {
      this.isEditing() && this.stopEditingAndFocus();
    }, e.prototype.takeValueFromCellEditor = function(t) {
      var i = { newValueExists: !1 };
      if (t)
        return i;
      var r = this.cellComp.getCellEditor();
      if (!r)
        return i;
      var o = r.isCancelAfterEnd && r.isCancelAfterEnd();
      if (o)
        return i;
      var s = r.getValue();
      return {
        newValue: s,
        newValueExists: !0
      };
    }, e.prototype.saveNewValue = function(t, i) {
      if (i !== t) {
        if (this.beans.gridOptionsWrapper.isReadOnlyEdit()) {
          this.dispatchEventForSaveValueReadOnly(t, i);
          return;
        }
        this.suppressRefreshCell = !0, this.rowNode.setDataValue(this.column, i), this.suppressRefreshCell = !1;
      }
    }, e.prototype.dispatchEventForSaveValueReadOnly = function(t, i) {
      var r = this.rowNode, o = {
        type: F.EVENT_CELL_EDIT_REQUEST,
        event: null,
        rowIndex: r.rowIndex,
        rowPinned: r.rowPinned,
        column: this.column,
        api: this.beans.gridApi,
        columnApi: this.beans.columnApi,
        colDef: this.column.getColDef(),
        context: this.beans.gridOptionsWrapper.getContext(),
        data: r.data,
        node: r,
        oldValue: t,
        newValue: i,
        value: i,
        source: void 0
      };
      this.beans.eventService.dispatchEvent(o);
    }, e.prototype.stopEditing = function(t) {
      if (t === void 0 && (t = !1), !!this.editing) {
        var i = this.takeValueFromCellEditor(t), r = i.newValue, o = i.newValueExists, s = this.getValueFromValueService();
        o && this.saveNewValue(s, r), this.setEditing(!1), this.cellComp.setEditDetails(), this.updateAndFormatValue(), this.refreshCell({ forceRefresh: !0, suppressFlash: !0 }), this.dispatchEditingStoppedEvent(s, r);
      }
    }, e.prototype.dispatchEditingStoppedEvent = function(t, i) {
      var r = Yw(Yw({}, this.createEvent(null, F.EVENT_CELL_EDITING_STOPPED)), {
        oldValue: t,
        newValue: i
      });
      this.beans.eventService.dispatchEvent(r);
    }, e.prototype.setInlineEditingClass = function() {
      if (this.isAlive()) {
        var t = this.editing && !this.editingInPopup, i = this.editing && this.editingInPopup;
        this.cellComp.addOrRemoveCssClass(NY, t), this.cellComp.addOrRemoveCssClass(ZM, !t), this.cellComp.addOrRemoveCssClass(IY, i), this.rowCtrl.setInlineEditingCss(this.editing);
      }
    }, e.prototype.hackSayEditingInPopup = function() {
      this.editingInPopup || (this.editingInPopup = !0, this.setInlineEditingClass());
    }, e.prototype.createCellEditorParams = function(t, i, r) {
      var o = {
        value: this.getValueFromValueService(),
        key: t,
        eventKey: t,
        charPress: i,
        column: this.column,
        colDef: this.column.getColDef(),
        rowIndex: this.getCellPosition().rowIndex,
        node: this.rowNode,
        data: this.rowNode.data,
        api: this.beans.gridOptionsWrapper.getApi(),
        cellStartedEdit: r,
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        context: this.beans.gridOptionsWrapper.getContext(),
        onKeyDown: this.onKeyDown.bind(this),
        stopEditing: this.stopEditingAndFocus.bind(this),
        eGridCell: this.getGui(),
        parseValue: this.parseValue.bind(this),
        formatValue: this.formatValue.bind(this)
      };
      return this.scope && (o.$scope = this.scope), o;
    }, e.prototype.createCellRendererParams = function() {
      var t = this, i = function(o, s) {
        console.warn("AG Grid: since AG Grid v26, params.addRowCompListener() is deprecated. If you need this functionality, please contact AG Grid support and advise why so that we can revert with an appropriate workaround, as we dont have any valid use cases for it. This method was originally provided as a work around to know when cells were destroyed in AG Grid before custom Cell Renderers could be provided."), t.rowCtrl.addEventListener(o, s);
      }, r = {
        value: this.value,
        valueFormatted: this.valueFormatted,
        getValue: this.getValueFromValueService.bind(this),
        setValue: function(o) {
          return t.beans.valueService.setValue(t.rowNode, t.column, o);
        },
        formatValue: this.formatValue.bind(this),
        data: this.rowNode.data,
        node: this.rowNode,
        colDef: this.column.getColDef(),
        column: this.column,
        rowIndex: this.getCellPosition().rowIndex,
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        context: this.beans.gridOptionsWrapper.getContext(),
        refreshCell: this.refreshCell.bind(this),
        eGridCell: this.getGui(),
        eParentOfValue: this.cellComp.getParentOfValue(),
        registerRowDragger: function(o, s, a, l) {
          return t.registerRowDragger(o, s, l);
        },
        // this function is not documented anywhere, so we could drop it
        // it was in the olden days to allow user to register for when rendered
        // row was removed (the row comp was removed), however now that the user
        // can provide components for cells, the destroy method gets call when this
        // happens so no longer need to fire event.
        addRowCompListener: i
      };
      return this.scope && (r.$scope = this.scope), r;
    }, e.prototype.parseValue = function(t) {
      var i = this.column.getColDef(), r = {
        node: this.rowNode,
        data: this.rowNode.data,
        oldValue: this.getValue(),
        newValue: t,
        colDef: i,
        column: this.column,
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        context: this.beans.gridOptionsWrapper.getContext()
      }, o = i.valueParser;
      return ge(o) ? this.beans.expressionService.evaluate(o, r) : t;
    }, e.prototype.setFocusOutOnEditor = function() {
      if (this.editing) {
        var t = this.cellComp.getCellEditor();
        t && t.focusOut && t.focusOut();
      }
    }, e.prototype.setFocusInOnEditor = function() {
      if (this.editing) {
        var t = this.cellComp.getCellEditor();
        t && t.focusIn ? t.focusIn() : this.focusCell(!0);
      }
    }, e.prototype.onCellChanged = function(t) {
      if (this.cellComp) {
        var i = t.column === this.column;
        i && this.refreshCell({});
      }
    }, e.prototype.refreshCell = function(t) {
      if (!(this.suppressRefreshCell || this.editing)) {
        var i = this.column.getColDef(), r = t != null && !!t.newData, o = t != null && !!t.suppressFlash || !!i.suppressCellFlash, s = i.field == null && i.valueGetter == null && i.showRowGroup == null, a = t && t.forceRefresh || s || r, l = this.updateAndFormatValue(), u = a || l;
        if (u) {
          this.showValue(r);
          var c = this.beans.filterManager.isSuppressFlashingCellsBecauseFiltering(), h = !o && !c && (this.beans.gridOptionsWrapper.isEnableCellChangeFlash() || i.enableCellChangeFlash);
          h && this.flashCell(), this.cellCustomStyleFeature.applyUserStyles(), this.cellCustomStyleFeature.applyClassesFromColDef();
        }
        this.refreshToolTip(), this.cellCustomStyleFeature.applyCellClassRules();
      }
    }, e.prototype.stopEditingAndFocus = function(t) {
      t === void 0 && (t = !1), this.stopRowOrCellEdit(), this.focusCell(!0), t || this.navigateAfterEdit();
    }, e.prototype.navigateAfterEdit = function() {
      var t = this.beans.gridOptionsWrapper.isFullRowEdit();
      if (!t) {
        var i = this.beans.gridOptionsWrapper.isEnterMovesDownAfterEdit();
        i && this.beans.navigationService.navigateToNextCell(null, _e.DOWN, this.getCellPosition(), !1);
      }
    }, e.prototype.flashCell = function(t) {
      var i = t && t.flashDelay, r = t && t.fadeDelay;
      this.animateCell("data-changed", i, r);
    }, e.prototype.animateCell = function(t, i, r) {
      var o = this, s = "ag-cell-" + t, a = "ag-cell-" + t + "-animation", l = this.beans.gridOptionsWrapper;
      i || (i = l.getCellFlashDelay()), ge(r) || (r = l.getCellFadeDelay()), this.cellComp.addOrRemoveCssClass(s, !0), this.cellComp.addOrRemoveCssClass(a, !1), window.setTimeout(function() {
        o.cellComp.addOrRemoveCssClass(s, !1), o.cellComp.addOrRemoveCssClass(a, !0), o.eGui.style.transition = "background-color " + r + "ms", window.setTimeout(function() {
          o.cellComp.addOrRemoveCssClass(a, !1), o.eGui.style.transition = "";
        }, r);
      }, i);
    }, e.prototype.onFlashCells = function(t) {
      if (this.cellComp) {
        var i = this.beans.cellPositionUtils.createId(this.getCellPosition()), r = t.cells[i];
        r && this.animateCell("highlight");
      }
    }, e.prototype.isCellEditable = function() {
      return this.column.isCellEditable(this.rowNode);
    }, e.prototype.isSuppressFillHandle = function() {
      return this.column.isSuppressFillHandle();
    }, e.prototype.formatValue = function(t) {
      var i = this.callValueFormatter(t);
      return i ?? t;
    }, e.prototype.callValueFormatter = function(t) {
      return this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, t);
    }, e.prototype.updateAndFormatValue = function(t) {
      t === void 0 && (t = !1);
      var i = this.value, r = this.valueFormatted;
      this.value = this.getValueFromValueService(), this.valueFormatted = this.callValueFormatter(this.value);
      var o = t ? !0 : !this.valuesAreEqual(i, this.value) || this.valueFormatted != r;
      return o;
    }, e.prototype.valuesAreEqual = function(t, i) {
      var r = this.column.getColDef();
      return r.equals ? r.equals(t, i) : t === i;
    }, e.prototype.getComp = function() {
      return this.cellComp;
    }, e.prototype.getValueFromValueService = function() {
      var t = this.rowNode.leafGroup && this.beans.columnModel.isPivotMode(), i = this.rowNode.group && this.rowNode.expanded && !this.rowNode.footer && !t, r = this.beans.gridOptionsWrapper.isGroupIncludeFooter(), o = this.beans.gridOptionsWrapper.isGroupSuppressBlankHeader(), s = i && r && !o, a = this.beans.valueService.getValue(this.column, this.rowNode, !1, s);
      return a;
    }, e.prototype.getValue = function() {
      return this.value;
    }, e.prototype.getValueFormatted = function() {
      return this.valueFormatted;
    }, e.prototype.addDomData = function() {
      var t = this, i = this.getGui();
      this.beans.gridOptionsWrapper.setDomData(i, e.DOM_DATA_KEY_CELL_CTRL, this), this.addDestroyFunc(function() {
        return t.beans.gridOptionsWrapper.setDomData(i, e.DOM_DATA_KEY_CELL_CTRL, null);
      });
    }, e.prototype.createEvent = function(t, i) {
      var r = {
        type: i,
        node: this.rowNode,
        data: this.rowNode.data,
        value: this.value,
        column: this.column,
        colDef: this.column.getColDef(),
        context: this.beans.gridOptionsWrapper.getContext(),
        api: this.beans.gridApi,
        columnApi: this.beans.columnApi,
        rowPinned: this.rowNode.rowPinned,
        event: t,
        rowIndex: this.rowNode.rowIndex
      };
      return this.scope && (r.$scope = this.scope), r;
    }, e.prototype.onKeyPress = function(t) {
      this.cellKeyboardListenerFeature.onKeyPress(t);
    }, e.prototype.onKeyDown = function(t) {
      this.cellKeyboardListenerFeature.onKeyDown(t);
    }, e.prototype.onMouseEvent = function(t, i) {
      this.cellMouseListenerFeature.onMouseEvent(t, i);
    }, e.prototype.getGui = function() {
      return this.eGui;
    }, e.prototype.refreshToolTip = function() {
      this.tooltipFeature.refreshToolTip();
    }, e.prototype.getColSpanningList = function() {
      return this.cellPositionFeature.getColSpanningList();
    }, e.prototype.onLeftChanged = function() {
      this.cellComp && this.cellPositionFeature.onLeftChanged();
    }, e.prototype.onDisplayedColumnsChanged = function() {
      this.eGui && this.setAriaColIndex();
    }, e.prototype.setAriaColIndex = function() {
      var t = this.beans.columnModel.getAriaColumnIndex(this.column);
      xx(this.getGui(), t);
    }, e.prototype.isSuppressNavigable = function() {
      return this.column.isSuppressNavigable(this.rowNode);
    }, e.prototype.onWidthChanged = function() {
      return this.cellPositionFeature.onWidthChanged();
    }, e.prototype.getColumn = function() {
      return this.column;
    }, e.prototype.getRowNode = function() {
      return this.rowNode;
    }, e.prototype.getBeans = function() {
      return this.beans;
    }, e.prototype.isPrintLayout = function() {
      return this.printLayout;
    }, e.prototype.appendChild = function(t) {
      this.eGui.appendChild(t);
    }, e.prototype.refreshHandle = function() {
      this.editing || this.cellRangeFeature && this.cellRangeFeature.refreshHandle();
    }, e.prototype.getCellPosition = function() {
      return this.cellPosition;
    }, e.prototype.isEditing = function() {
      return this.editing;
    }, e.prototype.startRowOrCellEdit = function(t, i, r) {
      r === void 0 && (r = null), this.beans.gridOptionsWrapper.isFullRowEdit() ? this.rowCtrl.startRowEditing(t, i, this) : this.startEditing(t, i, !0, r);
    }, e.prototype.getRowCtrl = function() {
      return this.rowCtrl;
    }, e.prototype.getRowPosition = function() {
      return {
        rowIndex: this.cellPosition.rowIndex,
        rowPinned: this.cellPosition.rowPinned
      };
    }, e.prototype.updateRangeBordersIfRangeCount = function() {
      this.cellComp && this.cellRangeFeature && this.cellRangeFeature.updateRangeBordersIfRangeCount();
    }, e.prototype.onRangeSelectionChanged = function() {
      this.cellComp && this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
    }, e.prototype.isRangeSelectionEnabled = function() {
      return this.cellRangeFeature != null;
    }, e.prototype.focusCell = function(t) {
      t === void 0 && (t = !1), this.beans.focusService.setFocusedCell(this.getCellPosition().rowIndex, this.column, this.rowNode.rowPinned, t);
    }, e.prototype.onRowIndexChanged = function() {
      this.createCellPosition(), this.onCellFocused(), this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
    }, e.prototype.onFirstRightPinnedChanged = function() {
      if (this.cellComp) {
        var t = this.column.isFirstRightPinned();
        this.cellComp.addOrRemoveCssClass(OY, t);
      }
    }, e.prototype.onLastLeftPinnedChanged = function() {
      if (this.cellComp) {
        var t = this.column.isLastLeftPinned();
        this.cellComp.addOrRemoveCssClass(xY, t);
      }
    }, e.prototype.onCellFocused = function(t) {
      if (!(!this.cellComp || this.gow.isSuppressCellFocus())) {
        var i = this.beans.focusService.isCellFocused(this.cellPosition);
        if (this.cellComp.addOrRemoveCssClass(TY, i), i && t && t.forceBrowserFocus) {
          var r = this.cellComp.getFocusableElement();
          r.focus();
        }
        var o = this.beans.gridOptionsWrapper.isFullRowEdit();
        !i && !o && this.editing && this.stopRowOrCellEdit();
      }
    }, e.prototype.createCellPosition = function() {
      this.cellPosition = {
        rowIndex: this.rowNode.rowIndex,
        rowPinned: this.rowNode.rowPinned,
        column: this.column
      };
    }, e.prototype.applyStaticCssClasses = function() {
      this.cellComp.addOrRemoveCssClass(LY, !0), this.cellComp.addOrRemoveCssClass(ZM, !0);
      var t = this.column.isAutoHeight() == !0;
      this.cellComp.addOrRemoveCssClass(DY, t), this.cellComp.addOrRemoveCssClass(RY, !t);
    }, e.prototype.onColumnHover = function() {
      if (this.cellComp && this.beans.gridOptionsWrapper.isColumnHoverHighlight()) {
        var t = this.beans.columnHoverService.isHovered(this.column);
        this.cellComp.addOrRemoveCssClass(PY, t);
      }
    }, e.prototype.onNewColumnsLoaded = function() {
      this.cellComp && (this.setWrapText(), this.editing || this.refreshCell({ forceRefresh: !0, suppressFlash: !0 }));
    }, e.prototype.setWrapText = function() {
      var t = this.column.getColDef().wrapText == !0;
      this.cellComp.addOrRemoveCssClass(AY, t);
    }, e.prototype.dispatchCellContextMenuEvent = function(t) {
      var i = this.column.getColDef(), r = this.createEvent(t, F.EVENT_CELL_CONTEXT_MENU);
      this.beans.eventService.dispatchEvent(r), i.onCellContextMenu && window.setTimeout(function() {
        return i.onCellContextMenu(r);
      }, 0);
    }, e.prototype.getCellRenderer = function() {
      return this.cellComp ? this.cellComp.getCellRenderer() : null;
    }, e.prototype.getCellEditor = function() {
      return this.cellComp ? this.cellComp.getCellEditor() : null;
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this);
    }, e.prototype.createSelectionCheckbox = function() {
      var t = new Vx();
      return this.beans.context.createBean(t), t.init({ rowNode: this.rowNode, column: this.column }), t;
    }, e.prototype.createDndSource = function() {
      var t = new SY(this.rowNode, this.column, this.beans, this.eGui);
      return this.beans.context.createBean(t), t;
    }, e.prototype.registerRowDragger = function(t, i, r) {
      var o = this;
      if (this.customRowDragComp) {
        this.customRowDragComp.setDragElement(t, i);
        return;
      }
      var s = this.createRowDragComp(t, i, r);
      s && (this.customRowDragComp = s, this.addDestroyFunc(function() {
        return o.beans.context.destroyBean(s);
      }));
    }, e.prototype.createRowDragComp = function(t, i, r) {
      var o = this, s = this.beans.gridOptionsWrapper.isPagination(), a = this.beans.gridOptionsWrapper.isRowDragManaged(), l = this.beans.gridOptionsWrapper.isRowModelDefault();
      if (a) {
        if (!l) {
          mi(function() {
            return console.warn("AG Grid: managed row dragging is only allowed in the Client Side Row Model");
          }, "CellComp.addRowDragging");
          return;
        }
        if (s) {
          mi(function() {
            return console.warn("AG Grid: managed row dragging is not possible when doing pagination");
          }, "CellComp.addRowDragging");
          return;
        }
      }
      var u = new Kw(function() {
        return o.value;
      }, this.rowNode, this.column, t, i, r);
      return this.beans.context.createBean(u), u;
    }, e.DOM_DATA_KEY_CELL_CTRL = "cellCtrl", e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var nR = globalThis && globalThis.__assign || function() {
  return nR = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, nR.apply(this, arguments);
}, FY = (
  /** @class */
  function() {
    function n() {
    }
    return n.createChildScopeOrNull = function(e, t, i) {
      var r = i.isAngularCompileRows();
      if (!r)
        return null;
      var o = t.$new();
      o.data = nR({}, e.data), o.rowNode = e, o.context = i.getContext();
      var s = function() {
        o.$destroy(), o.data = null, o.rowNode = null, o.context = null;
      };
      return {
        scope: o,
        scopeDestroyFunc: s
      };
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var kY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), rs = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, WY = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, VY = (
  /** @class */
  function(n) {
    kY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.element = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.addMouseListeners(), this.mockContextMenuForIPad(), this.addKeyboardEvents();
    }, e.prototype.addKeyboardEvents = function() {
      var t = this, i = ["keydown", "keypress"];
      i.forEach(function(r) {
        var o = t.processKeyboardEvent.bind(t, r);
        t.addManagedListener(t.element, r, o);
      });
    }, e.prototype.addMouseListeners = function() {
      var t = this, i = mx("touchstart") ? "touchstart" : "mousedown", r = ["dblclick", "contextmenu", "mouseover", "mouseout", "click", i];
      r.forEach(function(o) {
        var s = t.processMouseEvent.bind(t, o);
        t.addManagedListener(t.element, o, s);
      });
    }, e.prototype.processMouseEvent = function(t, i) {
      if (!(!this.mouseEventService.isEventFromThisGrid(i) || Hl(i))) {
        var r = this.getRowForEvent(i), o = this.mouseEventService.getRenderedCellForEvent(i);
        t === "contextmenu" ? this.handleContextMenuMouseEvent(i, null, r, o) : (o && o.onMouseEvent(t, i), r && r.onMouseEvent(t, i));
      }
    }, e.prototype.mockContextMenuForIPad = function() {
      var t = this;
      if (Cg()) {
        var i = new da(this.element), r = function(o) {
          var s = t.getRowForEvent(o.touchEvent), a = t.mouseEventService.getRenderedCellForEvent(o.touchEvent);
          t.handleContextMenuMouseEvent(null, o.touchEvent, s, a);
        };
        this.addManagedListener(i, da.EVENT_LONG_TAP, r), this.addDestroyFunc(function() {
          return i.destroy();
        });
      }
    }, e.prototype.getRowForEvent = function(t) {
      for (var i = t.target; i; ) {
        var r = this.gridOptionsWrapper.getDomData(i, Qc.DOM_DATA_KEY_ROW_CTRL);
        if (r)
          return r;
        i = i.parentElement;
      }
      return null;
    }, e.prototype.handleContextMenuMouseEvent = function(t, i, r, o) {
      var s = r ? r.getRowNode() : null, a = o ? o.getColumn() : null, l = null;
      if (a) {
        var u = t || i;
        o.dispatchCellContextMenuEvent(u), l = this.valueService.getValue(a, s);
      }
      var c = this.ctrlsService.getGridBodyCtrl(), h = o ? o.getGui() : c.getGridBodyElement();
      this.contextMenuFactory && this.contextMenuFactory.onContextMenu(t, i, s, a, l, h);
    }, e.prototype.processKeyboardEvent = function(t, i) {
      var r = Vw(this.gridOptionsWrapper, i, Zc.DOM_DATA_KEY_CELL_CTRL), o = Vw(this.gridOptionsWrapper, i, Qc.DOM_DATA_KEY_ROW_CTRL);
      i.defaultPrevented || (r ? this.processCellKeyboardEvent(r, t, i) : o && o.isFullWidth() && this.processFullWidthRowKeyboardEvent(o, t, i));
    }, e.prototype.processCellKeyboardEvent = function(t, i, r) {
      var o = t.getRowNode(), s = t.getColumn(), a = t.isEditing(), l = !zw(this.gridOptionsWrapper, r, o, s, a);
      if (l)
        switch (i) {
          case "keydown":
            var u = !a && this.navigationService.handlePageScrollingKey(r);
            u || t.onKeyDown(r), this.doGridOperations(r, t.isEditing());
            break;
          case "keypress":
            t.onKeyPress(r);
            break;
        }
      if (i === "keydown") {
        var c = t.createEvent(r, F.EVENT_CELL_KEY_DOWN);
        this.eventService.dispatchEvent(c);
      }
      if (i === "keypress") {
        var h = t.createEvent(r, F.EVENT_CELL_KEY_PRESS);
        this.eventService.dispatchEvent(h);
      }
    }, e.prototype.processFullWidthRowKeyboardEvent = function(t, i, r) {
      var o = t.getRowNode(), s = this.focusService.getFocusedCell(), a = s && s.column, l = !zw(this.gridOptionsWrapper, r, o, a, !1);
      if (l) {
        var u = r.key;
        if (i === "keydown")
          switch (u) {
            case _e.UP:
            case _e.DOWN:
              t.onKeyboardNavigate(r);
              break;
            case _e.TAB:
              t.onTabKeyDown(r);
          }
      }
      if (i === "keydown") {
        var c = t.createRowEvent(F.EVENT_CELL_KEY_DOWN, r);
        this.eventService.dispatchEvent(c);
      }
      if (i === "keypress") {
        var h = t.createRowEvent(F.EVENT_CELL_KEY_PRESS, r);
        this.eventService.dispatchEvent(h);
      }
    }, e.prototype.doGridOperations = function(t, i) {
      if (!(!t.ctrlKey && !t.metaKey) && !i && this.mouseEventService.isEventFromThisGrid(t))
        switch (t.key.toUpperCase()) {
          case _e.A:
            return this.onCtrlAndA(t);
          case _e.C:
            return this.onCtrlAndC(t);
          case _e.V:
            return this.onCtrlAndV();
          case _e.D:
            return this.onCtrlAndD(t);
          case _e.Z:
            return t.shiftKey ? this.undoRedoService.redo() : this.undoRedoService.undo();
          case _e.Y:
            return this.undoRedoService.redo();
        }
    }, e.prototype.onCtrlAndA = function(t) {
      var i = this, r = i.pinnedRowModel, o = i.paginationProxy, s = i.rangeService, a = Z.PINNED_BOTTOM, l = Z.PINNED_TOP;
      if (s && o.isRowsToRender()) {
        var u = WY([
          r.isEmpty(l),
          r.isEmpty(a)
        ], 2), c = u[0], h = u[1], d = c ? null : l, f = void 0, p = void 0;
        h ? (f = null, p = this.paginationProxy.getRowCount() - 1) : (f = a, p = r.getPinnedBottomRowData().length - 1);
        var g = this.columnModel.getAllDisplayedColumns();
        if (ms(g))
          return;
        s.setCellRange({
          rowStartIndex: 0,
          rowStartPinned: d,
          rowEndIndex: p,
          rowEndPinned: f,
          columnStart: g[0],
          columnEnd: Ti(g)
        });
      }
      t.preventDefault();
    }, e.prototype.onCtrlAndC = function(t) {
      !this.clipboardService || this.gridOptionsWrapper.isEnableCellTextSelection() || (this.clipboardService.copyToClipboard(), t.preventDefault());
    }, e.prototype.onCtrlAndV = function() {
      gt.isRegistered(ht.ClipboardModule) && !this.gridOptionsWrapper.isSuppressClipboardPaste() && this.clipboardService.pasteFromClipboard();
    }, e.prototype.onCtrlAndD = function(t) {
      gt.isRegistered(ht.ClipboardModule) && !this.gridOptionsWrapper.isSuppressClipboardPaste() && this.clipboardService.copyRangeDown(), t.preventDefault();
    }, rs([
      T("mouseEventService")
    ], e.prototype, "mouseEventService", void 0), rs([
      T("valueService")
    ], e.prototype, "valueService", void 0), rs([
      fi("contextMenuFactory")
    ], e.prototype, "contextMenuFactory", void 0), rs([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), rs([
      T("navigationService")
    ], e.prototype, "navigationService", void 0), rs([
      T("focusService")
    ], e.prototype, "focusService", void 0), rs([
      T("undoRedoService")
    ], e.prototype, "undoRedoService", void 0), rs([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), rs([
      T("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), rs([
      T("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), rs([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), rs([
      fi("clipboardService")
    ], e.prototype, "clipboardService", void 0), rs([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var BY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Lf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, HY = (
  /** @class */
  function(n) {
    BY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.centerContainerCon = t, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function() {
        t.gridBodyCon = t.ctrlsService.getGridBodyCtrl(), t.listenForResize();
      }), this.addManagedListener(this.eventService, F.EVENT_SCROLLBAR_WIDTH_CHANGED, this.onScrollbarWidthChanged.bind(this));
    }, e.prototype.listenForResize = function() {
      var t = this.onCenterViewportResized.bind(this);
      this.centerContainerCon.registerViewportResizeListener(t), this.gridBodyCon.registerBodyViewportResizeListener(t);
    }, e.prototype.onScrollbarWidthChanged = function() {
      this.checkViewportAndScrolls();
    }, e.prototype.onCenterViewportResized = function() {
      if (this.centerContainerCon.isViewportVisible()) {
        this.checkViewportAndScrolls();
        var t = this.centerContainerCon.getCenterWidth();
        t !== this.centerWidth && (this.centerWidth = t, this.columnModel.refreshFlexedColumns({ viewportWidth: this.centerWidth, updateBodyWidths: !0, fireResizedEvent: !0 }));
      } else
        this.bodyHeight = 0;
    }, e.prototype.checkViewportAndScrolls = function() {
      this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCon.getScrollFeature().checkScrollLeft();
    }, e.prototype.getBodyHeight = function() {
      return this.bodyHeight;
    }, e.prototype.checkBodyHeight = function() {
      var t = this.gridBodyCon.getBodyViewportElement(), i = x_(t);
      if (this.bodyHeight !== i) {
        this.bodyHeight = i;
        var r = {
          type: F.EVENT_BODY_HEIGHT_CHANGED,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(r);
      }
    }, e.prototype.updateScrollVisibleService = function() {
      this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
    }, e.prototype.updateScrollVisibleServiceImpl = function() {
      var t = {
        horizontalScrollShowing: this.isHorizontalScrollShowing(),
        verticalScrollShowing: this.gridBodyCon.isVerticalScrollShowing()
      };
      this.scrollVisibleService.setScrollsVisible(t), this.gridBodyCon.setVerticalScrollPaddingVisible(t.verticalScrollShowing);
    }, e.prototype.isHorizontalScrollShowing = function() {
      var t = this.gridOptionsWrapper.isAlwaysShowHorizontalScroll();
      return t || this.centerContainerCon.isViewportHScrollShowing();
    }, e.prototype.onHorizontalViewportChanged = function() {
      var t = this.centerContainerCon.getCenterWidth(), i = this.centerContainerCon.getViewportScrollLeft();
      this.columnModel.setViewportPosition(t, i);
    }, Lf([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Lf([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), Lf([
      T("scrollVisibleService")
    ], e.prototype, "scrollVisibleService", void 0), Lf([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), Lf([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Lf([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var GY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), QM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, UY = (
  /** @class */
  function(n) {
    GY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.element = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.eventService, F.EVENT_LEFT_PINNED_WIDTH_CHANGED, this.onPinnedLeftWidthChanged.bind(this));
    }, e.prototype.onPinnedLeftWidthChanged = function() {
      var t = this.pinnedWidthService.getPinnedLeftWidth(), i = t > 0;
      Bi(this.element, i), i && Yl(this.element, t);
    }, QM([
      T("pinnedWidthService")
    ], e.prototype, "pinnedWidthService", void 0), QM([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var zY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), JM = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, jY = (
  /** @class */
  function(n) {
    zY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.element = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.eventService, F.EVENT_RIGHT_PINNED_WIDTH_CHANGED, this.onPinnedRightWidthChanged.bind(this));
    }, e.prototype.onPinnedRightWidthChanged = function() {
      var t = this.pinnedWidthService.getPinnedRightWidth(), i = t > 0;
      Bi(this.element, i), i && Yl(this.element, t);
    }, JM([
      T("pinnedWidthService")
    ], e.prototype, "pinnedWidthService", void 0), JM([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var $Y = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), eF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, KY = (
  /** @class */
  function(n) {
    $Y(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.eContainer = t, r.eWrapper = i, r;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.eventService, F.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onHeightChanged.bind(this));
    }, e.prototype.onHeightChanged = function() {
      var t = this.maxDivHeightScaler.getUiContainerHeight(), i = t != null ? t + "px" : "";
      this.eContainer.style.height = i, this.eWrapper && (this.eWrapper.style.height = i);
    }, eF([
      T("rowContainerHeightService")
    ], e.prototype, "maxDivHeightScaler", void 0), eF([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var qY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), DL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, YY = (
  /** @class */
  function(n) {
    qY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.eContainer = t, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      if (!(!this.gridOptionsWrapper.isEnableRangeSelection() || // no range selection if no property
      Je(this.rangeService))) {
        var i = {
          dragStartPixels: 0,
          eElement: this.eContainer,
          onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
          onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
          onDragging: this.rangeService.onDragging.bind(this.rangeService)
        };
        this.dragService.addDragSource(i), this.addDestroyFunc(function() {
          return t.dragService.removeDragSource(i);
        });
      }
    }, DL([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), DL([
      T("dragService")
    ], e.prototype, "dragService", void 0), DL([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var XY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), tF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Ux = (
  /** @class */
  function(n) {
    XY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.callback = t, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this.setWidth.bind(this);
      this.addManagedListener(this.gridOptionsWrapper, He.PROP_DOM_LAYOUT, t), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, t), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, t), this.setWidth();
    }, e.prototype.setWidth = function() {
      var t = this.columnModel, i = this.gridOptionsWrapper.getDomLayout() === Z.DOM_LAYOUT_PRINT, r = t.getBodyContainerWidth(), o = t.getDisplayedColumnsLeftWidth(), s = t.getDisplayedColumnsRightWidth(), a = i ? r + o + s : r;
      this.callback(a);
    }, tF([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), tF([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var ZY = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Wh = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, QY = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, JY = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(QY(arguments[e]));
  return n;
}, we;
(function(n) {
  n.LEFT = "left", n.RIGHT = "right", n.CENTER = "center", n.FULL_WIDTH = "fullWidth", n.TOP_LEFT = "topLeft", n.TOP_RIGHT = "topRight", n.TOP_CENTER = "topCenter", n.TOP_FULL_WIDTH = "topFullWidth", n.BOTTOM_LEFT = "bottomLeft", n.BOTTOM_RIGHT = "bottomRight", n.BOTTOM_CENTER = "bottomCenter", n.BOTTOM_FULL_WIDTH = "bottomFullWidth";
})(we || (we = {}));
var Vo;
(function(n) {
  n.LEFT = "left", n.RIGHT = "right", n.CENTER = "center", n.FULL_WIDTH = "fullWidth";
})(Vo || (Vo = {}));
function HH(n) {
  switch (n) {
    case we.CENTER:
    case we.TOP_CENTER:
    case we.BOTTOM_CENTER:
      return Vo.CENTER;
    case we.LEFT:
    case we.TOP_LEFT:
    case we.BOTTOM_LEFT:
      return Vo.LEFT;
    case we.RIGHT:
    case we.TOP_RIGHT:
    case we.BOTTOM_RIGHT:
      return Vo.RIGHT;
    case we.FULL_WIDTH:
    case we.TOP_FULL_WIDTH:
    case we.BOTTOM_FULL_WIDTH:
      return Vo.FULL_WIDTH;
    default:
      throw Error("Invalid Row Container Type");
  }
}
var eX = zc([
  [we.CENTER, "ag-center-cols-container"],
  [we.LEFT, "ag-pinned-left-cols-container"],
  [we.RIGHT, "ag-pinned-right-cols-container"],
  [we.FULL_WIDTH, "ag-full-width-container"],
  [we.TOP_CENTER, "ag-floating-top-container"],
  [we.TOP_LEFT, "ag-pinned-left-floating-top"],
  [we.TOP_RIGHT, "ag-pinned-right-floating-top"],
  [we.TOP_FULL_WIDTH, "ag-floating-top-full-width-container"],
  [we.BOTTOM_CENTER, "ag-floating-bottom-container"],
  [we.BOTTOM_LEFT, "ag-pinned-left-floating-bottom"],
  [we.BOTTOM_RIGHT, "ag-pinned-right-floating-bottom"],
  [we.BOTTOM_FULL_WIDTH, "ag-floating-bottom-full-width-container"]
]), tX = zc([
  [we.CENTER, "ag-center-cols-viewport"],
  [we.TOP_CENTER, "ag-floating-top-viewport"],
  [we.BOTTOM_CENTER, "ag-floating-bottom-viewport"]
]), iX = zc([
  [we.CENTER, "ag-center-cols-clipper"]
]), Xw = (
  /** @class */
  function(n) {
    ZY(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.name = t, i;
    }
    return e.getRowContainerCssClasses = function(t) {
      var i = eX.get(t), r = tX.get(t), o = iX.get(t);
      return { container: i, viewport: r, wrapper: o };
    }, e.getPinned = function(t) {
      switch (t) {
        case we.BOTTOM_LEFT:
        case we.TOP_LEFT:
        case we.LEFT:
          return Z.PINNED_LEFT;
        case we.BOTTOM_RIGHT:
        case we.TOP_RIGHT:
        case we.RIGHT:
          return Z.PINNED_RIGHT;
        default:
          return null;
      }
    }, e.prototype.postConstruct = function() {
      var t = this;
      this.enableRtl = this.gridOptionsWrapper.isEnableRtl(), this.embedFullWidthRows = this.gridOptionsWrapper.isEmbedFullWidthRows(), this.addManagedListener(this.eventService, F.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_ROWS_CHANGED, this.onDisplayedRowsChanged.bind(this)), this.forContainers([we.CENTER], function() {
        return t.viewportSizeFeature = t.createManagedBean(new HY(t));
      }), this.registerWithCtrlsService();
    }, e.prototype.registerWithCtrlsService = function() {
      switch (this.name) {
        case we.CENTER:
          this.ctrlsService.registerCenterRowContainerCtrl(this);
          break;
        case we.LEFT:
          this.ctrlsService.registerLeftRowContainerCtrl(this);
          break;
        case we.RIGHT:
          this.ctrlsService.registerRightRowContainerCtrl(this);
          break;
        case we.TOP_CENTER:
          this.ctrlsService.registerTopCenterRowContainerCtrl(this);
          break;
        case we.TOP_LEFT:
          this.ctrlsService.registerTopLeftRowContainerCon(this);
          break;
        case we.TOP_RIGHT:
          this.ctrlsService.registerTopRightRowContainerCtrl(this);
          break;
        case we.BOTTOM_CENTER:
          this.ctrlsService.registerBottomCenterRowContainerCtrl(this);
          break;
        case we.BOTTOM_LEFT:
          this.ctrlsService.registerBottomLeftRowContainerCtrl(this);
          break;
        case we.BOTTOM_RIGHT:
          this.ctrlsService.registerBottomRightRowContainerCtrl(this);
          break;
      }
    }, e.prototype.forContainers = function(t, i) {
      t.indexOf(this.name) >= 0 && i();
    }, e.prototype.getContainerElement = function() {
      return this.eContainer;
    }, e.prototype.getViewportSizeFeature = function() {
      return this.viewportSizeFeature;
    }, e.prototype.setComp = function(t, i, r, o) {
      var s = this;
      this.comp = t, this.eContainer = i, this.eViewport = r, this.eWrapper = o, this.createManagedBean(new VY(this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder(), this.stopHScrollOnPinnedRows();
      var a = [we.TOP_CENTER, we.TOP_LEFT, we.TOP_RIGHT], l = [we.BOTTOM_CENTER, we.BOTTOM_LEFT, we.BOTTOM_RIGHT], u = [we.CENTER, we.LEFT, we.RIGHT], c = JY(a, l, u), h = [we.CENTER, we.LEFT, we.RIGHT, we.FULL_WIDTH], d = [we.CENTER, we.TOP_CENTER, we.BOTTOM_CENTER], f = [we.LEFT, we.BOTTOM_LEFT, we.TOP_LEFT], p = [we.RIGHT, we.BOTTOM_RIGHT, we.TOP_RIGHT];
      this.forContainers(f, function() {
        return s.createManagedBean(new UY(s.eContainer));
      }), this.forContainers(p, function() {
        return s.createManagedBean(new jY(s.eContainer));
      }), this.forContainers(h, function() {
        return s.createManagedBean(new KY(s.eContainer, s.eWrapper));
      }), this.forContainers(c, function() {
        return s.createManagedBean(new YY(s.eContainer));
      }), this.forContainers(d, function() {
        return s.createManagedBean(new Ux(function(g) {
          return s.comp.setContainerWidth(g + "px");
        }));
      });
    }, e.prototype.listenOnDomOrder = function() {
      var t = this, i = function() {
        return t.comp.setDomOrder(t.gridOptionsWrapper.isEnsureDomOrder());
      };
      this.addManagedListener(this.gridOptionsWrapper, He.PROP_DOM_LAYOUT, i), i();
    }, e.prototype.stopHScrollOnPinnedRows = function() {
      var t = this;
      this.forContainers([we.TOP_CENTER, we.BOTTOM_CENTER], function() {
        var i = function() {
          return t.eViewport.scrollLeft = 0;
        };
        t.addManagedListener(t.eViewport, "scroll", i);
      });
    }, e.prototype.onDisplayedColumnsChanged = function() {
      var t = this;
      this.forContainers([we.CENTER], function() {
        return t.onHorizontalViewportChanged();
      });
    }, e.prototype.onDisplayedColumnsWidthChanged = function() {
      var t = this;
      this.forContainers([we.CENTER], function() {
        return t.onHorizontalViewportChanged();
      });
    }, e.prototype.onScrollVisibilityChanged = function() {
      if (this.name === we.CENTER) {
        var t = this.scrollVisibleService.isHorizontalScrollShowing(), i = t && this.gridOptionsWrapper.getScrollbarWidth() || 0, r = i == 0 ? "100%" : "calc(100% + " + i + "px)";
        this.comp.setViewportHeight(r);
      }
    }, e.prototype.addPreventScrollWhileDragging = function() {
      var t = this, i = function(r) {
        t.dragService.isDragging() && r.cancelable && r.preventDefault();
      };
      this.eContainer.addEventListener("touchmove", i, { passive: !1 }), this.addDestroyFunc(function() {
        return t.eContainer.removeEventListener("touchmove", i);
      });
    }, e.prototype.onHorizontalViewportChanged = function() {
      var t = this.getCenterWidth(), i = this.getCenterViewportScrollLeft();
      this.columnModel.setViewportPosition(t, i);
    }, e.prototype.getCenterWidth = function() {
      return xS(this.eViewport);
    }, e.prototype.getCenterViewportScrollLeft = function() {
      return Uv(this.eViewport, this.enableRtl);
    }, e.prototype.registerViewportResizeListener = function(t) {
      var i = this.resizeObserverService.observeResize(this.eViewport, t);
      this.addDestroyFunc(function() {
        return i();
      });
    }, e.prototype.isViewportVisible = function() {
      return wg(this.eViewport);
    }, e.prototype.isViewportHScrollShowing = function() {
      return q1(this.eViewport);
    }, e.prototype.getViewportScrollLeft = function() {
      return Uv(this.eViewport, this.enableRtl);
    }, e.prototype.isHorizontalScrollShowing = function() {
      var t = this.gridOptionsWrapper.isAlwaysShowHorizontalScroll();
      return t || q1(this.eViewport);
    }, e.prototype.getViewportElement = function() {
      return this.eViewport;
    }, e.prototype.setContainerTranslateX = function(t) {
      this.eContainer.style.transform = "translateX(" + t + "px)";
    }, e.prototype.getHScrollPosition = function() {
      var t = {
        left: this.eViewport.scrollLeft,
        right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
      };
      return t;
    }, e.prototype.setCenterViewportScrollLeft = function(t) {
      Gw(this.eViewport, t, this.enableRtl);
    }, e.prototype.onDisplayedRowsChanged = function() {
      var t = this, i = this.name === we.TOP_FULL_WIDTH || this.name === we.BOTTOM_FULL_WIDTH || this.name === we.FULL_WIDTH, r = function(a) {
        var l = a.isFullWidth(), u = t.gridOptionsWrapper.getDomLayout() === Z.DOM_LAYOUT_PRINT, c = t.embedFullWidthRows || u, h = i ? !c && l : c || !l;
        return h;
      }, o = this.getRowCtrls(), s = o.filter(r);
      this.comp.setRowCtrls(s);
    }, e.prototype.getRowCtrls = function() {
      switch (this.name) {
        case we.TOP_CENTER:
        case we.TOP_LEFT:
        case we.TOP_RIGHT:
        case we.TOP_FULL_WIDTH:
          return this.rowRenderer.getTopRowCtrls();
        case we.BOTTOM_CENTER:
        case we.BOTTOM_LEFT:
        case we.BOTTOM_RIGHT:
        case we.BOTTOM_FULL_WIDTH:
          return this.rowRenderer.getBottomRowCtrls();
        default:
          return this.rowRenderer.getRowCtrls();
      }
    }, Wh([
      T("scrollVisibleService")
    ], e.prototype, "scrollVisibleService", void 0), Wh([
      T("dragService")
    ], e.prototype, "dragService", void 0), Wh([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Wh([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), Wh([
      T("resizeObserverService")
    ], e.prototype, "resizeObserverService", void 0), Wh([
      T("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), Wh([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var nX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), rX = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, oX = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(rX(arguments[e]));
  return n;
}, Wo;
(function(n) {
  n.Normal = "Normal", n.FullWidth = "FullWidth", n.FullWidthLoading = "FullWidthLoading", n.FullWidthGroup = "FullWidthGroup", n.FullWidthDetail = "FullWidthDetail";
})(Wo || (Wo = {}));
var sX = 0, Qc = (
  /** @class */
  function(n) {
    nX(e, n);
    function e(t, i, r, o, s, a) {
      var l = n.call(this) || this;
      return l.allRowGuis = [], l.active = !0, l.centerCellCtrls = { list: [], map: {} }, l.leftCellCtrls = { list: [], map: {} }, l.rightCellCtrls = { list: [], map: {} }, l.lastMouseDownOnDragger = !1, l.updateColumnListsPending = !1, l.parentScope = t, l.beans = r, l.rowNode = i, l.paginationPage = l.beans.paginationProxy.getCurrentPage(), l.useAnimationFrameForCreate = s, l.printLayout = a, l.instanceId = i.id + "-" + sX++, l.setAnimateFlags(o), l.rowFocused = l.beans.focusService.isRowFocused(l.rowNode.rowIndex, l.rowNode.rowPinned), l.setupAngular1Scope(), l.rowLevel = l.beans.rowCssClassCalculator.calculateRowLevel(l.rowNode), l.setRowType(), l.addListeners(), l.setInitialRowTop(), l;
    }
    return e.prototype.getBeans = function() {
      return this.beans;
    }, e.prototype.getInstanceId = function() {
      return this.instanceId;
    }, e.prototype.setComp = function(t, i, r) {
      var o = { rowComp: t, element: i, containerType: r };
      this.allRowGuis.push(o), r === Vo.LEFT ? this.leftGui = o : r === Vo.RIGHT ? this.rightGui = o : r === Vo.FULL_WIDTH ? this.fullWidthGui = o : this.centerGui = o;
      var s = this.leftGui != null && this.rightGui != null && this.centerGui != null, a = this.fullWidthGui != null;
      (s || a) && this.initialiseRowComps();
    }, e.prototype.isCacheable = function() {
      return this.rowType === Wo.FullWidthDetail && this.beans.gridOptionsWrapper.isKeepDetailRows();
    }, e.prototype.setCached = function(t) {
      var i = t ? "none" : "";
      this.allRowGuis.forEach(function(r) {
        return r.element.style.display = i;
      });
    }, e.prototype.initialiseRowComps = function() {
      var t = this, i = this.beans.gridOptionsWrapper;
      this.onRowHeightChanged(), this.updateRowIndexes(), this.setFocusedClasses(), this.setStylesFromGridOptions(), i.isRowSelection() && this.rowNode.selectable && this.onRowSelected(), this.updateColumnLists(!this.useAnimationFrameForCreate), this.slideRowIn && k1(this.onTopChanged.bind(this)), this.fadeRowIn && k1(function() {
        t.allRowGuis.forEach(function(a) {
          return a.rowComp.addOrRemoveCssClass("ag-opacity-zero", !1);
        });
      });
      var r = this.getRowBusinessKey(), o = ql(this.rowNode.id), s = ql(r);
      this.allRowGuis.forEach(function(a) {
        var l = a.rowComp;
        l.setRole("row");
        var u = t.getInitialRowClasses(a.containerType);
        u.forEach(function(c) {
          return l.addOrRemoveCssClass(c, !0);
        }), t.rowNode.group && bs(a.element, t.rowNode.expanded == !0), o != null && l.setRowId(o), s != null && l.setRowBusinessKey(s), t.isFullWidth() && !t.beans.gridOptionsWrapper.isSuppressCellFocus() && l.setTabIndex(-1), i.setDomData(a.element, e.DOM_DATA_KEY_ROW_CTRL, t), t.addDestroyFunc(function() {
          return i.setDomData(a.element, e.DOM_DATA_KEY_ROW_CTRL, null);
        }), t.useAnimationFrameForCreate ? t.beans.animationFrameService.createTask(t.addHoverFunctionality.bind(t, a.element), t.rowNode.rowIndex, "createTasksP2") : t.addHoverFunctionality(a.element), t.isFullWidth() && t.setupFullWidth(a), i.isRowDragEntireRow() && t.addRowDraggerToRow(a), t.useAnimationFrameForCreate && t.beans.animationFrameService.addDestroyTask(function() {
          t.isAlive() && a.rowComp.addOrRemoveCssClass("ag-after-created", !0);
        });
      }), this.executeProcessRowPostCreateFunc();
    }, e.prototype.addRowDraggerToRow = function(t) {
      var i = this.beans.gridOptionsWrapper;
      if (i.isEnableRangeSelection()) {
        mi(function() {
          console.warn("AG Grid: Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `enableRangeSelection: true`");
        }, "rowDragAndRangeSelectionEnabled");
        return;
      }
      var r = new Kw(function() {
        return "1 row";
      }, this.rowNode, void 0, t.element, void 0, !0);
      this.createManagedBean(r, this.beans.context);
    }, e.prototype.setupFullWidth = function(t) {
      var i = this.getPinnedForContainer(t.containerType), r = this.createFullWidthParams(t.element, i), o = gt.isRegistered(ht.MasterDetailModule);
      if (this.rowType == Wo.FullWidthDetail && !o) {
        gt.isPackageBased() ? console.warn("AG Grid: cell renderer 'agDetailCellRenderer' (for master detail) not found. Can only be used with ag-grid-enterprise package.") : console.warn("AG Grid: cell renderer 'agDetailCellRenderer' (for master detail) not found. Can only be used with AG Grid Enterprise Module " + ht.MasterDetailModule);
        return;
      }
      var s;
      switch (this.rowType) {
        case Wo.FullWidthDetail:
          s = this.beans.userComponentFactory.getFullWidthDetailCellRendererDetails(r);
          break;
        case Wo.FullWidthGroup:
          s = this.beans.userComponentFactory.getFullWidthGroupCellRendererDetails(r);
          break;
        case Wo.FullWidthLoading:
          s = this.beans.userComponentFactory.getFullWidthLoadingCellRendererDetails(r);
          break;
        default:
          s = this.beans.userComponentFactory.getFullWidthCellRendererDetails(r);
          break;
      }
      t.rowComp.showFullWidth(s);
    }, e.prototype.getScope = function() {
      return this.scope;
    }, e.prototype.isPrintLayout = function() {
      return this.printLayout;
    }, e.prototype.setupAngular1Scope = function() {
      var t = FY.createChildScopeOrNull(this.rowNode, this.parentScope, this.beans.gridOptionsWrapper);
      t && (this.scope = t.scope, this.addDestroyFunc(t.scopeDestroyFunc));
    }, e.prototype.getCellElement = function(t) {
      var i = this.getCellCtrl(t);
      return i ? i.getGui() : null;
    }, e.prototype.executeProcessRowPostCreateFunc = function() {
      var t = this.beans.gridOptionsWrapper.getProcessRowPostCreateFunc();
      if (t) {
        var i = {
          eRow: this.centerGui ? this.centerGui.element : void 0,
          ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
          ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
          node: this.rowNode,
          api: this.beans.gridOptionsWrapper.getApi(),
          rowIndex: this.rowNode.rowIndex,
          addRenderedRowListener: this.addEventListener.bind(this),
          columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
          context: this.beans.gridOptionsWrapper.getContext()
        };
        t(i);
      }
    }, e.prototype.setRowType = function() {
      var t = this.rowNode.stub, i = this.rowNode.isFullWidthCell(), r = this.beans.doingMasterDetail && this.rowNode.detail, o = this.beans.columnModel.isPivotMode(), s = !!this.rowNode.group && !this.rowNode.footer, a = s && this.beans.gridOptionsWrapper.isGroupUseEntireRow(o);
      t ? this.rowType = Wo.FullWidthLoading : r ? this.rowType = Wo.FullWidthDetail : i ? this.rowType = Wo.FullWidth : a ? this.rowType = Wo.FullWidthGroup : this.rowType = Wo.Normal;
    }, e.prototype.updateColumnLists = function(t) {
      var i = this;
      if (t === void 0 && (t = !1), !this.isFullWidth()) {
        var r = t || this.beans.gridOptionsWrapper.isSuppressAnimationFrame() || this.printLayout;
        if (r) {
          this.updateColumnListsImpl();
          return;
        }
        this.updateColumnListsPending || (this.beans.animationFrameService.createTask(function() {
          i.active && i.updateColumnListsImpl();
        }, this.rowNode.rowIndex, "createTasksP1"), this.updateColumnListsPending = !0);
      }
    }, e.prototype.createCellCtrls = function(t, i, r) {
      var o = this;
      r === void 0 && (r = null);
      var s = {
        list: [],
        map: {}
      }, a = function(l, u) {
        s.list.push(u), s.map[l] = u;
      };
      return i.forEach(function(l) {
        var u = l.getInstanceId(), c = t.map[u];
        c || (c = new Zc(l, o.rowNode, o.beans, o)), a(u, c);
      }), t.list.forEach(function(l) {
        var u = s.map[l.getColumn().getInstanceId()] != null;
        if (!u) {
          var c = !o.isCellEligibleToBeRemoved(l, r);
          if (c) {
            a(l.getColumn().getInstanceId(), l);
            return;
          }
          l.destroy();
        }
      }), s;
    }, e.prototype.updateColumnListsImpl = function() {
      var t = this;
      this.updateColumnListsPending = !1;
      var i = this.beans.columnModel;
      if (this.printLayout)
        this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, i.getAllDisplayedColumns()), this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} };
      else {
        var r = i.getViewportCenterColumnsForRow(this.rowNode);
        this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, r);
        var o = i.getDisplayedLeftColumnsForRow(this.rowNode);
        this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, o, Z.PINNED_LEFT);
        var s = i.getDisplayedRightColumnsForRow(this.rowNode);
        this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, s, Z.PINNED_RIGHT);
      }
      this.allRowGuis.forEach(function(a) {
        var l = a.containerType === Vo.LEFT ? t.leftCellCtrls : a.containerType === Vo.RIGHT ? t.rightCellCtrls : t.centerCellCtrls;
        a.rowComp.setCellCtrls(l.list);
      });
    }, e.prototype.isCellEligibleToBeRemoved = function(t, i) {
      var r = !0, o = !1, s = t.getColumn();
      if (s.getPinned() != i)
        return r;
      var a = t.isEditing(), l = this.beans.focusService.isCellFocused(t.getCellPosition()), u = a || l;
      if (u) {
        var c = t.getColumn(), h = this.beans.columnModel.getAllDisplayedColumns(), d = h.indexOf(c) >= 0;
        return d ? o : r;
      }
      return r;
    }, e.prototype.setAnimateFlags = function(t) {
      if (t) {
        var i = ge(this.rowNode.oldRowTop);
        this.slideRowIn = i, this.fadeRowIn = !i;
      } else
        this.slideRowIn = !1, this.fadeRowIn = !1;
    }, e.prototype.isEditing = function() {
      return this.editingRow;
    }, e.prototype.stopRowEditing = function(t) {
      this.stopEditing(t);
    }, e.prototype.isFullWidth = function() {
      return this.rowType !== Wo.Normal;
    }, e.prototype.getRowType = function() {
      return this.rowType;
    }, e.prototype.refreshFullWidth = function() {
      var t = this, i = function(u, c) {
        if (!u)
          return !0;
        var h = u.rowComp.getFullWidthCellRenderer();
        if (!h || !h.refresh)
          return !1;
        var d = t.createFullWidthParams(u.element, c), f = h.refresh(d);
        return f;
      }, r = i(this.fullWidthGui, null), o = i(this.centerGui, null), s = i(this.leftGui, Z.PINNED_LEFT), a = i(this.rightGui, Z.PINNED_RIGHT), l = r && o && s && a;
      return l;
    }, e.prototype.addListeners = function() {
      this.addManagedListener(this.rowNode, Wt.EVENT_HEIGHT_CHANGED, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_ROW_SELECTED, this.onRowSelected.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_ROW_INDEX_CHANGED, this.onRowIndexChanged.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_TOP_CHANGED, this.onTopChanged.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_EXPANDED_CHANGED, this.updateExpandedCss.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_HAS_CHILDREN_CHANGED, this.updateExpandedCss.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_DATA_CHANGED, this.onRowNodeDataChanged.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_CELL_CHANGED, this.onRowNodeCellChanged.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_HIGHLIGHT_CHANGED, this.onRowNodeHighlightChanged.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_DRAGGING_CHANGED, this.onRowNodeDraggingChanged.bind(this)), this.addManagedListener(this.rowNode, Wt.EVENT_UI_LEVEL_CHANGED, this.onUiLevelChanged.bind(this));
      var t = this.beans.eventService;
      this.addManagedListener(t, F.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED, this.onPaginationPixelOffsetChanged.bind(this)), this.addManagedListener(t, F.EVENT_HEIGHT_SCALE_CHANGED, this.onTopChanged.bind(this)), this.addManagedListener(t, F.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(t, F.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this)), this.addManagedListener(t, F.EVENT_CELL_FOCUSED, this.onCellFocusChanged.bind(this)), this.addManagedListener(t, F.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this)), this.addManagedListener(t, F.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this)), this.addManagedListener(t, F.EVENT_COLUMN_MOVED, this.onColumnMoved.bind(this)), this.addListenersForCellComps();
    }, e.prototype.onColumnMoved = function() {
      this.updateColumnLists();
    }, e.prototype.addListenersForCellComps = function() {
      var t = this;
      this.addManagedListener(this.rowNode, Wt.EVENT_ROW_INDEX_CHANGED, function() {
        t.getAllCellCtrls().forEach(function(i) {
          return i.onRowIndexChanged();
        });
      }), this.addManagedListener(this.rowNode, Wt.EVENT_CELL_CHANGED, function(i) {
        t.getAllCellCtrls().forEach(function(r) {
          return r.onCellChanged(i);
        });
      });
    }, e.prototype.onRowNodeDataChanged = function(t) {
      this.getAllCellCtrls().forEach(function(i) {
        return i.refreshCell({
          suppressFlash: !t.update,
          newData: !t.update
        });
      }), this.onRowSelected(), this.postProcessCss();
    }, e.prototype.onRowNodeCellChanged = function() {
      this.postProcessCss();
    }, e.prototype.postProcessCss = function() {
      this.setStylesFromGridOptions(), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), this.postProcessRowDragging();
    }, e.prototype.onRowNodeHighlightChanged = function() {
      var t = this.rowNode.highlighted;
      this.allRowGuis.forEach(function(i) {
        var r = t === Md.Above, o = t === Md.Below;
        i.rowComp.addOrRemoveCssClass("ag-row-highlight-above", r), i.rowComp.addOrRemoveCssClass("ag-row-highlight-below", o);
      });
    }, e.prototype.onRowNodeDraggingChanged = function() {
      this.postProcessRowDragging();
    }, e.prototype.postProcessRowDragging = function() {
      var t = this.rowNode.dragging;
      this.allRowGuis.forEach(function(i) {
        return i.rowComp.addOrRemoveCssClass("ag-row-dragging", t);
      });
    }, e.prototype.updateExpandedCss = function() {
      var t = this.rowNode.isExpandable(), i = this.rowNode.expanded == !0;
      this.allRowGuis.forEach(function(r) {
        r.rowComp.addOrRemoveCssClass("ag-row-group", t), r.rowComp.addOrRemoveCssClass("ag-row-group-expanded", t && i), r.rowComp.addOrRemoveCssClass("ag-row-group-contracted", t && !i), bs(r.element, t && i);
      });
    }, e.prototype.onDisplayedColumnsChanged = function() {
      this.updateColumnLists(!0), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights();
    }, e.prototype.onVirtualColumnsChanged = function() {
      this.updateColumnLists();
    }, e.prototype.getRowPosition = function() {
      return {
        rowPinned: this.rowNode.rowPinned,
        rowIndex: this.rowNode.rowIndex
      };
    }, e.prototype.onKeyboardNavigate = function(t) {
      var i = this.allRowGuis.find(function(u) {
        return u.element.contains(t.target);
      }), r = i ? i.element : null, o = r === t.target;
      if (o) {
        var s = this.rowNode, a = this.beans.focusService.getFocusedCell(), l = {
          rowIndex: s.rowIndex,
          rowPinned: s.rowPinned,
          column: a && a.column
        };
        this.beans.navigationService.navigateToNextCell(t, t.key, l, !0), t.preventDefault();
      }
    }, e.prototype.onTabKeyDown = function(t) {
      if (!(t.defaultPrevented || Hl(t))) {
        var i = this.allRowGuis.find(function(a) {
          return a.element.contains(t.target);
        }), r = i ? i.element : null, o = r === t.target, s = null;
        o || (s = this.beans.focusService.findNextFocusableElement(r, !1, t.shiftKey)), (this.isFullWidth() && o || !s) && this.beans.navigationService.onTabKeyDown(this, t);
      }
    }, e.prototype.onFullWidthRowFocused = function(t) {
      var i, r = this.rowNode, o = this.isFullWidth() && t.rowIndex === r.rowIndex && t.rowPinned == r.rowPinned, s = this.fullWidthGui ? this.fullWidthGui.element : (i = this.centerGui) === null || i === void 0 ? void 0 : i.element;
      s && (s.classList.toggle("ag-full-width-focus", o), o && s.focus({ preventScroll: !0 }));
    }, e.prototype.refreshCell = function(t) {
      this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, t), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, t), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, t), this.updateColumnLists();
    }, e.prototype.removeCellCtrl = function(t, i) {
      var r = {
        list: [],
        map: {}
      };
      return t.list.forEach(function(o) {
        o !== i && (r.list.push(o), r.map[o.getInstanceId()] = o);
      }), r;
    }, e.prototype.onMouseEvent = function(t, i) {
      switch (t) {
        case "dblclick":
          this.onRowDblClick(i);
          break;
        case "click":
          this.onRowClick(i);
          break;
        case "touchstart":
        case "mousedown":
          this.onRowMouseDown(i);
          break;
      }
    }, e.prototype.createRowEvent = function(t, i) {
      return {
        type: t,
        node: this.rowNode,
        data: this.rowNode.data,
        rowIndex: this.rowNode.rowIndex,
        rowPinned: this.rowNode.rowPinned,
        context: this.beans.gridOptionsWrapper.getContext(),
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        event: i
      };
    }, e.prototype.createRowEventWithSource = function(t, i) {
      var r = this.createRowEvent(t, i);
      return r.source = this, r;
    }, e.prototype.onRowDblClick = function(t) {
      if (!Hl(t)) {
        var i = this.createRowEventWithSource(F.EVENT_ROW_DOUBLE_CLICKED, t);
        this.beans.eventService.dispatchEvent(i);
      }
    }, e.prototype.onRowMouseDown = function(t) {
      if (this.lastMouseDownOnDragger = OS(t.target, "ag-row-drag", 3), !!this.isFullWidth()) {
        var i = this.rowNode, r = this.beans.columnModel;
        this.beans.focusService.setFocusedCell(i.rowIndex, r.getAllDisplayedColumns()[0], i.rowPinned, !0);
      }
    }, e.prototype.onRowClick = function(t) {
      var i = Hl(t) || this.lastMouseDownOnDragger;
      if (!i) {
        var r = this.createRowEventWithSource(F.EVENT_ROW_CLICKED, t);
        this.beans.eventService.dispatchEvent(r);
        var o = t.ctrlKey || t.metaKey, s = t.shiftKey, a = this.beans.gridOptionsWrapper.isGroupSelectsChildren();
        if (
          // we do not allow selecting groups by clicking (as the click here expands the group), or if it's a detail row,
          // so return if it's a group row
          !(a && this.rowNode.group || // this is needed so we don't unselect other rows when we click this row, eg if this row is not selectable,
          // and we click it, the selection should not change (ie any currently selected row should stay selected)
          !this.rowNode.selectable || // we also don't allow selection of pinned rows
          this.rowNode.rowPinned || // if no selection method enabled, do nothing
          !this.beans.gridOptionsWrapper.isRowSelection() || // if click selection suppressed, do nothing
          this.beans.gridOptionsWrapper.isSuppressRowClickSelection())
        ) {
          var l = this.beans.gridOptionsWrapper.isRowMultiSelectWithClick(), u = !this.beans.gridOptionsWrapper.isSuppressRowDeselection();
          if (this.rowNode.isSelected())
            l ? this.rowNode.setSelectedParams({ newValue: !1 }) : o ? u && this.rowNode.setSelectedParams({ newValue: !1 }) : this.rowNode.setSelectedParams({ newValue: !s, clearSelection: !s, rangeSelect: s });
          else {
            var c = l ? !1 : !o;
            this.rowNode.setSelectedParams({ newValue: !0, clearSelection: c, rangeSelect: s });
          }
        }
      }
    }, e.prototype.setupDetailRowAutoHeight = function(t) {
      var i = this;
      if (this.rowType === Wo.FullWidthDetail && this.beans.gridOptionsWrapper.isDetailRowAutoHeight()) {
        var r = function() {
          var s = t.clientHeight;
          if (s != null && s > 0) {
            var a = function() {
              i.rowNode.setRowHeight(s), i.beans.clientSideRowModel ? i.beans.clientSideRowModel.onRowHeightChanged() : i.beans.serverSideRowModel && i.beans.serverSideRowModel.onRowHeightChanged();
            };
            i.beans.frameworkOverrides.setTimeout(a, 0);
          }
        }, o = this.beans.resizeObserverService.observeResize(t, r);
        this.addDestroyFunc(o), r();
      }
    }, e.prototype.createFullWidthParams = function(t, i) {
      var r = this, o = {
        fullWidth: !0,
        data: this.rowNode.data,
        node: this.rowNode,
        value: this.rowNode.key,
        valueFormatted: this.rowNode.key,
        $scope: this.scope ? this.scope : this.parentScope,
        $compile: this.beans.$compile,
        rowIndex: this.rowNode.rowIndex,
        api: this.beans.gridOptionsWrapper.getApi(),
        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
        context: this.beans.gridOptionsWrapper.getContext(),
        // these need to be taken out, as part of 'afterAttached' now
        eGridCell: t,
        eParentOfValue: t,
        pinned: i,
        addRenderedRowListener: this.addEventListener.bind(this),
        registerRowDragger: function(s, a, l, u) {
          return r.addFullWidthRowDragging(s, a, l, u);
        }
      };
      return o;
    }, e.prototype.addFullWidthRowDragging = function(t, i, r, o) {
      if (r === void 0 && (r = ""), !!this.isFullWidth()) {
        var s = new Kw(function() {
          return r;
        }, this.rowNode, void 0, t, i, o);
        this.createManagedBean(s, this.beans.context);
      }
    }, e.prototype.onUiLevelChanged = function() {
      var t = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
      if (this.rowLevel != t) {
        var i = "ag-row-level-" + t, r = "ag-row-level-" + this.rowLevel;
        this.allRowGuis.forEach(function(o) {
          o.rowComp.addOrRemoveCssClass(i, !0), o.rowComp.addOrRemoveCssClass(r, !1);
        });
      }
      this.rowLevel = t;
    }, e.prototype.isFirstRowOnPage = function() {
      return this.rowNode.rowIndex === this.beans.paginationProxy.getPageFirstRow();
    }, e.prototype.isLastRowOnPage = function() {
      return this.rowNode.rowIndex === this.beans.paginationProxy.getPageLastRow();
    }, e.prototype.onModelUpdated = function() {
      this.refreshFirstAndLastRowStyles();
    }, e.prototype.refreshFirstAndLastRowStyles = function() {
      var t = this.isFirstRowOnPage(), i = this.isLastRowOnPage();
      this.firstRowOnPage !== t && (this.firstRowOnPage = t, this.allRowGuis.forEach(function(r) {
        return r.rowComp.addOrRemoveCssClass("ag-row-first", t);
      })), this.lastRowOnPage !== i && (this.lastRowOnPage = i, this.allRowGuis.forEach(function(r) {
        return r.rowComp.addOrRemoveCssClass("ag-row-last", i);
      }));
    }, e.prototype.stopEditing = function(t) {
      if (t === void 0 && (t = !1), this.getAllCellCtrls().forEach(function(r) {
        return r.stopEditing(t);
      }), !!this.editingRow) {
        if (!t) {
          var i = this.createRowEvent(F.EVENT_ROW_VALUE_CHANGED);
          this.beans.eventService.dispatchEvent(i);
        }
        this.setEditingRow(!1);
      }
    }, e.prototype.setInlineEditingCss = function(t) {
      this.allRowGuis.forEach(function(i) {
        i.rowComp.addOrRemoveCssClass("ag-row-inline-editing", t), i.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !t);
      });
    }, e.prototype.setEditingRow = function(t) {
      this.editingRow = t, this.allRowGuis.forEach(function(r) {
        return r.rowComp.addOrRemoveCssClass("ag-row-editing", t);
      });
      var i = t ? this.createRowEvent(F.EVENT_ROW_EDITING_STARTED) : this.createRowEvent(F.EVENT_ROW_EDITING_STOPPED);
      this.beans.eventService.dispatchEvent(i);
    }, e.prototype.startRowEditing = function(t, i, r, o) {
      t === void 0 && (t = null), i === void 0 && (i = null), r === void 0 && (r = null), o === void 0 && (o = null), !this.editingRow && (this.getAllCellCtrls().forEach(function(s) {
        var a = s === r;
        a ? s.startEditing(t, i, a, o) : s.startEditing(null, null, a, o);
      }), this.setEditingRow(!0));
    }, e.prototype.getAllCellCtrls = function() {
      var t = oX(this.centerCellCtrls.list, this.leftCellCtrls.list, this.rightCellCtrls.list);
      return t;
    }, e.prototype.postProcessClassesFromGridOptions = function() {
      var t = this, i = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode, this.scope);
      !i || !i.length || i.forEach(function(r) {
        t.allRowGuis.forEach(function(o) {
          return o.rowComp.addOrRemoveCssClass(r, !0);
        });
      });
    }, e.prototype.postProcessRowClassRules = function() {
      var t = this;
      this.beans.rowCssClassCalculator.processRowClassRules(this.rowNode, this.scope, function(i) {
        t.allRowGuis.forEach(function(r) {
          return r.rowComp.addOrRemoveCssClass(i, !0);
        });
      }, function(i) {
        t.allRowGuis.forEach(function(r) {
          return r.rowComp.addOrRemoveCssClass(i, !1);
        });
      });
    }, e.prototype.setStylesFromGridOptions = function() {
      var t = this.processStylesFromGridOptions();
      this.allRowGuis.forEach(function(i) {
        return i.rowComp.setUserStyles(t);
      });
    }, e.prototype.getRowBusinessKey = function() {
      var t = this.beans.gridOptionsWrapper.getBusinessKeyForNodeFunc();
      if (typeof t == "function")
        return t(this.rowNode);
    }, e.prototype.getPinnedForContainer = function(t) {
      var i = t === Vo.LEFT ? Z.PINNED_LEFT : t === Vo.RIGHT ? Z.PINNED_RIGHT : null;
      return i;
    }, e.prototype.getInitialRowClasses = function(t) {
      var i = this.getPinnedForContainer(t), r = {
        rowNode: this.rowNode,
        rowFocused: this.rowFocused,
        fadeRowIn: this.fadeRowIn,
        rowIsEven: this.rowNode.rowIndex % 2 === 0,
        rowLevel: this.rowLevel,
        fullWidthRow: this.isFullWidth(),
        firstRowOnPage: this.isFirstRowOnPage(),
        lastRowOnPage: this.isLastRowOnPage(),
        printLayout: this.printLayout,
        expandable: this.rowNode.isExpandable(),
        scope: this.scope,
        pinned: i
      };
      return this.beans.rowCssClassCalculator.getInitialRowClasses(r);
    }, e.prototype.processStylesFromGridOptions = function() {
      var t = this.beans.gridOptionsWrapper.getRowStyle();
      if (t && typeof t == "function") {
        console.warn("AG Grid: rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
        return;
      }
      var i = this.beans.gridOptionsWrapper.getRowStyleFunc(), r;
      if (i) {
        var o = {
          data: this.rowNode.data,
          node: this.rowNode,
          rowIndex: this.rowNode.rowIndex,
          $scope: this.scope,
          api: this.beans.gridOptionsWrapper.getApi(),
          columnApi: this.beans.gridOptionsWrapper.getColumnApi(),
          context: this.beans.gridOptionsWrapper.getContext()
        };
        r = i(o);
      }
      return Object.assign({}, t, r);
    }, e.prototype.onRowSelected = function() {
      var t = this, i = this.rowNode.isSelected();
      this.allRowGuis.forEach(function(r) {
        r.rowComp.addOrRemoveCssClass("ag-row-selected", i), $p(r.element, i ? !0 : void 0);
        var o = t.createAriaLabel();
        tf(r.element, o ?? "");
      });
    }, e.prototype.createAriaLabel = function() {
      var t = this.rowNode.isSelected();
      if (!(t && this.beans.gridOptionsWrapper.isSuppressRowDeselection())) {
        var i = this.beans.gridOptionsWrapper.getLocaleTextFunc(), r = i(t ? "ariaRowDeselect" : "ariaRowSelect", "Press SPACE to " + (t ? "deselect" : "select") + " this row.");
        return r;
      }
    }, e.prototype.isUseAnimationFrameForCreate = function() {
      return this.useAnimationFrameForCreate;
    }, e.prototype.addHoverFunctionality = function(t) {
      var i = this;
      this.active && (this.addManagedListener(t, "mouseenter", function() {
        return i.rowNode.onMouseEnter();
      }), this.addManagedListener(t, "mouseleave", function() {
        return i.rowNode.onMouseLeave();
      }), this.addManagedListener(this.rowNode, Wt.EVENT_MOUSE_ENTER, function() {
        i.beans.gridOptionsWrapper.isSuppressRowHoverHighlight() || t.classList.add("ag-row-hover");
      }), this.addManagedListener(this.rowNode, Wt.EVENT_MOUSE_LEAVE, function() {
        t.classList.remove("ag-row-hover");
      }));
    }, e.prototype.roundRowTopToBounds = function(t) {
      var i = this.beans.ctrlsService.getGridBodyCtrl(), r = i.getScrollFeature().getVScrollPosition(), o = this.applyPaginationOffset(r.top, !0) - 100, s = this.applyPaginationOffset(r.bottom, !0) + 100;
      return Math.min(Math.max(o, t), s);
    }, e.prototype.getFrameworkOverrides = function() {
      return this.beans.frameworkOverrides;
    }, e.prototype.onRowHeightChanged = function() {
      if (this.rowNode.rowHeight != null) {
        var t = this.beans.gridOptionsWrapper.isGetRowHeightFunction(), i = this.rowNode.rowHeight, r = this.beans.gridOptionsWrapper.getDefaultRowHeight();
        this.allRowGuis.forEach(function(o) {
          o.element.style.height = i + "px", t && o.element.style.setProperty("--ag-row-height", Math.min(r, i) - 2 + "px");
        });
      }
    }, e.prototype.addEventListener = function(t, i) {
      (t === "renderedRowRemoved" || t === "rowRemoved") && (t = F.EVENT_VIRTUAL_ROW_REMOVED, console.warn("AG Grid: Since version 11, event renderedRowRemoved is now called " + F.EVENT_VIRTUAL_ROW_REMOVED)), n.prototype.addEventListener.call(this, t, i);
    }, e.prototype.removeEventListener = function(t, i) {
      (t === "renderedRowRemoved" || t === "rowRemoved") && (t = F.EVENT_VIRTUAL_ROW_REMOVED, console.warn("AG Grid: Since version 11, event renderedRowRemoved and rowRemoved is now called " + F.EVENT_VIRTUAL_ROW_REMOVED)), n.prototype.removeEventListener.call(this, t, i);
    }, e.prototype.destroyFirstPass = function() {
      this.active = !1, this.setupRemoveAnimation();
      var t = this.createRowEvent(F.EVENT_VIRTUAL_ROW_REMOVED);
      this.dispatchEvent(t), this.beans.eventService.dispatchEvent(t), n.prototype.destroy.call(this);
    }, e.prototype.setupRemoveAnimation = function() {
      var t = this.rowNode.rowTop != null;
      if (t) {
        var i = this.roundRowTopToBounds(this.rowNode.rowTop);
        this.setRowTop(i);
      } else
        this.allRowGuis.forEach(function(r) {
          return r.rowComp.addOrRemoveCssClass("ag-opacity-zero", !0);
        });
    }, e.prototype.destroySecondPass = function() {
      this.allRowGuis.length = 0;
      var t = function(i) {
        return i.list.forEach(function(r) {
          return r.destroy();
        }), { list: [], map: {} };
      };
      this.centerCellCtrls = t(this.centerCellCtrls), this.leftCellCtrls = t(this.leftCellCtrls), this.rightCellCtrls = t(this.rightCellCtrls);
    }, e.prototype.setFocusedClasses = function() {
      var t = this;
      this.allRowGuis.forEach(function(i) {
        i.rowComp.addOrRemoveCssClass("ag-row-focus", t.rowFocused), i.rowComp.addOrRemoveCssClass("ag-row-no-focus", !t.rowFocused);
      });
    }, e.prototype.onCellFocusChanged = function() {
      var t = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
      t !== this.rowFocused && (this.rowFocused = t, this.setFocusedClasses()), !t && this.editingRow && this.stopEditing(!1);
    }, e.prototype.onPaginationChanged = function() {
      var t = this.beans.paginationProxy.getCurrentPage();
      this.paginationPage !== t && (this.paginationPage = t, this.onTopChanged()), this.refreshFirstAndLastRowStyles();
    }, e.prototype.onTopChanged = function() {
      this.setRowTop(this.rowNode.rowTop);
    }, e.prototype.onPaginationPixelOffsetChanged = function() {
      this.onTopChanged();
    }, e.prototype.applyPaginationOffset = function(t, i) {
      if (i === void 0 && (i = !1), this.rowNode.isRowPinned())
        return t;
      var r = this.beans.paginationProxy.getPixelOffset(), o = i ? 1 : -1;
      return t + r * o;
    }, e.prototype.setRowTop = function(t) {
      if (!this.printLayout && ge(t)) {
        var i = this.applyPaginationOffset(t), r = this.rowNode.isRowPinned() ? i : this.beans.rowContainerHeightService.getRealPixelPosition(i), o = r + "px";
        this.setRowTopStyle(o);
      }
    }, e.prototype.getInitialRowTop = function() {
      return this.initialTop;
    }, e.prototype.getInitialTransform = function() {
      return this.initialTransform;
    }, e.prototype.setInitialRowTop = function() {
      if (this.printLayout)
        return "";
      var t = this.slideRowIn ? this.roundRowTopToBounds(this.rowNode.oldRowTop) : this.rowNode.rowTop, i = this.applyPaginationOffset(t), r = this.rowNode.isRowPinned() ? i : this.beans.rowContainerHeightService.getRealPixelPosition(i), o = r + "px", s = this.beans.gridOptionsWrapper.isSuppressRowTransform();
      s ? this.initialTop = o : this.initialTransform = "translateY(" + o + ")";
    }, e.prototype.setRowTopStyle = function(t) {
      var i = this.beans.gridOptionsWrapper.isSuppressRowTransform();
      this.allRowGuis.forEach(function(r) {
        return i ? r.rowComp.setTop(t) : r.rowComp.setTransform("translateY(" + t + ")");
      });
    }, e.prototype.getRowNode = function() {
      return this.rowNode;
    }, e.prototype.getCellCtrl = function(t) {
      var i = null;
      return this.getAllCellCtrls().forEach(function(r) {
        r.getColumn() == t && (i = r);
      }), i != null || this.getAllCellCtrls().forEach(function(r) {
        r.getColSpanningList().indexOf(t) >= 0 && (i = r);
      }), i;
    }, e.prototype.onRowIndexChanged = function() {
      this.rowNode.rowIndex != null && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss());
    }, e.prototype.updateRowIndexes = function() {
      var t = this.rowNode.getRowIndexString(), i = this.beans.headerNavigationService.getHeaderRowCount(), r = this.rowNode.rowIndex % 2 === 0, o = i + this.rowNode.rowIndex + 1;
      this.allRowGuis.forEach(function(s) {
        s.rowComp.setRowIndex(t), s.rowComp.addOrRemoveCssClass("ag-row-even", r), s.rowComp.addOrRemoveCssClass("ag-row-odd", !r), Ox(s.element, o);
      });
    }, e.prototype.getPinnedLeftRowElement = function() {
      return this.leftGui ? this.leftGui.element : void 0;
    }, e.prototype.getPinnedRightRowElement = function() {
      return this.rightGui ? this.rightGui.element : void 0;
    }, e.prototype.getBodyRowElement = function() {
      return this.centerGui ? this.centerGui.element : void 0;
    }, e.prototype.getFullWidthRowElement = function() {
      return this.fullWidthGui ? this.fullWidthGui.element : void 0;
    }, e.DOM_DATA_KEY_ROW_CTRL = "renderedRow", e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var aX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), os = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, lX = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, iF = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(lX(arguments[e]));
  return n;
}, GH = (
  /** @class */
  function(n) {
    aX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.destroyFuncsForColumnListeners = [], t.rowCtrlsByRowIndex = {}, t.zombieRowCtrls = {}, t.allRowCtrls = [], t.topRowCtrls = [], t.bottomRowCtrls = [], t.refreshInProgress = !1, t;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function() {
        t.gridBodyCtrl = t.ctrlsService.getGridBodyCtrl(), t.initialise();
      });
    }, e.prototype.initialise = function() {
      this.addManagedListener(this.eventService, F.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this)), this.addManagedListener(this.eventService, F.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_BODY_SCROLL, this.redrawAfterScroll.bind(this)), this.addManagedListener(this.eventService, F.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this)), this.addManagedListener(this.gridOptionsWrapper, He.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this)), this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = this.gridOptionsWrapper.getDomLayout() === Z.DOM_LAYOUT_PRINT, this.embedFullWidthRows = this.printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows(), this.redrawAfterModelUpdate();
    }, e.prototype.initialiseCache = function() {
      if (this.gridOptionsWrapper.isKeepDetailRows()) {
        var t = this.gridOptionsWrapper.getKeepDetailRowsCount(), i = t ?? 3;
        this.cachedRowCtrls = new uX(i);
      }
    }, e.prototype.getRowCtrls = function() {
      return this.allRowCtrls;
    }, e.prototype.updateAllRowCtrls = function() {
      var t = Ja(this.rowCtrlsByRowIndex);
      this.gridOptionsWrapper.isEnsureDomOrder() && t.sort(function(o, s) {
        return o.getRowNode().rowIndex - s.getRowNode.rowIndex;
      });
      var i = Ja(this.zombieRowCtrls), r = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
      this.allRowCtrls = iF(t, i, r);
    }, e.prototype.registerCellEventListeners = function() {
      var t = this;
      this.addManagedListener(this.eventService, F.EVENT_CELL_FOCUSED, function(r) {
        t.getAllCellCtrls().forEach(function(o) {
          return o.onCellFocused(r);
        }), t.getFullWidthRowCtrls().forEach(function(o) {
          o.onFullWidthRowFocused(r);
        });
      }), this.addManagedListener(this.eventService, F.EVENT_FLASH_CELLS, function(r) {
        t.getAllCellCtrls().forEach(function(o) {
          return o.onFlashCells(r);
        });
      }), this.addManagedListener(this.eventService, F.EVENT_COLUMN_HOVER_CHANGED, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.onColumnHover();
        });
      }), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.onDisplayedColumnsChanged();
        });
      }), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, function() {
        t.printLayout && t.getAllCellCtrls().forEach(function(r) {
          return r.onLeftChanged();
        });
      });
      var i = this.gridOptionsWrapper.isEnableRangeSelection();
      i && (this.addManagedListener(this.eventService, F.EVENT_RANGE_SELECTION_CHANGED, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.onRangeSelectionChanged();
        });
      }), this.addManagedListener(this.eventService, F.EVENT_COLUMN_MOVED, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.updateRangeBordersIfRangeCount();
        });
      }), this.addManagedListener(this.eventService, F.EVENT_COLUMN_PINNED, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.updateRangeBordersIfRangeCount();
        });
      }), this.addManagedListener(this.eventService, F.EVENT_COLUMN_VISIBLE, function() {
        t.getAllCellCtrls().forEach(function(r) {
          return r.updateRangeBordersIfRangeCount();
        });
      })), this.refreshListenersToColumnsForCellComps(), this.addManagedListener(this.eventService, F.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this)), this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
    }, e.prototype.removeGridColumnListeners = function() {
      this.destroyFuncsForColumnListeners.forEach(function(t) {
        return t();
      }), this.destroyFuncsForColumnListeners.length = 0;
    }, e.prototype.refreshListenersToColumnsForCellComps = function() {
      var t = this;
      this.removeGridColumnListeners();
      var i = this.columnModel.getAllGridColumns();
      i && i.forEach(function(r) {
        var o = function(c) {
          t.getAllCellCtrls().forEach(function(h) {
            h.getColumn() === r && c(h);
          });
        }, s = function() {
          o(function(c) {
            return c.onLeftChanged();
          });
        }, a = function() {
          o(function(c) {
            return c.onWidthChanged();
          });
        }, l = function() {
          o(function(c) {
            return c.onFirstRightPinnedChanged();
          });
        }, u = function() {
          o(function(c) {
            return c.onLastLeftPinnedChanged();
          });
        };
        r.addEventListener(Gt.EVENT_LEFT_CHANGED, s), r.addEventListener(Gt.EVENT_WIDTH_CHANGED, a), r.addEventListener(Gt.EVENT_FIRST_RIGHT_PINNED_CHANGED, l), r.addEventListener(Gt.EVENT_LAST_LEFT_PINNED_CHANGED, u), t.destroyFuncsForColumnListeners.push(function() {
          r.removeEventListener(Gt.EVENT_LEFT_CHANGED, s), r.removeEventListener(Gt.EVENT_WIDTH_CHANGED, a), r.removeEventListener(Gt.EVENT_FIRST_RIGHT_PINNED_CHANGED, l), r.removeEventListener(Gt.EVENT_LAST_LEFT_PINNED_CHANGED, u);
        });
      });
    }, e.prototype.onDomLayoutChanged = function() {
      var t = this.gridOptionsWrapper.getDomLayout() === Z.DOM_LAYOUT_PRINT, i = t || this.gridOptionsWrapper.isEmbedFullWidthRows(), r = i !== this.embedFullWidthRows || this.printLayout !== t;
      this.printLayout = t, this.embedFullWidthRows = i, r && this.redrawAfterModelUpdate();
    }, e.prototype.datasourceChanged = function() {
      this.firstRenderedRow = 0, this.lastRenderedRow = -1;
      var t = Object.keys(this.rowCtrlsByRowIndex);
      this.removeRowCtrls(t);
    }, e.prototype.onPageLoaded = function(t) {
      var i = {
        recycleRows: t.keepRenderedRows,
        animate: t.animate,
        newData: t.newData,
        newPage: t.newPage,
        // because this is a model updated event (not pinned rows), we
        // can skip updating the pinned rows. this is needed so that if user
        // is doing transaction updates, the pinned rows are not getting constantly
        // trashed - or editing cells in pinned rows are not refreshed and put into read mode
        onlyBody: !0
      };
      this.redrawAfterModelUpdate(i);
    }, e.prototype.getAllCellsForColumn = function(t) {
      var i = [];
      return this.getAllRowCtrls().forEach(function(r) {
        var o = r.getCellElement(t);
        o && i.push(o);
      }), i;
    }, e.prototype.refreshFloatingRowComps = function() {
      this.refreshFloatingRows(this.topRowCtrls, this.pinnedRowModel.getPinnedTopRowData()), this.refreshFloatingRows(this.bottomRowCtrls, this.pinnedRowModel.getPinnedBottomRowData());
    }, e.prototype.getTopRowCtrls = function() {
      return this.topRowCtrls;
    }, e.prototype.getBottomRowCtrls = function() {
      return this.bottomRowCtrls;
    }, e.prototype.refreshFloatingRows = function(t, i) {
      var r = this;
      t.forEach(function(o) {
        o.destroyFirstPass(), o.destroySecondPass();
      }), t.length = 0, i && i.forEach(function(o) {
        var s = new Qc(r.$scope, o, r.beans, !1, !1, r.printLayout);
        t.push(s);
      });
    }, e.prototype.onPinnedRowDataChanged = function() {
      var t = {
        recycleRows: !0
      };
      this.redrawAfterModelUpdate(t);
    }, e.prototype.getRenderedIndexesForRowNodes = function(t) {
      var i = [];
      return Je(t) || pi(this.rowCtrlsByRowIndex, function(r, o) {
        var s = o.getRowNode();
        t.indexOf(s) >= 0 && i.push(r);
      }), i;
    }, e.prototype.redrawRows = function(t) {
      var i = t != null && t.length > 0;
      if (i) {
        var r = this.getRenderedIndexesForRowNodes(t);
        this.removeRowCtrls(r);
      }
      this.redrawAfterModelUpdate({
        recycleRows: i
      });
    }, e.prototype.getCellToRestoreFocusToAfterRefresh = function(t) {
      var i = t.suppressKeepFocus ? null : this.focusService.getFocusCellToUseAfterRefresh();
      if (i == null)
        return null;
      var r = this.gridOptionsWrapper.getDocument(), o = r.activeElement, s = this.gridOptionsWrapper.getDomData(o, Zc.DOM_DATA_KEY_CELL_CTRL), a = this.gridOptionsWrapper.getDomData(o, Qc.DOM_DATA_KEY_ROW_CTRL), l = s || a;
      return l ? i : null;
    }, e.prototype.redrawAfterModelUpdate = function(t) {
      t === void 0 && (t = {}), this.getLockOnRefresh();
      var i = this.getCellToRestoreFocusToAfterRefresh(t);
      this.updateContainerHeights(), this.scrollToTopIfNewData(t);
      var r = !this.printLayout && !!t.recycleRows, o = t.animate && this.gridOptionsWrapper.isAnimateRows(), s = r ? this.recycleRows() : null;
      r || this.removeAllRowComps();
      var a = function() {
        if (i == null || s == null)
          return !1;
        var u = !1;
        return pi(s, function(c, h) {
          var d = h.getRowNode(), f = d.rowIndex == i.rowIndex, p = d.rowPinned == i.rowPinned;
          f && p && (u = !0);
        }), u;
      }, l = a();
      this.redraw(s, o), t.onlyBody || this.refreshFloatingRowComps(), this.dispatchDisplayedRowsChanged(), l || this.restoreFocusedCell(i), this.releaseLockOnRefresh();
    }, e.prototype.scrollToTopIfNewData = function(t) {
      var i = t.newData || t.newPage, r = this.gridOptionsWrapper.isSuppressScrollOnNewData();
      i && !r && this.gridBodyCtrl.getScrollFeature().scrollToTop();
    }, e.prototype.updateContainerHeights = function() {
      if (this.printLayout) {
        this.rowContainerHeightService.setModelHeight(null);
        return;
      }
      var t = this.paginationProxy.getCurrentPageHeight();
      t === 0 && (t = 1), this.rowContainerHeightService.setModelHeight(t);
    }, e.prototype.getLockOnRefresh = function() {
      if (this.refreshInProgress)
        throw new Error("AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace.");
      this.refreshInProgress = !0;
    }, e.prototype.releaseLockOnRefresh = function() {
      this.refreshInProgress = !1;
    }, e.prototype.restoreFocusedCell = function(t) {
      t && this.focusService.setFocusedCell(t.rowIndex, t.column, t.rowPinned, !0);
    }, e.prototype.stopEditing = function(t) {
      t === void 0 && (t = !1), this.getAllRowCtrls().forEach(function(i) {
        i.stopEditing(t);
      });
    }, e.prototype.onNewColumnsLoaded = function() {
      this.getAllCellCtrls().forEach(function(t) {
        return t.onNewColumnsLoaded();
      });
    }, e.prototype.getAllCellCtrls = function() {
      var t = [];
      return this.getAllRowCtrls().forEach(function(i) {
        return t = t.concat(i.getAllCellCtrls());
      }), t;
    }, e.prototype.getAllRowCtrls = function() {
      var t = this, i = iF(this.topRowCtrls, this.bottomRowCtrls);
      return Object.keys(this.rowCtrlsByRowIndex).forEach(function(r) {
        return i.push(t.rowCtrlsByRowIndex[r]);
      }), i;
    }, e.prototype.addRenderedRowListener = function(t, i, r) {
      var o = this.rowCtrlsByRowIndex[i];
      o && o.addEventListener(t, r);
    }, e.prototype.flashCells = function(t) {
      t === void 0 && (t = {});
      var i = t.flashDelay, r = t.fadeDelay;
      this.getCellCtrls(t.rowNodes, t.columns).forEach(function(o) {
        return o.flashCell({ flashDelay: i, fadeDelay: r });
      });
    }, e.prototype.refreshCells = function(t) {
      t === void 0 && (t = {});
      var i = {
        forceRefresh: t.force,
        newData: !1,
        suppressFlash: t.suppressFlash
      };
      this.getCellCtrls(t.rowNodes, t.columns).forEach(function(r) {
        if (r.refreshShouldDestroy()) {
          var o = r.getRowCtrl();
          o && o.refreshCell(r);
        } else
          r.refreshCell(i);
      }), this.getFullWidthRowCtrls(t.rowNodes).forEach(function(r) {
        r.refreshFullWidth();
      });
    }, e.prototype.getCellRendererInstances = function(t) {
      var i = this.getCellCtrls(t.rowNodes, t.columns).map(function(r) {
        return r.getCellRenderer();
      }).filter(function(r) {
        return r != null;
      });
      return i;
    }, e.prototype.getCellEditorInstances = function(t) {
      var i = [];
      return this.getCellCtrls(t.rowNodes, t.columns).forEach(function(r) {
        var o = r.getCellEditor();
        o && i.push(o);
      }), i;
    }, e.prototype.getEditingCells = function() {
      var t = [];
      return this.getAllCellCtrls().forEach(function(i) {
        if (i.isEditing()) {
          var r = i.getCellPosition();
          t.push(r);
        }
      }), t;
    }, e.prototype.mapRowNodes = function(t) {
      if (t) {
        var i = {
          top: {},
          bottom: {},
          normal: {}
        };
        return t.forEach(function(r) {
          var o = r.id;
          r.rowPinned === Z.PINNED_TOP ? i.top[o] = r : r.rowPinned === Z.PINNED_BOTTOM ? i.bottom[o] = r : i.normal[o] = r;
        }), i;
      }
    }, e.prototype.isRowInMap = function(t, i) {
      var r = t.id, o = t.rowPinned;
      return o === Z.PINNED_BOTTOM ? i.bottom[r] != null : o === Z.PINNED_TOP ? i.top[r] != null : i.normal[r] != null;
    }, e.prototype.getCellCtrls = function(t, i) {
      var r = this, o = this.mapRowNodes(t), s = [], a;
      ge(i) && (a = {}, i.forEach(function(u) {
        var c = r.columnModel.getGridColumn(u);
        ge(c) && (a[c.getId()] = !0);
      }));
      var l = function(u) {
        var c = u.getRowNode();
        o != null && !r.isRowInMap(c, o) || u.getAllCellCtrls().forEach(function(h) {
          var d = h.getColumn().getId(), f = a && !a[d];
          f || s.push(h);
        });
      };
      return pi(this.rowCtrlsByRowIndex, function(u, c) {
        l(c);
      }), this.topRowCtrls && this.topRowCtrls.forEach(l), this.bottomRowCtrls && this.bottomRowCtrls.forEach(l), s;
    }, e.prototype.destroy = function() {
      this.removeAllRowComps(), n.prototype.destroy.call(this);
    }, e.prototype.removeAllRowComps = function() {
      var t = Object.keys(this.rowCtrlsByRowIndex);
      this.removeRowCtrls(t);
    }, e.prototype.recycleRows = function() {
      var t = [];
      pi(this.rowCtrlsByRowIndex, function(r, o) {
        var s = o.getRowNode().id == null;
        s && t.push(r);
      }), this.removeRowCtrls(t);
      var i = {};
      return pi(this.rowCtrlsByRowIndex, function(r, o) {
        var s = o.getRowNode();
        i[s.id] = o;
      }), this.rowCtrlsByRowIndex = {}, i;
    }, e.prototype.removeRowCtrls = function(t) {
      var i = this;
      t.forEach(function(r) {
        var o = i.rowCtrlsByRowIndex[r];
        o && (o.destroyFirstPass(), o.destroySecondPass()), delete i.rowCtrlsByRowIndex[r];
      });
    }, e.prototype.redrawAfterScroll = function() {
      this.getLockOnRefresh(), this.redraw(null, !1, !0), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged();
    }, e.prototype.removeRowCompsNotToDraw = function(t) {
      var i = {};
      t.forEach(function(s) {
        return i[s] = !0;
      });
      var r = Object.keys(this.rowCtrlsByRowIndex), o = r.filter(function(s) {
        return !i[s];
      });
      this.removeRowCtrls(o);
    }, e.prototype.calculateIndexesToDraw = function(t) {
      var i = this, r = dH(this.firstRenderedRow, this.lastRenderedRow), o = function(s, a) {
        var l = a.getRowNode().rowIndex;
        l != null && (l < i.firstRenderedRow || l > i.lastRenderedRow) && i.doNotUnVirtualiseRow(a) && r.push(l);
      };
      return pi(this.rowCtrlsByRowIndex, o), pi(t, o), r.sort(function(s, a) {
        return s - a;
      }), r;
    }, e.prototype.redraw = function(t, i, r) {
      var o = this;
      i === void 0 && (i = !1), r === void 0 && (r = !1), this.rowContainerHeightService.updateOffset(), this.workOutFirstAndLastRowsToRender();
      var s = this.calculateIndexesToDraw(t);
      if (this.removeRowCompsNotToDraw(s), this.printLayout && (i = !1), s.forEach(function(l) {
        var u = o.createOrUpdateRowCtrl(l, t, i, r);
        ge(u);
      }), t) {
        var a = r && !this.gridOptionsWrapper.isSuppressAnimationFrame() && !this.printLayout;
        a ? this.beans.animationFrameService.addDestroyTask(function() {
          o.destroyRowCtrls(t, i), o.updateAllRowCtrls(), o.dispatchDisplayedRowsChanged();
        }) : this.destroyRowCtrls(t, i);
      }
      this.updateAllRowCtrls(), this.checkAngularCompile(), this.gridBodyCtrl.updateRowCount();
    }, e.prototype.dispatchDisplayedRowsChanged = function() {
      var t = { type: F.EVENT_DISPLAYED_ROWS_CHANGED };
      this.eventService.dispatchEvent(t);
    }, e.prototype.onDisplayedColumnsChanged = function() {
      var t = this.columnModel.isPinningLeft(), i = this.columnModel.isPinningRight(), r = this.pinningLeft !== t || i !== this.pinningRight;
      r && (this.pinningLeft = t, this.pinningRight = i, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows());
    }, e.prototype.redrawFullWidthEmbeddedRows = function() {
      var t = [];
      this.getFullWidthRowCtrls().forEach(function(i) {
        var r = i.getRowNode().rowIndex;
        t.push(r.toString());
      }), this.refreshFloatingRowComps(), this.removeRowCtrls(t), this.redrawAfterScroll();
    }, e.prototype.getFullWidthRowCtrls = function(t) {
      var i = this, r = this.mapRowNodes(t);
      return Ja(this.rowCtrlsByRowIndex).filter(function(o) {
        if (!o.isFullWidth())
          return !1;
        var s = o.getRowNode();
        return !(r != null && !i.isRowInMap(s, r));
      });
    }, e.prototype.refreshFullWidthRows = function(t) {
      var i = [], r = !!t, o = r ? {} : void 0;
      r && o && t.forEach(function(s) {
        return o[s.id] = !0;
      }), this.getFullWidthRowCtrls().forEach(function(s) {
        var a = s.getRowNode();
        if (r && o) {
          var l = a.level > 0 && a.parent ? a.parent.id : void 0, u = !o[a.id] && !o[l];
          if (u)
            return;
        }
        var c = s.refreshFullWidth();
        if (!c) {
          var h = s.getRowNode().rowIndex;
          i.push(h.toString());
        }
      }), this.removeRowCtrls(i), this.redrawAfterScroll();
    }, e.prototype.createOrUpdateRowCtrl = function(t, i, r, o) {
      var s, a = this.rowCtrlsByRowIndex[t];
      a || (s = this.paginationProxy.getRow(t), ge(s) && ge(i) && i[s.id] && s.alreadyRendered && (a = i[s.id], i[s.id] = null));
      var l = !a;
      if (l)
        if (s || (s = this.paginationProxy.getRow(t)), ge(s))
          a = this.createRowCon(s, r, o);
        else
          return;
      return s && (s.alreadyRendered = !0), this.rowCtrlsByRowIndex[t] = a, a;
    }, e.prototype.destroyRowCtrls = function(t, i) {
      var r = this, o = [];
      pi(t, function(s, a) {
        if (a) {
          if (r.cachedRowCtrls && a.isCacheable()) {
            r.cachedRowCtrls.addRow(a);
            return;
          }
          a.destroyFirstPass(), i ? (r.zombieRowCtrls[a.getInstanceId()] = a, o.push(function() {
            a.destroySecondPass(), delete r.zombieRowCtrls[a.getInstanceId()];
          })) : a.destroySecondPass();
        }
      }), i && (o.push(function() {
        r.updateAllRowCtrls(), r.dispatchDisplayedRowsChanged();
      }), yB(o));
    }, e.prototype.checkAngularCompile = function() {
      var t = this;
      this.gridOptionsWrapper.isAngularCompileRows() && window.setTimeout(function() {
        t.$scope.$apply();
      }, 0);
    }, e.prototype.workOutFirstAndLastRowsToRender = function() {
      var t = this, i, r;
      if (!this.paginationProxy.isRowsToRender())
        i = 0, r = -1;
      else if (this.printLayout)
        i = this.paginationProxy.getPageFirstRow(), r = this.paginationProxy.getPageLastRow();
      else {
        var o = this.gridOptionsWrapper.getRowBufferInPixels(), s = this.ctrlsService.getGridBodyCtrl(), a = this.gridOptionsWrapper.isSuppressRowVirtualisation(), l = !1, u = void 0, c = void 0;
        do {
          var h = this.paginationProxy.getPixelOffset(), d = this.paginationProxy.getCurrentPagePixelRange(), f = d.pageFirstPixel, p = d.pageLastPixel, g = this.rowContainerHeightService.getDivStretchOffset();
          if (a)
            u = f + g, c = p + g;
          else {
            var _ = s.getScrollFeature().getVScrollPosition(), m = _.top, v = _.bottom;
            u = Math.max(m + h - o, f) + g, c = Math.min(v + h + o, p) + g;
          }
          l = this.ensureAllRowsInRangeHaveHeightsCalculated(u, c);
        } while (l);
        var C = this.paginationProxy.getRowIndexAtPixel(u), y = this.paginationProxy.getRowIndexAtPixel(c), w = this.paginationProxy.getPageFirstRow(), L = this.paginationProxy.getPageLastRow();
        C < w && (C = w), y > L && (y = L), i = C, r = y;
      }
      var S = this.gridOptionsWrapper.getDomLayout() === Z.DOM_LAYOUT_NORMAL, E = this.gridOptionsWrapper.isSuppressMaxRenderedRowRestriction(), D = Math.max(this.gridOptionsWrapper.getRowBuffer(), 500);
      S && !E && r - i > D && (r = i + D);
      var x = i !== this.firstRenderedRow, R = r !== this.lastRenderedRow;
      if (x || R) {
        this.firstRenderedRow = i, this.lastRenderedRow = r;
        var A = {
          type: F.EVENT_VIEWPORT_CHANGED,
          firstRow: i,
          lastRow: r,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(A);
      }
      if (this.paginationProxy.isRowsToRender()) {
        var M = {
          type: F.EVENT_FIRST_DATA_RENDERED,
          firstRow: i,
          lastRow: r,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        window.setTimeout(function() {
          return t.eventService.dispatchEventOnce(M);
        }, 50);
      }
    }, e.prototype.ensureAllRowsInRangeHaveHeightsCalculated = function(t, i) {
      var r = this.paginationProxy.ensureRowHeightsValid(t, i, -1, -1);
      return r && this.updateContainerHeights(), r;
    }, e.prototype.getFirstVirtualRenderedRow = function() {
      return this.firstRenderedRow;
    }, e.prototype.getLastVirtualRenderedRow = function() {
      return this.lastRenderedRow;
    }, e.prototype.doNotUnVirtualiseRow = function(t) {
      var i = !1, r = !0, o = t.getRowNode(), s = this.focusService.isRowNodeFocused(o), a = t.isEditing(), l = o.detail, u = s || a || l;
      if (!u)
        return i;
      var c = this.paginationProxy.isRowPresent(o);
      return c ? r : i;
    }, e.prototype.createRowCon = function(t, i, r) {
      var o = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(t) : null;
      if (o)
        return o;
      var s = this.gridOptionsWrapper.isSuppressAnimationFrame(), a = r && !s && !this.printLayout, l = new Qc(this.$scope, t, this.beans, i, a, this.printLayout);
      return l;
    }, e.prototype.getRenderedNodes = function() {
      var t = this.rowCtrlsByRowIndex;
      return Object.keys(t).map(function(i) {
        return t[i].getRowNode();
      });
    }, e.prototype.getRowByPosition = function(t) {
      var i;
      switch (t.rowPinned) {
        case Z.PINNED_TOP:
          i = this.topRowCtrls[t.rowIndex];
          break;
        case Z.PINNED_BOTTOM:
          i = this.bottomRowCtrls[t.rowIndex];
          break;
        default:
          i = this.rowCtrlsByRowIndex[t.rowIndex];
          break;
      }
      return i;
    }, e.prototype.getRowNode = function(t) {
      switch (t.rowPinned) {
        case Z.PINNED_TOP:
          return this.pinnedRowModel.getPinnedTopRowData()[t.rowIndex];
        case Z.PINNED_BOTTOM:
          return this.pinnedRowModel.getPinnedBottomRowData()[t.rowIndex];
        default:
          return this.rowModel.getRow(t.rowIndex);
      }
    }, e.prototype.isRangeInRenderedViewport = function(t, i) {
      var r = t == null || i == null;
      if (r)
        return !1;
      var o = t > this.lastRenderedRow, s = i < this.firstRenderedRow, a = !s && !o;
      return a;
    }, os([
      T("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), os([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), os([
      T("$scope")
    ], e.prototype, "$scope", void 0), os([
      T("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), os([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), os([
      T("focusService")
    ], e.prototype, "focusService", void 0), os([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), os([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), os([
      T("beans")
    ], e.prototype, "beans", void 0), os([
      T("rowContainerHeightService")
    ], e.prototype, "rowContainerHeightService", void 0), os([
      fi("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), os([
      Le
    ], e.prototype, "postConstruct", null), e = os([
      qe("rowRenderer")
    ], e), e;
  }(Se)
), uX = (
  /** @class */
  function() {
    function n(e) {
      this.entriesMap = {}, this.entriesList = [], this.maxCount = e;
    }
    return n.prototype.addRow = function(e) {
      if (this.entriesMap[e.getRowNode().id] = e, this.entriesList.push(e), e.setCached(!0), this.entriesList.length > this.maxCount) {
        var t = this.entriesList[0];
        t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t);
      }
    }, n.prototype.getRow = function(e) {
      if (e == null || e.id == null)
        return null;
      var t = this.entriesMap[e.id];
      if (!t)
        return null;
      this.removeFromCache(t), t.setCached(!1);
      var i = t.getRowNode() != e;
      return i ? null : t;
    }, n.prototype.removeFromCache = function(e) {
      var t = e.getRowNode().id;
      delete this.entriesMap[t], Zr(this.entriesList, e);
    }, n.prototype.getEntries = function() {
      return this.entriesList;
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var cX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), zx = (
  /** @class */
  function(n) {
    cX(e, n);
    function e(t, i) {
      var r = n.call(this, t) || this;
      return r.ctrl = i, r;
    }
    return e.prototype.getCtrl = function() {
      return this.ctrl;
    }, e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var hX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), RL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, dX = (
  /** @class */
  function(n) {
    hX(e, n);
    function e(t) {
      var i = n.call(this, e.TEMPLATE, t) || this;
      return i.headerCompVersion = 0, i.column = t.getColumnGroupChild(), i.pinned = t.getPinned(), i;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.getGui(), r = function(a, l, u) {
        var c = u || i;
        l != null && l != "" ? c.setAttribute(a, l) : c.removeAttribute(a);
      }, o = {
        setWidth: function(a) {
          return i.style.width = a;
        },
        addOrRemoveCssClass: function(a, l) {
          return t.addOrRemoveCssClass(a, l);
        },
        setAriaSort: function(a) {
          return a ? uH(i, a) : cH(i);
        },
        setColId: function(a) {
          return r("col-id", a);
        },
        setTitle: function(a) {
          return r("title", a);
        },
        setAriaDescribedBy: function(a) {
          return IS(i, a);
        },
        setUserCompDetails: function(a) {
          return t.setUserCompDetails(a);
        },
        getUserCompInstance: function() {
          return t.headerComp;
        }
      };
      this.ctrl.setComp(o, this.getGui(), this.eResize);
      var s = this.ctrl.getSelectAllGui();
      this.eResize.insertAdjacentElement("afterend", s);
    }, e.prototype.destroyHeaderComp = function() {
      this.headerComp && (this.getGui().removeChild(this.headerCompGui), this.headerComp = this.destroyBean(this.headerComp), this.headerCompGui = void 0);
    }, e.prototype.setUserCompDetails = function(t) {
      var i = this;
      this.headerCompVersion++;
      var r = this.headerCompVersion;
      t.newAgStackInstance().then(function(o) {
        return i.afterCompCreated(r, o);
      });
    }, e.prototype.afterCompCreated = function(t, i) {
      if (t != this.headerCompVersion || !this.isAlive()) {
        this.destroyBean(i);
        return;
      }
      this.destroyHeaderComp(), this.headerComp = i, this.headerCompGui = i.getGui(), this.getGui().appendChild(this.headerCompGui), this.ctrl.setDragSource(this.headerCompGui);
    }, e.TEMPLATE = `<div class="ag-header-cell" role="columnheader" tabindex="-1">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
        </div>`, RL([
      ve("eResize")
    ], e.prototype, "eResize", void 0), RL([
      Le
    ], e.prototype, "postConstruct", null), RL([
      To
    ], e.prototype, "destroyHeaderComp", null), e;
  }(zx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var fX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), TL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, pX = (
  /** @class */
  function(n) {
    fX(e, n);
    function e(t) {
      return n.call(this, e.TEMPLATE, t) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.getGui(), r = function(s, a) {
        return a != null ? i.setAttribute(s, a) : i.removeAttribute(s);
      }, o = {
        addOrRemoveCssClass: function(s, a) {
          return t.addOrRemoveCssClass(s, a);
        },
        addOrRemoveResizableCssClass: function(s, a) {
          return t.eResize.classList.toggle(s, a);
        },
        setWidth: function(s) {
          return i.style.width = s;
        },
        setColId: function(s) {
          return i.setAttribute("col-id", s);
        },
        setAriaExpanded: function(s) {
          return r("aria-expanded", s);
        },
        setTitle: function(s) {
          return r("title", s);
        },
        setUserCompDetails: function(s) {
          return t.setUserCompDetails(s);
        }
      };
      this.ctrl.setComp(o, i, this.eResize);
    }, e.prototype.setUserCompDetails = function(t) {
      var i = this;
      t.newAgStackInstance().then(function(r) {
        return i.afterHeaderCompCreated(r);
      });
    }, e.prototype.afterHeaderCompCreated = function(t) {
      var i = this, r = function() {
        return i.destroyBean(t);
      };
      if (!this.isAlive()) {
        r();
        return;
      }
      this.getGui().appendChild(t.getGui()), this.addDestroyFunc(r), this.ctrl.setDragSource(t.getGui());
    }, e.TEMPLATE = `<div class="ag-header-group-cell" role="columnheader" tabindex="-1">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
        </div>`, TL([
      T("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), TL([
      ve("eResize")
    ], e.prototype, "eResize", void 0), TL([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(zx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), HC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, UH = (
  /** @class */
  function(n) {
    gX(e, n);
    function e(t) {
      return n.call(this, e.TEMPLATE, t) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.getGui(), r = {
        addOrRemoveCssClass: function(o, s) {
          return t.addOrRemoveCssClass(o, s);
        },
        addOrRemoveBodyCssClass: function(o, s) {
          return t.eFloatingFilterBody.classList.toggle(o, s);
        },
        addOrRemoveButtonWrapperCssClass: function(o, s) {
          return t.eButtonWrapper.classList.toggle(o, s);
        },
        setCompDetails: function(o) {
          return t.setCompDetails(o);
        },
        getFloatingFilterComp: function() {
          return t.compPromise;
        },
        setWidth: function(o) {
          return i.style.width = o;
        },
        setMenuIcon: function(o) {
          return t.eButtonShowMainFilter.appendChild(o);
        }
      };
      this.ctrl.setComp(r, i, this.eButtonShowMainFilter, this.eFloatingFilterBody);
    }, e.prototype.setCompDetails = function(t) {
      var i = this;
      this.compPromise = t.newAgStackInstance(), this.compPromise.then(function(r) {
        return i.afterCompCreated(r);
      });
    }, e.prototype.afterCompCreated = function(t) {
      var i = this;
      t && (this.addDestroyFunc(function() {
        return i.context.destroyBean(t);
      }), this.isAlive() && (this.eFloatingFilterBody.appendChild(t.getGui()), t.afterGuiAttached && t.afterGuiAttached()));
    }, e.TEMPLATE = `<div class="ag-header-cell ag-floating-filter" role="gridcell" tabindex="-1">
            <div ref="eFloatingFilterBody" role="presentation"></div>
            <div class="ag-floating-filter-button ag-hidden" ref="eButtonWrapper" role="presentation">
                <button type="button" aria-label="Open Filter Menu" class="ag-floating-filter-button-button" ref="eButtonShowMainFilter" tabindex="-1"></button>
            </div>
        </div>`, HC([
      ve("eFloatingFilterBody")
    ], e.prototype, "eFloatingFilterBody", void 0), HC([
      ve("eButtonWrapper")
    ], e.prototype, "eButtonWrapper", void 0), HC([
      ve("eButtonShowMainFilter")
    ], e.prototype, "eButtonShowMainFilter", void 0), HC([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(zx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var mX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), nF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Jr;
(function(n) {
  n.COLUMN_GROUP = "group", n.COLUMN = "column", n.FLOATING_FILTER = "filter";
})(Jr || (Jr = {}));
var zH = (
  /** @class */
  function(n) {
    mX(e, n);
    function e(t) {
      var i = n.call(this) || this;
      i.headerComps = {};
      var r = t.getType() == Jr.COLUMN_GROUP ? "ag-header-row-column-group" : t.getType() == Jr.FLOATING_FILTER ? "ag-header-row-column-filter" : "ag-header-row-column";
      return i.setTemplate(
        /* html */
        '<div class="ag-header-row ' + r + '" role="row"></div>'
      ), i.ctrl = t, i;
    }
    return e.prototype.init = function() {
      var t = this, i = {
        setTransform: function(r) {
          return t.getGui().style.transform = r;
        },
        setHeight: function(r) {
          return t.getGui().style.height = r;
        },
        setTop: function(r) {
          return t.getGui().style.top = r;
        },
        setHeaderCtrls: function(r) {
          return t.setHeaderCtrls(r);
        },
        setWidth: function(r) {
          return t.getGui().style.width = r;
        },
        setAriaRowIndex: function(r) {
          return Ox(t.getGui(), r);
        }
      };
      this.ctrl.setComp(i);
    }, e.prototype.destroyHeaderCtrls = function() {
      this.setHeaderCtrls([]);
    }, e.prototype.setHeaderCtrls = function(t) {
      var i = this;
      if (this.isAlive()) {
        var r = this.headerComps;
        this.headerComps = {}, t.forEach(function(l) {
          var u = l.getInstanceId(), c = r[u];
          delete r[u], c == null && (c = i.createHeaderComp(l), i.getGui().appendChild(c.getGui())), i.headerComps[u] = c;
        }), pi(r, function(l, u) {
          i.getGui().removeChild(u.getGui()), i.destroyBean(u);
        });
        var o = this.gridOptionsWrapper.isEnsureDomOrder();
        if (o) {
          var s = Ja(this.headerComps);
          s.sort(function(l, u) {
            var c = l.getCtrl().getColumnGroupChild().getLeft(), h = u.getCtrl().getColumnGroupChild().getLeft();
            return c - h;
          });
          var a = s.map(function(l) {
            return l.getGui();
          });
          bx(this.getGui(), a);
        }
      }
    }, e.prototype.createHeaderComp = function(t) {
      var i;
      switch (this.ctrl.getType()) {
        case Jr.COLUMN_GROUP:
          i = new pX(t);
          break;
        case Jr.FLOATING_FILTER:
          i = new UH(t);
          break;
        default:
          i = new dX(t);
          break;
      }
      return this.createBean(i), i.setParentComponent(this), i;
    }, nF([
      Le
    ], e.prototype, "init", null), nF([
      To
    ], e.prototype, "destroyHeaderCtrls", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var vX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Df = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Ha;
(function(n) {
  n[n.UP = 0] = "UP", n[n.DOWN = 1] = "DOWN", n[n.LEFT = 2] = "LEFT", n[n.RIGHT = 3] = "RIGHT";
})(Ha || (Ha = {}));
var jH = (
  /** @class */
  function(n) {
    vX(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        t.gridBodyCon = i.gridBodyCtrl;
      });
    }, e.prototype.getHeaderRowCount = function() {
      var t = this.ctrlsService.getHeaderRowContainerCtrl();
      return t ? t.getRowCount() : 0;
    }, e.prototype.getHeaderRowType = function(t) {
      var i = this.ctrlsService.getHeaderRowContainerCtrl();
      if (i)
        return i.getRowType(t);
    }, e.prototype.navigateVertically = function(t, i, r) {
      if (i || (i = this.focusService.getFocusedHeader()), !i)
        return !1;
      var o = i.headerRowIndex, s = i.column, a = this.getHeaderRowCount(), l = t === Ha.UP, u = l ? o - 1 : o + 1, c = null, h = !1;
      u < 0 && (u = 0, c = s, h = !0), u >= a && (u = -1);
      var d = this.getHeaderRowType(o);
      if (!h) {
        if (d === Jr.COLUMN_GROUP) {
          var f = s;
          c = l ? s.getParent() : f.getDisplayedChildren()[0];
        } else if (d === Jr.FLOATING_FILTER)
          c = s;
        else {
          var f = s;
          c = l ? f.getParent() : f;
        }
        if (!c)
          return !1;
      }
      return this.focusService.focusHeaderPosition({
        headerPosition: { headerRowIndex: u, column: c },
        allowUserOverride: !0,
        event: r
      });
    }, e.prototype.navigateHorizontally = function(t, i, r) {
      i === void 0 && (i = !1);
      var o = this.focusService.getFocusedHeader(), s = t === Ha.LEFT, a = this.gridOptionsWrapper.isEnableRtl(), l, u;
      return s !== a ? (u = "Before", l = this.headerPositionUtils.findHeader(o, u)) : (u = "After", l = this.headerPositionUtils.findHeader(o, u)), l ? this.focusService.focusHeaderPosition({
        headerPosition: l,
        direction: u,
        fromTab: i,
        allowUserOverride: !0,
        event: r
      }) : i ? this.focusNextHeaderRow(o, u, r) : !0;
    }, e.prototype.focusNextHeaderRow = function(t, i, r) {
      var o = t.headerRowIndex, s = null, a;
      return i === "Before" ? o > 0 && (a = o - 1, s = this.headerPositionUtils.findColAtEdgeForHeaderRow(a, "end")) : (a = o + 1, s = this.headerPositionUtils.findColAtEdgeForHeaderRow(a, "start")), this.focusService.focusHeaderPosition({
        headerPosition: s,
        direction: i,
        fromTab: !0,
        allowUserOverride: !0,
        event: r
      });
    }, e.prototype.scrollToColumn = function(t, i) {
      if (i === void 0 && (i = "After"), !t.getPinned()) {
        var r;
        if (t instanceof Qr) {
          var o = t.getDisplayedLeafColumns();
          r = i === "Before" ? Ti(o) : o[0];
        } else
          r = t;
        this.gridBodyCon.getScrollFeature().ensureColumnVisible(r), this.gridBodyCon.getScrollFeature().horizontallyScrollHeaderCenterAndFloatingCenter(), this.animationFrameService.flushAllFrames();
      }
    }, Df([
      T("focusService")
    ], e.prototype, "focusService", void 0), Df([
      T("headerPositionUtils")
    ], e.prototype, "headerPositionUtils", void 0), Df([
      T("animationFrameService")
    ], e.prototype, "animationFrameService", void 0), Df([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Df([
      Le
    ], e.prototype, "postConstruct", null), e = Df([
      qe("headerNavigationService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var _X = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), GC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, $H = (
  /** @class */
  function(n) {
    _X(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setComp = function(t, i, r) {
      this.comp = t, this.eGui = i, this.createManagedBean(new nc(r, {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })), this.addManagedListener(this.eventService, F.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this)), this.onPivotModeChanged(), this.setupHeaderHeight(), this.ctrlsService.registerGridHeaderCtrl(this);
    }, e.prototype.setupHeaderHeight = function() {
      var t = this.setHeaderHeight.bind(this);
      t(), this.addManagedListener(this.gridOptionsWrapper, He.PROP_HEADER_HEIGHT, t), this.addManagedListener(this.gridOptionsWrapper, He.PROP_PIVOT_HEADER_HEIGHT, t), this.addManagedListener(this.gridOptionsWrapper, He.PROP_GROUP_HEADER_HEIGHT, t), this.addManagedListener(this.gridOptionsWrapper, He.PROP_PIVOT_GROUP_HEADER_HEIGHT, t), this.addManagedListener(this.gridOptionsWrapper, He.PROP_FLOATING_FILTERS_HEIGHT, t), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, t);
    }, e.prototype.setHeaderHeight = function() {
      var t = this, i = t.columnModel, r = t.gridOptionsWrapper, o = 0, s = i.getHeaderRowCount(), a, l, u;
      if (i.isPivotMode())
        l = r.getPivotGroupHeaderHeight(), u = r.getPivotHeaderHeight();
      else {
        var c = i.hasFloatingFilters();
        c && (s++, o = 1), l = r.getGroupHeaderHeight(), u = r.getHeaderHeight();
      }
      var h = 1 + o, d = s - h;
      a = o * r.getFloatingFiltersHeight(), a += d * l, a += u;
      var f = a + 1 + "px";
      this.comp.setHeightAndMinHeight(f);
    }, e.prototype.onPivotModeChanged = function() {
      var t = this.columnModel.isPivotMode();
      this.comp.addOrRemoveCssClass("ag-pivot-on", t), this.comp.addOrRemoveCssClass("ag-pivot-off", !t);
    }, e.prototype.onTabKeyDown = function(t) {
      var i = this.gridOptionsWrapper.isEnableRtl(), r = t.shiftKey !== i ? Ha.LEFT : Ha.RIGHT;
      (this.headerNavigationService.navigateHorizontally(r, !0, t) || this.focusService.focusNextGridCoreContainer(t.shiftKey)) && t.preventDefault();
    }, e.prototype.handleKeyDown = function(t) {
      var i = null;
      switch (t.key) {
        case _e.LEFT:
          i = Ha.LEFT;
        case _e.RIGHT:
          ge(i) || (i = Ha.RIGHT), this.headerNavigationService.navigateHorizontally(i, !1, t);
          break;
        case _e.UP:
          i = Ha.UP;
        case _e.DOWN:
          ge(i) || (i = Ha.DOWN), this.headerNavigationService.navigateVertically(i, null, t) && t.preventDefault();
          break;
        default:
          return;
      }
    }, e.prototype.onFocusOut = function(t) {
      var i = this.gridOptionsWrapper.getDocument(), r = t.relatedTarget;
      !r && this.eGui.contains(i.activeElement) || this.eGui.contains(r) || this.focusService.clearFocusedHeader();
    }, GC([
      T("headerNavigationService")
    ], e.prototype, "headerNavigationService", void 0), GC([
      T("focusService")
    ], e.prototype, "focusService", void 0), GC([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), GC([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, KH = (
  /** @class */
  function() {
    function n(e, t) {
      this.needToMoveLeft = !1, this.needToMoveRight = !1, this.pinned = e, this.eContainer = t, this.centerContainer = !ge(e);
    }
    return n.prototype.init = function() {
      var e = this;
      this.ctrlsService.whenReady(function() {
        e.gridBodyCon = e.ctrlsService.getGridBodyCtrl();
      });
    }, n.prototype.getIconName = function() {
      return this.pinned ? wo.ICON_PINNED : wo.ICON_MOVE;
    }, n.prototype.onDragEnter = function(e) {
      var t = e.dragItem.columns, i = e.dragSource.type === Ds.ToolPanel;
      if (i)
        this.setColumnsVisible(t, !0, "uiColumnDragged");
      else {
        var r = e.dragItem.visibleState, o = (t || []).filter(function(s) {
          return r[s.getId()];
        });
        this.setColumnsVisible(o, !0, "uiColumnDragged");
      }
      this.setColumnsPinned(t, this.pinned, "uiColumnDragged"), this.onDragging(e, !0);
    }, n.prototype.onDragLeave = function(e) {
      var t = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !e.fromNudge;
      if (t) {
        var i = e.dragSource.getDragItem(), r = i.columns;
        this.setColumnsVisible(r, !1, "uiColumnDragged");
      }
      this.ensureIntervalCleared();
    }, n.prototype.setColumnsVisible = function(e, t, i) {
      if (i === void 0 && (i = "api"), e) {
        var r = e.filter(function(o) {
          return !o.getColDef().lockVisible;
        });
        this.columnModel.setColumnsVisible(r, t, i);
      }
    }, n.prototype.setColumnsPinned = function(e, t, i) {
      if (i === void 0 && (i = "api"), e) {
        var r = e.filter(function(o) {
          return !o.getColDef().lockPinned;
        });
        this.columnModel.setColumnsPinned(r, t, i);
      }
    }, n.prototype.onDragStop = function() {
      this.ensureIntervalCleared();
    }, n.prototype.normaliseX = function(e) {
      if (this.gridOptionsWrapper.isEnableRtl()) {
        var t = this.eContainer.clientWidth;
        e = t - e;
      }
      return this.centerContainer && (e += this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft()), e;
    }, n.prototype.checkCenterForScrolling = function(e) {
      if (this.centerContainer) {
        var t = this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft(), i = t + this.ctrlsService.getCenterRowContainerCtrl().getCenterWidth();
        this.gridOptionsWrapper.isEnableRtl() ? (this.needToMoveRight = e < t + 50, this.needToMoveLeft = e > i - 50) : (this.needToMoveLeft = e < t + 50, this.needToMoveRight = e > i - 50), this.needToMoveLeft || this.needToMoveRight ? this.ensureIntervalStarted() : this.ensureIntervalCleared();
      }
    }, n.prototype.onDragging = function(e, t) {
      var i = this;
      if (t === void 0 && (t = !1), this.lastDraggingEvent = e, !Je(e.hDirection)) {
        var r = this.normaliseX(e.x);
        t || this.checkCenterForScrolling(r);
        var o = this.normaliseDirection(e.hDirection), s = e.dragSource.type, a = e.dragSource.getDragItem().columns;
        a = a.filter(function(l) {
          return l.getColDef().lockPinned ? l.getPinned() == i.pinned : !0;
        }), this.attemptMoveColumns(s, a, o, r, t);
      }
    }, n.prototype.normaliseDirection = function(e) {
      if (this.gridOptionsWrapper.isEnableRtl())
        switch (e) {
          case Ba.Left:
            return Ba.Right;
          case Ba.Right:
            return Ba.Left;
          default:
            console.error("AG Grid: Unknown direction " + e);
        }
      else
        return e;
    }, n.prototype.calculateOldIndex = function(e) {
      var t = this.columnModel.getAllGridColumns(), i = RB(e.map(function(l) {
        return t.indexOf(l);
      })), r = i[0], o = Ti(i), s = o - r, a = s !== i.length - 1;
      return a ? null : r;
    }, n.prototype.attemptMoveColumns = function(e, t, i, r, o) {
      var s = i === Ba.Left, a = i === Ba.Right, l = t.slice();
      this.columnModel.sortColumnsLikeGridColumns(l);
      var u = this.calculateValidMoves(l, a, r), c = this.calculateOldIndex(l);
      if (u.length !== 0) {
        var h = u[0], d = c !== null && !o;
        if (e == Ds.HeaderCell && (d = c !== null), !(d && (s && h >= c || a && h <= c)))
          for (var f = 0; f < u.length; f++) {
            var p = u[f];
            if (this.columnModel.doesMovePassRules(l, p)) {
              this.columnModel.moveColumns(l, p, "uiColumnDragged");
              return;
            }
          }
      }
    }, n.prototype.calculateValidMoves = function(e, t, i) {
      var r = this.gridOptionsWrapper.isSuppressMovableColumns() || e.some(function(S) {
        return S.getColDef().suppressMovable;
      });
      if (r)
        return [];
      var o = this.columnModel.getDisplayedColumns(this.pinned), s = this.columnModel.getAllGridColumns(), a = o.filter(function(S) {
        return Es(e, S);
      }), l = o.filter(function(S) {
        return !Es(e, S);
      }), u = s.filter(function(S) {
        return !Es(e, S);
      }), c = 0, h = i;
      if (t) {
        var d = 0;
        a.forEach(function(S) {
          return d += S.getActualWidth();
        }), h -= d;
      }
      if (h > 0) {
        for (var f = 0; f < l.length; f++) {
          var p = l[f];
          if (h -= p.getActualWidth(), h < 0)
            break;
          c++;
        }
        t && c++;
      }
      var g;
      if (c > 0) {
        var _ = l[c - 1];
        g = u.indexOf(_) + 1;
      } else
        g = u.indexOf(l[0]), g === -1 && (g = 0);
      var m = [g], v = function(S, E) {
        return S - E;
      };
      if (t) {
        for (var C = g + 1, y = s.length - 1; C <= y; )
          m.push(C), C++;
        m.sort(v);
      } else {
        for (var C = g, y = s.length - 1, w = s[C]; C <= y && this.isColumnHidden(o, w); )
          C++, m.push(C), w = s[C];
        C = g - 1;
        for (var L = 0; C >= L; )
          m.push(C), C--;
        m.sort(v).reverse();
      }
      return m;
    }, n.prototype.isColumnHidden = function(e, t) {
      return e.indexOf(t) < 0;
    }, n.prototype.ensureIntervalStarted = function() {
      this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100), this.needToMoveLeft ? this.dragAndDropService.setGhostIcon(wo.ICON_LEFT, !0) : this.dragAndDropService.setGhostIcon(wo.ICON_RIGHT, !0));
    }, n.prototype.ensureIntervalCleared = function() {
      this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.dragAndDropService.setGhostIcon(wo.ICON_MOVE));
    }, n.prototype.moveInterval = function() {
      var e;
      this.intervalCount++, e = 10 + this.intervalCount * 5, e > 100 && (e = 100);
      var t = null, i = this.gridBodyCon.getScrollFeature();
      if (this.needToMoveLeft ? t = i.scrollHorizontally(-e) : this.needToMoveRight && (t = i.scrollHorizontally(e)), t !== 0)
        this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
      else {
        this.failedMoveAttempts++;
        var r = this.lastDraggingEvent.dragItem.columns, o = r.filter(function(a) {
          return !a.getColDef().lockPinned;
        });
        if (o.length > 0 && (this.dragAndDropService.setGhostIcon(wo.ICON_PINNED), this.failedMoveAttempts > 7)) {
          var s = this.needToMoveLeft ? Z.PINNED_LEFT : Z.PINNED_RIGHT;
          this.setColumnsPinned(o, s, "uiColumnDragged"), this.dragAndDropService.nudge();
        }
      }
    }, gm([
      T("columnModel")
    ], n.prototype, "columnModel", void 0), gm([
      T("dragAndDropService")
    ], n.prototype, "dragAndDropService", void 0), gm([
      T("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), gm([
      T("ctrlsService")
    ], n.prototype, "ctrlsService", void 0), gm([
      Le
    ], n.prototype, "init", null), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var rF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, qH = (
  /** @class */
  function() {
    function n(e) {
      this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [], this.pinned = e;
    }
    return n.prototype.onDragEnter = function(e) {
      var t = this;
      if (this.clearColumnsList(), !this.gridOptionsWrapper.isFunctionsReadOnly()) {
        var i = e.dragItem.columns;
        i && i.forEach(function(r) {
          r.isPrimary() && (r.isAnyFunctionActive() || (r.isAllowValue() ? t.columnsToAggregate.push(r) : r.isAllowRowGroup() ? t.columnsToGroup.push(r) : r.isAllowPivot() && t.columnsToPivot.push(r)));
        });
      }
    }, n.prototype.getIconName = function() {
      var e = this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length;
      return e > 0 ? this.pinned ? wo.ICON_PINNED : wo.ICON_MOVE : null;
    }, n.prototype.onDragLeave = function(e) {
      this.clearColumnsList();
    }, n.prototype.clearColumnsList = function() {
      this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0;
    }, n.prototype.onDragging = function(e) {
    }, n.prototype.onDragStop = function(e) {
      this.columnsToAggregate.length > 0 && this.columnModel.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop"), this.columnsToGroup.length > 0 && this.columnModel.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop"), this.columnsToPivot.length > 0 && this.columnModel.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop");
    }, rF([
      T("columnModel")
    ], n.prototype, "columnModel", void 0), rF([
      T("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var CX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), mm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, YH = (
  /** @class */
  function(n) {
    CX(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.pinned = t, r.eContainer = i, r;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        switch (t.pinned) {
          case Z.PINNED_LEFT:
            t.eSecondaryContainers = [
              [i.gridBodyCtrl.getBodyViewportElement(), i.leftRowContainerCtrl.getContainerElement()],
              [i.bottomLeftRowContainerCtrl.getContainerElement()],
              [i.topLeftRowContainerCtrl.getContainerElement()]
            ];
            break;
          case Z.PINNED_RIGHT:
            t.eSecondaryContainers = [
              [i.gridBodyCtrl.getBodyViewportElement(), i.rightRowContainerCtrl.getContainerElement()],
              [i.bottomRightRowContainerCtrl.getContainerElement()],
              [i.topRightRowContainerCtrl.getContainerElement()]
            ];
            break;
          default:
            t.eSecondaryContainers = [
              [i.gridBodyCtrl.getBodyViewportElement(), i.centerRowContainerCtrl.getViewportElement()],
              [i.bottomCenterRowContainerCtrl.getViewportElement()],
              [i.topCenterRowContainerCtrl.getViewportElement()]
            ];
            break;
        }
      });
    }, e.prototype.isInterestedIn = function(t) {
      return t === Ds.HeaderCell || t === Ds.ToolPanel && this.gridOptionsWrapper.isAllowDragFromColumnsToolPanel();
    }, e.prototype.getSecondaryContainers = function() {
      return this.eSecondaryContainers;
    }, e.prototype.getContainer = function() {
      return this.eContainer;
    }, e.prototype.init = function() {
      this.moveColumnFeature = this.createManagedBean(new KH(this.pinned, this.eContainer)), this.bodyDropPivotTarget = this.createManagedBean(new qH(this.pinned)), this.dragAndDropService.addDropTarget(this);
    }, e.prototype.getIconName = function() {
      return this.currentDropListener.getIconName();
    }, e.prototype.isDropColumnInPivotMode = function(t) {
      return this.columnModel.isPivotMode() && t.dragSource.type === Ds.ToolPanel;
    }, e.prototype.onDragEnter = function(t) {
      this.currentDropListener = this.isDropColumnInPivotMode(t) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(t);
    }, e.prototype.onDragLeave = function(t) {
      this.currentDropListener.onDragLeave(t);
    }, e.prototype.onDragging = function(t) {
      this.currentDropListener.onDragging(t);
    }, e.prototype.onDragStop = function(t) {
      this.currentDropListener.onDragStop(t);
    }, mm([
      T("dragAndDropService")
    ], e.prototype, "dragAndDropService", void 0), mm([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), mm([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), mm([
      Le
    ], e.prototype, "postConstruct", null), mm([
      Le
    ], e.prototype, "init", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var yX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wX = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, bX = 0, P_ = (
  /** @class */
  function(n) {
    yX(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.lastFocusEvent = null, r.columnGroupChild = t, r.parentRowCtrl = i, r.instanceId = t.getUniqueId() + "-" + bX++, r;
    }
    return e.prototype.shouldStopEventPropagation = function(t) {
      var i = this.focusService.getFocusedHeader(), r = i.headerRowIndex, o = i.column;
      return CH(this.gridOptionsWrapper, t, r, o);
    }, e.prototype.setGui = function(t) {
      this.eGui = t, this.addDomData();
    }, e.prototype.addDomData = function() {
      var t = this, i = e.DOM_DATA_KEY_HEADER_CTRL;
      this.gridOptionsWrapper.setDomData(this.eGui, i, this), this.addDestroyFunc(function() {
        return t.gridOptionsWrapper.setDomData(t.eGui, i, null);
      });
    }, e.prototype.getGui = function() {
      return this.eGui;
    }, e.prototype.focus = function(t) {
      return this.eGui ? (this.lastFocusEvent = t || null, this.eGui.focus(), !0) : !1;
    }, e.prototype.getRowIndex = function() {
      return this.parentRowCtrl.getRowIndex();
    }, e.prototype.getParentRowCtrl = function() {
      return this.parentRowCtrl;
    }, e.prototype.getPinned = function() {
      return this.parentRowCtrl.getPinned();
    }, e.prototype.getInstanceId = function() {
      return this.instanceId;
    }, e.prototype.getColumnGroupChild = function() {
      return this.columnGroupChild;
    }, e.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl", wX([
      T("focusService")
    ], e.prototype, "focusService", void 0), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var _p;
(function(n) {
  n[n.SINGLE_SHEET = 0] = "SINGLE_SHEET", n[n.MULTI_SHEET = 1] = "MULTI_SHEET";
})(_p || (_p = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var oa;
(function(n) {
  n.EVERYTHING = "group", n.FILTER = "filter", n.SORT = "sort", n.MAP = "map", n.AGGREGATE = "aggregate", n.PIVOT = "pivot", n.NOTHING = "nothing";
})(oa || (oa = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Ht = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
};
function Kh(n) {
  var e = n, t = e != null && e.getFrameworkComponentInstance != null;
  return t ? e.getFrameworkComponentInstance() : n;
}
var XH = (
  /** @class */
  function() {
    function n() {
      this.detailGridInfoMap = {}, this.destroyCalled = !1;
    }
    return n.prototype.registerOverlayWrapperComp = function(e) {
      this.overlayWrapperComp = e;
    }, n.prototype.registerSideBarComp = function(e) {
      this.sideBarComp = e;
    }, n.prototype.init = function() {
      var e = this;
      switch (this.rowModel.getType()) {
        case Z.ROW_MODEL_TYPE_CLIENT_SIDE:
          this.clientSideRowModel = this.rowModel;
          break;
        case Z.ROW_MODEL_TYPE_INFINITE:
          this.infiniteRowModel = this.rowModel;
          break;
        case Z.ROW_MODEL_TYPE_SERVER_SIDE:
          this.serverSideRowModel = this.rowModel;
          break;
      }
      this.ctrlsService.whenReady(function() {
        e.gridBodyCon = e.ctrlsService.getGridBodyCtrl();
      });
    }, n.prototype.__getAlignedGridService = function() {
      return this.alignedGridsService;
    }, n.prototype.__getContext = function() {
      return this.context;
    }, n.prototype.addDetailGridInfo = function(e, t) {
      this.detailGridInfoMap[e] = t;
    }, n.prototype.removeDetailGridInfo = function(e) {
      this.detailGridInfoMap[e] = void 0;
    }, n.prototype.getDetailGridInfo = function(e) {
      return this.detailGridInfoMap[e];
    }, n.prototype.forEachDetailGridInfo = function(e) {
      var t = 0;
      pi(this.detailGridInfoMap, function(i, r) {
        ge(r) && (e(r, t), t++);
      });
    }, n.prototype.getDataAsCsv = function(e) {
      if (gt.assertRegistered(ht.CsvExportModule, "api.getDataAsCsv"))
        return this.csvCreator.getDataAsCsv(e);
    }, n.prototype.exportDataAsCsv = function(e) {
      gt.assertRegistered(ht.CsvExportModule, "api.exportDataAsCSv") && this.csvCreator.exportDataAsCsv(e);
    }, n.prototype.getExcelExportMode = function(e) {
      var t = this.gridOptionsWrapper.getDefaultExportParams("excel"), i = Object.assign({ exportMode: "xlsx" }, t, e);
      return i.exportMode;
    }, n.prototype.getDataAsExcel = function(e) {
      if (gt.assertRegistered(ht.ExcelExportModule, "api.getDataAsExcel")) {
        var t = this.getExcelExportMode(e);
        if (this.excelCreator.getFactoryMode(t) === _p.MULTI_SHEET) {
          console.warn("AG Grid: The Excel Exporter is currently on Multi Sheet mode. End that operation by calling `api.getMultipleSheetAsExcel()` or `api.exportMultipleSheetsAsExcel()`");
          return;
        }
        return this.excelCreator.getDataAsExcel(e);
      }
    }, n.prototype.exportDataAsExcel = function(e) {
      if (gt.assertRegistered(ht.ExcelExportModule, "api.exportDataAsExcel")) {
        var t = this.getExcelExportMode(e);
        if (this.excelCreator.getFactoryMode(t) === _p.MULTI_SHEET) {
          console.warn("AG Grid: The Excel Exporter is currently on Multi Sheet mode. End that operation by calling `api.getMultipleSheetAsExcel()` or `api.exportMultipleSheetsAsExcel()`");
          return;
        }
        this.excelCreator.exportDataAsExcel(e);
      }
    }, n.prototype.getSheetDataForExcel = function(e) {
      if (gt.assertRegistered(ht.ExcelExportModule, "api.getSheetDataForExcel")) {
        var t = this.getExcelExportMode(e);
        return this.excelCreator.setFactoryMode(_p.MULTI_SHEET, t), this.excelCreator.getSheetDataForExcel(e);
      }
    }, n.prototype.getMultipleSheetsAsExcel = function(e) {
      if (gt.assertRegistered(ht.ExcelExportModule, "api.getMultipleSheetsAsExcel"))
        return this.excelCreator.getMultipleSheetsAsExcel(e);
    }, n.prototype.exportMultipleSheetsAsExcel = function(e) {
      if (gt.assertRegistered(ht.ExcelExportModule, "api.exportMultipleSheetsAsExcel"))
        return this.excelCreator.exportMultipleSheetsAsExcel(e);
    }, n.prototype.setEnterpriseDatasource = function(e) {
      console.warn("AG Grid: since version 18.x, api.setEnterpriseDatasource() should be replaced with api.setServerSideDatasource()"), this.setServerSideDatasource(e);
    }, n.prototype.setGridAriaProperty = function(e, t) {
      if (e) {
        var i = this.ctrlsService.getGridBodyCtrl().getGui(), r = "aria-" + e;
        t === null ? i.removeAttribute(r) : i.setAttribute(r, t);
      }
    }, n.prototype.setServerSideDatasource = function(e) {
      this.serverSideRowModel ? this.serverSideRowModel.setDatasource(e) : console.warn("AG Grid: you can only use an enterprise datasource when gridOptions.rowModelType is '" + Z.ROW_MODEL_TYPE_SERVER_SIDE + "'");
    }, n.prototype.setDatasource = function(e) {
      this.gridOptionsWrapper.isRowModelInfinite() ? this.rowModel.setDatasource(e) : console.warn("AG Grid: you can only use a datasource when gridOptions.rowModelType is '" + Z.ROW_MODEL_TYPE_INFINITE + "'");
    }, n.prototype.setViewportDatasource = function(e) {
      this.gridOptionsWrapper.isRowModelViewport() ? this.rowModel.setViewportDatasource(e) : console.warn("AG Grid: you can only use a viewport datasource when gridOptions.rowModelType is '" + Z.ROW_MODEL_TYPE_VIEWPORT + "'");
    }, n.prototype.setRowData = function(e) {
      var t = this.immutableService == null;
      if (t) {
        console.warn("AG Grid: you can only set rowData when using the Client Side Row Model");
        return;
      }
      this.immutableService.isActive() ? this.immutableService.setRowData(e) : (this.selectionService.reset(), this.clientSideRowModel.setRowData(e));
    }, n.prototype.setFloatingTopRowData = function(e) {
      console.warn("AG Grid: since v12, api.setFloatingTopRowData() is now api.setPinnedTopRowData()"), this.setPinnedTopRowData(e);
    }, n.prototype.setFloatingBottomRowData = function(e) {
      console.warn("AG Grid: since v12, api.setFloatingBottomRowData() is now api.setPinnedBottomRowData()"), this.setPinnedBottomRowData(e);
    }, n.prototype.getFloatingTopRowCount = function() {
      return console.warn("AG Grid: since v12, api.getFloatingTopRowCount() is now api.getPinnedTopRowCount()"), this.getPinnedTopRowCount();
    }, n.prototype.getFloatingBottomRowCount = function() {
      return console.warn("AG Grid: since v12, api.getFloatingBottomRowCount() is now api.getPinnedBottomRowCount()"), this.getPinnedBottomRowCount();
    }, n.prototype.getFloatingTopRow = function(e) {
      return console.warn("AG Grid: since v12, api.getFloatingTopRow() is now api.getPinnedTopRow()"), this.getPinnedTopRow(e);
    }, n.prototype.getFloatingBottomRow = function(e) {
      return console.warn("AG Grid: since v12, api.getFloatingBottomRow() is now api.getPinnedBottomRow()"), this.getPinnedBottomRow(e);
    }, n.prototype.setPinnedTopRowData = function(e) {
      this.pinnedRowModel.setPinnedTopRowData(e);
    }, n.prototype.setPinnedBottomRowData = function(e) {
      this.pinnedRowModel.setPinnedBottomRowData(e);
    }, n.prototype.getPinnedTopRowCount = function() {
      return this.pinnedRowModel.getPinnedTopRowCount();
    }, n.prototype.getPinnedBottomRowCount = function() {
      return this.pinnedRowModel.getPinnedBottomRowCount();
    }, n.prototype.getPinnedTopRow = function(e) {
      return this.pinnedRowModel.getPinnedTopRow(e);
    }, n.prototype.getPinnedBottomRow = function(e) {
      return this.pinnedRowModel.getPinnedBottomRow(e);
    }, n.prototype.setColumnDefs = function(e, t) {
      t === void 0 && (t = "api"), this.columnModel.setColumnDefs(e, t);
    }, n.prototype.setAutoGroupColumnDef = function(e, t) {
      this.gridOptionsWrapper.setProperty("autoGroupColumnDef", e, !0);
    }, n.prototype.setDefaultColDef = function(e, t) {
      this.gridOptionsWrapper.setProperty("defaultColDef", e, !0);
    }, n.prototype.expireValueCache = function() {
      this.valueCache.expire();
    }, n.prototype.getVerticalPixelRange = function() {
      return this.gridBodyCon.getScrollFeature().getVScrollPosition();
    }, n.prototype.getHorizontalPixelRange = function() {
      return this.gridBodyCon.getScrollFeature().getHScrollPosition();
    }, n.prototype.setAlwaysShowHorizontalScroll = function(e) {
      this.gridOptionsWrapper.setProperty("alwaysShowHorizontalScroll", e);
    }, n.prototype.setAlwaysShowVerticalScroll = function(e) {
      this.gridOptionsWrapper.setProperty("alwaysShowVerticalScroll", e);
    }, n.prototype.refreshToolPanel = function() {
      this.sideBarComp && this.sideBarComp.refresh();
    }, n.prototype.refreshCells = function(e) {
      if (e === void 0 && (e = {}), Array.isArray(e)) {
        console.warn("since AG Grid v11.1, refreshCells() now takes parameters, please see the documentation.");
        return;
      }
      this.rowRenderer.refreshCells(e);
    }, n.prototype.flashCells = function(e) {
      e === void 0 && (e = {}), this.rowRenderer.flashCells(e);
    }, n.prototype.redrawRows = function(e) {
      e === void 0 && (e = {});
      var t = e ? e.rowNodes : void 0;
      this.rowRenderer.redrawRows(t);
    }, n.prototype.setFunctionsReadOnly = function(e) {
      this.gridOptionsWrapper.setProperty("functionsReadOnly", e);
    }, n.prototype.refreshHeader = function() {
      this.ctrlsService.getHeaderRowContainerCtrls().forEach(function(e) {
        return e.refresh();
      });
    }, n.prototype.isAnyFilterPresent = function() {
      return this.filterManager.isAnyFilterPresent();
    }, n.prototype.isColumnFilterPresent = function() {
      return this.filterManager.isAdvancedFilterPresent();
    }, n.prototype.isQuickFilterPresent = function() {
      return this.filterManager.isQuickFilterPresent();
    }, n.prototype.getModel = function() {
      return this.rowModel;
    }, n.prototype.setRowNodeExpanded = function(e, t) {
      e && e.setExpanded(t);
    }, n.prototype.onGroupExpandedOrCollapsed = function(e) {
      Je(this.clientSideRowModel) && console.warn("AG Grid: cannot call onGroupExpandedOrCollapsed unless using normal row model"), ge(e) && console.warn("AG Grid: api.onGroupExpandedOrCollapsed - refreshFromIndex parameter is no longer used, the grid will refresh all rows"), this.clientSideRowModel.refreshModel({ step: oa.MAP });
    }, n.prototype.refreshInMemoryRowModel = function(e) {
      console.warn("ag-grid: since version 18.x, api.refreshInMemoryRowModel() should be replaced with api.refreshClientSideRowModel()"), this.refreshClientSideRowModel(e);
    }, n.prototype.refreshClientSideRowModel = function(e) {
      Je(this.clientSideRowModel) && console.warn("cannot call refreshClientSideRowModel unless using normal row model");
      var t = oa.EVERYTHING, i = {
        group: oa.EVERYTHING,
        filter: oa.FILTER,
        map: oa.MAP,
        aggregate: oa.AGGREGATE,
        sort: oa.SORT,
        pivot: oa.PIVOT
      };
      if (ge(e) && (t = i[e]), Je(t)) {
        console.error("AG Grid: invalid step " + e + ", available steps are " + Object.keys(i).join(", "));
        return;
      }
      var r = !this.gridOptionsWrapper.isSuppressAnimationFrame(), o = {
        step: t,
        keepRenderedRows: !0,
        keepEditingRows: !0,
        animate: r
      };
      this.clientSideRowModel.refreshModel(o);
    }, n.prototype.isAnimationFrameQueueEmpty = function() {
      return this.animationFrameService.isQueueEmpty();
    }, n.prototype.flushAllAnimationFrames = function() {
      this.animationFrameService.flushAllFrames();
    }, n.prototype.getRowNode = function(e) {
      return this.rowModel.getRowNode(e);
    }, n.prototype.getSizesForCurrentTheme = function() {
      return {
        rowHeight: this.gridOptionsWrapper.getRowHeightAsNumber(),
        headerHeight: this.gridOptionsWrapper.getHeaderHeight()
      };
    }, n.prototype.expandAll = function() {
      this.clientSideRowModel ? this.clientSideRowModel.expandOrCollapseAll(!0) : this.serverSideRowModel ? this.serverSideRowModel.expandAll(!0) : console.warn("AG Grid: expandAll only works with Client Side Row Model and Server Side Row Model");
    }, n.prototype.collapseAll = function() {
      this.clientSideRowModel ? this.clientSideRowModel.expandOrCollapseAll(!1) : this.serverSideRowModel ? this.serverSideRowModel.expandAll(!1) : console.warn("AG Grid: collapseAll only works with Client Side Row Model and Server Side Row Model");
    }, n.prototype.getToolPanelInstance = function(e) {
      if (!this.sideBarComp) {
        console.warn("AG Grid: toolPanel is only available in AG Grid Enterprise");
        return;
      }
      var t = this.sideBarComp.getToolPanelInstance(e);
      return Kh(t);
    }, n.prototype.addVirtualRowListener = function(e, t, i) {
      typeof e != "string" && console.warn("AG Grid: addVirtualRowListener is deprecated, please use addRenderedRowListener."), this.addRenderedRowListener(e, t, i);
    }, n.prototype.addRenderedRowListener = function(e, t, i) {
      e === "virtualRowSelected" && console.warn(`AG Grid: event virtualRowSelected is deprecated, to register for individual row
                selection events, add a listener directly to the row node.`), this.rowRenderer.addRenderedRowListener(e, t, i);
    }, n.prototype.setQuickFilter = function(e) {
      this.filterManager.setQuickFilter(e);
    }, n.prototype.selectIndex = function(e, t, i) {
      console.warn("AG Grid: do not use api for selection, call node.setSelected(value) instead"), i && console.warn("AG Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it"), this.selectionService.selectIndex(e, t);
    }, n.prototype.deselectIndex = function(e, t) {
      t === void 0 && (t = !1), console.warn("AG Grid: do not use api for selection, call node.setSelected(value) instead"), t && console.warn("AG Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it"), this.selectionService.deselectIndex(e);
    }, n.prototype.selectNode = function(e, t, i) {
      t === void 0 && (t = !1), i === void 0 && (i = !1), console.warn("AG Grid: API for selection is deprecated, call node.setSelected(value) instead"), i && console.warn("AG Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it"), e.setSelectedParams({ newValue: !0, clearSelection: !t });
    }, n.prototype.deselectNode = function(e, t) {
      t === void 0 && (t = !1), console.warn("AG Grid: API for selection is deprecated, call node.setSelected(value) instead"), t && console.warn("AG Grid: suppressEvents is no longer supported, stop listening for the event if you no longer want it"), e.setSelectedParams({ newValue: !1 });
    }, n.prototype.selectAll = function() {
      this.selectionService.selectAllRowNodes();
    }, n.prototype.deselectAll = function() {
      this.selectionService.deselectAllRowNodes();
    }, n.prototype.selectAllFiltered = function() {
      this.selectionService.selectAllRowNodes(!0);
    }, n.prototype.deselectAllFiltered = function() {
      this.selectionService.deselectAllRowNodes(!0);
    }, n.prototype.recomputeAggregates = function() {
      Je(this.clientSideRowModel) && console.warn("cannot call recomputeAggregates unless using normal row model"), console.warn("recomputeAggregates is deprecated, please call api.refreshClientSideRowModel('aggregate') instead"), this.clientSideRowModel.refreshModel({ step: oa.AGGREGATE });
    }, n.prototype.sizeColumnsToFit = function() {
      this.gridBodyCon.sizeColumnsToFit();
    }, n.prototype.showLoadingOverlay = function() {
      this.overlayWrapperComp.showLoadingOverlay();
    }, n.prototype.showNoRowsOverlay = function() {
      this.overlayWrapperComp.showNoRowsOverlay();
    }, n.prototype.hideOverlay = function() {
      this.overlayWrapperComp.hideOverlay();
    }, n.prototype.isNodeSelected = function(e) {
      return console.warn("AG Grid: no need to call api.isNodeSelected(), just call node.isSelected() instead"), e.isSelected();
    }, n.prototype.getSelectedNodesById = function() {
      return console.error("AG Grid: since version 3.4, getSelectedNodesById no longer exists, use getSelectedNodes() instead"), null;
    }, n.prototype.getSelectedNodes = function() {
      return this.selectionService.getSelectedNodes();
    }, n.prototype.getSelectedRows = function() {
      return this.selectionService.getSelectedRows();
    }, n.prototype.getBestCostNodeSelection = function() {
      return this.selectionService.getBestCostNodeSelection();
    }, n.prototype.getRenderedNodes = function() {
      return this.rowRenderer.getRenderedNodes();
    }, n.prototype.ensureColIndexVisible = function(e) {
      console.warn("AG Grid: ensureColIndexVisible(index) no longer supported, use ensureColumnVisible(colKey) instead.");
    }, n.prototype.ensureColumnVisible = function(e, t) {
      t === void 0 && (t = "auto"), this.gridBodyCon.getScrollFeature().ensureColumnVisible(e, t);
    }, n.prototype.ensureIndexVisible = function(e, t) {
      this.gridBodyCon.getScrollFeature().ensureIndexVisible(e, t);
    }, n.prototype.ensureNodeVisible = function(e, t) {
      t === void 0 && (t = null), this.gridBodyCon.getScrollFeature().ensureNodeVisible(e, t);
    }, n.prototype.forEachLeafNode = function(e) {
      Je(this.clientSideRowModel) && console.warn("cannot call forEachNode unless using normal row model"), this.clientSideRowModel.forEachLeafNode(e);
    }, n.prototype.forEachNode = function(e) {
      this.rowModel.forEachNode(e);
    }, n.prototype.forEachNodeAfterFilter = function(e) {
      Je(this.clientSideRowModel) && console.warn("cannot call forEachNodeAfterFilter unless using normal row model"), this.clientSideRowModel.forEachNodeAfterFilter(e);
    }, n.prototype.forEachNodeAfterFilterAndSort = function(e) {
      Je(this.clientSideRowModel) && console.warn("cannot call forEachNodeAfterFilterAndSort unless using normal row model"), this.clientSideRowModel.forEachNodeAfterFilterAndSort(e);
    }, n.prototype.getFilterInstance = function(e, t) {
      var i = this.getFilterInstanceImpl(e, function(o) {
        if (t) {
          var s = Kh(o);
          t(s);
        }
      }), r = Kh(i);
      return r;
    }, n.prototype.getFilterInstanceImpl = function(e, t) {
      var i = this.columnModel.getPrimaryColumn(e);
      if (i) {
        var r = this.filterManager.getFilterComponent(i, "NO_UI"), o = r && r.resolveNow(null, function(s) {
          return s;
        });
        return o ? setTimeout(t, 0, o) : r && r.then(function(s) {
          t(s);
        }), o;
      }
    }, n.prototype.destroyFilter = function(e) {
      var t = this.columnModel.getPrimaryColumn(e);
      if (t)
        return this.filterManager.destroyFilter(t, "filterDestroyed");
    }, n.prototype.getStatusPanel = function(e) {
      if (this.statusBarService) {
        var t = this.statusBarService.getStatusPanel(e);
        return Kh(t);
      }
    }, n.prototype.getColumnDef = function(e) {
      var t = this.columnModel.getPrimaryColumn(e);
      return t ? t.getColDef() : null;
    }, n.prototype.getColumnDefs = function() {
      return this.columnModel.getColumnDefs();
    }, n.prototype.onFilterChanged = function() {
      this.filterManager.onFilterChanged();
    }, n.prototype.onSortChanged = function() {
      this.sortController.onSortChanged();
    }, n.prototype.setFilterModel = function(e) {
      this.filterManager.setFilterModel(e);
    }, n.prototype.getFilterModel = function() {
      return this.filterManager.getFilterModel();
    }, n.prototype.getFocusedCell = function() {
      return this.focusService.getFocusedCell();
    }, n.prototype.clearFocusedCell = function() {
      return this.focusService.clearFocusedCell();
    }, n.prototype.setFocusedCell = function(e, t, i) {
      this.focusService.setFocusedCell(e, t, i, !0);
    }, n.prototype.setSuppressRowDrag = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_SUPPRESS_ROW_DRAG, e);
    }, n.prototype.setSuppressMoveWhenRowDragging = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_SUPPRESS_MOVE_WHEN_ROW_DRAG, e);
    }, n.prototype.setSuppressRowClickSelection = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_SUPPRESS_ROW_CLICK_SELECTION, e);
    }, n.prototype.addRowDropZone = function(e) {
      this.gridBodyCon.getRowDragFeature().addRowDropZone(e);
    }, n.prototype.removeRowDropZone = function(e) {
      var t = this.dragAndDropService.findExternalZone(e);
      t && this.dragAndDropService.removeDropTarget(t);
    }, n.prototype.getRowDropZoneParams = function(e) {
      return this.gridBodyCon.getRowDragFeature().getRowDropZone(e);
    }, n.prototype.setHeaderHeight = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_HEADER_HEIGHT, e);
    }, n.prototype.setDomLayout = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_DOM_LAYOUT, e);
    }, n.prototype.setEnableCellTextSelection = function(e) {
      this.gridBodyCon.setCellTextSelection(e);
    }, n.prototype.setFillHandleDirection = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_FILL_HANDLE_DIRECTION, e);
    }, n.prototype.setGroupHeaderHeight = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GROUP_HEADER_HEIGHT, e);
    }, n.prototype.setFloatingFiltersHeight = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_FLOATING_FILTERS_HEIGHT, e);
    }, n.prototype.setPivotHeaderHeight = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_PIVOT_HEADER_HEIGHT, e);
    }, n.prototype.setPivotGroupHeaderHeight = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_PIVOT_GROUP_HEADER_HEIGHT, e);
    }, n.prototype.setIsExternalFilterPresent = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_IS_EXTERNAL_FILTER_PRESENT, e);
    }, n.prototype.setDoesExternalFilterPass = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_DOES_EXTERNAL_FILTER_PASS, e);
    }, n.prototype.setNavigateToNextCell = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_NAVIGATE_TO_NEXT_CELL, e);
    }, n.prototype.setTabToNextCell = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_TAB_TO_NEXT_CELL, e);
    }, n.prototype.setTabToNextHeader = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_TAB_TO_NEXT_HEADER, e);
    }, n.prototype.setNavigateToNextHeader = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_NAVIGATE_TO_NEXT_HEADER, e);
    }, n.prototype.setGroupRowAggNodes = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GROUP_ROW_AGG_NODES, e);
    }, n.prototype.setGetBusinessKeyForNode = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_BUSINESS_KEY_FOR_NODE, e);
    }, n.prototype.setGetChildCount = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_CHILD_COUNT, e);
    }, n.prototype.setProcessRowPostCreate = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_PROCESS_ROW_POST_CREATE, e);
    }, n.prototype.setGetRowNodeId = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_ROW_NODE_ID, e);
    }, n.prototype.setGetRowClass = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_ROW_CLASS, e);
    }, n.prototype.setIsFullWidthCell = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_IS_FULL_WIDTH_CELL, e);
    }, n.prototype.setIsRowSelectable = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_IS_ROW_SELECTABLE, e);
    }, n.prototype.setIsRowMaster = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_IS_ROW_MASTER, e);
    }, n.prototype.setPostSort = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_POST_SORT, e);
    }, n.prototype.setGetDocument = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_DOCUMENT, e);
    }, n.prototype.setGetContextMenuItems = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_CONTEXT_MENU_ITEMS, e);
    }, n.prototype.setGetMainMenuItems = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_MAIN_MENU_ITEMS, e);
    }, n.prototype.setProcessCellForClipboard = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_PROCESS_CELL_FOR_CLIPBOARD, e);
    }, n.prototype.setSendToClipboard = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_SEND_TO_CLIPBOARD, e);
    }, n.prototype.setProcessCellFromClipboard = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_PROCESS_CELL_FROM_CLIPBOARD, e);
    }, n.prototype.setProcessSecondaryColDef = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_PROCESS_TO_SECONDARY_COLDEF, e);
    }, n.prototype.setProcessSecondaryColGroupDef = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_PROCESS_SECONDARY_COL_GROUP_DEF, e);
    }, n.prototype.setPostProcessPopup = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_POST_PROCESS_POPUP, e);
    }, n.prototype.setDefaultGroupOrderComparator = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_DEFAULT_GROUP_ORDER_COMPARATOR, e);
    }, n.prototype.setGetChartToolbarItems = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_CHART_TOOLBAR_ITEMS, e);
    }, n.prototype.setPaginationNumberFormatter = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_PAGINATION_NUMBER_FORMATTER, e);
    }, n.prototype.setGetServerSideStoreParams = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_SERVER_SIDE_STORE_PARAMS, e);
    }, n.prototype.setIsServerSideGroupOpenByDefault = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_IS_SERVER_SIDE_GROUPS_OPEN_BY_DEFAULT, e);
    }, n.prototype.setIsApplyServerSideTransaction = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_IS_APPLY_SERVER_SIDE_TRANSACTION, e);
    }, n.prototype.setIsServerSideGroup = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_IS_SERVER_SIDE_GROUP, e);
    }, n.prototype.setGetServerSideGroupKey = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_SERVER_SIDE_GROUP_KEY, e);
    }, n.prototype.setGetRowStyle = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_ROW_STYLE, e);
    }, n.prototype.setGetRowHeight = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GET_ROW_HEIGHT, e);
    }, n.prototype.isSideBarVisible = function() {
      return this.sideBarComp ? this.sideBarComp.isDisplayed() : !1;
    }, n.prototype.setSideBarVisible = function(e) {
      if (!this.sideBarComp) {
        e && console.warn("AG Grid: sideBar is not loaded");
        return;
      }
      this.sideBarComp.setDisplayed(e);
    }, n.prototype.setSideBarPosition = function(e) {
      if (!this.sideBarComp) {
        console.warn("AG Grid: sideBar is not loaded");
        return;
      }
      this.sideBarComp.setSideBarPosition(e);
    }, n.prototype.openToolPanel = function(e) {
      if (!this.sideBarComp) {
        console.warn("AG Grid: toolPanel is only available in AG Grid Enterprise");
        return;
      }
      this.sideBarComp.openToolPanel(e);
    }, n.prototype.closeToolPanel = function() {
      if (!this.sideBarComp) {
        console.warn("AG Grid: toolPanel is only available in AG Grid Enterprise");
        return;
      }
      this.sideBarComp.close();
    }, n.prototype.getOpenedToolPanel = function() {
      return this.sideBarComp ? this.sideBarComp.openedItem() : null;
    }, n.prototype.getSideBar = function() {
      return this.gridOptionsWrapper.getSideBar();
    }, n.prototype.setSideBar = function(e) {
      this.gridOptionsWrapper.setProperty("sideBar", WH.parse(e));
    }, n.prototype.setSuppressClipboardPaste = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_SUPPRESS_CLIPBOARD_PASTE, e);
    }, n.prototype.isToolPanelShowing = function() {
      return this.sideBarComp.isToolPanelShowing();
    }, n.prototype.doLayout = function() {
      var e = "AG Grid - since version 25.1, doLayout was taken out, as it's not needed. The grid responds to grid size changes automatically";
      mi(function() {
        return console.warn(e);
      }, "doLayoutDeprecated");
    }, n.prototype.resetRowHeights = function() {
      if (ge(this.clientSideRowModel)) {
        if (this.columnModel.isAutoRowHeightActive()) {
          console.warn("AG Grid: calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
          return;
        }
        this.clientSideRowModel.resetRowHeights();
      }
    }, n.prototype.setGroupRemoveSingleChildren = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GROUP_REMOVE_SINGLE_CHILDREN, e);
    }, n.prototype.setGroupRemoveLowestSingleChildren = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN, e);
    }, n.prototype.onRowHeightChanged = function() {
      this.clientSideRowModel ? this.clientSideRowModel.onRowHeightChanged() : this.serverSideRowModel && this.serverSideRowModel.onRowHeightChanged();
    }, n.prototype.getValue = function(e, t) {
      var i = this.columnModel.getPrimaryColumn(e);
      return Je(i) && (i = this.columnModel.getGridColumn(e)), Je(i) ? null : this.valueService.getValue(i, t);
    }, n.prototype.addEventListener = function(e, t) {
      var i = this.gridOptionsWrapper.useAsyncEvents();
      this.eventService.addEventListener(e, t, i);
    }, n.prototype.addGlobalListener = function(e) {
      var t = this.gridOptionsWrapper.useAsyncEvents();
      this.eventService.addGlobalListener(e, t);
    }, n.prototype.removeEventListener = function(e, t) {
      var i = this.gridOptionsWrapper.useAsyncEvents();
      this.eventService.removeEventListener(e, t, i);
    }, n.prototype.removeGlobalListener = function(e) {
      var t = this.gridOptionsWrapper.useAsyncEvents();
      this.eventService.removeGlobalListener(e, t);
    }, n.prototype.dispatchEvent = function(e) {
      this.eventService.dispatchEvent(e);
    }, n.prototype.destroy = function() {
      if (!this.destroyCalled) {
        this.destroyCalled = !0;
        var e = this.ctrlsService.getGridCtrl();
        e && e.destroyGridUi(), this.context.destroy();
      }
    }, n.prototype.cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid = function() {
      setTimeout(CB.bind(window, this, "Grid API"), 100);
    }, n.prototype.warnIfDestroyed = function(e) {
      return this.destroyCalled && console.warn("AG Grid: Grid API method " + e + " was called on a grid that was destroyed."), this.destroyCalled;
    }, n.prototype.resetQuickFilter = function() {
      this.warnIfDestroyed("resetQuickFilter") || this.rowModel.forEachNode(function(e) {
        return e.quickFilterAggregateText = null;
      });
    }, n.prototype.getRangeSelections = function() {
      return console.warn(`AG Grid: in v20.1.x, api.getRangeSelections() is gone, please use getCellRanges() instead.
        We had to change how cell selections works a small bit to allow charting to integrate. The return type of
        getCellRanges() is a bit different, please check the AG Grid documentation.`), null;
    }, n.prototype.getCellRanges = function() {
      return this.rangeService ? this.rangeService.getCellRanges() : (console.warn("AG Grid: cell range selection is only available in AG Grid Enterprise"), null);
    }, n.prototype.camelCaseToHumanReadable = function(e) {
      return _x(e);
    }, n.prototype.addRangeSelection = function(e) {
      console.warn("AG Grid: As of version 21.x, range selection changed slightly to allow charting integration. Please call api.addCellRange() instead of api.addRangeSelection()");
    }, n.prototype.addCellRange = function(e) {
      this.rangeService || console.warn("AG Grid: cell range selection is only available in AG Grid Enterprise"), this.rangeService.addCellRange(e);
    }, n.prototype.clearRangeSelection = function() {
      this.rangeService || console.warn("AG Grid: cell range selection is only available in AG Grid Enterprise"), this.rangeService.removeAllCellRanges();
    }, n.prototype.undoCellEditing = function() {
      this.undoRedoService.undo();
    }, n.prototype.redoCellEditing = function() {
      this.undoRedoService.redo();
    }, n.prototype.getCurrentUndoSize = function() {
      return this.undoRedoService.getCurrentUndoStackSize();
    }, n.prototype.getCurrentRedoSize = function() {
      return this.undoRedoService.getCurrentRedoStackSize();
    }, n.prototype.getChartModels = function() {
      if (gt.assertRegistered(ht.RangeSelectionModule, "api.getChartModels") && gt.assertRegistered(ht.GridChartsModule, "api.getChartModels"))
        return this.chartService.getChartModels();
    }, n.prototype.getChartRef = function(e) {
      if (gt.assertRegistered(ht.RangeSelectionModule, "api.getChartRef") && gt.assertRegistered(ht.GridChartsModule, "api.getChartRef"))
        return this.chartService.getChartRef(e);
    }, n.prototype.getChartImageDataURL = function(e) {
      if (gt.assertRegistered(ht.RangeSelectionModule, "api.getChartImageDataURL") && gt.assertRegistered(ht.GridChartsModule, "api.getChartImageDataURL"))
        return this.chartService.getChartImageDataURL(e);
    }, n.prototype.createRangeChart = function(e) {
      if (gt.assertRegistered(ht.RangeSelectionModule, "api.createRangeChart") && gt.assertRegistered(ht.GridChartsModule, "api.createRangeChart"))
        return this.chartService.createRangeChart(e);
    }, n.prototype.createCrossFilterChart = function(e) {
      if (gt.assertRegistered(ht.RangeSelectionModule, "api.createCrossFilterChart") && gt.assertRegistered(ht.GridChartsModule, "api.createCrossFilterChart"))
        return this.chartService.createCrossFilterChart(e);
    }, n.prototype.restoreChart = function(e, t) {
      if (gt.assertRegistered(ht.RangeSelectionModule, "api.restoreChart") && gt.assertRegistered(ht.GridChartsModule, "api.restoreChart"))
        return this.chartService.restoreChart(e, t);
    }, n.prototype.createPivotChart = function(e) {
      if (gt.assertRegistered(ht.RangeSelectionModule, "api.createPivotChart") && gt.assertRegistered(ht.GridChartsModule, "api.createPivotChart"))
        return this.chartService.createPivotChart(e);
    }, n.prototype.copySelectedRowsToClipboard = function(e) {
      this.clipboardService || console.warn("AG Grid: clipboard is only available in AG Grid Enterprise"), this.clipboardService.copySelectedRowsToClipboard(e);
    }, n.prototype.copySelectedRangeToClipboard = function(e) {
      this.clipboardService || console.warn("AG Grid: clipboard is only available in AG Grid Enterprise"), this.clipboardService.copySelectedRangeToClipboard(e);
    }, n.prototype.copySelectedRangeDown = function() {
      this.clipboardService || console.warn("AG Grid: clipboard is only available in AG Grid Enterprise"), this.clipboardService.copyRangeDown();
    }, n.prototype.showColumnMenuAfterButtonClick = function(e, t) {
      var i = this.columnModel.getGridColumn(e);
      this.menuFactory.showMenuAfterButtonClick(i, t, "columnMenu");
    }, n.prototype.showColumnMenuAfterMouseClick = function(e, t) {
      var i = this.columnModel.getGridColumn(e);
      if (i || (i = this.columnModel.getPrimaryColumn(e)), !i) {
        console.error("AG Grid: column '" + e + "' not found");
        return;
      }
      this.menuFactory.showMenuAfterMouseEvent(i, t);
    }, n.prototype.hidePopupMenu = function() {
      this.contextMenuFactory && this.contextMenuFactory.hideActiveMenu(), this.menuFactory.hideActiveMenu();
    }, n.prototype.setPopupParent = function(e) {
      this.gridOptionsWrapper.setProperty(He.PROP_POPUP_PARENT, e);
    }, n.prototype.tabToNextCell = function(e) {
      return this.navigationService.tabToNextCell(!1, e);
    }, n.prototype.tabToPreviousCell = function(e) {
      return this.navigationService.tabToNextCell(!0, e);
    }, n.prototype.getCellRendererInstances = function(e) {
      e === void 0 && (e = {});
      var t = this.rowRenderer.getCellRendererInstances(e), i = t.map(Kh);
      return i;
    }, n.prototype.getCellEditorInstances = function(e) {
      e === void 0 && (e = {});
      var t = this.rowRenderer.getCellEditorInstances(e), i = t.map(Kh);
      return i;
    }, n.prototype.getEditingCells = function() {
      return this.rowRenderer.getEditingCells();
    }, n.prototype.stopEditing = function(e) {
      e === void 0 && (e = !1), this.rowRenderer.stopEditing(e);
    }, n.prototype.startEditingCell = function(e) {
      var t = this.columnModel.getGridColumn(e.colKey);
      if (!t) {
        console.warn("AG Grid: no column found for " + e.colKey);
        return;
      }
      var i = {
        rowIndex: e.rowIndex,
        rowPinned: e.rowPinned || null,
        column: t
      }, r = e.rowPinned == null;
      r && this.gridBodyCon.getScrollFeature().ensureIndexVisible(e.rowIndex);
      var o = this.navigationService.getCellByPosition(i);
      o && o.startRowOrCellEdit(e.key, e.charPress);
    }, n.prototype.addAggFunc = function(e, t) {
      this.aggFuncService && this.aggFuncService.addAggFunc(e, t);
    }, n.prototype.addAggFuncs = function(e) {
      this.aggFuncService && this.aggFuncService.addAggFuncs(e);
    }, n.prototype.clearAggFuncs = function() {
      this.aggFuncService && this.aggFuncService.clear();
    }, n.prototype.applyServerSideTransaction = function(e) {
      if (!this.serverSideTransactionManager) {
        console.warn("AG Grid: Cannot apply Server Side Transaction if not using the Server Side Row Model.");
        return;
      }
      return this.serverSideTransactionManager.applyTransaction(e);
    }, n.prototype.applyServerSideTransactionAsync = function(e, t) {
      if (!this.serverSideTransactionManager) {
        console.warn("AG Grid: Cannot apply Server Side Transaction if not using the Server Side Row Model.");
        return;
      }
      return this.serverSideTransactionManager.applyTransactionAsync(e, t);
    }, n.prototype.retryServerSideLoads = function() {
      if (!this.serverSideRowModel) {
        console.warn("AG Grid: API retryServerSideLoads() can only be used when using Server-Side Row Model.");
        return;
      }
      this.serverSideRowModel.retryLoads();
    }, n.prototype.flushServerSideAsyncTransactions = function() {
      if (!this.serverSideTransactionManager) {
        console.warn("AG Grid: Cannot flush Server Side Transaction if not using the Server Side Row Model.");
        return;
      }
      return this.serverSideTransactionManager.flushAsyncTransactions();
    }, n.prototype.applyTransaction = function(e) {
      if (!this.clientSideRowModel) {
        console.error("AG Grid: updateRowData() only works with ClientSideRowModel. Working with InfiniteRowModel was deprecated in v23.1 and removed in v24.1");
        return;
      }
      var t = this.clientSideRowModel.updateRowData(e);
      return this.rowRenderer.refreshFullWidthRows(t.update), this.gridOptionsWrapper.isSuppressChangeDetection() || this.rowRenderer.refreshCells(), t;
    }, n.prototype.updateRowData = function(e) {
      var t = "AG Grid: as of v23.1, grid API updateRowData(transaction) is now called applyTransaction(transaction). updateRowData is deprecated and will be removed in a future major release.";
      return mi(function() {
        return console.warn(t);
      }, "updateRowData deprecated"), this.applyTransaction(e);
    }, n.prototype.applyTransactionAsync = function(e, t) {
      if (!this.clientSideRowModel) {
        console.error("AG Grid: api.applyTransactionAsync() only works with ClientSideRowModel.");
        return;
      }
      this.clientSideRowModel.batchUpdateRowData(e, t);
    }, n.prototype.flushAsyncTransactions = function() {
      if (!this.clientSideRowModel) {
        console.error("AG Grid: api.applyTransactionAsync() only works with ClientSideRowModel.");
        return;
      }
      this.clientSideRowModel.flushAsyncTransactions();
    }, n.prototype.batchUpdateRowData = function(e, t) {
      var i = "AG Grid: as of v23.1, grid API batchUpdateRowData(transaction, callback) is now called applyTransactionAsync(transaction, callback). batchUpdateRowData is deprecated and will be removed in a future major release.";
      mi(function() {
        return console.warn(i);
      }, "batchUpdateRowData deprecated"), this.applyTransactionAsync(e, t);
    }, n.prototype.insertItemsAtIndex = function(e, t, i) {
      console.warn("AG Grid: insertItemsAtIndex() is deprecated, use updateRowData(transaction) instead."), this.updateRowData({ add: t, addIndex: e, update: null, remove: null });
    }, n.prototype.removeItems = function(e, t) {
      console.warn("AG Grid: removeItems() is deprecated, use updateRowData(transaction) instead.");
      var i = e.map(function(r) {
        return r.data;
      });
      this.updateRowData({ add: null, addIndex: null, update: null, remove: i });
    }, n.prototype.addItems = function(e, t) {
      console.warn("AG Grid: addItems() is deprecated, use updateRowData(transaction) instead."), this.updateRowData({ add: e, addIndex: null, update: null, remove: null });
    }, n.prototype.refreshVirtualPageCache = function() {
      console.warn("AG Grid: refreshVirtualPageCache() is now called refreshInfiniteCache(), please call refreshInfiniteCache() instead"), this.refreshInfiniteCache();
    }, n.prototype.refreshInfinitePageCache = function() {
      console.warn("AG Grid: refreshInfinitePageCache() is now called refreshInfiniteCache(), please call refreshInfiniteCache() instead"), this.refreshInfiniteCache();
    }, n.prototype.refreshInfiniteCache = function() {
      this.infiniteRowModel ? this.infiniteRowModel.refreshCache() : console.warn("AG Grid: api.refreshInfiniteCache is only available when rowModelType='infinite'.");
    }, n.prototype.purgeVirtualPageCache = function() {
      console.warn("AG Grid: purgeVirtualPageCache() is now called purgeInfiniteCache(), please call purgeInfiniteCache() instead"), this.purgeInfinitePageCache();
    }, n.prototype.purgeInfinitePageCache = function() {
      console.warn("AG Grid: purgeInfinitePageCache() is now called purgeInfiniteCache(), please call purgeInfiniteCache() instead"), this.purgeInfiniteCache();
    }, n.prototype.purgeInfiniteCache = function() {
      this.infiniteRowModel ? this.infiniteRowModel.purgeCache() : console.warn("AG Grid: api.purgeInfiniteCache is only available when rowModelType='infinite'.");
    }, n.prototype.purgeEnterpriseCache = function(e) {
      console.warn("ag-grid: since version 18.x, api.purgeEnterpriseCache() should be replaced with api.purgeServerSideCache()"), this.purgeServerSideCache(e);
    }, n.prototype.purgeServerSideCache = function(e) {
      e === void 0 && (e = []), this.serverSideRowModel ? (console.warn("AG Grid: since v25.0, api.purgeServerSideCache is deprecated. Please use api.refreshServerSideStore({purge: true}) instead."), this.refreshServerSideStore({
        route: e,
        purge: !0
      })) : console.warn("AG Grid: api.purgeServerSideCache is only available when rowModelType='serverSide'.");
    }, n.prototype.refreshServerSideStore = function(e) {
      this.serverSideRowModel ? this.serverSideRowModel.refreshStore(e) : console.warn("AG Grid: api.refreshServerSideStore is only available when rowModelType='serverSide'.");
    }, n.prototype.getServerSideStoreState = function() {
      return this.serverSideRowModel ? this.serverSideRowModel.getStoreState() : (console.warn("AG Grid: api.getServerSideStoreState is only available when rowModelType='serverSide'."), []);
    }, n.prototype.getVirtualRowCount = function() {
      return console.warn("AG Grid: getVirtualRowCount() is now called getInfiniteRowCount(), please call getInfiniteRowCount() instead"), this.getInfiniteRowCount();
    }, n.prototype.getInfiniteRowCount = function() {
      if (this.infiniteRowModel)
        return this.infiniteRowModel.getRowCount();
      console.warn("AG Grid: api.getVirtualRowCount is only available when rowModelType='virtual'.");
    }, n.prototype.isMaxRowFound = function() {
      return console.warn("AG Grid: api.isLastRowIndexKnown is deprecated, please use api.isLastRowIndexKnown()"), this.isLastRowIndexKnown();
    }, n.prototype.isLastRowIndexKnown = function() {
      if (this.infiniteRowModel)
        return this.infiniteRowModel.isLastRowIndexKnown();
      console.warn("AG Grid: api.isMaxRowFound is only available when rowModelType='virtual'.");
    }, n.prototype.setVirtualRowCount = function(e, t) {
      console.warn("AG Grid: setVirtualRowCount() is now called setInfiniteRowCount(), please call setInfiniteRowCount() instead"), this.setRowCount(e, t);
    }, n.prototype.setInfiniteRowCount = function(e, t) {
      console.warn("AG Grid: setInfiniteRowCount() is now called setRowCount(), please call setRowCount() instead"), this.setRowCount(e, t);
    }, n.prototype.setRowCount = function(e, t) {
      this.infiniteRowModel ? this.infiniteRowModel.setRowCount(e, t) : console.warn("AG Grid: api.setRowCount is only available for Infinite Row Model.");
    }, n.prototype.getVirtualPageState = function() {
      return console.warn("AG Grid: getVirtualPageState() is now called getCacheBlockState(), please call getCacheBlockState() instead"), this.getCacheBlockState();
    }, n.prototype.getInfinitePageState = function() {
      return console.warn("AG Grid: getInfinitePageState() is now called getCacheBlockState(), please call getCacheBlockState() instead"), this.getCacheBlockState();
    }, n.prototype.getCacheBlockState = function() {
      return this.rowNodeBlockLoader.getBlockState();
    }, n.prototype.checkGridSize = function() {
      console.warn("in AG Grid v25.2.0, checkGridSize() was removed, as it was legacy and didn't do anything uesful.");
    }, n.prototype.getFirstRenderedRow = function() {
      return console.warn("in AG Grid v12, getFirstRenderedRow() was renamed to getFirstDisplayedRow()"), this.getFirstDisplayedRow();
    }, n.prototype.getFirstDisplayedRow = function() {
      return this.rowRenderer.getFirstVirtualRenderedRow();
    }, n.prototype.getLastRenderedRow = function() {
      return console.warn("in AG Grid v12, getLastRenderedRow() was renamed to getLastDisplayedRow()"), this.getLastDisplayedRow();
    }, n.prototype.getLastDisplayedRow = function() {
      return this.rowRenderer.getLastVirtualRenderedRow();
    }, n.prototype.getDisplayedRowAtIndex = function(e) {
      return this.rowModel.getRow(e);
    }, n.prototype.getDisplayedRowCount = function() {
      return this.rowModel.getRowCount();
    }, n.prototype.paginationIsLastPageFound = function() {
      return this.paginationProxy.isLastPageFound();
    }, n.prototype.paginationGetPageSize = function() {
      return this.paginationProxy.getPageSize();
    }, n.prototype.paginationSetPageSize = function(e) {
      this.gridOptionsWrapper.setProperty("paginationPageSize", e);
    }, n.prototype.paginationGetCurrentPage = function() {
      return this.paginationProxy.getCurrentPage();
    }, n.prototype.paginationGetTotalPages = function() {
      return this.paginationProxy.getTotalPages();
    }, n.prototype.paginationGetRowCount = function() {
      return this.paginationProxy.getMasterRowCount();
    }, n.prototype.paginationGoToNextPage = function() {
      this.paginationProxy.goToNextPage();
    }, n.prototype.paginationGoToPreviousPage = function() {
      this.paginationProxy.goToPreviousPage();
    }, n.prototype.paginationGoToFirstPage = function() {
      this.paginationProxy.goToFirstPage();
    }, n.prototype.paginationGoToLastPage = function() {
      this.paginationProxy.goToLastPage();
    }, n.prototype.paginationGoToPage = function(e) {
      this.paginationProxy.goToPage(e);
    }, Ht([
      fi("immutableService")
    ], n.prototype, "immutableService", void 0), Ht([
      fi("csvCreator")
    ], n.prototype, "csvCreator", void 0), Ht([
      fi("excelCreator")
    ], n.prototype, "excelCreator", void 0), Ht([
      T("rowRenderer")
    ], n.prototype, "rowRenderer", void 0), Ht([
      T("navigationService")
    ], n.prototype, "navigationService", void 0), Ht([
      T("filterManager")
    ], n.prototype, "filterManager", void 0), Ht([
      T("columnModel")
    ], n.prototype, "columnModel", void 0), Ht([
      T("selectionService")
    ], n.prototype, "selectionService", void 0), Ht([
      T("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), Ht([
      T("valueService")
    ], n.prototype, "valueService", void 0), Ht([
      T("alignedGridsService")
    ], n.prototype, "alignedGridsService", void 0), Ht([
      T("eventService")
    ], n.prototype, "eventService", void 0), Ht([
      T("pinnedRowModel")
    ], n.prototype, "pinnedRowModel", void 0), Ht([
      T("context")
    ], n.prototype, "context", void 0), Ht([
      T("rowModel")
    ], n.prototype, "rowModel", void 0), Ht([
      T("sortController")
    ], n.prototype, "sortController", void 0), Ht([
      T("paginationProxy")
    ], n.prototype, "paginationProxy", void 0), Ht([
      T("focusService")
    ], n.prototype, "focusService", void 0), Ht([
      T("dragAndDropService")
    ], n.prototype, "dragAndDropService", void 0), Ht([
      fi("rangeService")
    ], n.prototype, "rangeService", void 0), Ht([
      fi("clipboardService")
    ], n.prototype, "clipboardService", void 0), Ht([
      fi("aggFuncService")
    ], n.prototype, "aggFuncService", void 0), Ht([
      T("menuFactory")
    ], n.prototype, "menuFactory", void 0), Ht([
      fi("contextMenuFactory")
    ], n.prototype, "contextMenuFactory", void 0), Ht([
      T("valueCache")
    ], n.prototype, "valueCache", void 0), Ht([
      T("animationFrameService")
    ], n.prototype, "animationFrameService", void 0), Ht([
      fi("statusBarService")
    ], n.prototype, "statusBarService", void 0), Ht([
      fi("chartService")
    ], n.prototype, "chartService", void 0), Ht([
      fi("undoRedoService")
    ], n.prototype, "undoRedoService", void 0), Ht([
      fi("rowNodeBlockLoader")
    ], n.prototype, "rowNodeBlockLoader", void 0), Ht([
      fi("ssrmTransactionManager")
    ], n.prototype, "serverSideTransactionManager", void 0), Ht([
      T("ctrlsService")
    ], n.prototype, "ctrlsService", void 0), Ht([
      fi("frameworkComponentWrapper")
    ], n.prototype, "frameworkComponentWrapper", void 0), Ht([
      Le
    ], n.prototype, "init", null), Ht([
      To
    ], n.prototype, "cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid", null), n = Ht([
      qe("gridApi")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var SX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), EX = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, kS = (
  /** @class */
  function(n) {
    SX(e, n);
    function e(t, i, r, o) {
      var s = n.call(this) || this;
      return s.columnOrGroup = t, s.eCell = i, s.ariaEl = s.eCell.querySelector("[role=columnheader]") || s.eCell, s.colsSpanning = o, s.beans = r, s;
    }
    return e.prototype.setColsSpanning = function(t) {
      this.colsSpanning = t, this.onLeftChanged();
    }, e.prototype.getColumnOrGroup = function() {
      return this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning ? Ti(this.colsSpanning) : this.columnOrGroup;
    }, e.prototype.postConstruct = function() {
      this.addManagedListener(this.columnOrGroup, Gt.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this)), this.setLeftFirstTime(), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onLeftChanged.bind(this)), this.addManagedListener(this.beans.gridOptionsWrapper, He.PROP_DOM_LAYOUT, this.onLeftChanged.bind(this));
    }, e.prototype.setLeftFirstTime = function() {
      var t = this.beans.gridOptionsWrapper.isSuppressColumnMoveAnimation(), i = ge(this.columnOrGroup.getOldLeft()), r = this.beans.columnAnimationService.isActive() && i && !t;
      r ? this.animateInLeft() : this.onLeftChanged();
    }, e.prototype.animateInLeft = function() {
      var t = this, i = this.getColumnOrGroup(), r = i.getLeft(), o = i.getOldLeft(), s = this.modifyLeftForPrintLayout(i, o), a = this.modifyLeftForPrintLayout(i, r);
      this.setLeft(s), this.actualLeft = a, this.beans.columnAnimationService.executeNextVMTurn(function() {
        t.actualLeft === a && t.setLeft(a);
      });
    }, e.prototype.onLeftChanged = function() {
      var t = this.getColumnOrGroup(), i = t.getLeft();
      this.actualLeft = this.modifyLeftForPrintLayout(t, i), this.setLeft(this.actualLeft);
    }, e.prototype.modifyLeftForPrintLayout = function(t, i) {
      var r = this.beans.gridOptionsWrapper.getDomLayout() === Z.DOM_LAYOUT_PRINT;
      if (!r || t.getPinned() === Z.PINNED_LEFT)
        return i;
      var o = this.beans.columnModel.getDisplayedColumnsLeftWidth();
      if (t.getPinned() === Z.PINNED_RIGHT) {
        var s = this.beans.columnModel.getBodyContainerWidth();
        return o + s + i;
      }
      return o + i;
    }, e.prototype.setLeft = function(t) {
      ge(t) && (this.eCell.style.left = t + "px");
      var i;
      if (this.columnOrGroup instanceof Gt)
        i = this.columnOrGroup;
      else {
        var r = this.columnOrGroup, o = r.getLeafColumns();
        if (!o.length)
          return;
        o.length > 1 && lH(this.ariaEl, o.length), i = o[0];
      }
      var s = this.beans.columnModel.getAriaColumnIndex(i);
      xx(this.ariaEl, s);
    }, EX([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var LX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), oF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, jx = (
  /** @class */
  function(n) {
    LX(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.columns = t, r.element = i, r;
    }
    return e.prototype.postConstruct = function() {
      this.gridOptionsWrapper.isColumnHoverHighlight() && this.addMouseHoverListeners();
    }, e.prototype.addMouseHoverListeners = function() {
      this.addManagedListener(this.element, "mouseout", this.onMouseOut.bind(this)), this.addManagedListener(this.element, "mouseover", this.onMouseOver.bind(this));
    }, e.prototype.onMouseOut = function() {
      this.columnHoverService.clearMouseOver();
    }, e.prototype.onMouseOver = function() {
      this.columnHoverService.setMouseOver(this.columns);
    }, oF([
      T("columnHoverService")
    ], e.prototype, "columnHoverService", void 0), oF([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var DX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Rf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, ZH = (
  /** @class */
  function(n) {
    DX(e, n);
    function e(t, i) {
      var r = n.call(this, t, i) || this;
      return r.column = t, r;
    }
    return e.prototype.setComp = function(t, i, r, o) {
      n.prototype.setGui.call(this, i), this.comp = t, this.eButtonShowMainFilter = r, this.eFloatingFilterBody = o;
      var s = this.column.getColDef(), a = !!s.filter || !!s.filterFramework, l = !!s.floatingFilter;
      this.active = a && l, this.setupWidth(), this.setupLeft(), this.setupHover(), this.setupFocus(), this.setupUserComp(), this.setupSyncWithFilter(), this.setupUi(), this.addManagedListener(this.eButtonShowMainFilter, "click", this.showParentFilter.bind(this));
    }, e.prototype.setupUi = function() {
      if (this.comp.addOrRemoveButtonWrapperCssClass("ag-hidden", !this.active || this.suppressFilterButton), !!this.active) {
        this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton);
        var t = Yn("filter", this.gridOptionsWrapper, this.column);
        t && this.eButtonShowMainFilter.appendChild(t);
      }
    }, e.prototype.setupFocus = function() {
      this.createManagedBean(new nc(this.eGui, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      }));
    }, e.prototype.onTabKeyDown = function(t) {
      var i = this.gridOptionsWrapper.getDocument(), r = i.activeElement, o = r === this.eGui;
      if (!o) {
        var s = this.focusService.findNextFocusableElement(this.eGui, null, t.shiftKey);
        if (s) {
          this.beans.headerNavigationService.scrollToColumn(this.column), t.preventDefault(), s.focus();
          return;
        }
        var a = this.findNextColumnWithFloatingFilter(t.shiftKey);
        a && this.focusService.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: this.getParentRowCtrl().getRowIndex(),
            column: a
          },
          event: t
        }) && t.preventDefault();
      }
    }, e.prototype.findNextColumnWithFloatingFilter = function(t) {
      var i = this.beans.columnModel, r = this.column;
      do
        if (r = t ? i.getDisplayedColBefore(r) : i.getDisplayedColAfter(r), !r)
          break;
      while (!r.getColDef().filter || !r.getColDef().floatingFilter);
      return r;
    }, e.prototype.handleKeyDown = function(t) {
      var i = this.gridOptionsWrapper.getDocument(), r = i.activeElement, o = r === this.eGui;
      switch (t.key) {
        case _e.UP:
        case _e.DOWN:
          o || t.preventDefault();
        case _e.LEFT:
        case _e.RIGHT:
          if (o)
            return;
          t.stopPropagation();
        case _e.ENTER:
          o && this.focusService.focusInto(this.eGui) && t.preventDefault();
          break;
        case _e.ESCAPE:
          o || this.eGui.focus();
      }
    }, e.prototype.onFocusIn = function(t) {
      var i = this.eGui.contains(t.relatedTarget);
      if (!i) {
        var r = !!t.relatedTarget && !t.relatedTarget.classList.contains("ag-floating-filter"), o = !!t.relatedTarget && OS(t.relatedTarget, "ag-floating-filter");
        if (r && o && t.target === this.eGui) {
          var s = this.lastFocusEvent, a = !!(s && s.key === _e.TAB);
          if (s && a) {
            var l = s.shiftKey;
            this.focusService.focusInto(this.eGui, l);
          }
        }
        var u = this.getRowIndex();
        this.beans.focusService.setFocusedHeader(u, this.column);
      }
    }, e.prototype.setupHover = function() {
      var t = this;
      this.createManagedBean(new jx([this.column], this.eGui));
      var i = function() {
        if (t.gridOptionsWrapper.isColumnHoverHighlight()) {
          var r = t.columnHoverService.isHovered(t.column);
          t.comp.addOrRemoveCssClass("ag-column-hover", r);
        }
      };
      this.addManagedListener(this.eventService, F.EVENT_COLUMN_HOVER_CHANGED, i), i();
    }, e.prototype.setupLeft = function() {
      var t = new kS(this.column, this.eGui, this.beans);
      this.createManagedBean(t);
    }, e.prototype.setupUserComp = function() {
      var t = this;
      if (this.active) {
        var i = this.column.getColDef(), r = this.filterManager.createFilterParams(this.column, i), o = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(i, iR, r), s = this.userComponentFactory.getDefaultFloatingFilterType(i);
        s == null && (s = "agReadOnlyFloatingFilter");
        var a = {
          api: this.gridApi,
          column: this.column,
          filterParams: o,
          currentParentModel: function() {
            return t.currentParentModel();
          },
          parentFilterInstance: function(u) {
            return t.parentFilterInstance(u);
          },
          showParentFilter: function() {
            return t.showParentFilter();
          },
          suppressFilterButton: !1
          // This one might be overridden from the colDef
        };
        this.suppressFilterButton = i.floatingFilterComponentParams ? !!i.floatingFilterComponentParams.suppressFilterButton : !1;
        var l = this.userComponentFactory.getFloatingFilterCompDetails(i, a, s);
        l && this.comp.setCompDetails(l);
      }
    }, e.prototype.currentParentModel = function() {
      var t = this.getFilterComponent(!1);
      return t ? t.resolveNow(null, function(i) {
        return i && i.getModel();
      }) : null;
    }, e.prototype.getFilterComponent = function(t) {
      return t === void 0 && (t = !0), this.filterManager.getFilterComponent(this.column, "NO_UI", t);
    }, e.prototype.parentFilterInstance = function(t) {
      var i = this.getFilterComponent();
      i != null && i.then(function(r) {
        t(Kh(r));
      });
    }, e.prototype.showParentFilter = function() {
      var t = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
      this.menuFactory.showMenuAfterButtonClick(this.column, t, "floatingFilter", "filterMenuTab", ["filterMenuTab"]);
    }, e.prototype.setupSyncWithFilter = function() {
      var t = this;
      if (this.active) {
        var i = function(r) {
          var o = t.comp.getFloatingFilterComp();
          if (o) {
            var s = t.currentParentModel();
            o.then(function(a) {
              a && a.onParentModelChanged(s, r);
            });
          }
        };
        this.addManagedListener(this.column, Gt.EVENT_FILTER_CHANGED, i), this.filterManager.isFilterActive(this.column) && i(null);
      }
    }, e.prototype.setupWidth = function() {
      var t = this, i = function() {
        var r = t.column.getActualWidth() + "px";
        t.comp.setWidth(r);
      };
      this.addManagedListener(this.column, Gt.EVENT_WIDTH_CHANGED, i), i();
    }, Rf([
      T("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), Rf([
      T("filterManager")
    ], e.prototype, "filterManager", void 0), Rf([
      T("columnHoverService")
    ], e.prototype, "columnHoverService", void 0), Rf([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Rf([
      T("menuFactory")
    ], e.prototype, "menuFactory", void 0), Rf([
      T("beans")
    ], e.prototype, "beans", void 0), e;
  }(P_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var $x = (
  /** @class */
  function() {
    function n() {
    }
    return n.getHeaderClassesFromColDef = function(e, t, i, r) {
      return Je(e) ? [] : this.getColumnClassesFromCollDef(e.headerClass, e, t, i, r);
    }, n.getToolPanelClassesFromColDef = function(e, t, i, r) {
      return Je(e) ? [] : this.getColumnClassesFromCollDef(e.toolPanelClass, e, t, i, r);
    }, n.getClassParams = function(e, t, i, r) {
      return {
        // bad naming, as colDef here can be a group or a column,
        // however most people won't appreciate the difference,
        // so keeping it as colDef to avoid confusion.
        colDef: e,
        column: i,
        columnGroup: r,
        context: t.getContext(),
        api: t.getApi()
      };
    }, n.getColumnClassesFromCollDef = function(e, t, i, r, o) {
      if (Je(e))
        return [];
      var s;
      if (typeof e == "function") {
        var a = this.getClassParams(t, i, r, o);
        s = e(a);
      } else
        s = e;
      return typeof s == "string" ? [s] : Array.isArray(s) ? s : [];
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var RX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), OL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, TX = (
  /** @class */
  function(n) {
    RX(e, n);
    function e(t, i, r, o, s) {
      var a = n.call(this) || this;
      return a.pinned = t, a.column = i, a.eResize = r, a.comp = o, a.ctrl = s, a;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.column.getColDef(), r = [], o, s, a = function() {
        if (Bi(t.eResize, o), !!o) {
          var c = t.horizontalResizeService.addResizeBar({
            eResizeBar: t.eResize,
            onResizeStart: t.onResizeStart.bind(t),
            onResizing: t.onResizing.bind(t, !1),
            onResizeEnd: t.onResizing.bind(t, !0)
          });
          if (r.push(c), s) {
            var h = t.gridOptionsWrapper.isSkipHeaderOnAutoSize(), d = function() {
              t.columnModel.autoSizeColumn(t.column, h, "uiColumnResized");
            };
            t.eResize.addEventListener("dblclick", d);
            var f = new da(t.eResize);
            f.addEventListener(da.EVENT_DOUBLE_TAP, d), t.addDestroyFunc(function() {
              t.eResize.removeEventListener("dblclick", d), f.removeEventListener(da.EVENT_DOUBLE_TAP, d), f.destroy();
            });
          }
        }
      }, l = function() {
        r.forEach(function(c) {
          return c();
        }), r.length = 0;
      }, u = function() {
        var c = t.column.isResizable(), h = !t.gridOptionsWrapper.isSuppressAutoSize() && !i.suppressAutoSize, d = c !== o || h !== s;
        d && (o = c, s = h, l(), a());
      };
      u(), this.addDestroyFunc(l), this.ctrl.addRefreshFunction(u);
    }, e.prototype.onResizing = function(t, i) {
      var r = this.normaliseResizeAmount(i), o = [{ key: this.column, newWidth: this.resizeStartWidth + r }];
      this.columnModel.setColumnWidths(o, this.resizeWithShiftKey, t, "uiColumnDragged"), t && this.comp.addOrRemoveCssClass("ag-column-resizing", !1);
    }, e.prototype.onResizeStart = function(t) {
      this.resizeStartWidth = this.column.getActualWidth(), this.resizeWithShiftKey = t, this.comp.addOrRemoveCssClass("ag-column-resizing", !0);
    }, e.prototype.normaliseResizeAmount = function(t) {
      var i = t, r = this.pinned !== Z.PINNED_LEFT, o = this.pinned === Z.PINNED_RIGHT;
      return this.gridOptionsWrapper.isEnableRtl() ? r && (i *= -1) : o && (i *= -1), i;
    }, OL([
      T("horizontalResizeService")
    ], e.prototype, "horizontalResizeService", void 0), OL([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), OL([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var OX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Kp = (
  /** @class */
  function(n) {
    OX(e, n);
    function e(t, i, r) {
      i === void 0 && (i = "ag-checkbox"), r === void 0 && (r = "checkbox");
      var o = n.call(this, t, i, r) || this;
      return o.labelAlignment = "right", o.selected = !1, o.readOnly = !1, o.passive = !1, o;
    }
    return e.prototype.addInputListeners = function() {
      this.addManagedListener(this.eInput, "click", this.onCheckboxClick.bind(this)), this.addManagedListener(this.eLabel, "click", this.toggle.bind(this));
    }, e.prototype.getNextValue = function() {
      return this.selected === void 0 ? !0 : !this.selected;
    }, e.prototype.setPassive = function(t) {
      this.passive = t;
    }, e.prototype.isReadOnly = function() {
      return this.readOnly;
    }, e.prototype.setReadOnly = function(t) {
      this.eWrapper.classList.toggle("ag-disabled", t), this.eInput.disabled = t, this.readOnly = t;
    }, e.prototype.setDisabled = function(t) {
      return this.eWrapper.classList.toggle("ag-disabled", t), n.prototype.setDisabled.call(this, t);
    }, e.prototype.toggle = function() {
      if (!this.eInput.disabled) {
        var t = this.isSelected(), i = this.getNextValue();
        this.passive ? this.dispatchChange(i, t) : this.setValue(i);
      }
    }, e.prototype.getValue = function() {
      return this.isSelected();
    }, e.prototype.setValue = function(t, i) {
      return this.refreshSelectedClass(t), this.setSelected(t, i), this;
    }, e.prototype.setName = function(t) {
      var i = this.getInputElement();
      return i.name = t, this;
    }, e.prototype.isSelected = function() {
      return this.selected;
    }, e.prototype.setSelected = function(t, i) {
      this.isSelected() !== t && (this.previousValue = this.isSelected(), t = this.selected = typeof t == "boolean" ? t : void 0, this.eInput.checked = t, this.eInput.indeterminate = t === void 0, i || this.dispatchChange(this.selected, this.previousValue));
    }, e.prototype.dispatchChange = function(t, i, r) {
      this.dispatchEvent({ type: e.EVENT_CHANGED, selected: t, previousValue: i, event: r });
      var o = this.getInputElement(), s = {
        type: F.EVENT_CHECKBOX_CHANGED,
        id: o.id,
        name: o.name,
        selected: t,
        previousValue: i
      };
      this.eventService.dispatchEvent(s);
    }, e.prototype.onCheckboxClick = function(t) {
      if (!(this.passive || this.eInput.disabled)) {
        var i = this.isSelected(), r = this.selected = t.target.checked;
        this.refreshSelectedClass(r), this.dispatchChange(r, i, t);
      }
    }, e.prototype.refreshSelectedClass = function(t) {
      this.eWrapper.classList.toggle("ag-checked", t === !0), this.eWrapper.classList.toggle("ag-indeterminate", t == null);
    }, e;
  }(Hu)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var xX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), UC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, NX = (
  /** @class */
  function(n) {
    xX(e, n);
    function e(t) {
      var i = n.call(this) || this;
      i.cbSelectAllVisible = !1, i.processingEventFromCheckbox = !1, i.column = t;
      var r = t.getColDef();
      return i.filteredOnly = r ? !!r.headerCheckboxSelectionFilteredOnly : !1, i;
    }
    return e.prototype.onSpaceKeyPressed = function(t) {
      var i = this.cbSelectAll, r = this.gridOptionsWrapper.getDocument();
      i.isDisplayed() && !i.getGui().contains(r.activeElement) && (t.preventDefault(), i.setValue(!i.getValue()));
    }, e.prototype.getCheckboxGui = function() {
      return this.cbSelectAll.getGui();
    }, e.prototype.setComp = function(t) {
      this.comp = t, this.cbSelectAll = this.createManagedBean(new Kp()), this.cbSelectAll.addCssClass("ag-header-select-all"), Do(this.cbSelectAll.getGui(), "presentation"), this.showOrHideSelectAll(), this.addManagedListener(this.eventService, F.EVENT_NEW_COLUMNS_LOADED, this.showOrHideSelectAll.bind(this)), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, this.showOrHideSelectAll.bind(this)), this.addManagedListener(this.eventService, F.EVENT_SELECTION_CHANGED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_MODEL_UPDATED, this.onModelChanged.bind(this)), this.addManagedListener(this.cbSelectAll, Kp.EVENT_CHANGED, this.onCbSelectAll.bind(this)), this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel();
    }, e.prototype.showOrHideSelectAll = function() {
      this.cbSelectAllVisible = this.isCheckboxSelection(), this.cbSelectAll.setDisplayed(this.cbSelectAllVisible), this.cbSelectAllVisible && (this.checkRightRowModelType(), this.updateStateOfCheckbox()), this.refreshHeaderAriaDescribedBy(this.cbSelectAllVisible);
    }, e.prototype.refreshHeaderAriaDescribedBy = function(t) {
      var i = t ? this.cbSelectAll.getInputElement().id : void 0;
      this.comp.setAriaDescribedBy(i);
    }, e.prototype.onModelChanged = function() {
      this.cbSelectAllVisible && this.updateStateOfCheckbox();
    }, e.prototype.onSelectionChanged = function() {
      this.cbSelectAllVisible && this.updateStateOfCheckbox();
    }, e.prototype.getNextCheckboxState = function(t) {
      return t.selected === 0 && t.notSelected === 0 ? !1 : t.selected > 0 && t.notSelected > 0 ? null : t.selected > 0;
    }, e.prototype.updateStateOfCheckbox = function() {
      if (!this.processingEventFromCheckbox) {
        this.processingEventFromCheckbox = !0;
        var t = this.getSelectionCount(), i = this.getNextCheckboxState(t);
        this.cbSelectAll.setValue(i), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = !1;
      }
    }, e.prototype.refreshSelectAllLabel = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = this.cbSelectAll.getValue(), r = i ? t("ariaChecked", "checked") : t("ariaUnchecked", "unchecked"), o = t("ariaRowSelectAll", "Press Space to toggle all rows selection");
      this.cbSelectAll.setInputAriaLabel(o + " (" + r + ")");
    }, e.prototype.getSelectionCount = function() {
      var t = this, i = 0, r = 0, o = function(s) {
        t.gridOptionsWrapper.isGroupSelectsChildren() && s.group || (s.isSelected() ? i++ : s.selectable && r++);
      };
      return this.filteredOnly ? this.gridApi.forEachNodeAfterFilter(o) : this.gridApi.forEachNode(o), {
        notSelected: r,
        selected: i
      };
    }, e.prototype.checkRightRowModelType = function() {
      var t = this.rowModel.getType(), i = t === Z.ROW_MODEL_TYPE_CLIENT_SIDE;
      i || console.warn("AG Grid: selectAllCheckbox is only available if using normal row model, you are using " + t);
    }, e.prototype.onCbSelectAll = function() {
      if (!this.processingEventFromCheckbox && this.cbSelectAllVisible) {
        var t = this.cbSelectAll.getValue();
        t ? this.selectionService.selectAllRowNodes(this.filteredOnly) : this.selectionService.deselectAllRowNodes(this.filteredOnly);
      }
    }, e.prototype.isCheckboxSelection = function() {
      var t = this.column.getColDef().headerCheckboxSelection;
      if (typeof t == "function") {
        var i = t;
        t = i({
          column: this.column,
          colDef: this.column.getColDef(),
          columnApi: this.columnApi,
          api: this.gridApi
        });
      }
      return t ? this.gridOptionsWrapper.isRowModelServerSide() ? (console.warn("AG Grid: headerCheckboxSelection is not supported for Server Side Row Model"), !1) : this.gridOptionsWrapper.isRowModelInfinite() ? (console.warn("AG Grid: headerCheckboxSelection is not supported for Infinite Row Model"), !1) : this.gridOptionsWrapper.isRowModelViewport() ? (console.warn("AG Grid: headerCheckboxSelection is not supported for Viewport Row Model"), !1) : !0 : !1;
    }, UC([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), UC([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), UC([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), UC([
      T("selectionService")
    ], e.prototype, "selectionService", void 0), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var IX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Dl = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, QH = (
  /** @class */
  function(n) {
    IX(e, n);
    function e(t, i) {
      var r = n.call(this, t, i) || this;
      return r.refreshFunctions = [], r.userHeaderClasses = /* @__PURE__ */ new Set(), r.column = t, r;
    }
    return e.prototype.setComp = function(t, i, r) {
      var o = this;
      n.prototype.setGui.call(this, i), this.comp = t, this.colDefVersion = this.columnModel.getColDefVersion(), this.updateState(), this.setupWidth(), this.setupMovingCss(), this.setupMenuClass(), this.setupSortableClass(), this.addColumnHoverListener(), this.setupFilterCss(), this.setupColId(), this.setupClassesFromColDef(), this.setupTooltip(), this.addActiveHeaderMouseListeners(), this.setupSelectAll(), this.setupUserComp(), this.createManagedBean(new TX(this.getPinned(), this.column, r, t, this)), this.createManagedBean(new jx([this.column], i)), this.createManagedBean(new kS(this.column, i, this.beans)), this.createManagedBean(new nc(i, {
        shouldStopEventPropagation: function(s) {
          return o.shouldStopEventPropagation(s);
        },
        onTabKeyDown: function() {
          return null;
        },
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })), this.addManagedListener(this.eventService, F.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this)), this.addManagedListener(this.eventService, F.EVENT_COLUMN_VALUE_CHANGED, this.onColumnValueChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_COLUMN_PIVOT_CHANGED, this.onColumnPivotChanged.bind(this));
    }, e.prototype.setupUserComp = function() {
      var t = this.lookupUserCompDetails();
      this.setCompDetails(t);
    }, e.prototype.setCompDetails = function(t) {
      this.userCompDetails = t, this.comp.setUserCompDetails(t);
    }, e.prototype.lookupUserCompDetails = function() {
      var t = this.createParams(), i = this.column.getColDef();
      return this.userComponentFactory.getHeaderCompDetails(i, t);
    }, e.prototype.createParams = function() {
      var t = this, i = this.column.getColDef(), r = {
        column: this.column,
        displayName: this.displayName,
        enableSorting: i.sortable,
        enableMenu: this.menuEnabled,
        showColumnMenu: function(o) {
          t.gridApi.showColumnMenuAfterButtonClick(t.column, o);
        },
        progressSort: function(o) {
          t.sortController.progressSort(t.column, !!o, "uiColumnSorted");
        },
        setSort: function(o, s) {
          t.sortController.setSortForColumn(t.column, o, !!s, "uiColumnSorted");
        },
        api: this.gridApi,
        columnApi: this.columnApi,
        context: this.gridOptionsWrapper.getContext(),
        eGridHeader: this.getGui()
      };
      return r;
    }, e.prototype.setupSelectAll = function() {
      this.selectAllFeature = this.createManagedBean(new NX(this.column)), this.selectAllFeature.setComp(this.comp);
    }, e.prototype.getSelectAllGui = function() {
      return this.selectAllFeature.getCheckboxGui();
    }, e.prototype.handleKeyDown = function(t) {
      t.key === _e.SPACE && this.selectAllFeature.onSpaceKeyPressed(t), t.key === _e.ENTER && this.onEnterKeyPressed(t);
    }, e.prototype.onEnterKeyPressed = function(t) {
      var i = this.comp.getUserCompInstance();
      if (i) {
        if (t.ctrlKey || t.metaKey)
          this.menuEnabled && i.showMenu && (t.preventDefault(), i.showMenu());
        else if (this.sortable) {
          var r = t.shiftKey;
          this.sortController.progressSort(this.column, r, "uiColumnSorted");
        }
      }
    }, e.prototype.isMenuEnabled = function() {
      return this.menuEnabled;
    }, e.prototype.onFocusIn = function(t) {
      if (!this.getGui().contains(t.relatedTarget)) {
        var i = this.getRowIndex();
        this.focusService.setFocusedHeader(i, this.column);
      }
      this.setActiveHeader(!0);
    }, e.prototype.onFocusOut = function(t) {
      this.getGui().contains(t.relatedTarget) || this.setActiveHeader(!1);
    }, e.prototype.setupTooltip = function() {
      var t = this, i = {
        getColumn: function() {
          return t.column;
        },
        getColDef: function() {
          return t.column.getColDef();
        },
        getGui: function() {
          return t.eGui;
        },
        getLocation: function() {
          return "header";
        },
        getTooltipValue: function() {
          var o = t.column.getColDef().headerTooltip;
          return o;
        }
      }, r = this.createManagedBean(new Hx(i, this.beans));
      r.setComp(this.comp), this.refreshFunctions.push(function() {
        return r.refreshToolTip();
      });
    }, e.prototype.setupClassesFromColDef = function() {
      var t = this, i = function() {
        var r = t.column.getColDef(), o = t.gridOptionsWrapper, s = $x.getHeaderClassesFromColDef(r, o, t.column, null), a = t.userHeaderClasses;
        t.userHeaderClasses = new Set(s), s.forEach(function(l) {
          a.has(l) ? a.delete(l) : t.comp.addOrRemoveCssClass(l, !0);
        }), a.forEach(function(l) {
          return t.comp.addOrRemoveCssClass(l, !1);
        });
      };
      this.refreshFunctions.push(i), i();
    }, e.prototype.setDragSource = function(t) {
      var i = this;
      this.dragSourceElement = t, this.removeDragSource(), t && this.draggable && (this.moveDragSource = {
        type: Ds.HeaderCell,
        eElement: t,
        defaultIconName: wo.ICON_HIDE,
        getDragItem: function() {
          return i.createDragItem();
        },
        dragItemName: this.displayName,
        onDragStarted: function() {
          return i.column.setMoving(!0, "uiColumnMoved");
        },
        onDragStopped: function() {
          return i.column.setMoving(!1, "uiColumnMoved");
        }
      }, this.dragAndDropService.addDragSource(this.moveDragSource, !0));
    }, e.prototype.createDragItem = function() {
      var t = {};
      return t[this.column.getId()] = this.column.isVisible(), {
        columns: [this.column],
        visibleState: t
      };
    }, e.prototype.removeDragSource = function() {
      this.moveDragSource && (this.dragAndDropService.removeDragSource(this.moveDragSource), this.moveDragSource = void 0);
    }, e.prototype.onNewColumnsLoaded = function() {
      var t = this.columnModel.getColDefVersion();
      t != this.colDefVersion && (this.colDefVersion = t, this.refresh());
    }, e.prototype.updateState = function() {
      var t = this.column.getColDef();
      this.menuEnabled = this.menuFactory.isMenuEnabled(this.column) && !t.suppressMenu, this.sortable = t.sortable, this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable();
    }, e.prototype.addRefreshFunction = function(t) {
      this.refreshFunctions.push(t);
    }, e.prototype.refresh = function() {
      this.updateState(), this.refreshHeaderComp(), this.refreshFunctions.forEach(function(t) {
        return t();
      });
    }, e.prototype.refreshHeaderComp = function() {
      var t = this.lookupUserCompDetails(), i = this.comp.getUserCompInstance(), r = i != null && this.userCompDetails.componentClass == t.componentClass, o = r ? this.attemptHeaderCompRefresh(t.params) : !1;
      o ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(t);
    }, e.prototype.attemptHeaderCompRefresh = function(t) {
      var i = this.comp.getUserCompInstance();
      if (!i || !i.refresh)
        return !1;
      var r = i.refresh(t);
      return r;
    }, e.prototype.calculateDisplayName = function() {
      return this.columnModel.getDisplayNameForColumn(this.column, "header", !0);
    }, e.prototype.checkDisplayName = function() {
      this.displayName !== this.calculateDisplayName() && this.refresh();
    }, e.prototype.workOutDraggable = function() {
      var t = this.column.getColDef(), i = this.gridOptionsWrapper.isSuppressMovableColumns(), r = !i && !t.suppressMovable && !t.lockPosition;
      return !!r || !!t.enableRowGroup || !!t.enablePivot;
    }, e.prototype.onColumnRowGroupChanged = function() {
      this.checkDisplayName();
    }, e.prototype.onColumnPivotChanged = function() {
      this.checkDisplayName();
    }, e.prototype.onColumnValueChanged = function() {
      this.checkDisplayName();
    }, e.prototype.setupWidth = function() {
      var t = this, i = function() {
        t.comp.setWidth(t.column.getActualWidth() + "px");
      };
      this.addManagedListener(this.column, Gt.EVENT_WIDTH_CHANGED, i), i();
    }, e.prototype.setupMovingCss = function() {
      var t = this, i = function() {
        t.comp.addOrRemoveCssClass("ag-header-cell-moving", t.column.isMoving());
      };
      this.addManagedListener(this.column, Gt.EVENT_MOVING_CHANGED, i), i();
    }, e.prototype.setupMenuClass = function() {
      var t = this, i = function() {
        t.comp.addOrRemoveCssClass("ag-column-menu-visible", t.column.isMenuVisible());
      };
      this.addManagedListener(this.column, Gt.EVENT_MENU_VISIBLE_CHANGED, i), i();
    }, e.prototype.setupSortableClass = function() {
      var t = this, i = function() {
        t.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!t.sortable);
      }, r = function() {
        t.sortable ? t.comp.setAriaSort(tH(t.column)) : t.comp.setAriaSort(void 0);
      };
      i(), r(), this.addRefreshFunction(i), this.addRefreshFunction(r), this.addManagedListener(this.column, Gt.EVENT_SORT_CHANGED, r);
    }, e.prototype.addColumnHoverListener = function() {
      var t = this, i = function() {
        if (t.gridOptionsWrapper.isColumnHoverHighlight()) {
          var r = t.columnHoverService.isHovered(t.column);
          t.comp.addOrRemoveCssClass("ag-column-hover", r);
        }
      };
      this.addManagedListener(this.eventService, F.EVENT_COLUMN_HOVER_CHANGED, i), i();
    }, e.prototype.setupFilterCss = function() {
      var t = this, i = function() {
        t.comp.addOrRemoveCssClass("ag-header-cell-filtered", t.column.isFilterActive());
      };
      this.addManagedListener(this.column, Gt.EVENT_FILTER_ACTIVE_CHANGED, i), i();
    }, e.prototype.setupColId = function() {
      this.comp.setColId(this.column.getColId());
    }, e.prototype.addActiveHeaderMouseListeners = function() {
      var t = this, i = function(r) {
        return t.setActiveHeader(r.type === "mouseenter");
      };
      this.addManagedListener(this.getGui(), "mouseenter", i), this.addManagedListener(this.getGui(), "mouseleave", i);
    }, e.prototype.setActiveHeader = function(t) {
      this.comp.addOrRemoveCssClass("ag-header-active", t);
    }, Dl([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), Dl([
      T("columnHoverService")
    ], e.prototype, "columnHoverService", void 0), Dl([
      T("beans")
    ], e.prototype, "beans", void 0), Dl([
      T("sortController")
    ], e.prototype, "sortController", void 0), Dl([
      T("menuFactory")
    ], e.prototype, "menuFactory", void 0), Dl([
      T("dragAndDropService")
    ], e.prototype, "dragAndDropService", void 0), Dl([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Dl([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), Dl([
      T("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), Dl([
      To
    ], e.prototype, "removeDragSource", null), e;
  }(P_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var PX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), zC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, AX = (
  /** @class */
  function(n) {
    PX(e, n);
    function e(t, i, r, o) {
      var s = n.call(this) || this;
      return s.eResize = i, s.comp = t, s.pinned = r, s.columnGroup = o, s;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      if (!this.columnGroup.isResizable()) {
        this.comp.addOrRemoveResizableCssClass("ag-hidden", !0);
        return;
      }
      var i = this.horizontalResizeService.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, !1),
        onResizeEnd: this.onResizing.bind(this, !0)
      });
      if (this.addDestroyFunc(i), !this.gridOptionsWrapper.isSuppressAutoSize()) {
        var r = this.gridOptionsWrapper.isSkipHeaderOnAutoSize();
        this.eResize.addEventListener("dblclick", function() {
          var o = [], s = t.columnGroup.getDisplayedLeafColumns();
          s.forEach(function(a) {
            a.getColDef().suppressAutoSize || o.push(a.getColId());
          }), o.length > 0 && t.columnModel.autoSizeColumns({
            columns: o,
            skipHeader: r,
            stopAtGroup: t.columnGroup,
            source: "uiColumnResized"
          }), t.resizeLeafColumnsToFit();
        });
      }
    }, e.prototype.onResizeStart = function(t) {
      var i = this;
      this.calculateInitialValues();
      var r = null;
      if (t && (r = this.columnModel.getDisplayedGroupAfter(this.columnGroup)), r) {
        var o = r.getDisplayedLeafColumns();
        this.resizeTakeFromCols = o.filter(function(s) {
          return s.isResizable();
        }), this.resizeTakeFromStartWidth = 0, this.resizeTakeFromCols.forEach(function(s) {
          return i.resizeTakeFromStartWidth += s.getActualWidth();
        }), this.resizeTakeFromRatios = [], this.resizeTakeFromCols.forEach(function(s) {
          return i.resizeTakeFromRatios.push(s.getActualWidth() / i.resizeTakeFromStartWidth);
        });
      } else
        this.resizeTakeFromCols = null, this.resizeTakeFromStartWidth = null, this.resizeTakeFromRatios = null;
      this.comp.addOrRemoveCssClass("ag-column-resizing", !0);
    }, e.prototype.onResizing = function(t, i) {
      var r = this.normaliseDragChange(i), o = this.resizeStartWidth + r;
      this.resizeColumns(o, t);
    }, e.prototype.resizeLeafColumnsToFit = function() {
      var t = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup);
      this.calculateInitialValues(), t > this.resizeStartWidth && this.resizeColumns(t, !0);
    }, e.prototype.resizeColumns = function(t, i) {
      i === void 0 && (i = !0);
      var r = [];
      if (r.push({
        columns: this.resizeCols,
        ratios: this.resizeRatios,
        width: t
      }), this.resizeTakeFromCols) {
        var o = t - this.resizeStartWidth;
        r.push({
          columns: this.resizeTakeFromCols,
          ratios: this.resizeTakeFromRatios,
          width: this.resizeTakeFromStartWidth - o
        });
      }
      this.columnModel.resizeColumnSets({
        resizeSets: r,
        finished: i,
        source: "uiColumnDragged"
      }), i && this.comp.addOrRemoveCssClass("ag-column-resizing", !1);
    }, e.prototype.calculateInitialValues = function() {
      var t = this, i = this.columnGroup.getDisplayedLeafColumns();
      this.resizeCols = i.filter(function(r) {
        return r.isResizable();
      }), this.resizeStartWidth = 0, this.resizeCols.forEach(function(r) {
        return t.resizeStartWidth += r.getActualWidth();
      }), this.resizeRatios = [], this.resizeCols.forEach(function(r) {
        return t.resizeRatios.push(r.getActualWidth() / t.resizeStartWidth);
      });
    }, e.prototype.normaliseDragChange = function(t) {
      var i = t;
      return this.gridOptionsWrapper.isEnableRtl() ? this.pinned !== Z.PINNED_LEFT && (i *= -1) : this.pinned === Z.PINNED_RIGHT && (i *= -1), i;
    }, zC([
      T("horizontalResizeService")
    ], e.prototype, "horizontalResizeService", void 0), zC([
      T("autoWidthCalculator")
    ], e.prototype, "autoWidthCalculator", void 0), zC([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), zC([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var MX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), FX = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, kX = (
  /** @class */
  function(n) {
    MX(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.removeChildListenersFuncs = [], r.columnGroup = i, r.comp = t, r;
    }
    return e.prototype.postConstruct = function() {
      this.addListenersToChildrenColumns(), this.addManagedListener(this.columnGroup, Qr.EVENT_DISPLAYED_CHILDREN_CHANGED, this.onDisplayedChildrenChanged.bind(this)), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
    }, e.prototype.addListenersToChildrenColumns = function() {
      var t = this;
      this.removeListenersOnChildrenColumns();
      var i = this.onWidthChanged.bind(this);
      this.columnGroup.getLeafColumns().forEach(function(r) {
        r.addEventListener(Gt.EVENT_WIDTH_CHANGED, i), r.addEventListener(Gt.EVENT_VISIBLE_CHANGED, i), t.removeChildListenersFuncs.push(function() {
          r.removeEventListener(Gt.EVENT_WIDTH_CHANGED, i), r.removeEventListener(Gt.EVENT_VISIBLE_CHANGED, i);
        });
      });
    }, e.prototype.removeListenersOnChildrenColumns = function() {
      this.removeChildListenersFuncs.forEach(function(t) {
        return t();
      }), this.removeChildListenersFuncs = [];
    }, e.prototype.onDisplayedChildrenChanged = function() {
      this.addListenersToChildrenColumns(), this.onWidthChanged();
    }, e.prototype.onWidthChanged = function() {
      this.comp.setWidth(this.columnGroup.getActualWidth() + "px");
    }, FX([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var WX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Tf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, JH = (
  /** @class */
  function(n) {
    WX(e, n);
    function e(t, i) {
      var r = n.call(this, t, i) || this;
      return r.columnGroup = t, r;
    }
    return e.prototype.setComp = function(t, i, r) {
      n.prototype.setGui.call(this, i), this.comp = t, this.displayName = this.columnModel.getDisplayNameForColumnGroup(this.columnGroup, "header"), this.addClasses(), this.addAttributes(), this.setupMovingCss(), this.setupExpandable(), this.setupTooltip(), this.setupUserComp();
      var o = this.getParentRowCtrl().getPinned(), s = this.columnGroup.getProvidedColumnGroup().getLeafColumns();
      this.createManagedBean(new jx(s, i)), this.createManagedBean(new kS(this.columnGroup, i, this.beans)), this.createManagedBean(new kX(t, this.columnGroup)), this.groupResizeFeature = this.createManagedBean(new AX(t, r, o, this.columnGroup)), this.createManagedBean(new nc(i, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: function() {
        },
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      }));
    }, e.prototype.resizeLeafColumnsToFit = function() {
      this.groupResizeFeature.onResizeStart(!1), this.groupResizeFeature.resizeLeafColumnsToFit();
    }, e.prototype.setupUserComp = function() {
      var t = this, i = this.displayName, r = {
        displayName: this.displayName,
        columnGroup: this.columnGroup,
        setExpanded: function(u) {
          t.columnModel.setColumnGroupOpened(t.columnGroup.getProvidedColumnGroup(), u, "gridInitializing");
        },
        api: this.gridApi,
        columnApi: this.columnApi,
        context: this.gridOptionsWrapper.getContext()
      };
      if (!i) {
        for (var o = this.columnGroup, s = o.getLeafColumns(); o.getParent() && o.getParent().getLeafColumns().length === s.length; )
          o = o.getParent();
        var a = o.getColGroupDef();
        a && (i = a.headerName), i || (i = s ? this.columnModel.getDisplayNameForColumn(s[0], "header", !0) : "");
      }
      var l = this.userComponentFactory.getHeaderGroupCompDetails(r);
      this.comp.setUserCompDetails(l);
    }, e.prototype.setupTooltip = function() {
      var t = this, i = this.columnGroup.getColGroupDef(), r = {
        getColumn: function() {
          return t.columnGroup;
        },
        getGui: function() {
          return t.eGui;
        },
        getLocation: function() {
          return "headerGroup";
        },
        getTooltipValue: function() {
          return i && i.headerTooltip;
        }
      };
      i && (r.getColDef = function() {
        return i;
      });
      var o = this.createManagedBean(new Hx(r, this.beans));
      o.setComp(this.comp);
    }, e.prototype.setupExpandable = function() {
      var t = this.columnGroup.getProvidedColumnGroup();
      this.refreshExpanded(), this.addManagedListener(t, gn.EVENT_EXPANDABLE_CHANGED, this.refreshExpanded.bind(this)), this.addManagedListener(t, gn.EVENT_EXPANDED_CHANGED, this.refreshExpanded.bind(this));
    }, e.prototype.refreshExpanded = function() {
      var t = this.columnGroup;
      this.expandable = t.isExpandable();
      var i = t.isExpanded();
      this.expandable ? this.comp.setAriaExpanded(i ? "true" : "false") : this.comp.setAriaExpanded(void 0);
    }, e.prototype.addAttributes = function() {
      this.comp.setColId(this.columnGroup.getUniqueId());
    }, e.prototype.addClasses = function() {
      var t = this, i = this.columnGroup.getColGroupDef(), r = $x.getHeaderClassesFromColDef(i, this.gridOptionsWrapper, null, this.columnGroup);
      r.push(this.columnGroup.isPadding() ? "ag-header-group-cell-no-group" : "ag-header-group-cell-with-group"), r.forEach(function(o) {
        return t.comp.addOrRemoveCssClass(o, !0);
      });
    }, e.prototype.setupMovingCss = function() {
      var t = this, i = this.columnGroup.getProvidedColumnGroup(), r = i.getLeafColumns(), o = function() {
        return t.comp.addOrRemoveCssClass("ag-header-cell-moving", t.columnGroup.isMoving());
      };
      r.forEach(function(s) {
        t.addManagedListener(s, Gt.EVENT_MOVING_CHANGED, o);
      }), o();
    }, e.prototype.onFocusIn = function(t) {
      if (!this.eGui.contains(t.relatedTarget)) {
        var i = this.getRowIndex();
        this.beans.focusService.setFocusedHeader(i, this.columnGroup);
      }
    }, e.prototype.handleKeyDown = function(t) {
      var i = this.gridOptionsWrapper.getDocument(), r = i.activeElement, o = r === this.eGui;
      if (!(!this.expandable || !o) && t.key === _e.ENTER) {
        var s = this.columnGroup, a = !s.isExpanded();
        this.columnModel.setColumnGroupOpened(s.getProvidedColumnGroup(), a, "uiColumnExpanded");
      }
    }, e.prototype.setDragSource = function(t) {
      var i = this;
      if (!this.isSuppressMoving()) {
        var r = this.columnGroup.getProvidedColumnGroup().getLeafColumns(), o = {
          type: Ds.HeaderCell,
          eElement: t,
          defaultIconName: wo.ICON_HIDE,
          dragItemName: this.displayName,
          // we add in the original group leaf columns, so we move both visible and non-visible items
          getDragItem: this.getDragItemForGroup.bind(this),
          onDragStarted: function() {
            return r.forEach(function(s) {
              return s.setMoving(!0, "uiColumnDragged");
            });
          },
          onDragStopped: function() {
            return r.forEach(function(s) {
              return s.setMoving(!1, "uiColumnDragged");
            });
          }
        };
        this.dragAndDropService.addDragSource(o, !0), this.addDestroyFunc(function() {
          return i.dragAndDropService.removeDragSource(o);
        });
      }
    }, e.prototype.getDragItemForGroup = function() {
      var t = this.columnGroup.getProvidedColumnGroup().getLeafColumns(), i = {};
      t.forEach(function(o) {
        return i[o.getId()] = o.isVisible();
      });
      var r = [];
      return this.columnModel.getAllDisplayedColumns().forEach(function(o) {
        t.indexOf(o) >= 0 && (r.push(o), Zr(t, o));
      }), t.forEach(function(o) {
        return r.push(o);
      }), {
        columns: r,
        visibleState: i
      };
    }, e.prototype.isSuppressMoving = function() {
      var t = !1;
      this.columnGroup.getLeafColumns().forEach(function(r) {
        (r.getColDef().suppressMovable || r.getColDef().lockPosition) && (t = !0);
      });
      var i = t || this.gridOptionsWrapper.isSuppressMovableColumns();
      return i;
    }, Tf([
      T("beans")
    ], e.prototype, "beans", void 0), Tf([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), Tf([
      T("dragAndDropService")
    ], e.prototype, "dragAndDropService", void 0), Tf([
      T("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), Tf([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Tf([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), e;
  }(P_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var VX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), xL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, BX = 0, Zy = (
  /** @class */
  function(n) {
    VX(e, n);
    function e(t, i, r) {
      var o = n.call(this) || this;
      return o.instanceId = BX++, o.headerCellCtrls = {}, o.rowIndex = t, o.pinned = i, o.type = r, o;
    }
    return e.prototype.getInstanceId = function() {
      return this.instanceId;
    }, e.prototype.setComp = function(t) {
      this.comp = t, this.onRowHeightChanged(), this.onVirtualColumnsChanged(), this.setWidth(), this.addEventListeners(), TS() && this.comp.setTransform("translateZ(0)"), t.setAriaRowIndex(this.rowIndex + 1);
    }, e.prototype.addEventListeners = function() {
      this.addManagedListener(this.eventService, F.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this)), this.addManagedListener(this.gridOptionsWrapper, He.PROP_DOM_LAYOUT, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this)), this.addManagedListener(this.gridOptionsWrapper, He.PROP_HEADER_HEIGHT, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.gridOptionsWrapper, He.PROP_PIVOT_HEADER_HEIGHT, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.gridOptionsWrapper, He.PROP_GROUP_HEADER_HEIGHT, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.gridOptionsWrapper, He.PROP_PIVOT_GROUP_HEADER_HEIGHT, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.gridOptionsWrapper, He.PROP_FLOATING_FILTERS_HEIGHT, this.onRowHeightChanged.bind(this));
    }, e.prototype.getHeaderCellCtrl = function(t) {
      return ef(this.headerCellCtrls).find(function(i) {
        return i.getColumnGroupChild() === t;
      });
    }, e.prototype.onDisplayedColumnsChanged = function() {
      this.onVirtualColumnsChanged(), this.setWidth();
    }, e.prototype.getType = function() {
      return this.type;
    }, e.prototype.onColumnResized = function() {
      this.setWidth();
    }, e.prototype.setWidth = function() {
      var t = this.getWidthForRow();
      this.comp.setWidth(t + "px");
    }, e.prototype.getWidthForRow = function() {
      var t = this.gridOptionsWrapper.getDomLayout() === Z.DOM_LAYOUT_PRINT;
      if (t) {
        var i = this.pinned != null;
        return i ? 0 : this.columnModel.getContainerWidth(Z.PINNED_RIGHT) + this.columnModel.getContainerWidth(Z.PINNED_LEFT) + this.columnModel.getContainerWidth(null);
      }
      return this.columnModel.getContainerWidth(this.pinned);
    }, e.prototype.onRowHeightChanged = function() {
      var t = this.columnModel.getHeaderRowCount(), i = [], r = 0, o, s;
      this.columnModel.isPivotMode() ? (o = this.gridOptionsWrapper.getPivotGroupHeaderHeight(), s = this.gridOptionsWrapper.getPivotHeaderHeight()) : (this.columnModel.hasFloatingFilters() && (t++, r = 1), o = this.gridOptionsWrapper.getGroupHeaderHeight(), s = this.gridOptionsWrapper.getHeaderHeight());
      for (var a = 1 + r, l = t - a, u = 0; u < l; u++)
        i.push(o);
      i.push(s);
      for (var u = 0; u < r; u++)
        i.push(this.gridOptionsWrapper.getFloatingFiltersHeight());
      for (var c = 0, u = 0; u < this.rowIndex; u++)
        c += i[u];
      this.comp.setTop(c + "px"), this.comp.setHeight(i[this.rowIndex] + "px");
    }, e.prototype.getPinned = function() {
      return this.pinned;
    }, e.prototype.getRowIndex = function() {
      return this.rowIndex;
    }, e.prototype.onVirtualColumnsChanged = function() {
      var t = this, i = this.headerCellCtrls;
      this.headerCellCtrls = {};
      var r = this.getColumnsInViewport();
      r.forEach(function(a) {
        if (!a.isEmptyGroup()) {
          var l = a.getUniqueId(), u = i[l];
          delete i[l];
          var c = u && u.getColumnGroupChild() != a;
          if (c && (t.destroyBean(u), u = void 0), u == null)
            switch (t.type) {
              case Jr.FLOATING_FILTER:
                u = t.createBean(new ZH(a, t));
                break;
              case Jr.COLUMN_GROUP:
                u = t.createBean(new JH(a, t));
                break;
              default:
                u = t.createBean(new QH(a, t));
                break;
            }
          t.headerCellCtrls[l] = u;
        }
      });
      var o = function(a) {
        var l = t.focusService.isHeaderWrapperFocused(a);
        if (!l)
          return !1;
        var u = t.columnModel.isDisplayed(a.getColumnGroupChild());
        return u;
      };
      pi(i, function(a, l) {
        var u = o(l);
        u ? t.headerCellCtrls[a] = l : t.destroyBean(l);
      });
      var s = Ja(this.headerCellCtrls);
      this.comp.setHeaderCtrls(s);
    }, e.prototype.destroyCtrls = function() {
      var t = this;
      pi(this.headerCellCtrls, function(i, r) {
        t.destroyBean(r);
      }), this.headerCellCtrls = {};
    }, e.prototype.getColumnsInViewport = function() {
      var t = this.gridOptionsWrapper.getDomLayout() === Z.DOM_LAYOUT_PRINT;
      return t ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
    }, e.prototype.getColumnsInViewportPrintLayout = function() {
      var t = this;
      if (this.pinned != null)
        return [];
      var i = [], r = this.getActualDepth();
      return [Z.PINNED_LEFT, null, Z.PINNED_RIGHT].forEach(function(o) {
        var s = t.columnModel.getVirtualHeaderGroupRow(o, r);
        i = i.concat(s);
      }), i;
    }, e.prototype.getActualDepth = function() {
      return this.type == Jr.FLOATING_FILTER ? this.rowIndex - 1 : this.rowIndex;
    }, e.prototype.getColumnsInViewportNormalLayout = function() {
      return this.columnModel.getVirtualHeaderGroupRow(this.pinned, this.getActualDepth());
    }, e.prototype.focusHeader = function(t, i) {
      var r = Ja(this.headerCellCtrls), o = r.find(function(s) {
        return s.getColumnGroupChild() == t;
      });
      return o ? (o.focus(i), !0) : !1;
    }, xL([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), xL([
      T("focusService")
    ], e.prototype, "focusService", void 0), xL([
      To
    ], e.prototype, "destroyCtrls", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var HX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), vm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, GX = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, UX = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(GX(arguments[e]));
  return n;
}, e4 = (
  /** @class */
  function(n) {
    HX(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.groupsRowCtrls = [], i.pinned = t, i;
    }
    return e.prototype.setComp = function(t, i) {
      this.comp = t, this.setupCenterWidth(), this.setupPinnedWidth(), this.setupDragAndDrop(i), this.addManagedListener(this.eventService, F.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this)), this.ctrlsService.registerHeaderContainer(this, this.pinned), this.columnModel.isReady() && this.refresh();
    }, e.prototype.setupDragAndDrop = function(t) {
      var i = new YH(this.pinned, t);
      this.createManagedBean(i);
    }, e.prototype.refresh = function(t) {
      var i = this;
      t === void 0 && (t = !1);
      var r = new PS(), o = this.focusService.getFocusHeaderToUseAfterRefresh(), s = function() {
        var c = i.columnModel.getHeaderRowCount() - 1;
        i.groupsRowCtrls = i.destroyBeans(i.groupsRowCtrls);
        for (var h = 0; h < c; h++) {
          var d = i.createBean(new Zy(r.next(), i.pinned, Jr.COLUMN_GROUP));
          i.groupsRowCtrls.push(d);
        }
      }, a = function() {
        var c = r.next(), h = i.columnsRowCtrl == null || !t || i.columnsRowCtrl.getRowIndex() !== c;
        h && (i.destroyBean(i.columnsRowCtrl), i.columnsRowCtrl = i.createBean(new Zy(c, i.pinned, Jr.COLUMN)));
      }, l = function() {
        var c = !i.columnModel.isPivotMode() && i.columnModel.hasFloatingFilters(), h = function() {
          i.filtersRowCtrl = i.destroyBean(i.filtersRowCtrl);
        };
        if (!c) {
          h();
          return;
        }
        var d = r.next();
        if (i.filtersRowCtrl) {
          var f = i.filtersRowCtrl.getRowIndex() !== d;
          (!t || f) && h();
        }
        i.filtersRowCtrl || (i.filtersRowCtrl = i.createBean(new Zy(d, i.pinned, Jr.FLOATING_FILTER)));
      };
      s(), a(), l();
      var u = this.getAllCtrls();
      this.comp.setCtrls(u), this.restoreFocusOnHeader(o);
    }, e.prototype.restoreFocusOnHeader = function(t) {
      t == null || t.column.getPinned() != this.pinned || this.focusService.focusHeaderPosition({ headerPosition: t });
    }, e.prototype.getAllCtrls = function() {
      var t = UX(this.groupsRowCtrls, [this.columnsRowCtrl]);
      return this.filtersRowCtrl && t.push(this.filtersRowCtrl), t;
    }, e.prototype.onGridColumnsChanged = function() {
      this.refresh(!0);
    }, e.prototype.setupCenterWidth = function() {
      var t = this;
      this.pinned == null && this.createManagedBean(new Ux(function(i) {
        return t.comp.setCenterWidth(i + "px");
      }));
    }, e.prototype.setHorizontalScroll = function(t) {
      this.comp.setContainerTransform("translateX(" + t + "px)");
    }, e.prototype.setupPinnedWidth = function() {
      var t = this;
      if (this.pinned != null) {
        var i = this.pinned === Z.PINNED_LEFT, r = this.pinned === Z.PINNED_RIGHT, o = function() {
          var s = i ? t.pinnedWidthService.getPinnedLeftWidth() : t.pinnedWidthService.getPinnedRightWidth();
          if (s != null) {
            var a = s == 0, l = t.gridOptionsWrapper.isEnableRtl(), u = t.gridOptionsWrapper.getScrollbarWidth(), c = t.scrollVisibleService.isVerticalScrollShowing() && (l && i || !l && r), h = c ? s + u : s;
            t.comp.setPinnedContainerWidth(h + "px"), t.comp.addOrRemoveCssClass("ag-hidden", a);
          }
        };
        this.addManagedListener(this.eventService, F.EVENT_LEFT_PINNED_WIDTH_CHANGED, o), this.addManagedListener(this.eventService, F.EVENT_RIGHT_PINNED_WIDTH_CHANGED, o), this.addManagedListener(this.eventService, F.EVENT_SCROLL_VISIBILITY_CHANGED, o), this.addManagedListener(this.eventService, F.EVENT_SCROLLBAR_WIDTH_CHANGED, o);
      }
    }, e.prototype.getHeaderCtrlForColumn = function(t) {
      if (t instanceof Gt)
        return this.columnsRowCtrl ? this.columnsRowCtrl.getHeaderCellCtrl(t) : void 0;
      if (this.groupsRowCtrls.length !== 0)
        for (var i = 0; i < this.groupsRowCtrls.length; i++) {
          var r = this.groupsRowCtrls[i].getHeaderCellCtrl(t);
          if (r)
            return r;
        }
    }, e.prototype.getHtmlElementForColumnHeader = function(t) {
      var i = this.getHeaderCtrlForColumn(t);
      return i ? i.getGui() : null;
    }, e.prototype.getRowType = function(t) {
      var i = this.getAllCtrls(), r = i[t];
      return r ? r.getType() : void 0;
    }, e.prototype.focusHeader = function(t, i, r) {
      var o = this.getAllCtrls(), s = o[t];
      return s ? s.focusHeader(i, r) : !1;
    }, e.prototype.getRowCount = function() {
      return this.getAllCtrls().length;
    }, vm([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), vm([
      T("scrollVisibleService")
    ], e.prototype, "scrollVisibleService", void 0), vm([
      T("pinnedWidthService")
    ], e.prototype, "pinnedWidthService", void 0), vm([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), vm([
      T("focusService")
    ], e.prototype, "focusService", void 0), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var zX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), NL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Qy = (
  /** @class */
  function(n) {
    zX(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.headerRowComps = {}, i.rowCompsList = [], i.pinned = t, i;
    }
    return e.prototype.init = function() {
      var t = this;
      this.selectAndSetTemplate();
      var i = {
        addOrRemoveCssClass: function(o, s) {
          return t.addOrRemoveCssClass(o, s);
        },
        setCtrls: function(o) {
          return t.setCtrls(o);
        },
        // only gets called for center section
        setCenterWidth: function(o) {
          return t.eCenterContainer.style.width = o;
        },
        setContainerTransform: function(o) {
          return t.eCenterContainer.style.transform = o;
        },
        // only gets called for pinned sections
        setPinnedContainerWidth: function(o) {
          var s = t.getGui();
          s.style.width = o, s.style.maxWidth = o, s.style.minWidth = o;
        }
      }, r = this.createManagedBean(new e4(this.pinned));
      r.setComp(i, this.getGui());
    }, e.prototype.selectAndSetTemplate = function() {
      var t = this.pinned == Z.PINNED_LEFT, i = this.pinned == Z.PINNED_RIGHT, r = t ? e.PINNED_LEFT_TEMPLATE : i ? e.PINNED_RIGHT_TEMPLATE : e.CENTER_TEMPLATE;
      this.setTemplate(r), this.eRowContainer = this.eCenterContainer ? this.eCenterContainer : this.getGui();
    }, e.prototype.destroyRowComps = function() {
      this.setCtrls([]);
    }, e.prototype.destroyRowComp = function(t) {
      this.destroyBean(t), this.eRowContainer.removeChild(t.getGui());
    }, e.prototype.setCtrls = function(t) {
      var i = this, r = this.headerRowComps;
      this.headerRowComps = {}, this.rowCompsList = [];
      var o, s = function(a) {
        var l = a.getGui(), u = l.parentElement != i.eRowContainer;
        u && i.eRowContainer.appendChild(l), o && wx(i.eRowContainer, l, o), o = l;
      };
      t.forEach(function(a) {
        var l = a.getInstanceId(), u = r[l];
        delete r[l];
        var c = u || i.createBean(new zH(a));
        i.headerRowComps[l] = c, i.rowCompsList.push(c), s(c);
      }), Ja(r).forEach(function(a) {
        return i.destroyRowComp(a);
      });
    }, e.PINNED_LEFT_TEMPLATE = '<div class="ag-pinned-left-header" role="presentation"/>', e.PINNED_RIGHT_TEMPLATE = '<div class="ag-pinned-right-header" role="presentation"/>', e.CENTER_TEMPLATE = `<div class="ag-header-viewport" role="presentation">
            <div class="ag-header-container" ref="eCenterContainer" role="rowgroup"></div>
        </div>`, NL([
      ve("eCenterContainer")
    ], e.prototype, "eCenterContainer", void 0), NL([
      Le
    ], e.prototype, "init", null), NL([
      To
    ], e.prototype, "destroyRowComps", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var jX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), $X = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, t4 = (
  /** @class */
  function(n) {
    jX(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = {
        addOrRemoveCssClass: function(s, a) {
          return t.addOrRemoveCssClass(s, a);
        },
        setHeightAndMinHeight: function(s) {
          t.getGui().style.height = s, t.getGui().style.minHeight = s;
        }
      }, r = this.createManagedBean(new $H());
      r.setComp(i, this.getGui(), this.getFocusableElement());
      var o = function(s) {
        t.createManagedBean(s), t.appendChild(s);
      };
      o(new Qy(Z.PINNED_LEFT)), o(new Qy(null)), o(new Qy(Z.PINNED_RIGHT));
    }, e.TEMPLATE = '<div class="ag-header" role="presentation"/>', $X([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var KX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Zw = globalThis && globalThis.__assign || function() {
  return Zw = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, Zw.apply(this, arguments);
}, Oa = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, i4 = (
  /** @class */
  function(n) {
    KX(e, n);
    function e() {
      var i = n !== null && n.apply(this, arguments) || this;
      return i.allAdvancedFilters = /* @__PURE__ */ new Map(), i.activeAdvancedFilters = [], i.quickFilter = null, i.quickFilterParts = null, i.processingFilterChange = !1, i;
    }
    t = e, e.prototype.init = function() {
      var i = this;
      this.addManagedListener(this.eventService, F.EVENT_ROW_DATA_CHANGED, function(r) {
        return i.onNewRowsLoaded(r);
      }), this.addManagedListener(this.eventService, F.EVENT_GRID_COLUMNS_CHANGED, function() {
        return i.onColumnsChanged();
      }), this.quickFilter = this.parseQuickFilter(this.gridOptionsWrapper.getQuickFilterText()), this.setQuickFilterParts(), this.allowShowChangeAfterFilter = this.gridOptionsWrapper.isAllowShowChangeAfterFilter();
    }, e.prototype.setQuickFilterParts = function() {
      this.quickFilterParts = this.quickFilter ? this.quickFilter.split(" ") : null;
    }, e.prototype.setFilterModel = function(i) {
      var r = this, o = [], s = this.getFilterModel();
      if (i) {
        var a = Px(Object.keys(i));
        this.allAdvancedFilters.forEach(function(l, u) {
          var c = i[u];
          o.push(r.setModelOnFilterWrapper(l.filterPromise, c)), a.delete(u);
        }), a.forEach(function(l) {
          var u = r.columnModel.getPrimaryColumn(l);
          if (!u) {
            console.warn("AG Grid: setFilterModel() - no column found for colId: " + l);
            return;
          }
          if (!u.isFilterAllowed()) {
            console.warn("AG Grid: setFilterModel() - unable to fully apply model, filtering disabled for colId: " + l);
            return;
          }
          var c = r.getOrCreateFilterWrapper(u, "NO_UI");
          if (!c) {
            console.warn("AG-Grid: setFilterModel() - unable to fully apply model, unable to create filter for colId: " + l);
            return;
          }
          o.push(r.setModelOnFilterWrapper(c.filterPromise, i[l]));
        });
      } else
        this.allAdvancedFilters.forEach(function(l) {
          o.push(r.setModelOnFilterWrapper(l.filterPromise, null));
        });
      Bo.all(o).then(function() {
        var l = r.getFilterModel(), u = [];
        r.allAdvancedFilters.forEach(function(c, h) {
          var d = s ? s[h] : null, f = l ? l[h] : null;
          Ad.jsonEquals(d, f) || u.push(c.column);
        }), u.length > 0 && r.onFilterChanged({ columns: u });
      });
    }, e.prototype.setModelOnFilterWrapper = function(i, r) {
      return new Bo(function(o) {
        i.then(function(s) {
          typeof s.setModel != "function" && (console.warn("AG Grid: filter missing setModel method, which is needed for setFilterModel"), o()), (s.setModel(r) || Bo.resolve()).then(function() {
            return o();
          });
        });
      });
    }, e.prototype.getFilterModel = function() {
      var i = {};
      return this.allAdvancedFilters.forEach(function(r, o) {
        var s = r.filterPromise, a = s.resolveNow(null, function(u) {
          return u;
        });
        if (a == null)
          return null;
        if (typeof a.getModel != "function") {
          console.warn("AG Grid: filter API missing getModel method, which is needed for getFilterModel");
          return;
        }
        var l = a.getModel();
        ge(l) && (i[o] = l);
      }), i;
    }, e.prototype.isAdvancedFilterPresent = function() {
      return this.activeAdvancedFilters.length > 0;
    }, e.prototype.updateActiveFilters = function() {
      var i = this;
      this.activeAdvancedFilters.length = 0;
      var r = function(o) {
        return o ? o.isFilterActive ? o.isFilterActive() : (console.warn("AG Grid: Filter is missing isFilterActive() method"), !1) : !1;
      };
      this.allAdvancedFilters.forEach(function(o) {
        if (o.filterPromise.resolveNow(!1, r)) {
          var s = o.filterPromise.resolveNow(null, function(a) {
            return a;
          });
          i.activeAdvancedFilters.push(s);
        }
      });
    }, e.prototype.updateFilterFlagInColumns = function(i, r) {
      this.allAdvancedFilters.forEach(function(o) {
        var s = o.filterPromise.resolveNow(!1, function(a) {
          return a.isFilterActive();
        });
        o.column.setFilterActive(s, i, r);
      });
    }, e.prototype.isAnyFilterPresent = function() {
      return this.isQuickFilterPresent() || this.isAdvancedFilterPresent() || this.gridOptionsWrapper.isExternalFilterPresent();
    }, e.prototype.doAdvancedFiltersPass = function(i, r) {
      for (var o = i.data, s = 0; s < this.activeAdvancedFilters.length; s++) {
        var a = this.activeAdvancedFilters[s];
        if (!(a == null || a === r)) {
          if (typeof a.doesFilterPass != "function")
            throw new Error("Filter is missing method doesFilterPass");
          if (!a.doesFilterPass({ node: i, data: o }))
            return !1;
        }
      }
      return !0;
    }, e.prototype.parseQuickFilter = function(i) {
      return ge(i) ? this.gridOptionsWrapper.isRowModelDefault() ? i.toUpperCase() : (console.warn("AG Grid - Quick filtering only works with the Client-Side Row Model"), null) : null;
    }, e.prototype.setQuickFilter = function(i) {
      if (i != null && typeof i != "string") {
        console.warn("AG Grid - setQuickFilter() only supports string inputs, received: " + typeof i);
        return;
      }
      var r = this.parseQuickFilter(i);
      this.quickFilter !== r && (this.quickFilter = r, this.setQuickFilterParts(), this.onFilterChanged());
    }, e.prototype.onFilterChanged = function(i) {
      i === void 0 && (i = {});
      var r = i.filterInstance, o = i.additionalEventAttributes, s = i.columns;
      this.updateActiveFilters(), this.updateFilterFlagInColumns("filterChanged", o), this.allAdvancedFilters.forEach(function(l) {
        l.filterPromise && l.filterPromise.then(function(u) {
          u && u !== r && u.onAnyFilterChanged && u.onAnyFilterChanged();
        });
      });
      var a = {
        type: F.EVENT_FILTER_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi,
        columns: s || []
      };
      o && ha(a, o), this.processingFilterChange = !0, this.eventService.dispatchEvent(a), this.processingFilterChange = !1;
    }, e.prototype.isSuppressFlashingCellsBecauseFiltering = function() {
      return !this.allowShowChangeAfterFilter && this.processingFilterChange;
    }, e.prototype.isQuickFilterPresent = function() {
      return this.quickFilter !== null;
    }, e.prototype.doesRowPassOtherFilters = function(i, r) {
      return this.doesRowPassFilter({ rowNode: r, filterInstanceToSkip: i });
    }, e.prototype.doesRowPassQuickFilterNoCache = function(i, r) {
      var o = this, s = this.columnModel.getAllColumnsForQuickFilter();
      return s.some(function(a) {
        var l = o.getQuickFilterTextForColumn(a, i);
        return ge(l) && l.indexOf(r) >= 0;
      });
    }, e.prototype.doesRowPassQuickFilterCache = function(i, r) {
      return i.quickFilterAggregateText || this.aggregateRowForQuickFilter(i), i.quickFilterAggregateText.indexOf(r) >= 0;
    }, e.prototype.doesRowPassQuickFilter = function(i) {
      var r = this, o = this.gridOptionsWrapper.isCacheQuickFilter();
      return this.quickFilterParts.every(function(s) {
        return o ? r.doesRowPassQuickFilterCache(i, s) : r.doesRowPassQuickFilterNoCache(i, s);
      });
    }, e.prototype.doesRowPassFilter = function(i) {
      return !(this.isQuickFilterPresent() && !this.doesRowPassQuickFilter(i.rowNode) || this.gridOptionsWrapper.isExternalFilterPresent() && !this.gridOptionsWrapper.doesExternalFilterPass(i.rowNode) || this.isAdvancedFilterPresent() && !this.doAdvancedFiltersPass(i.rowNode, i.filterInstanceToSkip));
    }, e.prototype.getQuickFilterTextForColumn = function(i, r) {
      var o = this.valueService.getValue(i, r, !0), s = i.getColDef();
      if (s.getQuickFilterText) {
        var a = {
          value: o,
          node: r,
          data: r.data,
          column: i,
          colDef: s,
          context: this.gridOptionsWrapper.getContext()
        };
        o = s.getQuickFilterText(a);
      }
      return ge(o) ? o.toString().toUpperCase() : null;
    }, e.prototype.aggregateRowForQuickFilter = function(i) {
      var r = this, o = [], s = this.columnModel.getAllColumnsForQuickFilter();
      s.forEach(function(a) {
        var l = r.getQuickFilterTextForColumn(a, i);
        ge(l) && o.push(l);
      }), i.quickFilterAggregateText = o.join(t.QUICK_FILTER_SEPARATOR);
    }, e.prototype.onNewRowsLoaded = function(i) {
      this.allAdvancedFilters.forEach(function(r) {
        r.filterPromise.then(function(o) {
          o.onNewRowsLoaded && o.onNewRowsLoaded();
        });
      }), this.updateFilterFlagInColumns(i), this.updateActiveFilters();
    }, e.prototype.createValueGetter = function(i) {
      var r = this;
      return function(o) {
        var s = o.node;
        return r.valueService.getValue(i, s, !0);
      };
    }, e.prototype.getFilterComponent = function(i, r, o) {
      o === void 0 && (o = !0);
      var s;
      if (o)
        return ((s = this.getOrCreateFilterWrapper(i, r)) === null || s === void 0 ? void 0 : s.filterPromise) || null;
      var a = this.cachedFilter(i);
      return a ? a.filterPromise : null;
    }, e.prototype.isFilterActive = function(i) {
      var r = this.cachedFilter(i);
      return !!r && r.filterPromise.resolveNow(!1, function(o) {
        return o.isFilterActive();
      });
    }, e.prototype.getOrCreateFilterWrapper = function(i, r) {
      if (!i.isFilterAllowed())
        return null;
      var o = this.cachedFilter(i);
      return o ? r !== "NO_UI" && this.putIntoGui(o, r) : (o = this.createFilterWrapper(i, r), this.allAdvancedFilters.set(i.getColId(), o)), o;
    }, e.prototype.cachedFilter = function(i) {
      return this.allAdvancedFilters.get(i.getColId());
    }, e.prototype.createFilterInstance = function(i, r) {
      var o = this, s = gt.isRegistered(ht.SetFilterModule) ? "agSetColumnFilter" : "agTextColumnFilter", a = i.getColDef(), l, u = Zw(Zw({}, this.createFilterParams(i, a, r)), { filterModifiedCallback: function() {
        var d = {
          type: F.EVENT_FILTER_MODIFIED,
          api: o.gridApi,
          columnApi: o.columnApi,
          column: i,
          filterInstance: l
        };
        o.eventService.dispatchEvent(d);
      }, filterChangedCallback: function(d) {
        return o.onFilterChanged({ filterInstance: l, additionalEventAttributes: d, columns: [i] });
      }, doesRowPassOtherFilter: function(d) {
        return o.doesRowPassOtherFilters(l, d);
      } }), c = this.userComponentFactory.getFilterDetails(a, u, s);
      if (!c)
        return null;
      var h = c.newAgStackInstance();
      return h && h.then(function(d) {
        return l = d;
      }), h;
    }, e.prototype.createFilterParams = function(i, r, o) {
      o === void 0 && (o = null);
      var s = {
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        column: i,
        colDef: fx(r),
        rowModel: this.rowModel,
        filterChangedCallback: function() {
        },
        filterModifiedCallback: function() {
        },
        valueGetter: this.createValueGetter(i),
        context: this.gridOptionsWrapper.getContext(),
        doesRowPassOtherFilter: function() {
          return !0;
        }
      };
      return o && (s.$scope = o), s;
    }, e.prototype.createFilterWrapper = function(i, r) {
      var o = {
        column: i,
        filterPromise: null,
        scope: null,
        compiledElement: null,
        guiPromise: Bo.resolve(null)
      };
      return o.scope = this.gridOptionsWrapper.isAngularCompileFilters() ? this.$scope.$new() : null, o.filterPromise = this.createFilterInstance(i, o.scope), o.filterPromise && this.putIntoGui(o, r), o;
    }, e.prototype.putIntoGui = function(i, r) {
      var o = this, s = document.createElement("div");
      s.className = "ag-filter", i.guiPromise = new Bo(function(a) {
        i.filterPromise.then(function(l) {
          var u = l.getGui();
          if (ge(u) || console.warn("AG Grid: getGui method from filter returned " + u + ", it should be a DOM element or an HTML template string."), typeof u == "string" && (u = Tr(u)), s.appendChild(u), i.scope) {
            var c = o.$compile(s)(i.scope);
            i.compiledElement = c, window.setTimeout(function() {
              return i.scope.$apply();
            }, 0);
          }
          a(s), o.eventService.dispatchEvent({
            type: F.EVENT_FILTER_OPENED,
            column: i.column,
            source: r,
            eGui: s,
            api: o.gridApi,
            columnApi: o.columnApi
          });
        });
      });
    }, e.prototype.onColumnsChanged = function() {
      var i = this, r = [];
      this.allAdvancedFilters.forEach(function(o, s) {
        var a = i.columnModel.getPrimaryColumn(s);
        a || (r.push(o.column), i.disposeFilterWrapper(o, "filterDestroyed"));
      }), r.length > 0 && this.onFilterChanged({ columns: r });
    }, e.prototype.destroyFilter = function(i, r) {
      r === void 0 && (r = "api");
      var o = this.allAdvancedFilters.get(i.getColId());
      o && (this.disposeFilterWrapper(o, r), this.onFilterChanged({ columns: [i] }));
    }, e.prototype.disposeFilterWrapper = function(i, r) {
      var o = this;
      i.filterPromise.then(function(s) {
        (s.setModel(null) || Bo.resolve()).then(function() {
          o.getContext().destroyBean(s), i.column.setFilterActive(!1, r), i.scope && (i.compiledElement && i.compiledElement.remove(), i.scope.$destroy()), o.allAdvancedFilters.delete(i.column.getColId());
        });
      });
    }, e.prototype.destroy = function() {
      var i = this;
      n.prototype.destroy.call(this), this.allAdvancedFilters.forEach(function(r) {
        return i.disposeFilterWrapper(r, "filterDestroyed");
      });
    };
    var t;
    return e.QUICK_FILTER_SEPARATOR = `
`, Oa([
      T("$compile")
    ], e.prototype, "$compile", void 0), Oa([
      T("$scope")
    ], e.prototype, "$scope", void 0), Oa([
      T("valueService")
    ], e.prototype, "valueService", void 0), Oa([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), Oa([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), Oa([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), Oa([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Oa([
      T("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), Oa([
      Le
    ], e.prototype, "init", null), Oa([
      To
    ], e.prototype, "destroy", null), e = t = Oa([
      qe("filterManager")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var qX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _m = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, n4 = (
  /** @class */
  function(n) {
    qX(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.initialised = !1, t;
    }
    return e.prototype.init = function() {
      this.cellExpressions = this.gridOptionsWrapper.isEnableCellExpressions(), this.initialised = !0;
    }, e.prototype.getValue = function(t, i, r, o) {
      if (r === void 0 && (r = !1), o === void 0 && (o = !1), this.initialised || this.init(), !!i) {
        var s = t.getColDef(), a = s.field, l = t.getId(), u = i.data, c, h = i.groupData && i.groupData[l] !== void 0, d = !o && i.aggData && i.aggData[l] !== void 0;
        if (r && s.filterValueGetter ? c = this.executeFilterValueGetter(s.filterValueGetter, u, t, i) : this.gridOptionsWrapper.isTreeData() && d ? c = i.aggData[l] : this.gridOptionsWrapper.isTreeData() && s.valueGetter ? c = this.executeValueGetter(s.valueGetter, u, t, i) : this.gridOptionsWrapper.isTreeData() && a && u ? c = Ww(u, a, t.isFieldContainsDots()) : h ? c = i.groupData[l] : d ? c = i.aggData[l] : s.valueGetter ? c = this.executeValueGetter(s.valueGetter, u, t, i) : a && u && (c = Ww(u, a, t.isFieldContainsDots())), this.cellExpressions && typeof c == "string" && c.indexOf("=") === 0) {
          var f = c.substring(1);
          c = this.executeValueGetter(f, u, t, i);
        }
        if (c == null) {
          var p = this.getOpenedGroup(i, t);
          if (p != null)
            return p;
        }
        return c;
      }
    }, e.prototype.getOpenedGroup = function(t, i) {
      if (this.gridOptionsWrapper.isShowOpenedGroup()) {
        var r = i.getColDef();
        if (r.showRowGroup)
          for (var o = i.getColDef().showRowGroup, s = t.parent; s != null; ) {
            if (s.rowGroupColumn && (o === !0 || o === s.rowGroupColumn.getId()))
              return s.key;
            s = s.parent;
          }
      }
    }, e.prototype.setValue = function(t, i, r, o) {
      var s = this.columnModel.getPrimaryColumn(i);
      if (!(!t || !s)) {
        Je(t.data) && (t.data = {});
        var a = s.getColDef(), l = a.field, u = a.newValueHandler, c = a.valueSetter;
        if (Je(l) && Je(u) && Je(c)) {
          console.warn("AG Grid: you need either field or valueSetter set on colDef for editing to work");
          return;
        }
        var h = {
          node: t,
          data: t.data,
          oldValue: this.getValue(s, t),
          newValue: r,
          colDef: s.getColDef(),
          column: s,
          api: this.gridOptionsWrapper.getApi(),
          columnApi: this.gridOptionsWrapper.getColumnApi(),
          context: this.gridOptionsWrapper.getContext()
        };
        h.newValue = r;
        var d;
        if (u && ge(u) ? d = u(h) : ge(c) ? d = this.expressionService.evaluate(c, h) : d = this.setValueUsingField(t.data, l, r, s.isFieldContainsDots()), d === void 0 && (d = !0), !!d) {
          t.resetQuickFilterAggregateText(), this.valueCache.onDataChanged(), h.newValue = this.getValue(s, t);
          var f = s.getColDef().onCellValueChanged;
          typeof f == "function" && setTimeout(function() {
            return f(h);
          }, 0);
          var p = {
            type: F.EVENT_CELL_VALUE_CHANGED,
            event: null,
            rowIndex: t.rowIndex,
            rowPinned: t.rowPinned,
            column: h.column,
            api: h.api,
            columnApi: h.columnApi,
            colDef: h.colDef,
            context: h.context,
            data: t.data,
            node: t,
            oldValue: h.oldValue,
            newValue: h.newValue,
            value: h.newValue,
            source: o
          };
          this.eventService.dispatchEvent(p);
        }
      }
    }, e.prototype.setValueUsingField = function(t, i, r, o) {
      if (!i)
        return !1;
      var s = !1;
      if (!o)
        t[i] = r;
      else
        for (var a = i.split("."), l = t; a.length > 0 && l; ) {
          var u = a.shift();
          a.length === 0 ? l[u] = r : l = l[u];
        }
      return !s;
    }, e.prototype.executeFilterValueGetter = function(t, i, r, o) {
      var s = {
        data: i,
        node: o,
        column: r,
        colDef: r.getColDef(),
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        context: this.gridOptionsWrapper.getContext(),
        getValue: this.getValueCallback.bind(this, o)
      };
      return this.expressionService.evaluate(t, s);
    }, e.prototype.executeValueGetter = function(t, i, r, o) {
      var s = r.getId(), a = this.valueCache.getValue(o, s);
      if (a !== void 0)
        return a;
      var l = {
        data: i,
        node: o,
        column: r,
        colDef: r.getColDef(),
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        context: this.gridOptionsWrapper.getContext(),
        getValue: this.getValueCallback.bind(this, o)
      }, u = this.expressionService.evaluate(t, l);
      return this.valueCache.setValue(o, s, u), u;
    }, e.prototype.getValueCallback = function(t, i) {
      var r = this.columnModel.getPrimaryColumn(i);
      return r ? this.getValue(r, t) : null;
    }, e.prototype.getKeyForNode = function(t, i) {
      var r = this.getValue(t, i), o = t.getColDef().keyCreator, s = r;
      if (o) {
        var a = {
          value: r,
          colDef: t.getColDef(),
          column: t,
          node: i,
          data: i.data,
          api: this.gridOptionsWrapper.getApi(),
          columnApi: this.gridOptionsWrapper.getColumnApi(),
          context: this.gridOptionsWrapper.getContext()
        };
        s = o(a);
      }
      return typeof s == "string" || s == null || (s = String(s), s === "[object Object]" && mi(function() {
        console.warn("AG Grid: a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key");
      }, "getKeyForNode - warn about [object,object]")), s;
    }, _m([
      T("expressionService")
    ], e.prototype, "expressionService", void 0), _m([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), _m([
      T("valueCache")
    ], e.prototype, "valueCache", void 0), _m([
      Le
    ], e.prototype, "init", null), e = _m([
      qe("valueService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var YX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), sF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Wn;
(function(n) {
  n.AUTO_HEIGHT = "ag-layout-auto-height", n.NORMAL = "ag-layout-normal", n.PRINT = "ag-layout-print";
})(Wn || (Wn = {}));
var Kx = (
  /** @class */
  function(n) {
    YX(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.view = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.gridOptionsWrapper, He.PROP_DOM_LAYOUT, this.updateLayoutClasses.bind(this)), this.updateLayoutClasses();
    }, e.prototype.updateLayoutClasses = function() {
      var t = this.gridOptionsWrapper.getDomLayout(), i = {
        autoHeight: t === Z.DOM_LAYOUT_AUTO_HEIGHT,
        normal: t === Z.DOM_LAYOUT_NORMAL,
        print: t === Z.DOM_LAYOUT_PRINT
      }, r = i.autoHeight ? Wn.AUTO_HEIGHT : i.print ? Wn.PRINT : Wn.NORMAL;
      this.view.updateLayoutClasses(r, i);
    }, sF([
      T("gridOptionsWrapper")
    ], e.prototype, "gridOptionsWrapper", void 0), sF([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var XX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Rl = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, ZX = (
  /** @class */
  function(n) {
    XX(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.scrollLeft = -1, i.nextScrollTop = -1, i.scrollTop = -1, i.eBodyViewport = t, i.resetLastHorizontalScrollElementDebounced = lh(i.resetLastHorizontalScrollElement.bind(i), 500), i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.enableRtl = this.gridOptionsWrapper.isEnableRtl(), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this)), this.ctrlsService.whenReady(function(i) {
        t.centerRowContainerCon = i.centerRowContainerCtrl, t.onDisplayedColumnsWidthChanged(), t.addScrollListener();
      });
    }, e.prototype.addScrollListener = function() {
      var t = this.ctrlsService.getFakeHScrollCtrl();
      this.addManagedListener(this.centerRowContainerCon.getViewportElement(), "scroll", this.onCenterViewportScroll.bind(this)), this.addManagedListener(t.getViewport(), "scroll", this.onFakeHorizontalScroll.bind(this));
      var i = this.gridOptionsWrapper.isDebounceVerticalScrollbar() ? lh(this.onVerticalScroll.bind(this), 100) : this.onVerticalScroll.bind(this);
      this.addManagedListener(this.eBodyViewport, "scroll", i);
    }, e.prototype.onDisplayedColumnsWidthChanged = function() {
      this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter();
    }, e.prototype.horizontallyScrollHeaderCenterAndFloatingCenter = function(t) {
      var i = this.centerRowContainerCon == null;
      if (!i) {
        t === void 0 && (t = this.centerRowContainerCon.getCenterViewportScrollLeft());
        var r = this.enableRtl ? t : -t, o = this.ctrlsService.getTopCenterRowContainerCtrl(), s = this.ctrlsService.getBottomCenterRowContainerCtrl(), a = this.ctrlsService.getFakeHScrollCtrl(), l = this.ctrlsService.getHeaderRowContainerCtrl();
        l.setHorizontalScroll(r), s.setContainerTranslateX(r), o.setContainerTranslateX(r);
        var u = this.lastHorizontalScrollElement === this.centerRowContainerCon.getViewportElement() ? a.getViewport() : this.centerRowContainerCon.getViewportElement();
        Gw(u, Math.abs(t), this.enableRtl);
      }
    }, e.prototype.isControllingScroll = function(t) {
      return this.lastHorizontalScrollElement ? t === this.lastHorizontalScrollElement : (this.lastHorizontalScrollElement = t, !0);
    }, e.prototype.onFakeHorizontalScroll = function() {
      var t = this.ctrlsService.getFakeHScrollCtrl().getViewport();
      this.isControllingScroll(t) && this.onBodyHorizontalScroll(t);
    }, e.prototype.onCenterViewportScroll = function() {
      var t = this.centerRowContainerCon.getViewportElement();
      this.isControllingScroll(t) && this.onBodyHorizontalScroll(t);
    }, e.prototype.onBodyHorizontalScroll = function(t) {
      var i = this.centerRowContainerCon.getViewportElement(), r = i.scrollLeft;
      this.shouldBlockScrollUpdate("horizontal", r, !0) || (this.doHorizontalScroll(Math.round(Uv(t, this.enableRtl))), this.resetLastHorizontalScrollElementDebounced());
    }, e.prototype.onVerticalScroll = function() {
      var t = this.eBodyViewport.scrollTop;
      this.shouldBlockScrollUpdate("vertical", t, !0) || (this.animationFrameService.setScrollTop(t), this.nextScrollTop = t, this.gridOptionsWrapper.isSuppressAnimationFrame() ? (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()) : this.animationFrameService.schedule());
    }, e.prototype.resetLastHorizontalScrollElement = function() {
      this.lastHorizontalScrollElement = null;
    }, e.prototype.doHorizontalScroll = function(t) {
      var i = this.ctrlsService.getFakeHScrollCtrl().getViewport(), r = Uv(i, this.enableRtl);
      this.scrollLeft === t && t === r || (this.scrollLeft = t, this.fireScrollEvent("horizontal"), this.horizontallyScrollHeaderCenterAndFloatingCenter(t), this.onHorizontalViewportChanged());
    }, e.prototype.fireScrollEvent = function(t) {
      var i = this, r = {
        type: F.EVENT_BODY_SCROLL,
        api: this.gridApi,
        columnApi: this.columnApi,
        direction: t,
        left: this.scrollLeft,
        top: this.scrollTop
      };
      this.eventService.dispatchEvent(r), window.clearTimeout(this.scrollTimer), this.scrollTimer = void 0, this.scrollTimer = window.setTimeout(function() {
        var o = Object.assign({}, r, {
          type: F.EVENT_BODY_SCROLL_END
        });
        i.eventService.dispatchEvent(o);
      }, 100);
    }, e.prototype.shouldBlockScrollUpdate = function(t, i, r) {
      if (r === void 0 && (r = !1), r && !Cg())
        return !1;
      if (t === "vertical") {
        var o = x_(this.eBodyViewport), s = this.eBodyViewport.scrollHeight;
        if (i < 0 || i + o > s)
          return !0;
      }
      if (t === "horizontal") {
        var a = this.centerRowContainerCon.getCenterWidth(), l = this.centerRowContainerCon.getViewportElement().scrollWidth;
        if (this.enableRtl && Gv()) {
          if (i > 0)
            return !0;
        } else if (i < 0)
          return !0;
        if (Math.abs(i) + a > l)
          return !0;
      }
      return !1;
    }, e.prototype.redrawRowsAfterScroll = function() {
      this.fireScrollEvent("vertical");
    }, e.prototype.onHorizontalViewportChanged = function() {
      this.centerRowContainerCon.onHorizontalViewportChanged();
    }, e.prototype.checkScrollLeft = function() {
      this.scrollLeft !== this.centerRowContainerCon.getCenterViewportScrollLeft() && this.onBodyHorizontalScroll(this.centerRowContainerCon.getViewportElement());
    }, e.prototype.executeAnimationFrameScroll = function() {
      var t = this.scrollTop != this.nextScrollTop;
      return t && (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()), t;
    }, e.prototype.setHorizontalScrollPosition = function(t) {
      var i = 0, r = this.centerRowContainerCon.getViewportElement().scrollWidth - this.centerRowContainerCon.getCenterWidth();
      this.shouldBlockScrollUpdate("horizontal", t) && (this.enableRtl && Gv() ? t = t > 0 ? 0 : r : t = Math.min(Math.max(t, i), r)), Gw(this.centerRowContainerCon.getViewportElement(), Math.abs(t), this.enableRtl), this.doHorizontalScroll(t);
    }, e.prototype.setVerticalScrollPosition = function(t) {
      this.eBodyViewport.scrollTop = t;
    }, e.prototype.getVScrollPosition = function() {
      var t = {
        top: this.eBodyViewport.scrollTop,
        bottom: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetHeight
      };
      return t;
    }, e.prototype.getHScrollPosition = function() {
      return this.centerRowContainerCon.getHScrollPosition();
    }, e.prototype.isHorizontalScrollShowing = function() {
      return this.centerRowContainerCon.isHorizontalScrollShowing();
    }, e.prototype.scrollHorizontally = function(t) {
      var i = this.centerRowContainerCon.getViewportElement().scrollLeft;
      return this.setHorizontalScrollPosition(i + t), this.centerRowContainerCon.getViewportElement().scrollLeft - i;
    }, e.prototype.scrollToTop = function() {
      this.eBodyViewport.scrollTop = 0;
    }, e.prototype.ensureNodeVisible = function(t, i) {
      i === void 0 && (i = null);
      for (var r = this.rowModel.getRowCount(), o = typeof t == "function", s = -1, a = 0; a < r; a++) {
        var l = this.rowModel.getRow(a);
        if (o) {
          if (t(l)) {
            s = a;
            break;
          }
        } else if (t === l || t === l.data) {
          s = a;
          break;
        }
      }
      s >= 0 && this.ensureIndexVisible(s, i);
    }, e.prototype.ensureIndexVisible = function(t, i) {
      if (this.gridOptionsWrapper.getDomLayout() !== Z.DOM_LAYOUT_PRINT) {
        var r = this.paginationProxy.getRowCount();
        if (typeof t != "number" || t < 0 || t >= r) {
          console.warn("invalid row index for ensureIndexVisible: " + t);
          return;
        }
        var o = this.gridOptionsWrapper.isPagination(), s = o && !this.gridOptionsWrapper.isSuppressPaginationPanel();
        s || this.paginationProxy.goToPageWithIndex(t);
        var a = this.paginationProxy.getRow(t), l;
        do {
          var u = a.rowTop, c = a.rowHeight, h = this.paginationProxy.getPixelOffset(), d = a.rowTop - h, f = d + a.rowHeight, p = this.getVScrollPosition(), g = this.heightScaler.getDivStretchOffset(), _ = p.top + g, m = p.bottom + g, v = m - _, C = this.heightScaler.getScrollPositionForPixel(d), y = this.heightScaler.getScrollPositionForPixel(f - v), w = Math.min((C + y) / 2, d), L = _ > d, S = m < f, E = null;
          i === "top" ? E = C : i === "bottom" ? E = y : i === "middle" ? E = w : L ? E = C : S && (E = y), E !== null && (this.eBodyViewport.scrollTop = E, this.rowRenderer.redrawAfterScroll()), l = u !== a.rowTop || c !== a.rowHeight;
        } while (l);
        this.animationFrameService.flushAllFrames();
      }
    }, e.prototype.ensureColumnVisible = function(t, i) {
      i === void 0 && (i = "auto");
      var r = this.columnModel.getGridColumn(t);
      if (r && !r.isPinned() && this.columnModel.isColumnDisplayed(r)) {
        var o = this.getPositionedHorizontalScroll(r, i);
        o !== null && this.centerRowContainerCon.setCenterViewportScrollLeft(o), this.centerRowContainerCon.onHorizontalViewportChanged(), this.animationFrameService.flushAllFrames();
      }
    }, e.prototype.getPositionedHorizontalScroll = function(t, i) {
      var r = this.isColumnOutsideViewport(t), o = r.columnBeforeStart, s = r.columnAfterEnd, a = this.centerRowContainerCon.getCenterWidth() < t.getActualWidth(), l = this.centerRowContainerCon.getCenterWidth(), u = this.enableRtl, c = (u ? o : s) || a, h = u ? s : o;
      i !== "auto" && (c = i === "start", h = i === "end");
      var d = i === "middle";
      if (c || h || d) {
        var f = this.getColumnBounds(t), p = f.colLeft, g = f.colMiddle, _ = f.colRight;
        return d ? g - l / 2 : c ? u ? _ : p : u ? p - l : _ - l;
      }
      return null;
    }, e.prototype.isColumnOutsideViewport = function(t) {
      var i = this.getViewportBounds(), r = i.start, o = i.end, s = this.getColumnBounds(t), a = s.colLeft, l = s.colRight, u = this.enableRtl, c = u ? r > l : o < l, h = u ? o < a : r > a;
      return { columnBeforeStart: c, columnAfterEnd: h };
    }, e.prototype.getColumnBounds = function(t) {
      var i = this.enableRtl, r = this.columnModel.getBodyContainerWidth(), o = t.getActualWidth(), s = t.getLeft(), a = i ? -1 : 1, l = i ? r - s : s, u = l + o * a, c = l + o / 2 * a;
      return { colLeft: l, colMiddle: c, colRight: u };
    }, e.prototype.getViewportBounds = function() {
      var t = this.centerRowContainerCon.getCenterWidth(), i = this.centerRowContainerCon.getCenterViewportScrollLeft(), r = i, o = t + i;
      return { start: r, end: o, width: t };
    }, Rl([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Rl([
      T("animationFrameService")
    ], e.prototype, "animationFrameService", void 0), Rl([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), Rl([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Rl([
      T("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), Rl([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), Rl([
      T("rowContainerHeightService")
    ], e.prototype, "heightScaler", void 0), Rl([
      T("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), Rl([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), Rl([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var r4 = (
  /** @class */
  function() {
    function n(e) {
      this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = e.scrollAxis.indexOf("x") !== -1, this.scrollVertically = e.scrollAxis.indexOf("y") !== -1, this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || function() {
        return !1;
      }, this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || function() {
        return !1;
      };
    }
    return n.prototype.check = function(e, t) {
      t === void 0 && (t = !1);
      var i = t || this.shouldSkipVerticalScroll();
      if (!(i && this.shouldSkipHorizontalScroll())) {
        var r = this.scrollContainer.getBoundingClientRect(), o = this.scrollByTick;
        this.tickLeft = e.clientX < r.left + o, this.tickRight = e.clientX > r.right - o, this.tickUp = e.clientY < r.top + o && !i, this.tickDown = e.clientY > r.bottom - o && !i, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared();
      }
    }, n.prototype.ensureTickingStarted = function() {
      this.tickingInterval === null && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0);
    }, n.prototype.doTick = function() {
      this.tickCount++;
      var e;
      if (e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40, this.scrollVertically) {
        var t = this.getVerticalPosition();
        this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e);
      }
      if (this.scrollHorizontally) {
        var i = this.getHorizontalPosition();
        this.tickLeft && this.setHorizontalPosition(i - e), this.tickRight && this.setHorizontalPosition(i + e);
      }
      this.onScrollCallback && this.onScrollCallback();
    }, n.prototype.ensureCleared = function() {
      this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null);
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var QX = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), rR = globalThis && globalThis.__assign || function() {
  return rR = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, rR.apply(this, arguments);
}, Ao = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, JX = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, eZ = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(JX(arguments[e]));
  return n;
}, tZ = (
  /** @class */
  function(n) {
    QX(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.isMultiRowDrag = !1, i.isGridSorted = !1, i.isGridFiltered = !1, i.isRowGroupActive = !1, i.eContainer = t, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.gridOptionsWrapper.isRowModelDefault() && (this.clientSideRowModel = this.rowModel);
      var i = function() {
        t.onSortChanged(), t.onFilterChanged(), t.onRowGroupChanged();
      };
      this.addManagedListener(this.eventService, F.EVENT_SORT_CHANGED, this.onSortChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_MODEL_UPDATED, function() {
        i();
      }), i(), this.ctrlsService.whenReady(function() {
        var r = t.ctrlsService.getGridBodyCtrl();
        t.autoScrollService = new r4({
          scrollContainer: r.getBodyViewportElement(),
          scrollAxis: "y",
          getVerticalPosition: function() {
            return r.getScrollFeature().getVScrollPosition().top;
          },
          setVerticalPosition: function(o) {
            return r.getScrollFeature().setVerticalScrollPosition(o);
          },
          onScrollCallback: function() {
            t.onDragging(t.lastDraggingEvent);
          }
        });
      });
    }, e.prototype.onSortChanged = function() {
      this.isGridSorted = this.sortController.isSortActive();
    }, e.prototype.onFilterChanged = function() {
      this.isGridFiltered = this.filterManager.isAnyFilterPresent();
    }, e.prototype.onRowGroupChanged = function() {
      var t = this.columnModel.getRowGroupColumns();
      this.isRowGroupActive = !ms(t);
    }, e.prototype.getContainer = function() {
      return this.eContainer;
    }, e.prototype.isInterestedIn = function(t) {
      return t === Ds.RowDrag;
    }, e.prototype.getIconName = function() {
      var t = this.gridOptionsWrapper.isRowDragManaged();
      return t && this.shouldPreventRowMove() ? wo.ICON_NOT_ALLOWED : wo.ICON_MOVE;
    }, e.prototype.shouldPreventRowMove = function() {
      return this.isGridSorted || this.isGridFiltered || this.isRowGroupActive;
    }, e.prototype.getRowNodes = function(t) {
      var i = this;
      if (!this.isFromThisGrid(t))
        return t.dragItem.rowNodes || [];
      var r = this.gridOptionsWrapper.isRowDragMultiRow(), o = eZ(this.selectionService.getSelectedNodes()).sort(function(a, l) {
        return i.getRowIndexNumber(a) - i.getRowIndexNumber(l);
      }), s = t.dragItem.rowNode;
      return r && o.indexOf(s) !== -1 ? (this.isMultiRowDrag = !0, o) : (this.isMultiRowDrag = !1, [s]);
    }, e.prototype.onDragEnter = function(t) {
      t.dragItem.rowNodes = this.getRowNodes(t), this.dispatchGridEvent(F.EVENT_ROW_DRAG_ENTER, t), this.getRowNodes(t).forEach(function(i) {
        i.setDragging(!0);
      }), this.onEnterOrDragging(t);
    }, e.prototype.onDragging = function(t) {
      this.onEnterOrDragging(t);
    }, e.prototype.isFromThisGrid = function(t) {
      var i = t.dragSource.dragSourceDomDataKey;
      return i === this.gridOptionsWrapper.getDomDataKey();
    }, e.prototype.isDropZoneWithinThisGrid = function(t) {
      var i = this.ctrlsService.getGridBodyCtrl(), r = i.getGui(), o = t.dropZoneTarget;
      return !r.contains(o);
    }, e.prototype.onEnterOrDragging = function(t) {
      this.dispatchGridEvent(F.EVENT_ROW_DRAG_MOVE, t), this.lastDraggingEvent = t;
      var i = this.mouseEventService.getNormalisedPosition(t).y, r = this.gridOptionsWrapper.isRowDragManaged();
      r && this.doManagedDrag(t, i), this.autoScrollService.check(t.event);
    }, e.prototype.doManagedDrag = function(t, i) {
      var r = this.isFromThisGrid(t), o = this.gridOptionsWrapper.isRowDragManaged(), s = t.dragItem.rowNodes;
      o && this.shouldPreventRowMove() || (this.gridOptionsWrapper.isSuppressMoveWhenRowDragging() || !r ? this.isDropZoneWithinThisGrid(t) || this.clientSideRowModel.highlightRowAtPixel(s[0], i) : this.moveRows(s, i));
    }, e.prototype.getRowIndexNumber = function(t) {
      return parseInt(Ti(t.getRowIndexString().split("-")), 10);
    }, e.prototype.moveRowAndClearHighlight = function(t) {
      var i = this, r = this.clientSideRowModel.getLastHighlightedRowNode(), o = r && r.highlighted === Md.Below, s = this.mouseEventService.getNormalisedPosition(t).y, a = t.dragItem.rowNodes, l = o ? 1 : 0;
      if (this.isFromThisGrid(t))
        a.forEach(function(h) {
          h.rowTop < s && (l -= 1);
        }), this.moveRows(a, s, l);
      else {
        var u = this.gridOptionsWrapper.getRowIdFunc(), c = this.clientSideRowModel.getRowIndexAtPixel(s) + 1;
        this.clientSideRowModel.getHighlightPosition(s) === Md.Above && c--, this.clientSideRowModel.updateRowData({
          add: a.map(function(h) {
            return h.data;
          }).filter(function(h) {
            return !i.clientSideRowModel.getRowNode(u ? u({ data: h, level: 0, api: i.gridApi, columnApi: i.columnApi }) : h.id);
          }),
          addIndex: c
        });
      }
      this.clearRowHighlight();
    }, e.prototype.clearRowHighlight = function() {
      this.clientSideRowModel.highlightRowAtPixel(null);
    }, e.prototype.moveRows = function(t, i, r) {
      r === void 0 && (r = 0);
      var o = this.clientSideRowModel.ensureRowsAtPixel(t, i, r);
      o && (this.focusService.clearFocusedCell(), this.rangeService && this.rangeService.removeAllCellRanges());
    }, e.prototype.addRowDropZone = function(t) {
      var i = this;
      if (!t.getContainer()) {
        mi(function() {
          return console.warn("AG Grid: addRowDropZone - A container target needs to be provided");
        }, "add-drop-zone-empty-target");
        return;
      }
      if (this.dragAndDropService.findExternalZone(t)) {
        console.warn("AG Grid: addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.");
        return;
      }
      var r = {
        getContainer: t.getContainer
      };
      t.fromGrid ? (t.fromGrid = void 0, r = t) : (t.onDragEnter && (r.onDragEnter = function(o) {
        t.onDragEnter(i.draggingToRowDragEvent(F.EVENT_ROW_DRAG_ENTER, o));
      }), t.onDragLeave && (r.onDragLeave = function(o) {
        t.onDragLeave(i.draggingToRowDragEvent(F.EVENT_ROW_DRAG_LEAVE, o));
      }), t.onDragging && (r.onDragging = function(o) {
        t.onDragging(i.draggingToRowDragEvent(F.EVENT_ROW_DRAG_MOVE, o));
      }), t.onDragStop && (r.onDragStop = function(o) {
        t.onDragStop(i.draggingToRowDragEvent(F.EVENT_ROW_DRAG_END, o));
      })), this.dragAndDropService.addDropTarget(rR({ isInterestedIn: function(o) {
        return o === Ds.RowDrag;
      }, getIconName: function() {
        return wo.ICON_MOVE;
      }, external: !0 }, r));
    }, e.prototype.getRowDropZone = function(t) {
      var i = this, r = this.getContainer.bind(this), o = this.onDragEnter.bind(this), s = this.onDragLeave.bind(this), a = this.onDragging.bind(this), l = this.onDragStop.bind(this);
      return t ? {
        getContainer: r,
        onDragEnter: t.onDragEnter ? function(u) {
          o(u), t.onDragEnter(i.draggingToRowDragEvent(F.EVENT_ROW_DRAG_ENTER, u));
        } : o,
        onDragLeave: t.onDragLeave ? function(u) {
          s(u), t.onDragLeave(i.draggingToRowDragEvent(F.EVENT_ROW_DRAG_LEAVE, u));
        } : s,
        onDragging: t.onDragging ? function(u) {
          a(u), t.onDragging(i.draggingToRowDragEvent(F.EVENT_ROW_DRAG_MOVE, u));
        } : a,
        onDragStop: t.onDragStop ? function(u) {
          l(u), t.onDragStop(i.draggingToRowDragEvent(F.EVENT_ROW_DRAG_END, u));
        } : l,
        fromGrid: !0
        /* @private */
      } : {
        getContainer: r,
        onDragEnter: o,
        onDragLeave: s,
        onDragging: a,
        onDragStop: l,
        /* @private */
        fromGrid: !0
      };
    }, e.prototype.draggingToRowDragEvent = function(t, i) {
      var r = this.mouseEventService.getNormalisedPosition(i).y, o = r > this.paginationProxy.getCurrentPageHeight(), s = -1, a;
      o || (s = this.rowModel.getRowIndexAtPixel(r), a = this.rowModel.getRow(s));
      var l;
      switch (i.vDirection) {
        case Fd.Down:
          l = "down";
          break;
        case Fd.Up:
          l = "up";
          break;
        default:
          l = null;
          break;
      }
      var u = {
        type: t,
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        event: i.event,
        node: i.dragItem.rowNode,
        nodes: i.dragItem.rowNodes,
        overIndex: s,
        overNode: a,
        y: r,
        vDirection: l
      };
      return u;
    }, e.prototype.dispatchGridEvent = function(t, i) {
      var r = this.draggingToRowDragEvent(t, i);
      this.eventService.dispatchEvent(r);
    }, e.prototype.onDragLeave = function(t) {
      this.dispatchGridEvent(F.EVENT_ROW_DRAG_LEAVE, t), this.stopDragging(t), this.gridOptionsWrapper.isRowDragManaged() && this.clearRowHighlight(), this.isFromThisGrid(t) && (this.isMultiRowDrag = !1);
    }, e.prototype.onDragStop = function(t) {
      this.dispatchGridEvent(F.EVENT_ROW_DRAG_END, t), this.stopDragging(t), this.gridOptionsWrapper.isRowDragManaged() && (this.gridOptionsWrapper.isSuppressMoveWhenRowDragging() || !this.isFromThisGrid(t)) && !this.isDropZoneWithinThisGrid(t) && this.moveRowAndClearHighlight(t);
    }, e.prototype.stopDragging = function(t) {
      this.autoScrollService.ensureCleared(), this.getRowNodes(t).forEach(function(i) {
        i.setDragging(!1);
      });
    }, Ao([
      T("dragAndDropService")
    ], e.prototype, "dragAndDropService", void 0), Ao([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), Ao([
      T("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), Ao([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), Ao([
      T("focusService")
    ], e.prototype, "focusService", void 0), Ao([
      T("sortController")
    ], e.prototype, "sortController", void 0), Ao([
      T("filterManager")
    ], e.prototype, "filterManager", void 0), Ao([
      T("selectionService")
    ], e.prototype, "selectionService", void 0), Ao([
      T("mouseEventService")
    ], e.prototype, "mouseEventService", void 0), Ao([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Ao([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), Ao([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), Ao([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Ao([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var iZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ss = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, kd;
(function(n) {
  n.ANIMATION_ON = "ag-row-animation", n.ANIMATION_OFF = "ag-row-no-animation";
})(kd || (kd = {}));
var o4 = "ag-selectable", s4 = "ag-force-vertical-scroll", a4 = "ag-column-moving", l4 = (
  /** @class */
  function(n) {
    iZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.angularApplyTriggered = !1, t;
    }
    return e.prototype.getScrollFeature = function() {
      return this.bodyScrollFeature;
    }, e.prototype.getBodyViewportElement = function() {
      return this.eBodyViewport;
    }, e.prototype.setComp = function(t, i, r, o, s) {
      this.comp = t, this.eGridBody = i, this.eBodyViewport = r, this.eTop = o, this.eBottom = s, this.setCellTextSelection(this.gridOptionsWrapper.isEnableCellTextSelect()), this.createManagedBean(new Kx(this.comp)), this.bodyScrollFeature = this.createManagedBean(new ZX(this.eBodyViewport)), this.addRowDragListener(), this.setupRowAnimationCssClass(), this.ctrlsService.registerGridBodyCtrl(this), this.addEventListeners(), this.addFocusListeners([o, r, s]), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), this.$scope && this.addAngularApplyCheck();
    }, e.prototype.getComp = function() {
      return this.comp;
    }, e.prototype.addEventListeners = function() {
      this.addManagedListener(this.eventService, F.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_PINNED_ROW_DATA_CHANGED, this.setFloatingHeights.bind(this));
    }, e.prototype.addFocusListeners = function(t) {
      var i = this;
      t.forEach(function(r) {
        i.addManagedListener(r, "focusin", function() {
          r.classList.add("ag-has-focus");
        }), i.addManagedListener(r, "focusout", function(o) {
          r.contains(o.relatedTarget) || r.classList.remove("ag-has-focus");
        });
      });
    }, e.prototype.setColumnMovingCss = function(t) {
      this.comp.setColumnMovingCss(t ? a4 : null, t);
    }, e.prototype.setCellTextSelection = function(t) {
      t === void 0 && (t = !1);
      var i = t ? o4 : null;
      this.comp.setCellSelectableCss(i, t);
    }, e.prototype.onScrollVisibilityChanged = function() {
      var t = this.scrollVisibleService.isVerticalScrollShowing();
      this.setVerticalScrollPaddingVisible(t);
    }, e.prototype.onGridColumnsChanged = function() {
      var t = this.columnModel.getAllGridColumns();
      this.comp.setColumnCount(t ? t.length : 0);
    }, e.prototype.disableBrowserDragging = function() {
      this.addManagedListener(this.eGridBody, "dragstart", function(t) {
        if (t.target instanceof HTMLImageElement)
          return t.preventDefault(), !1;
      });
    }, e.prototype.addStopEditingWhenGridLosesFocus = function() {
      var t = this;
      if (this.gridOptionsWrapper.isStopEditingWhenCellsLoseFocus()) {
        var i = function(o) {
          var s = o.relatedTarget;
          if (Hw(s) === null) {
            t.rowRenderer.stopEditing();
            return;
          }
          var a = (
            // see if click came from inside the viewports
            r.some(function(u) {
              return u.contains(s);
            }) && t.mouseEventService.isElementInThisGrid(s)
          );
          if (!a) {
            var l = t.popupService;
            a = l.getActivePopups().some(function(u) {
              return u.contains(s);
            }) || l.isElementWithinCustomPopup(s);
          }
          a || t.rowRenderer.stopEditing();
        }, r = [this.eBodyViewport, this.eBottom, this.eTop];
        r.forEach(function(o) {
          return t.addManagedListener(o, "focusout", i);
        });
      }
    }, e.prototype.updateRowCount = function() {
      var t = this.headerNavigationService.getHeaderRowCount(), i = this.paginationProxy.getType(), r = -1;
      i === Z.ROW_MODEL_TYPE_CLIENT_SIDE && (r = 0, this.paginationProxy.forEachNode(function(s) {
        s.group || r++;
      }));
      var o = r === -1 ? -1 : t + r;
      this.comp.setRowCount(o);
    }, e.prototype.registerBodyViewportResizeListener = function(t) {
      this.comp.registerBodyViewportResizeListener(t);
    }, e.prototype.setVerticalScrollPaddingVisible = function(t) {
      var i = t ? "scroll" : "hidden";
      this.comp.setPinnedTopBottomOverflowY(i);
    }, e.prototype.isVerticalScrollShowing = function() {
      var t = this.gridOptionsWrapper.isAlwaysShowVerticalScroll(), i = t ? s4 : null;
      return this.comp.setAlwaysVerticalScrollClass(i, t), t || YB(this.eBodyViewport);
    }, e.prototype.setupRowAnimationCssClass = function() {
      var t = this, i = function() {
        var r = t.gridOptionsWrapper.isAnimateRows() && !t.rowContainerHeightService.isStretching(), o = r ? kd.ANIMATION_ON : kd.ANIMATION_OFF;
        t.comp.setRowAnimationCssOnBodyViewport(o, r);
      };
      i(), this.addManagedListener(this.eventService, F.EVENT_HEIGHT_SCALE_CHANGED, i);
    }, e.prototype.getGridBodyElement = function() {
      return this.eGridBody;
    }, e.prototype.addBodyViewportListener = function() {
      var t = this, i = function(r) {
        t.gridOptionsWrapper.isPreventDefaultOnContextMenu() && r.preventDefault();
        var o = r.target;
        (o === t.eBodyViewport || o === t.ctrlsService.getCenterRowContainerCtrl().getViewportElement()) && t.contextMenuFactory && t.contextMenuFactory.onContextMenu(r, null, null, null, null, t.eGridBody);
      };
      this.addManagedListener(this.eBodyViewport, "contextmenu", i), this.addManagedListener(this.eBodyViewport, "wheel", this.onWheel.bind(this));
    }, e.prototype.onWheel = function(t) {
      this.gridOptionsWrapper.isSuppressScrollWhenPopupsAreOpen() && this.popupService.hasAnchoredPopup() && t.preventDefault();
    }, e.prototype.getGui = function() {
      return this.eGridBody;
    }, e.prototype.scrollVertically = function(t) {
      var i = this.eBodyViewport.scrollTop;
      return this.bodyScrollFeature.setVerticalScrollPosition(i + t), this.eBodyViewport.scrollTop - i;
    }, e.prototype.addRowDragListener = function() {
      this.rowDragFeature = this.createManagedBean(new tZ(this.eBodyViewport)), this.dragAndDropService.addDropTarget(this.rowDragFeature);
    }, e.prototype.getRowDragFeature = function() {
      return this.rowDragFeature;
    }, e.prototype.setFloatingHeights = function() {
      var t = this.pinnedRowModel, i = t.getPinnedTopTotalHeight();
      i && (i += 1);
      var r = t.getPinnedBottomTotalHeight();
      r && (r += 1), this.comp.setTopHeight(i), this.comp.setBottomHeight(r), this.comp.setTopDisplay(i ? "inherit" : "none"), this.comp.setBottomDisplay(r ? "inherit" : "none");
    }, e.prototype.sizeColumnsToFit = function(t) {
      var i = this, r = this.isVerticalScrollShowing(), o = r ? this.gridOptionsWrapper.getScrollbarWidth() : 0, s = xS(this.eBodyViewport), a = s - o;
      if (a > 0) {
        this.columnModel.sizeColumnsToFit(a, "sizeColumnsToFit");
        return;
      }
      t === void 0 ? window.setTimeout(function() {
        i.sizeColumnsToFit(100);
      }, 0) : t === 100 ? window.setTimeout(function() {
        i.sizeColumnsToFit(500);
      }, 100) : t === 500 ? window.setTimeout(function() {
        i.sizeColumnsToFit(-1);
      }, 500) : console.warn("AG Grid: tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?");
    }, e.prototype.addScrollEventListener = function(t) {
      this.eBodyViewport.addEventListener("scroll", t);
    }, e.prototype.removeScrollEventListener = function(t) {
      this.eBodyViewport.removeEventListener("scroll", t);
    }, e.prototype.requestAngularApply = function() {
      var t = this;
      this.angularApplyTriggered || (this.angularApplyTriggered = !0, window.setTimeout(function() {
        t.angularApplyTriggered = !1, t.$scope.$apply();
      }, 0));
    }, e.prototype.addAngularApplyCheck = function() {
      var t = this;
      this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, function() {
        return t.requestAngularApply();
      }), this.addManagedListener(this.eventService, F.EVENT_VIRTUAL_COLUMNS_CHANGED, function() {
        return t.requestAngularApply();
      });
    }, ss([
      T("rowContainerHeightService")
    ], e.prototype, "rowContainerHeightService", void 0), ss([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), ss([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), ss([
      T("scrollVisibleService")
    ], e.prototype, "scrollVisibleService", void 0), ss([
      fi("contextMenuFactory")
    ], e.prototype, "contextMenuFactory", void 0), ss([
      T("headerNavigationService")
    ], e.prototype, "headerNavigationService", void 0), ss([
      T("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), ss([
      T("dragAndDropService")
    ], e.prototype, "dragAndDropService", void 0), ss([
      T("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), ss([
      T("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), ss([
      T("popupService")
    ], e.prototype, "popupService", void 0), ss([
      T("mouseEventService")
    ], e.prototype, "mouseEventService", void 0), ss([
      T("$scope")
    ], e.prototype, "$scope", void 0), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var nZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Vh = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, rZ = (
  /* html */
  `<div class="ag-root ag-unselectable" role="grid">
        <ag-header-root ref="gridHeader"></ag-header-root>
        <div class="ag-floating-top" ref="eTop" role="presentation">
            <ag-row-container ref="topLeftContainer" name="` + we.TOP_LEFT + `"></ag-row-container>
            <ag-row-container ref="topCenterContainer" name="` + we.TOP_CENTER + `"></ag-row-container>
            <ag-row-container ref="topRightContainer" name="` + we.TOP_RIGHT + `"></ag-row-container>
            <ag-row-container ref="topFullWidthContainer" name="` + we.TOP_FULL_WIDTH + `"></ag-row-container>
        </div>
        <div class="ag-body-viewport" ref="eBodyViewport" role="presentation">
            <ag-row-container ref="leftContainer" name="` + we.LEFT + `"></ag-row-container>
            <ag-row-container ref="centerContainer" name="` + we.CENTER + `"></ag-row-container>
            <ag-row-container ref="rightContainer" name="` + we.RIGHT + `"></ag-row-container>
            <ag-row-container ref="fullWidthContainer" name="` + we.FULL_WIDTH + `"></ag-row-container>
        </div>
        <div class="ag-floating-bottom" ref="eBottom" role="presentation">
            <ag-row-container ref="bottomLeftContainer" name="` + we.BOTTOM_LEFT + `"></ag-row-container>
            <ag-row-container ref="bottomCenterContainer" name="` + we.BOTTOM_CENTER + `"></ag-row-container>
            <ag-row-container ref="bottomRightContainer" name="` + we.BOTTOM_RIGHT + `"></ag-row-container>
            <ag-row-container ref="bottomFullWidthContainer" name="` + we.BOTTOM_FULL_WIDTH + `"></ag-row-container>
        </div>
        <ag-fake-horizontal-scroll></ag-fake-horizontal-scroll>
        <ag-overlay-wrapper></ag-overlay-wrapper>
    </div>`
), u4 = (
  /** @class */
  function(n) {
    nZ(e, n);
    function e() {
      return n.call(this, rZ) || this;
    }
    return e.prototype.init = function() {
      var t = this, i = function(o, s) {
        var a = o + "px";
        s.style.minHeight = a, s.style.height = a;
      }, r = {
        setRowAnimationCssOnBodyViewport: function(o, s) {
          return t.setRowAnimationCssOnBodyViewport(o, s);
        },
        setColumnCount: function(o) {
          return aH(t.getGui(), o);
        },
        setRowCount: function(o) {
          return sH(t.getGui(), o);
        },
        setTopHeight: function(o) {
          return i(o, t.eTop);
        },
        setBottomHeight: function(o) {
          return i(o, t.eBottom);
        },
        setTopDisplay: function(o) {
          return t.eTop.style.display = o;
        },
        setBottomDisplay: function(o) {
          return t.eBottom.style.display = o;
        },
        setColumnMovingCss: function(o, s) {
          return t.addOrRemoveCssClass(a4, s);
        },
        updateLayoutClasses: function(o, s) {
          var a = t.eBodyViewport.classList;
          a.toggle(Wn.AUTO_HEIGHT, s.autoHeight), a.toggle(Wn.NORMAL, s.normal), a.toggle(Wn.PRINT, s.print), t.addOrRemoveCssClass(Wn.AUTO_HEIGHT, s.autoHeight), t.addOrRemoveCssClass(Wn.NORMAL, s.normal), t.addOrRemoveCssClass(Wn.PRINT, s.print);
        },
        setAlwaysVerticalScrollClass: function(o, s) {
          return t.eBodyViewport.classList.toggle(s4, s);
        },
        registerBodyViewportResizeListener: function(o) {
          var s = t.resizeObserverService.observeResize(t.eBodyViewport, o);
          t.addDestroyFunc(function() {
            return s();
          });
        },
        setPinnedTopBottomOverflowY: function(o) {
          return t.eTop.style.overflowY = t.eBottom.style.overflowY = o;
        },
        setCellSelectableCss: function(o, s) {
          [t.eTop, t.eBodyViewport, t.eBottom].forEach(function(a) {
            return a.classList.toggle(o4, s);
          });
        }
      };
      this.ctrl = this.createManagedBean(new l4()), this.ctrl.setComp(r, this.getGui(), this.eBodyViewport, this.eTop, this.eBottom), (this.rangeService || this.gridOptionsWrapper.isRowSelectionMulti()) && oH(this.getGui(), !0);
    }, e.prototype.setRowAnimationCssOnBodyViewport = function(t, i) {
      var r = this.eBodyViewport.classList;
      r.toggle(kd.ANIMATION_ON, i), r.toggle(kd.ANIMATION_OFF, !i);
    }, e.prototype.getFloatingTopBottom = function() {
      return [this.eTop, this.eBottom];
    }, Vh([
      T("resizeObserverService")
    ], e.prototype, "resizeObserverService", void 0), Vh([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), Vh([
      ve("eBodyViewport")
    ], e.prototype, "eBodyViewport", void 0), Vh([
      ve("eTop")
    ], e.prototype, "eTop", void 0), Vh([
      ve("eBottom")
    ], e.prototype, "eBottom", void 0), Vh([
      ve("gridHeader")
    ], e.prototype, "headerRootComp", void 0), Vh([
      Le
    ], e.prototype, "init", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var oZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), aF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, sZ = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, c4 = (
  /** @class */
  function(n) {
    oZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.expressionToFunctionCache = {}, t;
    }
    return e.prototype.setBeans = function(t) {
      this.logger = t.create("ExpressionService");
    }, e.prototype.evaluate = function(t, i) {
      if (typeof t == "function") {
        var r = t;
        return r(i);
      } else if (typeof t == "string") {
        var o = t;
        return this.evaluateExpression(o, i);
      } else
        console.error("AG Grid: value should be either a string or a function", t);
    }, e.prototype.evaluateExpression = function(t, i) {
      try {
        var r = this.createExpressionFunction(t), o = r(i.value, i.context, i.oldValue, i.newValue, i.value, i.node, i.data, i.colDef, i.rowIndex, i.api, i.columnApi, i.getValue, i.column, i.columnGroup);
        return o;
      } catch (s) {
        return console.log("Processing of the expression failed"), console.log("Expression = " + t), console.log("Params =", i), console.log("Exception = " + s), null;
      }
    }, e.prototype.createExpressionFunction = function(t) {
      if (this.expressionToFunctionCache[t])
        return this.expressionToFunctionCache[t];
      var i = this.createFunctionBody(t), r = new Function("x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, columnApi, getValue, column, columnGroup", i);
      return this.expressionToFunctionCache[t] = r, r;
    }, e.prototype.createFunctionBody = function(t) {
      return t.indexOf("return") >= 0 ? t : "return " + t + ";";
    }, aF([
      sZ(0, Eo("loggerFactory"))
    ], e.prototype, "setBeans", null), e = aF([
      qe("expressionService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var aZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), lF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, h4 = (
  /** @class */
  function(n) {
    aZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.templateCache = {}, t.waitingCallbacks = {}, t;
    }
    return e.prototype.getTemplate = function(t, i) {
      var r = this.templateCache[t];
      if (r)
        return r;
      var o = this.waitingCallbacks[t], s = this;
      if (!o) {
        o = [], this.waitingCallbacks[t] = o;
        var a = new XMLHttpRequest();
        a.onload = function() {
          s.handleHttpResult(this, t);
        }, a.open("GET", t), a.send();
      }
      return i && o.push(i), null;
    }, e.prototype.handleHttpResult = function(t, i) {
      if (t.status !== 200 || t.response === null) {
        console.warn("AG Grid: Unable to get template error " + t.status + " - " + i);
        return;
      }
      this.templateCache[i] = t.response || t.responseText;
      for (var r = this.waitingCallbacks[i], o = 0; o < r.length; o++) {
        var s = r[o];
        s();
      }
      if (this.$scope) {
        var a = this;
        window.setTimeout(function() {
          a.$scope.$apply();
        }, 0);
      }
    }, lF([
      T("$scope")
    ], e.prototype, "$scope", void 0), e = lF([
      qe("templateService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var lZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Qs = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, uZ = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, cZ = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(uZ(arguments[e]));
  return n;
}, Cp = (
  /** @class */
  function(n) {
    lZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    t = e, e.addKeyboardModeEvents = function(i, r) {
      var o = t.instancesMonitored.get(i);
      o && o.length > 0 ? o.indexOf(r) === -1 && o.push(r) : (t.instancesMonitored.set(i, [r]), i.addEventListener("keydown", t.toggleKeyboardMode), i.addEventListener("mousedown", t.toggleKeyboardMode));
    }, e.removeKeyboardModeEvents = function(i, r) {
      var o = t.instancesMonitored.get(i), s = [];
      o && o.length && (s = cZ(o).filter(function(a) {
        return a !== r;
      }), t.instancesMonitored.set(i, s)), s.length === 0 && (i.removeEventListener("keydown", t.toggleKeyboardMode), i.removeEventListener("mousedown", t.toggleKeyboardMode));
    }, e.toggleKeyboardMode = function(i) {
      var r = t.keyboardModeActive, o = i.type === "keydown";
      if (!(o && (i.ctrlKey || i.metaKey || i.altKey)) && !(r && o || !r && !o)) {
        t.keyboardModeActive = o;
        var s = i.target.ownerDocument;
        if (s) {
          var a = t.instancesMonitored.get(s);
          a && a.forEach(function(l) {
            l.dispatchEvent({ type: o ? F.EVENT_KEYBOARD_FOCUS : F.EVENT_MOUSE_FOCUS });
          });
        }
      }
    }, e.prototype.init = function() {
      var i = this, r = this.clearFocusedCell.bind(this);
      this.addManagedListener(this.eventService, F.EVENT_COLUMN_PIVOT_MODE_CHANGED, r), this.addManagedListener(this.eventService, F.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverythingChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_COLUMN_GROUP_OPENED, r), this.addManagedListener(this.eventService, F.EVENT_COLUMN_ROW_GROUP_CHANGED, r), this.ctrlsService.whenReady(function(o) {
        i.gridCtrl = o.gridCtrl;
        var s = i.gridOptionsWrapper.getDocument();
        t.addKeyboardModeEvents(s, i.gridCtrl), i.addDestroyFunc(function() {
          return i.unregisterGridCompController(i.gridCtrl);
        });
      });
    }, e.prototype.unregisterGridCompController = function(i) {
      var r = this.gridOptionsWrapper.getDocument();
      t.removeKeyboardModeEvents(r, i);
    }, e.prototype.onColumnEverythingChanged = function() {
      if (this.focusedCellPosition) {
        var i = this.focusedCellPosition.column, r = this.columnModel.getGridColumn(i.getId());
        i !== r && this.clearFocusedCell();
      }
    }, e.prototype.isKeyboardMode = function() {
      return t.keyboardModeActive;
    }, e.prototype.getFocusCellToUseAfterRefresh = function() {
      var i = this.gridOptionsWrapper.getDocument();
      return this.gridOptionsWrapper.isSuppressFocusAfterRefresh() || !this.focusedCellPosition || this.isDomDataMissingInHierarchy(i.activeElement, Qc.DOM_DATA_KEY_ROW_CTRL) ? null : this.focusedCellPosition;
    }, e.prototype.getFocusHeaderToUseAfterRefresh = function() {
      var i = this.gridOptionsWrapper.getDocument();
      return this.gridOptionsWrapper.isSuppressFocusAfterRefresh() || !this.focusedHeaderPosition || this.isDomDataMissingInHierarchy(i.activeElement, P_.DOM_DATA_KEY_HEADER_CTRL) ? null : this.focusedHeaderPosition;
    }, e.prototype.isDomDataMissingInHierarchy = function(i, r) {
      for (var o = i; o; ) {
        var s = this.gridOptionsWrapper.getDomData(o, r);
        if (s)
          return !1;
        o = o.parentNode;
      }
      return !0;
    }, e.prototype.clearFocusedCell = function() {
      this.focusedCellPosition = null, this.onCellFocused(!1);
    }, e.prototype.getFocusedCell = function() {
      return this.focusedCellPosition;
    }, e.prototype.setFocusedCell = function(i, r, o, s) {
      s === void 0 && (s = !1);
      var a = this.columnModel.getGridColumn(r);
      if (!a) {
        this.focusedCellPosition = null;
        return;
      }
      this.focusedCellPosition = a ? { rowIndex: i, rowPinned: vp(o), column: a } : null, this.onCellFocused(s);
    }, e.prototype.isCellFocused = function(i) {
      return this.focusedCellPosition == null ? !1 : this.focusedCellPosition.column === i.column && this.isRowFocused(i.rowIndex, i.rowPinned);
    }, e.prototype.isRowNodeFocused = function(i) {
      return this.isRowFocused(i.rowIndex, i.rowPinned);
    }, e.prototype.isHeaderWrapperFocused = function(i) {
      if (this.focusedHeaderPosition == null)
        return !1;
      var r = i.getColumnGroupChild(), o = i.getRowIndex(), s = i.getPinned(), a = this.focusedHeaderPosition, l = a.column, u = a.headerRowIndex;
      return r === l && o === u && s == l.getPinned();
    }, e.prototype.clearFocusedHeader = function() {
      this.focusedHeaderPosition = null;
    }, e.prototype.getFocusedHeader = function() {
      return this.focusedHeaderPosition;
    }, e.prototype.setFocusedHeader = function(i, r) {
      this.focusedHeaderPosition = { headerRowIndex: i, column: r };
    }, e.prototype.focusHeaderPosition = function(i) {
      var r = i.direction, o = i.fromTab, s = i.allowUserOverride, a = i.event, l = i.headerPosition;
      if (s) {
        var u = this.gridOptionsWrapper, c = this.getFocusedHeader(), h = this.headerNavigationService.getHeaderRowCount();
        if (o) {
          var d = u.getTabToNextHeaderFunc();
          if (d) {
            var f = {
              backwards: r === "Before",
              previousHeaderPosition: c,
              nextHeaderPosition: l,
              headerRowCount: h,
              api: u.getApi(),
              columnApi: u.getColumnApi()
            };
            l = d(f);
          }
        } else {
          var d = u.getNavigateToNextHeaderFunc();
          if (d && a) {
            var p = {
              key: a.key,
              previousHeaderPosition: c,
              nextHeaderPosition: l,
              headerRowCount: h,
              event: a,
              api: u.getApi(),
              columnApi: u.getColumnApi()
            };
            l = d(p);
          }
        }
      }
      if (!l)
        return !1;
      if (l.headerRowIndex === -1)
        return this.focusGridView(l.column);
      this.headerNavigationService.scrollToColumn(l.column, r);
      var g = this.ctrlsService.getHeaderRowContainerCtrl(l.column.getPinned()), _ = g.focusHeader(l.headerRowIndex, l.column, a);
      return _;
    }, e.prototype.focusFirstHeader = function() {
      var i = this.columnModel.getAllDisplayedColumns()[0];
      return i ? (i.getParent() && (i = this.columnModel.getColumnGroupAtLevel(i, 0)), this.focusHeaderPosition({
        headerPosition: { headerRowIndex: 0, column: i }
      })) : !1;
    }, e.prototype.focusLastHeader = function(i) {
      var r = this.headerNavigationService.getHeaderRowCount() - 1, o = Ti(this.columnModel.getAllDisplayedColumns());
      return this.focusHeaderPosition({
        headerPosition: { headerRowIndex: r, column: o },
        event: i
      });
    }, e.prototype.isAnyCellFocused = function() {
      return !!this.focusedCellPosition;
    }, e.prototype.isRowFocused = function(i, r) {
      return this.focusedCellPosition == null ? !1 : this.focusedCellPosition.rowIndex === i && this.focusedCellPosition.rowPinned === vp(r);
    }, e.prototype.findFocusableElements = function(i, r, o) {
      o === void 0 && (o = !1);
      var s = Z.FOCUSABLE_SELECTOR, a = Z.FOCUSABLE_EXCLUDE;
      r && (a += ", " + r), o && (a += ', [tabindex="-1"]');
      var l = Array.prototype.slice.apply(i.querySelectorAll(s)), u = Array.prototype.slice.apply(i.querySelectorAll(a));
      if (!u.length)
        return l;
      var c = function(h, d) {
        return h.filter(function(f) {
          return d.indexOf(f) === -1;
        });
      };
      return c(l, u);
    }, e.prototype.focusInto = function(i, r, o) {
      r === void 0 && (r = !1), o === void 0 && (o = !1);
      var s = this.findFocusableElements(i, null, o), a = r ? Ti(s) : s[0];
      return a ? (a.focus(), !0) : !1;
    }, e.prototype.findNextFocusableElement = function(i, r, o) {
      i === void 0 && (i = this.eGridDiv);
      var s = this.findFocusableElements(i, r ? ':not([tabindex="-1"])' : null), a = this.gridOptionsWrapper.getDocument(), l = a.activeElement, u;
      r ? u = s.findIndex(function(h) {
        return h.contains(l);
      }) : u = s.indexOf(l);
      var c = u + (o ? -1 : 1);
      return c < 0 || c >= s.length ? null : s[c];
    }, e.prototype.isFocusUnderManagedComponent = function(i) {
      var r = this.gridOptionsWrapper.getDocument(), o = i.querySelectorAll("." + nc.FOCUS_MANAGED_CLASS);
      if (!o.length)
        return !1;
      for (var s = 0; s < o.length; s++)
        if (o[s].contains(r.activeElement))
          return !0;
      return !1;
    }, e.prototype.findTabbableParent = function(i, r) {
      r === void 0 && (r = 5);
      for (var o = 0; i && Hw(i) === null && ++o <= r; )
        i = i.parentElement;
      return Hw(i) === null ? null : i;
    }, e.prototype.onCellFocused = function(i) {
      var r = {
        type: F.EVENT_CELL_FOCUSED,
        forceBrowserFocus: i,
        rowIndex: null,
        column: null,
        floating: null,
        api: this.gridApi,
        columnApi: this.columnApi,
        rowPinned: null,
        isFullWidthCell: !1
      };
      if (this.focusedCellPosition) {
        var o = r.rowIndex = this.focusedCellPosition.rowIndex, s = r.rowPinned = this.focusedCellPosition.rowPinned;
        r.column = this.focusedCellPosition.column;
        var a = this.rowRenderer.getRowByPosition({ rowIndex: o, rowPinned: s });
        a && (r.isFullWidthCell = a.isFullWidth());
      }
      this.eventService.dispatchEvent(r);
    }, e.prototype.focusGridView = function(i, r) {
      if (this.gridOptionsWrapper.isSuppressCellFocus())
        return r ? this.focusLastHeader() : this.focusNextGridCoreContainer(!1);
      var o = r ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
      if (!o)
        return !1;
      var s = o.rowIndex, a = o.rowPinned, l = this.getFocusedHeader();
      if (!i && l && (i = l.column), s == null || !i)
        return !1;
      if (this.navigationService.ensureCellVisible({ rowIndex: s, column: i, rowPinned: a }), this.setFocusedCell(s, i, vp(a), !0), this.rangeService) {
        var u = { rowIndex: s, rowPinned: a, column: i };
        this.rangeService.setRangeToCell(u);
      }
      return !0;
    }, e.prototype.focusNextGridCoreContainer = function(i) {
      return this.gridCtrl.focusNextInnerContainer(i) ? !0 : (i || this.gridCtrl.forceFocusOutOfContainer(), !1);
    };
    var t;
    return e.AG_KEYBOARD_FOCUS = "ag-keyboard-focus", e.keyboardModeActive = !1, e.instancesMonitored = /* @__PURE__ */ new Map(), Qs([
      T("eGridDiv")
    ], e.prototype, "eGridDiv", void 0), Qs([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), Qs([
      T("headerNavigationService")
    ], e.prototype, "headerNavigationService", void 0), Qs([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), Qs([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Qs([
      T("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), Qs([
      T("rowPositionUtils")
    ], e.prototype, "rowPositionUtils", void 0), Qs([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), Qs([
      T("navigationService")
    ], e.prototype, "navigationService", void 0), Qs([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Qs([
      Le
    ], e.prototype, "init", null), e = t = Qs([
      qe("focusService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var hZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Cm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Fc;
(function(n) {
  n[n.vertical = 0] = "vertical", n[n.horizontal = 1] = "horizontal";
})(Fc || (Fc = {}));
var dZ = 0, d4 = (
  /** @class */
  function(n) {
    hZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.popupList = [], t;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        t.gridCtrl = i.gridCtrl, t.addManagedListener(t.gridCtrl, F.EVENT_KEYBOARD_FOCUS, function() {
          t.popupList.forEach(function(r) {
            return r.element.classList.add(Cp.AG_KEYBOARD_FOCUS);
          });
        }), t.addManagedListener(t.gridCtrl, F.EVENT_MOUSE_FOCUS, function() {
          t.popupList.forEach(function(r) {
            return r.element.classList.remove(Cp.AG_KEYBOARD_FOCUS);
          });
        });
      });
    }, e.prototype.getPopupParent = function() {
      var t = this.gridOptionsWrapper.getPopupParent();
      return t || this.gridCtrl.getGui();
    }, e.prototype.positionPopupForMenu = function(t) {
      var i = t.eventSource.getBoundingClientRect(), r = this.getParentRect(), o = this.keepXYWithinBounds(t.ePopup, i.top - r.top, Fc.vertical), s = t.ePopup.clientWidth > 0 ? t.ePopup.clientWidth : 200;
      t.ePopup.style.minWidth = s + "px";
      var a = r.right - r.left, l = a - s, u;
      this.gridOptionsWrapper.isEnableRtl() ? (u = h(), u < 0 && (u = c()), u > l && (u = 0)) : (u = c(), u > l && (u = h()), u < 0 && (u = 0)), t.ePopup.style.left = u + "px", t.ePopup.style.top = o + "px";
      function c() {
        return i.right - r.left - 2;
      }
      function h() {
        return i.left - r.left - s;
      }
    }, e.prototype.positionPopupUnderMouseEvent = function(t) {
      var i = t.ePopup, r = t.nudgeX, o = t.nudgeY, s = this.calculatePointerAlign(t.mouseEvent), a = s.x, l = s.y;
      this.positionPopup({
        ePopup: i,
        x: a,
        y: l,
        nudgeX: r,
        nudgeY: o,
        keepWithinBounds: !0
      }), this.callPostProcessPopup(t.type, t.ePopup, null, t.mouseEvent, t.column, t.rowNode);
    }, e.prototype.calculatePointerAlign = function(t) {
      var i = this.getParentRect();
      return {
        x: t.clientX - i.left,
        y: t.clientY - i.top
      };
    }, e.prototype.positionPopupUnderComponent = function(t) {
      var i = t.eventSource.getBoundingClientRect(), r = t.alignSide || "left", o = this.getParentRect(), s = i.left - o.left;
      r === "right" && (s -= t.ePopup.offsetWidth - i.width), this.positionPopup({
        ePopup: t.ePopup,
        nudgeX: t.nudgeX,
        nudgeY: t.nudgeY,
        x: s,
        y: i.top - o.top + i.height,
        keepWithinBounds: t.keepWithinBounds
      }), this.callPostProcessPopup(t.type, t.ePopup, t.eventSource, null, t.column, t.rowNode);
    }, e.prototype.positionPopupOverComponent = function(t) {
      var i = t.eventSource.getBoundingClientRect(), r = this.getParentRect();
      this.positionPopup({
        ePopup: t.ePopup,
        nudgeX: t.nudgeX,
        nudgeY: t.nudgeY,
        x: i.left - r.left,
        y: i.top - r.top,
        keepWithinBounds: t.keepWithinBounds
      }), this.callPostProcessPopup(t.type, t.ePopup, t.eventSource, null, t.column, t.rowNode);
    }, e.prototype.callPostProcessPopup = function(t, i, r, o, s, a) {
      var l = this.gridOptionsWrapper.getPostProcessPopupFunc();
      if (l) {
        var u = {
          column: s,
          rowNode: a,
          ePopup: i,
          type: t,
          eventSource: r,
          mouseEvent: o
        };
        l(u);
      }
    }, e.prototype.positionPopup = function(t) {
      var i = t.ePopup, r = t.keepWithinBounds, o = t.nudgeX, s = t.nudgeY, a = t.x, l = t.y;
      o && (a += o), s && (l += s), r && (a = this.keepXYWithinBounds(i, a, Fc.horizontal), l = this.keepXYWithinBounds(i, l, Fc.vertical)), i.style.left = a + "px", i.style.top = l + "px";
    }, e.prototype.getActivePopups = function() {
      return this.popupList.map(function(t) {
        return t.element;
      });
    }, e.prototype.getPopupList = function() {
      return this.popupList;
    }, e.prototype.getParentRect = function() {
      var t = this.gridOptionsWrapper.getDocument(), i = this.getPopupParent();
      i === t.body && (i = t.documentElement);
      var r = getComputedStyle(i), o = i.getBoundingClientRect();
      return {
        top: o.top + parseFloat(r.borderTopWidth) || 0,
        left: o.left + parseFloat(r.borderLeftWidth) || 0,
        right: o.right + parseFloat(r.borderRightWidth) || 0,
        bottom: o.bottom + parseFloat(r.borderBottomWidth) || 0
      };
    }, e.prototype.keepXYWithinBounds = function(t, i, r) {
      var o = r === Fc.vertical, s = o ? "clientHeight" : "clientWidth", a = o ? "top" : "left", l = o ? "offsetHeight" : "offsetWidth", u = o ? "scrollTop" : "scrollLeft", c = this.gridOptionsWrapper.getDocument(), h = c.documentElement, d = this.getPopupParent(), f = d.getBoundingClientRect(), p = c.documentElement.getBoundingClientRect(), g = d === c.body, _ = t[l], m = o ? yx : NS, v = g ? m(h) + h[u] : d[s];
      g && (v -= Math.abs(p[a] - f[a]));
      var C = v - _;
      return Math.min(Math.max(i, 0), Math.abs(C));
    }, e.prototype.keepPopupPositionedRelativeTo = function(t) {
      var i = this, r = this.getPopupParent(), o = r.getBoundingClientRect(), s = t.element.getBoundingClientRect(), a = o.top - s.top, l = o.left - s.left, u = a, c = l, h = t.ePopup.style.top, d = parseInt(h.substring(0, h.length - 1), 10), f = t.ePopup.style.left, p = parseInt(f.substring(0, f.length - 1), 10);
      return new Bo(function(g) {
        i.getFrameworkOverrides().setInterval(function() {
          var _ = r.getBoundingClientRect(), m = t.element.getBoundingClientRect(), v = m.top == 0 && m.left == 0 && m.height == 0 && m.width == 0;
          if (v) {
            t.hidePopup();
            return;
          }
          var C = _.top - m.top;
          if (C != u) {
            var y = i.keepXYWithinBounds(t.ePopup, d + a - C, Fc.vertical);
            t.ePopup.style.top = y + "px";
          }
          u = C;
          var w = _.left - m.left;
          if (w != c) {
            var L = i.keepXYWithinBounds(t.ePopup, p + l - w, Fc.horizontal);
            t.ePopup.style.left = L + "px";
          }
          c = w;
        }, 200).then(function(_) {
          var m = function() {
            _ != null && window.clearInterval(_);
          };
          g(m);
        });
      });
    }, e.prototype.addPopup = function(t) {
      var i = this, r = t.modal, o = t.eChild, s = t.closeOnEsc, a = t.closedCallback, l = t.click, u = t.alwaysOnTop, c = t.afterGuiAttached, h = t.positionCallback, d = t.anchorToElement, f = t.ariaLabel, p = this.gridOptionsWrapper.getDocument(), g = new Bo(function(x) {
        return x(function() {
        });
      });
      if (!p)
        return console.warn("ag-grid: could not find the document, document is empty"), { hideFunc: function() {
        }, stopAnchoringPromise: g };
      var _ = this.popupList.findIndex(function(x) {
        return x.element === o;
      });
      if (_ !== -1) {
        var m = this.popupList[_];
        return { hideFunc: m.hideFunc, stopAnchoringPromise: m.stopAnchoringPromise };
      }
      var v = this.getPopupParent();
      o.style.top == null && (o.style.top = "0px"), o.style.left == null && (o.style.left = "0px");
      var C = document.createElement("div"), y = this.environment.getTheme().theme;
      y && C.classList.add(y), C.classList.add("ag-popup"), o.classList.add(this.gridOptionsWrapper.isEnableRtl() ? "ag-rtl" : "ag-ltr", "ag-popup-child"), o.hasAttribute("role") || Do(o, "dialog"), tf(o, f), this.focusService.isKeyboardMode() && o.classList.add(Cp.AG_KEYBOARD_FOCUS), C.appendChild(o), v.appendChild(C), u ? this.setAlwaysOnTop(C, !0) : this.bringPopupToFront(C);
      var w = !1, L = function(x) {
        if (C.contains(p.activeElement)) {
          var R = x.key;
          R === _e.ESCAPE && D({ keyboardEvent: x });
        }
      }, S = function(x) {
        return D({ mouseEvent: x });
      }, E = function(x) {
        return D({ touchEvent: x });
      }, D = function(x) {
        x === void 0 && (x = {});
        var R = x.mouseEvent, A = x.touchEvent, M = x.keyboardEvent;
        // we don't hide popup if the event was on the child, or any
        // children of this child
        i.isEventFromCurrentPopup({ mouseEvent: R, touchEvent: A }, o) || // if the event to close is actually the open event, then ignore it
        i.isEventSameChainAsOriginalEvent({ originalMouseEvent: l, mouseEvent: R, touchEvent: A }) || // this method should only be called once. the client can have different
        // paths, each one wanting to close, so this method may be called multiple times.
        w || (w = !0, v.removeChild(C), p.removeEventListener("keydown", L), p.removeEventListener("mousedown", S), p.removeEventListener("touchstart", E), p.removeEventListener("contextmenu", S), i.eventService.removeEventListener(F.EVENT_DRAG_STARTED, S), a && a(R || A || M), i.popupList = i.popupList.filter(function(z) {
          return z.element !== o;
        }), g && g.then(function(z) {
          return z && z();
        }));
      };
      return c && c({ hidePopup: D }), window.setTimeout(function() {
        s && p.addEventListener("keydown", L), r && (p.addEventListener("mousedown", S), i.eventService.addEventListener(F.EVENT_DRAG_STARTED, S), p.addEventListener("touchstart", E), p.addEventListener("contextmenu", S));
      }, 0), h && h(), d && (g = this.keepPopupPositionedRelativeTo({
        element: d,
        ePopup: o,
        hidePopup: D
      })), this.popupList.push({
        element: o,
        wrapper: C,
        hideFunc: D,
        stopAnchoringPromise: g,
        instanceId: dZ++,
        isAnchored: !!d
      }), {
        hideFunc: D,
        stopAnchoringPromise: g
      };
    }, e.prototype.hasAnchoredPopup = function() {
      return this.popupList.some(function(t) {
        return t.isAnchored;
      });
    }, e.prototype.isEventFromCurrentPopup = function(t, i) {
      var r = t.mouseEvent, o = t.touchEvent, s = r || o;
      if (!s)
        return !1;
      var a = this.popupList.findIndex(function(c) {
        return c.element === i;
      });
      if (a === -1)
        return !1;
      for (var l = a; l < this.popupList.length; l++) {
        var u = this.popupList[l];
        if (Bw(u.element, s))
          return !0;
      }
      return this.isElementWithinCustomPopup(s.target);
    }, e.prototype.isElementWithinCustomPopup = function(t) {
      for (var i = this.gridOptionsWrapper.getDocument(); t && t !== i.body; ) {
        if (t.classList.contains("ag-custom-component-popup") || t.parentElement === null)
          return !0;
        t = t.parentElement;
      }
      return !1;
    }, e.prototype.isEventSameChainAsOriginalEvent = function(t) {
      var i = t.originalMouseEvent, r = t.mouseEvent, o = t.touchEvent, s = null;
      if (r ? s = r : o && (s = o.touches[0]), s && i) {
        var a = r ? r.screenX : 0, l = r ? r.screenY : 0, u = Math.abs(i.screenX - a) < 5, c = Math.abs(i.screenY - l) < 5;
        if (u && c)
          return !0;
      }
      return !1;
    }, e.prototype.getWrapper = function(t) {
      for (; !t.classList.contains("ag-popup") && t.parentElement; )
        t = t.parentElement;
      return t.classList.contains("ag-popup") ? t : null;
    }, e.prototype.setAlwaysOnTop = function(t, i) {
      var r = this.getWrapper(t);
      r && (r.classList.toggle("ag-always-on-top", !!i), i && this.bringPopupToFront(r));
    }, e.prototype.bringPopupToFront = function(t) {
      var i = this.getPopupParent(), r = Array.prototype.slice.call(i.querySelectorAll(".ag-popup")), o = r.length, s = Array.prototype.slice.call(i.querySelectorAll(".ag-popup.ag-always-on-top")), a = s.length, l = this.getWrapper(t);
      if (!(!l || o <= 1 || !i.contains(t))) {
        var u = r.indexOf(l), c = l.querySelectorAll("div"), h = [];
        if (c.forEach(function(g) {
          g.scrollTop !== 0 && h.push([g, g.scrollTop]);
        }), a) {
          var d = l.classList.contains("ag-always-on-top");
          d ? u !== o - 1 && Ti(s).insertAdjacentElement("afterend", l) : u !== o - a - 1 && s[0].insertAdjacentElement("beforebegin", l);
        } else
          u !== o - 1 && Ti(r).insertAdjacentElement("afterend", l);
        for (; h.length; ) {
          var f = h.pop();
          f[0].scrollTop = f[1];
        }
        var p = {
          type: "popupToFront",
          api: this.gridOptionsWrapper.getApi(),
          columnApi: this.gridOptionsWrapper.getColumnApi(),
          eWrapper: l
        };
        this.eventService.dispatchEvent(p);
      }
    }, Cm([
      T("environment")
    ], e.prototype, "environment", void 0), Cm([
      T("focusService")
    ], e.prototype, "focusService", void 0), Cm([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Cm([
      Le
    ], e.prototype, "postConstruct", null), e = Cm([
      qe("popupService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var fZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), uF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, pZ = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, f4 = (
  /** @class */
  function(n) {
    fZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setBeans = function(t) {
      this.logging = t.isDebug();
    }, e.prototype.create = function(t) {
      return new Qw(t, this.isLogging.bind(this));
    }, e.prototype.isLogging = function() {
      return this.logging;
    }, uF([
      pZ(0, Eo("gridOptionsWrapper"))
    ], e.prototype, "setBeans", null), e = uF([
      qe("loggerFactory")
    ], e), e;
  }(Se)
), Qw = (
  /** @class */
  function() {
    function n(e, t) {
      this.name = e, this.isLoggingFunc = t;
    }
    return n.prototype.isLogging = function() {
      return this.isLoggingFunc();
    }, n.prototype.log = function(e) {
      this.isLoggingFunc() && console.log("AG Grid." + this.name + ": " + e);
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ym = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, p4 = (
  /** @class */
  function(n) {
    gZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        t.centerRowContainerCon = i.centerRowContainerCtrl;
      });
    }, e.prototype.getPreferredWidthForColumn = function(t, i) {
      var r = this.getHeaderCellForColumn(t);
      if (!r)
        return -1;
      var o = this.rowRenderer.getAllCellsForColumn(t);
      return i || o.push(r), this.addElementsToContainerAndGetWidth(o);
    }, e.prototype.getPreferredWidthForColumnGroup = function(t) {
      var i = this.getHeaderCellForColumn(t);
      return i ? this.addElementsToContainerAndGetWidth([i]) : -1;
    }, e.prototype.addElementsToContainerAndGetWidth = function(t) {
      var i = this, r = document.createElement("span");
      r.style.position = "fixed";
      var o = this.centerRowContainerCon.getContainerElement();
      o.appendChild(r), t.forEach(function(l) {
        return i.cloneItemIntoDummy(l, r);
      });
      var s = r.offsetWidth;
      o.removeChild(r);
      var a = this.gridOptionsWrapper.getAutoSizePadding();
      return s + a;
    }, e.prototype.getHeaderCellForColumn = function(t) {
      var i = null;
      return this.ctrlsService.getHeaderRowContainerCtrls().forEach(function(r) {
        var o = r.getHtmlElementForColumnHeader(t);
        o != null && (i = o);
      }), i;
    }, e.prototype.cloneItemIntoDummy = function(t, i) {
      var r = t.cloneNode(!0);
      r.style.width = "", r.style.position = "static", r.style.left = "";
      var o = document.createElement("div"), s = o.classList, a = ["ag-header-cell", "ag-header-group-cell"].some(function(d) {
        return r.classList.contains(d);
      });
      a ? (s.add("ag-header", "ag-header-row"), o.style.position = "static") : s.add("ag-row");
      for (var l = t.parentElement; l; ) {
        var u = ["ag-header-row", "ag-row"].some(function(d) {
          return l.classList.contains(d);
        });
        if (u) {
          for (var c = 0; c < l.classList.length; c++) {
            var h = l.classList[c];
            h != "ag-row-position-absolute" && s.add(h);
          }
          break;
        }
        l = l.parentElement;
      }
      o.appendChild(r), i.appendChild(o);
    }, ym([
      T("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), ym([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), ym([
      T("rowCssClassCalculator")
    ], e.prototype, "rowCssClassCalculator", void 0), ym([
      Le
    ], e.prototype, "postConstruct", null), e = ym([
      qe("autoWidthCalculator")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var mZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), IL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, g4 = (
  /** @class */
  function(n) {
    mZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.addResizeBar = function(t) {
      var i = this, r = {
        dragStartPixels: t.dragStartPixels || 0,
        eElement: t.eResizeBar,
        onDragStart: this.onDragStart.bind(this, t),
        onDragStop: this.onDragStop.bind(this, t),
        onDragging: this.onDragging.bind(this, t)
      };
      this.dragService.addDragSource(r, !0);
      var o = function() {
        return i.dragService.removeDragSource(r);
      };
      return o;
    }, e.prototype.onDragStart = function(t, i) {
      this.dragStartX = i.clientX, this.setResizeIcons();
      var r = i instanceof MouseEvent && i.shiftKey === !0;
      t.onResizeStart(r);
    }, e.prototype.setResizeIcons = function() {
      var t = this.ctrlsService.getGridCtrl();
      t.setResizeCursor(!0), t.disableUserSelect(!0);
    }, e.prototype.onDragStop = function(t, i) {
      t.onResizeEnd(this.resizeAmount), this.resetIcons();
    }, e.prototype.resetIcons = function() {
      var t = this.ctrlsService.getGridCtrl();
      t.setResizeCursor(!1), t.disableUserSelect(!1);
    }, e.prototype.onDragging = function(t, i) {
      this.resizeAmount = i.clientX - this.dragStartX, t.onResizing(this.resizeAmount);
    }, IL([
      T("dragService")
    ], e.prototype, "dragService", void 0), IL([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), e = IL([
      qe("horizontalResizeService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var vZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), bc = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, m4 = (
  /** @class */
  function(n) {
    vZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      this.ctrlsService.registerGridCtrl(this);
    }, e.prototype.setComp = function(t, i, r) {
      var o = this;
      this.view = t, this.eGridHostDiv = i, this.eGui = r, this.mouseEventService.stampTopLevelGridCompWithGridInstance(i), this.createManagedBean(new Kx(this.view)), this.addRtlSupport(), this.addManagedListener(this, F.EVENT_KEYBOARD_FOCUS, function() {
        o.view.addOrRemoveKeyboardFocusClass(!0);
      }), this.addManagedListener(this, F.EVENT_MOUSE_FOCUS, function() {
        o.view.addOrRemoveKeyboardFocusClass(!1);
      });
      var s = this.resizeObserverService.observeResize(this.eGridHostDiv, this.onGridSizeChanged.bind(this));
      this.addDestroyFunc(function() {
        return s();
      });
    }, e.prototype.showDropZones = function() {
      return gt.isRegistered(ht.RowGroupingModule);
    }, e.prototype.showSideBar = function() {
      return gt.isRegistered(ht.SideBarModule);
    }, e.prototype.showStatusBar = function() {
      return gt.isRegistered(ht.StatusBarModule);
    }, e.prototype.showWatermark = function() {
      return gt.isRegistered(ht.EnterpriseCoreModule);
    }, e.prototype.onGridSizeChanged = function() {
      var t = {
        type: F.EVENT_GRID_SIZE_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi,
        clientWidth: this.eGridHostDiv.clientWidth,
        clientHeight: this.eGridHostDiv.clientHeight
      };
      this.eventService.dispatchEvent(t);
    }, e.prototype.addRtlSupport = function() {
      var t = this.gridOptionsWrapper.isEnableRtl() ? "ag-rtl" : "ag-ltr";
      this.view.setRtlClass(t);
    }, e.prototype.destroyGridUi = function() {
      this.view.destroyGridUi();
    }, e.prototype.getGui = function() {
      return this.eGui;
    }, e.prototype.setResizeCursor = function(t) {
      this.view.setCursor(t ? "ew-resize" : null);
    }, e.prototype.disableUserSelect = function(t) {
      this.view.setUserSelect(t ? "none" : null);
    }, e.prototype.focusNextInnerContainer = function(t) {
      var i = this.gridOptionsWrapper.getDocument(), r = this.view.getFocusableContainers(), o = r.findIndex(function(a) {
        return a.contains(i.activeElement);
      }), s = o + (t ? -1 : 1);
      return s <= 0 || s >= r.length ? !1 : this.focusService.focusInto(r[s]);
    }, e.prototype.focusInnerElement = function(t) {
      var i = this.view.getFocusableContainers();
      if (t) {
        if (i.length > 1)
          return this.focusService.focusInto(Ti(i), !0);
        var r = Ti(this.columnModel.getAllDisplayedColumns());
        if (this.focusService.focusGridView(r, !0))
          return !0;
      }
      return this.focusService.focusFirstHeader();
    }, e.prototype.forceFocusOutOfContainer = function(t) {
      t === void 0 && (t = !1), this.view.forceFocusOutOfContainer(t);
    }, bc([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), bc([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), bc([
      T("focusService")
    ], e.prototype, "focusService", void 0), bc([
      T("resizeObserverService")
    ], e.prototype, "resizeObserverService", void 0), bc([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), bc([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), bc([
      T("mouseEventService")
    ], e.prototype, "mouseEventService", void 0), bc([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var _Z = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), cF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, v4 = (
  /** @class */
  function(n) {
    _Z(e, n);
    function e(t) {
      var i = n.call(this) || this;
      i.skipTabGuardFocus = !1;
      var r = t.comp, o = t.eTopGuard, s = t.eBottomGuard, a = t.focusInnerElement, l = t.onFocusIn, u = t.onFocusOut, c = t.shouldStopEventPropagation, h = t.onTabKeyDown, d = t.handleKeyDown, f = t.eFocusableElement;
      return i.comp = r, i.eTopGuard = o, i.eBottomGuard = s, i.providedFocusInnerElement = a, i.eFocusableElement = f, i.providedFocusIn = l, i.providedFocusOut = u, i.providedShouldStopEventPropagation = c, i.providedOnTabKeyDown = h, i.providedHandleKeyDown = d, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.createManagedBean(new nc(this.eFocusableElement, {
        shouldStopEventPropagation: function() {
          return t.shouldStopEventPropagation();
        },
        onTabKeyDown: function(i) {
          return t.onTabKeyDown(i);
        },
        handleKeyDown: function(i) {
          return t.handleKeyDown(i);
        },
        onFocusIn: function(i) {
          return t.onFocusIn(i);
        },
        onFocusOut: function(i) {
          return t.onFocusOut(i);
        }
      })), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach(function(i) {
        return t.addManagedListener(i, "focus", t.onFocus.bind(t));
      });
    }, e.prototype.handleKeyDown = function(t) {
      this.providedHandleKeyDown && this.providedHandleKeyDown(t);
    }, e.prototype.tabGuardsAreActive = function() {
      return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
    }, e.prototype.shouldStopEventPropagation = function() {
      return this.providedShouldStopEventPropagation ? this.providedShouldStopEventPropagation() : !1;
    }, e.prototype.activateTabGuards = function() {
      this.comp.setTabIndex(this.getGridTabIndex());
    }, e.prototype.deactivateTabGuards = function() {
      this.comp.setTabIndex();
    }, e.prototype.onFocus = function(t) {
      if (this.skipTabGuardFocus) {
        this.skipTabGuardFocus = !1;
        return;
      }
      var i = t.target === this.eBottomGuard;
      this.providedFocusInnerElement ? this.providedFocusInnerElement(i) : this.focusInnerElement(i);
    }, e.prototype.onFocusIn = function(t) {
      this.providedFocusIn && this.providedFocusIn(t) || this.deactivateTabGuards();
    }, e.prototype.onFocusOut = function(t) {
      this.providedFocusOut && this.providedFocusOut(t) || this.eFocusableElement.contains(t.relatedTarget) || this.activateTabGuards();
    }, e.prototype.onTabKeyDown = function(t) {
      var i = this;
      if (this.providedOnTabKeyDown) {
        this.providedOnTabKeyDown(t);
        return;
      }
      if (!t.defaultPrevented) {
        var r = this.tabGuardsAreActive();
        r && this.deactivateTabGuards();
        var o = this.getNextFocusableElement(t.shiftKey);
        r && setTimeout(function() {
          return i.activateTabGuards();
        }, 0), o && (o.focus(), t.preventDefault());
      }
    }, e.prototype.getGridTabIndex = function() {
      return this.gridOptionsWrapper.getGridTabIndex();
    }, e.prototype.focusInnerElement = function(t) {
      t === void 0 && (t = !1);
      var i = this.focusService.findFocusableElements(this.eFocusableElement);
      this.tabGuardsAreActive() && (i.splice(0, 1), i.splice(i.length - 1, 1)), i.length && i[t ? i.length - 1 : 0].focus();
    }, e.prototype.getNextFocusableElement = function(t) {
      return this.focusService.findNextFocusableElement(this.eFocusableElement, !1, t);
    }, e.prototype.forceFocusOutOfContainer = function(t) {
      t === void 0 && (t = !1);
      var i = t ? this.eTopGuard : this.eBottomGuard;
      this.activateTabGuards(), this.skipTabGuardFocus = !0, i.focus();
    }, cF([
      T("focusService")
    ], e.prototype, "focusService", void 0), cF([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var CZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), yZ = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, wZ = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(yZ(arguments[e]));
  return n;
}, A_ = (
  /** @class */
  function(n) {
    CZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.initialiseTabGuard = function(t) {
      this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.getFocusableElement();
      var i = [this.eTopGuard, this.eBottomGuard], r = {
        setTabIndex: function(o) {
          i.forEach(function(s) {
            return o != null ? s.setAttribute("tabIndex", o) : s.removeAttribute("tabIndex");
          });
        }
      };
      this.addTabGuards(this.eTopGuard, this.eBottomGuard), this.tabGuardCtrl = this.createManagedBean(new v4({
        comp: r,
        eTopGuard: this.eTopGuard,
        eBottomGuard: this.eBottomGuard,
        eFocusableElement: this.eFocusableElement,
        onFocusIn: t.onFocusIn,
        onFocusOut: t.onFocusOut,
        focusInnerElement: t.focusInnerElement,
        handleKeyDown: t.handleKeyDown,
        onTabKeyDown: t.onTabKeyDown,
        shouldStopEventPropagation: t.shouldStopEventPropagation
      }));
    }, e.prototype.createTabGuard = function(t) {
      var i = document.createElement("div");
      return i.classList.add("ag-tab-guard", "ag-tab-guard-" + t), Do(i, "presentation"), i;
    }, e.prototype.addTabGuards = function(t, i) {
      this.eFocusableElement.insertAdjacentElement("afterbegin", t), this.eFocusableElement.insertAdjacentElement("beforeend", i);
    }, e.prototype.removeAllChildrenExceptTabGuards = function() {
      var t = [this.eTopGuard, this.eBottomGuard];
      Ls(this.getFocusableElement()), this.addTabGuards.apply(this, wZ(t));
    }, e.prototype.forceFocusOutOfContainer = function(t) {
      t === void 0 && (t = !1), this.tabGuardCtrl.forceFocusOutOfContainer(t);
    }, e.prototype.appendChild = function(t, i) {
      I_(t) || (t = t.getGui());
      var r = this.eBottomGuard;
      r ? r.insertAdjacentElement("beforebegin", t) : n.prototype.appendChild.call(this, t, i);
    }, e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var bZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, _4 = (
  /** @class */
  function(n) {
    bZ(e, n);
    function e(t) {
      var i = n.call(this, void 0) || this;
      return i.eGridDiv = t, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.logger = this.loggerFactory.create("GridComp");
      var i = {
        destroyGridUi: function() {
          return t.destroyBean(t);
        },
        setRtlClass: function(o) {
          return t.addCssClass(o);
        },
        addOrRemoveKeyboardFocusClass: function(o) {
          return t.addOrRemoveCssClass(Cp.AG_KEYBOARD_FOCUS, o);
        },
        forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
        updateLayoutClasses: this.updateLayoutClasses.bind(this),
        getFocusableContainers: this.getFocusableContainers.bind(this),
        setUserSelect: function(o) {
          t.getGui().style.userSelect = o ?? "", t.getGui().style.webkitUserSelect = o ?? "";
        },
        setCursor: function(o) {
          t.getGui().style.cursor = o ?? "";
        }
      };
      this.ctrl = this.createManagedBean(new m4());
      var r = this.createTemplate();
      this.setTemplate(r), this.ctrl.setComp(i, this.eGridDiv, this.getGui()), this.insertGridIntoDom(), this.initialiseTabGuard({
        // we want to override the default behaviour to do nothing for onTabKeyDown
        onTabKeyDown: function() {
        },
        focusInnerElement: function(o) {
          return t.ctrl.focusInnerElement(o);
        }
      });
    }, e.prototype.insertGridIntoDom = function() {
      var t = this, i = this.getGui();
      this.eGridDiv.appendChild(i), this.addDestroyFunc(function() {
        t.eGridDiv.removeChild(i), t.logger.log("Grid removed from DOM");
      });
    }, e.prototype.updateLayoutClasses = function(t, i) {
      var r = this.eRootWrapperBody.classList;
      r.toggle(Wn.AUTO_HEIGHT, i.autoHeight), r.toggle(Wn.NORMAL, i.normal), r.toggle(Wn.PRINT, i.print), this.addOrRemoveCssClass(Wn.AUTO_HEIGHT, i.autoHeight), this.addOrRemoveCssClass(Wn.NORMAL, i.normal), this.addOrRemoveCssClass(Wn.PRINT, i.print);
    }, e.prototype.createTemplate = function() {
      var t = this.ctrl.showDropZones() ? "<ag-grid-header-drop-zones></ag-grid-header-drop-zones>" : "", i = this.ctrl.showSideBar() ? '<ag-side-bar ref="sideBar"></ag-side-bar>' : "", r = this.ctrl.showStatusBar() ? '<ag-status-bar ref="statusBar"></ag-status-bar>' : "", o = this.ctrl.showWatermark() ? "<ag-watermark></ag-watermark>" : "", s = (
        /* html */
        `<div class="ag-root-wrapper">
                ` + t + `
                <div class="ag-root-wrapper-body" ref="rootWrapperBody">
                    <ag-grid-body ref="gridBody"></ag-grid-body>
                    ` + i + `
                </div>
                ` + r + `
                <ag-pagination></ag-pagination>
                ` + o + `
            </div>`
      );
      return s;
    }, e.prototype.getFocusableElement = function() {
      return this.eRootWrapperBody;
    }, e.prototype.getFocusableContainers = function() {
      var t = [
        this.gridBodyComp.getGui()
      ];
      return this.sideBarComp && t.push(this.sideBarComp.getGui()), t.filter(function(i) {
        return wg(i);
      });
    }, wm([
      T("loggerFactory")
    ], e.prototype, "loggerFactory", void 0), wm([
      ve("gridBody")
    ], e.prototype, "gridBodyComp", void 0), wm([
      ve("sideBar")
    ], e.prototype, "sideBarComp", void 0), wm([
      ve("rootWrapperBody")
    ], e.prototype, "eRootWrapperBody", void 0), wm([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(A_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var SZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Of = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, C4 = (
  /** @class */
  function(n) {
    SZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.dragEndFunctions = [], t.dragSources = [], t;
    }
    return e.prototype.init = function() {
      this.logger = this.loggerFactory.create("DragService");
    }, e.prototype.removeAllListeners = function() {
      this.dragSources.forEach(this.removeListener.bind(this)), this.dragSources.length = 0;
    }, e.prototype.removeListener = function(t) {
      var i = t.dragSource.eElement, r = t.mouseDownListener;
      if (i.removeEventListener("mousedown", r), t.touchEnabled) {
        var o = t.touchStartListener;
        i.removeEventListener("touchstart", o, { passive: !0 });
      }
    }, e.prototype.removeDragSource = function(t) {
      var i = this.dragSources.find(function(r) {
        return r.dragSource === t;
      });
      i && (this.removeListener(i), Zr(this.dragSources, i));
    }, e.prototype.isDragging = function() {
      return this.dragging;
    }, e.prototype.addDragSource = function(t, i) {
      var r = this;
      i === void 0 && (i = !1);
      var o = this.onMouseDown.bind(this, t);
      t.eElement.addEventListener("mousedown", o);
      var s = null, a = this.gridOptionsWrapper.isSuppressTouch();
      i && !a && (s = function(l) {
        l.cancelable && l.preventDefault(), r.onTouchStart(t, l);
      }, t.eElement.addEventListener("touchstart", s, { passive: !0 })), this.dragSources.push({
        dragSource: t,
        mouseDownListener: o,
        touchStartListener: s,
        touchEnabled: i
      });
    }, e.prototype.onTouchStart = function(t, i) {
      var r = this;
      this.currentDragParams = t, this.dragging = !1;
      var o = i.touches[0];
      this.touchLastTime = o, this.touchStart = o;
      var s = function(h) {
        return r.onTouchMove(h, t.eElement);
      }, a = function(h) {
        return r.onTouchUp(h, t.eElement);
      }, l = function(h) {
        h.cancelable && h.preventDefault();
      }, u = t.eElement, c = [
        // Prevents the page document from moving while we are dragging items around.
        // preventDefault needs to be called in the touchmove listener and never inside the
        // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
        { target: document, type: "touchmove", listener: l, options: { passive: !1 } },
        { target: u, type: "touchmove", listener: s, options: { passive: !0 } },
        { target: u, type: "touchend", listener: a, options: { passive: !0 } },
        { target: u, type: "touchcancel", listener: a, options: { passive: !0 } }
      ];
      this.addTemporaryEvents(c), t.dragStartPixels === 0 && this.onCommonMove(o, this.touchStart, t.eElement);
    }, e.prototype.onMouseDown = function(t, i) {
      var r = this, o = i;
      if (!(t.skipMouseEvent && t.skipMouseEvent(i)) && !o._alreadyProcessedByDragService && (o._alreadyProcessedByDragService = !0, i.button === 0)) {
        this.currentDragParams = t, this.dragging = !1, this.mouseStartEvent = i;
        var s = this.gridOptionsWrapper.getDocument(), a = function(d) {
          return r.onMouseMove(d, t.eElement);
        }, l = function(d) {
          return r.onMouseUp(d, t.eElement);
        }, u = function(d) {
          return d.preventDefault();
        }, c = s, h = [
          { target: c, type: "mousemove", listener: a },
          { target: c, type: "mouseup", listener: l },
          { target: c, type: "contextmenu", listener: u }
        ];
        this.addTemporaryEvents(h), t.dragStartPixels === 0 && this.onMouseMove(i, t.eElement);
      }
    }, e.prototype.addTemporaryEvents = function(t) {
      t.forEach(function(i) {
        var r = i.target, o = i.type, s = i.listener, a = i.options;
        r.addEventListener(o, s, a);
      }), this.dragEndFunctions.push(function() {
        t.forEach(function(i) {
          var r = i.target, o = i.type, s = i.listener, a = i.options;
          r.removeEventListener(o, s, a);
        });
      });
    }, e.prototype.isEventNearStartEvent = function(t, i) {
      var r = this.currentDragParams.dragStartPixels, o = ge(r) ? r : 4;
      return Ix(t, i, o);
    }, e.prototype.getFirstActiveTouch = function(t) {
      for (var i = 0; i < t.length; i++)
        if (t[i].identifier === this.touchStart.identifier)
          return t[i];
      return null;
    }, e.prototype.onCommonMove = function(t, i, r) {
      if (!this.dragging) {
        if (!this.dragging && this.isEventNearStartEvent(t, i))
          return;
        this.dragging = !0;
        var o = {
          type: F.EVENT_DRAG_STARTED,
          api: this.gridApi,
          columnApi: this.columnApi,
          target: r
        };
        this.eventService.dispatchEvent(o), this.currentDragParams.onDragStart(i), this.currentDragParams.onDragging(i);
      }
      this.currentDragParams.onDragging(t);
    }, e.prototype.onTouchMove = function(t, i) {
      var r = this.getFirstActiveTouch(t.touches);
      r && this.onCommonMove(r, this.touchStart, i);
    }, e.prototype.onMouseMove = function(t, i) {
      t.type === "mousemove" && t.cancelable && t.preventDefault(), this.onCommonMove(t, this.mouseStartEvent, i);
    }, e.prototype.onTouchUp = function(t, i) {
      var r = this.getFirstActiveTouch(t.changedTouches);
      r || (r = this.touchLastTime), this.onUpCommon(r, i);
    }, e.prototype.onMouseUp = function(t, i) {
      this.onUpCommon(t, i);
    }, e.prototype.onUpCommon = function(t, i) {
      if (this.dragging) {
        this.dragging = !1, this.currentDragParams.onDragStop(t);
        var r = {
          type: F.EVENT_DRAG_STOPPED,
          api: this.gridApi,
          columnApi: this.columnApi,
          target: i
        };
        this.eventService.dispatchEvent(r);
      }
      this.mouseStartEvent = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null, this.dragEndFunctions.forEach(function(o) {
        return o();
      }), this.dragEndFunctions.length = 0;
    }, Of([
      T("loggerFactory")
    ], e.prototype, "loggerFactory", void 0), Of([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), Of([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Of([
      Le
    ], e.prototype, "init", null), Of([
      To
    ], e.prototype, "removeAllListeners", null), e = Of([
      qe("dragService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var EZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), jC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, y4 = (
  /** @class */
  function(n) {
    EZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    t = e, e.prototype.progressSort = function(i, r, o) {
      o === void 0 && (o = "api");
      var s = this.getNextSortDirection(i);
      this.setSortForColumn(i, s, r, o);
    }, e.prototype.setSortForColumn = function(i, r, o, s) {
      s === void 0 && (s = "api"), r !== Z.SORT_ASC && r !== Z.SORT_DESC && (r = null), i.setSort(r, s);
      var a = o && !this.gridOptionsWrapper.isSuppressMultiSort();
      a || this.clearSortBarThisColumn(i, s), this.updateSortIndex(i), this.dispatchSortChangedEvents();
    }, e.prototype.updateSortIndex = function(i) {
      var r = this.getColumnsWithSortingOrdered(), o = 0;
      r.forEach(function(a) {
        a !== i && (a.setSortIndex(o), o++);
      }), i.getSort() && i.setSortIndex(o);
      var s = this.columnModel.getPrimaryAndSecondaryAndAutoColumns();
      s.filter(function(a) {
        return a.getSort() == null;
      }).forEach(function(a) {
        return a.setSortIndex();
      });
    }, e.prototype.onSortChanged = function() {
      this.dispatchSortChangedEvents();
    }, e.prototype.isSortActive = function() {
      var i = this.columnModel.getPrimaryAndSecondaryAndAutoColumns(), r = i.filter(function(o) {
        return !!o.getSort();
      });
      return r && r.length > 0;
    }, e.prototype.dispatchSortChangedEvents = function() {
      var i = {
        type: F.EVENT_SORT_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.clearSortBarThisColumn = function(i, r) {
      this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach(function(o) {
        o !== i && o.setSort(void 0, r);
      });
    }, e.prototype.getNextSortDirection = function(i) {
      var r;
      if (i.getColDef().sortingOrder ? r = i.getColDef().sortingOrder : this.gridOptionsWrapper.getSortingOrder() ? r = this.gridOptionsWrapper.getSortingOrder() : r = t.DEFAULT_SORTING_ORDER, !Array.isArray(r) || r.length <= 0)
        return console.warn("AG Grid: sortingOrder must be an array with at least one element, currently it's " + r), null;
      var o = r.indexOf(i.getSort()), s = o < 0, a = o == r.length - 1, l;
      return s || a ? l = r[0] : l = r[o + 1], t.DEFAULT_SORTING_ORDER.indexOf(l) < 0 ? (console.warn("AG Grid: invalid sort type " + l), null) : l;
    }, e.prototype.getColumnsWithSortingOrdered = function() {
      var i = this.columnModel.getPrimaryAndSecondaryAndAutoColumns(), r = i.filter(function(s) {
        return !!s.getSort();
      }), o = {};
      return i.forEach(function(s, a) {
        return o[s.getId()] = a;
      }), r.sort(function(s, a) {
        var l = s.getSortIndex(), u = a.getSortIndex();
        if (l != null && u != null)
          return l - u;
        if (l == null && u == null) {
          var c = o[s.getId()], h = o[a.getId()];
          return c > h ? 1 : -1;
        } else
          return u == null ? -1 : 1;
      }), r;
    }, e.prototype.getSortModel = function() {
      return this.getColumnsWithSortingOrdered().map(function(i) {
        return {
          sort: i.getSort(),
          colId: i.getId()
        };
      });
    }, e.prototype.getSortOptions = function() {
      return this.getColumnsWithSortingOrdered().map(function(i) {
        return {
          sort: i.getSort(),
          column: i
        };
      });
    };
    var t;
    return e.DEFAULT_SORTING_ORDER = [Z.SORT_ASC, Z.SORT_DESC, null], jC([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), jC([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), jC([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), e = t = jC([
      qe("sortController")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var LZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), hF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, w4 = (
  /** @class */
  function(n) {
    LZ(e, n);
    function e() {
      var i = n !== null && n.apply(this, arguments) || this;
      return i.gridInstanceId = t.gridInstanceSequence.next(), i;
    }
    t = e, e.prototype.stampTopLevelGridCompWithGridInstance = function(i) {
      i[t.GRID_DOM_KEY] = this.gridInstanceId;
    }, e.prototype.getRenderedCellForEvent = function(i) {
      return Vw(this.gridOptionsWrapper, i, Zc.DOM_DATA_KEY_CELL_CTRL);
    }, e.prototype.isEventFromThisGrid = function(i) {
      var r = this.isElementInThisGrid(i.target);
      return r;
    }, e.prototype.isElementInThisGrid = function(i) {
      for (var r = i; r; ) {
        var o = r[t.GRID_DOM_KEY];
        if (ge(o)) {
          var s = o === this.gridInstanceId;
          return s;
        }
        r = r.parentElement;
      }
      return !1;
    }, e.prototype.getCellPositionForEvent = function(i) {
      var r = this.getRenderedCellForEvent(i);
      return r ? r.getCellPosition() : null;
    }, e.prototype.getNormalisedPosition = function(i) {
      var r = this.gridOptionsWrapper.getDomLayout() === Z.DOM_LAYOUT_NORMAL, o = i, s, a;
      if (o.clientX != null || o.clientY != null ? (s = o.clientX, a = o.clientY) : (s = o.x, a = o.y), r) {
        var l = this.ctrlsService.getGridBodyCtrl(), u = l.getScrollFeature().getVScrollPosition(), c = l.getScrollFeature().getHScrollPosition();
        s += c.left, a += u.top;
      }
      return { x: s, y: a };
    };
    var t;
    return e.gridInstanceSequence = new PS(), e.GRID_DOM_KEY = "__ag_grid_instance", hF([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), e = t = hF([
      qe("mouseEventService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var DZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), bm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, b4 = (
  /** @class */
  function(n) {
    DZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getNextCellToFocus = function(t, i) {
      for (var r = i, o = !1; !o; ) {
        switch (t) {
          case _e.UP:
            r = this.getCellAbove(r);
            break;
          case _e.DOWN:
            r = this.getCellBelow(r);
            break;
          case _e.RIGHT:
            this.gridOptionsWrapper.isEnableRtl() ? r = this.getCellToLeft(r) : r = this.getCellToRight(r);
            break;
          case _e.LEFT:
            this.gridOptionsWrapper.isEnableRtl() ? r = this.getCellToRight(r) : r = this.getCellToLeft(r);
            break;
          default:
            r = null, console.warn("AG Grid: unknown key for navigation " + t);
            break;
        }
        r ? o = this.isCellGoodToFocusOn(r) : o = !0;
      }
      return r;
    }, e.prototype.isCellGoodToFocusOn = function(t) {
      var i = t.column, r;
      switch (t.rowPinned) {
        case Z.PINNED_TOP:
          r = this.pinnedRowModel.getPinnedTopRow(t.rowIndex);
          break;
        case Z.PINNED_BOTTOM:
          r = this.pinnedRowModel.getPinnedBottomRow(t.rowIndex);
          break;
        default:
          r = this.rowModel.getRow(t.rowIndex);
          break;
      }
      if (!r)
        return !1;
      var o = i.isSuppressNavigable(r);
      return !o;
    }, e.prototype.getCellToLeft = function(t) {
      if (!t)
        return null;
      var i = this.columnModel.getDisplayedColBefore(t.column);
      return i ? {
        rowIndex: t.rowIndex,
        column: i,
        rowPinned: t.rowPinned
      } : null;
    }, e.prototype.getCellToRight = function(t) {
      if (!t)
        return null;
      var i = this.columnModel.getDisplayedColAfter(t.column);
      return i ? {
        rowIndex: t.rowIndex,
        column: i,
        rowPinned: t.rowPinned
      } : null;
    }, e.prototype.getRowBelow = function(t) {
      var i = t.rowIndex, r = t.rowPinned;
      if (this.isLastRowInContainer(t))
        switch (r) {
          case Z.PINNED_BOTTOM:
            return null;
          case Z.PINNED_TOP:
            return this.rowModel.isRowsToRender() ? { rowIndex: this.paginationProxy.getPageFirstRow(), rowPinned: null } : this.pinnedRowModel.isRowsToRender(Z.PINNED_BOTTOM) ? { rowIndex: 0, rowPinned: Z.PINNED_BOTTOM } : null;
          default:
            return this.pinnedRowModel.isRowsToRender(Z.PINNED_BOTTOM) ? { rowIndex: 0, rowPinned: Z.PINNED_BOTTOM } : null;
        }
      return { rowIndex: i + 1, rowPinned: r };
    }, e.prototype.getCellBelow = function(t) {
      if (!t)
        return null;
      var i = this.getRowBelow(t);
      return i ? {
        rowIndex: i.rowIndex,
        column: t.column,
        rowPinned: i.rowPinned
      } : null;
    }, e.prototype.isLastRowInContainer = function(t) {
      var i = t.rowPinned, r = t.rowIndex;
      if (i === Z.PINNED_TOP) {
        var o = this.pinnedRowModel.getPinnedTopRowData().length - 1;
        return o <= r;
      }
      if (i === Z.PINNED_BOTTOM) {
        var s = this.pinnedRowModel.getPinnedBottomRowData().length - 1;
        return s <= r;
      }
      var a = this.paginationProxy.getPageLastRow();
      return a <= r;
    }, e.prototype.getRowAbove = function(t) {
      var i = t.rowIndex, r = t.rowPinned, o = r ? i === 0 : i === this.paginationProxy.getPageFirstRow();
      return o ? r === Z.PINNED_TOP ? null : r ? this.rowModel.isRowsToRender() ? this.getLastBodyCell() : this.pinnedRowModel.isRowsToRender(Z.PINNED_TOP) ? this.getLastFloatingTopRow() : null : this.pinnedRowModel.isRowsToRender(Z.PINNED_TOP) ? this.getLastFloatingTopRow() : null : { rowIndex: i - 1, rowPinned: r };
    }, e.prototype.getCellAbove = function(t) {
      if (!t)
        return null;
      var i = this.getRowAbove({ rowIndex: t.rowIndex, rowPinned: t.rowPinned });
      return i ? {
        rowIndex: i.rowIndex,
        column: t.column,
        rowPinned: i.rowPinned
      } : null;
    }, e.prototype.getLastBodyCell = function() {
      var t = this.paginationProxy.getPageLastRow();
      return { rowIndex: t, rowPinned: null };
    }, e.prototype.getLastFloatingTopRow = function() {
      var t = this.pinnedRowModel.getPinnedTopRowData().length - 1;
      return { rowIndex: t, rowPinned: Z.PINNED_TOP };
    }, e.prototype.getNextTabbedCell = function(t, i) {
      return i ? this.getNextTabbedCellBackwards(t) : this.getNextTabbedCellForwards(t);
    }, e.prototype.getNextTabbedCellForwards = function(t) {
      var i = this.columnModel.getAllDisplayedColumns(), r = t.rowIndex, o = t.rowPinned, s = this.columnModel.getDisplayedColAfter(t.column);
      if (!s) {
        s = i[0];
        var a = this.getRowBelow(t);
        if (Je(a) || !a.rowPinned && !this.paginationProxy.isRowInPage(a))
          return null;
        r = a ? a.rowIndex : null, o = a ? a.rowPinned : null;
      }
      return { rowIndex: r, column: s, rowPinned: o };
    }, e.prototype.getNextTabbedCellBackwards = function(t) {
      var i = this.columnModel.getAllDisplayedColumns(), r = t.rowIndex, o = t.rowPinned, s = this.columnModel.getDisplayedColBefore(t.column);
      if (!s) {
        s = Ti(i);
        var a = this.getRowAbove({ rowIndex: t.rowIndex, rowPinned: t.rowPinned });
        if (Je(a) || !a.rowPinned && !this.paginationProxy.isRowInPage(a))
          return null;
        r = a ? a.rowIndex : null, o = a ? a.rowPinned : null;
      }
      return { rowIndex: r, column: s, rowPinned: o };
    }, bm([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), bm([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), bm([
      T("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), bm([
      T("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), e = bm([
      qe("cellNavigationService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var RZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), dF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, S4 = (
  /** @class */
  function(n) {
    RZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.formatValue = function(t, i, r, o, s, a) {
      a === void 0 && (a = !0);
      var l = null, u, c = t.getColDef();
      if (s ? u = s : a && (u = i && i.rowPinned && c.pinnedRowValueFormatter ? c.pinnedRowValueFormatter : c.valueFormatter), u) {
        var h = {
          value: o,
          node: i,
          data: i ? i.data : null,
          colDef: c,
          column: t,
          api: this.gridOptionsWrapper.getApi(),
          columnApi: this.gridOptionsWrapper.getColumnApi(),
          context: this.gridOptionsWrapper.getContext()
        };
        h.$scope = r, l = this.expressionService.evaluate(u, h);
      } else if (c.refData)
        return c.refData[o] || "";
      return l == null && Array.isArray(o) && (l = o.join(", ")), l;
    }, dF([
      T("expressionService")
    ], e.prototype, "expressionService", void 0), e = dF([
      qe("valueFormatterService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var TZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), E4 = (
  /** @class */
  function(n) {
    TZ(e, n);
    function e(t) {
      return n.call(this, t, "ag-radio-button", "radio") || this;
    }
    return e.prototype.isSelected = function() {
      return this.eInput.checked;
    }, e.prototype.toggle = function() {
      this.eInput.disabled || this.isSelected() || this.setValue(!0);
    }, e.prototype.addInputListeners = function() {
      n.prototype.addInputListeners.call(this), this.addManagedListener(this.eventService, F.EVENT_CHECKBOX_CHANGED, this.onChange.bind(this));
    }, e.prototype.onChange = function(t) {
      t.selected && t.name && this.eInput.name && this.eInput.name === t.name && t.id && this.eInput.id !== t.id && this.setValue(!1, !0);
    }, e;
  }(Kp)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var OZ = ["mouseover", "mouseout", "mouseenter", "mouseleave"], xZ = ["touchstart", "touchend", "touchmove", "touchcancel"], L4 = (
  /** @class */
  function() {
    function n() {
      this.isOutsideAngular = function(e) {
        return Es(OZ, e);
      };
    }
    return n.prototype.setTimeout = function(e, t) {
      window.setTimeout(e, t);
    }, n.prototype.setInterval = function(e, t) {
      return new Bo(function(i) {
        i(window.setInterval(e, t));
      });
    }, n.prototype.addEventListener = function(e, t, i, r) {
      var o = Es(xZ, t);
      e.addEventListener(t, i, { capture: !!r, passive: o });
    }, n.prototype.dispatchEvent = function(e, t, i) {
      t();
    }, n.prototype.frameworkComponent = function(e) {
      return null;
    }, n.prototype.isFrameworkComponent = function(e) {
      return !1;
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var NZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Sm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, D4 = (
  /** @class */
  function(n) {
    NZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));
    }, e.prototype.onDisplayedColumnsChanged = function() {
      this.update();
    }, e.prototype.onDisplayedColumnsWidthChanged = function() {
      this.update();
    }, e.prototype.update = function() {
      this.updateImpl(), setTimeout(this.updateImpl.bind(this), 500);
    }, e.prototype.updateImpl = function() {
      var t = this.ctrlsService.getCenterRowContainerCtrl();
      if (t) {
        var i = {
          horizontalScrollShowing: t.isHorizontalScrollShowing(),
          verticalScrollShowing: this.isVerticalScrollShowing()
        };
        this.setScrollsVisible(i);
      }
    }, e.prototype.setScrollsVisible = function(t) {
      var i = this.horizontalScrollShowing !== t.horizontalScrollShowing || this.verticalScrollShowing !== t.verticalScrollShowing;
      if (i) {
        this.horizontalScrollShowing = t.horizontalScrollShowing, this.verticalScrollShowing = t.verticalScrollShowing;
        var r = {
          type: F.EVENT_SCROLL_VISIBILITY_CHANGED,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.eventService.dispatchEvent(r);
      }
    }, e.prototype.isHorizontalScrollShowing = function() {
      return this.horizontalScrollShowing;
    }, e.prototype.isVerticalScrollShowing = function() {
      return this.verticalScrollShowing;
    }, Sm([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), Sm([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Sm([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Sm([
      Le
    ], e.prototype, "postConstruct", null), e = Sm([
      qe("scrollVisibleService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var IZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), fF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, R4 = (
  /** @class */
  function(n) {
    IZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.processAllCellClasses = function(t, i, r, o) {
      this.processClassRules(t.cellClassRules, i, r, o), this.processStaticCellClasses(t, i, r);
    }, e.prototype.processClassRules = function(t, i, r, o) {
      if (t != null) {
        for (var s = Object.keys(t), a = {}, l = {}, u = function(d) {
          var f = s[d], p = t[f], g;
          typeof p == "string" ? g = c.expressionService.evaluate(p, i) : typeof p == "function" && (g = p(i)), f.split(" ").forEach(function(_) {
            _ == null || _.trim() == "" || (g ? a[_] = !0 : l[_] = !0);
          });
        }, c = this, h = 0; h < s.length; h++)
          u(h);
        o && Object.keys(l).forEach(o), Object.keys(a).forEach(r);
      }
    }, e.prototype.getStaticCellClasses = function(t, i) {
      var r = t.cellClass;
      if (!r)
        return [];
      var o;
      if (typeof r == "function") {
        var s = r;
        o = s(i);
      } else
        o = r;
      return typeof o == "string" && (o = [o]), o || [];
    }, e.prototype.processStaticCellClasses = function(t, i, r) {
      var o = this.getStaticCellClasses(t, i);
      o.forEach(function(s) {
        r(s);
      });
    }, fF([
      T("expressionService")
    ], e.prototype, "expressionService", void 0), e = fF([
      qe("stylingService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var PZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), PL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, AZ = (
  /** @class */
  function(n) {
    PZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.setMouseOver = function(t) {
      this.selectedColumns = t;
      var i = {
        type: F.EVENT_COLUMN_HOVER_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.clearMouseOver = function() {
      this.selectedColumns = null;
      var t = {
        type: F.EVENT_COLUMN_HOVER_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(t);
    }, e.prototype.isHovered = function(t) {
      return !!this.selectedColumns && this.selectedColumns.indexOf(t) >= 0;
    }, PL([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), PL([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), e = PL([
      qe("columnHoverService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var MZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), AL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, FZ = (
  /** @class */
  function(n) {
    MZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.executeNextFuncs = [], t.executeLaterFuncs = [], t.active = !1, t.animationThreadCount = 0, t;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        return t.gridBodyCtrl = i.gridBodyCtrl;
      });
    }, e.prototype.isActive = function() {
      return this.active;
    }, e.prototype.start = function() {
      this.active || this.gridOptionsWrapper.isSuppressColumnMoveAnimation() || this.gridOptionsWrapper.isEnableRtl() || (this.ensureAnimationCssClassPresent(), this.active = !0);
    }, e.prototype.finish = function() {
      this.active && (this.flush(), this.active = !1);
    }, e.prototype.executeNextVMTurn = function(t) {
      this.active ? this.executeNextFuncs.push(t) : t();
    }, e.prototype.executeLaterVMTurn = function(t) {
      this.active ? this.executeLaterFuncs.push(t) : t();
    }, e.prototype.ensureAnimationCssClassPresent = function() {
      var t = this;
      this.animationThreadCount++;
      var i = this.animationThreadCount;
      this.gridBodyCtrl.setColumnMovingCss(!0), this.executeLaterFuncs.push(function() {
        t.animationThreadCount === i && t.gridBodyCtrl.setColumnMovingCss(!1);
      });
    }, e.prototype.flush = function() {
      var t = this.executeNextFuncs;
      this.executeNextFuncs = [];
      var i = this.executeLaterFuncs;
      this.executeLaterFuncs = [], !(t.length === 0 && i.length === 0) && (window.setTimeout(function() {
        return t.forEach(function(r) {
          return r();
        });
      }, 0), window.setTimeout(function() {
        return i.forEach(function(r) {
          return r();
        });
      }, 300));
    }, AL([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), AL([
      Le
    ], e.prototype, "postConstruct", null), e = AL([
      qe("columnAnimationService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var kZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ML = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, WZ = (
  /** @class */
  function(n) {
    kZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    t = e, e.prototype.createAutoGroupColumns = function(i) {
      var r = this, o = [], s = this.gridOptionsWrapper.isTreeData(), a = this.gridOptionsWrapper.isGroupMultiAutoColumn();
      return s && a && (console.warn("AG Grid: you cannot mix groupMultiAutoColumn with treeData, only one column can be used to display groups when doing tree data"), a = !1), a ? i.forEach(function(l, u) {
        o.push(r.createOneAutoGroupColumn(l, u));
      }) : o.push(this.createOneAutoGroupColumn()), o;
    }, e.prototype.createOneAutoGroupColumn = function(i, r) {
      var o = this.generateDefaultColDef(i), s;
      i ? s = Z.GROUP_AUTO_COLUMN_ID + "-" + i.getId() : s = t.GROUP_AUTO_COLUMN_BUNDLE_ID;
      var a = this.gridOptionsWrapper.getAutoGroupColumnDef();
      if (ha(o, a), o = this.columnFactory.mergeColDefs(o), o.colId = s, !this.gridOptionsWrapper.isTreeData()) {
        var l = Je(o.field) && Je(o.valueGetter) && Je(o.filterValueGetter);
        l && (o.filter = !1);
      }
      r && r > 0 && (o.headerCheckboxSelection = !1);
      var u = new Gt(o, null, s, !0);
      return this.context.createBean(u), u;
    }, e.prototype.generateDefaultColDef = function(i) {
      var r = this.gridOptionsWrapper.getAutoGroupColumnDef(), o = this.gridOptionsWrapper.getLocaleTextFunc(), s = {
        headerName: o("group", "Group")
      }, a = r && (r.cellRenderer || r.cellRendererFramework || r.cellRendererSelector);
      if (a || (s.cellRenderer = "agGroupCellRenderer"), i) {
        var l = i.getColDef();
        Object.assign(s, {
          // cellRendererParams.groupKey: colDefToCopy.field;
          headerName: this.columnModel.getDisplayNameForColumn(i, "header"),
          headerValueGetter: l.headerValueGetter
        }), (l.cellRenderer || l.cellRendererFramework) && Object.assign(s, {
          cellRendererParams: {
            innerRenderer: l.cellRenderer,
            innerRendererFramework: l.cellRendererFramework,
            innerRendererParams: l.cellRendererParams
          }
        }), s.showRowGroup = i.getColId();
      } else
        s.showRowGroup = !0;
      return s;
    };
    var t;
    return e.GROUP_AUTO_COLUMN_BUNDLE_ID = Z.GROUP_AUTO_COLUMN_ID, ML([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), ML([
      T("columnFactory")
    ], e.prototype, "columnFactory", void 0), e = t = ML([
      qe("autoGroupColService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var VZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Em = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, T4 = (
  /** @class */
  function(n) {
    VZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.currentPage = 0, t.topDisplayedRowIndex = 0, t.bottomDisplayedRowIndex = 0, t.pixelOffset = 0, t.masterRowCount = 0, t;
    }
    return e.prototype.postConstruct = function() {
      this.active = this.gridOptionsWrapper.isPagination(), this.paginateChildRows = this.gridOptionsWrapper.isPaginateChildRows(), this.addManagedListener(this.eventService, F.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this)), this.addManagedListener(this.gridOptionsWrapper, "paginationPageSize", this.onPaginationPageSizeChanged.bind(this)), this.onModelUpdated();
    }, e.prototype.ensureRowHeightsValid = function(t, i, r, o) {
      var s = this.rowModel.ensureRowHeightsValid(t, i, this.getPageFirstRow(), this.getPageLastRow());
      return s && this.calculatePages(), s;
    }, e.prototype.onModelUpdated = function(t) {
      this.calculatePages();
      var i = {
        type: F.EVENT_PAGINATION_CHANGED,
        animate: t ? t.animate : !1,
        newData: t ? t.newData : !1,
        newPage: t ? t.newPage : !1,
        keepRenderedRows: t ? t.keepRenderedRows : !1,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.onPaginationPageSizeChanged = function() {
      this.calculatePages();
      var t = {
        type: F.EVENT_PAGINATION_CHANGED,
        animate: !1,
        newData: !1,
        newPage: !1,
        // important to keep rendered rows, otherwise every time grid is resized,
        // we would destroy all the rows.
        keepRenderedRows: !0,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(t);
    }, e.prototype.goToPage = function(t) {
      if (!(!this.active || this.currentPage === t)) {
        this.currentPage = t;
        var i = {
          type: F.EVENT_MODEL_UPDATED,
          animate: !1,
          keepRenderedRows: !1,
          newData: !1,
          newPage: !0,
          api: this.gridApi,
          columnApi: this.columnApi
        };
        this.onModelUpdated(i);
      }
    }, e.prototype.getPixelOffset = function() {
      return this.pixelOffset;
    }, e.prototype.getRow = function(t) {
      return this.rowModel.getRow(t);
    }, e.prototype.getRowNode = function(t) {
      return this.rowModel.getRowNode(t);
    }, e.prototype.getRowIndexAtPixel = function(t) {
      return this.rowModel.getRowIndexAtPixel(t);
    }, e.prototype.getCurrentPageHeight = function() {
      return Je(this.topRowBounds) || Je(this.bottomRowBounds) ? 0 : Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0);
    }, e.prototype.getCurrentPagePixelRange = function() {
      var t = this.topRowBounds ? this.topRowBounds.rowTop : 0, i = this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0;
      return { pageFirstPixel: t, pageLastPixel: i };
    }, e.prototype.isRowPresent = function(t) {
      if (!this.rowModel.isRowPresent(t))
        return !1;
      var i = t.rowIndex >= this.topDisplayedRowIndex && t.rowIndex <= this.bottomDisplayedRowIndex;
      return i;
    }, e.prototype.isEmpty = function() {
      return this.rowModel.isEmpty();
    }, e.prototype.isRowsToRender = function() {
      return this.rowModel.isRowsToRender();
    }, e.prototype.getNodesInRangeForSelection = function(t, i) {
      return this.rowModel.getNodesInRangeForSelection(t, i);
    }, e.prototype.forEachNode = function(t) {
      return this.rowModel.forEachNode(t);
    }, e.prototype.getType = function() {
      return this.rowModel.getType();
    }, e.prototype.getRowBounds = function(t) {
      var i = this.rowModel.getRowBounds(t);
      return i.rowIndex = t, i;
    }, e.prototype.getPageFirstRow = function() {
      return this.topRowBounds ? this.topRowBounds.rowIndex : -1;
    }, e.prototype.getPageLastRow = function() {
      return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1;
    }, e.prototype.getRowCount = function() {
      return this.rowModel.getRowCount();
    }, e.prototype.getPageForIndex = function(t) {
      return Math.floor(t / this.pageSize);
    }, e.prototype.goToPageWithIndex = function(t) {
      if (this.active) {
        var i = this.getPageForIndex(t);
        this.goToPage(i);
      }
    }, e.prototype.isRowInPage = function(t) {
      if (!this.active)
        return !0;
      var i = this.getPageForIndex(t.rowIndex);
      return i === this.currentPage;
    }, e.prototype.isLastPageFound = function() {
      return this.rowModel.isLastRowIndexKnown();
    }, e.prototype.getCurrentPage = function() {
      return this.currentPage;
    }, e.prototype.goToNextPage = function() {
      this.goToPage(this.currentPage + 1);
    }, e.prototype.goToPreviousPage = function() {
      this.goToPage(this.currentPage - 1);
    }, e.prototype.goToFirstPage = function() {
      this.goToPage(0);
    }, e.prototype.goToLastPage = function() {
      var t = this.rowModel.getRowCount(), i = Math.floor(t / this.pageSize);
      this.goToPage(i);
    }, e.prototype.getPageSize = function() {
      return this.pageSize;
    }, e.prototype.getTotalPages = function() {
      return this.totalPages;
    }, e.prototype.setPageSize = function() {
      this.pageSize = this.gridOptionsWrapper.getPaginationPageSize(), (this.pageSize == null || this.pageSize < 1) && (this.pageSize = 100);
    }, e.prototype.calculatePages = function() {
      this.active ? (this.setPageSize(), this.paginateChildRows ? this.calculatePagesAllRows() : this.calculatePagesMasterRowsOnly()) : this.calculatedPagesNotActive(), this.topRowBounds = this.rowModel.getRowBounds(this.topDisplayedRowIndex), this.topRowBounds && (this.topRowBounds.rowIndex = this.topDisplayedRowIndex), this.bottomRowBounds = this.rowModel.getRowBounds(this.bottomDisplayedRowIndex), this.bottomRowBounds && (this.bottomRowBounds.rowIndex = this.bottomDisplayedRowIndex), this.setPixelOffset(ge(this.topRowBounds) ? this.topRowBounds.rowTop : 0);
    }, e.prototype.setPixelOffset = function(t) {
      this.pixelOffset !== t && (this.pixelOffset = t, this.eventService.dispatchEvent({ type: F.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED }));
    }, e.prototype.setZeroRows = function() {
      this.masterRowCount = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = -1, this.currentPage = 0, this.totalPages = 0;
    }, e.prototype.calculatePagesMasterRowsOnly = function() {
      if (this.masterRowCount = this.rowModel.getTopLevelRowCount(), this.masterRowCount <= 0) {
        this.setZeroRows();
        return;
      }
      var t = this.masterRowCount - 1;
      this.totalPages = Math.floor(t / this.pageSize) + 1, this.currentPage >= this.totalPages && (this.currentPage = this.totalPages - 1), (!Uw(this.currentPage) || this.currentPage < 0) && (this.currentPage = 0);
      var i = this.pageSize * this.currentPage, r = this.pageSize * (this.currentPage + 1) - 1;
      if (r > t && (r = t), this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(i), r === t)
        this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
      else {
        var o = this.rowModel.getTopLevelRowDisplayedIndex(r + 1);
        this.bottomDisplayedRowIndex = o - 1;
      }
    }, e.prototype.getMasterRowCount = function() {
      return this.masterRowCount;
    }, e.prototype.calculatePagesAllRows = function() {
      if (this.masterRowCount = this.rowModel.getRowCount(), this.masterRowCount === 0) {
        this.setZeroRows();
        return;
      }
      var t = this.masterRowCount - 1;
      this.totalPages = Math.floor(t / this.pageSize) + 1, this.currentPage >= this.totalPages && (this.currentPage = this.totalPages - 1), (!Uw(this.currentPage) || this.currentPage < 0) && (this.currentPage = 0), this.topDisplayedRowIndex = this.pageSize * this.currentPage, this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1, this.bottomDisplayedRowIndex > t && (this.bottomDisplayedRowIndex = t);
    }, e.prototype.calculatedPagesNotActive = function() {
      this.pageSize = this.rowModel.getRowCount(), this.totalPages = 1, this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
    }, Em([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), Em([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), Em([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Em([
      Le
    ], e.prototype, "postConstruct", null), e = Em([
      qe("paginationProxy")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var BZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), FL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, HZ = (
  /** @class */
  function(n) {
    BZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        t.centerRowContainerCon = i.centerRowContainerCtrl, t.addManagedListener(t.eventService, F.EVENT_BODY_HEIGHT_CHANGED, t.onBodyHeightChanged.bind(t)), t.addManagedListener(t.eventService, F.EVENT_SCROLL_VISIBILITY_CHANGED, t.onScrollVisibilityChanged.bind(t)), t.checkPageSize();
      });
    }, e.prototype.notActive = function() {
      return !this.gridOptionsWrapper.isPaginationAutoPageSize();
    }, e.prototype.onScrollVisibilityChanged = function() {
      this.checkPageSize();
    }, e.prototype.onBodyHeightChanged = function() {
      this.checkPageSize();
    }, e.prototype.checkPageSize = function() {
      if (!this.notActive()) {
        var t = this.gridOptionsWrapper.getRowHeightAsNumber(), i = this.centerRowContainerCon.getViewportSizeFeature().getBodyHeight();
        if (i > 0) {
          var r = Math.floor(i / t);
          this.gridOptionsWrapper.setProperty("paginationPageSize", r);
        }
      }
    }, FL([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), FL([
      Le
    ], e.prototype, "postConstruct", null), e = FL([
      qe("paginationAutoPageSizeService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var GZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), pF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, O4 = (
  /** @class */
  function(n) {
    GZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.cacheVersion = 0, t;
    }
    return e.prototype.init = function() {
      this.active = this.gridOptionsWrapper.isValueCache(), this.neverExpires = this.gridOptionsWrapper.isValueCacheNeverExpires();
    }, e.prototype.onDataChanged = function() {
      this.neverExpires || this.expire();
    }, e.prototype.expire = function() {
      this.cacheVersion++;
    }, e.prototype.setValue = function(t, i, r) {
      this.active && (t.__cacheVersion !== this.cacheVersion && (t.__cacheVersion = this.cacheVersion, t.__cacheData = {}), t.__cacheData[i] = r);
    }, e.prototype.getValue = function(t, i) {
      if (!(!this.active || t.__cacheVersion !== this.cacheVersion))
        return t.__cacheData[i];
    }, pF([
      Le
    ], e.prototype, "init", null), e = pF([
      qe("valueCache")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var UZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), $C = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, zZ = (
  /** @class */
  function(n) {
    UZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      this.rowModel.getType() === Z.ROW_MODEL_TYPE_CLIENT_SIDE && (this.clientSideRowModel = this.rowModel), this.addManagedListener(this.eventService, F.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged.bind(this));
    }, e.prototype.onCellValueChanged = function(t) {
      t.source !== Z.SOURCE_PASTE && this.doChangeDetection(t.node, t.column);
    }, e.prototype.doChangeDetection = function(t, i) {
      if (!this.gridOptionsWrapper.isSuppressChangeDetection()) {
        if (this.clientSideRowModel && !t.isRowPinned()) {
          var r = this.gridOptionsWrapper.isAggregateOnlyChangedColumns(), o = new Bx(r, this.clientSideRowModel.getRootNode());
          o.addParentNode(t.parent, [i]), this.clientSideRowModel.doAggregate(o);
        }
        this.rowRenderer.refreshCells();
      }
    }, $C([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), $C([
      T("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), $C([
      Le
    ], e.prototype, "init", null), e = $C([
      qe("changeDetectionService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var jZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Lm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, $Z = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, x4 = (
  /** @class */
  function(n) {
    jZ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.consuming = !1, t;
    }
    return e.prototype.setBeans = function(t) {
      this.logger = t.create("AlignedGridsService");
    }, e.prototype.init = function() {
      this.addManagedListener(this.eventService, F.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, F.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, F.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, F.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, F.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, F.EVENT_BODY_SCROLL, this.fireScrollEvent.bind(this));
    }, e.prototype.fireEvent = function(t) {
      if (!this.consuming) {
        var i = this.gridOptionsWrapper.getAlignedGrids();
        i && i.forEach(function(r) {
          if (r.api) {
            var o = r.api.__getAlignedGridService();
            t(o);
          }
        });
      }
    }, e.prototype.onEvent = function(t) {
      this.consuming = !0, t(), this.consuming = !1;
    }, e.prototype.fireColumnEvent = function(t) {
      this.fireEvent(function(i) {
        i.onColumnEvent(t);
      });
    }, e.prototype.fireScrollEvent = function(t) {
      t.direction === "horizontal" && this.fireEvent(function(i) {
        i.onScrollEvent(t);
      });
    }, e.prototype.onScrollEvent = function(t) {
      var i = this;
      this.onEvent(function() {
        var r = i.ctrlsService.getGridBodyCtrl();
        r.getScrollFeature().setHorizontalScrollPosition(t.left);
      });
    }, e.prototype.getMasterColumns = function(t) {
      var i = [];
      return t.columns ? t.columns.forEach(function(r) {
        i.push(r);
      }) : t.column && i.push(t.column), i;
    }, e.prototype.getColumnIds = function(t) {
      var i = [];
      return t.columns ? t.columns.forEach(function(r) {
        i.push(r.getColId());
      }) : t.column && i.push(t.column.getColId()), i;
    }, e.prototype.onColumnEvent = function(t) {
      var i = this;
      this.onEvent(function() {
        switch (t.type) {
          case F.EVENT_COLUMN_MOVED:
          case F.EVENT_COLUMN_VISIBLE:
          case F.EVENT_COLUMN_PINNED:
          case F.EVENT_COLUMN_RESIZED:
            var r = t;
            i.processColumnEvent(r);
            break;
          case F.EVENT_COLUMN_GROUP_OPENED:
            var o = t;
            i.processGroupOpenedEvent(o);
            break;
          case F.EVENT_COLUMN_PIVOT_CHANGED:
            console.warn("AG Grid: pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.");
            break;
        }
      });
    }, e.prototype.processGroupOpenedEvent = function(t) {
      var i = t.columnGroup, r = null;
      if (i) {
        var o = i.getGroupId();
        r = this.columnModel.getProvidedColumnGroup(o);
      }
      i && !r || (this.logger.log("onColumnEvent-> processing " + t + " expanded = " + i.isExpanded()), this.columnModel.setColumnGroupOpened(r, i.isExpanded(), "alignedGridChanged"));
    }, e.prototype.processColumnEvent = function(t) {
      var i = this, r = t.column, o = null;
      if (r && (o = this.columnModel.getPrimaryColumn(r.getColId())), !(r && !o)) {
        var s = this.getMasterColumns(t);
        switch (t.type) {
          case F.EVENT_COLUMN_MOVED:
            {
              var a = t, l = t.columnApi.getColumnState(), u = l.map(function(_) {
                return { colId: _.colId };
              });
              this.columnModel.applyColumnState({ state: u, applyOrder: !0 }, "alignedGridChanged"), this.logger.log("onColumnEvent-> processing " + t.type + " toIndex = " + a.toIndex);
            }
            break;
          case F.EVENT_COLUMN_VISIBLE:
            {
              var c = t, l = t.columnApi.getColumnState(), u = l.map(function(v) {
                return { colId: v.colId, hide: v.hide };
              });
              this.columnModel.applyColumnState({ state: u }, "alignedGridChanged"), this.logger.log("onColumnEvent-> processing " + t.type + " visible = " + c.visible);
            }
            break;
          case F.EVENT_COLUMN_PINNED:
            {
              var h = t, l = t.columnApi.getColumnState(), u = l.map(function(v) {
                return { colId: v.colId, pinned: v.pinned };
              });
              this.columnModel.applyColumnState({ state: u }, "alignedGridChanged"), this.logger.log("onColumnEvent-> processing " + t.type + " pinned = " + h.pinned);
            }
            break;
          case F.EVENT_COLUMN_RESIZED:
            var d = t;
            s.forEach(function(_) {
              i.logger.log("onColumnEvent-> processing " + t.type + " actualWidth = " + _.getActualWidth());
              var m = [{ key: _.getColId(), newWidth: _.getActualWidth() }];
              i.columnModel.setColumnWidths(m, !1, d.finished, "alignedGridChanged");
            });
            break;
        }
        var f = this.ctrlsService.getGridBodyCtrl(), p = f.isVerticalScrollShowing(), g = this.gridOptionsWrapper.getAlignedGrids();
        g && g.forEach(function(_) {
          _.api && _.api.setAlwaysShowVerticalScroll(p);
        });
      }
    }, Lm([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), Lm([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Lm([
      $Z(0, Eo("loggerFactory"))
    ], e.prototype, "setBeans", null), Lm([
      Le
    ], e.prototype, "init", null), e = Lm([
      qe("alignedGridsService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var KZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), gF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, qZ = (
  /** @class */
  function(n) {
    KZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.adaptFunction = function(t, i) {
      var r = this.componentMetadataProvider.retrieve(t);
      return r && r.functionAdapter ? r.functionAdapter(i) : null;
    }, e.prototype.adaptCellRendererFunction = function(t) {
      var i = (
        /** @class */
        function() {
          function r() {
          }
          return r.prototype.refresh = function(o) {
            return !1;
          }, r.prototype.getGui = function() {
            return this.eGui;
          }, r.prototype.init = function(o) {
            var s = t(o), a = typeof s;
            if (a === "string" || a === "number" || a === "boolean") {
              this.eGui = Tr("<span>" + s + "</span>");
              return;
            }
            if (s == null) {
              this.eGui = Tr("<span></span>");
              return;
            }
            this.eGui = s;
          }, r;
        }()
      );
      return i;
    }, e.prototype.doesImplementIComponent = function(t) {
      return t ? t.prototype && "getGui" in t.prototype : !1;
    }, gF([
      T("componentMetadataProvider")
    ], e.prototype, "componentMetadataProvider", void 0), e = gF([
      qe("agComponentUtils")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var YZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), kL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, XZ = (
  /** @class */
  function(n) {
    YZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      this.componentMetaData = {
        dateComponent: {
          mandatoryMethodList: ["getDate", "setDate"],
          optionalMethodList: ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel"]
        },
        detailCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        headerComponent: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh"]
        },
        headerGroupComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        loadingCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        loadingOverlayComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        noRowsOverlayComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        floatingFilterComponent: {
          mandatoryMethodList: ["onParentModelChanged"],
          optionalMethodList: ["afterGuiAttached"]
        },
        floatingFilterWrapperComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        cellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh", "afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        cellEditor: {
          mandatoryMethodList: ["getValue"],
          optionalMethodList: ["isPopup", "isCancelBeforeStart", "isCancelAfterEnd", "getPopupPosition", "focusIn", "focusOut", "afterGuiAttached"]
        },
        innerRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        fullWidthCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh", "afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        pinnedRowCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh", "afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        groupRowRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        filter: {
          mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
          optionalMethodList: ["afterGuiAttached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged"]
        },
        filterComponent: {
          mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
          optionalMethodList: ["afterGuiAttached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged"]
        },
        statusPanel: {
          mandatoryMethodList: [],
          optionalMethodList: ["afterGuiAttached"]
        },
        toolPanel: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh", "afterGuiAttached"]
        },
        tooltipComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        }
      };
    }, e.prototype.retrieve = function(t) {
      return this.componentMetaData[t];
    }, kL([
      T("agComponentUtils")
    ], e.prototype, "agComponentUtils", void 0), kL([
      Le
    ], e.prototype, "postConstruct", null), e = kL([
      qe("componentMetadataProvider")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var ZZ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), mF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, WL = 8, QZ = 4, VL = 4, BL = 6, JZ = {
  // this item is required for custom themes
  "ag-theme-custom": {
    headerHeight: 25,
    headerCellMinWidth: 24,
    listItemHeight: QZ * 5,
    rowHeight: 25,
    chartMenuPanelWidth: 220
  },
  "ag-theme-material": {
    headerHeight: WL * 7,
    headerCellMinWidth: 48,
    listItemHeight: WL * 4,
    rowHeight: WL * 6,
    chartMenuPanelWidth: 240
  },
  "ag-theme-balham": {
    headerHeight: VL * 8,
    headerCellMinWidth: 24,
    listItemHeight: VL * 6,
    rowHeight: VL * 7,
    chartMenuPanelWidth: 220
  },
  "ag-theme-alpine": {
    headerHeight: BL * 8,
    headerCellMinWidth: 36,
    listItemHeight: BL * 4,
    rowHeight: BL * 7,
    chartMenuPanelWidth: 240
  }
}, vF = {
  headerHeight: ["ag-header-row"],
  headerCellMinWidth: ["ag-header-cell"],
  listItemHeight: ["ag-virtual-list-item"],
  rowHeight: ["ag-row"],
  chartMenuPanelWidth: ["ag-chart-docked-container"]
}, Dm = {}, N4 = (
  /** @class */
  function(n) {
    ZZ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getSassVariable = function(t, i) {
      var r = "ag-theme-" + (t.match("material") ? "material" : t.match("balham") ? "balham" : t.match("alpine") ? "alpine" : "custom"), o = JZ[r][i], s = 0;
      Dm[t] || (Dm[t] = {});
      var a = Dm[t][i];
      if (a != null)
        return a;
      if (vF[i]) {
        var l = vF[i], u = document.createElement("div");
        u.classList.add(t), u.style.position = "absolute";
        var c = l.reduce(function(d, f) {
          var p = document.createElement("div");
          return p.style.position = "static", p.classList.add(f), d.appendChild(p), p;
        }, u);
        if (document.body) {
          document.body.appendChild(u);
          var h = i.toLowerCase().indexOf("height") !== -1 ? "height" : "width";
          s = parseInt(window.getComputedStyle(c)[h], 10), document.body.removeChild(u);
        }
      }
      return Dm[t][i] = s || o, Dm[t][i];
    }, e.prototype.isThemeDark = function() {
      var t = this.getTheme().theme;
      return !!t && t.indexOf("dark") >= 0;
    }, e.prototype.chartMenuPanelWidth = function() {
      var t = this.getTheme().themeFamily;
      return this.getSassVariable(t, "chartMenuPanelWidth");
    }, e.prototype.getTheme = function() {
      for (var t = /\bag-(material|(?:theme-([\w\-]*)))\b/, i = this.eGridDiv, r = null; i && (r = t.exec(i.className), !r); )
        i = i.parentElement || void 0;
      if (!r)
        return {};
      var o = r[0], s = r[2] === void 0;
      if (s) {
        var a = o.replace("ag-", "ag-theme-");
        mi(function() {
          return console.warn("AG Grid: As of v19 old theme are no longer provided. Please replace " + o + " with " + a + ".");
        }, "using-old-theme");
      }
      return { theme: o, el: i, themeFamily: o.replace(/-dark$/, "") };
    }, mF([
      T("eGridDiv")
    ], e.prototype, "eGridDiv", void 0), e = mF([
      qe("environment")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var eQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), HL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, I4 = (
  /** @class */
  function(n) {
    eQ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.createTasksP1 = { list: [], sorted: !1 }, t.createTasksP2 = { list: [], sorted: !1 }, t.destroyTasks = [], t.ticking = !1, t.scrollGoingDown = !0, t.lastScrollTop = 0, t.taskCount = 0, t.cancelledTasks = /* @__PURE__ */ new Set(), t;
    }
    return e.prototype.setScrollTop = function(t) {
      this.scrollGoingDown = t > this.lastScrollTop, this.lastScrollTop = t;
    }, e.prototype.init = function() {
      this.useAnimationFrame = !this.gridOptionsWrapper.isSuppressAnimationFrame();
    }, e.prototype.isOn = function() {
      return this.useAnimationFrame;
    }, e.prototype.verifyAnimationFrameOn = function(t) {
      this.useAnimationFrame === !1 && console.warn("AG Grid: AnimationFrameService." + t + " called but animation frames are off");
    }, e.prototype.createTask = function(t, i, r) {
      this.verifyAnimationFrameOn(r);
      var o = { task: t, index: i, createOrder: ++this.taskCount };
      this.addTaskToList(this[r], o), this.schedule();
    }, e.prototype.cancelTask = function(t) {
      this.cancelledTasks.add(t);
    }, e.prototype.addTaskToList = function(t, i) {
      t.list.push(i), t.sorted = !1;
    }, e.prototype.sortTaskList = function(t) {
      if (!t.sorted) {
        var i = this.scrollGoingDown ? 1 : -1;
        t.list.sort(function(r, o) {
          return r.index !== o.index ? i * (o.index - r.index) : o.createOrder - r.createOrder;
        }), t.sorted = !0;
      }
    }, e.prototype.addDestroyTask = function(t) {
      this.verifyAnimationFrameOn("createTasksP3"), this.destroyTasks.push(t), this.schedule();
    }, e.prototype.executeFrame = function(t) {
      this.verifyAnimationFrameOn("executeFrame");
      for (var i = this.createTasksP1, r = i.list, o = this.createTasksP2, s = o.list, a = this.destroyTasks, l = (/* @__PURE__ */ new Date()).getTime(), u = (/* @__PURE__ */ new Date()).getTime() - l, c = t <= 0, h = this.ctrlsService.getGridBodyCtrl(); c || u < t; ) {
        var d = h.getScrollFeature().executeAnimationFrameScroll();
        if (!d) {
          var f = void 0;
          if (r.length)
            this.sortTaskList(i), f = r.pop().task;
          else if (s.length)
            this.sortTaskList(o), f = s.pop().task;
          else if (a.length)
            f = a.pop();
          else {
            this.cancelledTasks.clear();
            break;
          }
          this.cancelledTasks.has(f) || f();
        }
        u = (/* @__PURE__ */ new Date()).getTime() - l;
      }
      r.length || s.length || a.length ? this.requestFrame() : this.stopTicking();
    }, e.prototype.stopTicking = function() {
      this.ticking = !1;
    }, e.prototype.flushAllFrames = function() {
      this.useAnimationFrame && this.executeFrame(-1);
    }, e.prototype.schedule = function() {
      this.useAnimationFrame && (this.ticking || (this.ticking = !0, this.requestFrame()));
    }, e.prototype.requestFrame = function() {
      var t = this.executeFrame.bind(this, 60), i = this.gridOptionsWrapper.getDocument(), r = i.defaultView || window;
      r.requestAnimationFrame ? r.requestAnimationFrame(t) : r.webkitRequestAnimationFrame ? r.webkitRequestAnimationFrame(t) : r.setTimeout(t, 0);
    }, e.prototype.isQueueEmpty = function() {
      return !this.ticking;
    }, e.prototype.debounce = function(t) {
      var i = this, r = !1;
      return function() {
        if (!i.isOn()) {
          i.getFrameworkOverrides().setTimeout(t, 0);
          return;
        }
        r || (r = !0, i.addDestroyTask(function() {
          r = !1, t();
        }));
      };
    }, HL([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), HL([
      Le
    ], e.prototype, "init", null), e = HL([
      qe("animationFrameService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var tQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Jw = globalThis && globalThis.__assign || function() {
  return Jw = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, Jw.apply(this, arguments);
}, Mo = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, P4 = (
  /** @class */
  function(n) {
    tQ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.timeLastPageEventProcessed = 0, t;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.ctrlsService.whenReady(function(i) {
        t.gridBodyCon = i.gridBodyCtrl;
      });
    }, e.prototype.handlePageScrollingKey = function(t) {
      var i = t.key, r = t.altKey, o = t.ctrlKey || t.metaKey, s = this.mouseEventService.getCellPositionForEvent(t);
      if (!s)
        return !1;
      var a = !1;
      switch (i) {
        case _e.PAGE_HOME:
        case _e.PAGE_END:
          !o && !r && (this.onHomeOrEndKey(i), a = !0);
          break;
        case _e.LEFT:
        case _e.RIGHT:
          o && !r && (this.onCtrlLeftOrRight(i, s), a = !0);
          break;
        case _e.UP:
        case _e.DOWN:
          o && !r && (this.onCtrlUpOrDown(i, s), a = !0);
          break;
        case _e.PAGE_DOWN:
          !o && !r && (this.onPageDown(s), a = !0);
          break;
        case _e.PAGE_UP:
          !o && !r && (this.onPageUp(s), a = !0);
          break;
      }
      return a && t.preventDefault(), a;
    }, e.prototype.isTimeSinceLastPageEventToRecent = function() {
      var t = (/* @__PURE__ */ new Date()).getTime(), i = t - this.timeLastPageEventProcessed;
      return i < 100;
    }, e.prototype.setTimeLastPageEventProcessed = function() {
      this.timeLastPageEventProcessed = (/* @__PURE__ */ new Date()).getTime();
    }, e.prototype.navigateTo = function(t) {
      var i = t.scrollIndex, r = t.scrollType, o = t.scrollColumn, s = t.focusIndex, a = t.focusColumn;
      if (ge(o) && !o.isPinned() && this.gridBodyCon.getScrollFeature().ensureColumnVisible(o), ge(i) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(i, r), this.animationFrameService.flushAllFrames(), this.focusService.setFocusedCell(s, a, null, !0), this.rangeService) {
        var l = { rowIndex: s, rowPinned: null, column: a };
        this.rangeService.setRangeToCell(l);
      }
    }, e.prototype.onPageDown = function(t) {
      if (!this.isTimeSinceLastPageEventToRecent()) {
        var i = this.ctrlsService.getGridBodyCtrl(), r = i.getScrollFeature().getVScrollPosition(), o = this.getViewportHeight(), s = this.paginationProxy.getPixelOffset(), a = r.top + o, l = this.paginationProxy.getRowIndexAtPixel(a + s), u = l, c = this.paginationProxy.getRow(t.rowIndex).rowTop, h = c + o - s, d = this.paginationProxy.getRowIndexAtPixel(h + s), f = this.paginationProxy.getPageLastRow();
        d === t.rowIndex && (u = d = t.rowIndex + 1), d > f && (d = f), u > f && (u = f), this.isRowTallerThanView(d) && (u = d), this.navigateTo({
          scrollIndex: u,
          scrollType: "top",
          scrollColumn: null,
          focusIndex: d,
          focusColumn: t.column
        }), this.setTimeLastPageEventProcessed();
      }
    }, e.prototype.onPageUp = function(t) {
      if (!this.isTimeSinceLastPageEventToRecent()) {
        var i = this.ctrlsService.getGridBodyCtrl(), r = i.getScrollFeature().getVScrollPosition(), o = this.getViewportHeight(), s = this.paginationProxy.getPixelOffset(), a = r.top, l = this.paginationProxy.getRowIndexAtPixel(a + s), u = l, c = this.paginationProxy.getRow(t.rowIndex), h = c.rowTop + c.rowHeight - o - s, d = this.paginationProxy.getRowIndexAtPixel(h + s), f = this.paginationProxy.getPageFirstRow();
        d === t.rowIndex && (u = d = t.rowIndex - 1), d < f && (d = f), u < f && (u = f);
        var p = "bottom";
        this.isRowTallerThanView(d) && (u = d, p = "top"), this.navigateTo({
          scrollIndex: u,
          scrollType: p,
          scrollColumn: null,
          focusIndex: d,
          focusColumn: t.column
        }), this.setTimeLastPageEventProcessed();
      }
    }, e.prototype.getViewportHeight = function() {
      var t = this.ctrlsService.getGridBodyCtrl(), i = t.getScrollFeature().getVScrollPosition(), r = this.gridOptionsWrapper.getScrollbarWidth(), o = i.bottom - i.top;
      return this.ctrlsService.getCenterRowContainerCtrl().isHorizontalScrollShowing() && (o -= r), o;
    }, e.prototype.isRowTallerThanView = function(t) {
      var i = this.paginationProxy.getRow(t);
      if (!i)
        return !1;
      var r = i.rowHeight;
      return typeof r != "number" ? !1 : r > this.getViewportHeight();
    }, e.prototype.getIndexToFocus = function(t, i) {
      var r = t;
      if (i) {
        var o = this.paginationProxy.getRow(t);
        o && o.stub && (r -= 1);
      }
      return r;
    }, e.prototype.onCtrlUpOrDown = function(t, i) {
      var r = t === _e.UP, o = r ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();
      this.navigateTo({
        scrollIndex: o,
        scrollType: null,
        scrollColumn: i.column,
        focusIndex: this.getIndexToFocus(o, !r),
        focusColumn: i.column
      });
    }, e.prototype.onCtrlLeftOrRight = function(t, i) {
      var r = t === _e.LEFT, o = this.columnModel.getAllDisplayedColumns(), s = this.gridOptionsWrapper.isEnableRtl(), a = r !== s ? o[0] : Ti(o);
      this.navigateTo({
        scrollIndex: i.rowIndex,
        scrollType: null,
        scrollColumn: a,
        focusIndex: i.rowIndex,
        focusColumn: a
      });
    }, e.prototype.onHomeOrEndKey = function(t) {
      var i = t === _e.PAGE_HOME, r = this.columnModel.getAllDisplayedColumns(), o = i ? r[0] : Ti(r), s = i ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();
      this.navigateTo({
        scrollIndex: s,
        scrollType: null,
        scrollColumn: o,
        focusIndex: this.getIndexToFocus(s, !i),
        focusColumn: o
      });
    }, e.prototype.onTabKeyDown = function(t, i) {
      var r = i.shiftKey, o = this.tabToNextCellCommon(t, r, i);
      if (o) {
        i.preventDefault();
        return;
      }
      if (r) {
        var s = t.getRowPosition(), a = s.rowIndex, l = s.rowPinned, u = l ? a === 0 : a === this.paginationProxy.getPageFirstRow();
        u && (i.preventDefault(), this.focusService.focusLastHeader(i));
      } else
        t instanceof Zc && t.focusCell(!0), this.focusService.focusNextGridCoreContainer(r) && i.preventDefault();
    }, e.prototype.tabToNextCell = function(t, i) {
      var r = this.focusService.getFocusedCell();
      if (!r)
        return !1;
      var o = this.getCellByPosition(r);
      return !o && (o = this.rowRenderer.getRowByPosition(r), !o || !o.isFullWidth()) ? !1 : this.tabToNextCellCommon(o, t, i);
    }, e.prototype.tabToNextCellCommon = function(t, i, r) {
      var o = t.isEditing();
      if (!o && t instanceof Zc) {
        var s = t, a = s.getRowCtrl();
        a && (o = a.isEditing());
      }
      var l;
      return o ? this.gridOptionsWrapper.isFullRowEdit() ? l = this.moveToNextEditingRow(t, i, r) : l = this.moveToNextEditingCell(t, i, r) : l = this.moveToNextCellNotEditing(t, i), l || !!this.focusService.getFocusedHeader();
    }, e.prototype.moveToNextEditingCell = function(t, i, r) {
      r === void 0 && (r = null);
      var o = t.getCellPosition();
      t.stopEditing();
      var s = this.findNextCellToFocusOn(o, i, !0);
      return s == null ? !1 : (s.startEditing(null, null, !0, r), s.focusCell(!1), !0);
    }, e.prototype.moveToNextEditingRow = function(t, i, r) {
      r === void 0 && (r = null);
      var o = t.getCellPosition(), s = this.findNextCellToFocusOn(o, i, !0);
      if (s == null)
        return !1;
      var a = s.getCellPosition(), l = this.isCellEditable(o), u = this.isCellEditable(a), c = a && o.rowIndex === a.rowIndex && o.rowPinned === a.rowPinned;
      if (l && t.setFocusOutOnEditor(), !c) {
        var h = t.getRowCtrl();
        h.stopEditing();
        var d = s.getRowCtrl();
        d.startRowEditing(void 0, void 0, void 0, r);
      }
      return u ? (s.setFocusInOnEditor(), s.focusCell()) : s.focusCell(!0), !0;
    }, e.prototype.moveToNextCellNotEditing = function(t, i) {
      var r = this.columnModel.getAllDisplayedColumns(), o;
      t instanceof Qc ? o = Jw(Jw({}, t.getRowPosition()), { column: i ? r[0] : Ti(r) }) : o = t.getCellPosition();
      var s = this.findNextCellToFocusOn(o, i, !1);
      if (s instanceof Zc)
        s.focusCell(!0);
      else if (s)
        return this.tryToFocusFullWidthRow(s.getRowPosition(), i);
      return ge(s);
    }, e.prototype.findNextCellToFocusOn = function(t, i, r) {
      for (var o = t; ; ) {
        t !== o && (t = o), i || (o = this.getLastCellOfColSpan(o)), o = this.cellNavigationService.getNextTabbedCell(o, i);
        var s = this.gridOptionsWrapper.getTabToNextCellFunc();
        if (ge(s)) {
          var a = {
            backwards: i,
            editing: r,
            previousCellPosition: t,
            nextCellPosition: o || null,
            api: this.gridOptionsWrapper.getApi(),
            columnApi: this.gridOptionsWrapper.getColumnApi()
          }, l = s(a);
          ge(l) ? (l.floating && (mi(function() {
            console.warn("AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?");
          }, "no floating in userCell"), l.rowPinned = l.floating), o = {
            rowIndex: l.rowIndex,
            column: l.column,
            rowPinned: l.rowPinned
          }) : o = null;
        }
        if (!o)
          return null;
        if (o.rowIndex < 0) {
          var u = this.headerNavigationService.getHeaderRowCount();
          return this.focusService.focusHeaderPosition({
            headerPosition: {
              headerRowIndex: u + o.rowIndex,
              column: o.column
            }
          }), null;
        }
        var c = this.gridOptionsWrapper.isFullRowEdit();
        if (r && !c) {
          var h = this.isCellEditable(o);
          if (!h)
            continue;
        }
        this.ensureCellVisible(o);
        var d = this.getCellByPosition(o);
        if (!d) {
          var f = this.rowRenderer.getRowByPosition(o);
          if (!f || !f.isFullWidth())
            continue;
          return f;
        }
        if (!d.isSuppressNavigable())
          return this.rangeService && this.rangeService.setRangeToCell(o), d;
      }
    }, e.prototype.isCellEditable = function(t) {
      var i = this.lookupRowNodeForCell(t);
      return i ? t.column.isCellEditable(i) : !1;
    }, e.prototype.getCellByPosition = function(t) {
      var i = this.rowRenderer.getRowByPosition(t);
      return i ? i.getCellCtrl(t.column) : null;
    }, e.prototype.lookupRowNodeForCell = function(t) {
      return t.rowPinned === Z.PINNED_TOP ? this.pinnedRowModel.getPinnedTopRow(t.rowIndex) : t.rowPinned === Z.PINNED_BOTTOM ? this.pinnedRowModel.getPinnedBottomRow(t.rowIndex) : this.paginationProxy.getRow(t.rowIndex);
    }, e.prototype.navigateToNextCell = function(t, i, r, o) {
      for (var s = r, a = !1; s && (s === r || !this.isValidNavigateCell(s)); )
        this.gridOptionsWrapper.isEnableRtl() ? i === _e.LEFT && (s = this.getLastCellOfColSpan(s)) : i === _e.RIGHT && (s = this.getLastCellOfColSpan(s)), s = this.cellNavigationService.getNextCellToFocus(i, s), a = Je(s);
      if (a && t && t.key === _e.UP && (s = {
        rowIndex: -1,
        rowPinned: null,
        column: r.column
      }), o) {
        var l = this.gridOptionsWrapper.getNavigateToNextCellFunc();
        if (ge(l)) {
          var u = {
            key: i,
            previousCellPosition: r,
            nextCellPosition: s || null,
            event: t,
            api: this.gridOptionsWrapper.getApi(),
            columnApi: this.gridOptionsWrapper.getColumnApi()
          }, c = l(u);
          ge(c) ? (c.floating && (mi(function() {
            console.warn("AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?");
          }, "no floating in userCell"), c.rowPinned = c.floating), s = {
            rowPinned: c.rowPinned,
            rowIndex: c.rowIndex,
            column: c.column
          }) : s = null;
        }
      }
      if (s) {
        if (s.rowIndex < 0) {
          var h = this.headerNavigationService.getHeaderRowCount();
          this.focusService.focusHeaderPosition({
            headerPosition: { headerRowIndex: h + s.rowIndex, column: r.column },
            event: t || void 0
          });
          return;
        }
        var d = this.getNormalisedPosition(s);
        d ? this.focusPosition(d) : this.tryToFocusFullWidthRow(s);
      }
    }, e.prototype.getNormalisedPosition = function(t) {
      this.ensureCellVisible(t);
      var i = this.getCellByPosition(t);
      return i ? (t = i.getCellPosition(), this.ensureCellVisible(t), t) : null;
    }, e.prototype.tryToFocusFullWidthRow = function(t, i) {
      i === void 0 && (i = !1);
      var r = this.columnModel.getAllDisplayedColumns(), o = this.rowRenderer.getRowByPosition(t);
      if (!o || !o.isFullWidth())
        return !1;
      var s = {
        rowIndex: t.rowIndex,
        rowPinned: t.rowPinned,
        column: t.column || (i ? Ti(r) : r[0])
      };
      return this.focusPosition(s), !0;
    }, e.prototype.focusPosition = function(t) {
      this.focusService.setFocusedCell(t.rowIndex, t.column, t.rowPinned, !0), this.rangeService && this.rangeService.setRangeToCell(t);
    }, e.prototype.isValidNavigateCell = function(t) {
      var i = this.rowPositionUtils.getRowNode(t);
      return !!i;
    }, e.prototype.getLastCellOfColSpan = function(t) {
      var i = this.getCellByPosition(t);
      if (!i)
        return t;
      var r = i.getColSpanningList();
      return r.length === 1 ? t : {
        rowIndex: t.rowIndex,
        column: Ti(r),
        rowPinned: t.rowPinned
      };
    }, e.prototype.ensureCellVisible = function(t) {
      Je(t.rowPinned) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(t.rowIndex), t.column.isPinned() || this.gridBodyCon.getScrollFeature().ensureColumnVisible(t.column), this.gridBodyCon.getScrollFeature().horizontallyScrollHeaderCenterAndFloatingCenter(), this.animationFrameService.flushAllFrames();
    }, Mo([
      T("mouseEventService")
    ], e.prototype, "mouseEventService", void 0), Mo([
      T("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), Mo([
      T("focusService")
    ], e.prototype, "focusService", void 0), Mo([
      T("animationFrameService")
    ], e.prototype, "animationFrameService", void 0), Mo([
      fi("rangeService")
    ], e.prototype, "rangeService", void 0), Mo([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), Mo([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), Mo([
      T("rowRenderer")
    ], e.prototype, "rowRenderer", void 0), Mo([
      T("headerNavigationService")
    ], e.prototype, "headerNavigationService", void 0), Mo([
      T("rowPositionUtils")
    ], e.prototype, "rowPositionUtils", void 0), Mo([
      T("cellNavigationService")
    ], e.prototype, "cellNavigationService", void 0), Mo([
      T("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), Mo([
      Le
    ], e.prototype, "postConstruct", null), e = Mo([
      qe("navigationService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var iQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), KC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, nQ = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, rQ = (
  /** @class */
  function(n) {
    iQ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.scrollY = 0, t.uiBodyHeight = 0, t;
    }
    return e.prototype.agWire = function(t) {
      this.logger = t.create("RowContainerHeightService");
    }, e.prototype.postConstruct = function() {
      this.addManagedListener(this.eventService, F.EVENT_BODY_HEIGHT_CHANGED, this.updateOffset.bind(this)), this.maxDivHeight = BB(), this.logger.log("maxDivHeight = " + this.maxDivHeight);
    }, e.prototype.isStretching = function() {
      return this.stretching;
    }, e.prototype.getDivStretchOffset = function() {
      return this.divStretchOffset;
    }, e.prototype.updateOffset = function() {
      if (this.stretching) {
        var t = this.ctrlsService.getGridBodyCtrl(), i = t.getScrollFeature().getVScrollPosition().top, r = this.getUiBodyHeight(), o = i !== this.scrollY || r !== this.uiBodyHeight;
        o && (this.scrollY = i, this.uiBodyHeight = r, this.calculateOffset());
      }
    }, e.prototype.calculateOffset = function() {
      this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
      var t = this.scrollY / this.maxScrollY, i = t * this.pixelsToShave;
      this.logger.log("Div Stretch Offset = " + i + " (" + this.pixelsToShave + " * " + t + ")"), this.setDivStretchOffset(i);
    }, e.prototype.setUiContainerHeight = function(t) {
      t !== this.uiContainerHeight && (this.uiContainerHeight = t, this.eventService.dispatchEvent({ type: F.EVENT_ROW_CONTAINER_HEIGHT_CHANGED }));
    }, e.prototype.clearOffset = function() {
      this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0);
    }, e.prototype.setDivStretchOffset = function(t) {
      var i = typeof t == "number" ? Math.floor(t) : null;
      this.divStretchOffset !== i && (this.divStretchOffset = i, this.eventService.dispatchEvent({ type: F.EVENT_HEIGHT_SCALE_CHANGED }));
    }, e.prototype.setModelHeight = function(t) {
      this.modelHeight = t, this.stretching = t != null && this.maxDivHeight > 0 && t > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset();
    }, e.prototype.getUiContainerHeight = function() {
      return this.uiContainerHeight;
    }, e.prototype.getRealPixelPosition = function(t) {
      return t - this.divStretchOffset;
    }, e.prototype.getUiBodyHeight = function() {
      var t = this.ctrlsService.getGridBodyCtrl(), i = t.getScrollFeature().getVScrollPosition();
      return i.bottom - i.top;
    }, e.prototype.getScrollPositionForPixel = function(t) {
      if (this.pixelsToShave <= 0)
        return t;
      var i = this.modelHeight - this.getUiBodyHeight(), r = t / i, o = this.maxScrollY * r;
      return o;
    }, KC([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), KC([
      nQ(0, Eo("loggerFactory"))
    ], e.prototype, "agWire", null), KC([
      Le
    ], e.prototype, "postConstruct", null), e = KC([
      qe("rowContainerHeightService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var oQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _F = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, A4 = (
  /** @class */
  function(n) {
    oQ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      this.groupSelectsChildren = this.gridOptionsWrapper.isGroupSelectsChildren(), this.isRowSelectableFunc = this.gridOptionsWrapper.getIsRowSelectableFunc();
    }, e.prototype.updateSelectableAfterGrouping = function(t) {
      if (this.isRowSelectableFunc) {
        var i = function(r) {
          return r.childrenAfterGroup;
        };
        this.recurseDown(t.childrenAfterGroup, i);
      }
    }, e.prototype.updateSelectableAfterFiltering = function(t) {
      if (this.isRowSelectableFunc) {
        var i = function(r) {
          return r.childrenAfterFilter;
        };
        this.recurseDown(t.childrenAfterGroup, i);
      }
    }, e.prototype.recurseDown = function(t, i) {
      var r = this;
      t && t.forEach(function(o) {
        if (o.group) {
          o.hasChildren() && r.recurseDown(i(o), i);
          var s;
          if (r.groupSelectsChildren) {
            var a = (i(o) || []).find(function(l) {
              return l.selectable === !0;
            });
            s = ge(a);
          } else
            s = r.isRowSelectableFunc ? r.isRowSelectableFunc(o) : !1;
          o.setRowSelectable(s);
        }
      });
    }, _F([
      Le
    ], e.prototype, "init", null), e = _F([
      qe("selectableService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var sQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Js = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, aQ = (
  /** @class */
  function(n) {
    sQ(e, n);
    function e() {
      var t = n.call(this) || this;
      return t.previousAndFirstButtonsDisabled = !1, t.nextButtonDisabled = !1, t.lastButtonDisabled = !1, t;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.gridOptionsWrapper.isEnableRtl();
      this.setTemplate(this.getTemplate()), this.btFirst.insertAdjacentElement("afterbegin", Yn(i ? "last" : "first", this.gridOptionsWrapper)), this.btPrevious.insertAdjacentElement("afterbegin", Yn(i ? "next" : "previous", this.gridOptionsWrapper)), this.btNext.insertAdjacentElement("afterbegin", Yn(i ? "previous" : "next", this.gridOptionsWrapper)), this.btLast.insertAdjacentElement("afterbegin", Yn(i ? "first" : "last", this.gridOptionsWrapper));
      var r = this.gridOptionsWrapper.isPagination(), o = r && !this.gridOptionsWrapper.isSuppressPaginationPanel();
      if (!o) {
        this.setDisplayed(!1);
        return;
      }
      this.addManagedListener(this.eventService, F.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this)), [
        { el: this.btFirst, fn: this.onBtFirst.bind(this) },
        { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
        { el: this.btNext, fn: this.onBtNext.bind(this) },
        { el: this.btLast, fn: this.onBtLast.bind(this) }
      ].forEach(function(s) {
        var a = s.el, l = s.fn;
        t.addManagedListener(a, "click", l), t.addManagedListener(a, "keydown", function(u) {
          (u.key === _e.ENTER || u.key === _e.SPACE) && (u.preventDefault(), l());
        });
      }), this.onPaginationChanged();
    }, e.prototype.onPaginationChanged = function() {
      this.enableOrDisableButtons(), this.updateRowLabels(), this.setCurrentPageLabel(), this.setTotalLabels();
    }, e.prototype.onBtFirst = function() {
      this.previousAndFirstButtonsDisabled || this.paginationProxy.goToFirstPage();
    }, e.prototype.setCurrentPageLabel = function() {
      var t = this.paginationProxy.getTotalPages() > 0, i = this.paginationProxy.getCurrentPage(), r = t ? i + 1 : 0;
      this.lbCurrent.innerHTML = this.formatNumber(r);
    }, e.prototype.formatNumber = function(t) {
      var i = this.gridOptionsWrapper.getPaginationNumberFormatterFunc();
      if (i)
        return i({ value: t });
      var r = this.gridOptionsWrapper.getLocaleTextFunc(), o = r("thousandSeparator", ","), s = r("decimalSeparator", ".");
      return Nx(t, o, s);
    }, e.prototype.getTemplate = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = t("page", "Page"), r = t("to", "to"), o = t("of", "of"), s = t("firstPage", "First Page"), a = t("previousPage", "Previous Page"), l = t("nextPage", "Next Page"), u = t("lastPage", "Last Page"), c = this.getCompId();
      return (
        /* html */
        '<div class="ag-paging-panel ag-unselectable" id="ag-' + c + `">
                <span class="ag-paging-row-summary-panel" role="status">
                    <span id="ag-` + c + `-first-row" ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-` + c + '-to">' + r + `</span>
                    <span id="ag-` + c + `-last-row" ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-` + c + '-of">' + o + `</span>
                    <span id="ag-` + c + `-row-count" ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div ref="btFirst" class="ag-paging-button" role="button" aria-label="` + s + `" tabindex="0"></div>
                    <div ref="btPrevious" class="ag-paging-button" role="button" aria-label="` + a + `" tabindex="0"></div>
                    <span class="ag-paging-description" role="status">
                        <span id="ag-` + c + '-start-page">' + i + `</span>
                        <span id="ag-` + c + `-start-page-number" ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-` + c + '-of-page">' + o + `</span>
                        <span id="ag-` + c + `-of-page-number" ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div ref="btNext" class="ag-paging-button" role="button" aria-label="` + l + `" tabindex="0"></div>
                    <div ref="btLast" class="ag-paging-button" role="button" aria-label="` + u + `" tabindex="0"></div>
                </span>
            </div>`
      );
    }, e.prototype.onBtNext = function() {
      this.nextButtonDisabled || this.paginationProxy.goToNextPage();
    }, e.prototype.onBtPrevious = function() {
      this.previousAndFirstButtonsDisabled || this.paginationProxy.goToPreviousPage();
    }, e.prototype.onBtLast = function() {
      this.lastButtonDisabled || this.paginationProxy.goToLastPage();
    }, e.prototype.enableOrDisableButtons = function() {
      var t = this.paginationProxy.getCurrentPage(), i = this.paginationProxy.isLastPageFound(), r = this.paginationProxy.getTotalPages();
      this.previousAndFirstButtonsDisabled = t === 0, this.btFirst.classList.toggle("ag-disabled", this.previousAndFirstButtonsDisabled), ep(this.btFirst, this.previousAndFirstButtonsDisabled), this.btPrevious.classList.toggle("ag-disabled", this.previousAndFirstButtonsDisabled), ep(this.btPrevious, this.previousAndFirstButtonsDisabled);
      var o = this.isZeroPagesToDisplay(), s = i && t === r - 1;
      this.nextButtonDisabled = s || o, this.btNext.classList.toggle("ag-disabled", this.nextButtonDisabled), ep(this.btNext, this.nextButtonDisabled), this.lastButtonDisabled = !i || o || t === r - 1, this.btLast.classList.toggle("ag-disabled", this.lastButtonDisabled), ep(this.btLast, this.lastButtonDisabled);
    }, e.prototype.updateRowLabels = function() {
      var t = this.paginationProxy.getCurrentPage(), i = this.paginationProxy.getPageSize(), r = this.paginationProxy.isLastPageFound(), o = this.paginationProxy.isLastPageFound() ? this.paginationProxy.getMasterRowCount() : null, s, a;
      this.isZeroPagesToDisplay() ? s = a = 0 : (s = i * t + 1, a = s + i - 1, r && a > o && (a = o)), this.lbFirstRowOnPage.innerHTML = this.formatNumber(s), this.rowNodeBlockLoader.isLoading() ? this.lbLastRowOnPage.innerHTML = "?" : this.lbLastRowOnPage.innerHTML = this.formatNumber(a);
    }, e.prototype.isZeroPagesToDisplay = function() {
      var t = this.paginationProxy.isLastPageFound(), i = this.paginationProxy.getTotalPages();
      return t && i === 0;
    }, e.prototype.setTotalLabels = function() {
      var t = this.paginationProxy.isLastPageFound(), i = this.paginationProxy.getTotalPages(), r = t ? this.paginationProxy.getMasterRowCount() : null;
      if (r === 1) {
        var o = this.paginationProxy.getRow(0), s = o && o.group && !(o.groupData || o.aggData);
        if (s) {
          this.setTotalLabelsToZero();
          return;
        }
      }
      if (t)
        this.lbTotal.innerHTML = this.formatNumber(i), this.lbRecordCount.innerHTML = this.formatNumber(r);
      else {
        var a = this.gridOptionsWrapper.getLocaleTextFunc()("more", "more");
        this.lbTotal.innerHTML = a, this.lbRecordCount.innerHTML = a;
      }
    }, e.prototype.setTotalLabelsToZero = function() {
      this.lbFirstRowOnPage.innerHTML = this.formatNumber(0), this.lbCurrent.innerHTML = this.formatNumber(0), this.lbLastRowOnPage.innerHTML = this.formatNumber(0), this.lbTotal.innerHTML = this.formatNumber(0), this.lbRecordCount.innerHTML = this.formatNumber(0);
    }, Js([
      T("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), Js([
      T("rowNodeBlockLoader")
    ], e.prototype, "rowNodeBlockLoader", void 0), Js([
      ve("btFirst")
    ], e.prototype, "btFirst", void 0), Js([
      ve("btPrevious")
    ], e.prototype, "btPrevious", void 0), Js([
      ve("btNext")
    ], e.prototype, "btNext", void 0), Js([
      ve("btLast")
    ], e.prototype, "btLast", void 0), Js([
      ve("lbRecordCount")
    ], e.prototype, "lbRecordCount", void 0), Js([
      ve("lbFirstRowOnPage")
    ], e.prototype, "lbFirstRowOnPage", void 0), Js([
      ve("lbLastRowOnPage")
    ], e.prototype, "lbLastRowOnPage", void 0), Js([
      ve("lbCurrent")
    ], e.prototype, "lbCurrent", void 0), Js([
      ve("lbTotal")
    ], e.prototype, "lbTotal", void 0), Js([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var lQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), uQ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, CF = 50, M4 = (
  /** @class */
  function(n) {
    lQ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.polyfillFunctions = [], t;
    }
    return e.prototype.observeResize = function(t, i) {
      var r = this, o = this.gridOptionsWrapper.getDocument(), s = o.defaultView || window, a = lh(i, CF), l = function() {
        var d = new s.ResizeObserver(a);
        return d.observe(t), function() {
          return d.disconnect();
        };
      }, u = function() {
        var d = K1(t), f = $1(t), p = !0, g = function() {
          if (p) {
            var _ = K1(t), m = $1(t), v = _ !== d || m !== f;
            v && (d = _, f = m, i()), r.doNextPolyfillTurn(g);
          }
        };
        return g(), function() {
          return p = !1;
        };
      }, c = this.gridOptionsWrapper.isSuppressBrowserResizeObserver(), h = !!s.ResizeObserver;
      return h && !c ? l() : u();
    }, e.prototype.doNextPolyfillTurn = function(t) {
      this.polyfillFunctions.push(t), this.schedulePolyfill();
    }, e.prototype.schedulePolyfill = function() {
      var t = this;
      if (!this.polyfillScheduled) {
        var i = function() {
          var r = t.polyfillFunctions;
          t.polyfillScheduled = !1, t.polyfillFunctions = [], r.forEach(function(o) {
            return o();
          });
        };
        this.polyfillScheduled = !0, this.getFrameworkOverrides().setTimeout(i, CF);
      }
    }, e = uQ([
      qe("resizeObserverService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var cQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), xf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, tp;
(function(n) {
  n[n.Loading = 0] = "Loading", n[n.NoRows = 1] = "NoRows";
})(tp || (tp = {}));
var hQ = (
  /** @class */
  function(n) {
    cQ(e, n);
    function e() {
      var t = n.call(this, e.TEMPLATE) || this;
      return t.inProgress = !1, t.destroyRequested = !1, t;
    }
    return e.prototype.updateLayoutClasses = function(t, i) {
      var r = this.eOverlayWrapper.classList;
      r.toggle(Wn.AUTO_HEIGHT, i.autoHeight), r.toggle(Wn.NORMAL, i.normal), r.toggle(Wn.PRINT, i.print);
    }, e.prototype.postConstruct = function() {
      this.createManagedBean(new Kx(this)), this.setDisplayed(!1), this.addManagedListener(this.eventService, F.EVENT_ROW_DATA_CHANGED, this.onRowDataChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_ROW_DATA_UPDATED, this.onRowDataChanged.bind(this)), this.addManagedListener(this.eventService, F.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this)), this.gridOptionsWrapper.isRowModelDefault() && !this.gridOptionsWrapper.getRowData() && this.showLoadingOverlay(), this.gridApi.registerOverlayWrapperComp(this);
    }, e.prototype.setWrapperTypeClass = function(t) {
      var i = this.eOverlayWrapper.classList;
      i.toggle("ag-overlay-loading-wrapper", t === tp.Loading), i.toggle("ag-overlay-no-rows-wrapper", t === tp.NoRows);
    }, e.prototype.showLoadingOverlay = function() {
      if (!this.gridOptionsWrapper.isSuppressLoadingOverlay()) {
        var t = {
          api: this.gridOptionsWrapper.getApi()
        }, i = this.userComponentFactory.getLoadingOverlayCompDetails(t), r = i.newAgStackInstance();
        this.showOverlay(r, tp.Loading);
      }
    }, e.prototype.showNoRowsOverlay = function() {
      if (!this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {
        var t = {
          api: this.gridOptionsWrapper.getApi()
        }, i = this.userComponentFactory.getNoRowsOverlayCompDetails(t), r = i.newAgStackInstance();
        this.showOverlay(r, tp.NoRows);
      }
    }, e.prototype.showOverlay = function(t, i) {
      var r = this;
      this.inProgress || (this.setWrapperTypeClass(i), this.destroyActiveOverlay(), this.inProgress = !0, t && t.then(function(o) {
        r.inProgress = !1, r.eOverlayWrapper.appendChild(o.getGui()), r.activeOverlay = o, r.destroyRequested && (r.destroyRequested = !1, r.destroyActiveOverlay());
      }), this.setDisplayed(!0));
    }, e.prototype.destroyActiveOverlay = function() {
      if (this.inProgress) {
        this.destroyRequested = !0;
        return;
      }
      this.activeOverlay && (this.activeOverlay = this.getContext().destroyBean(this.activeOverlay), Ls(this.eOverlayWrapper));
    }, e.prototype.hideOverlay = function() {
      this.destroyActiveOverlay(), this.setDisplayed(!1);
    }, e.prototype.destroy = function() {
      this.destroyActiveOverlay(), n.prototype.destroy.call(this);
    }, e.prototype.showOrHideOverlay = function() {
      var t = this.paginationProxy.isEmpty(), i = this.gridOptionsWrapper.isSuppressNoRowsOverlay();
      t && !i ? this.showNoRowsOverlay() : this.hideOverlay();
    }, e.prototype.onRowDataChanged = function() {
      this.showOrHideOverlay();
    }, e.prototype.onNewColumnsLoaded = function() {
      this.columnModel.isReady() && !this.paginationProxy.isEmpty() && this.hideOverlay();
    }, e.TEMPLATE = `
        <div class="ag-overlay" aria-hidden="true">
            <div class="ag-overlay-panel">
                <div class="ag-overlay-wrapper" ref="eOverlayWrapper"></div>
            </div>
        </div>`, xf([
      T("userComponentFactory")
    ], e.prototype, "userComponentFactory", void 0), xf([
      T("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), xf([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), xf([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), xf([
      ve("eOverlayWrapper")
    ], e.prototype, "eOverlayWrapper", void 0), xf([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var dQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Sc = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, F4 = (
  /** @class */
  function(n) {
    dQ(e, n);
    function e(t) {
      t === void 0 && (t = {});
      var i = n.call(this, e.getTemplate(t)) || this;
      i.suppressEnabledCheckbox = !0, i.suppressOpenCloseIcons = !1;
      var r = t.title, o = t.enabled, s = t.items, a = t.suppressEnabledCheckbox, l = t.suppressOpenCloseIcons;
      return i.title = r, i.cssIdentifier = t.cssIdentifier || "default", i.enabled = o ?? !0, i.items = s || [], i.alignItems = t.alignItems || "center", a != null && (i.suppressEnabledCheckbox = a), l != null && (i.suppressOpenCloseIcons = l), i;
    }
    return e.getTemplate = function(t) {
      var i = t.cssIdentifier || "default", r = t.direction || "vertical";
      return (
        /* html */
        '<div class="ag-group ag-' + i + `-group" role="presentation">
            <div class="ag-group-title-bar ag-` + i + `-group-title-bar ag-unselectable" ref="eTitleBar" role="button">
                <span class="ag-group-title-bar-icon ag-` + i + `-group-title-bar-icon" ref="eGroupOpenedIcon" role="presentation"></span>
                <span class="ag-group-title-bar-icon ag-` + i + `-group-title-bar-icon" ref="eGroupClosedIcon" role="presentation"></span>
                <span ref="eTitle" class="ag-group-title ag-` + i + `-group-title"></span>
            </div>
            <div ref="eToolbar" class="ag-group-toolbar ag-` + i + `-group-toolbar">
                <ag-checkbox ref="cbGroupEnabled"></ag-checkbox>
            </div>
            <div ref="eContainer" class="ag-group-container ag-group-container-` + r + " ag-" + i + `-group-container"></div>
        </div>`
      );
    }, e.prototype.postConstruct = function() {
      if (this.items.length) {
        var t = this.items;
        this.items = [], this.addItems(t);
      }
      var i = this.gridOptionsWrapper.getLocaleTextFunc();
      this.cbGroupEnabled.setLabel(i("enabled", "Enabled")), this.title && this.setTitle(this.title), this.enabled && this.setEnabled(this.enabled), this.setAlignItems(this.alignItems), this.hideEnabledCheckbox(this.suppressEnabledCheckbox), this.hideOpenCloseIcons(this.suppressOpenCloseIcons), this.setupExpandContract(), this.refreshAriaStatus(), this.refreshChildDisplay();
    }, e.prototype.setupExpandContract = function() {
      var t = this;
      this.eGroupClosedIcon.appendChild(ra("columnSelectClosed", this.gridOptionsWrapper, null)), this.eGroupOpenedIcon.appendChild(ra("columnSelectOpen", this.gridOptionsWrapper, null)), this.addManagedListener(this.eTitleBar, "click", function() {
        return t.toggleGroupExpand();
      }), this.addManagedListener(this.eTitleBar, "keydown", function(i) {
        switch (i.key) {
          case _e.ENTER:
          case _e.SPACE:
            i.preventDefault(), t.toggleGroupExpand();
            break;
          case _e.RIGHT:
          case _e.LEFT:
            i.preventDefault(), t.toggleGroupExpand(i.key === _e.RIGHT);
            break;
        }
      });
    }, e.prototype.refreshAriaStatus = function() {
      this.suppressOpenCloseIcons || bs(this.eTitleBar, this.expanded);
    }, e.prototype.refreshChildDisplay = function() {
      var t = !this.suppressOpenCloseIcons;
      Bi(this.eToolbar, this.expanded && !this.suppressEnabledCheckbox), Bi(this.eGroupOpenedIcon, t && this.expanded), Bi(this.eGroupClosedIcon, t && !this.expanded);
    }, e.prototype.isExpanded = function() {
      return this.expanded;
    }, e.prototype.setAlignItems = function(t) {
      this.alignItems !== t && this.removeCssClass("ag-group-item-alignment-" + this.alignItems), this.alignItems = t;
      var i = "ag-group-item-alignment-" + this.alignItems;
      return this.addCssClass(i), this;
    }, e.prototype.toggleGroupExpand = function(t) {
      return this.suppressOpenCloseIcons ? (this.expanded = !0, this.refreshChildDisplay(), Bi(this.eContainer, !0), this) : (t = t ?? !this.expanded, this.expanded === t ? this : (this.expanded = t, this.refreshAriaStatus(), this.refreshChildDisplay(), Bi(this.eContainer, t), this.dispatchEvent({ type: this.expanded ? e.EVENT_EXPANDED : e.EVENT_COLLAPSED }), this));
    }, e.prototype.addItems = function(t) {
      var i = this;
      t.forEach(function(r) {
        return i.addItem(r);
      });
    }, e.prototype.addItem = function(t) {
      var i = this.eContainer, r = t instanceof Et ? t.getGui() : t;
      r.classList.add("ag-group-item", "ag-" + this.cssIdentifier + "-group-item"), i.appendChild(r), this.items.push(r);
    }, e.prototype.hideItem = function(t, i) {
      var r = this.items[i];
      r.classList.toggle("ag-hidden", t);
    }, e.prototype.setTitle = function(t) {
      return this.eTitle.innerText = t, this;
    }, e.prototype.addCssClassToTitleBar = function(t) {
      this.eTitleBar.classList.add(t);
    }, e.prototype.setEnabled = function(t, i) {
      return this.enabled = t, this.refreshDisabledStyles(), this.toggleGroupExpand(t), i || this.cbGroupEnabled.setValue(t), this;
    }, e.prototype.isEnabled = function() {
      return this.enabled;
    }, e.prototype.onEnableChange = function(t) {
      var i = this;
      return this.cbGroupEnabled.onValueChange(function(r) {
        i.setEnabled(r, !0), t(r);
      }), this;
    }, e.prototype.hideEnabledCheckbox = function(t) {
      return this.suppressEnabledCheckbox = t, this.refreshChildDisplay(), this.refreshDisabledStyles(), this;
    }, e.prototype.hideOpenCloseIcons = function(t) {
      return this.suppressOpenCloseIcons = t, t && this.toggleGroupExpand(!0), this;
    }, e.prototype.refreshDisabledStyles = function() {
      this.addOrRemoveCssClass("ag-disabled", !this.enabled), this.suppressEnabledCheckbox && !this.enabled ? (this.eTitleBar.classList.add("ag-disabled-group-title-bar"), this.eTitleBar.removeAttribute("tabindex")) : (this.eTitleBar.classList.remove("ag-disabled-group-title-bar"), this.eTitleBar.setAttribute("tabindex", "0")), this.eContainer.classList.toggle("ag-disabled-group-container", !this.enabled);
    }, e.EVENT_EXPANDED = "expanded", e.EVENT_COLLAPSED = "collapsed", Sc([
      ve("eTitleBar")
    ], e.prototype, "eTitleBar", void 0), Sc([
      ve("eGroupOpenedIcon")
    ], e.prototype, "eGroupOpenedIcon", void 0), Sc([
      ve("eGroupClosedIcon")
    ], e.prototype, "eGroupClosedIcon", void 0), Sc([
      ve("eToolbar")
    ], e.prototype, "eToolbar", void 0), Sc([
      ve("cbGroupEnabled")
    ], e.prototype, "cbGroupEnabled", void 0), Sc([
      ve("eTitle")
    ], e.prototype, "eTitle", void 0), Sc([
      ve("eContainer")
    ], e.prototype, "eContainer", void 0), Sc([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var fQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), yF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, k4 = "ag-resizer-wrapper", pQ = (
  /* html */
  '<div class="' + k4 + `">
        <div ref="eTopLeftResizer" class="ag-resizer ag-resizer-topLeft"></div>
        <div ref="eTopResizer" class="ag-resizer ag-resizer-top"></div>
        <div ref="eTopRightResizer" class="ag-resizer ag-resizer-topRight"></div>
        <div ref="eRightResizer" class="ag-resizer ag-resizer-right"></div>
        <div ref="eBottomRightResizer" class="ag-resizer ag-resizer-bottomRight"></div>
        <div ref="eBottomResizer" class="ag-resizer ag-resizer-bottom"></div>
        <div ref="eBottomLeftResizer" class="ag-resizer ag-resizer-bottomLeft"></div>
        <div ref="eLeftResizer" class="ag-resizer ag-resizer-left"></div>
    </div>`
), W4 = (
  /** @class */
  function(n) {
    fQ(e, n);
    function e(t, i) {
      var r = n.call(this) || this;
      return r.element = t, r.dragStartPosition = {
        x: 0,
        y: 0
      }, r.position = {
        x: 0,
        y: 0
      }, r.lastSize = {
        width: -1,
        height: -1
      }, r.positioned = !1, r.resizersAdded = !1, r.resizeListeners = [], r.boundaryEl = null, r.isResizing = !1, r.isMoving = !1, r.resizable = {}, r.movable = !1, r.currentResizer = null, r.config = Object.assign({}, { popup: !1 }, i), r;
    }
    return e.prototype.center = function() {
      var t = this.offsetParent, i = t.clientHeight, r = t.clientWidth, o = r / 2 - this.getWidth() / 2, s = i / 2 - this.getHeight() / 2;
      this.offsetElement(o, s);
    }, e.prototype.initialisePosition = function() {
      var t = this.config, i = t.centered, r = t.forcePopupParentAsOffsetParent, o = t.minWidth, s = t.width, a = t.minHeight, l = t.height, u = t.x, c = t.y;
      this.offsetParent || this.setOffsetParent();
      var h = 0, d = 0, f = !!this.element.offsetParent;
      if (f) {
        var p = this.findBoundaryElement(), g = window.getComputedStyle(p);
        if (g.minWidth != null) {
          var _ = p.offsetWidth - this.element.offsetWidth;
          d = parseInt(g.minWidth, 10) - _;
        }
        if (g.minHeight != null) {
          var m = p.offsetHeight - this.element.offsetHeight;
          h = parseInt(g.minHeight, 10) - m;
        }
      }
      if (this.minHeight = a || h, this.minWidth = o || d, s && this.setWidth(s), l && this.setHeight(l), (!s || !l) && this.refreshSize(), i)
        this.center();
      else if (u || c)
        this.offsetElement(u, c);
      else if (f && r && this.boundaryEl) {
        var v = parseFloat(this.boundaryEl.style.top), C = parseFloat(this.boundaryEl.style.left);
        this.offsetElement(isNaN(C) ? 0 : C, isNaN(v) ? 0 : v);
      }
      this.positioned = !!this.offsetParent;
    }, e.prototype.isPositioned = function() {
      return this.positioned;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.setMovable = function(t, i) {
      if (!(!this.config.popup || t === this.movable)) {
        this.movable = t;
        var r = this.moveElementDragListener || {
          eElement: i,
          onDragStart: this.onMoveStart.bind(this),
          onDragging: this.onMove.bind(this),
          onDragStop: this.onMoveEnd.bind(this)
        };
        t ? (this.dragService.addDragSource(r), this.moveElementDragListener = r) : (this.dragService.removeDragSource(r), this.moveElementDragListener = void 0);
      }
    }, e.prototype.setResizable = function(t) {
      var i = this;
      if (this.clearResizeListeners(), t ? this.addResizers() : this.removeResizers(), typeof t == "boolean") {
        if (t === !1)
          return;
        t = {
          topLeft: t,
          top: t,
          topRight: t,
          right: t,
          bottomRight: t,
          bottom: t,
          bottomLeft: t,
          left: t
        };
      }
      Object.keys(t).forEach(function(r) {
        var o = t, s = !!o[r], a = i.getResizerElement(r), l = {
          dragStartPixels: 0,
          eElement: a,
          onDragStart: function(u) {
            return i.onResizeStart(u, r);
          },
          onDragging: i.onResize.bind(i),
          onDragStop: function(u) {
            return i.onResizeEnd(u, r);
          }
        };
        (!!i.resizable[r] !== s || !i.isAlive() && !s) && (s ? (i.dragService.addDragSource(l), i.resizeListeners.push(l), a.style.pointerEvents = "all") : a.style.pointerEvents = "none");
      });
    }, e.prototype.removeSizeFromEl = function() {
      this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex");
    }, e.prototype.restoreLastSize = function() {
      this.element.style.flex = "0 0 auto";
      var t = this.lastSize, i = t.height, r = t.width;
      r !== -1 && (this.element.style.width = r + "px"), i !== -1 && (this.element.style.height = i + "px");
    }, e.prototype.getHeight = function() {
      return this.element.offsetHeight;
    }, e.prototype.setHeight = function(t) {
      var i = this.config.popup, r = this.element, o = !1;
      if (typeof t == "string" && t.indexOf("%") !== -1)
        yd(r, t), t = yx(r), o = !0;
      else if (this.positioned) {
        var s = this.element.getBoundingClientRect(), a = this.offsetParent.getBoundingClientRect();
        t = Math.max(this.minHeight, t);
        var l = this.offsetParent.clientHeight, u = i ? this.position.y : s.top, c = i ? 0 : a.top;
        l && t + u > l + c && (t = l - u);
      }
      this.getHeight() !== t && (o ? (r.style.maxHeight = "unset", r.style.minHeight = "unset") : i ? yd(r, t) : (r.style.height = t + "px", r.style.flex = "0 0 auto", this.lastSize.height = typeof t == "number" ? t : parseFloat(t)));
    }, e.prototype.getWidth = function() {
      return this.element.offsetWidth;
    }, e.prototype.setWidth = function(t) {
      var i = this.element, r = this.config.popup, o = !1;
      if (typeof t == "string" && t.indexOf("%") !== -1)
        Yl(i, t), t = NS(i), o = !0;
      else if (this.positioned) {
        t = Math.max(this.minWidth, t);
        var s = this.offsetParent.clientWidth, a = r ? this.position.x : this.element.getBoundingClientRect().left;
        s && t + a > s && (t = s - a);
      }
      this.getWidth() !== t && (o ? (i.style.maxWidth = "unset", i.style.minWidth = "unset") : this.config.popup ? Yl(i, t) : (i.style.width = t + "px", i.style.flex = " unset", this.lastSize.width = typeof t == "number" ? t : parseFloat(t)));
    }, e.prototype.offsetElement = function(t, i) {
      t === void 0 && (t = 0), i === void 0 && (i = 0);
      var r = this.config.forcePopupParentAsOffsetParent ? this.boundaryEl : this.element;
      this.popupService.positionPopup({
        ePopup: r,
        x: t,
        y: i,
        keepWithinBounds: !0
      }), this.setPosition(parseFloat(r.style.left), parseFloat(r.style.top));
    }, e.prototype.setPosition = function(t, i) {
      this.position.x = t, this.position.y = i;
    }, e.prototype.updateDragStartPosition = function(t, i) {
      this.dragStartPosition = { x: t, y: i };
    }, e.prototype.calculateMouseMovement = function(t) {
      var i = t.e, r = t.isLeft, o = t.isTop, s = t.anywhereWithin, a = t.topBuffer, l = i.clientX - this.dragStartPosition.x, u = i.clientY - this.dragStartPosition.y, c = this.shouldSkipX(i, !!r, !!s, l) ? 0 : l, h = this.shouldSkipY(i, !!o, a, u) ? 0 : u;
      return { movementX: c, movementY: h };
    }, e.prototype.shouldSkipX = function(t, i, r, o) {
      var s = this.element.getBoundingClientRect(), a = this.offsetParent.getBoundingClientRect(), l = this.boundaryEl.getBoundingClientRect(), u = this.config.popup ? this.position.x : s.left, c = u <= 0 && a.left >= t.clientX || a.right <= t.clientX && a.right <= l.right;
      return c ? !0 : (i ? c = // skip if we are moving to the left and the cursor
      // is positioned to the right of the left side anchor
      o < 0 && t.clientX > u + a.left || // skip if we are moving to the right and the cursor
      // is positioned to the left of the dialog
      o > 0 && t.clientX < u + a.left : r ? c = o < 0 && t.clientX > l.right || o > 0 && t.clientX < u + a.left : c = // if the movement is bound to the right side of the dialog
      // we skip if we are moving to the left and the cursor
      // is to the right of the dialog
      o < 0 && t.clientX > l.right || // or skip if we are moving to the right and the cursor
      // is to the left of the right side anchor
      o > 0 && t.clientX < l.right, c);
    }, e.prototype.shouldSkipY = function(t, i, r, o) {
      r === void 0 && (r = 0);
      var s = this.element.getBoundingClientRect(), a = this.offsetParent.getBoundingClientRect(), l = this.boundaryEl.getBoundingClientRect(), u = this.config.popup ? this.position.y : s.top, c = u <= 0 && a.top >= t.clientY || a.bottom <= t.clientY && a.bottom <= l.bottom;
      return c ? !0 : (i ? c = // skip if we are moving to towards top and the cursor is
      // below the top anchor + topBuffer
      // note: topBuffer is used when moving the dialog using the title bar
      o < 0 && t.clientY > u + a.top + r || // skip if we are moving to the bottom and the cursor is
      // above the top anchor
      o > 0 && t.clientY < u + a.top : c = // skip if we are moving towards the top and the cursor
      // is below the bottom anchor
      o < 0 && t.clientY > l.bottom || // skip if we are moving towards the bottom and the cursor
      // is above the bottom anchor
      o > 0 && t.clientY < l.bottom, c);
    }, e.prototype.createResizeMap = function() {
      var t = this.element;
      this.resizerMap = {
        topLeft: { element: t.querySelector("[ref=eTopLeftResizer]") },
        top: { element: t.querySelector("[ref=eTopResizer]") },
        topRight: { element: t.querySelector("[ref=eTopRightResizer]") },
        right: { element: t.querySelector("[ref=eRightResizer]") },
        bottomRight: { element: t.querySelector("[ref=eBottomRightResizer]") },
        bottom: { element: t.querySelector("[ref=eBottomResizer]") },
        bottomLeft: { element: t.querySelector("[ref=eBottomLeftResizer]") },
        left: { element: t.querySelector("[ref=eLeftResizer]") }
      };
    }, e.prototype.addResizers = function() {
      if (!this.resizersAdded) {
        var t = this.element;
        if (t) {
          var i = new DOMParser(), r = i.parseFromString(pQ, "text/html").body;
          t.appendChild(r.firstChild), this.createResizeMap(), this.resizersAdded = !0;
        }
      }
    }, e.prototype.removeResizers = function() {
      this.resizerMap = void 0;
      var t = this.element.querySelector("." + k4);
      t && this.element.removeChild(t), this.resizersAdded = !1;
    }, e.prototype.getResizerElement = function(t) {
      return this.resizerMap[t].element;
    }, e.prototype.onResizeStart = function(t, i) {
      this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = {
        isTop: !!i.match(/top/i),
        isRight: !!i.match(/right/i),
        isBottom: !!i.match(/bottom/i),
        isLeft: !!i.match(/left/i)
      }, this.element.classList.add("ag-resizing"), this.resizerMap[i].element.classList.add("ag-active");
      var r = this.config, o = r.popup, s = r.forcePopupParentAsOffsetParent;
      !o && !s && this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = !0, this.updateDragStartPosition(t.clientX, t.clientY);
    }, e.prototype.getSiblings = function() {
      var t = this.element, i = t.parentElement;
      return i ? Array.prototype.slice.call(i.children).filter(function(r) {
        return !r.classList.contains("ag-hidden");
      }) : null;
    }, e.prototype.getMinSizeOfSiblings = function() {
      for (var t = this.getSiblings() || [], i = 0, r = 0, o = 0; o < t.length; o++) {
        var s = t[o], a = !!s.style.flex && s.style.flex !== "0 0 auto";
        if (s !== this.element) {
          var l = this.minHeight || 0, u = this.minWidth || 0;
          if (a) {
            var c = window.getComputedStyle(s);
            c.minHeight && (l = parseInt(c.minHeight, 10)), c.minWidth && (u = parseInt(c.minWidth, 10));
          } else
            l = s.offsetHeight, u = s.offsetWidth;
          i += l, r += u;
        }
      }
      return { height: i, width: r };
    }, e.prototype.applySizeToSiblings = function(t) {
      var i = null, r = this.getSiblings();
      if (r) {
        for (var o = 0; o < r.length; o++) {
          var s = r[o];
          s !== i && (t ? s.style.height = s.offsetHeight + "px" : s.style.width = s.offsetWidth + "px", s.style.flex = "0 0 auto", s === this.element && (i = r[o + 1]));
        }
        i && (i.style.removeProperty("height"), i.style.removeProperty("min-height"), i.style.removeProperty("max-height"), i.style.flex = "1 1 auto");
      }
    }, e.prototype.onResize = function(t) {
      if (!(!this.isResizing || !this.currentResizer)) {
        var i = this.config, r = i.popup, o = i.forcePopupParentAsOffsetParent, s = this.currentResizer, a = s.isTop, l = s.isRight, u = s.isBottom, c = s.isLeft, h = l || c, d = u || a, f = this.calculateMouseMovement({ e: t, isLeft: c, isTop: a }), p = f.movementX, g = f.movementY, _ = this.position.x, m = this.position.y, v = 0, C = 0;
        if (h && p) {
          var y = c ? -1 : 1, w = this.getWidth(), L = w + p * y, S = !1;
          c && (v = w - L, (_ + v <= 0 || L <= this.minWidth) && (S = !0, v = 0)), S || this.setWidth(L);
        }
        if (d && g) {
          var y = a ? -1 : 1, E = this.getHeight(), D = E + g * y, x = !1;
          a ? (C = E - D, (m + C <= 0 || D <= this.minHeight) && (x = !0, C = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && E < D && this.getMinSizeOfSiblings().height + D > this.element.parentElement.offsetHeight && (x = !0), x || this.setHeight(D);
        }
        this.updateDragStartPosition(t.clientX, t.clientY), ((r || o) && v || C) && this.offsetElement(_ + v, m + C);
      }
    }, e.prototype.onResizeEnd = function(t, i) {
      this.isResizing = !1, this.currentResizer = null, this.boundaryEl = null;
      var r = {
        type: "resize",
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi()
      };
      this.element.classList.remove("ag-resizing"), this.resizerMap[i].element.classList.remove("ag-active"), this.dispatchEvent(r);
    }, e.prototype.refreshSize = function() {
      var t = this.element;
      this.config.popup && (this.config.width || this.setWidth(t.offsetWidth), this.config.height || this.setHeight(t.offsetHeight));
    }, e.prototype.onMoveStart = function(t) {
      this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = !0, this.element.classList.add("ag-moving"), this.updateDragStartPosition(t.clientX, t.clientY);
    }, e.prototype.onMove = function(t) {
      if (this.isMoving) {
        var i = this.position, r = i.x, o = i.y, s;
        this.config.calculateTopBuffer && (s = this.config.calculateTopBuffer());
        var a = this.calculateMouseMovement({
          e: t,
          isTop: !0,
          anywhereWithin: !0,
          topBuffer: s
        }), l = a.movementX, u = a.movementY;
        this.offsetElement(r + l, o + u), this.updateDragStartPosition(t.clientX, t.clientY);
      }
    }, e.prototype.onMoveEnd = function() {
      this.isMoving = !1, this.boundaryEl = null, this.element.classList.remove("ag-moving");
    }, e.prototype.setOffsetParent = function() {
      this.config.forcePopupParentAsOffsetParent ? this.offsetParent = this.popupService.getPopupParent() : this.offsetParent = this.element.offsetParent;
    }, e.prototype.findBoundaryElement = function() {
      for (var t = this.element; t; ) {
        if (window.getComputedStyle(t).position !== "static")
          return t;
        t = t.parentElement;
      }
      return this.element;
    }, e.prototype.clearResizeListeners = function() {
      for (; this.resizeListeners.length; ) {
        var t = this.resizeListeners.pop();
        this.dragService.removeDragSource(t);
      }
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this), this.moveElementDragListener && this.dragService.removeDragSource(this.moveElementDragListener), this.clearResizeListeners(), this.removeResizers();
    }, yF([
      T("popupService")
    ], e.prototype, "popupService", void 0), yF([
      T("dragService")
    ], e.prototype, "dragService", void 0), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var gQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Rm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, qx = (
  /** @class */
  function(n) {
    gQ(e, n);
    function e(t) {
      var i = n.call(this, e.getTemplate(t)) || this;
      return i.closable = !0, i.config = t, i;
    }
    return e.getTemplate = function(t) {
      var i = t && t.cssIdentifier || "default";
      return (
        /* html */
        '<div class="ag-panel ag-' + i + `-panel" tabindex="-1">
            <div ref="eTitleBar" class="ag-panel-title-bar ag-` + i + `-panel-title-bar ag-unselectable">
                <span ref="eTitle" class="ag-panel-title-bar-title ag-` + i + `-panel-title-bar-title"></span>
                <div ref="eTitleBarButtons" class="ag-panel-title-bar-buttons ag-` + i + `-panel-title-bar-buttons"></div>
            </div>
            <div ref="eContentWrapper" class="ag-panel-content-wrapper ag-` + i + `-panel-content-wrapper"></div>
        </div>`
      );
    }, e.prototype.postConstruct = function() {
      var t = this, i = this.config, r = i.component, o = i.closable, s = i.hideTitleBar, a = i.title, l = i.minWidth, u = l === void 0 ? 250 : l, c = i.width, h = i.minHeight, d = h === void 0 ? 250 : h, f = i.height, p = i.centered, g = i.popup, _ = i.x, m = i.y;
      this.positionableFeature = new W4(this.getGui(), {
        minWidth: u,
        width: c,
        minHeight: d,
        height: f,
        centered: p,
        x: _,
        y: m,
        popup: g,
        calculateTopBuffer: function() {
          return t.positionableFeature.getHeight() - t.getBodyHeight();
        }
      }), this.createManagedBean(this.positionableFeature);
      var v = this.getGui();
      r && this.setBodyComponent(r), s ? this.eTitleBar.classList.add("ag-hidden") : (a && this.setTitle(a), this.setClosable(o ?? this.closable)), this.addManagedListener(this.eTitleBar, "mousedown", function(C) {
        var y = t.gridOptionsWrapper.getDocument();
        if (v.contains(C.relatedTarget) || v.contains(y.activeElement) || t.eTitleBarButtons.contains(C.target)) {
          C.preventDefault();
          return;
        }
        var w = t.eContentWrapper.querySelector("button, [href], input, select, textarea, [tabindex]");
        w && w.focus();
      }), !(g && this.positionableFeature.isPositioned()) && (this.renderComponent && this.renderComponent(), this.positionableFeature.initialisePosition(), this.eContentWrapper.style.height = "0");
    }, e.prototype.renderComponent = function() {
      var t = this, i = this.getGui();
      i.focus(), this.close = function() {
        i.parentElement.removeChild(i), t.destroy();
      };
    }, e.prototype.getHeight = function() {
      return this.positionableFeature.getHeight();
    }, e.prototype.setHeight = function(t) {
      this.positionableFeature.setHeight(t);
    }, e.prototype.getWidth = function() {
      return this.positionableFeature.getWidth();
    }, e.prototype.setWidth = function(t) {
      this.positionableFeature.setWidth(t);
    }, e.prototype.setClosable = function(t) {
      if (t !== this.closable && (this.closable = t), t) {
        var i = this.closeButtonComp = new Et(e.CLOSE_BTN_TEMPLATE);
        this.getContext().createBean(i);
        var r = i.getGui(), o = Yn("close", this.gridOptionsWrapper);
        o.classList.add("ag-panel-title-bar-button-icon"), r.appendChild(o), this.addTitleBarButton(i), i.addManagedListener(r, "click", this.onBtClose.bind(this));
      } else if (this.closeButtonComp) {
        var r = this.closeButtonComp.getGui();
        r.parentElement.removeChild(r), this.closeButtonComp = this.destroyBean(this.closeButtonComp);
      }
    }, e.prototype.setBodyComponent = function(t) {
      t.setParentComponent(this), this.eContentWrapper.appendChild(t.getGui());
    }, e.prototype.addTitleBarButton = function(t, i) {
      var r = this.eTitleBarButtons, o = r.children, s = o.length;
      i == null && (i = s), i = Math.max(0, Math.min(i, s)), t.addCssClass("ag-panel-title-bar-button");
      var a = t.getGui();
      i === 0 ? r.insertAdjacentElement("afterbegin", a) : i === s ? r.insertAdjacentElement("beforeend", a) : o[i - 1].insertAdjacentElement("afterend", a), t.setParentComponent(this);
    }, e.prototype.getBodyHeight = function() {
      return x_(this.eContentWrapper);
    }, e.prototype.getBodyWidth = function() {
      return xS(this.eContentWrapper);
    }, e.prototype.setTitle = function(t) {
      this.eTitle.innerText = t;
    }, e.prototype.onBtClose = function() {
      this.close();
    }, e.prototype.destroy = function() {
      this.closeButtonComp && (this.closeButtonComp = this.destroyBean(this.closeButtonComp));
      var t = this.getGui();
      t && t.offsetParent && this.close(), n.prototype.destroy.call(this);
    }, e.CLOSE_BTN_TEMPLATE = '<div class="ag-button"></div>', Rm([
      ve("eContentWrapper")
    ], e.prototype, "eContentWrapper", void 0), Rm([
      ve("eTitleBar")
    ], e.prototype, "eTitleBar", void 0), Rm([
      ve("eTitleBarButtons")
    ], e.prototype, "eTitleBarButtons", void 0), Rm([
      ve("eTitle")
    ], e.prototype, "eTitle", void 0), Rm([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var mQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), eb = globalThis && globalThis.__assign || function() {
  return eb = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, eb.apply(this, arguments);
}, vQ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Yx = (
  /** @class */
  function(n) {
    mQ(e, n);
    function e(t) {
      var i = n.call(this, eb(eb({}, t), { popup: !0 })) || this;
      return i.isMaximizable = !1, i.isMaximized = !1, i.maximizeListeners = [], i.resizeListenerDestroy = null, i.lastPosition = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = this.getGui(), r = this.config, o = r.movable, s = r.resizable, a = r.maximizable;
      this.addCssClass("ag-dialog"), n.prototype.postConstruct.call(this), this.addManagedListener(i, "focusin", function(l) {
        i.contains(l.relatedTarget) || t.popupService.bringPopupToFront(i);
      }), o && this.setMovable(o), a && this.setMaximizable(a), s && this.setResizable(s);
    }, e.prototype.renderComponent = function() {
      var t = this.getGui(), i = this.config, r = i.alwaysOnTop, o = i.modal, s = i.title, a = this.gridOptionsWrapper.getLocaleTextFunc(), l = this.popupService.addPopup({
        modal: o,
        eChild: t,
        closeOnEsc: !0,
        closedCallback: this.destroy.bind(this),
        alwaysOnTop: r,
        ariaLabel: s || a("ariaLabelDialog", "Dialog")
      });
      l && (this.close = l.hideFunc);
    }, e.prototype.toggleMaximize = function() {
      var t = this.positionableFeature.getPosition();
      if (this.isMaximized) {
        var i = this.lastPosition, r = i.x, o = i.y, s = i.width, a = i.height;
        this.setWidth(s), this.setHeight(a), this.positionableFeature.offsetElement(r, o);
      } else
        this.lastPosition.width = this.getWidth(), this.lastPosition.height = this.getHeight(), this.lastPosition.x = t.x, this.lastPosition.y = t.y, this.positionableFeature.offsetElement(0, 0), this.setHeight("100%"), this.setWidth("100%");
      this.isMaximized = !this.isMaximized, this.refreshMaximizeIcon();
    }, e.prototype.refreshMaximizeIcon = function() {
      Bi(this.maximizeIcon, !this.isMaximized), Bi(this.minimizeIcon, this.isMaximized);
    }, e.prototype.clearMaximizebleListeners = function() {
      this.maximizeListeners.length && (this.maximizeListeners.forEach(function(t) {
        return t();
      }), this.maximizeListeners.length = 0), this.resizeListenerDestroy && (this.resizeListenerDestroy(), this.resizeListenerDestroy = null);
    }, e.prototype.destroy = function() {
      this.maximizeButtonComp = this.destroyBean(this.maximizeButtonComp), this.clearMaximizebleListeners(), n.prototype.destroy.call(this);
    }, e.prototype.setResizable = function(t) {
      this.positionableFeature.setResizable(t);
    }, e.prototype.setMovable = function(t) {
      this.positionableFeature.setMovable(t, this.eTitleBar);
    }, e.prototype.setMaximizable = function(t) {
      var i = this;
      if (!t) {
        this.clearMaximizebleListeners(), this.maximizeButtonComp && (this.destroyBean(this.maximizeButtonComp), this.maximizeButtonComp = this.maximizeIcon = this.minimizeIcon = void 0);
        return;
      }
      var r = this.eTitleBar;
      if (!(!r || t === this.isMaximizable)) {
        var o = this.maximizeButtonComp = this.createBean(new Et(
          /* html */
          '<div class="ag-dialog-button"></span>'
        )), s = o.getGui();
        s.appendChild(this.maximizeIcon = Yn("maximize", this.gridOptionsWrapper)), this.maximizeIcon.classList.add("ag-panel-title-bar-button-icon"), s.appendChild(this.minimizeIcon = Yn("minimize", this.gridOptionsWrapper)), this.minimizeIcon.classList.add("ag-panel-title-bar-button-icon", "ag-hidden"), o.addManagedListener(s, "click", this.toggleMaximize.bind(this)), this.addTitleBarButton(o, 0), this.maximizeListeners.push(this.addManagedListener(r, "dblclick", this.toggleMaximize.bind(this))), this.resizeListenerDestroy = this.addManagedListener(this, "resize", function() {
          i.isMaximized = !1, i.refreshMaximizeIcon();
        });
      }
    }, vQ([
      T("popupService")
    ], e.prototype, "popupService", void 0), e;
  }(qx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var _Q = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Xx = (
  /** @class */
  function(n) {
    _Q(e, n);
    function e(t, i, r) {
      return i === void 0 && (i = "ag-text-field"), r === void 0 && (r = "text"), n.call(this, t, i, r) || this;
    }
    return e.prototype.postConstruct = function() {
      n.prototype.postConstruct.call(this), this.config.allowedCharPattern && this.preventDisallowedCharacters();
    }, e.prototype.setValue = function(t, i) {
      var r = n.prototype.setValue.call(this, t, i);
      return this.eInput.value !== t && (this.eInput.value = ge(t) ? t : ""), r;
    }, e.prototype.preventDisallowedCharacters = function() {
      var t = new RegExp("[" + this.config.allowedCharPattern + "]"), i = function(r) {
        r.key && !t.test(r.key) && r.preventDefault();
      };
      this.addManagedListener(this.eInput, "keypress", i), this.addManagedListener(this.eInput, "paste", function(r) {
        var o, s = (o = r.clipboardData) === null || o === void 0 ? void 0 : o.getData("text");
        s && s.split("").some(function(a) {
          return !t.test(a);
        }) && r.preventDefault();
      });
    }, e;
  }(Hu)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var CQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), V4 = (
  /** @class */
  function(n) {
    CQ(e, n);
    function e(t) {
      return n.call(this, t, "ag-text-area", null, "textarea") || this;
    }
    return e.prototype.setValue = function(t, i) {
      var r = n.prototype.setValue.call(this, t, i);
      return this.eInput.value = t, r;
    }, e.prototype.setCols = function(t) {
      return this.eInput.cols = t, this;
    }, e.prototype.setRows = function(t) {
      return this.eInput.rows = t, this;
    }, e;
  }(Hu)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var yQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), qC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, B4 = (
  /** @class */
  function(n) {
    yQ(e, n);
    function e(t) {
      var i = n.call(this, t, e.TEMPLATE) || this;
      return i.labelAlignment = "top", i;
    }
    return e.prototype.init = function() {
      this.eSlider.addCssClass("ag-slider-field");
    }, e.prototype.onValueChange = function(t) {
      var i = this, r = Gl.EVENT_CHANGED;
      return this.addManagedListener(this.eText, r, function() {
        var o = parseFloat(i.eText.getValue());
        i.eSlider.setValue(o.toString(), !0), t(o || 0);
      }), this.addManagedListener(this.eSlider, r, function() {
        var o = i.eSlider.getValue();
        i.eText.setValue(o, !0), t(parseFloat(o));
      }), this;
    }, e.prototype.setSliderWidth = function(t) {
      return this.eSlider.setWidth(t), this;
    }, e.prototype.setTextFieldWidth = function(t) {
      return this.eText.setWidth(t), this;
    }, e.prototype.setMinValue = function(t) {
      return this.eSlider.setMinValue(t), this.eText.setMin(t), this;
    }, e.prototype.setMaxValue = function(t) {
      return this.eSlider.setMaxValue(t), this.eText.setMax(t), this;
    }, e.prototype.getValue = function() {
      return this.eText.getValue();
    }, e.prototype.setValue = function(t) {
      return this.getValue() === t ? this : (this.eText.setValue(t, !0), this.eSlider.setValue(t, !0), this.dispatchEvent({ type: Gl.EVENT_CHANGED }), this);
    }, e.prototype.setStep = function(t) {
      return this.eSlider.setStep(t), this.eText.setStep(t), this;
    }, e.TEMPLATE = `<div class="ag-slider">
            <label ref="eLabel"></label>
            <div class="ag-wrapper ag-slider-wrapper">
                <ag-input-range ref="eSlider"></ag-input-range>
                <ag-input-number-field ref="eText"></ag-input-number-field>
            </div>
        </div>`, qC([
      ve("eLabel")
    ], e.prototype, "eLabel", void 0), qC([
      ve("eSlider")
    ], e.prototype, "eSlider", void 0), qC([
      ve("eText")
    ], e.prototype, "eText", void 0), qC([
      Le
    ], e.prototype, "init", null), e;
  }(Ax)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var wQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wu = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, bQ = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, SQ = (
  /** @class */
  function(n) {
    wQ(e, n);
    function e(t) {
      var i = n.call(this, e.TEMPLATE) || this;
      return i.H = 1, i.S = 1, i.B = 1, i.A = 1, i.isSpectrumDragging = !1, i.isSpectrumHueDragging = !1, i.isSpectrumAlphaDragging = !1, i.colorChanged = !1, i.picker = t.picker, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this.getGui();
      this.initRecentColors(), this.addManagedListener(this.spectrumVal, "mousedown", this.onSpectrumDraggerDown.bind(this)), this.addManagedListener(t, "mousemove", this.onSpectrumDraggerMove.bind(this)), this.addManagedListener(this.spectrumHue, "mousedown", this.onSpectrumHueDown.bind(this)), this.addManagedListener(t, "mousemove", this.onSpectrumHueMove.bind(this)), this.addManagedListener(this.spectrumAlpha, "mousedown", this.onSpectrumAlphaDown.bind(this)), this.addManagedListener(t, "mousemove", this.onSpectrumAlphaMove.bind(this)), this.addManagedListener(document, "mouseup", this.onMouseUp.bind(this)), this.addManagedListener(this.recentColors, "click", this.onRecentColorClick.bind(this));
    }, e.prototype.refreshSpectrumRect = function() {
      return this.spectrumValRect = this.spectrumVal.getBoundingClientRect();
    }, e.prototype.refreshHueRect = function() {
      return this.spectrumHueRect = this.spectrumHue.getBoundingClientRect();
    }, e.prototype.refreshAlphaRect = function() {
      return this.spectrumAlphaRect = this.spectrumAlpha.getBoundingClientRect();
    }, e.prototype.onSpectrumDraggerDown = function(t) {
      this.refreshSpectrumRect(), this.isSpectrumDragging = !0, this.moveDragger(t);
    }, e.prototype.onSpectrumDraggerMove = function(t) {
      this.isSpectrumDragging && this.moveDragger(t);
    }, e.prototype.onSpectrumHueDown = function(t) {
      this.refreshHueRect(), this.isSpectrumHueDragging = !0, this.moveHueSlider(t);
    }, e.prototype.onSpectrumHueMove = function(t) {
      this.isSpectrumHueDragging && this.moveHueSlider(t);
    }, e.prototype.onSpectrumAlphaDown = function(t) {
      this.refreshAlphaRect(), this.isSpectrumAlphaDragging = !0, this.moveAlphaSlider(t);
    }, e.prototype.onSpectrumAlphaMove = function(t) {
      this.isSpectrumAlphaDragging && this.moveAlphaSlider(t);
    }, e.prototype.onMouseUp = function() {
      this.isSpectrumDragging = !1, this.isSpectrumHueDragging = !1, this.isSpectrumAlphaDragging = !1;
    }, e.prototype.moveDragger = function(t) {
      var i = this.spectrumValRect;
      if (i) {
        var r = t.clientX - i.left, o = t.clientY - i.top;
        r = Math.max(r, 0), r = Math.min(r, i.width), o = Math.max(o, 0), o = Math.min(o, i.height), this.setSpectrumValue(r / i.width, 1 - o / i.height);
      }
    }, e.prototype.moveHueSlider = function(t) {
      var i = this.spectrumHueRect;
      if (i) {
        var r = this.spectrumHueSlider, o = r.getBoundingClientRect(), s = t.clientX - i.left;
        s = Math.max(s, 0), s = Math.min(s, i.width), this.H = 1 - s / i.width, r.style.left = s + o.width / 2 + "px", this.update();
      }
    }, e.prototype.moveAlphaSlider = function(t) {
      var i = this.spectrumAlphaRect;
      if (i) {
        var r = this.spectrumAlphaSlider, o = r.getBoundingClientRect(), s = t.clientX - i.left;
        s = Math.max(s, 0), s = Math.min(s, i.width), this.A = s / i.width, r.style.left = s + o.width / 2 + "px", this.update();
      }
    }, e.prototype.update = function() {
      var t = zf.fromHSB(this.H * 360, this.S, this.B, this.A), i = zf.fromHSB(this.H * 360, 1, 1), r = t.toRgbaString(), o = this.picker, s = zf.fromString(o.getValue());
      s.toRgbaString() !== r && (this.colorChanged = !0), o.setValue(r), this.spectrumColor.style.backgroundColor = i.toRgbaString(), this.spectrumDragger.style.backgroundColor = r;
    }, e.prototype.setSpectrumValue = function(t, i) {
      var r = this.spectrumValRect || this.refreshSpectrumRect();
      if (r) {
        var o = this.spectrumDragger, s = o.getBoundingClientRect();
        t = Math.max(0, t), t = Math.min(1, t), i = Math.max(0, i), i = Math.min(1, i), this.S = t, this.B = i, o.style.left = t * r.width - s.width / 2 + "px", o.style.top = (1 - i) * r.height - s.height / 2 + "px", this.update();
      }
    }, e.prototype.initRecentColors = function() {
      var t = e.recentColors, i = t.map(function(r, o) {
        return '<div class="ag-recent-color" id=' + o + ' style="background-color: ' + r + '; width: 15px; height: 15px;" recent-color="' + r + '"></div>';
      });
      this.recentColors.innerHTML = i.join("");
    }, e.prototype.setValue = function(t) {
      var i = zf.fromString(t), r = bQ(i.toHSB(), 3), o = r[0], s = r[1], a = r[2];
      this.H = (isNaN(o) ? 0 : o) / 360, this.A = i.a;
      var l = this.spectrumHueRect || this.refreshHueRect(), u = this.spectrumAlphaRect || this.refreshAlphaRect();
      this.spectrumHueSlider.style.left = (this.H - 1) * -l.width + "px", this.spectrumAlphaSlider.style.left = this.A * u.width + "px", this.setSpectrumValue(s, a);
    }, e.prototype.onRecentColorClick = function(t) {
      var i = t.target;
      if (ge(i.id)) {
        var r = parseInt(i.id, 10);
        this.setValue(e.recentColors[r]), this.destroy();
      }
    }, e.prototype.addRecentColor = function() {
      var t = zf.fromHSB(this.H * 360, this.S, this.B, this.A), i = t.toRgbaString(), r = e.recentColors;
      !this.colorChanged || r[0] === i || (r = r.filter(function(o) {
        return o != i;
      }), r = [i].concat(r), r.length > e.maxRecentColors && (r = r.slice(0, e.maxRecentColors)), e.recentColors = r);
    }, e.prototype.destroy = function() {
      this.addRecentColor(), n.prototype.destroy.call(this);
    }, e.maxRecentColors = 8, e.recentColors = [], e.TEMPLATE = `<div class="ag-color-panel">
            <div ref="spectrumColor" class="ag-spectrum-color">
                <div class="ag-spectrum-sat ag-spectrum-fill">
                    <div ref="spectrumVal" class="ag-spectrum-val ag-spectrum-fill">
                        <div ref="spectrumDragger" class="ag-spectrum-dragger"></div>
                    </div>
                </div>
            </div>
            <div class="ag-spectrum-tools">
                <div ref="spectrumHue" class="ag-spectrum-hue ag-spectrum-tool">
                    <div class="ag-spectrum-hue-background"></div>
                    <div ref="spectrumHueSlider" class="ag-spectrum-slider"></div>
                </div>
                <div ref="spectrumAlpha" class="ag-spectrum-alpha ag-spectrum-tool">
                    <div class="ag-spectrum-alpha-background"></div>
                    <div ref="spectrumAlphaSlider" class="ag-spectrum-slider"></div>
                </div>
                <div ref="recentColors" class="ag-recent-colors"></div>
            </div>
        </div>`, wu([
      ve("spectrumColor")
    ], e.prototype, "spectrumColor", void 0), wu([
      ve("spectrumVal")
    ], e.prototype, "spectrumVal", void 0), wu([
      ve("spectrumDragger")
    ], e.prototype, "spectrumDragger", void 0), wu([
      ve("spectrumHue")
    ], e.prototype, "spectrumHue", void 0), wu([
      ve("spectrumHueSlider")
    ], e.prototype, "spectrumHueSlider", void 0), wu([
      ve("spectrumAlpha")
    ], e.prototype, "spectrumAlpha", void 0), wu([
      ve("spectrumAlphaSlider")
    ], e.prototype, "spectrumAlphaSlider", void 0), wu([
      ve("recentColors")
    ], e.prototype, "recentColors", void 0), wu([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var EQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), H4 = (
  /** @class */
  function(n) {
    EQ(e, n);
    function e(t) {
      var i = n.call(this, t, "ag-color-picker", "colorPicker") || this;
      return t && t.color && (i.value = t.color), i;
    }
    return e.prototype.postConstruct = function() {
      n.prototype.postConstruct.call(this), this.value && this.setValue(this.value);
    }, e.prototype.showPicker = function() {
      var t = this, i = this.getGui().getBoundingClientRect(), r = this.createBean(new Yx({
        closable: !1,
        modal: !0,
        hideTitleBar: !0,
        minWidth: 190,
        width: 190,
        height: 250,
        x: i.right - 190,
        y: i.top - 250
      }));
      this.isPickerDisplayed = !0, r.addCssClass("ag-color-dialog"), bs(this.eWrapper, !0);
      var o = this.createBean(new SQ({ picker: this }));
      return o.addDestroyFunc(function() {
        r.isAlive() && t.destroyBean(r);
      }), r.setParentComponent(this), r.setBodyComponent(o), o.setValue(this.getValue()), r.addDestroyFunc(function() {
        t.isDestroyingPicker ? t.isDestroyingPicker = !1 : (t.isDestroyingPicker = !0, o.isAlive() && t.destroyBean(o)), t.isAlive() && (bs(t.eWrapper, !1), t.getFocusableElement().focus()), t.isPickerDisplayed = !1;
      }), r;
    }, e.prototype.setValue = function(t) {
      return this.value === t ? this : (this.eDisplayField.style.backgroundColor = t, n.prototype.setValue.call(this, t));
    }, e.prototype.getValue = function() {
      return this.value;
    }, e;
  }(EH)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var LQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), G4 = (
  /** @class */
  function(n) {
    LQ(e, n);
    function e(t) {
      return n.call(this, t, "ag-number-field", "number") || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      n.prototype.postConstruct.call(this), this.addManagedListener(this.eInput, "blur", function() {
        var i = parseFloat(t.eInput.value), r = isNaN(i) ? "" : t.normalizeValue(i.toString());
        t.value !== r && t.setValue(r);
      }), this.eInput.step = "any";
    }, e.prototype.normalizeValue = function(t) {
      if (t === "")
        return "";
      this.precision && (t = this.adjustPrecision(t));
      var i = parseFloat(t);
      return this.min != null && i < this.min ? t = this.min.toString() : this.max != null && i > this.max && (t = this.max.toString()), t;
    }, e.prototype.adjustPrecision = function(t) {
      if (this.precision) {
        var i = parseFloat(t).toFixed(this.precision);
        t = parseFloat(i).toString();
      }
      return t;
    }, e.prototype.setMin = function(t) {
      return this.min === t ? this : (this.min = t, lv(this.eInput, "min", t), this);
    }, e.prototype.setMax = function(t) {
      return this.max === t ? this : (this.max = t, lv(this.eInput, "max", t), this);
    }, e.prototype.setPrecision = function(t) {
      return this.precision = t, this;
    }, e.prototype.setStep = function(t) {
      return this.step === t ? this : (this.step = t, lv(this.eInput, "step", t), this);
    }, e.prototype.setValue = function(t, i) {
      t = this.adjustPrecision(t);
      var r = this.normalizeValue(t);
      return t != r ? this : n.prototype.setValue.call(this, t, i);
    }, e;
  }(Xx)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var DQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), U4 = (
  /** @class */
  function(n) {
    DQ(e, n);
    function e(t) {
      return n.call(this, t, "ag-range-field", "range") || this;
    }
    return e.prototype.postConstruct = function() {
      n.prototype.postConstruct.call(this);
      var t = this.config, i = t.min, r = t.max, o = t.step;
      i != null && this.setMinValue(i), r != null && this.setMaxValue(r), this.setStep(o || 1);
    }, e.prototype.addInputListeners = function() {
      var t = this;
      this.addManagedListener(this.eInput, "input", function(i) {
        var r = i.target.value;
        t.setValue(r);
      });
    }, e.prototype.setMinValue = function(t) {
      return this.min = t, this.eInput.setAttribute("min", t.toString()), this;
    }, e.prototype.setMaxValue = function(t) {
      return this.max = t, this.eInput.setAttribute("max", t.toString()), this;
    }, e.prototype.setStep = function(t) {
      return this.eInput.setAttribute("step", t.toString()), this;
    }, e.prototype.setValue = function(t, i) {
      this.min != null && (t = Math.max(parseFloat(t), this.min).toString()), this.max != null && (t = Math.min(parseFloat(t), this.max).toString());
      var r = n.prototype.setValue.call(this, t, i);
      return this.eInput.value = t, r;
    }, e;
  }(Hu)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var RQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Tm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, z4 = (
  /** @class */
  function(n) {
    RQ(e, n);
    function e(t) {
      var i = n.call(this, t, e.TEMPLATE) || this;
      return i.radius = 0, i.offsetX = 0, i.offsetY = 0, i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      n.prototype.postConstruct.call(this), this.dragListener = {
        eElement: this.eParentCircle,
        dragStartPixels: 0,
        onDragStart: function(i) {
          t.parentCircleRect = t.eParentCircle.getBoundingClientRect();
        },
        onDragging: function(i) {
          return t.calculateAngleDrag(i);
        },
        onDragStop: function() {
        }
      }, this.dragService.addDragSource(this.dragListener), this.eAngleValue.setLabel("").setLabelWidth(5).setInputWidth(45).setMin(0).setMax(360).setValue("" + this.degrees).onValueChange(function(i) {
        (i == null || i === "") && (i = "0"), i = t.eAngleValue.normalizeValue(i);
        var r = parseFloat(i);
        r > 180 && (r = r - 360), t.setValue(r);
      }), this.updateNumberInput(), ge(this.getValue()) && this.eAngleValue.setValue(this.normalizeNegativeValue(this.getValue()).toString()), this.addManagedListener(this, Gl.EVENT_CHANGED, function() {
        var i = t.gridOptionsWrapper.getDocument();
        t.eAngleValue.getInputElement().contains(i.activeElement) || t.updateNumberInput();
      });
    }, e.prototype.updateNumberInput = function() {
      var t = this.normalizeNegativeValue(this.getValue());
      this.eAngleValue.setValue(t.toString());
    }, e.prototype.positionChildCircle = function(t) {
      var i = this.parentCircleRect || { width: 24, height: 24 }, r = this.eChildCircle, o = i.width / 2, s = i.height / 2;
      r.style.left = o + Math.cos(t) * 8 + "px", r.style.top = s + Math.sin(t) * 8 + "px";
    }, e.prototype.calculatePolar = function() {
      var t = this.offsetX, i = this.offsetY, r = Math.atan2(i, t);
      this.degrees = this.toDegrees(r), this.radius = Math.sqrt(t * t + i * i), this.positionChildCircle(r);
    }, e.prototype.calculateCartesian = function() {
      var t = this.toRadians(this.getValue()), i = this.getRadius();
      this.setOffsetX(Math.cos(t) * i).setOffsetY(Math.sin(t) * i);
    }, e.prototype.setOffsetX = function(t) {
      return this.offsetX !== t && (this.offsetX = t, this.calculatePolar()), this;
    }, e.prototype.setOffsetY = function(t) {
      return this.offsetY !== t && (this.offsetY = t, this.calculatePolar()), this;
    }, e.prototype.calculateAngleDrag = function(t) {
      var i = this.parentCircleRect, r = i.width / 2, o = i.height / 2, s = t.clientX - i.left, a = t.clientY - i.top, l = s - r, u = a - o, c = Math.atan2(u, l);
      this.setValue(c, !0);
    }, e.prototype.toDegrees = function(t) {
      return t / Math.PI * 180;
    }, e.prototype.toRadians = function(t) {
      return t / 180 * Math.PI;
    }, e.prototype.normalizeNegativeValue = function(t) {
      return t < 0 ? 360 + t : t;
    }, e.prototype.normalizeAngle180 = function(t) {
      return t %= Math.PI * 2, t < -Math.PI ? t += Math.PI * 2 : t >= Math.PI && (t -= Math.PI * 2), t;
    }, e.prototype.getRadius = function() {
      return this.radius;
    }, e.prototype.setRadius = function(t) {
      return this.radius === t ? this : (this.radius = t, this.calculateCartesian(), this);
    }, e.prototype.onValueChange = function(t) {
      var i = this;
      return this.addManagedListener(this, Gl.EVENT_CHANGED, function() {
        t(i.degrees);
      }), this;
    }, e.prototype.getValue = function(t) {
      return t ? this.toRadians(this.degrees) : this.degrees;
    }, e.prototype.setValue = function(t, i) {
      var r;
      return i ? r = t : r = this.normalizeAngle180(this.toRadians(t)), t = this.toDegrees(r), this.degrees !== t && (this.degrees = Math.floor(t), this.calculateCartesian(), this.positionChildCircle(r), this.dispatchEvent({ type: Gl.EVENT_CHANGED })), this;
    }, e.prototype.setWidth = function(t) {
      return Yl(this.getGui(), t), this;
    }, e.prototype.destroy = function() {
      this.dragService.removeDragSource(this.dragListener), n.prototype.destroy.call(this);
    }, e.TEMPLATE = `<div class="ag-angle-select">
            <div ref="eLabel"></div>
            <div class="ag-wrapper ag-angle-select-wrapper">
                <div ref="eAngleSelectField" class="ag-angle-select-field">
                    <div ref="eParentCircle" class="ag-angle-select-parent-circle">
                        <div ref="eChildCircle" class="ag-angle-select-child-circle"></div>
                    </div>
                </div>
                <ag-input-number-field ref="eAngleValue"></ag-input-number-field>
            </div>
        </div>`, Tm([
      ve("eLabel")
    ], e.prototype, "eLabel", void 0), Tm([
      ve("eParentCircle")
    ], e.prototype, "eParentCircle", void 0), Tm([
      ve("eChildCircle")
    ], e.prototype, "eChildCircle", void 0), Tm([
      ve("eAngleValue")
    ], e.prototype, "eAngleValue", void 0), Tm([
      T("dragService")
    ], e.prototype, "dragService", void 0), e;
  }(Ax)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var TQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), j4 = (
  /** @class */
  function(n) {
    TQ(e, n);
    function e(t) {
      return n.call(this, t, "ag-toggle-button") || this;
    }
    return e.prototype.setValue = function(t, i) {
      return n.prototype.setValue.call(this, t, i), this.addOrRemoveCssClass("ag-selected", this.getValue()), this;
    }, e;
  }(Kp)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var OQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), YC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, $4 = (
  /** @class */
  function(n) {
    OQ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getFirstRow = function() {
      var t = 0, i;
      return this.pinnedRowModel.getPinnedTopRowCount() ? i = Z.PINNED_TOP : this.rowModel.getRowCount() ? (i = null, t = this.paginationProxy.getPageFirstRow()) : this.pinnedRowModel.getPinnedBottomRowCount() && (i = Z.PINNED_BOTTOM), i === void 0 ? null : { rowIndex: t, rowPinned: i };
    }, e.prototype.getLastRow = function() {
      var t, i = null, r = this.pinnedRowModel.getPinnedBottomRowCount(), o = this.pinnedRowModel.getPinnedTopRowCount();
      return r ? (i = Z.PINNED_BOTTOM, t = r - 1) : this.rowModel.getRowCount() ? (i = null, t = this.paginationProxy.getPageLastRow()) : o && (i = Z.PINNED_TOP, t = o - 1), t === void 0 ? null : { rowIndex: t, rowPinned: i };
    }, e.prototype.getRowNode = function(t) {
      switch (t.rowPinned) {
        case Z.PINNED_TOP:
          return this.pinnedRowModel.getPinnedTopRowData()[t.rowIndex];
        case Z.PINNED_BOTTOM:
          return this.pinnedRowModel.getPinnedBottomRowData()[t.rowIndex];
        default:
          return this.rowModel.getRow(t.rowIndex);
      }
    }, e.prototype.sameRow = function(t, i) {
      return !t && !i ? !0 : t && !i || !t && i ? !1 : t.rowIndex === i.rowIndex && t.rowPinned == i.rowPinned;
    }, e.prototype.before = function(t, i) {
      switch (t.rowPinned) {
        case Z.PINNED_TOP:
          if (i.rowPinned !== Z.PINNED_TOP)
            return !0;
          break;
        case Z.PINNED_BOTTOM:
          if (i.rowPinned !== Z.PINNED_BOTTOM)
            return !1;
          break;
        default:
          if (ge(i.rowPinned))
            return i.rowPinned !== Z.PINNED_TOP;
          break;
      }
      return t.rowIndex < i.rowIndex;
    }, YC([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), YC([
      T("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), YC([
      T("paginationProxy")
    ], e.prototype, "paginationProxy", void 0), e = YC([
      qe("rowPositionUtils")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var xQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), NQ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, K4 = (
  /** @class */
  function(n) {
    xQ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.createId = function(t) {
      var i = t.rowIndex, r = t.rowPinned, o = t.column;
      return this.createIdFromValues(i, o, r);
    }, e.prototype.createIdFromValues = function(t, i, r) {
      return t + "." + (r ?? "null") + "." + i.getId();
    }, e.prototype.equals = function(t, i) {
      var r = t.column === i.column, o = t.rowPinned === i.rowPinned, s = t.rowIndex === i.rowIndex;
      return r && o && s;
    }, e = NQ([
      qe("cellPositionUtils")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var IQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Om = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, q4 = (
  /** @class */
  function(n) {
    IQ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      this.setPinnedTopRowData(this.gridOptionsWrapper.getPinnedTopRowData()), this.setPinnedBottomRowData(this.gridOptionsWrapper.getPinnedBottomRowData());
    }, e.prototype.isEmpty = function(t) {
      var i = t === Z.PINNED_TOP ? this.pinnedTopRows : this.pinnedBottomRows;
      return ms(i);
    }, e.prototype.isRowsToRender = function(t) {
      return !this.isEmpty(t);
    }, e.prototype.getRowAtPixel = function(t, i) {
      var r = i === Z.PINNED_TOP ? this.pinnedTopRows : this.pinnedBottomRows;
      if (ms(r))
        return 0;
      for (var o = 0; o < r.length; o++) {
        var s = r[o], a = s.rowTop + s.rowHeight - 1;
        if (a >= t)
          return o;
      }
      return r.length - 1;
    }, e.prototype.setPinnedTopRowData = function(t) {
      this.pinnedTopRows = this.createNodesFromData(t, !0);
      var i = {
        type: F.EVENT_PINNED_ROW_DATA_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.setPinnedBottomRowData = function(t) {
      this.pinnedBottomRows = this.createNodesFromData(t, !1);
      var i = {
        type: F.EVENT_PINNED_ROW_DATA_CHANGED,
        api: this.gridApi,
        columnApi: this.columnApi
      };
      this.eventService.dispatchEvent(i);
    }, e.prototype.createNodesFromData = function(t, i) {
      var r = this, o = [];
      if (t) {
        var s = 0;
        t.forEach(function(a, l) {
          var u = new Wt(r.beans);
          u.data = a;
          var c = i ? Wt.ID_PREFIX_TOP_PINNED : Wt.ID_PREFIX_BOTTOM_PINNED;
          u.id = c + l, u.rowPinned = i ? Z.PINNED_TOP : Z.PINNED_BOTTOM, u.setRowTop(s), u.setRowHeight(r.gridOptionsWrapper.getRowHeightForNode(u).height), u.setRowIndex(l), s += u.rowHeight, o.push(u);
        });
      }
      return o;
    }, e.prototype.getPinnedTopRowData = function() {
      return this.pinnedTopRows;
    }, e.prototype.getPinnedBottomRowData = function() {
      return this.pinnedBottomRows;
    }, e.prototype.getPinnedTopTotalHeight = function() {
      return this.getTotalHeight(this.pinnedTopRows);
    }, e.prototype.getPinnedTopRowCount = function() {
      return this.pinnedTopRows ? this.pinnedTopRows.length : 0;
    }, e.prototype.getPinnedBottomRowCount = function() {
      return this.pinnedBottomRows ? this.pinnedBottomRows.length : 0;
    }, e.prototype.getPinnedTopRow = function(t) {
      return this.pinnedTopRows[t];
    }, e.prototype.getPinnedBottomRow = function(t) {
      return this.pinnedBottomRows[t];
    }, e.prototype.forEachPinnedTopRow = function(t) {
      ms(this.pinnedTopRows) || this.pinnedTopRows.forEach(t);
    }, e.prototype.forEachPinnedBottomRow = function(t) {
      ms(this.pinnedBottomRows) || this.pinnedBottomRows.forEach(t);
    }, e.prototype.getPinnedBottomTotalHeight = function() {
      return this.getTotalHeight(this.pinnedBottomRows);
    }, e.prototype.getTotalHeight = function(t) {
      if (!t || t.length === 0)
        return 0;
      var i = Ti(t);
      return i.rowTop + i.rowHeight;
    }, Om([
      T("columnApi")
    ], e.prototype, "columnApi", void 0), Om([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Om([
      T("beans")
    ], e.prototype, "beans", void 0), Om([
      Le
    ], e.prototype, "init", null), e = Om([
      qe("pinnedRowModel")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var PQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Jy = (
  /** @class */
  function() {
    function n(e) {
      this.cellValueChanges = e;
    }
    return n;
  }()
), GL = (
  /** @class */
  function(n) {
    PQ(e, n);
    function e(t, i, r) {
      var o = n.call(this, t) || this;
      return o.initialRange = i, o.finalRange = r, o;
    }
    return e;
  }(Jy)
), wF = (
  /** @class */
  function() {
    function n(e) {
      this.actionStack = [], this.maxStackSize = e || n.DEFAULT_STACK_SIZE, this.actionStack = new Array(this.maxStackSize);
    }
    return n.prototype.pop = function() {
      return this.actionStack.pop();
    }, n.prototype.push = function(e) {
      var t = e.cellValueChanges && e.cellValueChanges.length > 0;
      t && (this.actionStack.length === this.maxStackSize && this.actionStack.shift(), this.actionStack.push(e));
    }, n.prototype.clear = function() {
      this.actionStack = [];
    }, n.prototype.getCurrentStackSize = function() {
      return this.actionStack.length;
    }, n.DEFAULT_STACK_SIZE = 10, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var AQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Ec = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, MQ = (
  /** @class */
  function(n) {
    AQ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.cellValueChanges = [], t.activeCellEdit = null, t.activeRowEdit = null, t.isPasting = !1, t.isFilling = !1, t.onCellValueChanged = function(i) {
        var r = { column: i.column, rowIndex: i.rowIndex, rowPinned: i.rowPinned }, o = t.activeCellEdit !== null && t.cellPositionUtils.equals(t.activeCellEdit, r), s = t.activeRowEdit !== null && t.rowPositionUtils.sameRow(t.activeRowEdit, r), a = o || s || t.isPasting || t.isFilling;
        if (a) {
          var l = i.rowPinned, u = i.rowIndex, c = i.column, h = i.oldValue, d = i.value, f = {
            rowPinned: l,
            rowIndex: u,
            columnId: c.getColId(),
            newValue: d,
            oldValue: h
          };
          t.cellValueChanges.push(f);
        }
      }, t.clearStacks = function() {
        t.undoStack.clear(), t.redoStack.clear();
      }, t;
    }
    return e.prototype.init = function() {
      if (this.gridOptionsWrapper.isUndoRedoCellEditing()) {
        var t = this.gridOptionsWrapper.getUndoRedoCellEditingLimit();
        t <= 0 || (this.undoStack = new wF(t), this.redoStack = new wF(t), this.addRowEditingListeners(), this.addCellEditingListeners(), this.addPasteListeners(), this.addFillListeners(), this.addManagedListener(this.eventService, F.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged), this.addManagedListener(this.eventService, F.EVENT_MODEL_UPDATED, this.clearStacks), this.addManagedListener(this.eventService, F.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.clearStacks), this.addManagedListener(this.eventService, F.EVENT_NEW_COLUMNS_LOADED, this.clearStacks), this.addManagedListener(this.eventService, F.EVENT_COLUMN_GROUP_OPENED, this.clearStacks), this.addManagedListener(this.eventService, F.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearStacks), this.addManagedListener(this.eventService, F.EVENT_COLUMN_MOVED, this.clearStacks), this.addManagedListener(this.eventService, F.EVENT_COLUMN_PINNED, this.clearStacks), this.addManagedListener(this.eventService, F.EVENT_COLUMN_VISIBLE, this.clearStacks), this.addManagedListener(this.eventService, F.EVENT_ROW_DRAG_END, this.clearStacks));
      }
    }, e.prototype.getCurrentUndoStackSize = function() {
      return this.undoStack ? this.undoStack.getCurrentStackSize() : 0;
    }, e.prototype.getCurrentRedoStackSize = function() {
      return this.redoStack ? this.redoStack.getCurrentStackSize() : 0;
    }, e.prototype.undo = function() {
      if (this.undoStack) {
        var t = this.undoStack.pop();
        !t || !t.cellValueChanges || (this.processAction(t, function(i) {
          return i.oldValue;
        }), t instanceof GL ? this.processRangeAndCellFocus(t.cellValueChanges, t.initialRange) : this.processRangeAndCellFocus(t.cellValueChanges), this.redoStack.push(t));
      }
    }, e.prototype.redo = function() {
      if (this.redoStack) {
        var t = this.redoStack.pop();
        !t || !t.cellValueChanges || (this.processAction(t, function(i) {
          return i.newValue;
        }), t instanceof GL ? this.processRangeAndCellFocus(t.cellValueChanges, t.finalRange) : this.processRangeAndCellFocus(t.cellValueChanges), this.undoStack.push(t));
      }
    }, e.prototype.processAction = function(t, i) {
      var r = this;
      t.cellValueChanges.forEach(function(o) {
        var s = o.rowIndex, a = o.rowPinned, l = o.columnId, u = { rowIndex: s, rowPinned: a }, c = r.getRowNode(u);
        c.displayed && c.setDataValue(l, i(o));
      });
    }, e.prototype.processRangeAndCellFocus = function(t, i) {
      var r;
      if (i) {
        var o = i.startRow, s = i.endRow;
        r = {
          rowPinned: o.rowPinned,
          rowIndex: o.rowIndex,
          columnId: i.startColumn.getColId()
        }, this.setLastFocusedCell(r);
        var a = {
          rowStartIndex: o.rowIndex,
          rowStartPinned: o.rowPinned,
          rowEndIndex: s.rowIndex,
          rowEndPinned: s.rowPinned,
          columnStart: i.startColumn,
          columns: i.columns
        };
        this.gridApi.addCellRange(a);
        return;
      }
      var l = t[0], u = l.rowIndex, c = l.rowPinned, h = { rowIndex: u, rowPinned: c }, d = this.getRowNode(h);
      r = {
        rowPinned: l.rowPinned,
        rowIndex: d.rowIndex,
        columnId: l.columnId
      }, this.setLastFocusedCell(r);
    }, e.prototype.setLastFocusedCell = function(t) {
      var i = t.rowIndex, r = t.columnId, o = t.rowPinned;
      this.gridApi.ensureIndexVisible(i), this.gridApi.ensureColumnVisible(r), gt.isRegistered(ht.RangeSelectionModule) && this.gridApi.clearRangeSelection(), this.focusService.setFocusedCell(i, r, o, !0);
    }, e.prototype.addRowEditingListeners = function() {
      var t = this;
      this.addManagedListener(this.eventService, F.EVENT_ROW_EDITING_STARTED, function(i) {
        t.activeRowEdit = { rowIndex: i.rowIndex, rowPinned: i.rowPinned };
      }), this.addManagedListener(this.eventService, F.EVENT_ROW_EDITING_STOPPED, function() {
        var i = new Jy(t.cellValueChanges);
        t.pushActionsToUndoStack(i), t.activeRowEdit = null;
      });
    }, e.prototype.addCellEditingListeners = function() {
      var t = this;
      this.addManagedListener(this.eventService, F.EVENT_CELL_EDITING_STARTED, function(i) {
        t.activeCellEdit = { column: i.column, rowIndex: i.rowIndex, rowPinned: i.rowPinned };
      }), this.addManagedListener(this.eventService, F.EVENT_CELL_EDITING_STOPPED, function() {
        t.activeCellEdit = null;
        var i = !t.activeRowEdit && !t.isPasting && !t.isFilling;
        if (i) {
          var r = new Jy(t.cellValueChanges);
          t.pushActionsToUndoStack(r);
        }
      });
    }, e.prototype.addPasteListeners = function() {
      var t = this;
      this.addManagedListener(this.eventService, F.EVENT_PASTE_START, function() {
        t.isPasting = !0;
      }), this.addManagedListener(this.eventService, F.EVENT_PASTE_END, function() {
        var i = new Jy(t.cellValueChanges);
        t.pushActionsToUndoStack(i), t.isPasting = !1;
      });
    }, e.prototype.addFillListeners = function() {
      var t = this;
      this.addManagedListener(this.eventService, F.EVENT_FILL_START, function() {
        t.isFilling = !0;
      }), this.addManagedListener(this.eventService, F.EVENT_FILL_END, function(i) {
        var r = new GL(t.cellValueChanges, i.initialRange, i.finalRange);
        t.pushActionsToUndoStack(r), t.isFilling = !1;
      });
    }, e.prototype.pushActionsToUndoStack = function(t) {
      this.undoStack.push(t), this.cellValueChanges = [], this.redoStack.clear();
    }, e.prototype.getRowNode = function(t) {
      switch (t.rowPinned) {
        case Z.PINNED_TOP:
          return this.pinnedRowModel.getPinnedTopRowData()[t.rowIndex];
        case Z.PINNED_BOTTOM:
          return this.pinnedRowModel.getPinnedBottomRowData()[t.rowIndex];
        default:
          return this.rowModel.getRow(t.rowIndex);
      }
    }, Ec([
      T("focusService")
    ], e.prototype, "focusService", void 0), Ec([
      T("gridApi")
    ], e.prototype, "gridApi", void 0), Ec([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), Ec([
      T("pinnedRowModel")
    ], e.prototype, "pinnedRowModel", void 0), Ec([
      T("cellPositionUtils")
    ], e.prototype, "cellPositionUtils", void 0), Ec([
      T("rowPositionUtils")
    ], e.prototype, "rowPositionUtils", void 0), Ec([
      Le
    ], e.prototype, "init", null), e = Ec([
      qe("undoRedoService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var FQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), UL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Y4 = (
  /** @class */
  function(n) {
    FQ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.findHeader = function(t, i) {
      var r, o, s;
      if (t.column instanceof Qr ? (o = "getDisplayedGroup" + i, r = this.columnModel[o](t.column)) : (s = "getDisplayedCol" + i, r = this.columnModel[s](t.column)), r)
        return {
          column: r,
          headerRowIndex: t.headerRowIndex
        };
    }, e.prototype.findColAtEdgeForHeaderRow = function(t, i) {
      var r = this.columnModel.getAllDisplayedColumns(), o = r[i === "start" ? 0 : r.length - 1];
      if (o) {
        var s = this.ctrlsService.getHeaderRowContainerCtrl(o.getPinned()), a = s.getRowType(t);
        if (a == Jr.COLUMN_GROUP) {
          var l = this.columnModel.getColumnGroupAtLevel(o, t);
          return {
            headerRowIndex: t,
            column: l
          };
        }
        return {
          // if type==null, means the header level didn't exist
          headerRowIndex: a == null ? -1 : t,
          column: o
        };
      }
    }, UL([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), UL([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), e = UL([
      qe("headerPositionUtils")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var kQ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, WQ = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.buildColumnDefs = function(e, t, i) {
      var r = this, o = [], s = {};
      return e.forEach(function(a) {
        for (var l = r.createDefFromColumn(a, t, i), u = !0, c = l, h = a.getOriginalParent(); h; ) {
          var d = null;
          if (h.isPadding()) {
            h = h.getOriginalParent();
            continue;
          }
          var f = s[h.getGroupId()];
          if (f) {
            f.children.push(c), u = !1;
            break;
          }
          d = r.createDefFromGroup(h), d && (d.children = [c], s[d.groupId] = d, c = d, h = h.getOriginalParent());
        }
        u && o.push(c);
      }), o;
    }, n.prototype.createDefFromGroup = function(e) {
      var t = kw(e.getColGroupDef(), ["children"]);
      return t && (t.groupId = e.getGroupId()), t;
    }, n.prototype.createDefFromColumn = function(e, t, i) {
      var r = kw(e.getColDef());
      return r.colId = e.getColId(), r.width = e.getActualWidth(), r.rowGroup = e.isRowGroupActive(), r.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null, r.pivot = e.isPivotActive(), r.pivotIndex = e.isPivotActive() ? i.indexOf(e) : null, r.aggFunc = e.isValueActive() ? e.getAggFunc() : null, r.hide = e.isVisible() ? void 0 : !0, r.pinned = e.isPinned() ? e.getPinned() : null, r.sort = e.getSort() ? e.getSort() : null, r.sortIndex = e.getSortIndex() != null ? e.getSortIndex() : null, r;
    }, n = kQ([
      qe("columnDefFactory")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var zL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, VQ = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.getInitialRowClasses = function(e) {
      var t = [];
      return ge(e.extraCssClass) && t.push(e.extraCssClass), t.push("ag-row"), t.push(e.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), e.fadeRowIn && t.push("ag-opacity-zero"), t.push(e.rowIsEven ? "ag-row-even" : "ag-row-odd"), e.rowNode.isRowPinned() && t.push("ag-row-pinned"), e.rowNode.isSelected() && t.push("ag-row-selected"), e.rowNode.footer && t.push("ag-row-footer"), t.push("ag-row-level-" + e.rowLevel), e.rowNode.stub && t.push("ag-row-loading"), e.fullWidthRow && t.push("ag-full-width-row"), e.expandable && (t.push("ag-row-group"), t.push(e.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted")), e.rowNode.dragging && t.push("ag-row-dragging"), B1(t, this.processClassesFromGridOptions(e.rowNode, e.scope)), B1(t, this.preProcessRowClassRules(e.rowNode, e.scope)), t.push(e.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), e.firstRowOnPage && t.push("ag-row-first"), e.lastRowOnPage && t.push("ag-row-last"), e.fullWidthRow && (e.pinned === Z.PINNED_LEFT && t.push("ag-cell-last-left-pinned"), e.pinned === Z.PINNED_RIGHT && t.push("ag-cell-first-right-pinned")), t;
    }, n.prototype.processClassesFromGridOptions = function(e, t) {
      var i = [], r = function(u) {
        typeof u == "string" ? i.push(u) : Array.isArray(u) && u.forEach(function(c) {
          return i.push(c);
        });
      }, o = this.gridOptionsWrapper.getRowClass();
      if (o) {
        if (typeof o == "function")
          return console.warn("AG Grid: rowClass should not be a function, please use getRowClass instead"), [];
        r(o);
      }
      var s = this.gridOptionsWrapper.getRowClassFunc();
      if (s) {
        var a = {
          data: e.data,
          node: e,
          rowIndex: e.rowIndex,
          $scope: t,
          api: this.gridOptionsWrapper.getApi(),
          columnApi: this.gridOptionsWrapper.getColumnApi(),
          context: this.gridOptionsWrapper.getContext()
        }, l = s(a);
        r(l);
      }
      return i;
    }, n.prototype.preProcessRowClassRules = function(e, t) {
      var i = [];
      return this.processRowClassRules(e, t, function(r) {
        i.push(r);
      }, function(r) {
      }), i;
    }, n.prototype.processRowClassRules = function(e, t, i, r) {
      var o = {
        data: e.data,
        node: e,
        rowIndex: e.rowIndex,
        api: this.gridOptionsWrapper.getApi(),
        columnApi: this.gridOptionsWrapper.getColumnApi(),
        $scope: t,
        context: this.gridOptionsWrapper.getContext()
      };
      this.stylingService.processClassRules(this.gridOptionsWrapper.rowClassRules(), o, i, r);
    }, n.prototype.calculateRowLevel = function(e) {
      return e.group ? e.level : e.parent ? e.parent.level + 1 : 0;
    }, zL([
      T("stylingService")
    ], n.prototype, "stylingService", void 0), zL([
      T("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), n = zL([
      qe("rowCssClassCalculator")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var BQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), oR = (
  /** @class */
  function(n) {
    BQ(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.state = e.STATE_WAITING_TO_LOAD, i.version = 0, i.id = t, i;
    }
    return e.prototype.getId = function() {
      return this.id;
    }, e.prototype.load = function() {
      this.state = e.STATE_LOADING, this.loadFromDatasource();
    }, e.prototype.getVersion = function() {
      return this.version;
    }, e.prototype.setStateWaitingToLoad = function() {
      this.version++, this.state = e.STATE_WAITING_TO_LOAD;
    }, e.prototype.getState = function() {
      return this.state;
    }, e.prototype.pageLoadFailed = function(t) {
      var i = this.isRequestMostRecentAndLive(t);
      i && (this.state = e.STATE_FAILED, this.processServerFail()), this.dispatchLoadCompleted(!1);
    }, e.prototype.success = function(t, i) {
      this.successCommon(t, i);
    }, e.prototype.pageLoaded = function(t, i, r) {
      this.successCommon(t, { rowData: i, rowCount: r });
    }, e.prototype.isRequestMostRecentAndLive = function(t) {
      var i = t === this.version, r = this.isAlive();
      return i && r;
    }, e.prototype.successCommon = function(t, i) {
      this.dispatchLoadCompleted();
      var r = this.isRequestMostRecentAndLive(t);
      r && (this.state = e.STATE_LOADED, this.processServerResult(i));
    }, e.prototype.dispatchLoadCompleted = function(t) {
      t === void 0 && (t = !0);
      var i = {
        type: e.EVENT_LOAD_COMPLETE,
        success: t,
        block: this
      };
      this.dispatchEvent(i);
    }, e.EVENT_LOAD_COMPLETE = "loadComplete", e.STATE_WAITING_TO_LOAD = "needsLoading", e.STATE_LOADING = "loading", e.STATE_LOADED = "loaded", e.STATE_FAILED = "failed", e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var HQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), jL = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, GQ = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, X4 = (
  /** @class */
  function(n) {
    HQ(e, n);
    function e() {
      var i = n !== null && n.apply(this, arguments) || this;
      return i.activeBlockLoadsCount = 0, i.blocks = [], i.active = !0, i;
    }
    t = e, e.prototype.postConstruct = function() {
      this.maxConcurrentRequests = this.gridOptionsWrapper.getMaxConcurrentDatasourceRequests();
      var i = this.gridOptionsWrapper.getBlockLoadDebounceMillis();
      i && i > 0 && (this.checkBlockToLoadDebounce = Ad.debounce(this.performCheckBlocksToLoad.bind(this), i));
    }, e.prototype.setBeans = function(i) {
      this.logger = i.create("RowNodeBlockLoader");
    }, e.prototype.addBlock = function(i) {
      this.blocks.push(i), i.addEventListener(oR.EVENT_LOAD_COMPLETE, this.loadComplete.bind(this)), this.checkBlockToLoad();
    }, e.prototype.removeBlock = function(i) {
      Ad.removeFromArray(this.blocks, i);
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this), this.active = !1;
    }, e.prototype.loadComplete = function() {
      this.activeBlockLoadsCount--, this.checkBlockToLoad(), this.activeBlockLoadsCount == 0 && this.dispatchEvent({ type: t.BLOCK_LOADER_FINISHED_EVENT });
    }, e.prototype.checkBlockToLoad = function() {
      this.checkBlockToLoadDebounce ? this.checkBlockToLoadDebounce() : this.performCheckBlocksToLoad();
    }, e.prototype.performCheckBlocksToLoad = function() {
      if (this.active) {
        if (this.printCacheStatus(), this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
          this.logger.log("checkBlockToLoad: max loads exceeded");
          return;
        }
        var i = null;
        this.blocks.forEach(function(r) {
          r.getState() === oR.STATE_WAITING_TO_LOAD && (i = r);
        }), i && (i.load(), this.activeBlockLoadsCount++, this.printCacheStatus());
      }
    }, e.prototype.getBlockState = function() {
      var i = {};
      return this.blocks.forEach(function(r) {
        var o = r.getBlockStateJson(), s = o.id, a = o.state;
        i[s] = a;
      }), i;
    }, e.prototype.printCacheStatus = function() {
      this.logger.isLogging() && this.logger.log("printCacheStatus: activePageLoadsCount = " + this.activeBlockLoadsCount + "," + (" blocks = " + JSON.stringify(this.getBlockState())));
    }, e.prototype.isLoading = function() {
      return this.activeBlockLoadsCount > 0;
    };
    var t;
    return e.BLOCK_LOADER_FINISHED_EVENT = "blockLoaderFinished", jL([
      Le
    ], e.prototype, "postConstruct", null), jL([
      GQ(0, Eo("loggerFactory"))
    ], e.prototype, "setBeans", null), e = t = jL([
      qe("rowNodeBlockLoader")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var XC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Z4 = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.doFullSort = function(e, t) {
      var i = function(o, s) {
        return { currentPos: s, rowNode: o };
      }, r = e.map(i);
      return r.sort(this.compareRowNodes.bind(this, t)), r.map(function(o) {
        return o.rowNode;
      });
    }, n.prototype.compareRowNodes = function(e, t, i) {
      for (var r = t.rowNode, o = i.rowNode, s = 0, a = e.length; s < a; s++) {
        var l = e[s], u = l.sort === Z.SORT_DESC, c = this.getValue(r, l.column), h = this.getValue(o, l.column), d = void 0, f = this.getComparator(l, r);
        f ? d = f(c, h, r, o, u) : d = Ad.defaultComparator(c, h, this.gridOptionsWrapper.isAccentedSort());
        var p = !isNaN(d);
        if (p && d !== 0)
          return l.sort === Z.SORT_ASC ? d : d * -1;
      }
      return t.currentPos - i.currentPos;
    }, n.prototype.getComparator = function(e, t) {
      var i = e.column, r = i.getColDef().comparator;
      if (r != null)
        return r;
      if (t.rowGroupColumn)
        return t.rowGroupColumn.getColDef().comparator;
      if (i.getColDef().showRowGroup) {
        var o = !t.group && i.getColDef().field;
        if (o) {
          var s = this.columnModel.getPrimaryColumn(o);
          if (s)
            return s.getColDef().comparator;
        }
      }
    }, n.prototype.getValue = function(e, t) {
      return this.valueService.getValue(t, e, !1, !1);
    }, XC([
      T("gridOptionsWrapper")
    ], n.prototype, "gridOptionsWrapper", void 0), XC([
      T("valueService")
    ], n.prototype, "valueService", void 0), XC([
      T("columnModel")
    ], n.prototype, "columnModel", void 0), n = XC([
      qe("rowNodeSorter")
    ], n), n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var UQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), zQ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Q4 = (
  /** @class */
  function(n) {
    UQ(e, n);
    function e() {
      var i = n !== null && n.apply(this, arguments) || this;
      return i.ready = !1, i.readyCallbacks = [], i;
    }
    t = e, e.prototype.checkReady = function() {
      if (this.ready = this.gridCtrl != null && this.gridBodyCtrl != null && this.centerRowContainerCtrl != null && this.leftRowContainerCtrl != null && this.rightRowContainerCtrl != null && this.bottomCenterRowContainerCtrl != null && this.bottomLeftRowContainerCtrl != null && this.bottomRightRowContainerCtrl != null && this.topCenterRowContainerCtrl != null && this.topLeftRowContainerCtrl != null && this.topRightRowContainerCtrl != null && this.centerHeaderRowContainerCtrl != null && this.leftHeaderRowContainerCtrl != null && this.rightHeaderRowContainerCtrl != null && this.fakeHScrollCtrl != null && this.gridHeaderCtrl != null, this.ready) {
        var i = this.createReadyParams();
        this.readyCallbacks.forEach(function(r) {
          return r(i);
        }), this.readyCallbacks.length = 0;
      }
    }, e.prototype.whenReady = function(i) {
      this.ready ? i(this.createReadyParams()) : this.readyCallbacks.push(i);
    }, e.prototype.createReadyParams = function() {
      return {
        centerRowContainerCtrl: this.centerRowContainerCtrl,
        leftRowContainerCtrl: this.leftRowContainerCtrl,
        rightRowContainerCtrl: this.rightRowContainerCtrl,
        bottomCenterRowContainerCtrl: this.bottomCenterRowContainerCtrl,
        bottomLeftRowContainerCtrl: this.bottomLeftRowContainerCtrl,
        bottomRightRowContainerCtrl: this.bottomRightRowContainerCtrl,
        topCenterRowContainerCtrl: this.topCenterRowContainerCtrl,
        topLeftRowContainerCtrl: this.topLeftRowContainerCtrl,
        topRightRowContainerCtrl: this.topRightRowContainerCtrl,
        centerHeaderRowContainerCtrl: this.centerHeaderRowContainerCtrl,
        leftHeaderRowContainerCtrl: this.leftHeaderRowContainerCtrl,
        rightHeaderRowContainerCtrl: this.rightHeaderRowContainerCtrl,
        fakeHScrollCtrl: this.fakeHScrollCtrl,
        gridBodyCtrl: this.gridBodyCtrl,
        gridCtrl: this.gridCtrl,
        gridHeaderCtrl: this.gridHeaderCtrl
      };
    }, e.prototype.registerFakeHScrollCtrl = function(i) {
      this.fakeHScrollCtrl = i, this.checkReady();
    }, e.prototype.registerGridHeaderCtrl = function(i) {
      this.gridHeaderCtrl = i, this.checkReady();
    }, e.prototype.registerCenterRowContainerCtrl = function(i) {
      this.centerRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerLeftRowContainerCtrl = function(i) {
      this.leftRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerRightRowContainerCtrl = function(i) {
      this.rightRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerTopCenterRowContainerCtrl = function(i) {
      this.topCenterRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerTopLeftRowContainerCon = function(i) {
      this.topLeftRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerTopRightRowContainerCtrl = function(i) {
      this.topRightRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerBottomCenterRowContainerCtrl = function(i) {
      this.bottomCenterRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerBottomLeftRowContainerCtrl = function(i) {
      this.bottomLeftRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerBottomRightRowContainerCtrl = function(i) {
      this.bottomRightRowContainerCtrl = i, this.checkReady();
    }, e.prototype.registerHeaderContainer = function(i, r) {
      switch (r) {
        case Z.PINNED_LEFT:
          this.leftHeaderRowContainerCtrl = i;
          break;
        case Z.PINNED_RIGHT:
          this.rightHeaderRowContainerCtrl = i;
          break;
        default:
          this.centerHeaderRowContainerCtrl = i;
          break;
      }
      this.checkReady();
    }, e.prototype.registerGridBodyCtrl = function(i) {
      this.gridBodyCtrl = i, this.checkReady();
    }, e.prototype.registerGridCtrl = function(i) {
      this.gridCtrl = i, this.checkReady();
    }, e.prototype.getFakeHScrollCtrl = function() {
      return this.fakeHScrollCtrl;
    }, e.prototype.getGridHeaderCtrl = function() {
      return this.gridHeaderCtrl;
    }, e.prototype.getGridCtrl = function() {
      return this.gridCtrl;
    }, e.prototype.getCenterRowContainerCtrl = function() {
      return this.centerRowContainerCtrl;
    }, e.prototype.getTopCenterRowContainerCtrl = function() {
      return this.topCenterRowContainerCtrl;
    }, e.prototype.getBottomCenterRowContainerCtrl = function() {
      return this.bottomCenterRowContainerCtrl;
    }, e.prototype.getGridBodyCtrl = function() {
      return this.gridBodyCtrl;
    }, e.prototype.getHeaderRowContainerCtrls = function() {
      return [this.leftHeaderRowContainerCtrl, this.rightHeaderRowContainerCtrl, this.centerHeaderRowContainerCtrl];
    }, e.prototype.getHeaderRowContainerCtrl = function(i) {
      switch (i) {
        case Z.PINNED_LEFT:
          return this.leftHeaderRowContainerCtrl;
        case Z.PINNED_RIGHT:
          return this.rightHeaderRowContainerCtrl;
        default:
          return this.centerHeaderRowContainerCtrl;
      }
    };
    var t;
    return e.NAME = "ctrlsService", e = t = zQ([
      qe(t.NAME)
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var jQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), $Q = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, KQ = (
  /** @class */
  function(n) {
    jQ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.registry = {}, t;
    }
    return e.prototype.register = function(t) {
      this.registry[t.controllerName] = t.controllerClass;
    }, e.prototype.getInstance = function(t) {
      var i = this.registry[t];
      if (i != null)
        return new i();
    }, e = $Q([
      qe("ctrlsFactory")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var qQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ZC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, YQ = (
  /** @class */
  function(n) {
    qQ(e, n);
    function e() {
      return n.call(this) || this;
    }
    return e.prototype.setComp = function(t, i, r, o) {
      this.view = t, this.eViewport = r, this.eContainer = o, this.eGui = i, this.addManagedListener(this.eventService, F.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.onScrollVisibilityChanged();
      var s = this.setFakeHScrollSpacerWidths.bind(this);
      this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, s), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, s), this.addManagedListener(this.gridOptionsWrapper, He.PROP_DOM_LAYOUT, s), this.setFakeHScrollSpacerWidths(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()), this.ctrlsService.registerFakeHScrollCtrl(this);
    }, e.prototype.addActiveListenerToggles = function() {
      var t = this, i = ["mouseenter", "mousedown", "touchstart"], r = ["mouseleave", "mouseup", "touchend"];
      i.forEach(function(o) {
        return t.addManagedListener(t.eGui, o, function() {
          return t.view.addOrRemoveCssClass("ag-scrollbar-active", !0);
        });
      }), r.forEach(function(o) {
        return t.addManagedListener(t.eGui, o, function() {
          return t.view.addOrRemoveCssClass("ag-scrollbar-active", !1);
        });
      });
    }, e.prototype.postConstruct = function() {
      this.enableRtl = this.gridOptionsWrapper.isEnableRtl(), this.invisibleScrollbar = UB();
    }, e.prototype.onScrollVisibilityChanged = function() {
      this.setScrollVisible(), this.setFakeHScrollSpacerWidths();
    }, e.prototype.hideAndShowInvisibleScrollAsNeeded = function() {
      var t = this;
      this.addManagedListener(this.eventService, F.EVENT_BODY_SCROLL, function(i) {
        i.direction === "horizontal" && t.view.addOrRemoveCssClass("ag-scrollbar-scrolling", !0);
      }), this.addManagedListener(this.eventService, F.EVENT_BODY_SCROLL_END, function() {
        return t.view.addOrRemoveCssClass("ag-scrollbar-scrolling", !1);
      });
    }, e.prototype.setFakeHScrollSpacerWidths = function() {
      var t = this.scrollVisibleService.isVerticalScrollShowing(), i = this.columnModel.getDisplayedColumnsRightWidth(), r = !this.enableRtl && t, o = this.gridOptionsWrapper.getScrollbarWidth();
      r && (i += o), this.view.setRightSpacerFixedWidth(i), this.view.includeRightSpacerScrollerCss("ag-scroller-corner", i <= o);
      var s = this.columnModel.getDisplayedColumnsLeftWidth(), a = this.enableRtl && t;
      a && (s += o), this.view.setLeftSpacerFixedWidth(s), this.view.includeLeftSpacerScrollerCss("ag-scroller-corner", s <= o);
    }, e.prototype.setScrollVisible = function() {
      var t = this.scrollVisibleService.isHorizontalScrollShowing(), i = this.invisibleScrollbar, r = this.gridOptionsWrapper.isSuppressHorizontalScroll(), o = t && this.gridOptionsWrapper.getScrollbarWidth() || 0, s = o === 0 && i ? 15 : o, a = r ? 0 : s;
      this.view.addOrRemoveCssClass("ag-scrollbar-invisible", i), this.view.setHeight(a), this.view.setViewportHeight(a), this.view.setContainerHeight(a);
    }, e.prototype.getViewport = function() {
      return this.eViewport;
    }, e.prototype.getContainer = function() {
      return this.eContainer;
    }, ZC([
      T("scrollVisibleService")
    ], e.prototype, "scrollVisibleService", void 0), ZC([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), ZC([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), ZC([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var XQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), xm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, ZQ = (
  /** @class */
  function(n) {
    XQ(e, n);
    function e() {
      return n.call(this, e.TEMPLATE) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = {
        addOrRemoveCssClass: function(o, s) {
          return t.addOrRemoveCssClass(o, s);
        },
        setHeight: function(o) {
          return yd(t.getGui(), o);
        },
        setContainerHeight: function(o) {
          return yd(t.eContainer, o);
        },
        setViewportHeight: function(o) {
          return yd(t.eViewport, o);
        },
        setRightSpacerFixedWidth: function(o) {
          return Yl(t.eRightSpacer, o);
        },
        setLeftSpacerFixedWidth: function(o) {
          return Yl(t.eLeftSpacer, o);
        },
        includeLeftSpacerScrollerCss: function(o, s) {
          return t.eLeftSpacer.classList.toggle(o, s);
        },
        includeRightSpacerScrollerCss: function(o, s) {
          return t.eRightSpacer.classList.toggle(o, s);
        }
      }, r = this.createManagedBean(new YQ());
      r.setComp(i, this.getGui(), this.eViewport, this.eContainer), this.createManagedBean(new Ux(function(o) {
        return t.eContainer.style.width = o + "px";
      }));
    }, e.TEMPLATE = `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" ref="eRightSpacer"></div>
        </div>`, xm([
      ve("eLeftSpacer")
    ], e.prototype, "eLeftSpacer", void 0), xm([
      ve("eRightSpacer")
    ], e.prototype, "eRightSpacer", void 0), xm([
      ve("eViewport")
    ], e.prototype, "eViewport", void 0), xm([
      ve("eContainer")
    ], e.prototype, "eContainer", void 0), xm([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var QQ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), $L = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, JQ = (
  /** @class */
  function(n) {
    QQ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.postConstruct = function() {
      var t = this.checkContainerWidths.bind(this);
      this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_CHANGED, t), this.addManagedListener(this.eventService, F.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, t), this.addManagedListener(this.gridOptionsWrapper, He.PROP_DOM_LAYOUT, t);
    }, e.prototype.checkContainerWidths = function() {
      var t = this.gridOptionsWrapper.getDomLayout() === Z.DOM_LAYOUT_PRINT, i = t ? 0 : this.columnModel.getDisplayedColumnsLeftWidth(), r = t ? 0 : this.columnModel.getDisplayedColumnsRightWidth();
      i != this.leftWidth && (this.leftWidth = i, this.eventService.dispatchEvent({ type: F.EVENT_LEFT_PINNED_WIDTH_CHANGED })), r != this.rightWidth && (this.rightWidth = r, this.eventService.dispatchEvent({ type: F.EVENT_RIGHT_PINNED_WIDTH_CHANGED }));
    }, e.prototype.getPinnedRightWidth = function() {
      return this.rightWidth;
    }, e.prototype.getPinnedLeftWidth = function() {
      return this.leftWidth;
    }, $L([
      T("columnModel")
    ], e.prototype, "columnModel", void 0), $L([
      Le
    ], e.prototype, "postConstruct", null), e = $L([
      qe("pinnedWidthService")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var eJ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), tJ = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, J4 = (
  /** @class */
  function(n) {
    eJ(e, n);
    function e(t) {
      var i = n.call(
        this,
        /* html */
        '<div class="ag-popup-editor" tabindex="-1"/>'
      ) || this;
      return i.params = t, i;
    }
    return e.prototype.postConstruct = function() {
      this.gridOptionsWrapper.setDomData(this.getGui(), e.DOM_KEY_POPUP_EDITOR_WRAPPER, !0), this.addKeyDownListener();
    }, e.prototype.addKeyDownListener = function() {
      var t = this, i = this.getGui(), r = this.params, o = function(s) {
        zw(t.gridOptionsWrapper, s, r.node, r.column, !0) || r.onKeyDown(s);
      };
      this.addManagedListener(i, "keydown", o);
    }, e.DOM_KEY_POPUP_EDITOR_WRAPPER = "popupEditorWrapper", tJ([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Sg)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var iJ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), sR = globalThis && globalThis.__assign || function() {
  return sR = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, sR.apply(this, arguments);
}, eG = (
  /** @class */
  function(n) {
    iJ(e, n);
    function e(t, i, r, o, s, a) {
      var l = n.call(this) || this;
      l.scope = null, l.rendererVersion = 0, l.editorVersion = 0, l.scope = t, l.beans = i, l.column = r.getColumn(), l.rowNode = r.getRowNode(), l.rowCtrl = r.getRowCtrl(), l.eRow = s, l.setTemplate(
        /* html */
        '<div comp-id="' + l.getCompId() + '"/>'
      );
      var u = l.getGui();
      l.forceWrapper = r.isForceWrapper(), l.refreshWrapper(!1);
      var c = function(d, f, p) {
        var g = p || u;
        f != null && f != "" ? g.setAttribute(d, f) : g.removeAttribute(d);
      }, h = {
        addOrRemoveCssClass: function(d, f) {
          return l.addOrRemoveCssClass(d, f);
        },
        setUserStyles: function(d) {
          return Sx(u, d);
        },
        getFocusableElement: function() {
          return l.getFocusableElement();
        },
        setTabIndex: function(d) {
          return c("tabindex", d.toString());
        },
        setRole: function(d) {
          return Do(u, d);
        },
        setColId: function(d) {
          return c("col-id", d);
        },
        setTitle: function(d) {
          return c("title", d);
        },
        setIncludeSelection: function(d) {
          return l.includeSelection = d;
        },
        setIncludeRowDrag: function(d) {
          return l.includeRowDrag = d;
        },
        setIncludeDndSource: function(d) {
          return l.includeDndSource = d;
        },
        setRenderDetails: function(d, f, p) {
          return l.setRenderDetails(d, f, p);
        },
        setEditDetails: function(d, f, p) {
          return l.setEditDetails(d, f, p);
        },
        getCellEditor: function() {
          return l.cellEditor || null;
        },
        getCellRenderer: function() {
          return l.cellRenderer || null;
        },
        getParentOfValue: function() {
          return l.getParentOfValue();
        }
      };
      return l.cellCtrl = r, r.setComp(h, l.scope, l.getGui(), l.eCellWrapper, o, a), l;
    }
    return e.prototype.getParentOfValue = function() {
      return this.eCellValue ? this.eCellValue : this.eCellWrapper ? this.eCellWrapper : this.getGui();
    }, e.prototype.setRenderDetails = function(t, i, r) {
      var o = this.cellEditor && !this.cellEditorPopupWrapper;
      if (!o) {
        this.firstRender = this.firstRender == null;
        var s = this.isUsingAngular1Template(), a = this.refreshWrapper(!1);
        if (t) {
          var l = r || a, u = l ? !1 : this.refreshCellRenderer(t);
          u || (this.destroyRenderer(), this.createCellRendererInstance(t));
        } else
          this.destroyRenderer(), s ? this.insertValueUsingAngular1Template() : this.insertValueWithoutCellRenderer(i);
      }
    }, e.prototype.setEditDetails = function(t, i, r) {
      t ? this.createCellEditorInstance(t, i, r) : this.destroyEditor();
    }, e.prototype.removeControls = function() {
      this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp), this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp), this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp);
    }, e.prototype.refreshWrapper = function(t) {
      var i = this.includeRowDrag || this.includeDndSource || this.includeSelection, r = i || this.forceWrapper, o = r && this.eCellWrapper == null;
      o && (this.eCellWrapper = Tr('<div class="ag-cell-wrapper" role="presentation"></div>'), this.getGui().appendChild(this.eCellWrapper));
      var s = !r && this.eCellWrapper != null;
      s && (za(this.eCellWrapper), this.eCellWrapper = void 0), this.addOrRemoveCssClass("ag-cell-value", !r);
      var a = !t && r, l = a && this.eCellValue == null;
      l && (this.eCellValue = Tr('<span class="ag-cell-value" role="presentation"></span>'), this.eCellWrapper.appendChild(this.eCellValue));
      var u = !a && this.eCellValue != null;
      u && (za(this.eCellValue), this.eCellValue = void 0);
      var c = o || s || l || u;
      return c && this.removeControls(), !t && i && this.addControls(), c;
    }, e.prototype.addControls = function() {
      var t = this.eCellValue.id = "cell-" + this.getCompId(), i = [];
      this.includeRowDrag && this.rowDraggingComp == null && (this.rowDraggingComp = this.cellCtrl.createRowDragComp(), this.rowDraggingComp && this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue)), this.includeDndSource && this.dndSourceComp == null && (this.dndSourceComp = this.cellCtrl.createDndSource(), this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue)), this.includeSelection && (this.checkboxSelectionComp == null && (this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox(), this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue)), i.push(this.checkboxSelectionComp.getCheckboxId())), i.push(t), IS(this.getGui(), i.join(" "));
    }, e.prototype.createCellEditorInstance = function(t, i, r) {
      var o = this, s = this.editorVersion, a = t.newAgStackInstance();
      if (a) {
        var l = t.params;
        a.then(function(c) {
          return o.afterCellEditorCreated(s, c, l, i, r);
        });
        var u = Je(this.cellEditor);
        u && l.cellStartedEdit && this.cellCtrl.focusCell(!0);
      }
    }, e.prototype.insertValueWithoutCellRenderer = function(t) {
      var i = this.getParentOfValue();
      Ls(i);
      var r = t != null ? ql(t) : null;
      r != null && (i.innerHTML = r);
    }, e.prototype.insertValueUsingAngular1Template = function() {
      var t = this, i = this.column.getColDef(), r = i.template, o = i.templateUrl, s;
      if (r != null ? s = r : o != null && (s = this.beans.templateService.getTemplate(o, function() {
        return t.cellCtrl.refreshCell({ forceRefresh: !0 });
      })), s != null) {
        var a = this.getParentOfValue();
        a.innerHTML = s, this.updateAngular1ScopeAndCompile();
      }
    }, e.prototype.destroyEditorAndRenderer = function() {
      this.destroyRenderer(), this.destroyEditor();
    }, e.prototype.destroyRenderer = function() {
      var t = this.beans.context;
      this.cellRenderer = t.destroyBean(this.cellRenderer), za(this.cellRendererGui), this.cellRendererGui = null, this.rendererVersion++;
    }, e.prototype.destroyEditor = function() {
      var t = this.beans.context;
      this.hideEditorPopup && this.hideEditorPopup(), this.hideEditorPopup = void 0, this.cellEditor = t.destroyBean(this.cellEditor), this.cellEditorPopupWrapper = t.destroyBean(this.cellEditorPopupWrapper), za(this.cellEditorGui), this.cellEditorGui = null, this.editorVersion++;
    }, e.prototype.refreshCellRenderer = function(t) {
      if (this.cellRenderer == null || this.cellRenderer.refresh == null || this.cellRendererClass !== t.componentClass)
        return !1;
      var i = this.cellRenderer.refresh(t.params);
      return i === !0 || i === void 0;
    }, e.prototype.createCellRendererInstance = function(t) {
      var i = this, r = this.beans.gridOptionsWrapper.isAngularCompileRows(), o = this.beans.gridOptionsWrapper.isSuppressAnimationFrame(), s = !r && !o, a = this.rendererVersion, l = t.componentClass, u = function() {
        var c = i.rendererVersion !== a || !i.isAlive();
        if (!c) {
          var h = t.newAgStackInstance(), d = i.afterCellRendererCreated.bind(i, a, l);
          h && h.then(d);
        }
      };
      s && this.firstRender ? this.beans.animationFrameService.createTask(u, this.rowNode.rowIndex, "createTasksP2") : u();
    }, e.prototype.isUsingAngular1Template = function() {
      var t = this.column.getColDef(), i = t.template != null || t.templateUrl != null;
      return i;
    }, e.prototype.getCtrl = function() {
      return this.cellCtrl;
    }, e.prototype.getRowCtrl = function() {
      return this.rowCtrl;
    }, e.prototype.getCellRenderer = function() {
      return this.cellRenderer;
    }, e.prototype.getCellEditor = function() {
      return this.cellEditor;
    }, e.prototype.afterCellRendererCreated = function(t, i, r) {
      var o = !this.isAlive() || t !== this.rendererVersion;
      if (o) {
        this.beans.context.destroyBean(r);
        return;
      }
      if (this.cellRenderer = r, this.cellRendererClass = i, this.cellRendererGui = this.cellRenderer.getGui(), this.cellRendererGui != null) {
        var s = this.getParentOfValue();
        Ls(s), s.appendChild(this.cellRendererGui), this.updateAngular1ScopeAndCompile();
      }
    }, e.prototype.afterCellEditorCreated = function(t, i, r, o, s) {
      var a = t !== this.editorVersion;
      if (a) {
        this.beans.context.destroyBean(i);
        return;
      }
      var l = i.isCancelBeforeStart && i.isCancelBeforeStart();
      if (l) {
        this.beans.context.destroyBean(i), this.cellCtrl.stopEditing();
        return;
      }
      if (!i.getGui) {
        console.warn("AG Grid: cellEditor for column " + this.column.getId() + " is missing getGui() method"), this.beans.context.destroyBean(i);
        return;
      }
      this.cellEditor = i, this.cellEditorGui = i.getGui();
      var u = o || i.isPopup !== void 0 && i.isPopup();
      u ? (o || this.cellCtrl.hackSayEditingInPopup(), this.addPopupCellEditor(r, s)) : this.addInCellEditor(), i.afterGuiAttached && i.afterGuiAttached();
    }, e.prototype.addInCellEditor = function() {
      var t = this.getGui(), i = this.beans.gridOptionsWrapper.getDocument();
      if (t.contains(i.activeElement) && t.focus(), this.destroyRenderer(), this.refreshWrapper(!0), this.clearParentOfValue(), this.cellEditorGui) {
        var r = this.getParentOfValue();
        r.appendChild(this.cellEditorGui);
      }
    }, e.prototype.addPopupCellEditor = function(t, i) {
      var r = this;
      this.beans.gridOptionsWrapper.isFullRowEdit() && console.warn("AG Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.");
      var o = this.cellEditor;
      this.cellEditorPopupWrapper = this.beans.context.createBean(new J4(t));
      var s = this.cellEditorPopupWrapper.getGui();
      this.cellEditorGui && s.appendChild(this.cellEditorGui);
      var a = this.beans.popupService, l = this.beans.gridOptionsWrapper.isStopEditingWhenCellsLoseFocus(), u = i ?? (o.getPopupPosition ? o.getPopupPosition() : "over"), c = {
        column: this.column,
        rowNode: this.rowNode,
        type: "popupCellEditor",
        eventSource: this.getGui(),
        ePopup: s,
        keepWithinBounds: !0
      }, h = u === "under" ? a.positionPopupUnderComponent.bind(a, c) : a.positionPopupOverComponent.bind(a, c), d = this.beans.gridOptionsWrapper.getLocaleTextFunc(), f = a.addPopup({
        modal: l,
        eChild: s,
        closeOnEsc: !0,
        closedCallback: function() {
          r.cellCtrl.onPopupEditorClosed();
        },
        anchorToElement: this.getGui(),
        positionCallback: h,
        ariaLabel: d("ariaLabelCellEditor", "Cell Editor")
      });
      f && (this.hideEditorPopup = f.hideFunc);
    }, e.prototype.detach = function() {
      this.eRow.removeChild(this.getGui());
    }, e.prototype.destroy = function() {
      this.cellCtrl.stopEditing(), this.destroyEditorAndRenderer(), this.removeControls(), this.angularCompiledElement && (this.angularCompiledElement.remove(), this.angularCompiledElement = void 0), n.prototype.destroy.call(this);
    }, e.prototype.clearParentOfValue = function() {
      var t = this.getGui(), i = this.beans.gridOptionsWrapper.getDocument();
      t.contains(i.activeElement) && t.focus({
        preventScroll: !0
      }), Ls(this.getParentOfValue());
    }, e.prototype.updateAngular1ScopeAndCompile = function() {
      if (this.beans.gridOptionsWrapper.isAngularCompileRows() && this.scope) {
        this.scope.data = sR({}, this.rowNode.data), this.angularCompiledElement && this.angularCompiledElement.remove();
        var t = this.getParentOfValue();
        this.angularCompiledElement = this.beans.$compile(t.children)(this.scope), this.beans.ctrlsService.getGridBodyCtrl().requestAngularApply();
      }
    }, e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var nJ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), rJ = (
  /** @class */
  function(n) {
    nJ(e, n);
    function e(t, i, r) {
      var o = n.call(this) || this;
      o.cellComps = {}, o.beans = i, o.rowCtrl = t, o.setTemplate(
        /* html */
        '<div comp-id="' + o.getCompId() + '" style="' + o.getInitialStyle() + '"/>'
      );
      var s = o.getGui(), a = s.style, l = {
        setDomOrder: function(u) {
          return o.domOrder = u;
        },
        setCellCtrls: function(u) {
          return o.setCellCtrls(u);
        },
        showFullWidth: function(u) {
          return o.showFullWidth(u);
        },
        getFullWidthCellRenderer: function() {
          return o.getFullWidthCellRenderer();
        },
        addOrRemoveCssClass: function(u, c) {
          return o.addOrRemoveCssClass(u, c);
        },
        setUserStyles: function(u) {
          return Sx(s, u);
        },
        setTop: function(u) {
          return a.top = u;
        },
        setTransform: function(u) {
          return a.transform = u;
        },
        setRowIndex: function(u) {
          return s.setAttribute("row-index", u);
        },
        setRole: function(u) {
          return Do(s, u);
        },
        setRowId: function(u) {
          return s.setAttribute("row-id", u);
        },
        setRowBusinessKey: function(u) {
          return s.setAttribute("row-business-key", u);
        },
        setTabIndex: function(u) {
          return s.setAttribute("tabindex", u.toString());
        }
      };
      return t.setComp(l, o.getGui(), r), o;
    }
    return e.prototype.getInitialStyle = function() {
      var t = this.rowCtrl.getInitialTransform(), i = this.rowCtrl.getInitialRowTop();
      return t ? "transform: " + t : "top: " + i;
    }, e.prototype.showFullWidth = function(t) {
      var i = this, r = function(s) {
        if (i.isAlive()) {
          var a = s.getGui();
          i.getGui().appendChild(a), i.rowCtrl.setupDetailRowAutoHeight(a), i.setFullWidthRowComp(s);
        } else
          i.beans.context.destroyBean(s);
      }, o = t.newAgStackInstance();
      o && o.then(r);
    }, e.prototype.setCellCtrls = function(t) {
      var i = this, r = Object.assign({}, this.cellComps);
      t.forEach(function(s) {
        var a = s.getInstanceId(), l = i.cellComps[a];
        l == null ? i.newCellComp(s) : r[a] = null;
      });
      var o = Ja(r).filter(function(s) {
        return s != null;
      });
      this.destroyCells(o), this.ensureDomOrder(t);
    }, e.prototype.ensureDomOrder = function(t) {
      var i = this;
      if (this.domOrder) {
        var r = [];
        t.forEach(function(o) {
          var s = i.cellComps[o.getInstanceId()];
          s && r.push(s.getGui());
        }), bx(this.getGui(), r);
      }
    }, e.prototype.newCellComp = function(t) {
      var i = new eG(this.rowCtrl.getScope(), this.beans, t, this.rowCtrl.isPrintLayout(), this.getGui(), this.rowCtrl.isEditing());
      this.cellComps[t.getInstanceId()] = i, this.getGui().appendChild(i.getGui());
    }, e.prototype.destroy = function() {
      n.prototype.destroy.call(this), this.destroyAllCells();
    }, e.prototype.destroyAllCells = function() {
      var t = Ja(this.cellComps).filter(function(i) {
        return i != null;
      });
      this.destroyCells(t);
    }, e.prototype.setFullWidthRowComp = function(t) {
      var i = this;
      this.fullWidthCellRenderer && console.error("AG Grid - should not be setting fullWidthRowComponent twice"), this.fullWidthCellRenderer = t, this.addDestroyFunc(function() {
        i.fullWidthCellRenderer = i.beans.context.destroyBean(i.fullWidthCellRenderer);
      });
    }, e.prototype.getFullWidthCellRenderer = function() {
      return this.fullWidthCellRenderer;
    }, e.prototype.destroyCells = function(t) {
      var i = this;
      t.forEach(function(r) {
        if (r) {
          var o = r.getCtrl().getInstanceId();
          i.cellComps[o] === r && (r.detach(), r.destroy(), i.cellComps[o] = null);
        }
      });
    }, e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var oJ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), aR = globalThis && globalThis.__assign || function() {
  return aR = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, aR.apply(this, arguments);
}, Nf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
};
function sJ() {
  var n = Et.elementGettingCreated.getAttribute("name"), e = Xw.getRowContainerCssClasses(n), t, i = n === we.CENTER, r = n === we.TOP_CENTER || n === we.BOTTOM_CENTER;
  return i ? t = /* html */
  '<div class="' + e.wrapper + `" ref="eWrapper" role="presentation">
                <div class="` + e.viewport + `" ref="eViewport" role="presentation">
                    <div class="` + e.container + `" ref="eContainer" role="rowgroup"></div>
                </div>
            </div>` : r ? t = /* html */
  '<div class="' + e.viewport + `" ref="eViewport" role="presentation">
                <div class="` + e.container + `" ref="eContainer" role="presentation"></div>
            </div>` : t = /* html */
  '<div class="' + e.container + '" ref="eContainer" role="presentation"></div>', t;
}
var tG = (
  /** @class */
  function(n) {
    oJ(e, n);
    function e() {
      var t = n.call(this, sJ()) || this;
      return t.rowComps = {}, t.name = Et.elementGettingCreated.getAttribute("name"), t.type = HH(t.name), t;
    }
    return e.prototype.postConstruct = function() {
      var t = this, i = {
        setViewportHeight: function(o) {
          return t.eViewport.style.height = o;
        },
        setRowCtrls: function(o) {
          return t.setRowCtrls(o);
        },
        setDomOrder: function(o) {
          t.domOrder = o;
        },
        setContainerWidth: function(o) {
          return t.eContainer.style.width = o;
        }
      }, r = this.createManagedBean(new Xw(this.name));
      r.setComp(i, this.eContainer, this.eViewport, this.eWrapper);
    }, e.prototype.preDestroy = function() {
      this.setRowCtrls([]);
    }, e.prototype.setRowCtrls = function(t) {
      var i = this, r = aR({}, this.rowComps);
      this.rowComps = {}, this.lastPlacedElement = null;
      var o = function(s) {
        var a = s.getInstanceId(), l = r[a];
        if (l)
          i.rowComps[a] = l, delete r[a], i.ensureDomOrder(l.getGui());
        else {
          var u = i.newRowComp(s);
          i.rowComps[a] = u, i.appendRow(u.getGui());
        }
      };
      t.forEach(o), Ja(r).forEach(function(s) {
        i.eContainer.removeChild(s.getGui()), s.destroy();
      });
    }, e.prototype.appendRow = function(t) {
      this.domOrder ? qB(this.eContainer, t, this.lastPlacedElement) : this.eContainer.appendChild(t), this.lastPlacedElement = t;
    }, e.prototype.ensureDomOrder = function(t) {
      this.domOrder && (wx(this.eContainer, t, this.lastPlacedElement), this.lastPlacedElement = t);
    }, e.prototype.newRowComp = function(t) {
      Xw.getPinned(this.name);
      var i = new rJ(t, this.beans, this.type);
      return i;
    }, Nf([
      T("beans")
    ], e.prototype, "beans", void 0), Nf([
      ve("eViewport")
    ], e.prototype, "eViewport", void 0), Nf([
      ve("eContainer")
    ], e.prototype, "eContainer", void 0), Nf([
      ve("eWrapper")
    ], e.prototype, "eWrapper", void 0), Nf([
      Le
    ], e.prototype, "postConstruct", null), Nf([
      To
    ], e.prototype, "preDestroy", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var aJ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), QC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, lJ = (
  /** @class */
  function(n) {
    aJ(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.events = [], t;
    }
    return e.prototype.postConstruct = function() {
      this.rowModel.getType() == Z.ROW_MODEL_TYPE_CLIENT_SIDE && (this.clientSideRowModel = this.rowModel);
    }, e.prototype.dispatchExpanded = function(t) {
      var i = this;
      if (this.clientSideRowModel == null) {
        this.eventService.dispatchEvent(t);
        return;
      }
      this.events.push(t);
      var r = function() {
        i.clientSideRowModel && i.clientSideRowModel.onRowGroupOpened(), i.events.forEach(function(o) {
          return i.eventService.dispatchEvent(o);
        }), i.events = [];
      };
      this.dispatchExpandedDebounced == null && (this.dispatchExpandedDebounced = this.animationFrameService.debounce(r)), this.dispatchExpandedDebounced();
    }, QC([
      T("animationFrameService")
    ], e.prototype, "animationFrameService", void 0), QC([
      T("rowModel")
    ], e.prototype, "rowModel", void 0), QC([
      Le
    ], e.prototype, "postConstruct", null), e = QC([
      qe("rowNodeEventThrottle")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var uJ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Nm = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, iG = (
  /** @class */
  function(n) {
    uJ(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.hideActiveMenu = function() {
      this.hidePopup && this.hidePopup();
    }, e.prototype.showMenuAfterMouseEvent = function(t, i) {
      var r = this;
      this.showPopup(t, function(o) {
        r.popupService.positionPopupUnderMouseEvent({
          column: t,
          type: "columnMenu",
          mouseEvent: i,
          ePopup: o
        });
      }, i.target);
    }, e.prototype.showMenuAfterButtonClick = function(t, i, r) {
      var o = this;
      this.showPopup(t, function(s) {
        o.popupService.positionPopupUnderComponent({
          type: r,
          eventSource: i,
          ePopup: s,
          keepWithinBounds: !0,
          column: t
        });
      }, i);
    }, e.prototype.showPopup = function(t, i, r) {
      var o = this, s = this.filterManager.getOrCreateFilterWrapper(t, "COLUMN_MENU");
      if (!s)
        throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
      var a = document.createElement("div");
      Do(a, "presentation"), a.classList.add("ag-menu"), this.tabListener = this.addManagedListener(a, "keydown", function(f) {
        return o.trapFocusWithin(f, a);
      }), s.guiPromise.then(function(f) {
        return a.appendChild(f);
      });
      var l, u = r || this.ctrlsService.getGridBodyCtrl().getGui(), c = function(f) {
        t.setMenuVisible(!1, "contextMenu");
        var p = f instanceof KeyboardEvent;
        if (o.tabListener && (o.tabListener = o.tabListener()), p && r && wg(r)) {
          var g = o.focusService.findTabbableParent(r);
          g && g.focus();
        }
      }, h = this.gridOptionsWrapper.getLocaleTextFunc(), d = this.popupService.addPopup({
        modal: !0,
        eChild: a,
        closeOnEsc: !0,
        closedCallback: c,
        positionCallback: function() {
          return i(a);
        },
        anchorToElement: u,
        ariaLabel: h("ariaLabelColumnMenu", "Column Menu")
      });
      d && (this.hidePopup = l = d.hideFunc), s.filterPromise.then(function(f) {
        i(a), f.afterGuiAttached && f.afterGuiAttached({ container: "columnMenu", hidePopup: l });
      }), t.setMenuVisible(!0, "contextMenu");
    }, e.prototype.trapFocusWithin = function(t, i) {
      t.key !== _e.TAB || t.defaultPrevented || this.focusService.findNextFocusableElement(i, !1, t.shiftKey) || (t.preventDefault(), this.focusService.focusInto(i, t.shiftKey));
    }, e.prototype.isMenuEnabled = function(t) {
      return t.isFilterAllowed();
    }, Nm([
      T("filterManager")
    ], e.prototype, "filterManager", void 0), Nm([
      T("popupService")
    ], e.prototype, "popupService", void 0), Nm([
      T("focusService")
    ], e.prototype, "focusService", void 0), Nm([
      T("ctrlsService")
    ], e.prototype, "ctrlsService", void 0), e = Nm([
      qe("menuFactory")
    ], e), e;
  }(Se)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var cJ = globalThis && globalThis.__read || function(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t)
    return n;
  var i = t.call(n), r, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      o.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}, bF = globalThis && globalThis.__spread || function() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(cJ(arguments[e]));
  return n;
}, nG = (
  /** @class */
  function() {
    function n(e, t, i) {
      if (!t) {
        console.error("AG Grid: no gridOptions provided to the grid");
        return;
      }
      this.gridOptions = t, new rG().create(e, t, function(r) {
        var o = new _4(e);
        r.createBean(o);
      }, void 0, i);
    }
    return n.prototype.destroy = function() {
      this.gridOptions && this.gridOptions.api && this.gridOptions.api.destroy();
    }, n;
  }()
), rG = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.create = function(e, t, i, r, o) {
      var s = this, a = !!t.debug, l = this.getRegisteredModules(o), u = this.createBeansList(t.rowModelType, l), c = this.createProvidedBeans(e, t, o);
      if (u) {
        var h = {
          providedBeanInstances: c,
          beanClasses: u,
          debug: a
        }, d = new Qw("AG Grid", function() {
          return t.debug;
        }), f = new Qw("Context", function() {
          return h.debug;
        }), p = new EB(h, f), g = p.getBean("beans");
        this.registerModuleUserComponents(g, l), this.registerStackComponents(g, l), this.registerControllers(g, l), i(p), g.ctrlsService.whenReady(function() {
          s.setColumnsAndData(g), s.dispatchGridReadyEvent(g, t);
          var _ = gt.isRegistered(ht.EnterpriseCoreModule);
          d.log("initialised successfully, enterprise = " + _);
        }), r && r(p);
      }
    }, n.prototype.registerControllers = function(e, t) {
      t.forEach(function(i) {
        i.controllers && i.controllers.forEach(function(r) {
          return e.ctrlsFactory.register(r);
        });
      });
    }, n.prototype.registerStackComponents = function(e, t) {
      var i = this.createAgStackComponentsList(t);
      e.agStackComponentsRegistry.setupComponents(i);
    }, n.prototype.getRegisteredModules = function(e) {
      var t = e ? e.modules : null, i = gt.getRegisteredModules(), r = [], o = {};
      function s(a, l) {
        function u(c) {
          o[c.moduleName] || (o[c.moduleName] = !0, r.push(c), gt.register(c, a));
        }
        u(l), l.dependantModules && l.dependantModules.forEach(s.bind(null, a));
      }
      return t && t.forEach(s.bind(null, !0)), i && i.forEach(s.bind(null, !gt.isPackageBased())), r;
    }, n.prototype.registerModuleUserComponents = function(e, t) {
      var i = this.extractModuleEntity(t, function(r) {
        return r.userComponents ? r.userComponents : [];
      });
      i.forEach(function(r) {
        e.userComponentRegistry.registerDefaultComponent(r.componentName, r.componentClass);
      });
    }, n.prototype.createProvidedBeans = function(e, t, i) {
      var r = i ? i.frameworkOverrides : null;
      Je(r) && (r = new L4());
      var o = {
        gridOptions: t,
        eGridDiv: e,
        $scope: i ? i.$scope : null,
        $compile: i ? i.$compile : null,
        globalEventListener: i ? i.globalEventListener : null,
        frameworkOverrides: r
      };
      return i && i.providedBeanInstances && Object.assign(o, i.providedBeanInstances), o;
    }, n.prototype.createAgStackComponentsList = function(e) {
      var t = [
        { componentName: "AgCheckbox", componentClass: Kp },
        { componentName: "AgRadioButton", componentClass: E4 },
        { componentName: "AgToggleButton", componentClass: j4 },
        { componentName: "AgInputTextField", componentClass: Xx },
        { componentName: "AgInputTextArea", componentClass: V4 },
        { componentName: "AgInputNumberField", componentClass: G4 },
        { componentName: "AgInputRange", componentClass: U4 },
        { componentName: "AgSelect", componentClass: Mx },
        { componentName: "AgSlider", componentClass: B4 },
        { componentName: "AgAngleSelect", componentClass: z4 },
        { componentName: "AgColorPicker", componentClass: H4 },
        { componentName: "AgGridBody", componentClass: u4 },
        { componentName: "AgHeaderRoot", componentClass: t4 },
        { componentName: "AgPagination", componentClass: aQ },
        { componentName: "AgOverlayWrapper", componentClass: hQ },
        { componentName: "AgGroupComponent", componentClass: F4 },
        { componentName: "AgPanel", componentClass: qx },
        { componentName: "AgDialog", componentClass: Yx },
        { componentName: "AgRowContainer", componentClass: tG },
        { componentName: "AgFakeHorizontalScroll", componentClass: ZQ }
      ], i = this.extractModuleEntity(e, function(r) {
        return r.agStackComponents ? r.agStackComponents : [];
      });
      return t = t.concat(i), t;
    }, n.prototype.createBeansList = function(e, t) {
      var i = this.getRowModelClass(e, t);
      if (i) {
        var r = [
          i,
          Gx,
          $4,
          K4,
          Y4,
          HZ,
          XH,
          MH,
          qZ,
          XZ,
          M4,
          kH,
          rQ,
          g4,
          q4,
          C4,
          kB,
          ic,
          He,
          d4,
          VH,
          i4,
          MB,
          jH,
          T4,
          GH,
          c4,
          NB,
          h4,
          x4,
          P4,
          O4,
          n4,
          f4,
          FB,
          p4,
          iG,
          wo,
          BH,
          Cp,
          w4,
          N4,
          b4,
          S4,
          R4,
          D4,
          y4,
          AZ,
          FZ,
          A4,
          WZ,
          zZ,
          I4,
          MQ,
          WB,
          WQ,
          VQ,
          X4,
          Z4,
          Q4,
          JQ,
          lJ,
          KQ
        ], o = this.extractModuleEntity(t, function(a) {
          return a.beans ? a.beans : [];
        });
        r.push.apply(r, bF(o));
        var s = [];
        return r.forEach(function(a) {
          s.indexOf(a) < 0 && s.push(a);
        }), s;
      }
    }, n.prototype.extractModuleEntity = function(e, t) {
      return [].concat.apply([], bF(e.map(t)));
    }, n.prototype.setColumnsAndData = function(e) {
      var t = e.gridOptionsWrapper.getColumnDefs();
      e.columnModel.setColumnDefs(t || [], "gridInitializing"), e.rowModel.start();
    }, n.prototype.dispatchGridReadyEvent = function(e, t) {
      var i = {
        type: F.EVENT_GRID_READY,
        api: t.api,
        columnApi: t.columnApi
      };
      e.eventService.dispatchEvent(i);
    }, n.prototype.getRowModelClass = function(e, t) {
      e || (e = Z.ROW_MODEL_TYPE_CLIENT_SIDE);
      var i = {};
      t.forEach(function(o) {
        pi(o.rowModels, function(s, a) {
          i[s] = a;
        });
      });
      var r = i[e];
      if (ge(r))
        return r;
      e === Z.ROW_MODEL_TYPE_INFINITE && console.error('AG Grid: Row Model "Infinite" not found. Please ensure the ' + ht.InfiniteRowModelModule + " is registered.';"), console.error("AG Grid: could not find matching row model for rowModelType " + e), e === Z.ROW_MODEL_TYPE_VIEWPORT && console.error('AG Grid: Row Model "Viewport" not found. Please ensure the AG Grid Enterprise Module ' + ht.ViewportRowModelModule + " is registered.';"), e === Z.ROW_MODEL_TYPE_SERVER_SIDE && console.error('AG Grid: Row Model "Server Side" not found. Please ensure the AG Grid Enterprise Module ' + ht.ServerSideRowModelModule + " is registered.';"), e === Z.ROW_MODEL_TYPE_CLIENT_SIDE && console.error('AG Grid: Row Model "Client Side" not found. Please ensure the ' + ht.ClientSideRowModelModule + " is registered.';");
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function hJ(n) {
  var e = n.module("agGrid", []);
  e.directive("agGrid", function() {
    return {
      restrict: "A",
      controller: ["$element", "$scope", "$compile", "$attrs", dJ],
      scope: !0
    };
  });
}
function dJ(n, e, t, i) {
  var r, o = i.agGrid;
  if (r = e.$eval(o), !r) {
    console.warn("WARNING - grid options for AG Grid not found. Please ensure the attribute ag-grid points to a valid object on the scope");
    return;
  }
  var s = n[0], a = {
    $scope: e,
    $compile: t
  }, l = new nG(s, r, a), u = o + ".quickFilterText", c = e.$watch(u, function(h) {
    r.api.setQuickFilter(h);
  });
  e.$on("$destroy", function() {
    c(), l && l.destroy(), l = null;
  });
}
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var fJ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), JC = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, pJ = (
  /** @class */
  function(n) {
    fJ(e, n);
    function e(t) {
      var i = n.call(this, e.getTemplate(t.cssClass)) || this;
      return i.items = [], i.tabbedItemScrollMap = /* @__PURE__ */ new Map(), i.params = t, t.items && t.items.forEach(function(r) {
        return i.addItem(r);
      }), i;
    }
    return e.prototype.postConstruct = function() {
      this.createManagedBean(new nc(this.getFocusableElement(), {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this)
      }));
    }, e.getTemplate = function(t) {
      return (
        /* html */
        '<div class="ag-tabs ' + t + `">
            <div ref="eHeader" role="tablist" class="ag-tabs-header ` + (t ? t + "-header" : "") + `"></div>
            <div ref="eBody" role="presentation" class="ag-tabs-body ` + (t ? t + "-body" : "") + `"></div>
        </div>`
      );
    }, e.prototype.handleKeyDown = function(t) {
      var i = this.gridOptionsWrapper.getDocument();
      switch (t.key) {
        case _e.RIGHT:
        case _e.LEFT:
          if (!this.eHeader.contains(i.activeElement))
            return;
          var r = this.items.indexOf(this.activeItem), o = t.key === _e.RIGHT ? Math.min(r + 1, this.items.length - 1) : Math.max(r - 1, 0);
          if (r === o)
            return;
          t.preventDefault();
          var s = this.items[o];
          this.showItemWrapper(s), s.eHeaderButton.focus();
          break;
        case _e.UP:
        case _e.DOWN:
          t.stopPropagation();
          break;
      }
    }, e.prototype.onTabKeyDown = function(t) {
      if (!t.defaultPrevented) {
        var i = this, r = i.focusService, o = i.eHeader, s = i.eBody, a = i.activeItem, l = this.gridOptionsWrapper.getDocument(), u = l.activeElement;
        if (t.preventDefault(), o.contains(u))
          r.focusInto(s, t.shiftKey);
        else if (r.isFocusUnderManagedComponent(s))
          a.eHeaderButton.focus();
        else {
          var c = r.findNextFocusableElement(s, !1, t.shiftKey);
          c ? c.focus() : a.eHeaderButton.focus();
        }
      }
    }, e.prototype.setAfterAttachedParams = function(t) {
      this.afterAttachedParams = t;
    }, e.prototype.showFirstItem = function() {
      this.items.length > 0 && this.showItemWrapper(this.items[0]);
    }, e.prototype.addItem = function(t) {
      var i = document.createElement("span");
      Do(i, "tab"), i.setAttribute("tabIndex", "-1"), i.appendChild(t.title), i.classList.add("ag-tab"), this.eHeader.appendChild(i), tf(i, t.titleLabel);
      var r = {
        tabbedItem: t,
        eHeaderButton: i
      };
      this.items.push(r), i.addEventListener("click", this.showItemWrapper.bind(this, r));
    }, e.prototype.showItem = function(t) {
      var i = this.items.find(function(r) {
        return r.tabbedItem === t;
      });
      i && this.showItemWrapper(i);
    }, e.prototype.showItemWrapper = function(t) {
      var i = this, r = t.tabbedItem, o = t.eHeaderButton;
      if (this.params.onItemClicked && this.params.onItemClicked({ item: r }), this.activeItem === t) {
        SB(this.params.onActiveItemClicked);
        return;
      }
      this.lastScrollListener && (this.lastScrollListener = this.lastScrollListener()), Ls(this.eBody), r.bodyPromise.then(function(s) {
        i.eBody.appendChild(s);
        var a = !i.focusService.isKeyboardMode();
        if (i.focusService.focusInto(i.eBody, !1, a), r.afterAttachedCallback && r.afterAttachedCallback(i.afterAttachedParams), i.params.keepScrollPosition) {
          var l = r.getScrollableContainer && r.getScrollableContainer() || s;
          i.lastScrollListener = i.addManagedListener(l, "scroll", function() {
            i.tabbedItemScrollMap.set(r.name, l.scrollTop);
          });
          var u = i.tabbedItemScrollMap.get(r.name);
          u !== void 0 && setTimeout(function() {
            l.scrollTop = u;
          }, 0);
        }
      }), this.activeItem && this.activeItem.eHeaderButton.classList.remove("ag-tab-selected"), o.classList.add("ag-tab-selected"), this.activeItem = t;
    }, JC([
      T("focusService")
    ], e.prototype, "focusService", void 0), JC([
      ve("eHeader")
    ], e.prototype, "eHeader", void 0), JC([
      ve("eBody")
    ], e.prototype, "eBody", void 0), JC([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function gJ(n) {
  return new Bo(function(e) {
    var t = new XMLHttpRequest();
    t.open("GET", n.url), t.send(), t.onreadystatechange = function() {
      t.readyState === 4 && t.status === 200 && e(JSON.parse(t.responseText));
    };
  });
}
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var lR;
(function(n) {
  n.Applied = "Applied", n.StoreNotFound = "StoreNotFound", n.StoreLoading = "StoreLoading", n.StoreWaitingToLoad = "StoreWaitingToLoad", n.StoreLoadingFailed = "StoreLoadingFailed", n.StoreWrongType = "StoreWrongType", n.Cancelled = "Cancelled";
})(lR || (lR = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var mJ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), tb = globalThis && globalThis.__assign || function() {
  return tb = Object.assign || function(n) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    }
    return n;
  }, tb.apply(this, arguments);
}, SF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, oG = (
  /** @class */
  function(n) {
    mJ(e, n);
    function e(t) {
      t === void 0 && (t = 1);
      var i = n.call(
        this,
        /* html */
        '<div class="ag-menu-list" role="tree"></div>'
      ) || this;
      return i.level = t, i.menuItems = [], i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.initialiseTabGuard({
        onTabKeyDown: function(i) {
          return t.onTabKeyDown(i);
        },
        handleKeyDown: function(i) {
          return t.handleKeyDown(i);
        }
      });
    }, e.prototype.onTabKeyDown = function(t) {
      var i = this.getParentComponent(), r = i && i.getGui(), o = r && r.classList.contains("ag-focus-managed");
      o || t.preventDefault(), t.shiftKey && this.closeIfIsChild(t);
    }, e.prototype.handleKeyDown = function(t) {
      switch (t.key) {
        case _e.UP:
        case _e.RIGHT:
        case _e.DOWN:
        case _e.LEFT:
          t.preventDefault(), this.handleNavKey(t.key);
          break;
        case _e.ESCAPE:
          var i = this.findTopMenu();
          i && this.focusService.focusInto(i.getGui());
          break;
      }
    }, e.prototype.clearActiveItem = function() {
      this.activeMenuItem && (this.activeMenuItem.deactivate(), this.activeMenuItem = null);
    }, e.prototype.addMenuItems = function(t) {
      var i = this;
      t != null && t.forEach(function(r) {
        r === "separator" ? i.addSeparator() : typeof r == "string" ? console.warn("AG Grid: unrecognised menu item " + r) : i.addItem(r);
      });
    }, e.prototype.addItem = function(t) {
      var i = this, r = this.createManagedBean(new jf(tb(tb({}, t), { isAnotherSubMenuOpen: function() {
        return i.menuItems.some(function(o) {
          return o.isSubMenuOpen();
        });
      } })));
      r.setParentComponent(this), rH(r.getGui(), this.level), this.menuItems.push(r), this.appendChild(r.getGui()), this.addManagedListener(r, jf.EVENT_MENU_ITEM_SELECTED, function(o) {
        i.dispatchEvent(o);
      }), this.addManagedListener(r, jf.EVENT_MENU_ITEM_ACTIVATED, function(o) {
        i.activeMenuItem && i.activeMenuItem !== o.menuItem && i.activeMenuItem.deactivate(), i.activeMenuItem = o.menuItem;
      });
    }, e.prototype.activateFirstItem = function() {
      var t = this.menuItems.filter(function(i) {
        return !i.isDisabled();
      })[0];
      t && t.activate();
    }, e.prototype.addSeparator = function() {
      var t = (
        /* html */
        `
            <div class="ag-menu-separator" aria-hidden="true">
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
            </div>`
      );
      this.appendChild(Tr(t));
    }, e.prototype.findTopMenu = function() {
      var t = this.getParentComponent();
      if (!t && this instanceof e)
        return this;
      for (; ; ) {
        var i = t && t.getParentComponent && t.getParentComponent();
        if (!i || !(i instanceof e || i instanceof jf))
          break;
        t = i;
      }
      return t instanceof e ? t : void 0;
    }, e.prototype.handleNavKey = function(t) {
      switch (t) {
        case _e.UP:
        case _e.DOWN:
          var i = this.findNextItem(t === _e.UP);
          i && i !== this.activeMenuItem && i.activate();
          return;
      }
      var r = this.gridOptionsWrapper.isEnableRtl() ? _e.RIGHT : _e.LEFT;
      t === r ? this.closeIfIsChild() : this.openChild();
    }, e.prototype.closeIfIsChild = function(t) {
      var i = this.getParentComponent();
      i && i instanceof jf && (t && t.preventDefault(), i.closeSubMenu(), i.getGui().focus());
    }, e.prototype.openChild = function() {
      this.activeMenuItem && this.activeMenuItem.openSubMenu(!0);
    }, e.prototype.findNextItem = function(t) {
      var i = this.menuItems.filter(function(l) {
        return !l.isDisabled();
      });
      if (i.length) {
        if (!this.activeMenuItem)
          return t ? Ti(i) : i[0];
        t && i.reverse();
        for (var r, o = !1, s = 0; s < i.length; s++) {
          var a = i[s];
          if (!o) {
            a === this.activeMenuItem && (o = !0);
            continue;
          }
          r = a;
          break;
        }
        return r || this.activeMenuItem;
      }
    }, e.prototype.destroy = function() {
      this.clearActiveItem(), n.prototype.destroy.call(this);
    }, SF([
      T("focusService")
    ], e.prototype, "focusService", void 0), SF([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(A_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var vJ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _J = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, sG = (
  /** @class */
  function(n) {
    vJ(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.wrappedComponent = t, i.setTemplateFromElement(t.getGui()), i;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.initialiseTabGuard({
        onTabKeyDown: function(i) {
          return t.onTabKeyDown(i);
        },
        handleKeyDown: function(i) {
          return t.handleKeyDown(i);
        }
      });
    }, e.prototype.handleKeyDown = function(t) {
      t.key === _e.ESCAPE && this.closePanel();
    }, e.prototype.onTabKeyDown = function(t) {
      t.defaultPrevented || (this.closePanel(), t.preventDefault());
    }, e.prototype.closePanel = function() {
      var t = this.parentComponent;
      t.closeSubMenu(), setTimeout(function() {
        return t.getGui().focus();
      }, 0);
    }, _J([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(A_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var CJ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), EF = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, jf = (
  /** @class */
  function(n) {
    CJ(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return i.params = t, i.isActive = !1, i.subMenuIsOpen = !1, i.setTemplate(
        /* html */
        '<div class="' + i.getClassName() + '" tabindex="-1" role="treeitem"></div>'
      ), i;
    }
    return e.prototype.init = function() {
      var t = this;
      this.addIcon(), this.addName(), this.addShortcut(), this.addSubMenu(), this.addTooltip();
      var i = this.getGui();
      this.params.disabled ? (this.addCssClass(this.getClassName("disabled")), ep(i, !0)) : (this.addGuiEventListener("click", function(r) {
        return t.onItemSelected(r);
      }), this.addGuiEventListener("keydown", function(r) {
        (r.key === _e.ENTER || r.key === _e.SPACE) && (r.preventDefault(), t.onItemSelected(r));
      }), this.addGuiEventListener("mousedown", function(r) {
        r.stopPropagation(), r.preventDefault();
      }), this.addGuiEventListener("mouseenter", function() {
        return t.onMouseEnter();
      }), this.addGuiEventListener("mouseleave", function() {
        return t.onMouseLeave();
      })), this.params.cssClasses && this.params.cssClasses.forEach(function(r) {
        return t.addCssClass(r);
      });
    }, e.prototype.isDisabled = function() {
      return !!this.params.disabled;
    }, e.prototype.openSubMenu = function(t) {
      var i = this;
      if (t === void 0 && (t = !1), this.closeSubMenu(), !!this.params.subMenu) {
        var r = Tr(
          /* html */
          '<div class="ag-menu" role="presentation"></div>'
        ), o;
        if (this.params.subMenu instanceof Array) {
          var s = iH(this.getGui()), a = isNaN(s) ? 1 : s + 1, l = this.createBean(new oG(a));
          l.setParentComponent(this), l.addMenuItems(this.params.subMenu), r.appendChild(l.getGui()), this.addManagedListener(l, e.EVENT_MENU_ITEM_SELECTED, function(v) {
            return i.dispatchEvent(v);
          }), l.addGuiEventListener("mouseenter", function() {
            return i.cancelDeactivate();
          }), o = function() {
            return i.destroyBean(l);
          }, t && setTimeout(function() {
            return l.activateFirstItem();
          }, 0);
        } else {
          var u = this.params.subMenu, c = this.createBean(new sG(u));
          c.setParentComponent(this);
          var h = c.getGui(), d = "mouseenter", f = function() {
            return i.cancelDeactivate();
          };
          h.addEventListener(d, f), o = function() {
            return h.removeEventListener(d, f);
          }, r.appendChild(h), u.afterGuiAttached && setTimeout(function() {
            return u.afterGuiAttached();
          }, 0);
        }
        var p = this.getGui(), g = this.popupService.positionPopupForMenu.bind(this.popupService, { eventSource: p, ePopup: r }), _ = this.gridOptionsWrapper.getLocaleTextFunc(), m = this.popupService.addPopup({
          modal: !0,
          eChild: r,
          positionCallback: g,
          anchorToElement: p,
          ariaLabel: _("ariaLabelSubMenu", "SubMenu")
        });
        this.subMenuIsOpen = !0, bs(p, !0), this.hideSubMenu = function() {
          m && m.hideFunc(), i.subMenuIsOpen = !1, bs(p, !1), o();
        };
      }
    }, e.prototype.closeSubMenu = function() {
      this.hideSubMenu && (this.hideSubMenu(), this.hideSubMenu = null, bs(this.getGui(), !1));
    }, e.prototype.isSubMenuOpen = function() {
      return this.subMenuIsOpen;
    }, e.prototype.activate = function(t) {
      var i = this;
      this.cancelActivate(), !this.params.disabled && (this.isActive = !0, this.addCssClass(this.getClassName("active")), this.getGui().focus(), t && this.params.subMenu && window.setTimeout(function() {
        i.isAlive() && i.isActive && i.openSubMenu();
      }, 300), this.onItemActivated());
    }, e.prototype.deactivate = function() {
      this.cancelDeactivate(), this.removeCssClass(this.getClassName("active")), this.isActive = !1, this.subMenuIsOpen && this.hideSubMenu();
    }, e.prototype.addIcon = function() {
      if (!(!this.params.checked && !this.params.icon && this.params.isCompact)) {
        var t = Tr(
          /* html */
          '<span ref="eIcon" class="' + this.getClassName("part") + " " + this.getClassName("icon") + '" role="presentation"></span>'
        );
        this.params.checked ? t.appendChild(Yn("check", this.gridOptionsWrapper)) : this.params.icon && (I_(this.params.icon) ? t.appendChild(this.params.icon) : typeof this.params.icon == "string" ? t.innerHTML = this.params.icon : console.warn("AG Grid: menu item icon must be DOM node or string")), this.getGui().appendChild(t);
      }
    }, e.prototype.addName = function() {
      if (!(!this.params.name && this.params.isCompact)) {
        var t = Tr(
          /* html */
          '<span ref="eName" class="' + this.getClassName("part") + " " + this.getClassName("text") + '">' + (this.params.name || "") + "</span>"
        );
        this.getGui().appendChild(t);
      }
    }, e.prototype.addTooltip = function() {
      this.params.tooltip && (this.tooltip = this.params.tooltip, this.gridOptionsWrapper.isEnableBrowserTooltips() ? this.getGui().setAttribute("title", this.tooltip) : this.createManagedBean(new AS(this)));
    }, e.prototype.getTooltipParams = function() {
      return {
        location: "menu",
        value: this.tooltip
      };
    }, e.prototype.addShortcut = function() {
      if (!(!this.params.shortcut && this.params.isCompact)) {
        var t = Tr(
          /* html */
          '<span ref="eShortcut" class="' + this.getClassName("part") + " " + this.getClassName("shortcut") + '">' + (this.params.shortcut || "") + "</span>"
        );
        this.getGui().appendChild(t);
      }
    }, e.prototype.addSubMenu = function() {
      if (!(!this.params.subMenu && this.params.isCompact)) {
        var t = Tr(
          /* html */
          '<span ref="ePopupPointer" class="' + this.getClassName("part") + " " + this.getClassName("popup-pointer") + '"></span>'
        ), i = this.getGui();
        if (this.params.subMenu) {
          var r = this.gridOptionsWrapper.isEnableRtl() ? "smallLeft" : "smallRight";
          bs(i, !1), t.appendChild(Yn(r, this.gridOptionsWrapper));
        }
        i.appendChild(t);
      }
    }, e.prototype.onItemSelected = function(t) {
      if (this.params.action ? this.params.action() : this.openSubMenu(t && t.type === "keydown"), !(this.params.subMenu && !this.params.action)) {
        var i = {
          type: e.EVENT_MENU_ITEM_SELECTED,
          action: this.params.action,
          checked: this.params.checked,
          cssClasses: this.params.cssClasses,
          disabled: this.params.disabled,
          icon: this.params.icon,
          name: this.params.name,
          shortcut: this.params.shortcut,
          subMenu: this.params.subMenu,
          tooltip: this.params.tooltip,
          event: t
        };
        this.dispatchEvent(i);
      }
    }, e.prototype.onItemActivated = function() {
      var t = {
        type: e.EVENT_MENU_ITEM_ACTIVATED,
        menuItem: this
      };
      this.dispatchEvent(t);
    }, e.prototype.cancelActivate = function() {
      this.activateTimeoutId && (window.clearTimeout(this.activateTimeoutId), this.activateTimeoutId = 0);
    }, e.prototype.cancelDeactivate = function() {
      this.deactivateTimeoutId && (window.clearTimeout(this.deactivateTimeoutId), this.deactivateTimeoutId = 0);
    }, e.prototype.onMouseEnter = function() {
      var t = this;
      this.cancelDeactivate(), this.params.isAnotherSubMenuOpen() ? this.activateTimeoutId = window.setTimeout(function() {
        return t.activate(!0);
      }, e.ACTIVATION_DELAY) : this.activate(!0);
    }, e.prototype.onMouseLeave = function() {
      var t = this;
      this.cancelActivate(), this.isSubMenuOpen() ? this.deactivateTimeoutId = window.setTimeout(function() {
        return t.deactivate();
      }, e.ACTIVATION_DELAY) : this.deactivate();
    }, e.prototype.getClassName = function(t) {
      var i = this.params.isCompact ? "ag-compact-menu-option" : "ag-menu-option";
      return t ? i + "-" + t : i;
    }, e.EVENT_MENU_ITEM_SELECTED = "menuItemSelected", e.EVENT_MENU_ITEM_ACTIVATED = "menuItemActivated", e.ACTIVATION_DELAY = 80, EF([
      T("popupService")
    ], e.prototype, "popupService", void 0), EF([
      Le
    ], e.prototype, "init", null), e;
  }(Et)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var yJ = globalThis && globalThis.__extends || function() {
  var n = function(e, t) {
    return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, n(e, t);
  };
  return function(e, t) {
    n(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ey = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, wJ = (
  /** @class */
  function(n) {
    yJ(e, n);
    function e(t, i, r) {
      t === void 0 && (t = "default"), i === void 0 && (i = "listbox");
      var o = n.call(this, e.getTemplate(t)) || this;
      return o.cssIdentifier = t, o.ariaRole = i, o.listName = r, o.renderedRows = /* @__PURE__ */ new Map(), o.rowHeight = 20, o.isDestroyed = !1, o;
    }
    return e.prototype.postConstruct = function() {
      var t = this;
      this.addScrollListener(), this.rowHeight = this.getItemHeight(), this.addResizeObserver(), this.initialiseTabGuard({
        onFocusIn: function(i) {
          return t.onFocusIn(i);
        },
        onFocusOut: function(i) {
          return t.onFocusOut(i);
        },
        focusInnerElement: function(i) {
          return t.focusInnerElement(i);
        },
        onTabKeyDown: function(i) {
          return t.onTabKeyDown(i);
        },
        handleKeyDown: function(i) {
          return t.handleKeyDown(i);
        }
      }), this.setAriaProperties();
    }, e.prototype.setAriaProperties = function() {
      var t = this.gridOptionsWrapper.getLocaleTextFunc(), i = t("ariaDefaultListName", this.listName || "List"), r = this.eContainer;
      Do(r, this.ariaRole), tf(r, i);
    }, e.prototype.addResizeObserver = function() {
      var t = this.drawVirtualRows.bind(this), i = this.resizeObserverService.observeResize(this.getGui(), t);
      this.addDestroyFunc(i);
    }, e.prototype.focusInnerElement = function(t) {
      this.focusRow(t ? this.model.getRowCount() - 1 : 0);
    }, e.prototype.onFocusIn = function(t) {
      var i = t.target;
      return i.classList.contains("ag-virtual-list-item") && (this.lastFocusedRowIndex = nH(i) - 1), !1;
    }, e.prototype.onFocusOut = function(t) {
      return this.getFocusableElement().contains(t.relatedTarget) || (this.lastFocusedRowIndex = null), !1;
    }, e.prototype.handleKeyDown = function(t) {
      switch (t.key) {
        case _e.UP:
        case _e.DOWN:
          this.navigate(t.key === _e.UP) && t.preventDefault();
          break;
      }
    }, e.prototype.onTabKeyDown = function(t) {
      this.navigate(t.shiftKey) ? t.preventDefault() : this.focusService.focusInto(this.getGui(), !t.shiftKey);
    }, e.prototype.navigate = function(t) {
      if (this.lastFocusedRowIndex == null)
        return !1;
      var i = this.lastFocusedRowIndex + (t ? -1 : 1);
      return i < 0 || i >= this.model.getRowCount() ? !1 : (this.focusRow(i), !0);
    }, e.prototype.getLastFocusedRow = function() {
      return this.lastFocusedRowIndex;
    }, e.prototype.focusRow = function(t) {
      var i = this;
      this.ensureIndexVisible(t), window.setTimeout(function() {
        var r = i.renderedRows.get(t);
        r && r.eDiv.focus();
      }, 10);
    }, e.prototype.getComponentAt = function(t) {
      var i = this.renderedRows.get(t);
      return i && i.rowComponent;
    }, e.getTemplate = function(t) {
      return (
        /* html */
        `
            <div class="ag-virtual-list-viewport ag-` + t + `-virtual-list-viewport" role="presentation">
                <div class="ag-virtual-list-container ag-` + t + `-virtual-list-container" ref="eContainer"></div>
            </div>`
      );
    }, e.prototype.getItemHeight = function() {
      return this.gridOptionsWrapper.getListItemHeight();
    }, e.prototype.ensureIndexVisible = function(t) {
      var i = this.model.getRowCount();
      if (typeof t != "number" || t < 0 || t >= i) {
        console.warn("AG Grid: invalid row index for ensureIndexVisible: " + t);
        return;
      }
      var r = t * this.rowHeight, o = r + this.rowHeight, s = this.getGui(), a = s.scrollTop, l = s.offsetHeight, u = a + l, c = a > r, h = u < o;
      if (c)
        s.scrollTop = r;
      else if (h) {
        var d = o - l;
        s.scrollTop = d;
      }
    }, e.prototype.setComponentCreator = function(t) {
      this.componentCreator = t;
    }, e.prototype.getRowHeight = function() {
      return this.rowHeight;
    }, e.prototype.getScrollTop = function() {
      return this.getGui().scrollTop;
    }, e.prototype.setRowHeight = function(t) {
      this.rowHeight = t, this.refresh();
    }, e.prototype.refresh = function() {
      var t = this;
      if (!(this.model == null || this.isDestroyed)) {
        var i = this.model.getRowCount();
        this.eContainer.style.height = i * this.rowHeight + "px", bB(function() {
          return t.eContainer.clientHeight >= i * t.rowHeight;
        }, function() {
          t.isDestroyed || (t.clearVirtualRows(), t.drawVirtualRows());
        });
      }
    }, e.prototype.clearVirtualRows = function() {
      var t = this;
      this.renderedRows.forEach(function(i, r) {
        return t.removeRow(r);
      });
    }, e.prototype.drawVirtualRows = function() {
      var t = this.getGui(), i = t.scrollTop, r = i + t.offsetHeight, o = Math.floor(i / this.rowHeight), s = Math.floor(r / this.rowHeight);
      this.ensureRowsRendered(o, s);
    }, e.prototype.ensureRowsRendered = function(t, i) {
      var r = this;
      this.renderedRows.forEach(function(s, a) {
        (a < t || a > i) && a !== r.lastFocusedRowIndex && r.removeRow(a);
      });
      for (var o = t; o <= i; o++)
        this.renderedRows.has(o) || o < this.model.getRowCount() && this.insertRow(o);
    }, e.prototype.insertRow = function(t) {
      var i = this, r = this.model.getRow(t), o = document.createElement("div");
      if (o.classList.add("ag-virtual-list-item", "ag-" + this.cssIdentifier + "-virtual-list-item"), Do(o, this.ariaRole === "tree" ? "treeitem" : "option"), Rx(o, this.model.getRowCount()), Tx(o, t + 1), o.setAttribute("tabindex", "-1"), typeof this.model.isRowSelected == "function") {
        var s = this.model.isRowSelected(t);
        $p(o, !!s), hH(o, s);
      }
      o.style.height = this.rowHeight + "px", o.style.top = this.rowHeight * t + "px";
      var a = this.componentCreator(r, o);
      a.addGuiEventListener("focusin", function() {
        return i.lastFocusedRowIndex = t;
      }), o.appendChild(a.getGui()), this.renderedRows.has(t - 1) ? this.renderedRows.get(t - 1).eDiv.insertAdjacentElement("afterend", o) : this.renderedRows.has(t + 1) ? this.renderedRows.get(t + 1).eDiv.insertAdjacentElement("beforebegin", o) : this.eContainer.appendChild(o), this.renderedRows.set(t, { rowComponent: a, eDiv: o });
    }, e.prototype.removeRow = function(t) {
      var i = this.renderedRows.get(t);
      this.eContainer.removeChild(i.eDiv), this.destroyBean(i.rowComponent), this.renderedRows.delete(t);
    }, e.prototype.addScrollListener = function() {
      var t = this;
      this.addGuiEventListener("scroll", function() {
        return t.drawVirtualRows();
      });
    }, e.prototype.setModel = function(t) {
      this.model = t;
    }, e.prototype.destroy = function() {
      this.isDestroyed || (this.clearVirtualRows(), this.isDestroyed = !0, n.prototype.destroy.call(this));
    }, ey([
      T("resizeObserverService")
    ], e.prototype, "resizeObserverService", void 0), ey([
      T("focusService")
    ], e.prototype, "focusService", void 0), ey([
      ve("eContainer")
    ], e.prototype, "eContainer", void 0), ey([
      Le
    ], e.prototype, "postConstruct", null), e;
  }(A_)
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
function bJ(n, e, t, i, r) {
  r === void 0 && (r = !1), console.warn("AG Grid: Since ag-grid 11.0.0 defaultGroupComparator is not necessary. You can remove this from your colDef");
  var o = ge(t) && t.group, s = ge(i) && i.group, a = o && s, l = !o && !s;
  return a ? F1(t.key, i.key, r) : l ? F1(n, e, r) : o ? 1 : -1;
}
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var SJ = (
  /** @class */
  function() {
    function n() {
    }
    return n.prototype.wrap = function(e, t, i, r) {
      var o = this;
      i === void 0 && (i = []);
      var s = this.createWrapper(e, r);
      return t.forEach(function(a) {
        o.createMethod(s, a, !0);
      }), i.forEach(function(a) {
        o.createMethod(s, a, !1);
      }), s;
    }, n.prototype.unwrap = function(e) {
      return e;
    }, n.prototype.createMethod = function(e, t, i) {
      e.addMethod(t, this.createMethodProxy(e, t, i));
    }, n.prototype.createMethodProxy = function(e, t, i) {
      return function() {
        return e.hasMethod(t) ? e.callMethod(t, arguments) : (i && console.warn("AG Grid: Framework component is missing the method " + t + "()"), null);
      };
    }, n;
  }()
);
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var uR;
(function(n) {
  n.InsideBase = "insideBase", n.InsideEnd = "insideEnd", n.Center = "center", n.OutsideEnd = "outsideEnd";
})(uR || (uR = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v27.1.0
 * @link http://www.ag-grid.com/
 * @license MIT
 */
var Eg = typeof global > "u" ? {} : global;
Eg.HTMLElement = typeof HTMLElement > "u" ? {} : HTMLElement;
Eg.HTMLButtonElement = typeof HTMLButtonElement > "u" ? {} : HTMLButtonElement;
Eg.HTMLSelectElement = typeof HTMLSelectElement > "u" ? {} : HTMLSelectElement;
Eg.HTMLInputElement = typeof HTMLInputElement > "u" ? {} : HTMLInputElement;
Eg.Node = typeof Node > "u" ? {} : Node;
Eg.MouseEvent = typeof MouseEvent > "u" ? {} : MouseEvent;
const EJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbstractHeaderCellCtrl: P_,
  AgAbstractField: Gl,
  AgAngleSelect: z4,
  AgCheckbox: Kp,
  AgColorPicker: H4,
  AgDialog: Yx,
  AgGroupComponent: F4,
  AgInputNumberField: G4,
  AgInputRange: U4,
  AgInputTextArea: V4,
  AgInputTextField: Xx,
  AgMenuItemComponent: jf,
  AgMenuList: oG,
  AgMenuPanel: sG,
  AgPanel: qx,
  AgPromise: Bo,
  get AgPromiseStatus() {
    return od;
  },
  AgRadioButton: E4,
  AgSelect: Mx,
  AgSlider: B4,
  AgStackComponentsRegistry: WB,
  AgToggleButton: j4,
  AlignedGridsService: x4,
  AnimateShowChangeCellRenderer: NH,
  AnimateSlideCellRenderer: IH,
  AnimationFrameService: I4,
  AutoScrollService: r4,
  AutoWidthCalculator: p4,
  Autowired: T,
  get BarColumnLabelPlacement() {
    return uR;
  },
  BaseComponentWrapper: SJ,
  Bean: qe,
  BeanStub: Se,
  Beans: Gx,
  BodyDropPivotTarget: qH,
  BodyDropTarget: YH,
  CellComp: eG,
  CellCtrl: Zc,
  CellNavigationService: b4,
  CellPositionUtils: K4,
  get CellRangeType() {
    return sd;
  },
  ChangedPath: Bx,
  CheckboxSelectionComponent: Vx,
  get ClientSideRowModelSteps() {
    return oa;
  },
  ColDefUtil: U1,
  Color: zf,
  Column: Gt,
  ColumnApi: BH,
  ColumnFactory: NB,
  ColumnGroup: Qr,
  ColumnKeyCreator: fB,
  ColumnModel: MB,
  ColumnUtils: FB,
  Component: Et,
  ComponentUtil: Xc,
  Constants: Z,
  Context: EB,
  CssClassApplier: $x,
  CssClassManager: yH,
  CtrlsService: Q4,
  CustomTooltipFeature: AS,
  DateFilter: Fx,
  DisplayedGroupCreator: kB,
  DragAndDropService: wo,
  DragService: C4,
  get DragSourceType() {
    return Ds;
  },
  Environment: N4,
  EventService: ic,
  Events: F,
  get ExcelFactoryMode() {
    return _p;
  },
  ExpressionService: c4,
  FilterManager: i4,
  FloatingFilterMapper: FH,
  FocusService: Cp,
  Grid: nG,
  GridApi: XH,
  GridBodyComp: u4,
  GridBodyCtrl: l4,
  GridComp: _4,
  GridCoreCreator: rG,
  GridCtrl: m4,
  GridHeaderComp: t4,
  GridHeaderCtrl: $H,
  GridOptionsWrapper: He,
  GroupCellRenderer: tR,
  GroupCellRendererCtrl: AH,
  GroupInstanceIdCreator: IB,
  HeaderCellCtrl: QH,
  HeaderFilterCellComp: UH,
  HeaderFilterCellCtrl: ZH,
  HeaderGroupCellCtrl: JH,
  get HeaderNavigationDirection() {
    return Ha;
  },
  HeaderNavigationService: jH,
  HeaderPositionUtils: Y4,
  HeaderRowComp: zH,
  HeaderRowContainerComp: Qy,
  HeaderRowContainerCtrl: e4,
  HeaderRowCtrl: Zy,
  get HeaderRowType() {
    return Jr;
  },
  get HorizontalDirection() {
    return Ba;
  },
  HorizontalResizeService: g4,
  KeyCode: _e,
  LargeTextCellEditor: TH,
  get LayoutCssClasses() {
    return Wn;
  },
  Logger: Qw,
  LoggerFactory: f4,
  ManagedFocusFeature: nc,
  get ModuleNames() {
    return ht;
  },
  ModuleRegistry: gt,
  MouseEventService: w4,
  MoveColumnFeature: KH,
  NavigationService: P4,
  NumberFilter: kx,
  NumberSequence: PS,
  Optional: fi,
  PaginationProxy: T4,
  PinnedRowModel: q4,
  PopupComponent: Sg,
  PopupEditorWrapper: J4,
  PopupSelectCellEditor: OH,
  PopupService: d4,
  PopupTextCellEditor: xH,
  PositionableFeature: W4,
  PostConstruct: Le,
  PreConstruct: W1,
  PreDestroy: To,
  PropertyKeys: Ml,
  ProvidedColumnGroup: gn,
  ProvidedFilter: zv,
  Qualifier: Eo,
  QuerySelector: SK,
  RefSelector: ve,
  ResizeObserverService: M4,
  get RowAnimationCssClasses() {
    return kd;
  },
  RowContainerComp: tG,
  RowContainerCtrl: Xw,
  get RowContainerName() {
    return we;
  },
  get RowContainerType() {
    return Vo;
  },
  RowCtrl: Qc,
  get RowHighlightPosition() {
    return Md;
  },
  RowNode: Wt,
  RowNodeBlock: oR,
  RowNodeBlockLoader: X4,
  RowNodeSorter: Z4,
  RowPositionUtils: $4,
  RowRenderer: GH,
  ScalarFilter: hr,
  ScrollVisibleService: D4,
  SelectCellEditor: Wx,
  SelectableService: A4,
  get SelectionHandleType() {
    return jv;
  },
  SelectionService: VH,
  get ServerSideTransactionResultStatus() {
    return lR;
  },
  SetLeftFeature: kS,
  SimpleFilter: En,
  SortController: y4,
  StandardMenuFactory: iG,
  StylingService: R4,
  TabGuardComp: A_,
  TabGuardCtrl: v4,
  TabbedLayout: pJ,
  TemplateService: h4,
  TextCellEditor: $w,
  TextFilter: MS,
  TextFloatingFilter: RH,
  Timer: CK,
  TouchListener: da,
  UserComponentFactory: kH,
  UserComponentRegistry: MH,
  ValueCache: O4,
  ValueFormatterService: S4,
  ValueService: n4,
  VanillaFrameworkOverrides: L4,
  get VerticalDirection() {
    return Fd;
  },
  VirtualList: wJ,
  _: Ad,
  defaultGroupComparator: bJ,
  getRowContainerTypeForName: HH,
  initialiseAgGridWithAngular1: hJ,
  simpleHttpRequest: gJ,
  stringToArray: VB
}, Symbol.toStringTag, { value: "Module" }));
var Zx = {}, Qx = {};
const vr = /* @__PURE__ */ YO(EJ);
var Jx = {}, WS = {};
Object.defineProperty(WS, "__esModule", { value: !0 });
class LJ {
}
class DJ extends LJ {
  constructor(e, t, i) {
    super(), this.portal = null, this.reactComponent = e, this.portalManager = t, this.componentType = i, this.statelessComponent = this.isStateless(this.reactComponent);
  }
  getGui() {
    return this.eParentElement;
  }
  destroy() {
    return this.componentInstance && typeof this.componentInstance.destroy == "function" && this.componentInstance.destroy(), this.portalManager.destroyPortal(this.portal);
  }
  createParentElement(e) {
    const t = this.portalManager.getComponentWrappingElement(), i = document.createElement(t || "div");
    return i.classList.add("ag-react-container"), e.reactContainer = i, i;
  }
  addParentContainerStyleAndClasses() {
    this.componentInstance && (this.componentInstance.getReactContainerStyle && this.componentInstance.getReactContainerStyle() && Object.assign(this.eParentElement.style, this.componentInstance.getReactContainerStyle()), this.componentInstance.getReactContainerClasses && this.componentInstance.getReactContainerClasses() && this.componentInstance.getReactContainerClasses().forEach((t) => this.eParentElement.classList.add(t)));
  }
  statelessComponentRendered() {
    return this.eParentElement.childElementCount > 0 || this.eParentElement.childNodes.length > 0;
  }
  getFrameworkComponentInstance() {
    return this.componentInstance;
  }
  isStatelessComponent() {
    return this.statelessComponent;
  }
  getReactComponentName() {
    return this.reactComponent.name;
  }
  getMemoType() {
    return this.hasSymbol() ? Symbol.for("react.memo") : 60115;
  }
  hasSymbol() {
    return typeof Symbol == "function" && Symbol.for;
  }
  isStateless(e) {
    return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === this.getMemoType();
  }
  hasMethod(e) {
    const t = this.getFrameworkComponentInstance();
    return !!t && t[e] !== null || this.fallbackMethodAvailable(e);
  }
  callMethod(e, t) {
    const i = this.getFrameworkComponentInstance();
    if (this.isStatelessComponent())
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
    if (!i) {
      setTimeout(() => this.callMethod(e, t));
      return;
    }
    const r = i[e];
    if (r)
      return r.apply(i, t);
    if (this.fallbackMethodAvailable(e))
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
  }
  addMethod(e, t) {
    this[e] = t;
  }
}
WS.ReactComponent = DJ;
var VS = {};
Object.defineProperty(VS, "__esModule", { value: !0 });
let RJ = 0;
function TJ() {
  return `agPortalKey_${++RJ}`;
}
VS.default = TJ;
var OJ = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(Jx, "__esModule", { value: !0 });
const LF = bt, xJ = pg, NJ = vr, IJ = WS, PJ = EV, AJ = OJ(VS);
class BS extends IJ.ReactComponent {
  constructor(e, t, i, r) {
    super(e, i, r), this.staticMarkup = null, this.staticRenderTime = 0, this.parentComponent = t;
  }
  init(e) {
    return this.eParentElement = this.createParentElement(e), this.renderStaticMarkup(e), new NJ.AgPromise((t) => this.createReactComponent(e, t));
  }
  createReactComponent(e, t) {
    this.isStatelessComponent() || (e.ref = (o) => {
      this.componentInstance = o, this.addParentContainerStyleAndClasses(), this.removeStaticMarkup();
    });
    const i = LF.createElement(this.reactComponent, e), r = xJ.createPortal(
      i,
      this.eParentElement,
      AJ.default()
      // fixed deltaRowModeRefreshCompRenderer
    );
    this.portal = r, this.portalManager.mountReactPortal(r, this, (o) => {
      t(o), this.isStatelessComponent() && (this.isSlowRenderer() && this.removeStaticMarkup(), setTimeout(() => {
        this.removeStaticMarkup();
      }));
    });
  }
  fallbackMethodAvailable(e) {
    return !1;
  }
  fallbackMethod(e, t) {
  }
  isSlowRenderer() {
    return this.staticRenderTime >= BS.SLOW_RENDERING_THRESHOLD;
  }
  isNullValue() {
    return this.staticMarkup === "";
  }
  /*
   * Attempt to render the component as static markup if possible
   * What this does is eliminate any visible flicker for the user in the scenario where a component is destroyed and
   * recreated with exactly the same data (ie with force refresh)
   * Note: Some use cases will throw an error (ie when using Context) so if an error occurs just ignore it any move on
   */
  renderStaticMarkup(e) {
    if (this.parentComponent.isDisableStaticMarkup() || !this.componentType.cellRenderer)
      return;
    const t = console.error, i = LF.createElement(this.reactComponent, e);
    try {
      console.error = () => {
      };
      const r = Date.now(), o = PJ.renderToStaticMarkup(i);
      this.staticRenderTime = Date.now() - r, console.error = t, o === "" ? this.staticMarkup = o : o && (this.staticMarkup = document.createElement("span"), this.staticMarkup.innerHTML = o, this.eParentElement.appendChild(this.staticMarkup));
    } catch {
    } finally {
      console.error = t;
    }
  }
  removeStaticMarkup() {
    this.parentComponent.isDisableStaticMarkup() || !this.componentType.cellRenderer || this.staticMarkup && (this.staticMarkup.remove ? (this.staticMarkup.remove(), this.staticMarkup = null) : this.eParentElement.removeChild && (this.eParentElement.removeChild(this.staticMarkup), this.staticMarkup = null));
  }
  rendered() {
    return this.isNullValue() || !!this.staticMarkup || this.isStatelessComponent() && this.statelessComponentRendered() || !!(!this.isStatelessComponent() && this.getFrameworkComponentInstance());
  }
}
Jx.LegacyReactComponent = BS;
BS.SLOW_RENDERING_THRESHOLD = 3;
var M_ = {}, MJ = Ae && Ae.__rest || function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
}, aG = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, FJ = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(M_, "__esModule", { value: !0 });
const KL = aG(bt), Lg = FJ(Qu), Dg = aG(vr);
class yp extends KL.Component {
  constructor(e) {
    super(e), this.props = e;
  }
  render() {
    return null;
  }
  static mapChildColumnDefs(e) {
    return KL.default.Children.map(e, (t) => t ? yp.toColDef(t.props) : null);
  }
  static toColDef(e) {
    const { children: t } = e, i = MJ(e, ["children"]);
    return yp.hasChildColumns(t) && (i.children = yp.mapChildColumnDefs(t)), i;
  }
  static hasChildColumns(e) {
    return KL.default.Children.count(e) > 0;
  }
}
M_.AgGridColumn = yp;
Rg(Dg.ColDefUtil.BOOLEAN_PROPERTIES, Lg.default.bool);
Rg(Dg.ColDefUtil.STRING_PROPERTIES, Lg.default.string);
Rg(Dg.ColDefUtil.OBJECT_PROPERTIES, Lg.default.object);
Rg(Dg.ColDefUtil.ARRAY_PROPERTIES, Lg.default.array);
Rg(Dg.ColDefUtil.NUMBER_PROPERTIES, Lg.default.number);
Rg(Dg.ColDefUtil.FUNCTION_PROPERTIES, Lg.default.func);
function Rg(n, e) {
  n.forEach((t) => {
    yp[t] = e;
  });
}
var HS = {};
(function(n) {
  Object.defineProperty(n, "__esModule", { value: !0 });
  var e;
  (function(o) {
    o.IdentityCheck = "IdentityCheck", o.DeepValueCheck = "DeepValueCheck", o.NoCheck = "NoCheck";
  })(e = n.ChangeDetectionStrategyType || (n.ChangeDetectionStrategyType = {}));
  class t {
    constructor(s) {
      this.strategy = s;
    }
    areEqual(s, a) {
      return this.strategy(s, a);
    }
  }
  class i {
    areEqual(s, a) {
      return i.areEquivalent(i.copy(s), i.copy(a));
    }
    /*
     * deeper object comparison - taken from https://stackoverflow.com/questions/1068834/object-comparison-in-javascript
     */
    static unwrapStringOrNumber(s) {
      return s instanceof Number || s instanceof String ? s.valueOf() : s;
    }
    // sigh, here for ie compatibility
    static copy(s) {
      if (!s)
        return s;
      if (Array.isArray(s)) {
        const a = [];
        for (let l = 0; l < s.length; l++)
          a.push(this.copy(s[l]));
        return a;
      }
      return typeof s != "object" ? s : [{}, s].reduce((a, l) => (Object.keys(l).forEach(function(u) {
        a[u] = l[u];
      }), a), {});
    }
    static isNaN(s) {
      return Number.isNaN ? Number.isNaN(s) : typeof s == "number" && isNaN(s);
    }
    /*
     * slightly modified, but taken from https://stackoverflow.com/questions/1068834/object-comparison-in-javascript
     *
     * What we're trying to do here is determine if the property being checked has changed in _value_, not just in reference
     *
     * For eg, if a user updates the columnDefs via property binding, but the actual columns defs are the same before and
     * after, then we don't want the grid to re-render
     */
    static areEquivalent(s, a) {
      if (s = i.unwrapStringOrNumber(s), a = i.unwrapStringOrNumber(a), s === a)
        return !0;
      if (s === null || a === null || typeof s != typeof a)
        return !1;
      if (i.isNaN(s) && i.isNaN(a))
        return !0;
      if (s instanceof Date)
        return a instanceof Date && s.valueOf() === a.valueOf();
      if (typeof s == "function")
        return !1;
      if (typeof s != "object" || s.$$typeof && s.$$typeof.toString() === "Symbol(react.element)")
        return s == a;
      if (Object.isFrozen(s) || Object.isFrozen(a))
        return s === a;
      const l = s.areEquivPropertyTracking === void 0, u = a.areEquivPropertyTracking === void 0;
      try {
        let c;
        if (l)
          s.areEquivPropertyTracking = [];
        else if (s.areEquivPropertyTracking.some(function(d) {
          return d === a;
        }))
          return !0;
        if (u)
          a.areEquivPropertyTracking = [];
        else if (a.areEquivPropertyTracking.some((d) => d === s))
          return !0;
        s.areEquivPropertyTracking.push(a), a.areEquivPropertyTracking.push(s);
        const h = {};
        for (c in s)
          c != "areEquivPropertyTracking" && (h[c] = null);
        for (c in a)
          c != "areEquivPropertyTracking" && (h[c] = null);
        for (c in h)
          if (!this.areEquivalent(s[c], a[c]))
            return !1;
        return !0;
      } finally {
        l && delete s.areEquivPropertyTracking, u && delete a.areEquivPropertyTracking;
      }
    }
  }
  class r {
    constructor() {
      this.strategyMap = {
        [e.DeepValueCheck]: new i(),
        [e.IdentityCheck]: new t((s, a) => s === a),
        [e.NoCheck]: new t((s, a) => !1)
      };
    }
    getStrategy(s) {
      return this.strategyMap[s];
    }
  }
  n.ChangeDetectionService = r;
})(HS);
var GS = {}, kJ = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(GS, "__esModule", { value: !0 });
const DF = bt, WJ = pg, VJ = vr, BJ = WS, HJ = EV, RF = kJ(VS);
class GJ extends BJ.ReactComponent {
  constructor(e, t, i) {
    super(e, t, i), this.oldPortal = null, this.key = RF.default(), this.portalKey = RF.default();
  }
  init(e) {
    return this.eParentElement = this.createParentElement(e), this.params = e, this.createOrUpdatePortal(e), new VJ.AgPromise((t) => this.createReactComponent(t));
  }
  createOrUpdatePortal(e) {
    this.isStatelessComponent() || (e.ref = (t) => {
      this.componentInstance = t, this.addParentContainerStyleAndClasses();
    }), this.reactElement = DF.createElement(this.reactComponent, Object.assign(Object.assign({}, e), { key: this.key })), this.portal = WJ.createPortal(
      this.reactElement,
      this.eParentElement,
      this.portalKey
      // fixed deltaRowModeRefreshCompRenderer
    );
  }
  createReactComponent(e) {
    this.portalManager.mountReactPortal(this.portal, this, (t) => {
      e(t);
    });
  }
  isNullValue() {
    return this.valueRenderedIsNull(this.params);
  }
  rendered() {
    return this.isStatelessComponent() && this.statelessComponentRendered() || !!(!this.isStatelessComponent() && this.getFrameworkComponentInstance());
  }
  valueRenderedIsNull(e) {
    if (!this.componentType.cellRenderer)
      return !1;
    const t = console.error;
    try {
      return console.error = () => {
      }, HJ.renderToStaticMarkup(DF.createElement(this.reactComponent, e)) === "";
    } catch {
    } finally {
      console.error = t;
    }
    return !1;
  }
  /*
  * fallback methods - these will be invoked if a corresponding instance method is not present
  * for example if refresh is called and is not available on the component instance, then refreshComponent on this
  * class will be invoked instead
  *
  * Currently only refresh is supported
  */
  refreshComponent(e) {
    this.oldPortal = this.portal, this.createOrUpdatePortal(e), this.portalManager.updateReactPortal(this.oldPortal, this.portal);
  }
  fallbackMethod(e, t) {
    const i = this[`${e}Component`];
    if (i)
      return i.bind(this)(t);
  }
  fallbackMethodAvailable(e) {
    return !!this[`${e}Component`];
  }
}
GS.NewReactComponent = GJ;
var US = {};
Object.defineProperty(US, "__esModule", { value: !0 });
class zS {
  constructor(e, t, i) {
    this.destroyed = !1, this.portals = [], this.hasPendingPortalUpdate = !1, this.wrappingElement = t || "div", this.parent = e, this.maxComponentCreationTimeMs = i || zS.MAX_COMPONENT_CREATION_TIME_IN_MS;
  }
  getPortals() {
    return this.portals;
  }
  destroy() {
    this.destroyed = !0;
  }
  destroyPortal(e) {
    this.portals = this.portals.filter((t) => t !== e), this.batchUpdate();
  }
  getComponentWrappingElement() {
    return this.wrappingElement;
  }
  mountReactPortal(e, t, i) {
    this.portals = [...this.portals, e], this.waitForInstance(t, i), this.batchUpdate();
  }
  updateReactPortal(e, t) {
    this.portals[this.portals.indexOf(e)] = t, this.batchUpdate();
  }
  batchUpdate() {
    this.hasPendingPortalUpdate || (setTimeout(() => {
      this.destroyed || this.parent.forceUpdate(() => {
        this.hasPendingPortalUpdate = !1;
      });
    }), this.hasPendingPortalUpdate = !0);
  }
  waitForInstance(e, t, i = Date.now()) {
    if (this.destroyed) {
      t(null);
      return;
    }
    if (e.rendered())
      t(e);
    else {
      if (Date.now() - i >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate) {
        if (e.isNullValue()) {
          t(e);
          return;
        }
        console.error(`AG Grid: React Component '${e.getReactComponentName()}' not created within ${this.maxComponentCreationTimeMs}ms`);
        return;
      }
      window.setTimeout(() => {
        this.waitForInstance(e, t, i);
      });
    }
  }
}
US.PortalManager = zS;
zS.MAX_COMPONENT_CREATION_TIME_IN_MS = 1e3;
var ty = {}, eN = {}, xr = {}, UJ = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(xr, "__esModule", { value: !0 });
const zJ = UJ(bt);
xr.BeansContext = zJ.default.createContext({});
var rc = {};
Object.defineProperty(rc, "__esModule", { value: !0 });
rc.showJsComp = (n, e, t, i) => {
  if (!n || n.componentFromFramework)
    return;
  const o = n.newAgStackInstance();
  if (!o)
    return;
  let s, a, l = !1;
  return o.then((u) => {
    if (l) {
      e.destroyBean(u);
      return;
    }
    s = u, a = s.getGui(), t.appendChild(a), TF(i, s);
  }), () => {
    l = !0, s && (a && a.parentElement && a.parentElement.removeChild(a), e.destroyBean(s), i && TF(i, void 0));
  };
};
const TF = (n, e) => {
  if (n)
    if (n instanceof Function)
      n(e);
    else {
      const t = n;
      t.current = e;
    }
};
rc.createSyncJsComp = (n) => {
  const e = n.newAgStackInstance();
  if (e)
    return e.resolveNow(null, (t) => t);
};
var so = {};
Object.defineProperty(so, "__esModule", { value: !0 });
so.classesList = (...n) => n.filter((t) => t != null && t !== "").join(" ");
class tN {
  constructor() {
    this.classesMap = {};
  }
  setClass(e, t) {
    if (!!this.classesMap[e] == t)
      return this;
    const r = new tN();
    return r.classesMap = Object.assign({}, this.classesMap), r.classesMap[e] = t, r;
  }
  toString() {
    return Object.keys(this.classesMap).filter((t) => this.classesMap[t]).join(" ");
  }
}
so.CssClasses = tN;
so.isComponentStateless = (n) => {
  const e = () => typeof Symbol == "function" && Symbol.for, t = () => e() ? Symbol.for("react.memo") : 60115;
  return typeof n == "function" && !(n.prototype && n.prototype.isReactComponent) || typeof n == "object" && n.$$typeof === t();
};
var jJ = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(eN, "__esModule", { value: !0 });
const $J = vr, wi = jJ(bt), KJ = xr, qJ = rc, iy = so, lG = wi.forwardRef((n, e) => {
  const t = wi.useContext(KJ.BeansContext).context, i = wi.useRef(null), r = wi.useRef(null), o = wi.useRef(null), s = wi.useRef(null), a = wi.useRef(null), [l, u] = wi.useState(), [c, h] = wi.useState(), [d, f] = wi.useState(), [p, g] = wi.useState(new iy.CssClasses()), [_, m] = wi.useState(new iy.CssClasses()), [v, C] = wi.useState(new iy.CssClasses()), [y, w] = wi.useState(new iy.CssClasses());
  wi.useImperativeHandle(e, () => ({
    // force new instance when grid tries to refresh
    refresh() {
      return !1;
    }
  })), wi.useEffect(() => qJ.showJsComp(l, t, r.current), [l]), wi.useEffect(() => {
    const M = {
      setInnerRenderer: (j, $) => {
        u(j), f($);
      },
      setChildCount: (j) => h(j),
      addOrRemoveCssClass: (j, $) => g((k) => k.setClass(j, $)),
      setContractedDisplayed: (j) => C(($) => $.setClass("ag-hidden", !j)),
      setExpandedDisplayed: (j) => m(($) => $.setClass("ag-hidden", !j)),
      setCheckboxVisible: (j) => {
        w(($) => $.setClass("ag-invisible", !j));
      }
    }, z = t.createBean(new $J.GroupCellRendererCtrl());
    return z.init(M, i.current, o.current, s.current, a.current, lG, n), () => {
      t.destroyBean(z);
    };
  }, []);
  const L = wi.useMemo(() => `ag-cell-wrapper ${p.toString()}`, [p]), S = wi.useMemo(() => `ag-group-expanded ${_.toString()}`, [_]), E = wi.useMemo(() => `ag-group-contracted ${v.toString()}`, [v]), D = wi.useMemo(() => `ag-group-checkbox ${y.toString()}`, [y]), x = l && l.componentFromFramework, R = x ? l.componentClass : void 0, A = l == null && d != null;
  return wi.default.createElement(
    "span",
    Object.assign({ className: L, ref: i }, n.colDef ? {} : { role: "gridcell" }),
    wi.default.createElement("span", { className: S, ref: s }),
    wi.default.createElement("span", { className: E, ref: a }),
    wi.default.createElement("span", { className: D, ref: o }),
    wi.default.createElement(
      "span",
      { className: "ag-group-value", ref: r },
      A && wi.default.createElement(wi.default.Fragment, null, d),
      x && wi.default.createElement(R, Object.assign({}, l.params))
    ),
    wi.default.createElement("span", { className: "ag-group-child-count" }, c)
  );
});
eN.default = lG;
var ny = {}, ry = {}, iN = {}, nN = {}, rN = {}, oN = {}, sN = {}, aN = {}, YJ = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(aN, "__esModule", { value: !0 });
const Fn = YJ(bt), XJ = xr, ZJ = vr, QJ = so, JJ = rc, eee = (n) => {
  const { context: e } = Fn.useContext(XJ.BeansContext), [t, i] = Fn.useState(), [r, o] = Fn.useState(), [s, a] = Fn.useState(), [l, u] = Fn.useState(), [c, h] = Fn.useState(), [d, f] = Fn.useState(), p = Fn.useRef(null), g = Fn.useRef(null), _ = Fn.useRef(), { ctrl: m } = n, v = Fn.useMemo(() => new ZJ.CssClassManager(() => p.current), []);
  Fn.useEffect(() => {
    const S = {
      setWidth: (D) => i(D),
      addOrRemoveCssClass: (D, x) => v.addOrRemoveCssClass(D, x),
      setAriaSort: (D) => u(D),
      setColId: (D) => a(D),
      setTitle: (D) => o(D),
      setAriaDescribedBy: (D) => h(D),
      setUserCompDetails: (D) => f(D),
      getUserCompInstance: () => _.current || void 0
    };
    m.setComp(S, p.current, g.current);
    const E = m.getSelectAllGui();
    g.current.insertAdjacentElement("afterend", E);
  }, []), Fn.useEffect(() => JJ.showJsComp(d, e, p.current, _), [d]), Fn.useEffect(() => {
    let S;
    p.current.childNodes.forEach((E) => {
      E != null && E !== g.current && (S = E);
    }), m.setDragSource(S);
  }, [d]);
  const C = Fn.useMemo(() => ({ width: t }), [t]), y = Fn.useMemo(() => {
    var S;
    return !!(((S = d) === null || S === void 0 ? void 0 : S.componentFromFramework) && QJ.isComponentStateless(d.componentClass));
  }, [d]), w = d && d.componentFromFramework, L = d && d.componentClass;
  return Fn.default.createElement(
    "div",
    { ref: p, className: "ag-header-cell", style: C, title: r, "col-id": s, "aria-sort": l, role: "columnheader", tabIndex: -1, "aria-describedby": c },
    Fn.default.createElement("div", { ref: g, className: "ag-header-cell-resize", role: "presentation" }),
    w && y && Fn.default.createElement(L, Object.assign({}, d.params)),
    w && !y && Fn.default.createElement(L, Object.assign({}, d.params, { ref: _ }))
  );
};
aN.default = Fn.memo(eee);
var lN = {}, tee = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(lN, "__esModule", { value: !0 });
const zn = tee(bt), iee = xr, nee = rc, OF = so, ree = (n) => {
  const { context: e } = zn.useContext(iee.BeansContext), [t, i] = zn.useState(new OF.CssClasses()), [r, o] = zn.useState(new OF.CssClasses()), [s, a] = zn.useState(), [l, u] = zn.useState(), [c, h] = zn.useState(), [d, f] = zn.useState(), [p, g] = zn.useState(), _ = zn.useRef(null), m = zn.useRef(null), { ctrl: v } = n;
  zn.useEffect(() => {
    const E = {
      setWidth: (D) => a(D),
      addOrRemoveCssClass: (D, x) => i((R) => R.setClass(D, x)),
      setColId: (D) => h(D),
      setTitle: (D) => u(D),
      setUserCompDetails: (D) => g(D),
      addOrRemoveResizableCssClass: (D, x) => o((R) => R.setClass(D, x)),
      setAriaExpanded: (D) => f(D)
    };
    v.setComp(E, _.current, m.current);
  }, []), zn.useEffect(() => nee.showJsComp(p, e, _.current), [p]), zn.useEffect(() => {
    let E;
    _.current.childNodes.forEach((D) => {
      D != null && D !== m.current && (E = D);
    }), E && v.setDragSource(E);
  }, [p]);
  const C = zn.useMemo(() => ({
    width: s
  }), [s]), y = zn.useMemo(() => "ag-header-group-cell " + t.toString(), [t]), w = zn.useMemo(() => "ag-header-cell-resize " + r.toString(), [r]), L = p && p.componentFromFramework, S = p && p.componentClass;
  return zn.default.createElement(
    "div",
    { ref: _, className: y, style: C, title: l, "col-id": c, role: "columnheader", tabIndex: -1, "aria-expanded": d },
    L && zn.default.createElement(S, Object.assign({}, p.params)),
    zn.default.createElement("div", { ref: m, className: w })
  );
};
lN.default = zn.memo(ree);
var uN = {}, oee = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(uN, "__esModule", { value: !0 });
const $i = oee(bt), see = xr, aee = vr, oy = so, lee = rc, uee = (n) => {
  const { context: e } = $i.useContext(see.BeansContext), [t, i] = $i.useState(new oy.CssClasses()), [r, o] = $i.useState(new oy.CssClasses()), [s, a] = $i.useState(new oy.CssClasses()), [l, u] = $i.useState(), [c, h] = $i.useState(), d = $i.useRef(null), f = $i.useRef(null), p = $i.useRef(null), g = $i.useRef(null), _ = $i.useRef(), m = $i.useMemo(() => new aee.AgPromise((x) => _.current = x), []), { ctrl: v } = n;
  $i.useEffect(() => {
    const x = {
      addOrRemoveCssClass: (R, A) => i((M) => M.setClass(R, A)),
      addOrRemoveBodyCssClass: (R, A) => o((M) => M.setClass(R, A)),
      addOrRemoveButtonWrapperCssClass: (R, A) => a((M) => M.setClass(R, A)),
      setWidth: (R) => u(R),
      setCompDetails: (R) => h(R),
      getFloatingFilterComp: () => m,
      setMenuIcon: (R) => g.current.appendChild(R)
    };
    v.setComp(x, d.current, g.current, f.current);
  }, []), $i.useEffect(() => lee.showJsComp(c, e, f.current, _.current), [c]);
  const C = $i.useMemo(() => ({
    width: l
  }), [l]), y = $i.useMemo(() => "ag-header-cell ag-floating-filter " + t.toString(), [t]), w = $i.useMemo(() => r.toString(), [r]), L = $i.useMemo(() => "ag-floating-filter-button " + s.toString(), [r]), S = $i.useMemo(() => !!(c && c.componentFromFramework && oy.isComponentStateless(c.componentClass)), [c]), E = c && c.componentFromFramework, D = c && c.componentClass;
  return $i.default.createElement(
    "div",
    { ref: d, className: y, style: C, role: "gridcell", tabIndex: -1 },
    $i.default.createElement(
      "div",
      { ref: f, className: w, role: "presentation" },
      E && S && $i.default.createElement(D, Object.assign({}, c.params)),
      E && !S && $i.default.createElement(D, Object.assign({}, c.params, { ref: _.current }))
    ),
    $i.default.createElement(
      "div",
      { ref: p, className: L, role: "presentation" },
      $i.default.createElement("button", { ref: g, type: "button", "aria-label": "Open Filter Menu", className: "ag-floating-filter-button-button", tabIndex: -1 })
    )
  );
};
uN.default = $i.memo(uee);
var cee = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, cN = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(sN, "__esModule", { value: !0 });
const Bh = vr, Sr = cee(bt), hee = xr, dee = cN(aN), fee = cN(lN), pee = cN(uN), gee = (n) => {
  const { gridOptionsWrapper: e } = Sr.useContext(hee.BeansContext), [t, i] = Sr.useState(), [r, o] = Sr.useState(), [s, a] = Sr.useState(), [l, u] = Sr.useState(), [c, h] = Sr.useState(), [d, f] = Sr.useState([]), p = Sr.useRef(null), { ctrl: g } = n, _ = g.getType() === Bh.HeaderRowType.COLUMN, m = g.getType() === Bh.HeaderRowType.COLUMN_GROUP, v = g.getType() === Bh.HeaderRowType.FLOATING_FILTER, C = Sr.useCallback((S, E) => {
    if (e.isEnsureDomOrder())
      return E;
    const D = Bh._.mapById(S, (M) => M.getInstanceId()), x = Bh._.mapById(E, (M) => M.getInstanceId()), R = S.filter((M) => x.has(M.getInstanceId())), A = E.filter((M) => !D.has(M.getInstanceId()));
    return [...R, ...A];
  }, []);
  Sr.useEffect(() => {
    const S = {
      setTransform: (E) => i(E),
      setHeight: (E) => o(E),
      setTop: (E) => a(E),
      setHeaderCtrls: (E) => f((D) => C(D, E)),
      setWidth: (E) => u(E),
      setAriaRowIndex: (E) => h(E)
    };
    g.setComp(S);
  }, []);
  const y = Sr.useMemo(() => ({
    transform: t,
    height: r,
    top: s,
    width: l
  }), [t, r, s, l]), w = Sr.useMemo(() => {
    const S = ["ag-header-row"];
    return _ && S.push("ag-header-row-column"), m && S.push("ag-header-row-column-group"), v && S.push("ag-header-row-column-filter"), S.join(" ");
  }, []), L = Sr.useCallback((S) => {
    switch (g.getType()) {
      case Bh.HeaderRowType.COLUMN_GROUP:
        return Sr.default.createElement(fee.default, { ctrl: S, key: S.getInstanceId() });
      case Bh.HeaderRowType.FLOATING_FILTER:
        return Sr.default.createElement(pee.default, { ctrl: S, key: S.getInstanceId() });
      default:
        return Sr.default.createElement(dee.default, { ctrl: S, key: S.getInstanceId() });
    }
  }, []);
  return Sr.default.createElement("div", { ref: p, className: w, role: "row", style: y, "aria-rowindex": c }, d.map(L));
};
sN.default = Sr.memo(gee);
var mee = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, vee = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(oN, "__esModule", { value: !0 });
const ar = mee(bt), _ee = xr, qL = vr, Cee = so, yee = vee(sN), wee = (n) => {
  const [e, t] = ar.useState(new Cee.CssClasses()), [i, r] = ar.useState(), [o, s] = ar.useState(), [a, l] = ar.useState(), [u, c] = ar.useState([]), { context: h } = ar.useContext(_ee.BeansContext), d = ar.useRef(null), f = n.pinned === qL.Constants.PINNED_LEFT, p = n.pinned === qL.Constants.PINNED_RIGHT, g = !f && !p;
  ar.useEffect(() => {
    const y = {
      addOrRemoveCssClass: (L, S) => t((E) => E.setClass(L, S)),
      setCtrls: (L) => c(L),
      // centre only
      setCenterWidth: (L) => r(L),
      setContainerTransform: (L) => s(L),
      // pinned only
      setPinnedContainerWidth: (L) => l(L)
    }, w = h.createBean(new qL.HeaderRowContainerCtrl(n.pinned));
    return w.setComp(y, d.current), () => {
      h.destroyBean(w);
    };
  }, []);
  const _ = ar.useMemo(() => e.toString(), [e]), m = () => u.map((y) => ar.default.createElement(yee.default, { ctrl: y, key: y.getInstanceId() })), v = ar.useMemo(() => ({
    width: i,
    transform: o
  }), [i, o]), C = ar.useMemo(() => ({
    width: a,
    minWidth: a,
    maxWidth: a
  }), [a]);
  return ar.default.createElement(
    ar.default.Fragment,
    null,
    f && ar.default.createElement("div", { ref: d, className: "ag-pinned-left-header " + _, role: "presentation", style: C }, m()),
    p && ar.default.createElement("div", { ref: d, className: "ag-pinned-right-header " + _, role: "presentation", style: C }, m()),
    g && ar.default.createElement(
      "div",
      { ref: d, className: "ag-header-viewport " + _, role: "presentation" },
      ar.default.createElement("div", { className: "ag-header-container", role: "rowgroup", style: v }, m())
    )
  );
};
oN.default = ar.memo(wee);
var bee = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, See = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(rN, "__esModule", { value: !0 });
const ta = bee(bt), Eee = xr, YL = vr, Lee = so, XL = See(oN), Dee = () => {
  const [n, e] = ta.useState(new Lee.CssClasses()), [t, i] = ta.useState(), { context: r } = ta.useContext(Eee.BeansContext), o = ta.useRef(null);
  ta.useEffect(() => {
    const l = {
      addOrRemoveCssClass: (c, h) => e((d) => d.setClass(c, h)),
      setHeightAndMinHeight: (c) => i(c)
    }, u = r.createBean(new YL.GridHeaderCtrl());
    return u.setComp(l, o.current, o.current), () => {
      r.destroyBean(u);
    };
  }, []);
  const s = ta.useMemo(() => "ag-header " + n.toString(), [n]), a = ta.useMemo(() => ({
    height: t,
    minHeight: t
  }), [t]);
  return ta.default.createElement(
    "div",
    { ref: o, className: s, style: a, role: "presentation" },
    ta.default.createElement(XL.default, { pinned: YL.Constants.PINNED_LEFT }),
    ta.default.createElement(XL.default, { pinned: null }),
    ta.default.createElement(XL.default, { pinned: YL.Constants.PINNED_RIGHT })
  );
};
rN.default = ta.memo(Dee);
var F_ = {};
Object.defineProperty(F_, "__esModule", { value: !0 });
const Ree = bt, Tee = (n, e) => {
  Ree.useEffect(() => {
    const t = e.current, i = t.parentElement;
    if (!i)
      return;
    const r = document.createComment(n);
    return i.insertBefore(r, t), () => {
      i.removeChild(r);
    };
  }, []);
};
F_.default = Tee;
var hN = {}, dN = {}, uG = {}, fN = {}, Oee = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(fN, "__esModule", { value: !0 });
const xee = vr, $f = Oee(bt), Nee = pg, Iee = xr, Pee = (n) => {
  const [e, t] = $f.useState(), { context: i, popupService: r, gridOptionsWrapper: o } = $f.useContext(Iee.BeansContext);
  return $f.useEffect(() => {
    const { editDetails: s, cellCtrl: a, eParentCell: l } = n, { compDetails: u } = s, c = o.isStopEditingWhenCellsLoseFocus(), h = i.createBean(new xee.PopupEditorWrapper(u.params)), d = h.getGui();
    if (n.jsChildComp) {
      const v = n.jsChildComp.getGui();
      v && d.appendChild(v);
    }
    const f = {
      column: a.getColumn(),
      rowNode: a.getRowNode(),
      type: "popupCellEditor",
      eventSource: l,
      ePopup: d,
      keepWithinBounds: !0
    }, p = s.popupPosition === "under" ? r.positionPopupUnderComponent.bind(r, f) : r.positionPopupOverComponent.bind(r, f), g = o.getLocaleTextFunc(), _ = r.addPopup({
      modal: c,
      eChild: d,
      closeOnEsc: !0,
      closedCallback: () => {
        a.onPopupEditorClosed();
      },
      anchorToElement: l,
      positionCallback: p,
      ariaLabel: g("ariaLabelCellEditor", "Cell Editor")
    }), m = _ ? _.hideFunc : void 0;
    return t(h), n.jsChildComp && n.jsChildComp.afterGuiAttached && n.jsChildComp.afterGuiAttached(), () => {
      m != null && m(), i.destroyBean(h);
    };
  }, []), $f.default.createElement($f.default.Fragment, null, e && n.wrappedContent && Nee.createPortal(n.wrappedContent, e.getGui()));
};
fN.default = $f.memo(Pee);
var pN = {};
Object.defineProperty(pN, "__esModule", { value: !0 });
const sy = bt, Aee = xr, Mee = (n, e, t, i, r, o) => {
  const { context: s, userComponentFactory: a } = sy.useContext(Aee.BeansContext), l = sy.useCallback(() => {
    const u = r.current;
    if (!u)
      return;
    const c = u.getGui();
    c && c.parentElement && c.parentElement.removeChild(c), s.destroyBean(u), r.current = void 0;
  }, []);
  sy.useEffect(() => {
    const u = n != null, c = n && n.compDetails && !n.compDetails.componentFromFramework, h = e && t == null;
    if (!(u && c && !h)) {
      l();
      return;
    }
    const f = n.compDetails;
    if (r.current) {
      const v = r.current, y = v.refresh != null && n.force == !1 ? v.refresh(f.params) : !1;
      if (y === !0 || y === void 0)
        return;
      l();
    }
    const p = f.newAgStackInstance();
    if (!p)
      return;
    const g = p.resolveNow(null, (v) => v);
    if (!g)
      return;
    const _ = g.getGui();
    if (!_)
      return;
    (e ? t : o.current).appendChild(_), r.current = g;
  }, [n, e, i]), sy.useEffect(() => l, []);
};
pN.default = Mee;
(function(n) {
  var e = Ae && Ae.__importStar || function(p) {
    if (p && p.__esModule)
      return p;
    var g = {};
    if (p != null)
      for (var _ in p)
        Object.hasOwnProperty.call(p, _) && (g[_] = p[_]);
    return g.default = p, g;
  }, t = Ae && Ae.__importDefault || function(p) {
    return p && p.__esModule ? p : { default: p };
  };
  Object.defineProperty(n, "__esModule", { value: !0 });
  const i = vr, r = e(bt), o = so, s = t(fN), a = t(pN), l = xr, u = rc;
  (function(p) {
    p[p.ShowValue = 0] = "ShowValue", p[p.EditValue = 1] = "EditValue";
  })(n.CellCompState || (n.CellCompState = {}));
  const c = (p, g, _) => {
    const m = _.getColumn();
    if (!p && g.isPopup && g.isPopup()) {
      const v = `AG Grid: Found an issue in column ${m.getColId()}. If using React, specify an editor is a popup using colDef.cellEditorPopup=true. AG Grid React cannot depend on the editor component specifying if it's in a popup (via the isPopup() method on the editor), as React needs to know this information BEFORE the component is created.`;
      i._.doOnce(() => console.warn(v), "jsEditorComp-isPopup-" + _.getColumn().getColId());
    }
    if (p && g.getPopupPosition && g.getPopupPosition() != null) {
      const v = `AG Grid: Found an issue in column ${m.getColId()}. If using React, specify an editor popup position using colDef.cellEditorPopupPosition=true. AG Grid React cannot depend on the editor component specifying it's position (via the getPopupPosition() method on the editor), as React needs to know this information BEFORE the component is created.`;
      i._.doOnce(() => console.warn(v), "jsEditorComp-getPopupPosition-" + _.getColumn().getColId());
    }
  }, h = (p, g, _, m, v, C) => {
    const y = p.compDetails, w = y.componentClass, L = y.componentFromFramework && !p.popup, S = y.componentFromFramework && p.popup, E = !y.componentFromFramework && p.popup;
    return r.default.createElement(
      r.default.Fragment,
      null,
      L && r.default.createElement(w, Object.assign({}, p.compDetails.params, { ref: g })),
      S && r.default.createElement(s.default, { editDetails: p, cellCtrl: v, eParentCell: m, wrappedContent: r.default.createElement(w, Object.assign({}, p.compDetails.params, { ref: _ })) }),
      E && C && r.default.createElement(s.default, { editDetails: p, cellCtrl: v, eParentCell: m, jsChildComp: C })
    );
  }, d = (p, g, _, m, v, C, y) => {
    const { compDetails: w, value: L } = p, S = !w, E = w && w.componentFromFramework, D = w && w.componentClass, x = L && L.toString ? L.toString() : L, R = () => r.default.createElement(
      r.default.Fragment,
      null,
      S && r.default.createElement(r.default.Fragment, null, x),
      E && !C && r.default.createElement(D, Object.assign({}, w.params, { key: g, ref: m })),
      E && C && r.default.createElement(D, Object.assign({}, w.params, { key: g }))
    );
    return r.default.createElement(r.default.Fragment, null, v ? r.default.createElement("span", { role: "presentation", id: `cell-${_}`, className: "ag-cell-value", ref: y }, R()) : R());
  }, f = (p) => {
    const { context: g } = r.useContext(l.BeansContext), { cellCtrl: _, printLayout: m, editingRow: v } = p, [C, y] = r.useState(), [w, L] = r.useState(), [S, E] = r.useState(1), [D, x] = r.useState(new o.CssClasses()), [R, A] = r.useState(), [M, z] = r.useState(), [j, $] = r.useState(), [k, ae] = r.useState(), [re, Y] = r.useState(), [K, W] = r.useState(), [B, U] = r.useState(!1), [O, N] = r.useState(!1), [I, V] = r.useState(!1), [te, ue] = r.useState(), De = r.useMemo(() => _.isForceWrapper(), []), ce = r.useRef(null), ke = r.useRef(null), Ie = r.useRef(), $e = r.useRef(), Ot = r.useRef(), [It, ti] = r.useState(0), ii = r.useCallback((Q) => {
      Ot.current = Q, ti((le) => le + 1);
    }, []), lt = r.useRef(), [Ui, zt] = r.useState(0), Xi = r.useCallback((Q) => {
      lt.current = Q, zt((le) => le + 1);
    }, []), Zi = C != null && (B || I || O), Si = De || Zi, pt = r.useCallback((Q, le) => {
      $e.current = le, le && (c(Q, le, _), le.isCancelBeforeStart && le.isCancelBeforeStart() && setTimeout(() => _.stopEditing(), 0));
    }, []), ai = r.useCallback((Q) => pt(!0, Q), []), tr = r.useCallback((Q) => pt(!1, Q), []);
    a.default(C, Si, lt.current, Ui, Ie, ce);
    const Nn = r.useRef();
    r.useEffect(() => {
      const Q = Nn.current, le = C;
      if (Nn.current = C, Q == null || Q.compDetails == null || le == null || le.compDetails == null)
        return;
      const pe = Q.compDetails, Ee = le.compDetails;
      if (pe.componentClass != Ee.componentClass || ke.current == null || ke.current.refresh == null)
        return;
      ke.current.refresh(Ee.params) != !0 && E((Ke) => Ke + 1);
    }, [C]), r.useEffect(() => {
      if (!(w && !w.compDetails.componentFromFramework))
        return;
      const le = w.compDetails, pe = w.popup === !0, Ee = u.createSyncJsComp(le);
      if (!Ee)
        return;
      const Pe = Ee.getGui();
      return pt(pe, Ee), pe || (ce.current.appendChild(Pe), Ee.afterGuiAttached && Ee.afterGuiAttached()), ue(Ee), () => {
        g.destroyBean(Ee), pt(pe, void 0), ue(void 0), Pe && Pe.parentElement && Pe.parentElement.removeChild(Pe);
      };
    }, [w]), r.useEffect(() => {
      if (!_ || !g || ($(Ot.current ? `cell-${_.getInstanceId()}` : void 0), !Ot.current || !Si))
        return;
      const Q = [], le = (pe) => {
        if (pe) {
          const Ee = pe.getGui();
          Ot.current.insertAdjacentElement("afterbegin", Ee), Q.push(() => {
            g.destroyBean(pe), i._.removeFromParent(Ee);
          });
        }
        return pe;
      };
      return B && le(_.createSelectionCheckbox()), I && le(_.createDndSource()), O && le(_.createRowDragComp()), () => {
        Q.forEach((pe) => {
          pe();
        });
      };
    }, [Si, I, O, B, It]), r.useEffect(() => {
      if (!_)
        return;
      const Q = {
        addOrRemoveCssClass: (pe, Ee) => x((Pe) => Pe.setClass(pe, Ee)),
        setUserStyles: (pe) => A(pe),
        getFocusableElement: () => ce.current,
        setTabIndex: (pe) => z(pe),
        setRole: (pe) => ae(pe),
        setColId: (pe) => Y(pe),
        setTitle: (pe) => W(pe),
        setIncludeSelection: (pe) => U(pe),
        setIncludeRowDrag: (pe) => N(pe),
        setIncludeDndSource: (pe) => V(pe),
        getCellEditor: () => $e.current || null,
        getCellRenderer: () => ke.current ? ke.current : Ie.current,
        getParentOfValue: () => lt.current ? lt.current : Ot.current ? Ot.current : ce.current,
        setRenderDetails: (pe, Ee, Pe) => {
          y({
            value: Ee,
            compDetails: pe,
            force: Pe
          });
        },
        setEditDetails: (pe, Ee, Pe) => {
          pe ? (L({
            compDetails: pe,
            popup: Ee,
            popupPosition: Pe
          }), Ee || y(void 0)) : L(void 0);
        }
      }, le = Ot.current || void 0;
      _.setComp(Q, null, ce.current, le, m, v);
    }, []);
    const Hn = r.useMemo(() => !!(C && C.compDetails && C.compDetails.componentFromFramework && o.isComponentStateless(C.compDetails.componentClass)), [C]), Yt = r.useMemo(() => {
      let Q = D.toString();
      return Si || (Q += " ag-cell-value"), Q;
    }, [D, Zi]), No = r.useMemo(() => _.getInstanceId(), []), oe = () => r.default.createElement(
      r.default.Fragment,
      null,
      C != null && d(C, S, No, ke, Si, Hn, Xi),
      w != null && h(w, tr, ai, ce.current, _, te)
    );
    return r.default.createElement("div", { ref: ce, className: Yt, style: R, tabIndex: M, role: k, "col-id": re, title: K, "aria-describedby": j }, Si ? r.default.createElement("div", { className: "ag-cell-wrapper", role: "presentation", ref: ii }, oe()) : oe());
  };
  n.default = r.memo(f);
})(uG);
var Fee = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, kee = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(dN, "__esModule", { value: !0 });
const Li = Fee(bt), Wee = vr, Vee = rc, Bee = so, Hee = xr, Gee = kee(uG), Uee = (n, e, t) => {
  if (t) {
    const l = { list: e, instanceIdMap: /* @__PURE__ */ new Map() };
    return e.forEach((u) => l.instanceIdMap.set(u.getInstanceId(), u)), l;
  }
  const i = [], r = [], o = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  return e.forEach((l) => s.set(l.getInstanceId(), l)), n.list.forEach((l) => {
    const u = l.getInstanceId();
    s.has(u) && (i.push(l), o.set(u, l));
  }), e.forEach((l) => {
    const u = l.getInstanceId();
    n.instanceIdMap.has(u) || (r.push(l), o.set(u, l));
  }), {
    list: [...i, ...r],
    instanceIdMap: o
  };
}, zee = (n) => {
  const { context: e } = Li.useContext(Hee.BeansContext), { rowCtrl: t, containerType: i } = n, [r, o] = Li.useState(), [s, a] = Li.useState(), [l, u] = Li.useState(), [c, h] = Li.useState(), [d, f] = Li.useState(), [p, g] = Li.useState(), [_, m] = Li.useState({ list: [], instanceIdMap: /* @__PURE__ */ new Map() }), [v, C] = Li.useState(), [y, w] = Li.useState(!1), [L, S] = Li.useState(t.getInitialRowTop()), [E, D] = Li.useState(t.getInitialTransform()), x = Li.useRef(null), R = Li.useRef(), A = Li.useRef(!1), [M, z] = Li.useState(0);
  Li.useEffect(() => {
    var W;
    if (A.current || !v || M > 10)
      return;
    const B = (W = x.current) === null || W === void 0 ? void 0 : W.firstChild;
    B ? (t.setupDetailRowAutoHeight(B), A.current = !0) : z((U) => U + 1);
  }, [v, M]);
  const j = Li.useMemo(() => new Wee.CssClassManager(() => x.current), []);
  Li.useEffect(() => {
    if (!t.isAlive())
      return;
    const W = {
      // the rowTop is managed by state, instead of direct style manipulation by rowCtrl (like all the other styles)
      // as we need to have an initial value when it's placed into he DOM for the first time, for animation to work.
      setTop: (B) => S(B),
      setTransform: (B) => D(B),
      // i found using React for managing classes at the row level was to slow, as modifying classes caused a lot of
      // React code to execute, so avoiding React for managing CSS Classes made the grid go much faster.
      addOrRemoveCssClass: (B, U) => j.addOrRemoveCssClass(B, U),
      setDomOrder: (B) => w(B),
      setRowIndex: (B) => o(B),
      setRowId: (B) => a(B),
      setRowBusinessKey: (B) => h(B),
      setTabIndex: (B) => f(B),
      setUserStyles: (B) => g(B),
      setRole: (B) => u(B),
      // if we don't maintain the order, then cols will be ripped out and into the dom
      // when cols reordered, which would stop the CSS transitions from working
      setCellCtrls: (B) => m((U) => Uee(U, B, y)),
      showFullWidth: (B) => C(B),
      getFullWidthCellRenderer: () => R.current
    };
    t.setComp(W, x.current, i);
  }, []), Li.useEffect(() => Vee.showJsComp(v, e, x.current, R), [v]);
  const $ = Li.useMemo(() => {
    const W = { top: L, transform: E };
    return Object.assign(W, p), W;
  }, [L, E, p]), k = v && v.componentFromFramework, ae = _ != null, re = Li.useMemo(() => {
    var W;
    return !!(((W = v) === null || W === void 0 ? void 0 : W.componentFromFramework) && Bee.isComponentStateless(v.componentClass));
  }, [v]), Y = () => _.list.map((W) => Li.default.createElement(Gee.default, { cellCtrl: W, editingRow: t.isEditing(), printLayout: t.isPrintLayout(), key: W.getInstanceId() })), K = () => {
    const W = v.componentClass;
    return Li.default.createElement(
      Li.default.Fragment,
      null,
      re && Li.default.createElement(W, Object.assign({}, v.params)),
      !re && Li.default.createElement(W, Object.assign({}, v.params, { ref: R }))
    );
  };
  return Li.default.createElement(
    "div",
    { ref: x, role: l, style: $, "row-index": r, "row-id": s, "row-business-key": c, tabIndex: d },
    ae && Y(),
    k && K()
  );
};
dN.default = Li.memo(zee);
var jee = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, cG = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(hN, "__esModule", { value: !0 });
const If = vr, Ki = jee(bt), ZL = so, $ee = cG(F_), Kee = cG(dN), qee = xr, Yee = (n) => {
  const { context: e } = Ki.useContext(qee.BeansContext), [t, i] = Ki.useState(""), [r, o] = Ki.useState([]), [s, a] = Ki.useState([]), [l, u] = Ki.useState(!1), [c, h] = Ki.useState(""), { name: d } = n, f = Ki.useMemo(() => If.getRowContainerTypeForName(d), [d]), p = Ki.useRef(null), g = Ki.useRef(null), _ = Ki.useRef(null), m = Ki.useMemo(() => If.RowContainerCtrl.getRowContainerCssClasses(d), [d]), v = Ki.useMemo(() => ZL.classesList(m.wrapper), []), C = Ki.useMemo(() => ZL.classesList(m.viewport), []), y = Ki.useMemo(() => ZL.classesList(m.container), []), w = d === If.RowContainerName.CENTER, L = d === If.RowContainerName.TOP_CENTER || d === If.RowContainerName.BOTTOM_CENTER, S = !w && !L, E = w ? p : L ? g : _;
  $ee.default(" AG Row Container " + d + " ", E), Ki.useEffect(() => {
    o((A) => {
      if (l)
        return s;
      const M = A.filter(($) => s.indexOf($) >= 0), z = s.filter(($) => M.indexOf($) < 0);
      return [...M, ...z];
    });
  }, [l, s]), Ki.useEffect(() => {
    const A = [], M = {
      setViewportHeight: i,
      setRowCtrls: (j) => a(j),
      setDomOrder: (j) => u(j),
      setContainerWidth: (j) => h(j)
    }, z = e.createBean(new If.RowContainerCtrl(d));
    return A.push(z), z.setComp(M, _.current, g.current, p.current), () => {
      e.destroyBeans(A);
    };
  }, []);
  const D = Ki.useMemo(() => ({
    height: t
  }), [t]), x = Ki.useMemo(() => ({
    width: c
  }), [c]), R = () => Ki.default.createElement("div", { className: y, ref: _, role: "rowgroup", style: x }, r.map((A) => Ki.default.createElement(Kee.default, { rowCtrl: A, containerType: f, key: A.getInstanceId() })));
  return Ki.default.createElement(
    Ki.default.Fragment,
    null,
    w && Ki.default.createElement(
      "div",
      { className: v, ref: p, role: "presentation" },
      Ki.default.createElement("div", { className: C, ref: g, role: "presentation", style: D }, R())
    ),
    L && Ki.default.createElement("div", { className: C, ref: g, role: "presentation", style: D }, R()),
    S && R()
  );
};
hN.default = Ki.memo(Yee);
var Xee = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, gN = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(nN, "__esModule", { value: !0 });
const as = vr, Di = Xee(bt), Zee = xr, Qee = gN(rN), ay = gN(F_), Jee = gN(hN), ly = so, ete = () => {
  const { context: n, agStackComponentsRegistry: e, resizeObserverService: t } = Di.useContext(Zee.BeansContext), [i, r] = Di.useState(""), [o, s] = Di.useState(0), [a, l] = Di.useState(0), [u, c] = Di.useState(0), [h, d] = Di.useState(0), [f, p] = Di.useState(""), [g, _] = Di.useState(""), [m, v] = Di.useState(null), [C, y] = Di.useState(""), [w, L] = Di.useState(null), [S, E] = Di.useState(""), [D, x] = Di.useState(null), R = Di.useRef(null), A = Di.useRef(null), M = Di.useRef(null), z = Di.useRef(null);
  ay.default(" AG Grid Body ", R), ay.default(" AG Pinned Top ", A), ay.default(" AG Middle ", M), ay.default(" AG Pinned Bottom ", z), Di.useEffect(() => {
    const B = [], U = [];
    if (!n)
      return;
    const O = (V) => {
      const te = e.getComponentClass(V), ue = n.createBean(new te());
      return B.push(ue), ue;
    };
    R.current.appendChild(document.createComment(" AG Fake Horizontal Scroll ")), R.current.appendChild(O("AG-FAKE-HORIZONTAL-SCROLL").getGui()), R.current.appendChild(document.createComment(" AG Overlay Wrapper ")), R.current.appendChild(O("AG-OVERLAY-WRAPPER").getGui());
    const N = {
      setRowAnimationCssOnBodyViewport: r,
      setColumnCount: s,
      setRowCount: l,
      setTopHeight: c,
      setBottomHeight: d,
      setTopDisplay: p,
      setBottomDisplay: _,
      setColumnMovingCss: v,
      updateLayoutClasses: y,
      setAlwaysVerticalScrollClass: L,
      setPinnedTopBottomOverflowY: E,
      setCellSelectableCss: x,
      registerBodyViewportResizeListener: (V) => {
        const te = t.observeResize(M.current, V);
        U.push(() => te());
      }
    }, I = n.createBean(new as.GridBodyCtrl());
    return B.push(I), I.setComp(N, R.current, M.current, A.current, z.current), () => {
      n.destroyBeans(B), U.forEach((V) => V());
    };
  }, []);
  const j = Di.useMemo(() => ly.classesList("ag-root", "ag-unselectable", m, C), [m, C]), $ = Di.useMemo(() => ly.classesList("ag-body-viewport", i, C, w, D), [i, C, w, D]), k = Di.useMemo(() => ly.classesList("ag-floating-top", D), [D]), ae = Di.useMemo(() => ly.classesList("ag-floating-bottom", D), [D]), re = Di.useMemo(() => ({
    height: u,
    minHeight: u,
    display: f,
    overflowY: S
  }), [u, f, S]), Y = Di.useMemo(() => ({
    height: h,
    minHeight: h,
    display: g,
    overflowY: S
  }), [h, g, S]), K = (B) => Di.default.createElement(Jee.default, { name: B, key: `${B}-container` }), W = ({ section: B, children: U, className: O, style: N }) => Di.default.createElement("div", { ref: B, className: O, role: "presentation", style: N }, U.map(K));
  return Di.default.createElement(
    "div",
    { ref: R, className: j, role: "grid", "aria-colcount": o, "aria-rowcount": a },
    Di.default.createElement(Qee.default, null),
    W({ section: A, className: k, style: re, children: [
      as.RowContainerName.TOP_LEFT,
      as.RowContainerName.TOP_CENTER,
      as.RowContainerName.TOP_RIGHT,
      as.RowContainerName.TOP_FULL_WIDTH
    ] }),
    W({ section: M, className: $, children: [
      as.RowContainerName.LEFT,
      as.RowContainerName.CENTER,
      as.RowContainerName.RIGHT,
      as.RowContainerName.FULL_WIDTH
    ] }),
    W({ section: z, className: ae, style: Y, children: [
      as.RowContainerName.BOTTOM_LEFT,
      as.RowContainerName.BOTTOM_CENTER,
      as.RowContainerName.BOTTOM_RIGHT,
      as.RowContainerName.BOTTOM_FULL_WIDTH
    ] })
  );
};
nN.default = Di.memo(ete);
var mN = {}, tte = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(mN, "__esModule", { value: !0 });
const na = tte(bt), ite = vr, nte = xr, rte = (n, e) => {
  const { children: t, eFocusableElement: i, onTabKeyDown: r, gridCtrl: o } = n, { context: s } = na.useContext(nte.BeansContext), a = na.useRef(null), l = na.useRef(null), u = na.useRef(), [c, h] = na.useState();
  na.useImperativeHandle(e, () => ({
    forceFocusOutOfContainer() {
      u.current.forceFocusOutOfContainer();
    }
  })), na.useEffect(() => {
    const f = a.current, p = l.current, g = {
      setTabIndex: (m) => m == null ? h(void 0) : h(parseInt(m, 10))
    }, _ = u.current = s.createBean(new ite.TabGuardCtrl({
      comp: g,
      eTopGuard: f,
      eBottomGuard: p,
      eFocusableElement: i,
      onTabKeyDown: r,
      focusInnerElement: (m) => o.focusInnerElement(m)
    }));
    return () => {
      s.destroyBean(_);
    };
  }, []);
  const d = (f) => na.default.createElement("div", { className: `ag-tab-guard ag-tab-guard-${f}`, role: "presentation", tabIndex: c, ref: f === "top" ? a : l });
  return na.default.createElement(
    na.default.Fragment,
    null,
    d("top"),
    t,
    d("bottom")
  );
}, ote = na.forwardRef(rte);
mN.default = na.memo(ote);
var ste = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
}, vN = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
};
Object.defineProperty(iN, "__esModule", { value: !0 });
const xF = vr, Wi = ste(bt), ate = xr, lte = vN(nN), ute = vN(F_), cte = vN(mN), NF = so, hte = ({ context: n }) => {
  const [e, t] = Wi.useState(""), [i, r] = Wi.useState(""), [o, s] = Wi.useState(""), [a, l] = Wi.useState(null), [u, c] = Wi.useState(null), [h, d] = Wi.useState(!1), [f, p] = Wi.useState(), g = Wi.useRef(null), _ = Wi.useRef(null), m = Wi.useRef(), v = Wi.useRef(null), C = Wi.useRef(() => {
  }), y = Wi.useCallback(() => {
  }, []), w = Wi.useMemo(() => n.getBean("beans"), []);
  ute.default(" AG Grid ", _), Wi.useEffect(() => {
    const R = g.current = n.createBean(new xF.GridCtrl());
    return () => {
      n.destroyBean(R), g.current = null;
    };
  }, []), Wi.useEffect(() => {
    const R = g.current;
    C.current = R.focusInnerElement.bind(R);
    const A = {
      destroyGridUi: () => {
      },
      setRtlClass: t,
      addOrRemoveKeyboardFocusClass: (M) => r(M ? xF.FocusService.AG_KEYBOARD_FOCUS : ""),
      forceFocusOutOfContainer: () => {
        m.current.forceFocusOutOfContainer();
      },
      updateLayoutClasses: s,
      getFocusableContainers: () => {
        const M = [], z = _.current.querySelector(".ag-root"), j = _.current.querySelector(".ag-side-bar");
        return z && M.push(z), j && M.push(j), M;
      },
      setCursor: l,
      setUserSelect: c
    };
    R.setComp(A, _.current, _.current), d(!0);
  }, []), Wi.useEffect(() => {
    if (!f)
      return;
    const R = g.current, A = [], { agStackComponentsRegistry: M } = w, z = M.getComponentClass("AG-GRID-HEADER-DROP-ZONES"), j = M.getComponentClass("AG-SIDE-BAR"), $ = M.getComponentClass("AG-STATUS-BAR"), k = M.getComponentClass("AG-WATERMARK"), ae = M.getComponentClass("AG-PAGINATION"), re = [], Y = _.current, K = v.current;
    if (R.showDropZones() && z) {
      const W = n.createBean(new z()), B = W.getGui();
      Y.insertAdjacentElement("afterbegin", B), re.push(B), A.push(W);
    }
    if (R.showSideBar() && j) {
      const W = n.createBean(new j()), B = W.getGui(), U = K.querySelector(".ag-tab-guard-bottom");
      U && (U.insertAdjacentElement("beforebegin", B), re.push(B)), A.push(W);
    }
    if (R.showStatusBar() && $) {
      const W = n.createBean(new $()), B = W.getGui();
      Y.insertAdjacentElement("beforeend", B), re.push(B), A.push(W);
    }
    if (ae) {
      const W = n.createBean(new ae()), B = W.getGui();
      Y.insertAdjacentElement("beforeend", B), re.push(B), A.push(W);
    }
    if (R.showWatermark() && k) {
      const W = n.createBean(new k()), B = W.getGui();
      Y.insertAdjacentElement("beforeend", B), re.push(B), A.push(W);
    }
    return () => {
      n.destroyBeans(A), re.forEach((W) => {
        W.parentElement && W.parentElement.removeChild(W);
      });
    };
  }, [f]);
  const L = Wi.useMemo(() => NF.classesList("ag-root-wrapper", e, i, o), [e, i, o]), S = Wi.useMemo(() => NF.classesList("ag-root-wrapper-body", "ag-focus-managed", o), [o]), E = Wi.useMemo(() => ({
    userSelect: u ?? "",
    WebkitUserSelect: u ?? "",
    cursor: a ?? ""
  }), [u, a]), D = v.current, x = Wi.useCallback((R) => {
    m.current = R, p(!0);
  }, []);
  return Wi.default.createElement(
    "div",
    { ref: _, className: L, style: E },
    Wi.default.createElement("div", { className: S, ref: v }, h && D && Wi.default.createElement(
      ate.BeansContext.Provider,
      { value: w },
      Wi.default.createElement(
        cte.default,
        { ref: x, eFocusableElement: D, onTabKeyDown: y, gridCtrl: g.current },
        // we wait for initialised before rending the children, so GridComp has created and registered with it's
        // GridCtrl before we create the child GridBodyComp. Otherwise the GridBodyComp would initialise first,
        // before we have set the the Layout CSS classes, causing the GridBodyComp to render rows to a grid that
        // doesn't have it's height specified, which would result if all the rows getting rendered (and if many rows,
        // hangs the UI)
        Wi.default.createElement(lte.default, null)
      )
    ))
  );
};
iN.default = Wi.memo(hte);
var IF;
function _N() {
  if (IF)
    return ry;
  IF = 1;
  var n = Ae && Ae.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var f = {};
    if (d != null)
      for (var p in d)
        Object.hasOwnProperty.call(d, p) && (f[p] = d[p]);
    return f.default = d, f;
  }, e = Ae && Ae.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(ry, "__esModule", { value: !0 });
  const t = vr, i = n(bt), r = M_, o = HS, s = GS, a = US, l = e(iN), u = hG();
  class c extends i.Component {
    constructor(f) {
      super(f), this.props = f, this.destroyFuncs = [], this.changeDetectionService = new o.ChangeDetectionService(), this.eGui = i.default.createRef(), this.whenReadyFuncs = [], this.ready = !1, this.state = { context: void 0 }, this.portalManager = new a.PortalManager(this, f.componentWrappingElement, f.maxComponentCreationTimeMs);
    }
    render() {
      return i.default.createElement(
        "div",
        { style: this.createStyleForDiv(), className: this.props.className, ref: this.eGui },
        this.state.context && i.default.createElement(l.default, { context: this.state.context }),
        this.portalManager.getPortals()
      );
    }
    createStyleForDiv() {
      return Object.assign({ height: "100%" }, this.props.containerStyle || {});
    }
    componentDidMount() {
      const f = this.props.modules || [], p = {
        providedBeanInstances: {
          frameworkComponentWrapper: new h(this.portalManager)
        },
        modules: f,
        frameworkOverrides: new u.ReactFrameworkOverrides(!0)
      };
      this.gridOptions = this.props.gridOptions || {};
      const { children: g } = this.props;
      r.AgGridColumn.hasChildColumns(g) && (this.gridOptions.columnDefs = r.AgGridColumn.mapChildColumnDefs(g)), this.gridOptions = t.ComponentUtil.copyAttributesToGridOptions(this.gridOptions, this.props);
      const _ = (C) => {
        this.setState({ context: C }), C.getBean(t.CtrlsService.NAME).whenReady(() => {
          this.api = this.gridOptions.api, this.columnApi = this.gridOptions.columnApi, this.props.setGridApi(this.api, this.columnApi), this.destroyFuncs.push(() => this.api.destroy());
        });
      }, m = (C) => {
        C.getBean(t.CtrlsService.NAME).whenReady(() => {
          this.whenReadyFuncs.forEach((w) => w()), this.whenReadyFuncs.length = 0, this.ready = !0;
        });
      };
      new t.GridCoreCreator().create(this.eGui.current, this.gridOptions, _, m, p);
    }
    componentWillUnmount() {
      this.destroyFuncs.forEach((f) => f());
    }
    componentDidUpdate(f) {
      this.processPropsChanges(f, this.props);
    }
    processPropsChanges(f, p) {
      const g = {};
      this.extractGridPropertyChanges(f, p, g), this.extractDeclarativeColDefChanges(p, g), this.processChanges(g);
    }
    extractDeclarativeColDefChanges(f, p) {
      if (this.props.gridOptions && this.props.gridOptions.columnDefs || this.props.columnDefs)
        return;
      const g = !!f.debug, _ = "columnDefs", m = this.gridOptions.columnDefs;
      if (r.AgGridColumn.hasChildColumns(f.children)) {
        const v = this.changeDetectionService.getStrategy(this.getStrategyTypeForProp(_)), C = r.AgGridColumn.mapChildColumnDefs(f.children);
        v.areEqual(m, C) || (g && console.log("agGridReact: colDefs definitions changed"), p[_] = {
          previousValue: m,
          currentValue: C
        });
      } else
        m && m.length > 0 && (p[_] = {
          previousValue: m,
          currentValue: []
        });
    }
    extractGridPropertyChanges(f, p, g) {
      const _ = !!p.debug;
      Object.keys(p).forEach((m) => {
        t._.includes(t.ComponentUtil.ALL_PROPERTIES, m) && (this.changeDetectionService.getStrategy(this.getStrategyTypeForProp(m)).areEqual(f[m], p[m]) || (_ && console.log(`agGridReact: [${m}] property changed`), g[m] = {
          previousValue: f[m],
          currentValue: p[m]
        }));
      }), t.ComponentUtil.getEventCallbacks().forEach((m) => {
        f[m] !== p[m] && (_ && console.log(`agGridReact: [${m}] event callback changed`), g[m] = {
          previousValue: f[m],
          currentValue: p[m]
        });
      });
    }
    processChanges(f) {
      this.processWhenReady(() => t.ComponentUtil.processOnChange(f, this.gridOptions, this.api, this.columnApi));
    }
    processWhenReady(f) {
      this.ready ? f() : this.whenReadyFuncs.push(f);
    }
    getStrategyTypeForProp(f) {
      if (f === "rowData") {
        if (this.props.rowDataChangeDetectionStrategy)
          return this.props.rowDataChangeDetectionStrategy;
        if (this.isImmutableDataActive())
          return o.ChangeDetectionStrategyType.IdentityCheck;
      }
      return o.ChangeDetectionStrategyType.DeepValueCheck;
    }
    isImmutableDataActive() {
      return this.props.deltaRowDataMode || this.props.immutableData || this.props.gridOptions && (this.props.gridOptions.deltaRowDataMode || this.props.gridOptions.immutableData);
    }
  }
  ry.AgGridReactUi = c;
  class h extends t.BaseComponentWrapper {
    constructor(f) {
      super(), this.parent = f;
    }
    createWrapper(f, p) {
      return new s.NewReactComponent(f, this.parent, p);
    }
  }
  return ry;
}
var PF;
function dte() {
  if (PF)
    return ny;
  PF = 1;
  var n = Ae && Ae.__importStar || function(s) {
    if (s && s.__esModule)
      return s;
    var a = {};
    if (s != null)
      for (var l in s)
        Object.hasOwnProperty.call(s, l) && (a[l] = s[l]);
    return a.default = s, a;
  };
  Object.defineProperty(ny, "__esModule", { value: !0 });
  const e = n(bt), t = so, i = xr, r = _N(), o = (s, a) => {
    const { ctrlsFactory: l, context: u, gridOptionsWrapper: c, resizeObserverService: h, clientSideRowModel: d, serverSideRowModel: f } = e.useContext(i.BeansContext), [p, g] = e.useState(new t.CssClasses()), [_, m] = e.useState(new t.CssClasses()), [v, C] = e.useState(), [y, w] = e.useState(), L = e.useRef(), S = e.useRef(null), E = e.useMemo(() => p.toString() + " ag-details-row", [p]), D = e.useMemo(() => _.toString() + " ag-details-grid", [_]);
    a && e.useImperativeHandle(a, () => ({
      refresh() {
        return L.current.refresh();
      }
    })), e.useEffect(() => {
      s.template && typeof s.template == "string" && console.warn("AG Grid: detailCellRendererParams.template is not supported by React - this only works with frameworks that work against String templates. To change the template, please provide your own React Detail Cell Renderer.");
    }, []), e.useEffect(() => {
      const R = {
        addOrRemoveCssClass: (M, z) => g((j) => j.setClass(M, z)),
        addOrRemoveDetailGridCssClass: (M, z) => m((j) => j.setClass(M, z)),
        setDetailGrid: (M) => C(M),
        setRowData: (M) => w(M)
      }, A = l.getInstance("detailCellRenderer");
      if (A) {
        if (u.createBean(A), A.init(R, s), L.current = A, c.isDetailRowAutoHeight()) {
          const M = () => {
            if (S.current == null)
              return;
            const z = S.current.clientHeight;
            z != null && z > 0 && setTimeout(() => {
              s.node.setRowHeight(z), d ? d.onRowHeightChanged() : f && f.onRowHeightChanged();
            }, 0);
          };
          h.observeResize(S.current, M), M();
        }
        return () => {
          u.destroyBean(A);
        };
      }
    }, []);
    const x = e.useCallback((R, A) => {
      L.current.registerDetailWithMaster(R, A);
    }, []);
    return e.default.createElement("div", { className: E, ref: S }, v && e.default.createElement(r.AgGridReactUi, Object.assign({ className: D }, v, { rowData: y, setGridApi: x })));
  };
  return ny.default = e.forwardRef(o), ny;
}
var AF;
function hG() {
  if (AF)
    return ty;
  AF = 1;
  var n = Ae && Ae.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  };
  Object.defineProperty(ty, "__esModule", { value: !0 });
  const e = vr, t = n(eN), i = n(dte());
  class r extends e.VanillaFrameworkOverrides {
    constructor(s) {
      super(), this.frameworkComponents = {
        agGroupCellRenderer: t.default,
        agGroupRowRenderer: t.default,
        agDetailCellRenderer: i.default
      }, this.reactUi = s;
    }
    frameworkComponent(s) {
      if (this.reactUi)
        return this.frameworkComponents[s];
    }
    isFrameworkComponent(s) {
      if (!s)
        return !1;
      const a = s.prototype;
      return !(a && "getGui" in a);
    }
  }
  return ty.ReactFrameworkOverrides = r, ty;
}
var fte = Ae && Ae.__importDefault || function(n) {
  return n && n.__esModule ? n : { default: n };
}, pte = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(Qx, "__esModule", { value: !0 });
const Co = vr, gh = fte(Qu), MF = pte(bt), gte = Jx, uy = M_, QL = HS, mte = GS, vte = US, _te = hG();
class qp extends MF.Component {
  constructor(e) {
    super(e), this.props = e, this.changeDetectionService = new QL.ChangeDetectionService(), this.api = null, this.destroyed = !1, this.SYNCHRONOUS_CHANGE_PROPERTIES = ["context"], this.portalManager = new vte.PortalManager(this, e.componentWrappingElement, e.maxComponentCreationTimeMs);
  }
  render() {
    return MF.default.createElement("div", {
      style: this.createStyleForDiv(),
      className: this.props.className,
      ref: (e) => {
        this.eGridDiv = e;
      }
    }, this.portalManager.getPortals());
  }
  createStyleForDiv() {
    return Object.assign({ height: "100%" }, this.props.containerStyle || {});
  }
  componentDidMount() {
    const e = this.props.modules || [], t = {
      providedBeanInstances: {
        agGridReact: this,
        frameworkComponentWrapper: new Cte(this, this.portalManager)
      },
      modules: e,
      frameworkOverrides: new _te.ReactFrameworkOverrides(!1)
    }, i = this.props.gridOptions || {}, { children: r } = this.props;
    uy.AgGridColumn.hasChildColumns(r) && (i.columnDefs = uy.AgGridColumn.mapChildColumnDefs(r)), this.gridOptions = Co.ComponentUtil.copyAttributesToGridOptions(i, this.props), new Co.Grid(this.eGridDiv, this.gridOptions, t), this.api = this.gridOptions.api, this.columnApi = this.gridOptions.columnApi, this.props.setGridApi(this.api, this.columnApi);
  }
  getStrategyTypeForProp(e) {
    if (e === "rowData") {
      if (this.props.rowDataChangeDetectionStrategy)
        return this.props.rowDataChangeDetectionStrategy;
      if (this.isImmutableDataActive())
        return QL.ChangeDetectionStrategyType.IdentityCheck;
    }
    return QL.ChangeDetectionStrategyType.DeepValueCheck;
  }
  isImmutableDataActive() {
    return this.props.deltaRowDataMode || this.props.immutableData || this.props.gridOptions && (this.props.gridOptions.deltaRowDataMode || this.props.gridOptions.immutableData || this.props.gridOptions.getRowId);
  }
  shouldComponentUpdate(e) {
    return this.processPropsChanges(this.props, e), !1;
  }
  componentDidUpdate(e) {
    this.processPropsChanges(e, this.props);
  }
  processPropsChanges(e, t) {
    const i = {};
    this.extractGridPropertyChanges(e, t, i), this.extractDeclarativeColDefChanges(t, i), this.processSynchronousChanges(i), this.processAsynchronousChanges(i);
  }
  extractDeclarativeColDefChanges(e, t) {
    if (this.props.gridOptions && this.props.gridOptions.columnDefs || this.props.columnDefs)
      return;
    const i = !!e.debug, r = "columnDefs", o = this.gridOptions.columnDefs;
    if (uy.AgGridColumn.hasChildColumns(e.children)) {
      const s = this.changeDetectionService.getStrategy(this.getStrategyTypeForProp(r)), a = uy.AgGridColumn.mapChildColumnDefs(e.children);
      s.areEqual(o, a) || (i && console.log("agGridReact: colDefs definitions changed"), t[r] = {
        previousValue: o,
        currentValue: a
      });
    } else
      o && o.length > 0 && (t[r] = {
        previousValue: o,
        currentValue: []
      });
  }
  extractGridPropertyChanges(e, t, i) {
    const r = !!t.debug;
    Object.keys(t).forEach((o) => {
      Co._.includes(Co.ComponentUtil.ALL_PROPERTIES, o) && (this.changeDetectionService.getStrategy(this.getStrategyTypeForProp(o)).areEqual(e[o], t[o]) || (r && console.log(`agGridReact: [${o}] property changed`), i[o] = {
        previousValue: e[o],
        currentValue: t[o]
      }));
    }), Co.ComponentUtil.getEventCallbacks().forEach((o) => {
      e[o] !== t[o] && (r && console.log(`agGridReact: [${o}] event callback changed`), i[o] = {
        previousValue: e[o],
        currentValue: t[o]
      });
    });
  }
  componentWillUnmount() {
    this.api && (this.api.destroy(), this.api = null), this.destroyed = !0, this.portalManager.destroy();
  }
  isDisableStaticMarkup() {
    return this.props.disableStaticMarkup === !0;
  }
  isLegacyComponentRendering() {
    return this.props.legacyComponentRendering === !0;
  }
  processSynchronousChanges(e) {
    const t = Object.assign({}, e);
    if (Object.keys(t).length > 0) {
      const i = {};
      this.SYNCHRONOUS_CHANGE_PROPERTIES.forEach((r) => {
        t[r] && (i[r] = t[r], delete t[r]);
      }), Object.keys(i).length > 0 && this.api && Co.ComponentUtil.processOnChange(i, this.gridOptions, this.api, this.columnApi);
    }
    return t;
  }
  processAsynchronousChanges(e) {
    Object.keys(e).length > 0 && window.setTimeout(() => {
      this.api && Co.ComponentUtil.processOnChange(e, this.gridOptions, this.api, this.columnApi);
    });
  }
}
Qx.AgGridReactLegacy = qp;
qp.MAX_COMPONENT_CREATION_TIME_IN_MS = 1e3;
qp.defaultProps = {
  legacyComponentRendering: !1,
  disableStaticMarkup: !1,
  maxComponentCreationTimeMs: qp.MAX_COMPONENT_CREATION_TIME_IN_MS
};
qp.propTypes = {
  gridOptions: gh.default.object
};
nf(Co.ComponentUtil.getEventCallbacks(), gh.default.func);
nf(Co.ComponentUtil.BOOLEAN_PROPERTIES, gh.default.bool);
nf(Co.ComponentUtil.STRING_PROPERTIES, gh.default.string);
nf(Co.ComponentUtil.OBJECT_PROPERTIES, gh.default.object);
nf(Co.ComponentUtil.ARRAY_PROPERTIES, gh.default.array);
nf(Co.ComponentUtil.NUMBER_PROPERTIES, gh.default.number);
nf(Co.ComponentUtil.FUNCTION_PROPERTIES, gh.default.func);
function nf(n, e) {
  n.forEach((t) => {
    qp[t] = e;
  });
}
class Cte extends Co.BaseComponentWrapper {
  constructor(e, t) {
    super(), this.agGridReact = e, this.portalManager = t;
  }
  createWrapper(e, t) {
    return this.agGridReact.isLegacyComponentRendering() ? new gte.LegacyReactComponent(e, this.agGridReact, this.portalManager, t) : new mte.NewReactComponent(e, this.portalManager, t);
  }
}
var yte = Ae && Ae.__importStar || function(n) {
  if (n && n.__esModule)
    return n;
  var e = {};
  if (n != null)
    for (var t in n)
      Object.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  return e.default = n, e;
};
Object.defineProperty(Zx, "__esModule", { value: !0 });
const FF = yte(bt), wte = Qx, bte = _N();
let Ste = class extends FF.Component {
  constructor() {
    super(...arguments), this.setGridApi = (e, t) => {
      this.api = e, this.columnApi = t;
    };
  }
  render() {
    const e = this.props.suppressReactUi ? wte.AgGridReactLegacy : bte.AgGridReactUi;
    return FF.default.createElement(e, Object.assign({}, this.props, { setGridApi: this.setGridApi }));
  }
};
Zx.AgGridReact = Ste;
var qCe = Zx.AgGridReact;
M_.AgGridColumn;
HS.ChangeDetectionStrategyType;
_N().AgGridReactUi;
const kF = {
  "show-settings": "boolean",
  "show-placeholder": "boolean"
}, Ete = {
  "show-close-button": "boolean"
}, WF = {
  "max-count": "number",
  "fetch-additional-count": "number",
  "show-placeholder": "boolean",
  filter: "json"
}, CN = {
  MultipleCursors: {
    context: "json",
    location: "json"
  },
  PagePresence: {
    context: "json",
    location: "json",
    durable: "boolean",
    "max-users": "number",
    "exclude-viewer": "boolean",
    "only-present-users": "boolean",
    orientation: "orientation"
  },
  PresenceFacepile: {
    context: "json",
    location: "json",
    "max-users": "number",
    "exclude-viewer": "boolean",
    "only-present-users": "boolean",
    "exact-match": "boolean",
    orientation: "orientation"
  },
  PresenceObserver: {
    context: "json",
    location: "json",
    "present-events": "array",
    "absent-events": "array",
    "observe-document": "boolean",
    durable: "boolean",
    "initial-state": "boolean"
  },
  Sidebar: {
    context: "json",
    location: "json",
    open: "boolean",
    "show-close-button": "boolean",
    "show-inbox": "boolean",
    "show-presence": "boolean",
    "show-launcher": "boolean",
    "show-all-activity": "boolean",
    "exclude-viewer-from-presence": "boolean",
    "show-pins-on-page": "boolean",
    "thread-name": "string"
  },
  SidebarLauncher: {
    disabled: "boolean",
    label: "string",
    "icon-url": "string",
    "inbox-badge-style": "badge-style"
  },
  Thread: {
    context: "json",
    location: "json",
    "thread-id": "string",
    "thread-name": "string",
    metadata: "json",
    collapsed: "boolean",
    autofocus: "boolean",
    "show-header": "boolean",
    "show-placeholder": "boolean",
    "composer-expanded": "boolean",
    "thread-options": "json"
  },
  ThreadList: {
    location: "json",
    filter: "json",
    "partial-match": "boolean",
    "show-screenshot-preview-in-message": "boolean",
    "highlight-open-floating-thread": "boolean",
    "highlight-thread-id": "string",
    mode: "string",
    "show-placeholder": "boolean"
  },
  Composer: {
    location: "json",
    "thread-id": "string",
    "thread-name": "string",
    autofocus: "boolean",
    "show-expanded": "boolean",
    "show-close-button": "boolean",
    size: "composer-size"
  },
  InboxLauncher: {
    label: "string",
    disabled: "boolean",
    "icon-url": "string",
    "inbox-badge-style": "badge-style",
    "show-inbox-on-click": "boolean",
    ...kF
  },
  Inbox: { ...kF, ...Ete },
  Settings: {},
  FloatingThreads: {
    location: "json",
    disabled: "boolean",
    "show-button": "boolean",
    "button-label": "string",
    "thread-name": "string",
    "show-screenshot-preview": "boolean"
  },
  SelectionComments: {
    location: "json",
    "button-label": "string",
    "icon-url": "string",
    "thread-name": "string"
  },
  NotificationList: {
    ...WF
  },
  Message: {
    "thread-id": "string",
    "message-id": "string"
  },
  Facepile: {
    users: "array",
    "enable-tooltip": "boolean"
  },
  NotificationListLauncher: {
    label: "string",
    "icon-url": "string",
    "badge-style": "badge-style",
    disabled: "boolean",
    ...WF
  },
  Pin: {
    location: "json",
    "thread-id": "string"
  },
  Avatar: {
    "user-id": "string",
    "enable-tooltip": "boolean"
  },
  AddReaction: {
    "thread-id": "string",
    "message-id": "string",
    "enable-tooltip": "boolean",
    disabled: "boolean"
  }
}, Lte = {
  json: (n) => n !== void 0 ? JSON.stringify(n) : void 0,
  boolean: (n) => n == null ? void 0 : n.toString(),
  number: (n) => n == null ? void 0 : n.toString(),
  string: (n) => n === void 0 ? void 0 : n || "",
  array: (n) => n == null ? void 0 : n.join(","),
  "badge-style": (n) => n === void 0 ? void 0 : n || "",
  orientation: (n) => n === void 0 ? void 0 : n || "",
  "composer-size": (n) => n === void 0 ? void 0 : n || ""
};
function Dte(n) {
  return n.replace(/-([a-z])/g, function(e, t) {
    return t.toUpperCase();
  });
}
const yN = (n) => (e) => {
  const t = {};
  for (const i of Object.keys(n)) {
    const r = i, o = Dte(r);
    o in e && (t[r] = Lte[n[r]](e[o]));
  }
  return t;
};
function Rte(n, e) {
  if (n === e)
    return !0;
  if (!n || !e)
    return !1;
  const t = Object.keys(n);
  return t.length !== Object.keys(e).length || !t.every((i) => Object.prototype.hasOwnProperty.call(e, i)) ? !1 : t.every((i) => n[i] === e[i]);
}
const VF = "data-cord-annotation-location";
function dG(n) {
  return JSON.stringify(Object.fromEntries(Object.entries(n).filter(([e, t]) => t !== void 0).sort(([e], [t]) => e < t ? -1 : 1)));
}
let Tte = !1, Ote = null;
try {
  Tte = !!localStorage.getItem("__cord_log_loading_times__"), Ote = localStorage.getItem("__cord_override_script_url__");
} catch {
}
const xte = me.createContext({
  sdk: null,
  location: void 0,
  setLocation: () => {
  },
  hasProvider: !1,
  clientAuthToken: void 0,
  userID: void 0,
  organizationID: void 0
});
function jS(n) {
  const { hasProvider: e, ...t } = pz(xte);
  return oh(() => {
    e || console.error(`[Cord SDK] The ${n} hook is used in a component that is not a descendant of <CordProvider>.`);
  }, [e, n]), t;
}
function fG(n) {
  const { location: e, setLocation: t } = jS("useCordLocation");
  return oh(() => {
    n && !Rte(e, n) && t(n);
  }, [n, e, t]), oh(() => () => {
    t(void 0);
  }, [t]), n ?? e;
}
function Nte(n, e) {
  const [t, i] = RA(null), [r, o] = RA(!1);
  return oh(() => {
    if (!t)
      return;
    const s = Object.keys(n).map((a) => {
      const l = n[a], u = (h) => {
        h instanceof CustomEvent && (l == null || l(...h.detail));
      }, c = `${e ?? t.nodeName.toLowerCase()}:${a}`;
      return t.addEventListener(c, u), [c, u];
    });
    return o(!0), () => {
      for (const [a, l] of s)
        t.removeEventListener(a, l);
      o(!1);
    };
  }, [t, n, e]), [i, r];
}
function Ite(n) {
  return Pv((e) => {
    if (!n)
      return;
    const t = (s) => {
      typeof n == "function" ? n(s) : n.current = s;
    };
    if (!e) {
      t(null);
      return;
    }
    if (e.initialised) {
      t(e);
      return;
    }
    let i = !0;
    const r = () => {
      i && t(e);
    }, o = `${e.nodeName.toLowerCase()}:initialised`;
    return e.addEventListener(o, r), () => {
      i = !1, e.removeEventListener(o, r);
    };
  }, [n]);
}
function wN(n, e) {
  const [t, i] = Nte(n), r = Ite(e);
  return [
    Pv((o) => {
      r(o), t(o);
    }, [t, r]),
    i
  ];
}
const Pte = yN(CN.MultipleCursors);
function Ate(n, e) {
  const [t, i] = wN({}, e), r = fG();
  return me.createElement("cord-multiple-cursors", { id: n.id, class: n.className, style: n.style, ref: t, "buffer-events": !i, ...Pte({ location: r, ...n }) });
}
me.forwardRef(Ate);
function pG(n, e) {
  return Pv((t) => {
    t && Object.assign(t, n), e(t);
  }, [e, n]);
}
const Mte = yN(CN.Sidebar);
function Fte(n, e) {
  const { onOpen: t, onClose: i, onThreadOpen: r, onThreadClose: o } = n, [s, a] = wN({
    open: t,
    close: i,
    threadopen: r,
    threadclose: o
  }, e), l = pG({
    newComponentSwitchConfig: n.newComponentSwitchConfig,
    screenshotConfig: n.screenshotConfig
  }, s), u = fG();
  return me.createElement("cord-sidebar", { id: n.id, class: n.className, style: n.style, ref: l, "buffer-events": !a, ...Mte({ location: u, ...n }) });
}
me.forwardRef(Fte);
function bN(n) {
  const e = E1(() => dG(n), [n]);
  return E1(() => JSON.parse(e), [e]);
}
const kte = () => {
};
function YCe(n, e) {
  var t;
  const { sdk: i } = jS("useCordAnnotationRenderer"), r = bN(n);
  return oh(() => {
    if (!(!e || !i))
      return i.annotation.setRenderHandler(r, e), () => {
        i.annotation.clearRenderHandler(r);
      };
  }, [i, r, e]), {
    redrawAnnotations: (t = i == null ? void 0 : i.annotation.redrawAnnotations) !== null && t !== void 0 ? t : kte
  };
}
function XCe(n, e) {
  const { sdk: t } = jS("useCordAnnotationCaptureHandler"), i = bN(n);
  oh(() => {
    if (!(!e || !t))
      return t.annotation.setCaptureHandler(i, e), () => {
        t.annotation.clearCaptureHandler(i);
      };
  }, [t, i, e]);
}
function ZCe(n, e) {
  const { sdk: t } = jS("useCordAnnotationClickHandler"), i = bN(n);
  oh(() => {
    if (!(!e || !t))
      return t.annotation.setClickHandler(i, e), () => {
        t.annotation.clearClickHandler(i);
      };
  }, [t, i, e]);
}
function Wte(n, e) {
  const t = gz(null);
  return E1(() => ({
    get current() {
      return t.current;
    },
    set current(i) {
      t.current !== i && (e == null || e(t.current), t.current = i, n(i));
    }
  }), [n, e]);
}
function QCe(n) {
  const e = dG(n), t = Pv((r) => {
    r == null || r.setAttribute(VF, e);
  }, [e]), i = Pv((r) => {
    r == null || r.removeAttribute(VF);
  }, []);
  return Wte(t, i);
}
const Vte = yN(CN.FloatingThreads);
let gG = !1;
try {
  gG = !!localStorage.getItem("__cord_log_loading_times__");
} catch {
}
function Bte(n, e) {
  const [t, i] = wN({
    start: n.onStart,
    finish: n.onFinish,
    cancel: n.onCancel
  }, e), r = pG({
    newComponentSwitchConfig: n.newComponentSwitchConfig,
    screenshotConfig: n.screenshotConfig
  }, t);
  return oh(() => {
    gG && console.log(`<cord-floating-threads> first render: ${(/* @__PURE__ */ new Date()).toISOString()}`);
  }, []), me.createElement("cord-floating-threads", { ref: r, id: n.id, "buffer-events": !i, class: n.className, style: n.style, ...Vte(n) });
}
me.forwardRef(Bte);
var ib = {}, Hte = {
  get exports() {
    return ib;
  },
  set exports(n) {
    ib = n;
  }
}, mG = {};
function vG(n) {
  var e, t, i = "";
  if (typeof n == "string" || typeof n == "number")
    i += n;
  else if (typeof n == "object")
    if (Array.isArray(n))
      for (e = 0; e < n.length; e++)
        n[e] && (t = vG(n[e])) && (i && (i += " "), i += t);
    else
      for (e in n)
        n[e] && (i && (i += " "), i += e);
  return i;
}
function BF() {
  for (var n, e, t = 0, i = ""; t < arguments.length; )
    (n = arguments[t++]) && (e = vG(n)) && (i && (i += " "), i += e);
  return i;
}
const Gte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: BF,
  default: BF
}, Symbol.toStringTag, { value: "Module" })), Ute = /* @__PURE__ */ YO(Gte);
var xn = {}, iu = {};
Object.defineProperty(iu, "__esModule", {
  value: !0
});
iu.dontSetMe = qte;
iu.findInArray = zte;
iu.int = Kte;
iu.isFunction = jte;
iu.isNum = $te;
function zte(n, e) {
  for (var t = 0, i = n.length; t < i; t++)
    if (e.apply(e, [n[t], t, n]))
      return n[t];
}
function jte(n) {
  return typeof n == "function" || Object.prototype.toString.call(n) === "[object Function]";
}
function $te(n) {
  return typeof n == "number" && !isNaN(n);
}
function Kte(n) {
  return parseInt(n, 10);
}
function qte(n, e, t) {
  if (n[e])
    return new Error("Invalid prop ".concat(e, " passed to ").concat(t, " - do not set this, set it on the child."));
}
var rf = {};
Object.defineProperty(rf, "__esModule", {
  value: !0
});
rf.browserPrefixToKey = CG;
rf.browserPrefixToStyle = Yte;
rf.default = void 0;
rf.getPrefix = _G;
var JL = ["Moz", "Webkit", "O", "ms"];
function _G() {
  var n, e, t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
  if (typeof window > "u")
    return "";
  var i = (n = window.document) === null || n === void 0 || (e = n.documentElement) === null || e === void 0 ? void 0 : e.style;
  if (!i || t in i)
    return "";
  for (var r = 0; r < JL.length; r++)
    if (CG(t, JL[r]) in i)
      return JL[r];
  return "";
}
function CG(n, e) {
  return e ? "".concat(e).concat(Xte(n)) : n;
}
function Yte(n, e) {
  return e ? "-".concat(e.toLowerCase(), "-").concat(n) : n;
}
function Xte(n) {
  for (var e = "", t = !0, i = 0; i < n.length; i++)
    t ? (e += n[i].toUpperCase(), t = !1) : n[i] === "-" ? t = !0 : e += n[i];
  return e;
}
var Zte = _G();
rf.default = Zte;
function cR(n) {
  return cR = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, cR(n);
}
Object.defineProperty(xn, "__esModule", {
  value: !0
});
xn.addClassName = EG;
xn.addEvent = eie;
xn.addUserSelectStyles = hie;
xn.createCSSTransform = aie;
xn.createSVGTransform = lie;
xn.getTouch = uie;
xn.getTouchIdentifier = cie;
xn.getTranslation = SN;
xn.innerHeight = rie;
xn.innerWidth = oie;
xn.matchesSelector = SG;
xn.matchesSelectorAndParentsTo = Jte;
xn.offsetXYFromParent = sie;
xn.outerHeight = iie;
xn.outerWidth = nie;
xn.removeClassName = LG;
xn.removeEvent = tie;
xn.removeUserSelectStyles = die;
var Rs = iu, HF = Qte(rf);
function yG(n) {
  if (typeof WeakMap != "function")
    return null;
  var e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
  return (yG = function(r) {
    return r ? t : e;
  })(n);
}
function Qte(n, e) {
  if (!e && n && n.__esModule)
    return n;
  if (n === null || cR(n) !== "object" && typeof n != "function")
    return { default: n };
  var t = yG(e);
  if (t && t.has(n))
    return t.get(n);
  var i = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in n)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(n, o)) {
      var s = r ? Object.getOwnPropertyDescriptor(n, o) : null;
      s && (s.get || s.set) ? Object.defineProperty(i, o, s) : i[o] = n[o];
    }
  return i.default = n, t && t.set(n, i), i;
}
function GF(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    })), t.push.apply(t, i);
  }
  return t;
}
function wG(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? GF(Object(t), !0).forEach(function(i) {
      bG(n, i, t[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : GF(Object(t)).forEach(function(i) {
      Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
    });
  }
  return n;
}
function bG(n, e, t) {
  return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n;
}
var cy = "";
function SG(n, e) {
  return cy || (cy = (0, Rs.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(t) {
    return (0, Rs.isFunction)(n[t]);
  })), (0, Rs.isFunction)(n[cy]) ? n[cy](e) : !1;
}
function Jte(n, e, t) {
  var i = n;
  do {
    if (SG(i, e))
      return !0;
    if (i === t)
      return !1;
    i = i.parentNode;
  } while (i);
  return !1;
}
function eie(n, e, t, i) {
  if (n) {
    var r = wG({
      capture: !0
    }, i);
    n.addEventListener ? n.addEventListener(e, t, r) : n.attachEvent ? n.attachEvent("on" + e, t) : n["on" + e] = t;
  }
}
function tie(n, e, t, i) {
  if (n) {
    var r = wG({
      capture: !0
    }, i);
    n.removeEventListener ? n.removeEventListener(e, t, r) : n.detachEvent ? n.detachEvent("on" + e, t) : n["on" + e] = null;
  }
}
function iie(n) {
  var e = n.clientHeight, t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e += (0, Rs.int)(t.borderTopWidth), e += (0, Rs.int)(t.borderBottomWidth), e;
}
function nie(n) {
  var e = n.clientWidth, t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e += (0, Rs.int)(t.borderLeftWidth), e += (0, Rs.int)(t.borderRightWidth), e;
}
function rie(n) {
  var e = n.clientHeight, t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e -= (0, Rs.int)(t.paddingTop), e -= (0, Rs.int)(t.paddingBottom), e;
}
function oie(n) {
  var e = n.clientWidth, t = n.ownerDocument.defaultView.getComputedStyle(n);
  return e -= (0, Rs.int)(t.paddingLeft), e -= (0, Rs.int)(t.paddingRight), e;
}
function sie(n, e, t) {
  var i = e === e.ownerDocument.body, r = i ? {
    left: 0,
    top: 0
  } : e.getBoundingClientRect(), o = (n.clientX + e.scrollLeft - r.left) / t, s = (n.clientY + e.scrollTop - r.top) / t;
  return {
    x: o,
    y: s
  };
}
function aie(n, e) {
  var t = SN(n, e, "px");
  return bG({}, (0, HF.browserPrefixToKey)("transform", HF.default), t);
}
function lie(n, e) {
  var t = SN(n, e, "");
  return t;
}
function SN(n, e, t) {
  var i = n.x, r = n.y, o = "translate(".concat(i).concat(t, ",").concat(r).concat(t, ")");
  if (e) {
    var s = "".concat(typeof e.x == "string" ? e.x : e.x + t), a = "".concat(typeof e.y == "string" ? e.y : e.y + t);
    o = "translate(".concat(s, ", ").concat(a, ")") + o;
  }
  return o;
}
function uie(n, e) {
  return n.targetTouches && (0, Rs.findInArray)(n.targetTouches, function(t) {
    return e === t.identifier;
  }) || n.changedTouches && (0, Rs.findInArray)(n.changedTouches, function(t) {
    return e === t.identifier;
  });
}
function cie(n) {
  if (n.targetTouches && n.targetTouches[0])
    return n.targetTouches[0].identifier;
  if (n.changedTouches && n.changedTouches[0])
    return n.changedTouches[0].identifier;
}
function hie(n) {
  if (n) {
    var e = n.getElementById("react-draggable-style-el");
    e || (e = n.createElement("style"), e.type = "text/css", e.id = "react-draggable-style-el", e.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, e.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, n.getElementsByTagName("head")[0].appendChild(e)), n.body && EG(n.body, "react-draggable-transparent-selection");
  }
}
function die(n) {
  if (n)
    try {
      if (n.body && LG(n.body, "react-draggable-transparent-selection"), n.selection)
        n.selection.empty();
      else {
        var e = (n.defaultView || window).getSelection();
        e && e.type !== "Caret" && e.removeAllRanges();
      }
    } catch {
    }
}
function EG(n, e) {
  n.classList ? n.classList.add(e) : n.className.match(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"))) || (n.className += " ".concat(e));
}
function LG(n, e) {
  n.classList ? n.classList.remove(e) : n.className = n.className.replace(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"), "g"), "");
}
var nu = {};
Object.defineProperty(nu, "__esModule", {
  value: !0
});
nu.canDragX = gie;
nu.canDragY = mie;
nu.createCoreData = _ie;
nu.createDraggableData = Cie;
nu.getBoundPosition = fie;
nu.getControlPosition = vie;
nu.snapToGrid = pie;
var cs = iu, ip = xn;
function fie(n, e, t) {
  if (!n.props.bounds)
    return [e, t];
  var i = n.props.bounds;
  i = typeof i == "string" ? i : yie(i);
  var r = EN(n);
  if (typeof i == "string") {
    var o = r.ownerDocument, s = o.defaultView, a;
    if (i === "parent" ? a = r.parentNode : a = o.querySelector(i), !(a instanceof s.HTMLElement))
      throw new Error('Bounds selector "' + i + '" could not find an element.');
    var l = a, u = s.getComputedStyle(r), c = s.getComputedStyle(l);
    i = {
      left: -r.offsetLeft + (0, cs.int)(c.paddingLeft) + (0, cs.int)(u.marginLeft),
      top: -r.offsetTop + (0, cs.int)(c.paddingTop) + (0, cs.int)(u.marginTop),
      right: (0, ip.innerWidth)(l) - (0, ip.outerWidth)(r) - r.offsetLeft + (0, cs.int)(c.paddingRight) - (0, cs.int)(u.marginRight),
      bottom: (0, ip.innerHeight)(l) - (0, ip.outerHeight)(r) - r.offsetTop + (0, cs.int)(c.paddingBottom) - (0, cs.int)(u.marginBottom)
    };
  }
  return (0, cs.isNum)(i.right) && (e = Math.min(e, i.right)), (0, cs.isNum)(i.bottom) && (t = Math.min(t, i.bottom)), (0, cs.isNum)(i.left) && (e = Math.max(e, i.left)), (0, cs.isNum)(i.top) && (t = Math.max(t, i.top)), [e, t];
}
function pie(n, e, t) {
  var i = Math.round(e / n[0]) * n[0], r = Math.round(t / n[1]) * n[1];
  return [i, r];
}
function gie(n) {
  return n.props.axis === "both" || n.props.axis === "x";
}
function mie(n) {
  return n.props.axis === "both" || n.props.axis === "y";
}
function vie(n, e, t) {
  var i = typeof e == "number" ? (0, ip.getTouch)(n, e) : null;
  if (typeof e == "number" && !i)
    return null;
  var r = EN(t), o = t.props.offsetParent || r.offsetParent || r.ownerDocument.body;
  return (0, ip.offsetXYFromParent)(i || n, o, t.props.scale);
}
function _ie(n, e, t) {
  var i = n.state, r = !(0, cs.isNum)(i.lastX), o = EN(n);
  return r ? {
    node: o,
    deltaX: 0,
    deltaY: 0,
    lastX: e,
    lastY: t,
    x: e,
    y: t
  } : {
    node: o,
    deltaX: e - i.lastX,
    deltaY: t - i.lastY,
    lastX: i.lastX,
    lastY: i.lastY,
    x: e,
    y: t
  };
}
function Cie(n, e) {
  var t = n.props.scale;
  return {
    node: e.node,
    x: n.state.x + e.deltaX / t,
    y: n.state.y + e.deltaY / t,
    deltaX: e.deltaX / t,
    deltaY: e.deltaY / t,
    lastX: n.state.x,
    lastY: n.state.y
  };
}
function yie(n) {
  return {
    left: n.left,
    top: n.top,
    right: n.right,
    bottom: n.bottom
  };
}
function EN(n) {
  var e = n.findDOMNode();
  if (!e)
    throw new Error("<DraggableCore>: Unmounted during event!");
  return e;
}
var $S = {}, KS = {};
Object.defineProperty(KS, "__esModule", {
  value: !0
});
KS.default = wie;
function wie() {
}
function nb(n) {
  return nb = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, nb(n);
}
Object.defineProperty($S, "__esModule", {
  value: !0
});
$S.default = void 0;
var eD = Sie(bt), ls = LN(Qu), bie = LN(pg), zr = xn, Lc = nu, tD = iu, Im = LN(KS);
function LN(n) {
  return n && n.__esModule ? n : { default: n };
}
function DG(n) {
  if (typeof WeakMap != "function")
    return null;
  var e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
  return (DG = function(r) {
    return r ? t : e;
  })(n);
}
function Sie(n, e) {
  if (!e && n && n.__esModule)
    return n;
  if (n === null || nb(n) !== "object" && typeof n != "function")
    return { default: n };
  var t = DG(e);
  if (t && t.has(n))
    return t.get(n);
  var i = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in n)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(n, o)) {
      var s = r ? Object.getOwnPropertyDescriptor(n, o) : null;
      s && (s.get || s.set) ? Object.defineProperty(i, o, s) : i[o] = n[o];
    }
  return i.default = n, t && t.set(n, i), i;
}
function UF(n, e) {
  return Rie(n) || Die(n, e) || Lie(n, e) || Eie();
}
function Eie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Lie(n, e) {
  if (n) {
    if (typeof n == "string")
      return zF(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return zF(n, e);
  }
}
function zF(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, i = new Array(e); t < e; t++)
    i[t] = n[t];
  return i;
}
function Die(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var i = [], r = !0, o = !1, s, a;
    try {
      for (t = t.call(n); !(r = (s = t.next()).done) && (i.push(s.value), !(e && i.length === e)); r = !0)
        ;
    } catch (l) {
      o = !0, a = l;
    } finally {
      try {
        !r && t.return != null && t.return();
      } finally {
        if (o)
          throw a;
      }
    }
    return i;
  }
}
function Rie(n) {
  if (Array.isArray(n))
    return n;
}
function Tie(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function jF(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(n, i.key, i);
  }
}
function Oie(n, e, t) {
  return e && jF(n.prototype, e), t && jF(n, t), Object.defineProperty(n, "prototype", { writable: !1 }), n;
}
function xie(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  n.prototype = Object.create(e && e.prototype, { constructor: { value: n, writable: !0, configurable: !0 } }), Object.defineProperty(n, "prototype", { writable: !1 }), e && hR(n, e);
}
function hR(n, e) {
  return hR = Object.setPrototypeOf || function(i, r) {
    return i.__proto__ = r, i;
  }, hR(n, e);
}
function Nie(n) {
  var e = Pie();
  return function() {
    var i = rb(n), r;
    if (e) {
      var o = rb(this).constructor;
      r = Reflect.construct(i, arguments, o);
    } else
      r = i.apply(this, arguments);
    return Iie(this, r);
  };
}
function Iie(n, e) {
  if (e && (nb(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return jr(n);
}
function jr(n) {
  if (n === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function Pie() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function rb(n) {
  return rb = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, rb(n);
}
function sa(n, e, t) {
  return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n;
}
var xa = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  }
}, Dc = xa.mouse, qS = /* @__PURE__ */ function(n) {
  xie(t, n);
  var e = Nie(t);
  function t() {
    var i;
    Tie(this, t);
    for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++)
      o[s] = arguments[s];
    return i = e.call.apply(e, [this].concat(o)), sa(jr(i), "state", {
      dragging: !1,
      // Used while dragging to determine deltas.
      lastX: NaN,
      lastY: NaN,
      touchIdentifier: null
    }), sa(jr(i), "mounted", !1), sa(jr(i), "handleDragStart", function(a) {
      if (i.props.onMouseDown(a), !i.props.allowAnyClick && typeof a.button == "number" && a.button !== 0)
        return !1;
      var l = i.findDOMNode();
      if (!l || !l.ownerDocument || !l.ownerDocument.body)
        throw new Error("<DraggableCore> not mounted on DragStart!");
      var u = l.ownerDocument;
      if (!(i.props.disabled || !(a.target instanceof u.defaultView.Node) || i.props.handle && !(0, zr.matchesSelectorAndParentsTo)(a.target, i.props.handle, l) || i.props.cancel && (0, zr.matchesSelectorAndParentsTo)(a.target, i.props.cancel, l))) {
        a.type === "touchstart" && a.preventDefault();
        var c = (0, zr.getTouchIdentifier)(a);
        i.setState({
          touchIdentifier: c
        });
        var h = (0, Lc.getControlPosition)(a, c, jr(i));
        if (h != null) {
          var d = h.x, f = h.y, p = (0, Lc.createCoreData)(jr(i), d, f);
          (0, Im.default)("DraggableCore: handleDragStart: %j", p), (0, Im.default)("calling", i.props.onStart);
          var g = i.props.onStart(a, p);
          g === !1 || i.mounted === !1 || (i.props.enableUserSelectHack && (0, zr.addUserSelectStyles)(u), i.setState({
            dragging: !0,
            lastX: d,
            lastY: f
          }), (0, zr.addEvent)(u, Dc.move, i.handleDrag), (0, zr.addEvent)(u, Dc.stop, i.handleDragStop));
        }
      }
    }), sa(jr(i), "handleDrag", function(a) {
      var l = (0, Lc.getControlPosition)(a, i.state.touchIdentifier, jr(i));
      if (l != null) {
        var u = l.x, c = l.y;
        if (Array.isArray(i.props.grid)) {
          var h = u - i.state.lastX, d = c - i.state.lastY, f = (0, Lc.snapToGrid)(i.props.grid, h, d), p = UF(f, 2);
          if (h = p[0], d = p[1], !h && !d)
            return;
          u = i.state.lastX + h, c = i.state.lastY + d;
        }
        var g = (0, Lc.createCoreData)(jr(i), u, c);
        (0, Im.default)("DraggableCore: handleDrag: %j", g);
        var _ = i.props.onDrag(a, g);
        if (_ === !1 || i.mounted === !1) {
          try {
            i.handleDragStop(new MouseEvent("mouseup"));
          } catch {
            var m = document.createEvent("MouseEvents");
            m.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), i.handleDragStop(m);
          }
          return;
        }
        i.setState({
          lastX: u,
          lastY: c
        });
      }
    }), sa(jr(i), "handleDragStop", function(a) {
      if (i.state.dragging) {
        var l = (0, Lc.getControlPosition)(a, i.state.touchIdentifier, jr(i));
        if (l != null) {
          var u = l.x, c = l.y;
          if (Array.isArray(i.props.grid)) {
            var h = u - i.state.lastX || 0, d = c - i.state.lastY || 0, f = (0, Lc.snapToGrid)(i.props.grid, h, d), p = UF(f, 2);
            h = p[0], d = p[1], u = i.state.lastX + h, c = i.state.lastY + d;
          }
          var g = (0, Lc.createCoreData)(jr(i), u, c), _ = i.props.onStop(a, g);
          if (_ === !1 || i.mounted === !1)
            return !1;
          var m = i.findDOMNode();
          m && i.props.enableUserSelectHack && (0, zr.removeUserSelectStyles)(m.ownerDocument), (0, Im.default)("DraggableCore: handleDragStop: %j", g), i.setState({
            dragging: !1,
            lastX: NaN,
            lastY: NaN
          }), m && ((0, Im.default)("DraggableCore: Removing handlers"), (0, zr.removeEvent)(m.ownerDocument, Dc.move, i.handleDrag), (0, zr.removeEvent)(m.ownerDocument, Dc.stop, i.handleDragStop));
        }
      }
    }), sa(jr(i), "onMouseDown", function(a) {
      return Dc = xa.mouse, i.handleDragStart(a);
    }), sa(jr(i), "onMouseUp", function(a) {
      return Dc = xa.mouse, i.handleDragStop(a);
    }), sa(jr(i), "onTouchStart", function(a) {
      return Dc = xa.touch, i.handleDragStart(a);
    }), sa(jr(i), "onTouchEnd", function(a) {
      return Dc = xa.touch, i.handleDragStop(a);
    }), i;
  }
  return Oie(t, [{
    key: "componentDidMount",
    value: function() {
      this.mounted = !0;
      var r = this.findDOMNode();
      r && (0, zr.addEvent)(r, xa.touch.start, this.onTouchStart, {
        passive: !1
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.mounted = !1;
      var r = this.findDOMNode();
      if (r) {
        var o = r.ownerDocument;
        (0, zr.removeEvent)(o, xa.mouse.move, this.handleDrag), (0, zr.removeEvent)(o, xa.touch.move, this.handleDrag), (0, zr.removeEvent)(o, xa.mouse.stop, this.handleDragStop), (0, zr.removeEvent)(o, xa.touch.stop, this.handleDragStop), (0, zr.removeEvent)(r, xa.touch.start, this.onTouchStart, {
          passive: !1
        }), this.props.enableUserSelectHack && (0, zr.removeUserSelectStyles)(o);
      }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
  }, {
    key: "findDOMNode",
    value: function() {
      var r, o, s;
      return (r = this.props) !== null && r !== void 0 && r.nodeRef ? (o = this.props) === null || o === void 0 || (s = o.nodeRef) === null || s === void 0 ? void 0 : s.current : bie.default.findDOMNode(this);
    }
  }, {
    key: "render",
    value: function() {
      return /* @__PURE__ */ eD.cloneElement(eD.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  }]), t;
}(eD.Component);
$S.default = qS;
sa(qS, "displayName", "DraggableCore");
sa(qS, "propTypes", {
  /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */
  allowAnyClick: ls.default.bool,
  /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */
  disabled: ls.default.bool,
  /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */
  enableUserSelectHack: ls.default.bool,
  /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */
  offsetParent: function(e, t) {
    if (e[t] && e[t].nodeType !== 1)
      throw new Error("Draggable's offsetParent must be a DOM Node.");
  },
  /**
   * `grid` specifies the x and y that dragging should snap to.
   */
  grid: ls.default.arrayOf(ls.default.number),
  /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  handle: ls.default.string,
  /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */
  cancel: ls.default.string,
  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */
  nodeRef: ls.default.object,
  /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onStart: ls.default.func,
  /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onDrag: ls.default.func,
  /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */
  onStop: ls.default.func,
  /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */
  onMouseDown: ls.default.func,
  /**
   * `scale`, if set, applies scaling while dragging an element
   */
  scale: ls.default.number,
  /**
   * These properties should be defined on the child, not here.
   */
  className: tD.dontSetMe,
  style: tD.dontSetMe,
  transform: tD.dontSetMe
});
sa(qS, "defaultProps", {
  allowAnyClick: !1,
  // by default only accept left click
  disabled: !1,
  enableUserSelectHack: !0,
  onStart: function() {
  },
  onDrag: function() {
  },
  onStop: function() {
  },
  onMouseDown: function() {
  },
  scale: 1
});
(function(n) {
  function e(W) {
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(B) {
      return typeof B;
    } : function(B) {
      return B && typeof Symbol == "function" && B.constructor === Symbol && B !== Symbol.prototype ? "symbol" : typeof B;
    }, e(W);
  }
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), Object.defineProperty(n, "DraggableCore", {
    enumerable: !0,
    get: function() {
      return u.default;
    }
  }), n.default = void 0;
  var t = p(bt), i = d(Qu), r = d(pg), o = d(Ute), s = xn, a = nu, l = iu, u = d($S), c = d(KS), h = ["axis", "bounds", "children", "defaultPosition", "defaultClassName", "defaultClassNameDragging", "defaultClassNameDragged", "position", "positionOffset", "scale"];
  function d(W) {
    return W && W.__esModule ? W : { default: W };
  }
  function f(W) {
    if (typeof WeakMap != "function")
      return null;
    var B = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap();
    return (f = function(N) {
      return N ? U : B;
    })(W);
  }
  function p(W, B) {
    if (!B && W && W.__esModule)
      return W;
    if (W === null || e(W) !== "object" && typeof W != "function")
      return { default: W };
    var U = f(B);
    if (U && U.has(W))
      return U.get(W);
    var O = {}, N = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var I in W)
      if (I !== "default" && Object.prototype.hasOwnProperty.call(W, I)) {
        var V = N ? Object.getOwnPropertyDescriptor(W, I) : null;
        V && (V.get || V.set) ? Object.defineProperty(O, I, V) : O[I] = W[I];
      }
    return O.default = W, U && U.set(W, O), O;
  }
  function g() {
    return g = Object.assign || function(W) {
      for (var B = 1; B < arguments.length; B++) {
        var U = arguments[B];
        for (var O in U)
          Object.prototype.hasOwnProperty.call(U, O) && (W[O] = U[O]);
      }
      return W;
    }, g.apply(this, arguments);
  }
  function _(W, B) {
    if (W == null)
      return {};
    var U = m(W, B), O, N;
    if (Object.getOwnPropertySymbols) {
      var I = Object.getOwnPropertySymbols(W);
      for (N = 0; N < I.length; N++)
        O = I[N], !(B.indexOf(O) >= 0) && Object.prototype.propertyIsEnumerable.call(W, O) && (U[O] = W[O]);
    }
    return U;
  }
  function m(W, B) {
    if (W == null)
      return {};
    var U = {}, O = Object.keys(W), N, I;
    for (I = 0; I < O.length; I++)
      N = O[I], !(B.indexOf(N) >= 0) && (U[N] = W[N]);
    return U;
  }
  function v(W, B) {
    var U = Object.keys(W);
    if (Object.getOwnPropertySymbols) {
      var O = Object.getOwnPropertySymbols(W);
      B && (O = O.filter(function(N) {
        return Object.getOwnPropertyDescriptor(W, N).enumerable;
      })), U.push.apply(U, O);
    }
    return U;
  }
  function C(W) {
    for (var B = 1; B < arguments.length; B++) {
      var U = arguments[B] != null ? arguments[B] : {};
      B % 2 ? v(Object(U), !0).forEach(function(O) {
        Y(W, O, U[O]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(W, Object.getOwnPropertyDescriptors(U)) : v(Object(U)).forEach(function(O) {
        Object.defineProperty(W, O, Object.getOwnPropertyDescriptor(U, O));
      });
    }
    return W;
  }
  function y(W, B) {
    return D(W) || E(W, B) || L(W, B) || w();
  }
  function w() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function L(W, B) {
    if (W) {
      if (typeof W == "string")
        return S(W, B);
      var U = Object.prototype.toString.call(W).slice(8, -1);
      if (U === "Object" && W.constructor && (U = W.constructor.name), U === "Map" || U === "Set")
        return Array.from(W);
      if (U === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(U))
        return S(W, B);
    }
  }
  function S(W, B) {
    (B == null || B > W.length) && (B = W.length);
    for (var U = 0, O = new Array(B); U < B; U++)
      O[U] = W[U];
    return O;
  }
  function E(W, B) {
    var U = W == null ? null : typeof Symbol < "u" && W[Symbol.iterator] || W["@@iterator"];
    if (U != null) {
      var O = [], N = !0, I = !1, V, te;
      try {
        for (U = U.call(W); !(N = (V = U.next()).done) && (O.push(V.value), !(B && O.length === B)); N = !0)
          ;
      } catch (ue) {
        I = !0, te = ue;
      } finally {
        try {
          !N && U.return != null && U.return();
        } finally {
          if (I)
            throw te;
        }
      }
      return O;
    }
  }
  function D(W) {
    if (Array.isArray(W))
      return W;
  }
  function x(W, B) {
    if (!(W instanceof B))
      throw new TypeError("Cannot call a class as a function");
  }
  function R(W, B) {
    for (var U = 0; U < B.length; U++) {
      var O = B[U];
      O.enumerable = O.enumerable || !1, O.configurable = !0, "value" in O && (O.writable = !0), Object.defineProperty(W, O.key, O);
    }
  }
  function A(W, B, U) {
    return B && R(W.prototype, B), U && R(W, U), Object.defineProperty(W, "prototype", { writable: !1 }), W;
  }
  function M(W, B) {
    if (typeof B != "function" && B !== null)
      throw new TypeError("Super expression must either be null or a function");
    W.prototype = Object.create(B && B.prototype, { constructor: { value: W, writable: !0, configurable: !0 } }), Object.defineProperty(W, "prototype", { writable: !1 }), B && z(W, B);
  }
  function z(W, B) {
    return z = Object.setPrototypeOf || function(O, N) {
      return O.__proto__ = N, O;
    }, z(W, B);
  }
  function j(W) {
    var B = ae();
    return function() {
      var O = re(W), N;
      if (B) {
        var I = re(this).constructor;
        N = Reflect.construct(O, arguments, I);
      } else
        N = O.apply(this, arguments);
      return $(this, N);
    };
  }
  function $(W, B) {
    if (B && (e(B) === "object" || typeof B == "function"))
      return B;
    if (B !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return k(W);
  }
  function k(W) {
    if (W === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return W;
  }
  function ae() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function re(W) {
    return re = Object.setPrototypeOf ? Object.getPrototypeOf : function(U) {
      return U.__proto__ || Object.getPrototypeOf(U);
    }, re(W);
  }
  function Y(W, B, U) {
    return B in W ? Object.defineProperty(W, B, { value: U, enumerable: !0, configurable: !0, writable: !0 }) : W[B] = U, W;
  }
  var K = /* @__PURE__ */ function(W) {
    M(U, W);
    var B = j(U);
    function U(O) {
      var N;
      return x(this, U), N = B.call(this, O), Y(k(N), "onDragStart", function(I, V) {
        (0, c.default)("Draggable: onDragStart: %j", V);
        var te = N.props.onStart(I, (0, a.createDraggableData)(k(N), V));
        if (te === !1)
          return !1;
        N.setState({
          dragging: !0,
          dragged: !0
        });
      }), Y(k(N), "onDrag", function(I, V) {
        if (!N.state.dragging)
          return !1;
        (0, c.default)("Draggable: onDrag: %j", V);
        var te = (0, a.createDraggableData)(k(N), V), ue = {
          x: te.x,
          y: te.y
        };
        if (N.props.bounds) {
          var De = ue.x, ce = ue.y;
          ue.x += N.state.slackX, ue.y += N.state.slackY;
          var ke = (0, a.getBoundPosition)(k(N), ue.x, ue.y), Ie = y(ke, 2), $e = Ie[0], Ot = Ie[1];
          ue.x = $e, ue.y = Ot, ue.slackX = N.state.slackX + (De - ue.x), ue.slackY = N.state.slackY + (ce - ue.y), te.x = ue.x, te.y = ue.y, te.deltaX = ue.x - N.state.x, te.deltaY = ue.y - N.state.y;
        }
        var It = N.props.onDrag(I, te);
        if (It === !1)
          return !1;
        N.setState(ue);
      }), Y(k(N), "onDragStop", function(I, V) {
        if (!N.state.dragging)
          return !1;
        var te = N.props.onStop(I, (0, a.createDraggableData)(k(N), V));
        if (te === !1)
          return !1;
        (0, c.default)("Draggable: onDragStop: %j", V);
        var ue = {
          dragging: !1,
          slackX: 0,
          slackY: 0
        }, De = !!N.props.position;
        if (De) {
          var ce = N.props.position, ke = ce.x, Ie = ce.y;
          ue.x = ke, ue.y = Ie;
        }
        N.setState(ue);
      }), N.state = {
        // Whether or not we are currently dragging.
        dragging: !1,
        // Whether or not we have been dragged before.
        dragged: !1,
        // Current transform x and y.
        x: O.position ? O.position.x : O.defaultPosition.x,
        y: O.position ? O.position.y : O.defaultPosition.y,
        prevPropsPosition: C({}, O.position),
        // Used for compensating for out-of-bounds drags
        slackX: 0,
        slackY: 0,
        // Can only determine if SVG after mounting
        isElementSVG: !1
      }, O.position && !(O.onDrag || O.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element."), N;
    }
    return A(U, [{
      key: "componentDidMount",
      value: function() {
        typeof window.SVGElement < "u" && this.findDOMNode() instanceof window.SVGElement && this.setState({
          isElementSVG: !0
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.setState({
          dragging: !1
        });
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
    }, {
      key: "findDOMNode",
      value: function() {
        var N, I, V;
        return (N = (I = this.props) === null || I === void 0 || (V = I.nodeRef) === null || V === void 0 ? void 0 : V.current) !== null && N !== void 0 ? N : r.default.findDOMNode(this);
      }
    }, {
      key: "render",
      value: function() {
        var N, I = this.props;
        I.axis, I.bounds;
        var V = I.children, te = I.defaultPosition, ue = I.defaultClassName, De = I.defaultClassNameDragging, ce = I.defaultClassNameDragged, ke = I.position, Ie = I.positionOffset;
        I.scale;
        var $e = _(I, h), Ot = {}, It = null, ti = !!ke, ii = !ti || this.state.dragging, lt = ke || te, Ui = {
          // Set left if horizontal drag is enabled
          x: (0, a.canDragX)(this) && ii ? this.state.x : lt.x,
          // Set top if vertical drag is enabled
          y: (0, a.canDragY)(this) && ii ? this.state.y : lt.y
        };
        this.state.isElementSVG ? It = (0, s.createSVGTransform)(Ui, Ie) : Ot = (0, s.createCSSTransform)(Ui, Ie);
        var zt = (0, o.default)(V.props.className || "", ue, (N = {}, Y(N, De, this.state.dragging), Y(N, ce, this.state.dragged), N));
        return /* @__PURE__ */ t.createElement(u.default, g({}, $e, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), /* @__PURE__ */ t.cloneElement(t.Children.only(V), {
          className: zt,
          style: C(C({}, V.props.style), Ot),
          transform: It
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: (
        // React 16.3+
        // Arity (props, state)
        function(N, I) {
          var V = N.position, te = I.prevPropsPosition;
          return V && (!te || V.x !== te.x || V.y !== te.y) ? ((0, c.default)("Draggable: getDerivedStateFromProps %j", {
            position: V,
            prevPropsPosition: te
          }), {
            x: V.x,
            y: V.y,
            prevPropsPosition: C({}, V)
          }) : null;
        }
      )
    }]), U;
  }(t.Component);
  n.default = K, Y(K, "displayName", "Draggable"), Y(K, "propTypes", C(C({}, u.default.propTypes), {}, {
    /**
     * `axis` determines which axis the draggable can move.
     *
     *  Note that all callbacks will still return data as normal. This only
     *  controls flushing to the DOM.
     *
     * 'both' allows movement horizontally and vertically.
     * 'x' limits movement to horizontal axis.
     * 'y' limits movement to vertical axis.
     * 'none' limits all movement.
     *
     * Defaults to 'both'.
     */
    axis: i.default.oneOf(["both", "x", "y", "none"]),
    /**
     * `bounds` determines the range of movement available to the element.
     * Available values are:
     *
     * 'parent' restricts movement within the Draggable's parent node.
     *
     * Alternatively, pass an object with the following properties, all of which are optional:
     *
     * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
     *
     * All values are in px.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable bounds={{right: 300, bottom: 300}}>
     *              <div>Content</div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    bounds: i.default.oneOfType([i.default.shape({
      left: i.default.number,
      right: i.default.number,
      top: i.default.number,
      bottom: i.default.number
    }), i.default.string, i.default.oneOf([!1])]),
    defaultClassName: i.default.string,
    defaultClassNameDragging: i.default.string,
    defaultClassNameDragged: i.default.string,
    /**
     * `defaultPosition` specifies the x and y that the dragged item should start at
     *
     * Example:
     *
     * ```jsx
     *      let App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable defaultPosition={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    defaultPosition: i.default.shape({
      x: i.default.number,
      y: i.default.number
    }),
    positionOffset: i.default.shape({
      x: i.default.oneOfType([i.default.number, i.default.string]),
      y: i.default.oneOfType([i.default.number, i.default.string])
    }),
    /**
     * `position`, if present, defines the current position of the element.
     *
     *  This is similar to how form elements in React work - if no `position` is supplied, the component
     *  is uncontrolled.
     *
     * Example:
     *
     * ```jsx
     *      let App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable position={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    position: i.default.shape({
      x: i.default.number,
      y: i.default.number
    }),
    /**
     * These properties should be defined on the child, not here.
     */
    className: l.dontSetMe,
    style: l.dontSetMe,
    transform: l.dontSetMe
  })), Y(K, "defaultProps", C(C({}, u.default.defaultProps), {}, {
    axis: "both",
    bounds: !1,
    defaultClassName: "react-draggable",
    defaultClassNameDragging: "react-draggable-dragging",
    defaultClassNameDragged: "react-draggable-dragged",
    defaultPosition: {
      x: 0,
      y: 0
    },
    scale: 1
  }));
})(mG);
var RG = mG, TG = RG.default, Aie = RG.DraggableCore;
Hte.exports = TG;
ib.default = TG;
ib.DraggableCore = Aie;
/**
 * React Router DOM v6.12.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Xl() {
  return Xl = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, Xl.apply(this, arguments);
}
function DN(n, e) {
  if (n == null)
    return {};
  var t = {}, i = Object.keys(n), r, o;
  for (o = 0; o < i.length; o++)
    r = i[o], !(e.indexOf(r) >= 0) && (t[r] = n[r]);
  return t;
}
const ew = "get", iD = "application/x-www-form-urlencoded";
function YS(n) {
  return n != null && typeof n.tagName == "string";
}
function Mie(n) {
  return YS(n) && n.tagName.toLowerCase() === "button";
}
function Fie(n) {
  return YS(n) && n.tagName.toLowerCase() === "form";
}
function kie(n) {
  return YS(n) && n.tagName.toLowerCase() === "input";
}
function Wie(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
}
function Vie(n, e) {
  return n.button === 0 && // Ignore everything but left clicks
  (!e || e === "_self") && // Let browser handle "target=_blank" etc.
  !Wie(n);
}
function dR(n) {
  return n === void 0 && (n = ""), new URLSearchParams(typeof n == "string" || Array.isArray(n) || n instanceof URLSearchParams ? n : Object.keys(n).reduce((e, t) => {
    let i = n[t];
    return e.concat(Array.isArray(i) ? i.map((r) => [t, r]) : [[t, i]]);
  }, []));
}
function Bie(n, e) {
  let t = dR(n);
  if (e)
    for (let i of e.keys())
      t.has(i) || e.getAll(i).forEach((r) => {
        t.append(i, r);
      });
  return t;
}
function Hie(n, e, t) {
  let i, r = null, o, s;
  if (Fie(n)) {
    let a = e.submissionTrigger;
    if (e.action)
      r = e.action;
    else {
      let l = n.getAttribute("action");
      r = l ? ah(l, t) : null;
    }
    i = e.method || n.getAttribute("method") || ew, o = e.encType || n.getAttribute("enctype") || iD, s = new FormData(n), a && a.name && s.append(a.name, a.value);
  } else if (Mie(n) || kie(n) && (n.type === "submit" || n.type === "image")) {
    let a = n.form;
    if (a == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    if (e.action)
      r = e.action;
    else {
      let l = n.getAttribute("formaction") || a.getAttribute("action");
      r = l ? ah(l, t) : null;
    }
    i = e.method || n.getAttribute("formmethod") || a.getAttribute("method") || ew, o = e.encType || n.getAttribute("formenctype") || a.getAttribute("enctype") || iD, s = new FormData(a), n.name && s.append(n.name, n.value);
  } else {
    if (YS(n))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    if (i = e.method || ew, r = e.action || null, o = e.encType || iD, n instanceof FormData)
      s = n;
    else if (s = new FormData(), n instanceof URLSearchParams)
      for (let [a, l] of n)
        s.append(a, l);
    else if (n != null)
      for (let a of Object.keys(n))
        s.append(a, n[a]);
  }
  return {
    action: r,
    method: i.toLowerCase(),
    encType: o,
    formData: s
  };
}
const Gie = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], Uie = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"], zie = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"];
function JCe(n, e) {
  return qz({
    basename: e == null ? void 0 : e.basename,
    future: Xl({}, e == null ? void 0 : e.future, {
      v7_prependBasename: !0
    }),
    history: vz({
      window: e == null ? void 0 : e.window
    }),
    hydrationData: (e == null ? void 0 : e.hydrationData) || jie(),
    routes: n,
    mapRouteProperties: w6
  }).initialize();
}
function jie() {
  var n;
  let e = (n = window) == null ? void 0 : n.__staticRouterHydrationData;
  return e && e.errors && (e = Xl({}, e, {
    errors: $ie(e.errors)
  })), e;
}
function $ie(n) {
  if (!n)
    return null;
  let e = Object.entries(n), t = {};
  for (let [i, r] of e)
    if (r && r.__type === "RouteErrorResponse")
      t[i] = new ZO(r.status, r.statusText, r.data, r.internal === !0);
    else if (r && r.__type === "Error") {
      let o = new Error(r.message);
      o.stack = "", t[i] = o;
    } else
      t[i] = r;
  return t;
}
process.env.NODE_ENV;
const Kie = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", qie = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, OG = /* @__PURE__ */ me.forwardRef(function(e, t) {
  let {
    onClick: i,
    relative: r,
    reloadDocument: o,
    replace: s,
    state: a,
    target: l,
    to: u,
    preventScrollReset: c
  } = e, h = DN(e, Gie), {
    basename: d
  } = me.useContext(tu), f, p = !1;
  if (typeof u == "string" && qie.test(u) && (f = u, Kie))
    try {
      let v = new URL(window.location.href), C = u.startsWith("//") ? new URL(v.protocol + u) : new URL(u), y = ah(C.pathname, d);
      C.origin === v.origin && y != null ? u = y + C.search + C.hash : p = !0;
    } catch {
      process.env.NODE_ENV !== "production" && Or(!1, '<Link to="' + u + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let g = r6(u, {
    relative: r
  }), _ = Jie(u, {
    replace: s,
    state: a,
    target: l,
    preventScrollReset: c,
    relative: r
  });
  function m(v) {
    i && i(v), v.defaultPrevented || _(v);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ me.createElement("a", Xl({}, h, {
      href: f || g,
      onClick: p || o ? i : m,
      ref: t,
      target: l
    }))
  );
});
process.env.NODE_ENV !== "production" && (OG.displayName = "Link");
const Yie = /* @__PURE__ */ me.forwardRef(function(e, t) {
  let {
    "aria-current": i = "page",
    caseSensitive: r = !1,
    className: o = "",
    end: s = !1,
    style: a,
    to: l,
    children: u
  } = e, c = DN(e, Uie), h = bS(l, {
    relative: c.relative
  }), d = Jd(), f = me.useContext(wS), {
    navigator: p
  } = me.useContext(tu), g = p.encodeLocation ? p.encodeLocation(h).pathname : h.pathname, _ = d.pathname, m = f && f.navigation && f.navigation.location ? f.navigation.location.pathname : null;
  r || (_ = _.toLowerCase(), m = m ? m.toLowerCase() : null, g = g.toLowerCase());
  let v = _ === g || !s && _.startsWith(g) && _.charAt(g.length) === "/", C = m != null && (m === g || !s && m.startsWith(g) && m.charAt(g.length) === "/"), y = v ? i : void 0, w;
  typeof o == "function" ? w = o({
    isActive: v,
    isPending: C
  }) : w = [o, v ? "active" : null, C ? "pending" : null].filter(Boolean).join(" ");
  let L = typeof a == "function" ? a({
    isActive: v,
    isPending: C
  }) : a;
  return /* @__PURE__ */ me.createElement(OG, Xl({}, c, {
    "aria-current": y,
    className: w,
    ref: t,
    style: L,
    to: l
  }), typeof u == "function" ? u({
    isActive: v,
    isPending: C
  }) : u);
});
process.env.NODE_ENV !== "production" && (Yie.displayName = "NavLink");
const Xie = /* @__PURE__ */ me.forwardRef((n, e) => /* @__PURE__ */ me.createElement(xG, Xl({}, n, {
  ref: e
})));
process.env.NODE_ENV !== "production" && (Xie.displayName = "Form");
const xG = /* @__PURE__ */ me.forwardRef((n, e) => {
  let {
    reloadDocument: t,
    replace: i,
    method: r = ew,
    action: o,
    onSubmit: s,
    fetcherKey: a,
    routeId: l,
    relative: u,
    preventScrollReset: c
  } = n, h = DN(n, zie), d = ene(a, l), f = r.toLowerCase() === "get" ? "get" : "post", p = tne(o, {
    relative: u
  }), g = (_) => {
    if (s && s(_), _.defaultPrevented)
      return;
    _.preventDefault();
    let m = _.nativeEvent.submitter, v = (m == null ? void 0 : m.getAttribute("formmethod")) || r;
    d(m || _.currentTarget, {
      method: v,
      replace: i,
      relative: u,
      preventScrollReset: c
    });
  };
  return /* @__PURE__ */ me.createElement("form", Xl({
    ref: e,
    method: f,
    action: p,
    onSubmit: t ? s : g
  }, h));
});
process.env.NODE_ENV !== "production" && (xG.displayName = "FormImpl");
process.env.NODE_ENV;
var fR;
(function(n) {
  n.UseScrollRestoration = "useScrollRestoration", n.UseSubmitImpl = "useSubmitImpl", n.UseFetcher = "useFetcher";
})(fR || (fR = {}));
var $F;
(function(n) {
  n.UseFetchers = "useFetchers", n.UseScrollRestoration = "useScrollRestoration";
})($F || ($F = {}));
function Zie(n) {
  return n + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function Qie(n) {
  let e = me.useContext(gg);
  return e || (process.env.NODE_ENV !== "production" ? it(!1, Zie(n)) : it(!1)), e;
}
function Jie(n, e) {
  let {
    target: t,
    replace: i,
    state: r,
    preventScrollReset: o,
    relative: s
  } = e === void 0 ? {} : e, a = kV(), l = Jd(), u = bS(n, {
    relative: s
  });
  return me.useCallback((c) => {
    if (Vie(c, t)) {
      c.preventDefault();
      let h = i !== void 0 ? i : sh(l) === sh(u);
      a(n, {
        replace: h,
        state: r,
        preventScrollReset: o,
        relative: s
      });
    }
  }, [l, a, u, i, r, t, n, o, s]);
}
function eye(n) {
  process.env.NODE_ENV !== "production" && Or(typeof URLSearchParams < "u", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\n\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.");
  let e = me.useRef(dR(n)), t = me.useRef(!1), i = Jd(), r = me.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    Bie(i.search, t.current ? null : e.current)
  ), [i.search]), o = kV(), s = me.useCallback((a, l) => {
    const u = dR(typeof a == "function" ? a(r) : a);
    t.current = !0, o("?" + u, l);
  }, [o, r]);
  return [r, s];
}
function ene(n, e) {
  let {
    router: t
  } = Qie(fR.UseSubmitImpl), {
    basename: i
  } = me.useContext(tu), r = p6();
  return me.useCallback(function(o, s) {
    if (s === void 0 && (s = {}), typeof document > "u")
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    let {
      action: a,
      method: l,
      encType: u,
      formData: c
    } = Hie(o, s, i), h = {
      preventScrollReset: s.preventScrollReset,
      formData: c,
      formMethod: l,
      formEncType: u
    };
    n ? (e == null && (process.env.NODE_ENV !== "production" ? it(!1, "No routeId available for useFetcher()") : it(!1)), t.fetch(n, e, a, h)) : t.navigate(a, Xl({}, h, {
      replace: s.replace,
      fromRouteId: r
    }));
  }, [t, i, n, e, r]);
}
function tne(n, e) {
  let {
    relative: t
  } = e === void 0 ? {} : e, {
    basename: i
  } = me.useContext(tu), r = me.useContext(rl);
  r || (process.env.NODE_ENV !== "production" ? it(!1, "useFormAction must be used inside a RouteContext") : it(!1));
  let [o] = r.matches.slice(-1), s = Xl({}, bS(n || ".", {
    relative: t
  })), a = Jd();
  if (n == null && (s.search = a.search, s.hash = a.hash, o.route.index)) {
    let l = new URLSearchParams(s.search);
    l.delete("index"), s.search = l.toString() ? "?" + l.toString() : "";
  }
  return (!n || n === ".") && o.route.index && (s.search = s.search ? s.search.replace(/^\?/, "?index&") : "?index"), i !== "/" && (s.pathname = s.pathname === "/" ? i : Bl([i, s.pathname])), sh(s);
}
function ine(n, e) {
  let t;
  return e.length === 0 ? t = n : t = n.replace(/\{(\d+)\}/g, function(i, r) {
    const o = r[0];
    return typeof e[o] < "u" ? e[o] : i;
  }), t;
}
function b(n, e, ...t) {
  return ine(e, t);
}
var nD;
const tw = "en";
let ob = !1, sb = !1, iw = !1, NG = !1, IG = !1, RN = !1, hy, rD = tw, nne, Ic;
const vn = typeof self == "object" ? self : typeof global == "object" ? global : {};
let un;
typeof vn.vscode < "u" && typeof vn.vscode.process < "u" ? un = vn.vscode.process : typeof process < "u" && (un = process);
const PG = typeof ((nD = un == null ? void 0 : un.versions) === null || nD === void 0 ? void 0 : nD.electron) == "string" && un.type === "renderer", rne = PG && (un == null ? void 0 : un.sandboxed), one = (() => {
  if (rne)
    return "bypassHeatCheck";
  const n = un == null ? void 0 : un.env.VSCODE_BROWSER_CODE_LOADING;
  if (typeof n == "string")
    return n === "none" || n === "code" || n === "bypassHeatCheck" || n === "bypassHeatCheckAndEagerCompile" ? n : "bypassHeatCheck";
})(), sne = typeof one == "string";
if (typeof navigator == "object" && !PG)
  Ic = navigator.userAgent, ob = Ic.indexOf("Windows") >= 0, sb = Ic.indexOf("Macintosh") >= 0, RN = (Ic.indexOf("Macintosh") >= 0 || Ic.indexOf("iPad") >= 0 || Ic.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0, iw = Ic.indexOf("Linux") >= 0, IG = !0, hy = navigator.language, rD = hy;
else if (typeof un == "object") {
  ob = un.platform === "win32", sb = un.platform === "darwin", iw = un.platform === "linux", iw && un.env.SNAP && un.env.SNAP_REVISION, hy = tw, rD = tw;
  const n = un.env.VSCODE_NLS_CONFIG;
  if (n)
    try {
      const e = JSON.parse(n), t = e.availableLanguages["*"];
      hy = e.locale, rD = t || tw, nne = e._translationsConfigFile;
    } catch {
    }
  NG = !0;
} else
  console.error("Unable to resolve platform.");
const Ro = ob, kt = sb, Is = iw, cv = NG, XS = IG, Tg = RN, ane = Ic, ab = function() {
  if (vn.setImmediate)
    return vn.setImmediate.bind(vn);
  if (typeof vn.postMessage == "function" && !vn.importScripts) {
    let t = [];
    vn.addEventListener("message", (r) => {
      if (r.data && r.data.vscodeSetImmediateId)
        for (let o = 0, s = t.length; o < s; o++) {
          const a = t[o];
          if (a.id === r.data.vscodeSetImmediateId) {
            t.splice(o, 1), a.callback();
            return;
          }
        }
    });
    let i = 0;
    return (r) => {
      const o = ++i;
      t.push({
        id: o,
        callback: r
      }), vn.postMessage({ vscodeSetImmediateId: o }, "*");
    };
  }
  if (typeof (un == null ? void 0 : un.nextTick) == "function")
    return un.nextTick.bind(un);
  const e = Promise.resolve();
  return (t) => e.then(t);
}(), ja = sb || RN ? 2 : ob ? 1 : 3;
let KF = !0, qF = !1;
function AG() {
  if (!qF) {
    qF = !0;
    const n = new Uint8Array(2);
    n[0] = 1, n[1] = 2, KF = new Uint16Array(n.buffer)[0] === (2 << 8) + 1;
  }
  return KF;
}
const MG = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function lne(n = "") {
  let e = "(-?\\d*\\.\\d\\w*)|([^";
  for (const t of MG)
    n.indexOf(t) >= 0 || (e += "\\" + t);
  return e += "\\s]+)", new RegExp(e, "g");
}
const FG = lne();
function pR(n) {
  let e = FG;
  if (n && n instanceof RegExp)
    if (n.global)
      e = n;
    else {
      let t = "g";
      n.ignoreCase && (t += "i"), n.multiline && (t += "m"), n.unicode && (t += "u"), e = new RegExp(n.source, t);
    }
  return e.lastIndex = 0, e;
}
const une = {
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
};
function lb(n, e, t, i, r = une) {
  if (t.length > r.maxLen) {
    let u = n - r.maxLen / 2;
    return u < 0 ? u = 0 : i += u, t = t.substring(u, n + r.maxLen / 2), lb(n, e, t, i, r);
  }
  const o = Date.now(), s = n - 1 - i;
  let a = -1, l = null;
  for (let u = 1; !(Date.now() - o >= r.timeBudget); u++) {
    const c = s - r.windowSize * u;
    e.lastIndex = Math.max(0, c);
    const h = cne(e, t, s, a);
    if (!h && l || (l = h, c <= 0))
      break;
    a = c;
  }
  if (l) {
    let u = {
      word: l[0],
      startColumn: i + 1 + l.index,
      endColumn: i + 1 + l.index + l[0].length
    };
    return e.lastIndex = 0, u;
  }
  return null;
}
function cne(n, e, t, i) {
  let r;
  for (; r = n.exec(e); ) {
    const o = r.index || 0;
    if (o <= t && n.lastIndex >= t)
      return r;
    if (i > 0 && o > i)
      return null;
  }
  return null;
}
const Ym = 8;
class kG {
  /**
   * @internal
   */
  constructor(e) {
    this._values = e;
  }
  hasChanged(e) {
    return this._values[e];
  }
}
class hne {
  constructor() {
    this._values = [];
  }
  _read(e) {
    return this._values[e];
  }
  get(e) {
    return this._values[e];
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class WG {
  constructor() {
    this.stableMinimapLayoutInput = null, this.stableFitMaxMinimapScale = 0, this.stableFitRemainingWidth = 0;
  }
}
class Zn {
  constructor(e, t, i, r) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = r;
  }
  compute(e, t, i) {
    return i;
  }
}
class Og {
  constructor(e, t = null) {
    this.schema = void 0, this.id = e, this.name = "_never_", this.defaultValue = void 0, this.deps = t;
  }
  validate(e) {
    return this.defaultValue;
  }
}
class of {
  constructor(e, t, i, r) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = r;
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : e;
  }
  compute(e, t, i) {
    return i;
  }
}
function ze(n, e) {
  return typeof n > "u" ? e : n === "false" ? !1 : !!n;
}
class ct extends of {
  constructor(e, t, i, r = void 0) {
    typeof r < "u" && (r.type = "boolean", r.default = i), super(e, t, i, r);
  }
  validate(e) {
    return ze(e, this.defaultValue);
  }
}
class oi extends of {
  constructor(e, t, i, r, o, s = void 0) {
    typeof s < "u" && (s.type = "integer", s.default = i, s.minimum = r, s.maximum = o), super(e, t, i, s), this.minimum = r, this.maximum = o;
  }
  static clampedInt(e, t, i, r) {
    if (typeof e > "u")
      return t;
    let o = parseInt(e, 10);
    return isNaN(o) ? t : (o = Math.max(i, o), o = Math.min(r, o), o | 0);
  }
  validate(e) {
    return oi.clampedInt(e, this.defaultValue, this.minimum, this.maximum);
  }
}
class Kc extends of {
  constructor(e, t, i, r, o) {
    typeof o < "u" && (o.type = "number", o.default = i), super(e, t, i, o), this.validationFn = r;
  }
  static clamp(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static float(e, t) {
    if (typeof e == "number")
      return e;
    if (typeof e > "u")
      return t;
    const i = parseFloat(e);
    return isNaN(i) ? t : i;
  }
  validate(e) {
    return this.validationFn(Kc.float(e, this.defaultValue));
  }
}
class yo extends of {
  static string(e, t) {
    return typeof e != "string" ? t : e;
  }
  constructor(e, t, i, r = void 0) {
    typeof r < "u" && (r.type = "string", r.default = i), super(e, t, i, r);
  }
  validate(e) {
    return yo.string(e, this.defaultValue);
  }
}
function gs(n, e, t) {
  return typeof n != "string" || t.indexOf(n) === -1 ? e : n;
}
class ln extends of {
  constructor(e, t, i, r, o = void 0) {
    typeof o < "u" && (o.type = "string", o.enum = r, o.default = i), super(e, t, i, o), this._allowedValues = r;
  }
  validate(e) {
    return gs(e, this.defaultValue, this._allowedValues);
  }
}
class Pm extends Zn {
  constructor(e, t, i, r, o, s, a = void 0) {
    typeof a < "u" && (a.type = "string", a.enum = o, a.default = r), super(e, t, i, a), this._allowedValues = o, this._convert = s;
  }
  validate(e) {
    return typeof e != "string" ? this.defaultValue : this._allowedValues.indexOf(e) === -1 ? this.defaultValue : this._convert(e);
  }
}
function dne(n) {
  switch (n) {
    case "none":
      return 0;
    case "keep":
      return 1;
    case "brackets":
      return 2;
    case "advanced":
      return 3;
    case "full":
      return 4;
  }
}
class fne extends Zn {
  constructor() {
    super(2, "accessibilitySupport", 0, {
      type: "string",
      enum: ["auto", "on", "off"],
      enumDescriptions: [
        b("accessibilitySupport.auto", "The editor will use platform APIs to detect when a Screen Reader is attached."),
        b("accessibilitySupport.on", "The editor will be permanently optimized for usage with a Screen Reader. Word wrapping will be disabled."),
        b("accessibilitySupport.off", "The editor will never be optimized for usage with a Screen Reader.")
      ],
      default: "auto",
      description: b("accessibilitySupport", "Controls whether the editor should run in a mode where it is optimized for screen readers. Setting to on will disable word wrapping.")
    });
  }
  validate(e) {
    switch (e) {
      case "auto":
        return 0;
      case "off":
        return 1;
      case "on":
        return 2;
    }
    return this.defaultValue;
  }
  compute(e, t, i) {
    return i === 0 ? e.accessibilitySupport : i;
  }
}
class pne extends Zn {
  constructor() {
    const e = {
      insertSpace: !0,
      ignoreEmptyLines: !0
    };
    super(17, "comments", e, {
      "editor.comments.insertSpace": {
        type: "boolean",
        default: e.insertSpace,
        description: b("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
      },
      "editor.comments.ignoreEmptyLines": {
        type: "boolean",
        default: e.ignoreEmptyLines,
        description: b("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertSpace: ze(t.insertSpace, this.defaultValue.insertSpace),
      ignoreEmptyLines: ze(t.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
    };
  }
}
function gne(n) {
  switch (n) {
    case "blink":
      return 1;
    case "smooth":
      return 2;
    case "phase":
      return 3;
    case "expand":
      return 4;
    case "solid":
      return 5;
  }
}
var Vn;
(function(n) {
  n[n.Line = 1] = "Line", n[n.Block = 2] = "Block", n[n.Underline = 3] = "Underline", n[n.LineThin = 4] = "LineThin", n[n.BlockOutline = 5] = "BlockOutline", n[n.UnderlineThin = 6] = "UnderlineThin";
})(Vn || (Vn = {}));
function mne(n) {
  switch (n) {
    case "line":
      return Vn.Line;
    case "block":
      return Vn.Block;
    case "underline":
      return Vn.Underline;
    case "line-thin":
      return Vn.LineThin;
    case "block-outline":
      return Vn.BlockOutline;
    case "underline-thin":
      return Vn.UnderlineThin;
  }
}
class vne extends Og {
  constructor() {
    super(125, [
      63,
      31
      /* extraEditorClassName */
    ]);
  }
  compute(e, t, i) {
    const r = ["monaco-editor"];
    return t.get(
      31
      /* extraEditorClassName */
    ) && r.push(t.get(
      31
      /* extraEditorClassName */
    )), e.extraEditorClassName && r.push(e.extraEditorClassName), t.get(
      63
      /* mouseStyle */
    ) === "default" ? r.push("mouse-default") : t.get(
      63
      /* mouseStyle */
    ) === "copy" && r.push("mouse-copy"), t.get(
      98
      /* showUnused */
    ) && r.push("showUnused"), t.get(
      123
      /* showDeprecated */
    ) && r.push("showDeprecated"), r.join(" ");
  }
}
class _ne extends ct {
  constructor() {
    super(30, "emptySelectionClipboard", !0, { description: b("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.") });
  }
  compute(e, t, i) {
    return i && e.emptySelectionClipboard;
  }
}
class Cne extends Zn {
  constructor() {
    const e = {
      cursorMoveOnType: !0,
      seedSearchStringFromSelection: !0,
      autoFindInSelection: "never",
      globalFindClipboard: !1,
      addExtraSpaceOnTop: !0,
      loop: !0
    };
    super(33, "find", e, {
      "editor.find.cursorMoveOnType": {
        type: "boolean",
        default: e.cursorMoveOnType,
        description: b("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
      },
      "editor.find.seedSearchStringFromSelection": {
        type: "boolean",
        default: e.seedSearchStringFromSelection,
        description: b("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
      },
      "editor.find.autoFindInSelection": {
        type: "string",
        enum: ["never", "always", "multiline"],
        default: e.autoFindInSelection,
        enumDescriptions: [
          b("editor.find.autoFindInSelection.never", "Never turn on Find in selection automatically (default)."),
          b("editor.find.autoFindInSelection.always", "Always turn on Find in selection automatically."),
          b("editor.find.autoFindInSelection.multiline", "Turn on Find in selection automatically when multiple lines of content are selected.")
        ],
        description: b("find.autoFindInSelection", "Controls the condition for turning on find in selection automatically.")
      },
      "editor.find.globalFindClipboard": {
        type: "boolean",
        default: e.globalFindClipboard,
        description: b("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
        included: kt
      },
      "editor.find.addExtraSpaceOnTop": {
        type: "boolean",
        default: e.addExtraSpaceOnTop,
        description: b("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
      },
      "editor.find.loop": {
        type: "boolean",
        default: e.loop,
        description: b("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      cursorMoveOnType: ze(t.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
      seedSearchStringFromSelection: ze(t.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection),
      autoFindInSelection: typeof e.autoFindInSelection == "boolean" ? e.autoFindInSelection ? "always" : "never" : gs(t.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
      globalFindClipboard: ze(t.globalFindClipboard, this.defaultValue.globalFindClipboard),
      addExtraSpaceOnTop: ze(t.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
      loop: ze(t.loop, this.defaultValue.loop)
    };
  }
}
class vs extends Zn {
  constructor() {
    super(41, "fontLigatures", vs.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: b("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
        },
        {
          type: "string",
          description: b("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
        }
      ],
      description: b("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" ? vs.OFF : e === "true" ? vs.ON : e : e ? vs.ON : vs.OFF;
  }
}
vs.OFF = '"liga" off, "calt" off';
vs.ON = '"liga" on, "calt" on';
class yne extends Og {
  constructor() {
    super(
      40
      /* fontInfo */
    );
  }
  compute(e, t, i) {
    return e.fontInfo;
  }
}
class wne extends of {
  constructor() {
    super(42, "fontSize", Ts.fontSize, {
      type: "number",
      minimum: 6,
      maximum: 100,
      default: Ts.fontSize,
      description: b("fontSize", "Controls the font size in pixels.")
    });
  }
  validate(e) {
    let t = Kc.float(e, this.defaultValue);
    return t === 0 ? Ts.fontSize : Kc.clamp(t, 6, 100);
  }
  compute(e, t, i) {
    return e.fontInfo.fontSize;
  }
}
class kl extends Zn {
  constructor() {
    super(43, "fontWeight", Ts.fontWeight, {
      anyOf: [
        {
          type: "number",
          minimum: kl.MINIMUM_VALUE,
          maximum: kl.MAXIMUM_VALUE,
          errorMessage: b("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: kl.SUGGESTION_VALUES
        }
      ],
      default: Ts.fontWeight,
      description: b("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
    });
  }
  validate(e) {
    return e === "normal" || e === "bold" ? e : String(oi.clampedInt(e, Ts.fontWeight, kl.MINIMUM_VALUE, kl.MAXIMUM_VALUE));
  }
}
kl.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
kl.MINIMUM_VALUE = 1;
kl.MAXIMUM_VALUE = 1e3;
class bne extends Zn {
  constructor() {
    const e = {
      multiple: "peek",
      multipleDefinitions: "peek",
      multipleTypeDefinitions: "peek",
      multipleDeclarations: "peek",
      multipleImplementations: "peek",
      multipleReferences: "peek",
      alternativeDefinitionCommand: "editor.action.goToReferences",
      alternativeTypeDefinitionCommand: "editor.action.goToReferences",
      alternativeDeclarationCommand: "editor.action.goToReferences",
      alternativeImplementationCommand: "",
      alternativeReferenceCommand: ""
    }, t = {
      type: "string",
      enum: ["peek", "gotoAndPeek", "goto"],
      default: e.multiple,
      enumDescriptions: [
        b("editor.gotoLocation.multiple.peek", "Show peek view of the results (default)"),
        b("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a peek view"),
        b("editor.gotoLocation.multiple.goto", "Go to the primary result and enable peek-less navigation to others")
      ]
    }, i = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
    super(47, "gotoLocation", e, {
      "editor.gotoLocation.multiple": {
        deprecationMessage: b("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
      },
      "editor.gotoLocation.multipleDefinitions": Object.assign({ description: b("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleTypeDefinitions": Object.assign({ description: b("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleDeclarations": Object.assign({ description: b("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleImplementations": Object.assign({ description: b("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.multipleReferences": Object.assign({ description: b("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist.") }, t),
      "editor.gotoLocation.alternativeDefinitionCommand": {
        type: "string",
        default: e.alternativeDefinitionCommand,
        enum: i,
        description: b("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeTypeDefinitionCommand": {
        type: "string",
        default: e.alternativeTypeDefinitionCommand,
        enum: i,
        description: b("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeDeclarationCommand": {
        type: "string",
        default: e.alternativeDeclarationCommand,
        enum: i,
        description: b("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
      },
      "editor.gotoLocation.alternativeImplementationCommand": {
        type: "string",
        default: e.alternativeImplementationCommand,
        enum: i,
        description: b("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
      },
      "editor.gotoLocation.alternativeReferenceCommand": {
        type: "string",
        default: e.alternativeReferenceCommand,
        enum: i,
        description: b("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
      }
    });
  }
  validate(e) {
    var t, i, r, o, s;
    if (!e || typeof e != "object")
      return this.defaultValue;
    const a = e;
    return {
      multiple: gs(a.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
      multipleDefinitions: (t = a.multipleDefinitions) !== null && t !== void 0 ? t : gs(a.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTypeDefinitions: (i = a.multipleTypeDefinitions) !== null && i !== void 0 ? i : gs(a.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleDeclarations: (r = a.multipleDeclarations) !== null && r !== void 0 ? r : gs(a.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleImplementations: (o = a.multipleImplementations) !== null && o !== void 0 ? o : gs(a.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleReferences: (s = a.multipleReferences) !== null && s !== void 0 ? s : gs(a.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
      alternativeDefinitionCommand: yo.string(a.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
      alternativeTypeDefinitionCommand: yo.string(a.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
      alternativeDeclarationCommand: yo.string(a.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
      alternativeImplementationCommand: yo.string(a.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
      alternativeReferenceCommand: yo.string(a.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand)
    };
  }
}
class Sne extends Zn {
  constructor() {
    const e = {
      enabled: !0,
      delay: 300,
      sticky: !0
    };
    super(50, "hover", e, {
      "editor.hover.enabled": {
        type: "boolean",
        default: e.enabled,
        description: b("hover.enabled", "Controls whether the hover is shown.")
      },
      "editor.hover.delay": {
        type: "number",
        default: e.delay,
        description: b("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
      },
      "editor.hover.sticky": {
        type: "boolean",
        default: e.sticky,
        description: b("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ze(t.enabled, this.defaultValue.enabled),
      delay: oi.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
      sticky: ze(t.sticky, this.defaultValue.sticky)
    };
  }
}
class wp extends Og {
  constructor() {
    super(128, [
      46,
      55,
      35,
      62,
      90,
      57,
      58,
      92,
      115,
      118,
      119,
      120,
      2
      /* accessibilitySupport */
    ]);
  }
  compute(e, t, i) {
    return wp.computeLayout(t, {
      memory: e.memory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight,
      isDominatedByLongLines: e.isDominatedByLongLines,
      lineHeight: e.fontInfo.lineHeight,
      viewLineCount: e.viewLineCount,
      lineNumbersDigitCount: e.lineNumbersDigitCount,
      typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
      maxDigitWidth: e.fontInfo.maxDigitWidth,
      pixelRatio: e.pixelRatio
    });
  }
  static computeContainedMinimapLineCount(e) {
    const t = e.height / e.lineHeight, i = e.scrollBeyondLastLine ? t - 1 : 0, r = (e.viewLineCount + i) / (e.pixelRatio * e.height), o = Math.floor(e.viewLineCount / r);
    return { typicalViewportLineCount: t, extraLinesBeyondLastLine: i, desiredRatio: r, minimapLineCount: o };
  }
  static _computeMinimapLayout(e, t) {
    const i = e.outerWidth, r = e.outerHeight, o = e.pixelRatio;
    if (!e.minimap.enabled)
      return {
        renderMinimap: 0,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: !1,
        minimapIsSampling: !1,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: Math.floor(o * r),
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: r
      };
    const s = t.stableMinimapLayoutInput, a = s && e.outerHeight === s.outerHeight && e.lineHeight === s.lineHeight && e.typicalHalfwidthCharacterWidth === s.typicalHalfwidthCharacterWidth && e.pixelRatio === s.pixelRatio && e.scrollBeyondLastLine === s.scrollBeyondLastLine && e.minimap.enabled === s.minimap.enabled && e.minimap.side === s.minimap.side && e.minimap.size === s.minimap.size && e.minimap.showSlider === s.minimap.showSlider && e.minimap.renderCharacters === s.minimap.renderCharacters && e.minimap.maxColumn === s.minimap.maxColumn && e.minimap.scale === s.minimap.scale && e.verticalScrollbarWidth === s.verticalScrollbarWidth && e.isViewportWrapping === s.isViewportWrapping, l = e.lineHeight, u = e.typicalHalfwidthCharacterWidth, c = e.scrollBeyondLastLine, h = e.minimap.renderCharacters;
    let d = o >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale;
    const f = e.minimap.maxColumn, p = e.minimap.size, g = e.minimap.side, _ = e.verticalScrollbarWidth, m = e.viewLineCount, v = e.remainingWidth, C = e.isViewportWrapping, y = h ? 2 : 3;
    let w = Math.floor(o * r);
    const L = w / o;
    let S = !1, E = !1, D = y * d, x = d / o, R = 1;
    if (p === "fill" || p === "fit") {
      const { typicalViewportLineCount: ae, extraLinesBeyondLastLine: re, desiredRatio: Y, minimapLineCount: K } = wp.computeContainedMinimapLineCount({
        viewLineCount: m,
        scrollBeyondLastLine: c,
        height: r,
        lineHeight: l,
        pixelRatio: o
      });
      if (m / K > 1)
        S = !0, E = !0, d = 1, D = 1, x = d / o;
      else {
        let B = !1, U = d + 1;
        if (p === "fit") {
          const O = Math.ceil((m + re) * D);
          C && a && v <= t.stableFitRemainingWidth ? (B = !0, U = t.stableFitMaxMinimapScale) : (B = O > w, C && B ? (t.stableMinimapLayoutInput = e, t.stableFitRemainingWidth = v) : (t.stableMinimapLayoutInput = null, t.stableFitRemainingWidth = 0));
        }
        if (p === "fill" || B) {
          S = !0;
          const O = d;
          D = Math.min(l * o, Math.max(1, Math.floor(1 / Y))), d = Math.min(U, Math.max(1, Math.floor(D / y))), d > O && (R = Math.min(2, d / O)), x = d / o / R, w = Math.ceil(Math.max(ae, m + re) * D), C && B && (t.stableFitMaxMinimapScale = d);
        }
      }
    }
    const A = Math.floor(f * x), M = Math.min(A, Math.max(0, Math.floor((v - _ - 2) * x / (u + x))) + Ym);
    let z = Math.floor(o * M);
    const j = z / o;
    z = Math.floor(z * R);
    const $ = h ? 1 : 2, k = g === "left" ? 0 : i - M - _;
    return {
      renderMinimap: $,
      minimapLeft: k,
      minimapWidth: M,
      minimapHeightIsEditorHeight: S,
      minimapIsSampling: E,
      minimapScale: d,
      minimapLineHeight: D,
      minimapCanvasInnerWidth: z,
      minimapCanvasInnerHeight: w,
      minimapCanvasOuterWidth: j,
      minimapCanvasOuterHeight: L
    };
  }
  static computeLayout(e, t) {
    const i = t.outerWidth | 0, r = t.outerHeight | 0, o = t.lineHeight | 0, s = t.lineNumbersDigitCount | 0, a = t.typicalHalfwidthCharacterWidth, l = t.maxDigitWidth, u = t.pixelRatio, c = t.viewLineCount, h = e.get(
      120
      /* wordWrapOverride2 */
    ), d = h === "inherit" ? e.get(
      119
      /* wordWrapOverride1 */
    ) : h, f = d === "inherit" ? e.get(
      115
      /* wordWrap */
    ) : d, p = e.get(
      118
      /* wordWrapColumn */
    ), g = e.get(
      2
      /* accessibilitySupport */
    ), _ = t.isDominatedByLongLines, m = e.get(
      46
      /* glyphMargin */
    ), v = e.get(
      57
      /* lineNumbers */
    ).renderType !== 0, C = e.get(
      58
      /* lineNumbersMinChars */
    ), y = e.get(
      92
      /* scrollBeyondLastLine */
    ), w = e.get(
      62
      /* minimap */
    ), L = e.get(
      90
      /* scrollbar */
    ), S = L.verticalScrollbarSize, E = L.verticalHasArrows, D = L.arrowSize, x = L.horizontalScrollbarSize, R = e.get(
      55
      /* lineDecorationsWidth */
    ), A = e.get(
      35
      /* folding */
    );
    let M;
    if (typeof R == "string" && /^\d+(\.\d+)?ch$/.test(R)) {
      const V = parseFloat(R.substr(0, R.length - 2));
      M = oi.clampedInt(V * a, 0, 0, 1e3);
    } else
      M = oi.clampedInt(R, 0, 0, 1e3);
    A && (M += 16);
    let z = 0;
    if (v) {
      const V = Math.max(s, C);
      z = Math.round(V * l);
    }
    let j = 0;
    m && (j = o);
    let $ = 0, k = $ + j, ae = k + z, re = ae + M;
    const Y = i - j - z - M;
    let K = !1, W = !1, B = -1;
    g !== 2 && (d === "inherit" && _ ? (K = !0, W = !0) : f === "on" || f === "bounded" ? W = !0 : f === "wordWrapColumn" && (B = p));
    const U = wp._computeMinimapLayout({
      outerWidth: i,
      outerHeight: r,
      lineHeight: o,
      typicalHalfwidthCharacterWidth: a,
      pixelRatio: u,
      scrollBeyondLastLine: y,
      minimap: w,
      verticalScrollbarWidth: S,
      viewLineCount: c,
      remainingWidth: Y,
      isViewportWrapping: W
    }, t.memory || new WG());
    U.renderMinimap !== 0 && U.minimapLeft === 0 && ($ += U.minimapWidth, k += U.minimapWidth, ae += U.minimapWidth, re += U.minimapWidth);
    const O = Y - U.minimapWidth, N = Math.max(1, Math.floor((O - S - 2) / a)), I = E ? D : 0;
    return W && (B = Math.max(1, N), f === "bounded" && (B = Math.min(B, p))), {
      width: i,
      height: r,
      glyphMarginLeft: $,
      glyphMarginWidth: j,
      lineNumbersLeft: k,
      lineNumbersWidth: z,
      decorationsLeft: ae,
      decorationsWidth: M,
      contentLeft: re,
      contentWidth: O,
      minimap: U,
      viewportColumn: N,
      isWordWrapMinified: K,
      isViewportWrapping: W,
      wrappingColumn: B,
      verticalScrollbarWidth: S,
      horizontalScrollbarHeight: x,
      overviewRuler: {
        top: I,
        width: S,
        height: r - 2 * I,
        right: 0
      }
    };
  }
}
class Ene extends Zn {
  constructor() {
    const e = { enabled: !0 };
    super(54, "lightbulb", e, {
      "editor.lightbulb.enabled": {
        type: "boolean",
        default: e.enabled,
        description: b("codeActions", "Enables the code action lightbulb in the editor.")
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      enabled: ze(e.enabled, this.defaultValue.enabled)
    };
  }
}
class Lne extends Zn {
  constructor() {
    const e = { enabled: !0, fontSize: 0, fontFamily: Ts.fontFamily };
    super(124, "inlayHints", e, {
      "editor.inlayHints.enabled": {
        type: "boolean",
        default: e.enabled,
        description: b("inlayHints.enable", "Enables the inlay hints in the editor.")
      },
      "editor.inlayHints.fontSize": {
        type: "number",
        default: e.fontSize,
        description: b("inlayHints.fontSize", "Controls font size of inlay hints in the editor. When set to `0`, the 90% of `#editor.fontSize#` is used.")
      },
      "editor.inlayHints.fontFamily": {
        type: "string",
        default: e.fontFamily,
        description: b("inlayHints.fontFamily", "Controls font family of inlay hints in the editor.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ze(t.enabled, this.defaultValue.enabled),
      fontSize: oi.clampedInt(t.fontSize, this.defaultValue.fontSize, 0, 100),
      fontFamily: yo.string(t.fontFamily, this.defaultValue.fontFamily)
    };
  }
}
class Dne extends oi {
  constructor() {
    super(56, "lineHeight", Ts.lineHeight, 0, 150, { description: b("lineHeight", "Controls the line height. Use 0 to compute the line height from the font size.") });
  }
  compute(e, t, i) {
    return e.fontInfo.lineHeight;
  }
}
class Rne extends Zn {
  constructor() {
    const e = {
      enabled: !0,
      size: "proportional",
      side: "right",
      showSlider: "mouseover",
      renderCharacters: !0,
      maxColumn: 120,
      scale: 1
    };
    super(62, "minimap", e, {
      "editor.minimap.enabled": {
        type: "boolean",
        default: e.enabled,
        description: b("minimap.enabled", "Controls whether the minimap is shown.")
      },
      "editor.minimap.size": {
        type: "string",
        enum: ["proportional", "fill", "fit"],
        enumDescriptions: [
          b("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
          b("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
          b("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
        ],
        default: e.size,
        description: b("minimap.size", "Controls the size of the minimap.")
      },
      "editor.minimap.side": {
        type: "string",
        enum: ["left", "right"],
        default: e.side,
        description: b("minimap.side", "Controls the side where to render the minimap.")
      },
      "editor.minimap.showSlider": {
        type: "string",
        enum: ["always", "mouseover"],
        default: e.showSlider,
        description: b("minimap.showSlider", "Controls when the minimap slider is shown.")
      },
      "editor.minimap.scale": {
        type: "number",
        default: e.scale,
        minimum: 1,
        maximum: 3,
        enum: [1, 2, 3],
        description: b("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
      },
      "editor.minimap.renderCharacters": {
        type: "boolean",
        default: e.renderCharacters,
        description: b("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
      },
      "editor.minimap.maxColumn": {
        type: "number",
        default: e.maxColumn,
        description: b("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ze(t.enabled, this.defaultValue.enabled),
      size: gs(t.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
      side: gs(t.side, this.defaultValue.side, ["right", "left"]),
      showSlider: gs(t.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
      renderCharacters: ze(t.renderCharacters, this.defaultValue.renderCharacters),
      scale: oi.clampedInt(t.scale, 1, 1, 3),
      maxColumn: oi.clampedInt(t.maxColumn, this.defaultValue.maxColumn, 1, 1e4)
    };
  }
}
function Tne(n) {
  return n === "ctrlCmd" ? kt ? "metaKey" : "ctrlKey" : "altKey";
}
class One extends Zn {
  constructor() {
    super(72, "padding", { top: 0, bottom: 0 }, {
      "editor.padding.top": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: b("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
      },
      "editor.padding.bottom": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: b("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      top: oi.clampedInt(t.top, 0, 0, 1e3),
      bottom: oi.clampedInt(t.bottom, 0, 0, 1e3)
    };
  }
}
class xne extends Zn {
  constructor() {
    const e = {
      enabled: !0,
      cycle: !1
    };
    super(73, "parameterHints", e, {
      "editor.parameterHints.enabled": {
        type: "boolean",
        default: e.enabled,
        description: b("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
      },
      "editor.parameterHints.cycle": {
        type: "boolean",
        default: e.cycle,
        description: b("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ze(t.enabled, this.defaultValue.enabled),
      cycle: ze(t.cycle, this.defaultValue.cycle)
    };
  }
}
class Nne extends Og {
  constructor() {
    super(
      126
      /* pixelRatio */
    );
  }
  compute(e, t, i) {
    return e.pixelRatio;
  }
}
class Ine extends Zn {
  constructor() {
    const e = {
      other: !0,
      comments: !1,
      strings: !1
    };
    super(76, "quickSuggestions", e, {
      anyOf: [
        {
          type: "boolean"
        },
        {
          type: "object",
          properties: {
            strings: {
              type: "boolean",
              default: e.strings,
              description: b("quickSuggestions.strings", "Enable quick suggestions inside strings.")
            },
            comments: {
              type: "boolean",
              default: e.comments,
              description: b("quickSuggestions.comments", "Enable quick suggestions inside comments.")
            },
            other: {
              type: "boolean",
              default: e.other,
              description: b("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
            }
          }
        }
      ],
      default: e,
      description: b("quickSuggestions", "Controls whether suggestions should automatically show up while typing.")
    }), this.defaultValue = e;
  }
  validate(e) {
    if (typeof e == "boolean")
      return e;
    if (e && typeof e == "object") {
      const t = e, i = {
        other: ze(t.other, this.defaultValue.other),
        comments: ze(t.comments, this.defaultValue.comments),
        strings: ze(t.strings, this.defaultValue.strings)
      };
      return i.other && i.comments && i.strings ? !0 : !i.other && !i.comments && !i.strings ? !1 : i;
    }
    return this.defaultValue;
  }
}
class Pne extends Zn {
  constructor() {
    super(57, "lineNumbers", { renderType: 1, renderFn: null }, {
      type: "string",
      enum: ["off", "on", "relative", "interval"],
      enumDescriptions: [
        b("lineNumbers.off", "Line numbers are not rendered."),
        b("lineNumbers.on", "Line numbers are rendered as absolute number."),
        b("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
        b("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
      ],
      default: "on",
      description: b("lineNumbers", "Controls the display of line numbers.")
    });
  }
  validate(e) {
    let t = this.defaultValue.renderType, i = this.defaultValue.renderFn;
    return typeof e < "u" && (typeof e == "function" ? (t = 4, i = e) : e === "interval" ? t = 3 : e === "relative" ? t = 2 : e === "on" ? t = 1 : t = 0), {
      renderType: t,
      renderFn: i
    };
  }
}
function TN(n) {
  const e = n.get(
    85
    /* renderValidationDecorations */
  );
  return e === "editable" ? n.get(
    78
    /* readOnly */
  ) : e !== "on";
}
class Ane extends Zn {
  constructor() {
    const e = [], t = { type: "number", description: b("rulers.size", "Number of monospace characters at which this editor ruler will render.") };
    super(89, "rulers", e, {
      type: "array",
      items: {
        anyOf: [
          t,
          {
            type: [
              "object"
            ],
            properties: {
              column: t,
              color: {
                type: "string",
                description: b("rulers.color", "Color of this editor ruler."),
                format: "color-hex"
              }
            }
          }
        ]
      },
      default: e,
      description: b("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
    });
  }
  validate(e) {
    if (Array.isArray(e)) {
      let t = [];
      for (let i of e)
        if (typeof i == "number")
          t.push({
            column: oi.clampedInt(i, 0, 0, 1e4),
            color: null
          });
        else if (i && typeof i == "object") {
          const r = i;
          t.push({
            column: oi.clampedInt(r.column, 0, 0, 1e4),
            color: r.color
          });
        }
      return t.sort((i, r) => i.column - r.column), t;
    }
    return this.defaultValue;
  }
}
function YF(n, e) {
  if (typeof n != "string")
    return e;
  switch (n) {
    case "hidden":
      return 2;
    case "visible":
      return 3;
    default:
      return 1;
  }
}
let Mne = class extends Zn {
  constructor() {
    super(90, "scrollbar", {
      vertical: 1,
      horizontal: 1,
      arrowSize: 11,
      useShadows: !0,
      verticalHasArrows: !1,
      horizontalHasArrows: !1,
      horizontalScrollbarSize: 12,
      horizontalSliderSize: 12,
      verticalScrollbarSize: 14,
      verticalSliderSize: 14,
      handleMouseWheel: !0,
      alwaysConsumeMouseWheel: !0,
      scrollByPage: !1
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e, i = oi.clampedInt(t.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3), r = oi.clampedInt(t.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
    return {
      arrowSize: oi.clampedInt(t.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
      vertical: YF(t.vertical, this.defaultValue.vertical),
      horizontal: YF(t.horizontal, this.defaultValue.horizontal),
      useShadows: ze(t.useShadows, this.defaultValue.useShadows),
      verticalHasArrows: ze(t.verticalHasArrows, this.defaultValue.verticalHasArrows),
      horizontalHasArrows: ze(t.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
      handleMouseWheel: ze(t.handleMouseWheel, this.defaultValue.handleMouseWheel),
      alwaysConsumeMouseWheel: ze(t.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
      horizontalScrollbarSize: i,
      horizontalSliderSize: oi.clampedInt(t.horizontalSliderSize, i, 0, 1e3),
      verticalScrollbarSize: r,
      verticalSliderSize: oi.clampedInt(t.verticalSliderSize, r, 0, 1e3),
      scrollByPage: ze(t.scrollByPage, this.defaultValue.scrollByPage)
    };
  }
};
class Fne extends Zn {
  constructor() {
    const e = {
      enabled: !1
    };
    super(52, "inlineSuggest", e, {
      "editor.inlineSuggest.enabled": {
        type: "boolean",
        default: e.enabled,
        description: b("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      enabled: ze(e.enabled, this.defaultValue.enabled)
    };
  }
}
class kne extends Zn {
  constructor() {
    const e = {
      insertMode: "insert",
      filterGraceful: !0,
      snippetsPreventQuickSuggestions: !0,
      localityBonus: !1,
      shareSuggestSelections: !1,
      showIcons: !0,
      showStatusBar: !1,
      preview: !1,
      showInlineDetails: !0,
      showMethods: !0,
      showFunctions: !0,
      showConstructors: !0,
      showDeprecated: !0,
      showFields: !0,
      showVariables: !0,
      showClasses: !0,
      showStructs: !0,
      showInterfaces: !0,
      showModules: !0,
      showProperties: !0,
      showEvents: !0,
      showOperators: !0,
      showUnits: !0,
      showValues: !0,
      showConstants: !0,
      showEnums: !0,
      showEnumMembers: !0,
      showKeywords: !0,
      showWords: !0,
      showColors: !0,
      showFiles: !0,
      showReferences: !0,
      showFolders: !0,
      showTypeParameters: !0,
      showSnippets: !0,
      showUsers: !0,
      showIssues: !0
    };
    super(104, "suggest", e, {
      "editor.suggest.insertMode": {
        type: "string",
        enum: ["insert", "replace"],
        enumDescriptions: [
          b("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
          b("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
        ],
        default: e.insertMode,
        description: b("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
      },
      "editor.suggest.filterGraceful": {
        type: "boolean",
        default: e.filterGraceful,
        description: b("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
      },
      "editor.suggest.localityBonus": {
        type: "boolean",
        default: e.localityBonus,
        description: b("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
      },
      "editor.suggest.shareSuggestSelections": {
        type: "boolean",
        default: e.shareSuggestSelections,
        markdownDescription: b("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
      },
      "editor.suggest.snippetsPreventQuickSuggestions": {
        type: "boolean",
        default: e.snippetsPreventQuickSuggestions,
        description: b("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
      },
      "editor.suggest.showIcons": {
        type: "boolean",
        default: e.showIcons,
        description: b("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
      },
      "editor.suggest.showStatusBar": {
        type: "boolean",
        default: e.showStatusBar,
        description: b("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
      },
      "editor.suggest.preview": {
        type: "boolean",
        default: e.preview,
        description: b("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
      },
      "editor.suggest.showInlineDetails": {
        type: "boolean",
        default: e.showInlineDetails,
        description: b("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget")
      },
      "editor.suggest.maxVisibleSuggestions": {
        type: "number",
        deprecationMessage: b("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
      },
      "editor.suggest.filteredTypes": {
        type: "object",
        deprecationMessage: b("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
      },
      "editor.suggest.showMethods": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
      },
      "editor.suggest.showFunctions": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
      },
      "editor.suggest.showConstructors": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
      },
      "editor.suggest.showDeprecated": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
      },
      "editor.suggest.showFields": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
      },
      "editor.suggest.showVariables": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
      },
      "editor.suggest.showClasses": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
      },
      "editor.suggest.showStructs": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
      },
      "editor.suggest.showInterfaces": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
      },
      "editor.suggest.showModules": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
      },
      "editor.suggest.showProperties": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
      },
      "editor.suggest.showEvents": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
      },
      "editor.suggest.showOperators": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
      },
      "editor.suggest.showUnits": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
      },
      "editor.suggest.showValues": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
      },
      "editor.suggest.showConstants": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
      },
      "editor.suggest.showEnums": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
      },
      "editor.suggest.showEnumMembers": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
      },
      "editor.suggest.showKeywords": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
      },
      "editor.suggest.showWords": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
      },
      "editor.suggest.showColors": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
      },
      "editor.suggest.showFiles": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
      },
      "editor.suggest.showReferences": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
      },
      "editor.suggest.showCustomcolors": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
      },
      "editor.suggest.showFolders": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
      },
      "editor.suggest.showTypeParameters": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
      },
      "editor.suggest.showSnippets": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
      },
      "editor.suggest.showUsers": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
      },
      "editor.suggest.showIssues": {
        type: "boolean",
        default: !0,
        markdownDescription: b("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertMode: gs(t.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
      filterGraceful: ze(t.filterGraceful, this.defaultValue.filterGraceful),
      snippetsPreventQuickSuggestions: ze(t.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
      localityBonus: ze(t.localityBonus, this.defaultValue.localityBonus),
      shareSuggestSelections: ze(t.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
      showIcons: ze(t.showIcons, this.defaultValue.showIcons),
      showStatusBar: ze(t.showStatusBar, this.defaultValue.showStatusBar),
      preview: ze(t.preview, this.defaultValue.preview),
      showInlineDetails: ze(t.showInlineDetails, this.defaultValue.showInlineDetails),
      showMethods: ze(t.showMethods, this.defaultValue.showMethods),
      showFunctions: ze(t.showFunctions, this.defaultValue.showFunctions),
      showConstructors: ze(t.showConstructors, this.defaultValue.showConstructors),
      showDeprecated: ze(t.showDeprecated, this.defaultValue.showDeprecated),
      showFields: ze(t.showFields, this.defaultValue.showFields),
      showVariables: ze(t.showVariables, this.defaultValue.showVariables),
      showClasses: ze(t.showClasses, this.defaultValue.showClasses),
      showStructs: ze(t.showStructs, this.defaultValue.showStructs),
      showInterfaces: ze(t.showInterfaces, this.defaultValue.showInterfaces),
      showModules: ze(t.showModules, this.defaultValue.showModules),
      showProperties: ze(t.showProperties, this.defaultValue.showProperties),
      showEvents: ze(t.showEvents, this.defaultValue.showEvents),
      showOperators: ze(t.showOperators, this.defaultValue.showOperators),
      showUnits: ze(t.showUnits, this.defaultValue.showUnits),
      showValues: ze(t.showValues, this.defaultValue.showValues),
      showConstants: ze(t.showConstants, this.defaultValue.showConstants),
      showEnums: ze(t.showEnums, this.defaultValue.showEnums),
      showEnumMembers: ze(t.showEnumMembers, this.defaultValue.showEnumMembers),
      showKeywords: ze(t.showKeywords, this.defaultValue.showKeywords),
      showWords: ze(t.showWords, this.defaultValue.showWords),
      showColors: ze(t.showColors, this.defaultValue.showColors),
      showFiles: ze(t.showFiles, this.defaultValue.showFiles),
      showReferences: ze(t.showReferences, this.defaultValue.showReferences),
      showFolders: ze(t.showFolders, this.defaultValue.showFolders),
      showTypeParameters: ze(t.showTypeParameters, this.defaultValue.showTypeParameters),
      showSnippets: ze(t.showSnippets, this.defaultValue.showSnippets),
      showUsers: ze(t.showUsers, this.defaultValue.showUsers),
      showIssues: ze(t.showIssues, this.defaultValue.showIssues)
    };
  }
}
class Wne extends Zn {
  constructor() {
    super(100, "smartSelect", {
      selectLeadingAndTrailingWhitespace: !0
    }, {
      "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
        description: b("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
        default: !0,
        type: "boolean"
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      selectLeadingAndTrailingWhitespace: ze(e.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace)
    };
  }
}
class Vne extends Og {
  constructor() {
    super(127, [
      78
      /* readOnly */
    ]);
  }
  compute(e, t, i) {
    return t.get(
      78
      /* readOnly */
    ) ? !0 : e.tabFocusMode;
  }
}
function Bne(n) {
  switch (n) {
    case "none":
      return 0;
    case "same":
      return 1;
    case "indent":
      return 2;
    case "deepIndent":
      return 3;
  }
}
class Hne extends Og {
  constructor() {
    super(129, [
      128
      /* layoutInfo */
    ]);
  }
  compute(e, t, i) {
    const r = t.get(
      128
      /* layoutInfo */
    );
    return {
      isDominatedByLongLines: e.isDominatedByLongLines,
      isWordWrapMinified: r.isWordWrapMinified,
      isViewportWrapping: r.isViewportWrapping,
      wrappingColumn: r.wrappingColumn
    };
  }
}
const Gne = "Consolas, 'Courier New', monospace", Une = "Menlo, Monaco, 'Courier New', monospace", zne = "'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback'", Ts = {
  fontFamily: kt ? Une : Is ? zne : Gne,
  fontWeight: "normal",
  fontSize: kt ? 12 : 14,
  lineHeight: 0,
  letterSpacing: 0
}, bo = {
  tabSize: 4,
  indentSize: 4,
  insertSpaces: !0,
  detectIndentation: !0,
  trimAutoWhitespace: !0,
  largeFileOptimizations: !0
}, np = [];
function he(n) {
  return np[n.id] = n, n;
}
const sf = {
  acceptSuggestionOnCommitCharacter: he(new ct(0, "acceptSuggestionOnCommitCharacter", !0, { markdownDescription: b("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
  acceptSuggestionOnEnter: he(new ln(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
    markdownEnumDescriptions: [
      "",
      b("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
      ""
    ],
    markdownDescription: b("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
  })),
  accessibilitySupport: he(new fne()),
  accessibilityPageSize: he(new oi(3, "accessibilityPageSize", 10, 1, 1073741824, {
    description: b("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default.")
  })),
  ariaLabel: he(new yo(4, "ariaLabel", b("editorViewAccessibleLabel", "Editor content"))),
  autoClosingBrackets: he(new ln(5, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      b("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
      b("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
      ""
    ],
    description: b("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
  })),
  autoClosingDelete: he(new ln(6, "autoClosingDelete", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      b("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: b("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
  })),
  autoClosingOvertype: he(new ln(7, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      b("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: b("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
  })),
  autoClosingQuotes: he(new ln(8, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      b("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
      b("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
      ""
    ],
    description: b("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
  })),
  autoIndent: he(new Pm(9, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], dne, {
    enumDescriptions: [
      b("editor.autoIndent.none", "The editor will not insert indentation automatically."),
      b("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
      b("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
      b("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
      b("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
    ],
    description: b("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
  })),
  automaticLayout: he(new ct(10, "automaticLayout", !1)),
  autoSurround: he(new ln(11, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
    enumDescriptions: [
      b("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
      b("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
      b("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
      ""
    ],
    description: b("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
  })),
  stickyTabStops: he(new ct(102, "stickyTabStops", !1, { description: b("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
  codeLens: he(new ct(12, "codeLens", !0, { description: b("codeLens", "Controls whether the editor shows CodeLens.") })),
  codeLensFontFamily: he(new yo(13, "codeLensFontFamily", "", { description: b("codeLensFontFamily", "Controls the font family for CodeLens.") })),
  codeLensFontSize: he(new oi(14, "codeLensFontSize", 0, 0, 100, {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 100,
    description: b("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to `0`, the 90% of `#editor.fontSize#` is used.")
  })),
  colorDecorators: he(new ct(15, "colorDecorators", !0, { description: b("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.") })),
  columnSelection: he(new ct(16, "columnSelection", !1, { description: b("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.") })),
  comments: he(new pne()),
  contextmenu: he(new ct(18, "contextmenu", !0)),
  copyWithSyntaxHighlighting: he(new ct(19, "copyWithSyntaxHighlighting", !0, { description: b("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.") })),
  cursorBlinking: he(new Pm(20, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], gne, { description: b("cursorBlinking", "Control the cursor animation style.") })),
  cursorSmoothCaretAnimation: he(new ct(21, "cursorSmoothCaretAnimation", !1, { description: b("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.") })),
  cursorStyle: he(new Pm(22, "cursorStyle", Vn.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], mne, { description: b("cursorStyle", "Controls the cursor style.") })),
  cursorSurroundingLines: he(new oi(23, "cursorSurroundingLines", 0, 0, 1073741824, { description: b("cursorSurroundingLines", "Controls the minimal number of visible leading and trailing lines surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
  cursorSurroundingLinesStyle: he(new ln(24, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
    enumDescriptions: [
      b("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
      b("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
    ],
    description: b("cursorSurroundingLinesStyle", "Controls when `cursorSurroundingLines` should be enforced.")
  })),
  cursorWidth: he(new oi(25, "cursorWidth", 0, 0, 1073741824, { markdownDescription: b("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
  disableLayerHinting: he(new ct(26, "disableLayerHinting", !1)),
  disableMonospaceOptimizations: he(new ct(27, "disableMonospaceOptimizations", !1)),
  domReadOnly: he(new ct(28, "domReadOnly", !1)),
  dragAndDrop: he(new ct(29, "dragAndDrop", !0, { description: b("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.") })),
  emptySelectionClipboard: he(new _ne()),
  extraEditorClassName: he(new yo(31, "extraEditorClassName", "")),
  fastScrollSensitivity: he(new Kc(32, "fastScrollSensitivity", 5, (n) => n <= 0 ? 5 : n, { markdownDescription: b("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.") })),
  find: he(new Cne()),
  fixedOverflowWidgets: he(new ct(34, "fixedOverflowWidgets", !1)),
  folding: he(new ct(35, "folding", !0, { description: b("folding", "Controls whether the editor has code folding enabled.") })),
  foldingStrategy: he(new ln(36, "foldingStrategy", "auto", ["auto", "indentation"], {
    enumDescriptions: [
      b("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
      b("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
    ],
    description: b("foldingStrategy", "Controls the strategy for computing folding ranges.")
  })),
  foldingHighlight: he(new ct(37, "foldingHighlight", !0, { description: b("foldingHighlight", "Controls whether the editor should highlight folded ranges.") })),
  unfoldOnClickAfterEndOfLine: he(new ct(38, "unfoldOnClickAfterEndOfLine", !1, { description: b("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
  fontFamily: he(new yo(39, "fontFamily", Ts.fontFamily, { description: b("fontFamily", "Controls the font family.") })),
  fontInfo: he(new yne()),
  fontLigatures2: he(new vs()),
  fontSize: he(new wne()),
  fontWeight: he(new kl()),
  formatOnPaste: he(new ct(44, "formatOnPaste", !1, { description: b("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
  formatOnType: he(new ct(45, "formatOnType", !1, { description: b("formatOnType", "Controls whether the editor should automatically format the line after typing.") })),
  glyphMargin: he(new ct(46, "glyphMargin", !0, { description: b("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
  gotoLocation: he(new bne()),
  hideCursorInOverviewRuler: he(new ct(48, "hideCursorInOverviewRuler", !1, { description: b("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.") })),
  highlightActiveIndentGuide: he(new ct(49, "highlightActiveIndentGuide", !0, { description: b("highlightActiveIndentGuide", "Controls whether the editor should highlight the active indent guide.") })),
  hover: he(new Sne()),
  inDiffEditor: he(new ct(51, "inDiffEditor", !1)),
  letterSpacing: he(new Kc(53, "letterSpacing", Ts.letterSpacing, (n) => Kc.clamp(n, -5, 20), { description: b("letterSpacing", "Controls the letter spacing in pixels.") })),
  lightbulb: he(new Ene()),
  lineDecorationsWidth: he(new of(55, "lineDecorationsWidth", 10)),
  lineHeight: he(new Dne()),
  lineNumbers: he(new Pne()),
  lineNumbersMinChars: he(new oi(58, "lineNumbersMinChars", 5, 1, 300)),
  linkedEditing: he(new ct(59, "linkedEditing", !1, { description: b("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols, e.g. HTML tags, are updated while editing.") })),
  links: he(new ct(60, "links", !0, { description: b("links", "Controls whether the editor should detect links and make them clickable.") })),
  matchBrackets: he(new ln(61, "matchBrackets", "always", ["always", "near", "never"], { description: b("matchBrackets", "Highlight matching brackets.") })),
  minimap: he(new Rne()),
  mouseStyle: he(new ln(63, "mouseStyle", "text", ["text", "default", "copy"])),
  mouseWheelScrollSensitivity: he(new Kc(64, "mouseWheelScrollSensitivity", 1, (n) => n === 0 ? 1 : n, { markdownDescription: b("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
  mouseWheelZoom: he(new ct(65, "mouseWheelZoom", !1, { markdownDescription: b("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.") })),
  multiCursorMergeOverlapping: he(new ct(66, "multiCursorMergeOverlapping", !0, { description: b("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.") })),
  multiCursorModifier: he(new Pm(67, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], Tne, {
    markdownEnumDescriptions: [
      b("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
      b("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
    ],
    markdownDescription: b({
      key: "multiCursorModifier",
      comment: [
        "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
        "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
      ]
    }, "The modifier to be used to add multiple cursors with the mouse. The Go To Definition and Open Link mouse gestures will adapt such that they do not conflict with the multicursor modifier. [Read more](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
  })),
  multiCursorPaste: he(new ln(68, "multiCursorPaste", "spread", ["spread", "full"], {
    markdownEnumDescriptions: [
      b("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
      b("multiCursorPaste.full", "Each cursor pastes the full text.")
    ],
    markdownDescription: b("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
  })),
  occurrencesHighlight: he(new ct(69, "occurrencesHighlight", !0, { description: b("occurrencesHighlight", "Controls whether the editor should highlight semantic symbol occurrences.") })),
  overviewRulerBorder: he(new ct(70, "overviewRulerBorder", !0, { description: b("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.") })),
  overviewRulerLanes: he(new oi(71, "overviewRulerLanes", 3, 0, 3)),
  padding: he(new One()),
  parameterHints: he(new xne()),
  peekWidgetDefaultFocus: he(new ln(74, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
    enumDescriptions: [
      b("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
      b("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
    ],
    description: b("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
  })),
  definitionLinkOpensInPeek: he(new ct(75, "definitionLinkOpensInPeek", !1, { description: b("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
  quickSuggestions: he(new Ine()),
  quickSuggestionsDelay: he(new oi(77, "quickSuggestionsDelay", 10, 0, 1073741824, { description: b("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.") })),
  readOnly: he(new ct(78, "readOnly", !1)),
  renameOnType: he(new ct(79, "renameOnType", !1, { description: b("renameOnType", "Controls whether the editor auto renames on type."), markdownDeprecationMessage: b("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.") })),
  renderControlCharacters: he(new ct(80, "renderControlCharacters", !1, { description: b("renderControlCharacters", "Controls whether the editor should render control characters.") })),
  renderIndentGuides: he(new ct(81, "renderIndentGuides", !0, { description: b("renderIndentGuides", "Controls whether the editor should render indent guides.") })),
  renderFinalNewline: he(new ct(82, "renderFinalNewline", !0, { description: b("renderFinalNewline", "Render last line number when the file ends with a newline.") })),
  renderLineHighlight: he(new ln(83, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
    enumDescriptions: [
      "",
      "",
      "",
      b("renderLineHighlight.all", "Highlights both the gutter and the current line.")
    ],
    description: b("renderLineHighlight", "Controls how the editor should render the current line highlight.")
  })),
  renderLineHighlightOnlyWhenFocus: he(new ct(84, "renderLineHighlightOnlyWhenFocus", !1, { description: b("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.") })),
  renderValidationDecorations: he(new ln(85, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
  renderWhitespace: he(new ln(86, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
    enumDescriptions: [
      "",
      b("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
      b("renderWhitespace.selection", "Render whitespace characters only on selected text."),
      b("renderWhitespace.trailing", "Render only trailing whitespace characters."),
      ""
    ],
    description: b("renderWhitespace", "Controls how the editor should render whitespace characters.")
  })),
  revealHorizontalRightPadding: he(new oi(87, "revealHorizontalRightPadding", 30, 0, 1e3)),
  roundedSelection: he(new ct(88, "roundedSelection", !0, { description: b("roundedSelection", "Controls whether selections should have rounded corners.") })),
  rulers: he(new Ane()),
  scrollbar: he(new Mne()),
  scrollBeyondLastColumn: he(new oi(91, "scrollBeyondLastColumn", 5, 0, 1073741824, { description: b("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
  scrollBeyondLastLine: he(new ct(92, "scrollBeyondLastLine", !0, { description: b("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.") })),
  scrollPredominantAxis: he(new ct(93, "scrollPredominantAxis", !0, { description: b("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
  selectionClipboard: he(new ct(94, "selectionClipboard", !0, {
    description: b("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
    included: Is
  })),
  selectionHighlight: he(new ct(95, "selectionHighlight", !0, { description: b("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.") })),
  selectOnLineNumbers: he(new ct(96, "selectOnLineNumbers", !0)),
  showFoldingControls: he(new ln(97, "showFoldingControls", "mouseover", ["always", "mouseover"], {
    enumDescriptions: [
      b("showFoldingControls.always", "Always show the folding controls."),
      b("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
    ],
    description: b("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
  })),
  showUnused: he(new ct(98, "showUnused", !0, { description: b("showUnused", "Controls fading out of unused code.") })),
  showDeprecated: he(new ct(123, "showDeprecated", !0, { description: b("showDeprecated", "Controls strikethrough deprecated variables.") })),
  inlayHints: he(new Lne()),
  snippetSuggestions: he(new ln(99, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
    enumDescriptions: [
      b("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
      b("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
      b("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
      b("snippetSuggestions.none", "Do not show snippet suggestions.")
    ],
    description: b("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
  })),
  smartSelect: he(new Wne()),
  smoothScrolling: he(new ct(101, "smoothScrolling", !1, { description: b("smoothScrolling", "Controls whether the editor will scroll using an animation.") })),
  stopRenderingLineAfter: he(new oi(
    103,
    "stopRenderingLineAfter",
    1e4,
    -1,
    1073741824
    /* MAX_SAFE_SMALL_INTEGER */
  )),
  suggest: he(new kne()),
  inlineSuggest: he(new Fne()),
  suggestFontSize: he(new oi(105, "suggestFontSize", 0, 0, 1e3, { markdownDescription: b("suggestFontSize", "Font size for the suggest widget. When set to `0`, the value of `#editor.fontSize#` is used.") })),
  suggestLineHeight: he(new oi(106, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: b("suggestLineHeight", "Line height for the suggest widget. When set to `0`, the value of `#editor.lineHeight#` is used. The minimum value is 8.") })),
  suggestOnTriggerCharacters: he(new ct(107, "suggestOnTriggerCharacters", !0, { description: b("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.") })),
  suggestSelection: he(new ln(108, "suggestSelection", "recentlyUsed", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
    markdownEnumDescriptions: [
      b("suggestSelection.first", "Always select the first suggestion."),
      b("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
      b("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
    ],
    description: b("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
  })),
  tabCompletion: he(new ln(109, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
    enumDescriptions: [
      b("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
      b("tabCompletion.off", "Disable tab completions."),
      b("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
    ],
    description: b("tabCompletion", "Enables tab completions.")
  })),
  tabIndex: he(new oi(
    110,
    "tabIndex",
    0,
    -1,
    1073741824
    /* MAX_SAFE_SMALL_INTEGER */
  )),
  unusualLineTerminators: he(new ln(111, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
    enumDescriptions: [
      b("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
      b("unusualLineTerminators.off", "Unusual line terminators are ignored."),
      b("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
    ],
    description: b("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
  })),
  useShadowDOM: he(new ct(112, "useShadowDOM", !0)),
  useTabStops: he(new ct(113, "useTabStops", !0, { description: b("useTabStops", "Inserting and deleting whitespace follows tab stops.") })),
  wordSeparators: he(new yo(114, "wordSeparators", MG, { description: b("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.") })),
  wordWrap: he(new ln(115, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
    markdownEnumDescriptions: [
      b("wordWrap.off", "Lines will never wrap."),
      b("wordWrap.on", "Lines will wrap at the viewport width."),
      b({
        key: "wordWrap.wordWrapColumn",
        comment: [
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at `#editor.wordWrapColumn#`."),
      b({
        key: "wordWrap.bounded",
        comment: [
          "- viewport means the edge of the visible window size.",
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
    ],
    description: b({
      key: "wordWrap",
      comment: [
        "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
        "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
      ]
    }, "Controls how lines should wrap.")
  })),
  wordWrapBreakAfterCharacters: he(new yo(116, "wordWrapBreakAfterCharacters", " 	})]?|/&.,;")),
  wordWrapBreakBeforeCharacters: he(new yo(117, "wordWrapBreakBeforeCharacters", "([{+")),
  wordWrapColumn: he(new oi(118, "wordWrapColumn", 80, 1, 1073741824, {
    markdownDescription: b({
      key: "wordWrapColumn",
      comment: [
        "- `editor.wordWrap` refers to a different setting and should not be localized.",
        "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
      ]
    }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
  })),
  wordWrapOverride1: he(new ln(119, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
  wordWrapOverride2: he(new ln(120, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
  wrappingIndent: he(new Pm(121, "wrappingIndent", 1, "same", ["none", "same", "indent", "deepIndent"], Bne, {
    enumDescriptions: [
      b("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
      b("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
      b("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
      b("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
    ],
    description: b("wrappingIndent", "Controls the indentation of wrapped lines.")
  })),
  wrappingStrategy: he(new ln(122, "wrappingStrategy", "simple", ["simple", "advanced"], {
    enumDescriptions: [
      b("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
      b("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
    ],
    description: b("wrappingStrategy", "Controls the algorithm that computes wrapping points.")
  })),
  // Leave these at the end (because they have dependencies!)
  editorClassName: he(new vne()),
  pixelRatio: he(new Nne()),
  tabFocusMode: he(new Vne()),
  layoutInfo: he(new wp()),
  wrappingInfo: he(new Hne())
};
class jne {
  constructor() {
    this.listeners = [], this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        throw e.stack ? new Error(e.message + `

` + e.stack) : e;
      }, 0);
    };
  }
  emit(e) {
    this.listeners.forEach((t) => {
      t(e);
    });
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e), this.emit(e);
  }
  // For external errors, we don't want the listeners to be called
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
}
const VG = new jne();
function Pi(n) {
  W_(n) || VG.onUnexpectedError(n);
}
function k_(n) {
  W_(n) || VG.onUnexpectedExternalError(n);
}
function XF(n) {
  if (n instanceof Error) {
    let { name: e, message: t } = n;
    const i = n.stacktrace || n.stack;
    return {
      $isError: !0,
      name: e,
      message: t,
      stack: i
    };
  }
  return n;
}
const gR = "Canceled";
function W_(n) {
  return n instanceof Error && n.name === gR && n.message === gR;
}
function ZS() {
  const n = new Error(gR);
  return n.name = n.message, n;
}
function V_(n) {
  return n ? new Error(`Illegal argument: ${n}`) : new Error("Illegal argument");
}
function $ne(n) {
  return n ? new Error(`Illegal state: ${n}`) : new Error("Illegal state");
}
var Ct;
(function(n) {
  function e(v) {
    return v && typeof v == "object" && typeof v[Symbol.iterator] == "function";
  }
  n.is = e;
  const t = Object.freeze([]);
  function i() {
    return t;
  }
  n.empty = i;
  function* r(v) {
    yield v;
  }
  n.single = r;
  function o(v) {
    return v || t;
  }
  n.from = o;
  function s(v) {
    return !v || v[Symbol.iterator]().next().done === !0;
  }
  n.isEmpty = s;
  function a(v) {
    return v[Symbol.iterator]().next().value;
  }
  n.first = a;
  function l(v, C) {
    for (const y of v)
      if (C(y))
        return !0;
    return !1;
  }
  n.some = l;
  function u(v, C) {
    for (const y of v)
      if (C(y))
        return y;
  }
  n.find = u;
  function* c(v, C) {
    for (const y of v)
      C(y) && (yield y);
  }
  n.filter = c;
  function* h(v, C) {
    let y = 0;
    for (const w of v)
      yield C(w, y++);
  }
  n.map = h;
  function* d(...v) {
    for (const C of v)
      for (const y of C)
        yield y;
  }
  n.concat = d;
  function* f(v) {
    for (const C of v)
      for (const y of C)
        yield y;
  }
  n.concatNested = f;
  function p(v, C, y) {
    let w = y;
    for (const L of v)
      w = C(w, L);
    return w;
  }
  n.reduce = p;
  function* g(v, C, y = v.length) {
    for (C < 0 && (C += v.length), y < 0 ? y += v.length : y > v.length && (y = v.length); C < y; C++)
      yield v[C];
  }
  n.slice = g;
  function _(v, C = Number.POSITIVE_INFINITY) {
    const y = [];
    if (C === 0)
      return [y, v];
    const w = v[Symbol.iterator]();
    for (let L = 0; L < C; L++) {
      const S = w.next();
      if (S.done)
        return [y, n.empty()];
      y.push(S.value);
    }
    return [y, { [Symbol.iterator]() {
      return w;
    } }];
  }
  n.consume = _;
  function m(v, C, y = (w, L) => w === L) {
    const w = v[Symbol.iterator](), L = C[Symbol.iterator]();
    for (; ; ) {
      const S = w.next(), E = L.next();
      if (S.done !== E.done)
        return !1;
      if (S.done)
        return !0;
      if (!y(S.value, E.value))
        return !1;
    }
  }
  n.equals = m;
})(Ct || (Ct = {}));
function Kne(n) {
}
class qne extends Error {
  constructor(e) {
    super(`Encountered errors while disposing of store. Errors: [${e.join(", ")}]`), this.errors = e;
  }
}
function Yne(n) {
  return typeof n.dispose == "function" && n.dispose.length === 0;
}
function bi(n) {
  if (Ct.is(n)) {
    let e = [];
    for (const t of n)
      if (t)
        try {
          t.dispose();
        } catch (i) {
          e.push(i);
        }
    if (e.length === 1)
      throw e[0];
    if (e.length > 1)
      throw new qne(e);
    return Array.isArray(n) ? [] : n;
  } else if (n)
    return n.dispose(), n;
}
function bp(...n) {
  return n.forEach(Kne), Oi(() => bi(n));
}
function Oi(n) {
  return {
    dispose: () => {
      n();
    }
  };
}
class dt {
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set(), this._isDisposed = !1;
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this.clear());
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    try {
      bi(this._toDispose.values());
    } finally {
      this._toDispose.clear();
    }
  }
  add(e) {
    if (!e)
      return e;
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._isDisposed ? dt.DISABLE_DISPOSED_WARNING || console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this._toDispose.add(e), e;
  }
}
dt.DISABLE_DISPOSED_WARNING = !1;
class Ce {
  constructor() {
    this._store = new dt();
  }
  dispose() {
    this._store.dispose();
  }
  _register(e) {
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._store.add(e);
  }
}
Ce.None = Object.freeze({ dispose() {
} });
class Xne {
  constructor() {
    this._isDisposed = !1;
  }
  get value() {
    return this._isDisposed ? void 0 : this._value;
  }
  set value(e) {
    var t;
    this._isDisposed || e === this._value || ((t = this._value) === null || t === void 0 || t.dispose(), this._value = e);
  }
  clear() {
    this.value = void 0;
  }
  dispose() {
    var e;
    this._isDisposed = !0, (e = this._value) === null || e === void 0 || e.dispose(), this._value = void 0;
  }
}
class Zne {
  constructor(e) {
    this.object = e;
  }
  dispose() {
  }
}
let on = class mR {
  constructor(e) {
    this.element = e, this.next = mR.Undefined, this.prev = mR.Undefined;
  }
};
on.Undefined = new on(void 0);
class fa {
  constructor() {
    this._first = on.Undefined, this._last = on.Undefined, this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === on.Undefined;
  }
  clear() {
    let e = this._first;
    for (; e !== on.Undefined; ) {
      const t = e.next;
      e.prev = on.Undefined, e.next = on.Undefined, e = t;
    }
    this._first = on.Undefined, this._last = on.Undefined, this._size = 0;
  }
  unshift(e) {
    return this._insert(e, !1);
  }
  push(e) {
    return this._insert(e, !0);
  }
  _insert(e, t) {
    const i = new on(e);
    if (this._first === on.Undefined)
      this._first = i, this._last = i;
    else if (t) {
      const o = this._last;
      this._last = i, i.prev = o, o.next = i;
    } else {
      const o = this._first;
      this._first = i, i.next = o, o.prev = i;
    }
    this._size += 1;
    let r = !1;
    return () => {
      r || (r = !0, this._remove(i));
    };
  }
  shift() {
    if (this._first !== on.Undefined) {
      const e = this._first.element;
      return this._remove(this._first), e;
    }
  }
  pop() {
    if (this._last !== on.Undefined) {
      const e = this._last.element;
      return this._remove(this._last), e;
    }
  }
  _remove(e) {
    if (e.prev !== on.Undefined && e.next !== on.Undefined) {
      const t = e.prev;
      t.next = e.next, e.next.prev = t;
    } else
      e.prev === on.Undefined && e.next === on.Undefined ? (this._first = on.Undefined, this._last = on.Undefined) : e.next === on.Undefined ? (this._last = this._last.prev, this._last.next = on.Undefined) : e.prev === on.Undefined && (this._first = this._first.next, this._first.prev = on.Undefined);
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let e = this._first;
    for (; e !== on.Undefined; )
      yield e.element, e = e.next;
  }
}
const Qne = vn.performance && typeof vn.performance.now == "function";
class xg {
  constructor(e) {
    this._highResolution = Qne && e, this._startTime = this._now(), this._stopTime = -1;
  }
  static create(e = !0) {
    return new xg(e);
  }
  stop() {
    this._stopTime = this._now();
  }
  elapsed() {
    return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
  }
  _now() {
    return this._highResolution ? vn.performance.now() : Date.now();
  }
}
var We;
(function(n) {
  n.None = () => Ce.None;
  function e(y) {
    return (w, L = null, S) => {
      let E = !1, D;
      return D = y((x) => {
        if (!E)
          return D ? D.dispose() : E = !0, w.call(L, x);
      }, null, S), E && D.dispose(), D;
    };
  }
  n.once = e;
  function t(y, w) {
    return l((L, S = null, E) => y((D) => L.call(S, w(D)), null, E));
  }
  n.map = t;
  function i(y, w) {
    return l((L, S = null, E) => y((D) => {
      w(D), L.call(S, D);
    }, null, E));
  }
  n.forEach = i;
  function r(y, w) {
    return l((L, S = null, E) => y((D) => w(D) && L.call(S, D), null, E));
  }
  n.filter = r;
  function o(y) {
    return y;
  }
  n.signal = o;
  function s(...y) {
    return (w, L = null, S) => bp(...y.map((E) => E((D) => w.call(L, D), null, S)));
  }
  n.any = s;
  function a(y, w, L) {
    let S = L;
    return t(y, (E) => (S = w(S, E), S));
  }
  n.reduce = a;
  function l(y) {
    let w;
    const L = new q({
      onFirstListenerAdd() {
        w = y(L.fire, L);
      },
      onLastListenerRemove() {
        w.dispose();
      }
    });
    return L.event;
  }
  n.snapshot = l;
  function u(y, w, L = 100, S = !1, E) {
    let D, x, R, A = 0;
    const M = new q({
      leakWarningThreshold: E,
      onFirstListenerAdd() {
        D = y((z) => {
          A++, x = w(x, z), S && !R && (M.fire(x), x = void 0), clearTimeout(R), R = setTimeout(() => {
            const j = x;
            x = void 0, R = void 0, (!S || A > 1) && M.fire(j), A = 0;
          }, L);
        });
      },
      onLastListenerRemove() {
        D.dispose();
      }
    });
    return M.event;
  }
  n.debounce = u;
  function c(y) {
    const w = (/* @__PURE__ */ new Date()).getTime();
    return t(e(y), (L) => (/* @__PURE__ */ new Date()).getTime() - w);
  }
  n.stopwatch = c;
  function h(y, w = (L, S) => L === S) {
    let L = !0, S;
    return r(y, (E) => {
      const D = L || !w(E, S);
      return L = !1, S = E, D;
    });
  }
  n.latch = h;
  function d(y, w) {
    return [
      n.filter(y, w),
      n.filter(y, (L) => !w(L))
    ];
  }
  n.split = d;
  function f(y, w = !1, L = []) {
    let S = L.slice(), E = y((R) => {
      S ? S.push(R) : x.fire(R);
    });
    const D = () => {
      S && S.forEach((R) => x.fire(R)), S = null;
    }, x = new q({
      onFirstListenerAdd() {
        E || (E = y((R) => x.fire(R)));
      },
      onFirstListenerDidAdd() {
        S && (w ? setTimeout(D) : D());
      },
      onLastListenerRemove() {
        E && E.dispose(), E = null;
      }
    });
    return x.event;
  }
  n.buffer = f;
  class p {
    constructor(w) {
      this.event = w;
    }
    map(w) {
      return new p(t(this.event, w));
    }
    forEach(w) {
      return new p(i(this.event, w));
    }
    filter(w) {
      return new p(r(this.event, w));
    }
    reduce(w, L) {
      return new p(a(this.event, w, L));
    }
    latch() {
      return new p(h(this.event));
    }
    debounce(w, L = 100, S = !1, E) {
      return new p(u(this.event, w, L, S, E));
    }
    on(w, L, S) {
      return this.event(w, L, S);
    }
    once(w, L, S) {
      return e(this.event)(w, L, S);
    }
  }
  function g(y) {
    return new p(y);
  }
  n.chain = g;
  function _(y, w, L = (S) => S) {
    const S = (...R) => x.fire(L(...R)), E = () => y.on(w, S), D = () => y.removeListener(w, S), x = new q({ onFirstListenerAdd: E, onLastListenerRemove: D });
    return x.event;
  }
  n.fromNodeEventEmitter = _;
  function m(y, w, L = (S) => S) {
    const S = (...R) => x.fire(L(...R)), E = () => y.addEventListener(w, S), D = () => y.removeEventListener(w, S), x = new q({ onFirstListenerAdd: E, onLastListenerRemove: D });
    return x.event;
  }
  n.fromDOMEventEmitter = m;
  function v(y) {
    const w = new q();
    let L = !1;
    return y.then(void 0, () => null).then(() => {
      L ? w.fire(void 0) : setTimeout(() => w.fire(void 0), 0);
    }), L = !0, w.event;
  }
  n.fromPromise = v;
  function C(y) {
    return new Promise((w) => e(y)(w));
  }
  n.toPromise = C;
})(We || (We = {}));
class QS {
  constructor(e) {
    this._listenerCount = 0, this._invocationCount = 0, this._elapsedOverall = 0, this._name = `${e}_${QS._idPool++}`;
  }
  start(e) {
    this._stopWatch = new xg(!0), this._listenerCount = e;
  }
  stop() {
    if (this._stopWatch) {
      const e = this._stopWatch.elapsed();
      this._elapsedOverall += e, this._invocationCount += 1, console.info(`did FIRE ${this._name}: elapsed_ms: ${e.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`), this._stopWatch = void 0;
    }
  }
}
QS._idPool = 0;
let q = class BG {
  constructor(e) {
    var t;
    this._disposed = !1, this._options = e, this._leakageMon = void 0, this._perfMon = !((t = this._options) === null || t === void 0) && t._profName ? new QS(this._options._profName) : void 0;
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    return this._event || (this._event = (e, t, i) => {
      var r;
      this._listeners || (this._listeners = new fa());
      const o = this._listeners.isEmpty();
      o && this._options && this._options.onFirstListenerAdd && this._options.onFirstListenerAdd(this);
      const s = this._listeners.push(t ? [e, t] : e);
      o && this._options && this._options.onFirstListenerDidAdd && this._options.onFirstListenerDidAdd(this), this._options && this._options.onListenerDidAdd && this._options.onListenerDidAdd(this, e, t);
      const a = (r = this._leakageMon) === null || r === void 0 ? void 0 : r.check(this._listeners.size);
      let l;
      return l = {
        dispose: () => {
          a && a(), l.dispose = BG._noop, this._disposed || (s(), this._options && this._options.onLastListenerRemove && (this._listeners && !this._listeners.isEmpty() || this._options.onLastListenerRemove(this)));
        }
      }, i instanceof dt ? i.add(l) : Array.isArray(i) && i.push(l), l;
    }), this._event;
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(e) {
    var t, i;
    if (this._listeners) {
      this._deliveryQueue || (this._deliveryQueue = new fa());
      for (let r of this._listeners)
        this._deliveryQueue.push([r, e]);
      for ((t = this._perfMon) === null || t === void 0 || t.start(this._deliveryQueue.size); this._deliveryQueue.size > 0; ) {
        const [r, o] = this._deliveryQueue.shift();
        try {
          typeof r == "function" ? r.call(void 0, o) : r[0].call(r[1], o);
        } catch (s) {
          Pi(s);
        }
      }
      (i = this._perfMon) === null || i === void 0 || i.stop();
    }
  }
  dispose() {
    var e, t, i, r, o;
    this._disposed || (this._disposed = !0, (e = this._listeners) === null || e === void 0 || e.clear(), (t = this._deliveryQueue) === null || t === void 0 || t.clear(), (r = (i = this._options) === null || i === void 0 ? void 0 : i.onLastListenerRemove) === null || r === void 0 || r.call(i), (o = this._leakageMon) === null || o === void 0 || o.dispose());
  }
};
q._noop = function() {
};
class vR extends q {
  constructor(e) {
    super(e), this._isPaused = 0, this._eventQueue = new fa(), this._mergeFn = e == null ? void 0 : e.merge;
  }
  pause() {
    this._isPaused++;
  }
  resume() {
    if (this._isPaused !== 0 && --this._isPaused === 0)
      if (this._mergeFn) {
        const e = Array.from(this._eventQueue);
        this._eventQueue.clear(), super.fire(this._mergeFn(e));
      } else
        for (; !this._isPaused && this._eventQueue.size !== 0; )
          super.fire(this._eventQueue.shift());
  }
  fire(e) {
    this._listeners && (this._isPaused !== 0 ? this._eventQueue.push(e) : super.fire(e));
  }
}
class ON {
  constructor() {
    this.buffers = [];
  }
  wrapEvent(e) {
    return (t, i, r) => e((o) => {
      const s = this.buffers[this.buffers.length - 1];
      s ? s.push(() => t.call(i, o)) : t.call(i, o);
    }, void 0, r);
  }
  bufferEvents(e) {
    const t = [];
    this.buffers.push(t);
    const i = e();
    return this.buffers.pop(), t.forEach((r) => r()), i;
  }
}
class ZF {
  constructor() {
    this.listening = !1, this.inputEvent = We.None, this.inputEventListener = Ce.None, this.emitter = new q({
      onFirstListenerDidAdd: () => {
        this.listening = !0, this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
      },
      onLastListenerRemove: () => {
        this.listening = !1, this.inputEventListener.dispose();
      }
    }), this.event = this.emitter.event;
  }
  set input(e) {
    this.inputEvent = e, this.listening && (this.inputEventListener.dispose(), this.inputEventListener = e(this.emitter.fire, this.emitter));
  }
  dispose() {
    this.inputEventListener.dispose(), this.emitter.dispose();
  }
}
const HG = Object.freeze(function(n, e) {
  const t = setTimeout(n.bind(e), 0);
  return { dispose() {
    clearTimeout(t);
  } };
});
var Ko;
(function(n) {
  function e(t) {
    return t === n.None || t === n.Cancelled || t instanceof nw ? !0 : !t || typeof t != "object" ? !1 : typeof t.isCancellationRequested == "boolean" && typeof t.onCancellationRequested == "function";
  }
  n.isCancellationToken = e, n.None = Object.freeze({
    isCancellationRequested: !1,
    onCancellationRequested: We.None
  }), n.Cancelled = Object.freeze({
    isCancellationRequested: !0,
    onCancellationRequested: HG
  });
})(Ko || (Ko = {}));
class nw {
  constructor() {
    this._isCancelled = !1, this._emitter = null;
  }
  cancel() {
    this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    return this._isCancelled ? HG : (this._emitter || (this._emitter = new q()), this._emitter.event);
  }
  dispose() {
    this._emitter && (this._emitter.dispose(), this._emitter = null);
  }
}
let mh = class {
  constructor(e) {
    this._token = void 0, this._parentListener = void 0, this._parentListener = e && e.onCancellationRequested(this.cancel, this);
  }
  get token() {
    return this._token || (this._token = new nw()), this._token;
  }
  cancel() {
    this._token ? this._token instanceof nw && this._token.cancel() : this._token = Ko.Cancelled;
  }
  dispose(e = !1) {
    e && this.cancel(), this._parentListener && this._parentListener.dispose(), this._token ? this._token instanceof nw && this._token.dispose() : this._token = Ko.None;
  }
};
class xN {
  constructor() {
    this._keyCodeToStr = [], this._strToKeyCode = /* @__PURE__ */ Object.create(null);
  }
  define(e, t) {
    this._keyCodeToStr[e] = t, this._strToKeyCode[t.toLowerCase()] = e;
  }
  keyCodeToStr(e) {
    return this._keyCodeToStr[e];
  }
  strToKeyCode(e) {
    return this._strToKeyCode[e.toLowerCase()] || 0;
  }
}
const _R = new xN(), CR = new xN(), yR = new xN();
(function() {
  function n(e, t, i = t, r = i) {
    _R.define(e, t), CR.define(e, i), yR.define(e, r);
  }
  n(0, "unknown"), n(1, "Backspace"), n(2, "Tab"), n(3, "Enter"), n(4, "Shift"), n(5, "Ctrl"), n(6, "Alt"), n(7, "PauseBreak"), n(8, "CapsLock"), n(9, "Escape"), n(10, "Space"), n(11, "PageUp"), n(12, "PageDown"), n(13, "End"), n(14, "Home"), n(15, "LeftArrow", "Left"), n(16, "UpArrow", "Up"), n(17, "RightArrow", "Right"), n(18, "DownArrow", "Down"), n(19, "Insert"), n(20, "Delete"), n(21, "0"), n(22, "1"), n(23, "2"), n(24, "3"), n(25, "4"), n(26, "5"), n(27, "6"), n(28, "7"), n(29, "8"), n(30, "9"), n(31, "A"), n(32, "B"), n(33, "C"), n(34, "D"), n(35, "E"), n(36, "F"), n(37, "G"), n(38, "H"), n(39, "I"), n(40, "J"), n(41, "K"), n(42, "L"), n(43, "M"), n(44, "N"), n(45, "O"), n(46, "P"), n(47, "Q"), n(48, "R"), n(49, "S"), n(50, "T"), n(51, "U"), n(52, "V"), n(53, "W"), n(54, "X"), n(55, "Y"), n(56, "Z"), n(57, "Meta"), n(58, "ContextMenu"), n(59, "F1"), n(60, "F2"), n(61, "F3"), n(62, "F4"), n(63, "F5"), n(64, "F6"), n(65, "F7"), n(66, "F8"), n(67, "F9"), n(68, "F10"), n(69, "F11"), n(70, "F12"), n(71, "F13"), n(72, "F14"), n(73, "F15"), n(74, "F16"), n(75, "F17"), n(76, "F18"), n(77, "F19"), n(78, "NumLock"), n(79, "ScrollLock"), n(80, ";", ";", "OEM_1"), n(81, "=", "=", "OEM_PLUS"), n(82, ",", ",", "OEM_COMMA"), n(83, "-", "-", "OEM_MINUS"), n(84, ".", ".", "OEM_PERIOD"), n(85, "/", "/", "OEM_2"), n(86, "`", "`", "OEM_3"), n(110, "ABNT_C1"), n(111, "ABNT_C2"), n(87, "[", "[", "OEM_4"), n(88, "\\", "\\", "OEM_5"), n(89, "]", "]", "OEM_6"), n(90, "'", "'", "OEM_7"), n(91, "OEM_8"), n(92, "OEM_102"), n(93, "NumPad0"), n(94, "NumPad1"), n(95, "NumPad2"), n(96, "NumPad3"), n(97, "NumPad4"), n(98, "NumPad5"), n(99, "NumPad6"), n(100, "NumPad7"), n(101, "NumPad8"), n(102, "NumPad9"), n(103, "NumPad_Multiply"), n(104, "NumPad_Add"), n(105, "NumPad_Separator"), n(106, "NumPad_Subtract"), n(107, "NumPad_Decimal"), n(108, "NumPad_Divide");
})();
var Sp;
(function(n) {
  function e(s) {
    return _R.keyCodeToStr(s);
  }
  n.toString = e;
  function t(s) {
    return _R.strToKeyCode(s);
  }
  n.fromString = t;
  function i(s) {
    return CR.keyCodeToStr(s);
  }
  n.toUserSettingsUS = i;
  function r(s) {
    return yR.keyCodeToStr(s);
  }
  n.toUserSettingsGeneral = r;
  function o(s) {
    return CR.strToKeyCode(s) || yR.strToKeyCode(s);
  }
  n.fromUserSettings = o;
})(Sp || (Sp = {}));
function Jne(n, e) {
  const t = (e & 65535) << 16 >>> 0;
  return (n | t) >>> 0;
}
function wR(n, e) {
  if (n === 0)
    return null;
  const t = (n & 65535) >>> 0, i = (n & 4294901760) >>> 16;
  return i !== 0 ? new bR([
    oD(t, e),
    oD(i, e)
  ]) : new bR([oD(t, e)]);
}
function oD(n, e) {
  const t = !!(n & 2048), i = !!(n & 256), r = e === 2 ? i : t, o = !!(n & 1024), s = !!(n & 512), a = e === 2 ? t : i, l = n & 255;
  return new NN(r, o, s, a, l);
}
class NN {
  constructor(e, t, i, r, o) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = r, this.keyCode = o;
  }
  equals(e) {
    return this.ctrlKey === e.ctrlKey && this.shiftKey === e.shiftKey && this.altKey === e.altKey && this.metaKey === e.metaKey && this.keyCode === e.keyCode;
  }
  isModifierKey() {
    return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
  }
  toChord() {
    return new bR([this]);
  }
  /**
   * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
   */
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
  }
}
class bR {
  constructor(e) {
    if (e.length === 0)
      throw V_("parts");
    this.parts = e;
  }
}
class ere {
  constructor(e, t, i, r, o, s) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = r, this.keyLabel = o, this.keyAriaLabel = s;
  }
}
class tre {
}
let Ep;
if (typeof vn.vscode < "u" && typeof vn.vscode.process < "u") {
  const n = vn.vscode.process;
  Ep = {
    get platform() {
      return n.platform;
    },
    get env() {
      return n.env;
    },
    cwd() {
      return n.cwd();
    },
    nextTick(e) {
      return ab(e);
    }
  };
} else
  typeof process < "u" ? Ep = {
    get platform() {
      return process.platform;
    },
    get env() {
      return process.env;
    },
    cwd() {
      return process.env.VSCODE_CWD || process.cwd();
    },
    nextTick(n) {
      return process.nextTick(n);
    }
  } : Ep = {
    // Supported
    get platform() {
      return Ro ? "win32" : kt ? "darwin" : "linux";
    },
    nextTick(n) {
      return ab(n);
    },
    // Unsupported
    get env() {
      return {};
    },
    cwd() {
      return "/";
    }
  };
const SR = Ep.cwd, ire = Ep.env, af = Ep.platform, nre = 65, rre = 97, ore = 90, sre = 122, Jc = 46, Lr = 47, ko = 92, Rc = 58, are = 63;
class GG extends Error {
  constructor(e, t, i) {
    let r;
    typeof t == "string" && t.indexOf("not ") === 0 ? (r = "must not be", t = t.replace(/^not /, "")) : r = "must be";
    const o = e.indexOf(".") !== -1 ? "property" : "argument";
    let s = `The "${e}" ${o} ${r} of type ${t}`;
    s += `. Received type ${typeof i}`, super(s), this.code = "ERR_INVALID_ARG_TYPE";
  }
}
function Tn(n, e) {
  if (typeof n != "string")
    throw new GG(e, "string", n);
}
function Tt(n) {
  return n === Lr || n === ko;
}
function ER(n) {
  return n === Lr;
}
function Tc(n) {
  return n >= nre && n <= ore || n >= rre && n <= sre;
}
function ub(n, e, t, i) {
  let r = "", o = 0, s = -1, a = 0, l = 0;
  for (let u = 0; u <= n.length; ++u) {
    if (u < n.length)
      l = n.charCodeAt(u);
    else {
      if (i(l))
        break;
      l = Lr;
    }
    if (i(l)) {
      if (!(s === u - 1 || a === 1))
        if (a === 2) {
          if (r.length < 2 || o !== 2 || r.charCodeAt(r.length - 1) !== Jc || r.charCodeAt(r.length - 2) !== Jc) {
            if (r.length > 2) {
              const c = r.lastIndexOf(t);
              c === -1 ? (r = "", o = 0) : (r = r.slice(0, c), o = r.length - 1 - r.lastIndexOf(t)), s = u, a = 0;
              continue;
            } else if (r.length !== 0) {
              r = "", o = 0, s = u, a = 0;
              continue;
            }
          }
          e && (r += r.length > 0 ? `${t}..` : "..", o = 2);
        } else
          r.length > 0 ? r += `${t}${n.slice(s + 1, u)}` : r = n.slice(s + 1, u), o = u - s - 1;
      s = u, a = 0;
    } else
      l === Jc && a !== -1 ? ++a : a = -1;
  }
  return r;
}
function UG(n, e) {
  if (e === null || typeof e != "object")
    throw new GG("pathObject", "Object", e);
  const t = e.dir || e.root, i = e.base || `${e.name || ""}${e.ext || ""}`;
  return t ? t === e.root ? `${t}${i}` : `${t}${n}${i}` : i;
}
const Lo = {
  // path.resolve([from ...], to)
  resolve(...n) {
    let e = "", t = "", i = !1;
    for (let r = n.length - 1; r >= -1; r--) {
      let o;
      if (r >= 0) {
        if (o = n[r], Tn(o, "path"), o.length === 0)
          continue;
      } else
        e.length === 0 ? o = SR() : (o = ire[`=${e}`] || SR(), (o === void 0 || o.slice(0, 2).toLowerCase() !== e.toLowerCase() && o.charCodeAt(2) === ko) && (o = `${e}\\`));
      const s = o.length;
      let a = 0, l = "", u = !1;
      const c = o.charCodeAt(0);
      if (s === 1)
        Tt(c) && (a = 1, u = !0);
      else if (Tt(c))
        if (u = !0, Tt(o.charCodeAt(1))) {
          let h = 2, d = h;
          for (; h < s && !Tt(o.charCodeAt(h)); )
            h++;
          if (h < s && h !== d) {
            const f = o.slice(d, h);
            for (d = h; h < s && Tt(o.charCodeAt(h)); )
              h++;
            if (h < s && h !== d) {
              for (d = h; h < s && !Tt(o.charCodeAt(h)); )
                h++;
              (h === s || h !== d) && (l = `\\\\${f}\\${o.slice(d, h)}`, a = h);
            }
          }
        } else
          a = 1;
      else
        Tc(c) && o.charCodeAt(1) === Rc && (l = o.slice(0, 2), a = 2, s > 2 && Tt(o.charCodeAt(2)) && (u = !0, a = 3));
      if (l.length > 0)
        if (e.length > 0) {
          if (l.toLowerCase() !== e.toLowerCase())
            continue;
        } else
          e = l;
      if (i) {
        if (e.length > 0)
          break;
      } else if (t = `${o.slice(a)}\\${t}`, i = u, u && e.length > 0)
        break;
    }
    return t = ub(t, !i, "\\", Tt), i ? `${e}\\${t}` : `${e}${t}` || ".";
  },
  normalize(n) {
    Tn(n, "path");
    const e = n.length;
    if (e === 0)
      return ".";
    let t = 0, i, r = !1;
    const o = n.charCodeAt(0);
    if (e === 1)
      return ER(o) ? "\\" : n;
    if (Tt(o))
      if (r = !0, Tt(n.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !Tt(n.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          const u = n.slice(l, a);
          for (l = a; a < e && Tt(n.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !Tt(n.charCodeAt(a)); )
              a++;
            if (a === e)
              return `\\\\${u}\\${n.slice(l)}\\`;
            a !== l && (i = `\\\\${u}\\${n.slice(l, a)}`, t = a);
          }
        }
      } else
        t = 1;
    else
      Tc(o) && n.charCodeAt(1) === Rc && (i = n.slice(0, 2), t = 2, e > 2 && Tt(n.charCodeAt(2)) && (r = !0, t = 3));
    let s = t < e ? ub(n.slice(t), !r, "\\", Tt) : "";
    return s.length === 0 && !r && (s = "."), s.length > 0 && Tt(n.charCodeAt(e - 1)) && (s += "\\"), i === void 0 ? r ? `\\${s}` : s : r ? `${i}\\${s}` : `${i}${s}`;
  },
  isAbsolute(n) {
    Tn(n, "path");
    const e = n.length;
    if (e === 0)
      return !1;
    const t = n.charCodeAt(0);
    return Tt(t) || // Possible device root
    e > 2 && Tc(t) && n.charCodeAt(1) === Rc && Tt(n.charCodeAt(2));
  },
  join(...n) {
    if (n.length === 0)
      return ".";
    let e, t;
    for (let o = 0; o < n.length; ++o) {
      const s = n[o];
      Tn(s, "path"), s.length > 0 && (e === void 0 ? e = t = s : e += `\\${s}`);
    }
    if (e === void 0)
      return ".";
    let i = !0, r = 0;
    if (typeof t == "string" && Tt(t.charCodeAt(0))) {
      ++r;
      const o = t.length;
      o > 1 && Tt(t.charCodeAt(1)) && (++r, o > 2 && (Tt(t.charCodeAt(2)) ? ++r : i = !1));
    }
    if (i) {
      for (; r < e.length && Tt(e.charCodeAt(r)); )
        r++;
      r >= 2 && (e = `\\${e.slice(r)}`);
    }
    return Lo.normalize(e);
  },
  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(n, e) {
    if (Tn(n, "from"), Tn(e, "to"), n === e)
      return "";
    const t = Lo.resolve(n), i = Lo.resolve(e);
    if (t === i || (n = t.toLowerCase(), e = i.toLowerCase(), n === e))
      return "";
    let r = 0;
    for (; r < n.length && n.charCodeAt(r) === ko; )
      r++;
    let o = n.length;
    for (; o - 1 > r && n.charCodeAt(o - 1) === ko; )
      o--;
    const s = o - r;
    let a = 0;
    for (; a < e.length && e.charCodeAt(a) === ko; )
      a++;
    let l = e.length;
    for (; l - 1 > a && e.charCodeAt(l - 1) === ko; )
      l--;
    const u = l - a, c = s < u ? s : u;
    let h = -1, d = 0;
    for (; d < c; d++) {
      const p = n.charCodeAt(r + d);
      if (p !== e.charCodeAt(a + d))
        break;
      p === ko && (h = d);
    }
    if (d !== c) {
      if (h === -1)
        return i;
    } else {
      if (u > c) {
        if (e.charCodeAt(a + d) === ko)
          return i.slice(a + d + 1);
        if (d === 2)
          return i.slice(a + d);
      }
      s > c && (n.charCodeAt(r + d) === ko ? h = d : d === 2 && (h = 3)), h === -1 && (h = 0);
    }
    let f = "";
    for (d = r + h + 1; d <= o; ++d)
      (d === o || n.charCodeAt(d) === ko) && (f += f.length === 0 ? ".." : "\\..");
    return a += h, f.length > 0 ? `${f}${i.slice(a, l)}` : (i.charCodeAt(a) === ko && ++a, i.slice(a, l));
  },
  toNamespacedPath(n) {
    if (typeof n != "string")
      return n;
    if (n.length === 0)
      return "";
    const e = Lo.resolve(n);
    if (e.length <= 2)
      return n;
    if (e.charCodeAt(0) === ko) {
      if (e.charCodeAt(1) === ko) {
        const t = e.charCodeAt(2);
        if (t !== are && t !== Jc)
          return `\\\\?\\UNC\\${e.slice(2)}`;
      }
    } else if (Tc(e.charCodeAt(0)) && e.charCodeAt(1) === Rc && e.charCodeAt(2) === ko)
      return `\\\\?\\${e}`;
    return n;
  },
  dirname(n) {
    Tn(n, "path");
    const e = n.length;
    if (e === 0)
      return ".";
    let t = -1, i = 0;
    const r = n.charCodeAt(0);
    if (e === 1)
      return Tt(r) ? n : ".";
    if (Tt(r)) {
      if (t = i = 1, Tt(n.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !Tt(n.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          for (l = a; a < e && Tt(n.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !Tt(n.charCodeAt(a)); )
              a++;
            if (a === e)
              return n;
            a !== l && (t = i = a + 1);
          }
        }
      }
    } else
      Tc(r) && n.charCodeAt(1) === Rc && (t = e > 2 && Tt(n.charCodeAt(2)) ? 3 : 2, i = t);
    let o = -1, s = !0;
    for (let a = e - 1; a >= i; --a)
      if (Tt(n.charCodeAt(a))) {
        if (!s) {
          o = a;
          break;
        }
      } else
        s = !1;
    if (o === -1) {
      if (t === -1)
        return ".";
      o = t;
    }
    return n.slice(0, o);
  },
  basename(n, e) {
    e !== void 0 && Tn(e, "ext"), Tn(n, "path");
    let t = 0, i = -1, r = !0, o;
    if (n.length >= 2 && Tc(n.charCodeAt(0)) && n.charCodeAt(1) === Rc && (t = 2), e !== void 0 && e.length > 0 && e.length <= n.length) {
      if (e === n)
        return "";
      let s = e.length - 1, a = -1;
      for (o = n.length - 1; o >= t; --o) {
        const l = n.charCodeAt(o);
        if (Tt(l)) {
          if (!r) {
            t = o + 1;
            break;
          }
        } else
          a === -1 && (r = !1, a = o + 1), s >= 0 && (l === e.charCodeAt(s) ? --s === -1 && (i = o) : (s = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = n.length), n.slice(t, i);
    }
    for (o = n.length - 1; o >= t; --o)
      if (Tt(n.charCodeAt(o))) {
        if (!r) {
          t = o + 1;
          break;
        }
      } else
        i === -1 && (r = !1, i = o + 1);
    return i === -1 ? "" : n.slice(t, i);
  },
  extname(n) {
    Tn(n, "path");
    let e = 0, t = -1, i = 0, r = -1, o = !0, s = 0;
    n.length >= 2 && n.charCodeAt(1) === Rc && Tc(n.charCodeAt(0)) && (e = i = 2);
    for (let a = n.length - 1; a >= e; --a) {
      const l = n.charCodeAt(a);
      if (Tt(l)) {
        if (!o) {
          i = a + 1;
          break;
        }
        continue;
      }
      r === -1 && (o = !1, r = a + 1), l === Jc ? t === -1 ? t = a : s !== 1 && (s = 1) : t !== -1 && (s = -1);
    }
    return t === -1 || r === -1 || // We saw a non-dot character immediately before the dot
    s === 0 || // The (right-most) trimmed path component is exactly '..'
    s === 1 && t === r - 1 && t === i + 1 ? "" : n.slice(t, r);
  },
  format: UG.bind(null, "\\"),
  parse(n) {
    Tn(n, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (n.length === 0)
      return e;
    const t = n.length;
    let i = 0, r = n.charCodeAt(0);
    if (t === 1)
      return Tt(r) ? (e.root = e.dir = n, e) : (e.base = e.name = n, e);
    if (Tt(r)) {
      if (i = 1, Tt(n.charCodeAt(1))) {
        let h = 2, d = h;
        for (; h < t && !Tt(n.charCodeAt(h)); )
          h++;
        if (h < t && h !== d) {
          for (d = h; h < t && Tt(n.charCodeAt(h)); )
            h++;
          if (h < t && h !== d) {
            for (d = h; h < t && !Tt(n.charCodeAt(h)); )
              h++;
            h === t ? i = h : h !== d && (i = h + 1);
          }
        }
      }
    } else if (Tc(r) && n.charCodeAt(1) === Rc) {
      if (t <= 2)
        return e.root = e.dir = n, e;
      if (i = 2, Tt(n.charCodeAt(2))) {
        if (t === 3)
          return e.root = e.dir = n, e;
        i = 3;
      }
    }
    i > 0 && (e.root = n.slice(0, i));
    let o = -1, s = i, a = -1, l = !0, u = n.length - 1, c = 0;
    for (; u >= i; --u) {
      if (r = n.charCodeAt(u), Tt(r)) {
        if (!l) {
          s = u + 1;
          break;
        }
        continue;
      }
      a === -1 && (l = !1, a = u + 1), r === Jc ? o === -1 ? o = u : c !== 1 && (c = 1) : o !== -1 && (c = -1);
    }
    return a !== -1 && (o === -1 || // We saw a non-dot character immediately before the dot
    c === 0 || // The (right-most) trimmed path component is exactly '..'
    c === 1 && o === a - 1 && o === s + 1 ? e.base = e.name = n.slice(s, a) : (e.name = n.slice(s, o), e.base = n.slice(s, a), e.ext = n.slice(o, a))), s > 0 && s !== i ? e.dir = n.slice(0, s - 1) : e.dir = e.root, e;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
}, _n = {
  // path.resolve([from ...], to)
  resolve(...n) {
    let e = "", t = !1;
    for (let i = n.length - 1; i >= -1 && !t; i--) {
      const r = i >= 0 ? n[i] : SR();
      Tn(r, "path"), r.length !== 0 && (e = `${r}/${e}`, t = r.charCodeAt(0) === Lr);
    }
    return e = ub(e, !t, "/", ER), t ? `/${e}` : e.length > 0 ? e : ".";
  },
  normalize(n) {
    if (Tn(n, "path"), n.length === 0)
      return ".";
    const e = n.charCodeAt(0) === Lr, t = n.charCodeAt(n.length - 1) === Lr;
    return n = ub(n, !e, "/", ER), n.length === 0 ? e ? "/" : t ? "./" : "." : (t && (n += "/"), e ? `/${n}` : n);
  },
  isAbsolute(n) {
    return Tn(n, "path"), n.length > 0 && n.charCodeAt(0) === Lr;
  },
  join(...n) {
    if (n.length === 0)
      return ".";
    let e;
    for (let t = 0; t < n.length; ++t) {
      const i = n[t];
      Tn(i, "path"), i.length > 0 && (e === void 0 ? e = i : e += `/${i}`);
    }
    return e === void 0 ? "." : _n.normalize(e);
  },
  relative(n, e) {
    if (Tn(n, "from"), Tn(e, "to"), n === e || (n = _n.resolve(n), e = _n.resolve(e), n === e))
      return "";
    const t = 1, i = n.length, r = i - t, o = 1, s = e.length - o, a = r < s ? r : s;
    let l = -1, u = 0;
    for (; u < a; u++) {
      const h = n.charCodeAt(t + u);
      if (h !== e.charCodeAt(o + u))
        break;
      h === Lr && (l = u);
    }
    if (u === a)
      if (s > a) {
        if (e.charCodeAt(o + u) === Lr)
          return e.slice(o + u + 1);
        if (u === 0)
          return e.slice(o + u);
      } else
        r > a && (n.charCodeAt(t + u) === Lr ? l = u : u === 0 && (l = 0));
    let c = "";
    for (u = t + l + 1; u <= i; ++u)
      (u === i || n.charCodeAt(u) === Lr) && (c += c.length === 0 ? ".." : "/..");
    return `${c}${e.slice(o + l)}`;
  },
  toNamespacedPath(n) {
    return n;
  },
  dirname(n) {
    if (Tn(n, "path"), n.length === 0)
      return ".";
    const e = n.charCodeAt(0) === Lr;
    let t = -1, i = !0;
    for (let r = n.length - 1; r >= 1; --r)
      if (n.charCodeAt(r) === Lr) {
        if (!i) {
          t = r;
          break;
        }
      } else
        i = !1;
    return t === -1 ? e ? "/" : "." : e && t === 1 ? "//" : n.slice(0, t);
  },
  basename(n, e) {
    e !== void 0 && Tn(e, "ext"), Tn(n, "path");
    let t = 0, i = -1, r = !0, o;
    if (e !== void 0 && e.length > 0 && e.length <= n.length) {
      if (e === n)
        return "";
      let s = e.length - 1, a = -1;
      for (o = n.length - 1; o >= 0; --o) {
        const l = n.charCodeAt(o);
        if (l === Lr) {
          if (!r) {
            t = o + 1;
            break;
          }
        } else
          a === -1 && (r = !1, a = o + 1), s >= 0 && (l === e.charCodeAt(s) ? --s === -1 && (i = o) : (s = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = n.length), n.slice(t, i);
    }
    for (o = n.length - 1; o >= 0; --o)
      if (n.charCodeAt(o) === Lr) {
        if (!r) {
          t = o + 1;
          break;
        }
      } else
        i === -1 && (r = !1, i = o + 1);
    return i === -1 ? "" : n.slice(t, i);
  },
  extname(n) {
    Tn(n, "path");
    let e = -1, t = 0, i = -1, r = !0, o = 0;
    for (let s = n.length - 1; s >= 0; --s) {
      const a = n.charCodeAt(s);
      if (a === Lr) {
        if (!r) {
          t = s + 1;
          break;
        }
        continue;
      }
      i === -1 && (r = !1, i = s + 1), a === Jc ? e === -1 ? e = s : o !== 1 && (o = 1) : e !== -1 && (o = -1);
    }
    return e === -1 || i === -1 || // We saw a non-dot character immediately before the dot
    o === 0 || // The (right-most) trimmed path component is exactly '..'
    o === 1 && e === i - 1 && e === t + 1 ? "" : n.slice(e, i);
  },
  format: UG.bind(null, "/"),
  parse(n) {
    Tn(n, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (n.length === 0)
      return e;
    const t = n.charCodeAt(0) === Lr;
    let i;
    t ? (e.root = "/", i = 1) : i = 0;
    let r = -1, o = 0, s = -1, a = !0, l = n.length - 1, u = 0;
    for (; l >= i; --l) {
      const c = n.charCodeAt(l);
      if (c === Lr) {
        if (!a) {
          o = l + 1;
          break;
        }
        continue;
      }
      s === -1 && (a = !1, s = l + 1), c === Jc ? r === -1 ? r = l : u !== 1 && (u = 1) : r !== -1 && (u = -1);
    }
    if (s !== -1) {
      const c = o === 0 && t ? 1 : o;
      r === -1 || // We saw a non-dot character immediately before the dot
      u === 0 || // The (right-most) trimmed path component is exactly '..'
      u === 1 && r === s - 1 && r === o + 1 ? e.base = e.name = n.slice(c, s) : (e.name = n.slice(c, r), e.base = n.slice(c, s), e.ext = n.slice(r, s));
    }
    return o > 0 ? e.dir = n.slice(0, o - 1) : t && (e.dir = "/"), e;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
_n.win32 = Lo.win32 = Lo;
_n.posix = Lo.posix = _n;
const IN = af === "win32" ? Lo.normalize : _n.normalize, lre = af === "win32" ? Lo.resolve : _n.resolve, ure = af === "win32" ? Lo.relative : _n.relative, cre = af === "win32" ? Lo.dirname : _n.dirname, zG = af === "win32" ? Lo.basename : _n.basename, hre = af === "win32" ? Lo.extname : _n.extname, rw = af === "win32" ? Lo.sep : _n.sep, dre = /^\w[\w\d+.-]*$/, fre = /^\//, pre = /^\/\//;
function QF(n, e) {
  if (!n.scheme && e)
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${n.authority}", path: "${n.path}", query: "${n.query}", fragment: "${n.fragment}"}`);
  if (n.scheme && !dre.test(n.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.");
  if (n.path) {
    if (n.authority) {
      if (!fre.test(n.path))
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
    } else if (pre.test(n.path))
      throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
  }
}
function gre(n, e) {
  return !n && !e ? "file" : n;
}
function mre(n, e) {
  switch (n) {
    case "https":
    case "http":
    case "file":
      e ? e[0] !== Ga && (e = Ga + e) : e = Ga;
      break;
  }
  return e;
}
const ki = "", Ga = "/", vre = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
class ft {
  /**
   * @internal
   */
  constructor(e, t, i, r, o, s = !1) {
    typeof e == "object" ? (this.scheme = e.scheme || ki, this.authority = e.authority || ki, this.path = e.path || ki, this.query = e.query || ki, this.fragment = e.fragment || ki) : (this.scheme = gre(e, s), this.authority = t || ki, this.path = mre(this.scheme, i || ki), this.query = r || ki, this.fragment = o || ki, QF(this, s));
  }
  static isUri(e) {
    return e instanceof ft ? !0 : e ? typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function" : !1;
  }
  // ---- filesystem path -----------------------
  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
      const u = URI.parse('file://server/c$/folder/file.txt')
      u.authority === 'server'
      u.path === '/shares/c$/file.txt'
      u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */
  get fsPath() {
    return cb(this, !1);
  }
  // ---- modify to new -------------------------
  with(e) {
    if (!e)
      return this;
    let { scheme: t, authority: i, path: r, query: o, fragment: s } = e;
    return t === void 0 ? t = this.scheme : t === null && (t = ki), i === void 0 ? i = this.authority : i === null && (i = ki), r === void 0 ? r = this.path : r === null && (r = ki), o === void 0 ? o = this.query : o === null && (o = ki), s === void 0 ? s = this.fragment : s === null && (s = ki), t === this.scheme && i === this.authority && r === this.path && o === this.query && s === this.fragment ? this : new Pf(t, i, r, o, s);
  }
  // ---- parse & validate ------------------------
  /**
   * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */
  static parse(e, t = !1) {
    const i = vre.exec(e);
    return i ? new Pf(i[2] || ki, dy(i[4] || ki), dy(i[5] || ki), dy(i[7] || ki), dy(i[9] || ki), t) : new Pf(ki, ki, ki, ki, ki);
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */
  static file(e) {
    let t = ki;
    if (Ro && (e = e.replace(/\\/g, Ga)), e[0] === Ga && e[1] === Ga) {
      const i = e.indexOf(Ga, 2);
      i === -1 ? (t = e.substring(2), e = Ga) : (t = e.substring(2, i), e = e.substring(i) || Ga);
    }
    return new Pf("file", t, e, ki, ki);
  }
  static from(e) {
    const t = new Pf(e.scheme, e.authority, e.path, e.query, e.fragment);
    return QF(t, !0), t;
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */
  static joinPath(e, ...t) {
    if (!e.path)
      throw new Error("[UriError]: cannot call joinPath on URI without path");
    let i;
    return Ro && e.scheme === "file" ? i = ft.file(Lo.join(cb(e, !0), ...t)).path : i = _n.join(e.path, ...t), e.with({ path: i });
  }
  // ---- printing/externalize ---------------------------
  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */
  toString(e = !1) {
    return LR(this, e);
  }
  toJSON() {
    return this;
  }
  static revive(e) {
    if (e) {
      if (e instanceof ft)
        return e;
      {
        const t = new Pf(e);
        return t._formatted = e.external, t._fsPath = e._sep === jG ? e.fsPath : null, t;
      }
    } else
      return e;
  }
}
const jG = Ro ? 1 : void 0;
let Pf = class extends ft {
  constructor() {
    super(...arguments), this._formatted = null, this._fsPath = null;
  }
  get fsPath() {
    return this._fsPath || (this._fsPath = cb(this, !1)), this._fsPath;
  }
  toString(e = !1) {
    return e ? LR(this, !0) : (this._formatted || (this._formatted = LR(this, !1)), this._formatted);
  }
  toJSON() {
    const e = {
      $mid: 1
    };
    return this._fsPath && (e.fsPath = this._fsPath, e._sep = jG), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
  }
};
const $G = {
  [
    58
    /* Colon */
  ]: "%3A",
  [
    47
    /* Slash */
  ]: "%2F",
  [
    63
    /* QuestionMark */
  ]: "%3F",
  [
    35
    /* Hash */
  ]: "%23",
  [
    91
    /* OpenSquareBracket */
  ]: "%5B",
  [
    93
    /* CloseSquareBracket */
  ]: "%5D",
  [
    64
    /* AtSign */
  ]: "%40",
  [
    33
    /* ExclamationMark */
  ]: "%21",
  [
    36
    /* DollarSign */
  ]: "%24",
  [
    38
    /* Ampersand */
  ]: "%26",
  [
    39
    /* SingleQuote */
  ]: "%27",
  [
    40
    /* OpenParen */
  ]: "%28",
  [
    41
    /* CloseParen */
  ]: "%29",
  [
    42
    /* Asterisk */
  ]: "%2A",
  [
    43
    /* Plus */
  ]: "%2B",
  [
    44
    /* Comma */
  ]: "%2C",
  [
    59
    /* Semicolon */
  ]: "%3B",
  [
    61
    /* Equals */
  ]: "%3D",
  [
    32
    /* Space */
  ]: "%20"
};
function JF(n, e) {
  let t, i = -1;
  for (let r = 0; r < n.length; r++) {
    const o = n.charCodeAt(r);
    if (o >= 97 && o <= 122 || o >= 65 && o <= 90 || o >= 48 && o <= 57 || o === 45 || o === 46 || o === 95 || o === 126 || e && o === 47)
      i !== -1 && (t += encodeURIComponent(n.substring(i, r)), i = -1), t !== void 0 && (t += n.charAt(r));
    else {
      t === void 0 && (t = n.substr(0, r));
      const s = $G[o];
      s !== void 0 ? (i !== -1 && (t += encodeURIComponent(n.substring(i, r)), i = -1), t += s) : i === -1 && (i = r);
    }
  }
  return i !== -1 && (t += encodeURIComponent(n.substring(i))), t !== void 0 ? t : n;
}
function _re(n) {
  let e;
  for (let t = 0; t < n.length; t++) {
    const i = n.charCodeAt(t);
    i === 35 || i === 63 ? (e === void 0 && (e = n.substr(0, t)), e += $G[i]) : e !== void 0 && (e += n[t]);
  }
  return e !== void 0 ? e : n;
}
function cb(n, e) {
  let t;
  return n.authority && n.path.length > 1 && n.scheme === "file" ? t = `//${n.authority}${n.path}` : n.path.charCodeAt(0) === 47 && (n.path.charCodeAt(1) >= 65 && n.path.charCodeAt(1) <= 90 || n.path.charCodeAt(1) >= 97 && n.path.charCodeAt(1) <= 122) && n.path.charCodeAt(2) === 58 ? e ? t = n.path.substr(1) : t = n.path[1].toLowerCase() + n.path.substr(2) : t = n.path, Ro && (t = t.replace(/\//g, "\\")), t;
}
function LR(n, e) {
  const t = e ? _re : JF;
  let i = "", { scheme: r, authority: o, path: s, query: a, fragment: l } = n;
  if (r && (i += r, i += ":"), (o || r === "file") && (i += Ga, i += Ga), o) {
    let u = o.indexOf("@");
    if (u !== -1) {
      const c = o.substr(0, u);
      o = o.substr(u + 1), u = c.indexOf(":"), u === -1 ? i += t(c, !1) : (i += t(c.substr(0, u), !1), i += ":", i += t(c.substr(u + 1), !1)), i += "@";
    }
    o = o.toLowerCase(), u = o.indexOf(":"), u === -1 ? i += t(o, !1) : (i += t(o.substr(0, u), !1), i += o.substr(u));
  }
  if (s) {
    if (s.length >= 3 && s.charCodeAt(0) === 47 && s.charCodeAt(2) === 58) {
      const u = s.charCodeAt(1);
      u >= 65 && u <= 90 && (s = `/${String.fromCharCode(u + 32)}:${s.substr(3)}`);
    } else if (s.length >= 2 && s.charCodeAt(1) === 58) {
      const u = s.charCodeAt(0);
      u >= 65 && u <= 90 && (s = `${String.fromCharCode(u + 32)}:${s.substr(2)}`);
    }
    i += t(s, !0);
  }
  return a && (i += "?", i += t(a, !1)), l && (i += "#", i += e ? l : JF(l, !1)), i;
}
function KG(n) {
  try {
    return decodeURIComponent(n);
  } catch {
    return n.length > 3 ? n.substr(0, 3) + KG(n.substr(3)) : n;
  }
}
const ek = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function dy(n) {
  return n.match(ek) ? n.replace(ek, (e) => KG(e)) : n;
}
let ie = class qh {
  constructor(e, t) {
    this.lineNumber = e, this.column = t;
  }
  /**
   * Create a new position from this position.
   *
   * @param newLineNumber new line number
   * @param newColumn new column
   */
  with(e = this.lineNumber, t = this.column) {
    return e === this.lineNumber && t === this.column ? this : new qh(e, t);
  }
  /**
   * Derive a new position from this position.
   *
   * @param deltaLineNumber line number delta
   * @param deltaColumn column delta
   */
  delta(e = 0, t = 0) {
    return this.with(this.lineNumber + e, this.column + t);
  }
  /**
   * Test if this position equals other position
   */
  equals(e) {
    return qh.equals(this, e);
  }
  /**
   * Test if position `a` equals position `b`
   */
  static equals(e, t) {
    return !e && !t ? !0 : !!e && !!t && e.lineNumber === t.lineNumber && e.column === t.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be false.
   */
  isBefore(e) {
    return qh.isBefore(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be false.
   */
  static isBefore(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column < t.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be true.
   */
  isBeforeOrEqual(e) {
    return qh.isBeforeOrEqual(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be true.
   */
  static isBeforeOrEqual(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column <= t.column;
  }
  /**
   * A function that compares positions, useful for sorting
   */
  static compare(e, t) {
    let i = e.lineNumber | 0, r = t.lineNumber | 0;
    if (i === r) {
      let o = e.column | 0, s = t.column | 0;
      return o - s;
    }
    return i - r;
  }
  /**
   * Clone this position.
   */
  clone() {
    return new qh(this.lineNumber, this.column);
  }
  /**
   * Convert to a human-readable representation.
   */
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  // ---
  /**
   * Create a `Position` from an `IPosition`.
   */
  static lift(e) {
    return new qh(e.lineNumber, e.column);
  }
  /**
   * Test if `obj` is an `IPosition`.
   */
  static isIPosition(e) {
    return e && typeof e.lineNumber == "number" && typeof e.column == "number";
  }
}, G = class Er {
  constructor(e, t, i, r) {
    e > i || e === i && t > r ? (this.startLineNumber = i, this.startColumn = r, this.endLineNumber = e, this.endColumn = t) : (this.startLineNumber = e, this.startColumn = t, this.endLineNumber = i, this.endColumn = r);
  }
  /**
   * Test if this range is empty.
   */
  isEmpty() {
    return Er.isEmpty(this);
  }
  /**
   * Test if `range` is empty.
   */
  static isEmpty(e) {
    return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn;
  }
  /**
   * Test if position is in this range. If the position is at the edges, will return true.
   */
  containsPosition(e) {
    return Er.containsPosition(this, e);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return true.
   */
  static containsPosition(e, t) {
    return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column < e.startColumn || t.lineNumber === e.endLineNumber && t.column > e.endColumn);
  }
  /**
   * Test if range is in this range. If the range is equal to this range, will return true.
   */
  containsRange(e) {
    return Er.containsRange(this, e);
  }
  /**
   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
   */
  static containsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn < e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn > e.endColumn);
  }
  /**
   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
   */
  strictContainsRange(e) {
    return Er.strictContainsRange(this, e);
  }
  /**
   * Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.
   */
  static strictContainsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn <= e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn >= e.endColumn);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  plusRange(e) {
    return Er.plusRange(this, e);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  static plusRange(e, t) {
    let i, r, o, s;
    return t.startLineNumber < e.startLineNumber ? (i = t.startLineNumber, r = t.startColumn) : t.startLineNumber === e.startLineNumber ? (i = t.startLineNumber, r = Math.min(t.startColumn, e.startColumn)) : (i = e.startLineNumber, r = e.startColumn), t.endLineNumber > e.endLineNumber ? (o = t.endLineNumber, s = t.endColumn) : t.endLineNumber === e.endLineNumber ? (o = t.endLineNumber, s = Math.max(t.endColumn, e.endColumn)) : (o = e.endLineNumber, s = e.endColumn), new Er(i, r, o, s);
  }
  /**
   * A intersection of the two ranges.
   */
  intersectRanges(e) {
    return Er.intersectRanges(this, e);
  }
  /**
   * A intersection of the two ranges.
   */
  static intersectRanges(e, t) {
    let i = e.startLineNumber, r = e.startColumn, o = e.endLineNumber, s = e.endColumn, a = t.startLineNumber, l = t.startColumn, u = t.endLineNumber, c = t.endColumn;
    return i < a ? (i = a, r = l) : i === a && (r = Math.max(r, l)), o > u ? (o = u, s = c) : o === u && (s = Math.min(s, c)), i > o || i === o && r > s ? null : new Er(i, r, o, s);
  }
  /**
   * Test if this range equals other.
   */
  equalsRange(e) {
    return Er.equalsRange(this, e);
  }
  /**
   * Test if range `a` equals `b`.
   */
  static equalsRange(e, t) {
    return !!e && !!t && e.startLineNumber === t.startLineNumber && e.startColumn === t.startColumn && e.endLineNumber === t.endLineNumber && e.endColumn === t.endColumn;
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  getEndPosition() {
    return Er.getEndPosition(this);
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  static getEndPosition(e) {
    return new ie(e.endLineNumber, e.endColumn);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  getStartPosition() {
    return Er.getStartPosition(this);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  static getStartPosition(e) {
    return new ie(e.startLineNumber, e.startColumn);
  }
  /**
   * Transform to a user presentable string representation.
   */
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  /**
   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
   */
  setEndPosition(e, t) {
    return new Er(this.startLineNumber, this.startColumn, e, t);
  }
  /**
   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
   */
  setStartPosition(e, t) {
    return new Er(e, t, this.endLineNumber, this.endColumn);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  collapseToStart() {
    return Er.collapseToStart(this);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  static collapseToStart(e) {
    return new Er(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn);
  }
  // ---
  static fromPositions(e, t = e) {
    return new Er(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  static lift(e) {
    return e ? new Er(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null;
  }
  /**
   * Test if `obj` is an `IRange`.
   */
  static isIRange(e) {
    return e && typeof e.startLineNumber == "number" && typeof e.startColumn == "number" && typeof e.endLineNumber == "number" && typeof e.endColumn == "number";
  }
  /**
   * Test if the two ranges are touching in any way.
   */
  static areIntersectingOrTouching(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn);
  }
  /**
   * Test if the two ranges are intersecting. If the ranges are touching it returns true.
   */
  static areIntersecting(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn <= e.startColumn);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the startPosition and then on the endPosition
   */
  static compareRangesUsingStarts(e, t) {
    if (e && t) {
      const o = e.startLineNumber | 0, s = t.startLineNumber | 0;
      if (o === s) {
        const a = e.startColumn | 0, l = t.startColumn | 0;
        if (a === l) {
          const u = e.endLineNumber | 0, c = t.endLineNumber | 0;
          if (u === c) {
            const h = e.endColumn | 0, d = t.endColumn | 0;
            return h - d;
          }
          return u - c;
        }
        return a - l;
      }
      return o - s;
    }
    return (e ? 1 : 0) - (t ? 1 : 0);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the endPosition and then on the startPosition
   */
  static compareRangesUsingEnds(e, t) {
    return e.endLineNumber === t.endLineNumber ? e.endColumn === t.endColumn ? e.startLineNumber === t.startLineNumber ? e.startColumn - t.startColumn : e.startLineNumber - t.startLineNumber : e.endColumn - t.endColumn : e.endLineNumber - t.endLineNumber;
  }
  /**
   * Test if the range spans multiple lines.
   */
  static spansMultipleLines(e) {
    return e.endLineNumber > e.startLineNumber;
  }
}, Ut = class xl extends G {
  constructor(e, t, i, r) {
    super(e, t, i, r), this.selectionStartLineNumber = e, this.selectionStartColumn = t, this.positionLineNumber = i, this.positionColumn = r;
  }
  /**
   * Transform to a human-readable representation.
   */
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  /**
   * Test if equals other selection.
   */
  equalsSelection(e) {
    return xl.selectionsEqual(this, e);
  }
  /**
   * Test if the two selections are equal.
   */
  static selectionsEqual(e, t) {
    return e.selectionStartLineNumber === t.selectionStartLineNumber && e.selectionStartColumn === t.selectionStartColumn && e.positionLineNumber === t.positionLineNumber && e.positionColumn === t.positionColumn;
  }
  /**
   * Get directions (LTR or RTL).
   */
  getDirection() {
    return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? 0 : 1;
  }
  /**
   * Create a new selection with a different `positionLineNumber` and `positionColumn`.
   */
  setEndPosition(e, t) {
    return this.getDirection() === 0 ? new xl(this.startLineNumber, this.startColumn, e, t) : new xl(e, t, this.startLineNumber, this.startColumn);
  }
  /**
   * Get the position at `positionLineNumber` and `positionColumn`.
   */
  getPosition() {
    return new ie(this.positionLineNumber, this.positionColumn);
  }
  /**
   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
   */
  setStartPosition(e, t) {
    return this.getDirection() === 0 ? new xl(e, t, this.endLineNumber, this.endColumn) : new xl(this.endLineNumber, this.endColumn, e, t);
  }
  // ----
  /**
   * Create a `Selection` from one or two positions
   */
  static fromPositions(e, t = e) {
    return new xl(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  /**
   * Create a `Selection` from an `ISelection`.
   */
  static liftSelection(e) {
    return new xl(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
  }
  /**
   * `a` equals `b`.
   */
  static selectionsArrEqual(e, t) {
    if (e && !t || !e && t)
      return !1;
    if (!e && !t)
      return !0;
    if (e.length !== t.length)
      return !1;
    for (let i = 0, r = e.length; i < r; i++)
      if (!this.selectionsEqual(e[i], t[i]))
        return !1;
    return !0;
  }
  /**
   * Test if `obj` is an `ISelection`.
   */
  static isISelection(e) {
    return e && typeof e.selectionStartLineNumber == "number" && typeof e.selectionStartColumn == "number" && typeof e.positionLineNumber == "number" && typeof e.positionColumn == "number";
  }
  /**
   * Create with a direction.
   */
  static createWithDirection(e, t, i, r, o) {
    return o === 0 ? new xl(e, t, i, r) : new xl(i, r, e, t);
  }
}, JS = class {
  constructor(e, t, i) {
    this.offset = e | 0, this.type = t, this.language = i;
  }
  toString() {
    return "(" + this.offset + ", " + this.type + ")";
  }
};
class PN {
  constructor(e, t) {
    this.tokens = e, this.endState = t;
  }
}
class eE {
  constructor(e, t) {
    this.tokens = e, this.endState = t;
  }
}
var DR;
(function(n) {
  n[n.Unknown = 0] = "Unknown", n[n.Disabled = 1] = "Disabled", n[n.Enabled = 2] = "Enabled";
})(DR || (DR = {}));
var RR;
(function(n) {
  n[n.KeepWhitespace = 1] = "KeepWhitespace", n[n.InsertAsSnippet = 4] = "InsertAsSnippet";
})(RR || (RR = {}));
var TR;
(function(n) {
  n[n.Method = 0] = "Method", n[n.Function = 1] = "Function", n[n.Constructor = 2] = "Constructor", n[n.Field = 3] = "Field", n[n.Variable = 4] = "Variable", n[n.Class = 5] = "Class", n[n.Struct = 6] = "Struct", n[n.Interface = 7] = "Interface", n[n.Module = 8] = "Module", n[n.Property = 9] = "Property", n[n.Event = 10] = "Event", n[n.Operator = 11] = "Operator", n[n.Unit = 12] = "Unit", n[n.Value = 13] = "Value", n[n.Constant = 14] = "Constant", n[n.Enum = 15] = "Enum", n[n.EnumMember = 16] = "EnumMember", n[n.Keyword = 17] = "Keyword", n[n.Text = 18] = "Text", n[n.Color = 19] = "Color", n[n.File = 20] = "File", n[n.Reference = 21] = "Reference", n[n.Customcolor = 22] = "Customcolor", n[n.Folder = 23] = "Folder", n[n.TypeParameter = 24] = "TypeParameter", n[n.User = 25] = "User", n[n.Issue = 26] = "Issue", n[n.Snippet = 27] = "Snippet";
})(TR || (TR = {}));
var OR;
(function(n) {
  n[n.Deprecated = 1] = "Deprecated";
})(OR || (OR = {}));
var xR;
(function(n) {
  n[n.Invoke = 0] = "Invoke", n[n.TriggerCharacter = 1] = "TriggerCharacter", n[n.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
})(xR || (xR = {}));
var NR;
(function(n) {
  n[n.EXACT = 0] = "EXACT", n[n.ABOVE = 1] = "ABOVE", n[n.BELOW = 2] = "BELOW";
})(NR || (NR = {}));
var IR;
(function(n) {
  n[n.NotSet = 0] = "NotSet", n[n.ContentFlush = 1] = "ContentFlush", n[n.RecoverFromMarkers = 2] = "RecoverFromMarkers", n[n.Explicit = 3] = "Explicit", n[n.Paste = 4] = "Paste", n[n.Undo = 5] = "Undo", n[n.Redo = 6] = "Redo";
})(IR || (IR = {}));
var PR;
(function(n) {
  n[n.LF = 1] = "LF", n[n.CRLF = 2] = "CRLF";
})(PR || (PR = {}));
var AR;
(function(n) {
  n[n.Text = 0] = "Text", n[n.Read = 1] = "Read", n[n.Write = 2] = "Write";
})(AR || (AR = {}));
var MR;
(function(n) {
  n[n.None = 0] = "None", n[n.Keep = 1] = "Keep", n[n.Brackets = 2] = "Brackets", n[n.Advanced = 3] = "Advanced", n[n.Full = 4] = "Full";
})(MR || (MR = {}));
var FR;
(function(n) {
  n[n.acceptSuggestionOnCommitCharacter = 0] = "acceptSuggestionOnCommitCharacter", n[n.acceptSuggestionOnEnter = 1] = "acceptSuggestionOnEnter", n[n.accessibilitySupport = 2] = "accessibilitySupport", n[n.accessibilityPageSize = 3] = "accessibilityPageSize", n[n.ariaLabel = 4] = "ariaLabel", n[n.autoClosingBrackets = 5] = "autoClosingBrackets", n[n.autoClosingDelete = 6] = "autoClosingDelete", n[n.autoClosingOvertype = 7] = "autoClosingOvertype", n[n.autoClosingQuotes = 8] = "autoClosingQuotes", n[n.autoIndent = 9] = "autoIndent", n[n.automaticLayout = 10] = "automaticLayout", n[n.autoSurround = 11] = "autoSurround", n[n.codeLens = 12] = "codeLens", n[n.codeLensFontFamily = 13] = "codeLensFontFamily", n[n.codeLensFontSize = 14] = "codeLensFontSize", n[n.colorDecorators = 15] = "colorDecorators", n[n.columnSelection = 16] = "columnSelection", n[n.comments = 17] = "comments", n[n.contextmenu = 18] = "contextmenu", n[n.copyWithSyntaxHighlighting = 19] = "copyWithSyntaxHighlighting", n[n.cursorBlinking = 20] = "cursorBlinking", n[n.cursorSmoothCaretAnimation = 21] = "cursorSmoothCaretAnimation", n[n.cursorStyle = 22] = "cursorStyle", n[n.cursorSurroundingLines = 23] = "cursorSurroundingLines", n[n.cursorSurroundingLinesStyle = 24] = "cursorSurroundingLinesStyle", n[n.cursorWidth = 25] = "cursorWidth", n[n.disableLayerHinting = 26] = "disableLayerHinting", n[n.disableMonospaceOptimizations = 27] = "disableMonospaceOptimizations", n[n.domReadOnly = 28] = "domReadOnly", n[n.dragAndDrop = 29] = "dragAndDrop", n[n.emptySelectionClipboard = 30] = "emptySelectionClipboard", n[n.extraEditorClassName = 31] = "extraEditorClassName", n[n.fastScrollSensitivity = 32] = "fastScrollSensitivity", n[n.find = 33] = "find", n[n.fixedOverflowWidgets = 34] = "fixedOverflowWidgets", n[n.folding = 35] = "folding", n[n.foldingStrategy = 36] = "foldingStrategy", n[n.foldingHighlight = 37] = "foldingHighlight", n[n.unfoldOnClickAfterEndOfLine = 38] = "unfoldOnClickAfterEndOfLine", n[n.fontFamily = 39] = "fontFamily", n[n.fontInfo = 40] = "fontInfo", n[n.fontLigatures = 41] = "fontLigatures", n[n.fontSize = 42] = "fontSize", n[n.fontWeight = 43] = "fontWeight", n[n.formatOnPaste = 44] = "formatOnPaste", n[n.formatOnType = 45] = "formatOnType", n[n.glyphMargin = 46] = "glyphMargin", n[n.gotoLocation = 47] = "gotoLocation", n[n.hideCursorInOverviewRuler = 48] = "hideCursorInOverviewRuler", n[n.highlightActiveIndentGuide = 49] = "highlightActiveIndentGuide", n[n.hover = 50] = "hover", n[n.inDiffEditor = 51] = "inDiffEditor", n[n.inlineSuggest = 52] = "inlineSuggest", n[n.letterSpacing = 53] = "letterSpacing", n[n.lightbulb = 54] = "lightbulb", n[n.lineDecorationsWidth = 55] = "lineDecorationsWidth", n[n.lineHeight = 56] = "lineHeight", n[n.lineNumbers = 57] = "lineNumbers", n[n.lineNumbersMinChars = 58] = "lineNumbersMinChars", n[n.linkedEditing = 59] = "linkedEditing", n[n.links = 60] = "links", n[n.matchBrackets = 61] = "matchBrackets", n[n.minimap = 62] = "minimap", n[n.mouseStyle = 63] = "mouseStyle", n[n.mouseWheelScrollSensitivity = 64] = "mouseWheelScrollSensitivity", n[n.mouseWheelZoom = 65] = "mouseWheelZoom", n[n.multiCursorMergeOverlapping = 66] = "multiCursorMergeOverlapping", n[n.multiCursorModifier = 67] = "multiCursorModifier", n[n.multiCursorPaste = 68] = "multiCursorPaste", n[n.occurrencesHighlight = 69] = "occurrencesHighlight", n[n.overviewRulerBorder = 70] = "overviewRulerBorder", n[n.overviewRulerLanes = 71] = "overviewRulerLanes", n[n.padding = 72] = "padding", n[n.parameterHints = 73] = "parameterHints", n[n.peekWidgetDefaultFocus = 74] = "peekWidgetDefaultFocus", n[n.definitionLinkOpensInPeek = 75] = "definitionLinkOpensInPeek", n[n.quickSuggestions = 76] = "quickSuggestions", n[n.quickSuggestionsDelay = 77] = "quickSuggestionsDelay", n[n.readOnly = 78] = "readOnly", n[n.renameOnType = 79] = "renameOnType", n[n.renderControlCharacters = 80] = "renderControlCharacters", n[n.renderIndentGuides = 81] = "renderIndentGuides", n[n.renderFinalNewline = 82] = "renderFinalNewline", n[n.renderLineHighlight = 83] = "renderLineHighlight", n[n.renderLineHighlightOnlyWhenFocus = 84] = "renderLineHighlightOnlyWhenFocus", n[n.renderValidationDecorations = 85] = "renderValidationDecorations", n[n.renderWhitespace = 86] = "renderWhitespace", n[n.revealHorizontalRightPadding = 87] = "revealHorizontalRightPadding", n[n.roundedSelection = 88] = "roundedSelection", n[n.rulers = 89] = "rulers", n[n.scrollbar = 90] = "scrollbar", n[n.scrollBeyondLastColumn = 91] = "scrollBeyondLastColumn", n[n.scrollBeyondLastLine = 92] = "scrollBeyondLastLine", n[n.scrollPredominantAxis = 93] = "scrollPredominantAxis", n[n.selectionClipboard = 94] = "selectionClipboard", n[n.selectionHighlight = 95] = "selectionHighlight", n[n.selectOnLineNumbers = 96] = "selectOnLineNumbers", n[n.showFoldingControls = 97] = "showFoldingControls", n[n.showUnused = 98] = "showUnused", n[n.snippetSuggestions = 99] = "snippetSuggestions", n[n.smartSelect = 100] = "smartSelect", n[n.smoothScrolling = 101] = "smoothScrolling", n[n.stickyTabStops = 102] = "stickyTabStops", n[n.stopRenderingLineAfter = 103] = "stopRenderingLineAfter", n[n.suggest = 104] = "suggest", n[n.suggestFontSize = 105] = "suggestFontSize", n[n.suggestLineHeight = 106] = "suggestLineHeight", n[n.suggestOnTriggerCharacters = 107] = "suggestOnTriggerCharacters", n[n.suggestSelection = 108] = "suggestSelection", n[n.tabCompletion = 109] = "tabCompletion", n[n.tabIndex = 110] = "tabIndex", n[n.unusualLineTerminators = 111] = "unusualLineTerminators", n[n.useShadowDOM = 112] = "useShadowDOM", n[n.useTabStops = 113] = "useTabStops", n[n.wordSeparators = 114] = "wordSeparators", n[n.wordWrap = 115] = "wordWrap", n[n.wordWrapBreakAfterCharacters = 116] = "wordWrapBreakAfterCharacters", n[n.wordWrapBreakBeforeCharacters = 117] = "wordWrapBreakBeforeCharacters", n[n.wordWrapColumn = 118] = "wordWrapColumn", n[n.wordWrapOverride1 = 119] = "wordWrapOverride1", n[n.wordWrapOverride2 = 120] = "wordWrapOverride2", n[n.wrappingIndent = 121] = "wrappingIndent", n[n.wrappingStrategy = 122] = "wrappingStrategy", n[n.showDeprecated = 123] = "showDeprecated", n[n.inlayHints = 124] = "inlayHints", n[n.editorClassName = 125] = "editorClassName", n[n.pixelRatio = 126] = "pixelRatio", n[n.tabFocusMode = 127] = "tabFocusMode", n[n.layoutInfo = 128] = "layoutInfo", n[n.wrappingInfo = 129] = "wrappingInfo";
})(FR || (FR = {}));
var kR;
(function(n) {
  n[n.TextDefined = 0] = "TextDefined", n[n.LF = 1] = "LF", n[n.CRLF = 2] = "CRLF";
})(kR || (kR = {}));
var WR;
(function(n) {
  n[n.LF = 0] = "LF", n[n.CRLF = 1] = "CRLF";
})(WR || (WR = {}));
var VR;
(function(n) {
  n[n.None = 0] = "None", n[n.Indent = 1] = "Indent", n[n.IndentOutdent = 2] = "IndentOutdent", n[n.Outdent = 3] = "Outdent";
})(VR || (VR = {}));
var BR;
(function(n) {
  n[n.Other = 0] = "Other", n[n.Type = 1] = "Type", n[n.Parameter = 2] = "Parameter";
})(BR || (BR = {}));
var HR;
(function(n) {
  n[n.Automatic = 0] = "Automatic", n[n.Explicit = 1] = "Explicit";
})(HR || (HR = {}));
var GR;
(function(n) {
  n[n.DependsOnKbLayout = -1] = "DependsOnKbLayout", n[n.Unknown = 0] = "Unknown", n[n.Backspace = 1] = "Backspace", n[n.Tab = 2] = "Tab", n[n.Enter = 3] = "Enter", n[n.Shift = 4] = "Shift", n[n.Ctrl = 5] = "Ctrl", n[n.Alt = 6] = "Alt", n[n.PauseBreak = 7] = "PauseBreak", n[n.CapsLock = 8] = "CapsLock", n[n.Escape = 9] = "Escape", n[n.Space = 10] = "Space", n[n.PageUp = 11] = "PageUp", n[n.PageDown = 12] = "PageDown", n[n.End = 13] = "End", n[n.Home = 14] = "Home", n[n.LeftArrow = 15] = "LeftArrow", n[n.UpArrow = 16] = "UpArrow", n[n.RightArrow = 17] = "RightArrow", n[n.DownArrow = 18] = "DownArrow", n[n.Insert = 19] = "Insert", n[n.Delete = 20] = "Delete", n[n.KEY_0 = 21] = "KEY_0", n[n.KEY_1 = 22] = "KEY_1", n[n.KEY_2 = 23] = "KEY_2", n[n.KEY_3 = 24] = "KEY_3", n[n.KEY_4 = 25] = "KEY_4", n[n.KEY_5 = 26] = "KEY_5", n[n.KEY_6 = 27] = "KEY_6", n[n.KEY_7 = 28] = "KEY_7", n[n.KEY_8 = 29] = "KEY_8", n[n.KEY_9 = 30] = "KEY_9", n[n.KEY_A = 31] = "KEY_A", n[n.KEY_B = 32] = "KEY_B", n[n.KEY_C = 33] = "KEY_C", n[n.KEY_D = 34] = "KEY_D", n[n.KEY_E = 35] = "KEY_E", n[n.KEY_F = 36] = "KEY_F", n[n.KEY_G = 37] = "KEY_G", n[n.KEY_H = 38] = "KEY_H", n[n.KEY_I = 39] = "KEY_I", n[n.KEY_J = 40] = "KEY_J", n[n.KEY_K = 41] = "KEY_K", n[n.KEY_L = 42] = "KEY_L", n[n.KEY_M = 43] = "KEY_M", n[n.KEY_N = 44] = "KEY_N", n[n.KEY_O = 45] = "KEY_O", n[n.KEY_P = 46] = "KEY_P", n[n.KEY_Q = 47] = "KEY_Q", n[n.KEY_R = 48] = "KEY_R", n[n.KEY_S = 49] = "KEY_S", n[n.KEY_T = 50] = "KEY_T", n[n.KEY_U = 51] = "KEY_U", n[n.KEY_V = 52] = "KEY_V", n[n.KEY_W = 53] = "KEY_W", n[n.KEY_X = 54] = "KEY_X", n[n.KEY_Y = 55] = "KEY_Y", n[n.KEY_Z = 56] = "KEY_Z", n[n.Meta = 57] = "Meta", n[n.ContextMenu = 58] = "ContextMenu", n[n.F1 = 59] = "F1", n[n.F2 = 60] = "F2", n[n.F3 = 61] = "F3", n[n.F4 = 62] = "F4", n[n.F5 = 63] = "F5", n[n.F6 = 64] = "F6", n[n.F7 = 65] = "F7", n[n.F8 = 66] = "F8", n[n.F9 = 67] = "F9", n[n.F10 = 68] = "F10", n[n.F11 = 69] = "F11", n[n.F12 = 70] = "F12", n[n.F13 = 71] = "F13", n[n.F14 = 72] = "F14", n[n.F15 = 73] = "F15", n[n.F16 = 74] = "F16", n[n.F17 = 75] = "F17", n[n.F18 = 76] = "F18", n[n.F19 = 77] = "F19", n[n.NumLock = 78] = "NumLock", n[n.ScrollLock = 79] = "ScrollLock", n[n.US_SEMICOLON = 80] = "US_SEMICOLON", n[n.US_EQUAL = 81] = "US_EQUAL", n[n.US_COMMA = 82] = "US_COMMA", n[n.US_MINUS = 83] = "US_MINUS", n[n.US_DOT = 84] = "US_DOT", n[n.US_SLASH = 85] = "US_SLASH", n[n.US_BACKTICK = 86] = "US_BACKTICK", n[n.US_OPEN_SQUARE_BRACKET = 87] = "US_OPEN_SQUARE_BRACKET", n[n.US_BACKSLASH = 88] = "US_BACKSLASH", n[n.US_CLOSE_SQUARE_BRACKET = 89] = "US_CLOSE_SQUARE_BRACKET", n[n.US_QUOTE = 90] = "US_QUOTE", n[n.OEM_8 = 91] = "OEM_8", n[n.OEM_102 = 92] = "OEM_102", n[n.NUMPAD_0 = 93] = "NUMPAD_0", n[n.NUMPAD_1 = 94] = "NUMPAD_1", n[n.NUMPAD_2 = 95] = "NUMPAD_2", n[n.NUMPAD_3 = 96] = "NUMPAD_3", n[n.NUMPAD_4 = 97] = "NUMPAD_4", n[n.NUMPAD_5 = 98] = "NUMPAD_5", n[n.NUMPAD_6 = 99] = "NUMPAD_6", n[n.NUMPAD_7 = 100] = "NUMPAD_7", n[n.NUMPAD_8 = 101] = "NUMPAD_8", n[n.NUMPAD_9 = 102] = "NUMPAD_9", n[n.NUMPAD_MULTIPLY = 103] = "NUMPAD_MULTIPLY", n[n.NUMPAD_ADD = 104] = "NUMPAD_ADD", n[n.NUMPAD_SEPARATOR = 105] = "NUMPAD_SEPARATOR", n[n.NUMPAD_SUBTRACT = 106] = "NUMPAD_SUBTRACT", n[n.NUMPAD_DECIMAL = 107] = "NUMPAD_DECIMAL", n[n.NUMPAD_DIVIDE = 108] = "NUMPAD_DIVIDE", n[n.KEY_IN_COMPOSITION = 109] = "KEY_IN_COMPOSITION", n[n.ABNT_C1 = 110] = "ABNT_C1", n[n.ABNT_C2 = 111] = "ABNT_C2", n[n.MAX_VALUE = 112] = "MAX_VALUE";
})(GR || (GR = {}));
var UR;
(function(n) {
  n[n.Hint = 1] = "Hint", n[n.Info = 2] = "Info", n[n.Warning = 4] = "Warning", n[n.Error = 8] = "Error";
})(UR || (UR = {}));
var zR;
(function(n) {
  n[n.Unnecessary = 1] = "Unnecessary", n[n.Deprecated = 2] = "Deprecated";
})(zR || (zR = {}));
var jR;
(function(n) {
  n[n.Inline = 1] = "Inline", n[n.Gutter = 2] = "Gutter";
})(jR || (jR = {}));
var $R;
(function(n) {
  n[n.UNKNOWN = 0] = "UNKNOWN", n[n.TEXTAREA = 1] = "TEXTAREA", n[n.GUTTER_GLYPH_MARGIN = 2] = "GUTTER_GLYPH_MARGIN", n[n.GUTTER_LINE_NUMBERS = 3] = "GUTTER_LINE_NUMBERS", n[n.GUTTER_LINE_DECORATIONS = 4] = "GUTTER_LINE_DECORATIONS", n[n.GUTTER_VIEW_ZONE = 5] = "GUTTER_VIEW_ZONE", n[n.CONTENT_TEXT = 6] = "CONTENT_TEXT", n[n.CONTENT_EMPTY = 7] = "CONTENT_EMPTY", n[n.CONTENT_VIEW_ZONE = 8] = "CONTENT_VIEW_ZONE", n[n.CONTENT_WIDGET = 9] = "CONTENT_WIDGET", n[n.OVERVIEW_RULER = 10] = "OVERVIEW_RULER", n[n.SCROLLBAR = 11] = "SCROLLBAR", n[n.OVERLAY_WIDGET = 12] = "OVERLAY_WIDGET", n[n.OUTSIDE_EDITOR = 13] = "OUTSIDE_EDITOR";
})($R || ($R = {}));
var KR;
(function(n) {
  n[n.TOP_RIGHT_CORNER = 0] = "TOP_RIGHT_CORNER", n[n.BOTTOM_RIGHT_CORNER = 1] = "BOTTOM_RIGHT_CORNER", n[n.TOP_CENTER = 2] = "TOP_CENTER";
})(KR || (KR = {}));
var qR;
(function(n) {
  n[n.Left = 1] = "Left", n[n.Center = 2] = "Center", n[n.Right = 4] = "Right", n[n.Full = 7] = "Full";
})(qR || (qR = {}));
var YR;
(function(n) {
  n[n.Off = 0] = "Off", n[n.On = 1] = "On", n[n.Relative = 2] = "Relative", n[n.Interval = 3] = "Interval", n[n.Custom = 4] = "Custom";
})(YR || (YR = {}));
var XR;
(function(n) {
  n[n.None = 0] = "None", n[n.Text = 1] = "Text", n[n.Blocks = 2] = "Blocks";
})(XR || (XR = {}));
var ZR;
(function(n) {
  n[n.Smooth = 0] = "Smooth", n[n.Immediate = 1] = "Immediate";
})(ZR || (ZR = {}));
var QR;
(function(n) {
  n[n.Auto = 1] = "Auto", n[n.Hidden = 2] = "Hidden", n[n.Visible = 3] = "Visible";
})(QR || (QR = {}));
var JR;
(function(n) {
  n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL";
})(JR || (JR = {}));
var eT;
(function(n) {
  n[n.Invoke = 1] = "Invoke", n[n.TriggerCharacter = 2] = "TriggerCharacter", n[n.ContentChange = 3] = "ContentChange";
})(eT || (eT = {}));
var tT;
(function(n) {
  n[n.File = 0] = "File", n[n.Module = 1] = "Module", n[n.Namespace = 2] = "Namespace", n[n.Package = 3] = "Package", n[n.Class = 4] = "Class", n[n.Method = 5] = "Method", n[n.Property = 6] = "Property", n[n.Field = 7] = "Field", n[n.Constructor = 8] = "Constructor", n[n.Enum = 9] = "Enum", n[n.Interface = 10] = "Interface", n[n.Function = 11] = "Function", n[n.Variable = 12] = "Variable", n[n.Constant = 13] = "Constant", n[n.String = 14] = "String", n[n.Number = 15] = "Number", n[n.Boolean = 16] = "Boolean", n[n.Array = 17] = "Array", n[n.Object = 18] = "Object", n[n.Key = 19] = "Key", n[n.Null = 20] = "Null", n[n.EnumMember = 21] = "EnumMember", n[n.Struct = 22] = "Struct", n[n.Event = 23] = "Event", n[n.Operator = 24] = "Operator", n[n.TypeParameter = 25] = "TypeParameter";
})(tT || (tT = {}));
var iT;
(function(n) {
  n[n.Deprecated = 1] = "Deprecated";
})(iT || (iT = {}));
var nT;
(function(n) {
  n[n.Hidden = 0] = "Hidden", n[n.Blink = 1] = "Blink", n[n.Smooth = 2] = "Smooth", n[n.Phase = 3] = "Phase", n[n.Expand = 4] = "Expand", n[n.Solid = 5] = "Solid";
})(nT || (nT = {}));
var rT;
(function(n) {
  n[n.Line = 1] = "Line", n[n.Block = 2] = "Block", n[n.Underline = 3] = "Underline", n[n.LineThin = 4] = "LineThin", n[n.BlockOutline = 5] = "BlockOutline", n[n.UnderlineThin = 6] = "UnderlineThin";
})(rT || (rT = {}));
var oT;
(function(n) {
  n[n.AlwaysGrowsWhenTypingAtEdges = 0] = "AlwaysGrowsWhenTypingAtEdges", n[n.NeverGrowsWhenTypingAtEdges = 1] = "NeverGrowsWhenTypingAtEdges", n[n.GrowsOnlyWhenTypingBefore = 2] = "GrowsOnlyWhenTypingBefore", n[n.GrowsOnlyWhenTypingAfter = 3] = "GrowsOnlyWhenTypingAfter";
})(oT || (oT = {}));
var sT;
(function(n) {
  n[n.None = 0] = "None", n[n.Same = 1] = "Same", n[n.Indent = 2] = "Indent", n[n.DeepIndent = 3] = "DeepIndent";
})(sT || (sT = {}));
let B_ = class {
  static chord(e, t) {
    return Jne(e, t);
  }
};
B_.CtrlCmd = 2048;
B_.Shift = 1024;
B_.Alt = 512;
B_.WinCtrl = 256;
function qG() {
  return {
    editor: void 0,
    languages: void 0,
    CancellationTokenSource: mh,
    Emitter: q,
    KeyCode: GR,
    KeyMod: B_,
    Position: ie,
    Range: G,
    Selection: Ut,
    SelectionDirection: JR,
    MarkerSeverity: UR,
    MarkerTag: zR,
    Uri: ft,
    Token: JS
  };
}
var Ka;
(function(n) {
  n.serviceIds = /* @__PURE__ */ new Map(), n.DI_TARGET = "$di$target", n.DI_DEPENDENCIES = "$di$dependencies";
  function e(t) {
    return t[n.DI_DEPENDENCIES] || [];
  }
  n.getServiceDependencies = e;
})(Ka || (Ka = {}));
const no = Vt("instantiationService");
function YG(n, e, t, i) {
  e[Ka.DI_TARGET] === e ? e[Ka.DI_DEPENDENCIES].push({ id: n, index: t, optional: i }) : (e[Ka.DI_DEPENDENCIES] = [{ id: n, index: t, optional: i }], e[Ka.DI_TARGET] = e);
}
function Vt(n) {
  if (Ka.serviceIds.has(n))
    return Ka.serviceIds.get(n);
  const e = function(t, i, r) {
    if (arguments.length !== 3)
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    YG(e, t, r, !1);
  };
  return e.toString = () => n, Ka.serviceIds.set(n, e), e;
}
function Cre(n) {
  return function(e, t, i) {
    if (arguments.length !== 3)
      throw new Error("@optional-decorator can only be used to decorate a parameter");
    YG(n, e, i, !0);
  };
}
const mr = Vt("codeEditorService");
class Wd {
  constructor() {
    this._zoomLevel = 0, this._lastZoomLevelChangeTime = 0, this._onDidChangeZoomLevel = new q(), this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event, this._zoomFactor = 1;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  getTimeSinceLastZoomLevelChanged() {
    return Date.now() - this._lastZoomLevelChangeTime;
  }
  getZoomFactor() {
    return this._zoomFactor;
  }
  // --- Pixel Ratio
  getPixelRatio() {
    let e = document.createElement("canvas").getContext("2d"), t = window.devicePixelRatio || 1, i = e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1;
    return t / i;
  }
}
Wd.INSTANCE = new Wd();
function aT() {
  return Wd.INSTANCE.getZoomLevel();
}
function yre() {
  return Wd.INSTANCE.getTimeSinceLastZoomLevelChanged();
}
function wre(n) {
  return Wd.INSTANCE.onDidChangeZoomLevel(n);
}
function bre() {
  return Wd.INSTANCE.getZoomFactor();
}
function hb() {
  return Wd.INSTANCE.getPixelRatio();
}
const H_ = navigator.userAgent, to = H_.indexOf("Firefox") >= 0, wd = H_.indexOf("AppleWebKit") >= 0, db = H_.indexOf("Chrome") >= 0, Vd = !db && H_.indexOf("Safari") >= 0, Sre = !db && !Vd && wd, Xm = H_.indexOf("Android") >= 0, Ere = window.matchMedia && window.matchMedia("(display-mode: standalone)").matches, wt = (n, e, t) => {
  const i = (o) => r.fire(o), r = new q({
    onFirstListenerAdd: () => {
      n.addEventListener(e, i, t);
    },
    onLastListenerRemove: () => {
      n.removeEventListener(e, i, t);
    }
  });
  return r.event;
};
class Dr {
  constructor(e, t, i) {
    const r = (o) => this.emitter.fire(o);
    this.emitter = new q({
      onFirstListenerAdd: () => e.addEventListener(t, r, i),
      onLastListenerRemove: () => e.removeEventListener(t, r, i)
    });
  }
  get event() {
    return this.emitter.event;
  }
  dispose() {
    this.emitter.dispose();
  }
}
function lT(n) {
  return n.preventDefault(), n.stopPropagation(), n;
}
function sye(n) {
  return We.map(n, lT);
}
let XG = new Array(230), sD = new Array(
  112
  /* MAX_VALUE */
);
(function() {
  for (let e = 0; e < sD.length; e++)
    sD[e] = -1;
  function n(e, t) {
    XG[e] = t, sD[t] = e;
  }
  n(
    3,
    7
    /* PauseBreak */
  ), n(
    8,
    1
    /* Backspace */
  ), n(
    9,
    2
    /* Tab */
  ), n(
    13,
    3
    /* Enter */
  ), n(
    16,
    4
    /* Shift */
  ), n(
    17,
    5
    /* Ctrl */
  ), n(
    18,
    6
    /* Alt */
  ), n(
    19,
    7
    /* PauseBreak */
  ), n(
    20,
    8
    /* CapsLock */
  ), n(
    27,
    9
    /* Escape */
  ), n(
    32,
    10
    /* Space */
  ), n(
    33,
    11
    /* PageUp */
  ), n(
    34,
    12
    /* PageDown */
  ), n(
    35,
    13
    /* End */
  ), n(
    36,
    14
    /* Home */
  ), n(
    37,
    15
    /* LeftArrow */
  ), n(
    38,
    16
    /* UpArrow */
  ), n(
    39,
    17
    /* RightArrow */
  ), n(
    40,
    18
    /* DownArrow */
  ), n(
    45,
    19
    /* Insert */
  ), n(
    46,
    20
    /* Delete */
  ), n(
    48,
    21
    /* KEY_0 */
  ), n(
    49,
    22
    /* KEY_1 */
  ), n(
    50,
    23
    /* KEY_2 */
  ), n(
    51,
    24
    /* KEY_3 */
  ), n(
    52,
    25
    /* KEY_4 */
  ), n(
    53,
    26
    /* KEY_5 */
  ), n(
    54,
    27
    /* KEY_6 */
  ), n(
    55,
    28
    /* KEY_7 */
  ), n(
    56,
    29
    /* KEY_8 */
  ), n(
    57,
    30
    /* KEY_9 */
  ), n(
    65,
    31
    /* KEY_A */
  ), n(
    66,
    32
    /* KEY_B */
  ), n(
    67,
    33
    /* KEY_C */
  ), n(
    68,
    34
    /* KEY_D */
  ), n(
    69,
    35
    /* KEY_E */
  ), n(
    70,
    36
    /* KEY_F */
  ), n(
    71,
    37
    /* KEY_G */
  ), n(
    72,
    38
    /* KEY_H */
  ), n(
    73,
    39
    /* KEY_I */
  ), n(
    74,
    40
    /* KEY_J */
  ), n(
    75,
    41
    /* KEY_K */
  ), n(
    76,
    42
    /* KEY_L */
  ), n(
    77,
    43
    /* KEY_M */
  ), n(
    78,
    44
    /* KEY_N */
  ), n(
    79,
    45
    /* KEY_O */
  ), n(
    80,
    46
    /* KEY_P */
  ), n(
    81,
    47
    /* KEY_Q */
  ), n(
    82,
    48
    /* KEY_R */
  ), n(
    83,
    49
    /* KEY_S */
  ), n(
    84,
    50
    /* KEY_T */
  ), n(
    85,
    51
    /* KEY_U */
  ), n(
    86,
    52
    /* KEY_V */
  ), n(
    87,
    53
    /* KEY_W */
  ), n(
    88,
    54
    /* KEY_X */
  ), n(
    89,
    55
    /* KEY_Y */
  ), n(
    90,
    56
    /* KEY_Z */
  ), n(
    93,
    58
    /* ContextMenu */
  ), n(
    96,
    93
    /* NUMPAD_0 */
  ), n(
    97,
    94
    /* NUMPAD_1 */
  ), n(
    98,
    95
    /* NUMPAD_2 */
  ), n(
    99,
    96
    /* NUMPAD_3 */
  ), n(
    100,
    97
    /* NUMPAD_4 */
  ), n(
    101,
    98
    /* NUMPAD_5 */
  ), n(
    102,
    99
    /* NUMPAD_6 */
  ), n(
    103,
    100
    /* NUMPAD_7 */
  ), n(
    104,
    101
    /* NUMPAD_8 */
  ), n(
    105,
    102
    /* NUMPAD_9 */
  ), n(
    106,
    103
    /* NUMPAD_MULTIPLY */
  ), n(
    107,
    104
    /* NUMPAD_ADD */
  ), n(
    108,
    105
    /* NUMPAD_SEPARATOR */
  ), n(
    109,
    106
    /* NUMPAD_SUBTRACT */
  ), n(
    110,
    107
    /* NUMPAD_DECIMAL */
  ), n(
    111,
    108
    /* NUMPAD_DIVIDE */
  ), n(
    112,
    59
    /* F1 */
  ), n(
    113,
    60
    /* F2 */
  ), n(
    114,
    61
    /* F3 */
  ), n(
    115,
    62
    /* F4 */
  ), n(
    116,
    63
    /* F5 */
  ), n(
    117,
    64
    /* F6 */
  ), n(
    118,
    65
    /* F7 */
  ), n(
    119,
    66
    /* F8 */
  ), n(
    120,
    67
    /* F9 */
  ), n(
    121,
    68
    /* F10 */
  ), n(
    122,
    69
    /* F11 */
  ), n(
    123,
    70
    /* F12 */
  ), n(
    124,
    71
    /* F13 */
  ), n(
    125,
    72
    /* F14 */
  ), n(
    126,
    73
    /* F15 */
  ), n(
    127,
    74
    /* F16 */
  ), n(
    128,
    75
    /* F17 */
  ), n(
    129,
    76
    /* F18 */
  ), n(
    130,
    77
    /* F19 */
  ), n(
    144,
    78
    /* NumLock */
  ), n(
    145,
    79
    /* ScrollLock */
  ), n(
    186,
    80
    /* US_SEMICOLON */
  ), n(
    187,
    81
    /* US_EQUAL */
  ), n(
    188,
    82
    /* US_COMMA */
  ), n(
    189,
    83
    /* US_MINUS */
  ), n(
    190,
    84
    /* US_DOT */
  ), n(
    191,
    85
    /* US_SLASH */
  ), n(
    192,
    86
    /* US_BACKTICK */
  ), n(
    193,
    110
    /* ABNT_C1 */
  ), n(
    194,
    111
    /* ABNT_C2 */
  ), n(
    219,
    87
    /* US_OPEN_SQUARE_BRACKET */
  ), n(
    220,
    88
    /* US_BACKSLASH */
  ), n(
    221,
    89
    /* US_CLOSE_SQUARE_BRACKET */
  ), n(
    222,
    90
    /* US_QUOTE */
  ), n(
    223,
    91
    /* OEM_8 */
  ), n(
    226,
    92
    /* OEM_102 */
  ), n(
    229,
    109
    /* KEY_IN_COMPOSITION */
  ), to ? (n(
    59,
    80
    /* US_SEMICOLON */
  ), n(
    107,
    81
    /* US_EQUAL */
  ), n(
    109,
    83
    /* US_MINUS */
  ), kt && n(
    224,
    57
    /* Meta */
  )) : wd && (n(
    91,
    57
    /* Meta */
  ), n(
    kt ? 93 : 92,
    57
    /* Meta */
  ));
})();
function Lre(n) {
  if (n.charCode) {
    let e = String.fromCharCode(n.charCode).toUpperCase();
    return Sp.fromString(e);
  }
  return XG[n.keyCode] || 0;
}
const Dre = kt ? 256 : 2048, Rre = 512, Tre = 1024, Ore = kt ? 2048 : 256;
class Yi {
  constructor(e) {
    this._standardKeyboardEventBrand = !0;
    let t = e;
    this.browserEvent = t, this.target = t.target, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, this.keyCode = Lre(t), this.code = t.code, this.ctrlKey = this.ctrlKey || this.keyCode === 5, this.altKey = this.altKey || this.keyCode === 6, this.shiftKey = this.shiftKey || this.keyCode === 4, this.metaKey = this.metaKey || this.keyCode === 57, this._asKeybinding = this._computeKeybinding(), this._asRuntimeKeybinding = this._computeRuntimeKeybinding();
  }
  preventDefault() {
    this.browserEvent && this.browserEvent.preventDefault && this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent && this.browserEvent.stopPropagation && this.browserEvent.stopPropagation();
  }
  toKeybinding() {
    return this._asRuntimeKeybinding;
  }
  equals(e) {
    return this._asKeybinding === e;
  }
  _computeKeybinding() {
    let e = 0;
    this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode);
    let t = 0;
    return this.ctrlKey && (t |= Dre), this.altKey && (t |= Rre), this.shiftKey && (t |= Tre), this.metaKey && (t |= Ore), t |= e, t;
  }
  _computeRuntimeKeybinding() {
    let e = 0;
    return this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode), new NN(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, e);
  }
}
let uT = !1, Af = null;
function xre(n) {
  if (!n.parent || n.parent === n)
    return null;
  try {
    let e = n.location, t = n.parent.location;
    if (e.origin !== "null" && t.origin !== "null" && (e.protocol !== t.protocol || e.hostname !== t.hostname || e.port !== t.port))
      return uT = !0, null;
  } catch {
    return uT = !0, null;
  }
  return n.parent;
}
class cT {
  /**
   * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).
   * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.
   * To distinguish if at one point the current execution environment is running inside a window with a different origin, see hasDifferentOriginAncestor()
   */
  static getSameOriginWindowChain() {
    if (!Af) {
      Af = [];
      let e = window, t;
      do
        t = xre(e), t ? Af.push({
          window: e,
          iframeElement: e.frameElement || null
        }) : Af.push({
          window: e,
          iframeElement: null
        }), e = t;
      while (e);
    }
    return Af.slice(0);
  }
  /**
   * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.
   * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.
   */
  static hasDifferentOriginAncestor() {
    return Af || this.getSameOriginWindowChain(), uT;
  }
  /**
   * Returns the position of `childWindow` relative to `ancestorWindow`
   */
  static getPositionOfChildWindowRelativeToAncestorWindow(e, t) {
    if (!t || e === t)
      return {
        top: 0,
        left: 0
      };
    let i = 0, r = 0, o = this.getSameOriginWindowChain();
    for (const s of o) {
      if (i += s.window.scrollY, r += s.window.scrollX, s.window === t || !s.iframeElement)
        break;
      let a = s.iframeElement.getBoundingClientRect();
      i += a.top, r += a.left;
    }
    return {
      top: i,
      left: r
    };
  }
}
class pa {
  constructor(e) {
    this.timestamp = Date.now(), this.browserEvent = e, this.leftButton = e.button === 0, this.middleButton = e.button === 1, this.rightButton = e.button === 2, this.buttons = e.buttons, this.target = e.target, this.detail = e.detail || 1, e.type === "dblclick" && (this.detail = 2), this.ctrlKey = e.ctrlKey, this.shiftKey = e.shiftKey, this.altKey = e.altKey, this.metaKey = e.metaKey, typeof e.pageX == "number" ? (this.posx = e.pageX, this.posy = e.pageY) : (this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop);
    let t = cT.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);
    this.posx -= t.left, this.posy -= t.top;
  }
  preventDefault() {
    this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent.stopPropagation();
  }
}
class Yp {
  constructor(e, t = 0, i = 0) {
    if (this.browserEvent = e || null, this.target = e ? e.target || e.targetNode || e.srcElement : null, this.deltaY = i, this.deltaX = t, e) {
      let r = e, o = e;
      if (typeof r.wheelDeltaY < "u")
        this.deltaY = r.wheelDeltaY / 120;
      else if (typeof o.VERTICAL_AXIS < "u" && o.axis === o.VERTICAL_AXIS)
        this.deltaY = -o.detail / 3;
      else if (e.type === "wheel") {
        const s = e;
        s.deltaMode === s.DOM_DELTA_LINE ? to && !kt ? this.deltaY = -e.deltaY / 3 : this.deltaY = -e.deltaY : this.deltaY = -e.deltaY / 40;
      }
      if (typeof r.wheelDeltaX < "u")
        Vd && Ro ? this.deltaX = -(r.wheelDeltaX / 120) : this.deltaX = r.wheelDeltaX / 120;
      else if (typeof o.HORIZONTAL_AXIS < "u" && o.axis === o.HORIZONTAL_AXIS)
        this.deltaX = -e.detail / 3;
      else if (e.type === "wheel") {
        const s = e;
        s.deltaMode === s.DOM_DELTA_LINE ? to && !kt ? this.deltaX = -e.deltaX / 3 : this.deltaX = -e.deltaX : this.deltaX = -e.deltaX / 40;
      }
      this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta && (this.deltaY = e.wheelDelta / 120);
    }
  }
  preventDefault() {
    this.browserEvent && this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent && this.browserEvent.stopPropagation();
  }
}
var fy = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function Nre(n) {
  return !!n && typeof n.then == "function";
}
function ZG(n) {
  const e = new mh(), t = n(e.token), i = new Promise((r, o) => {
    e.token.onCancellationRequested(() => {
      o(ZS());
    }), Promise.resolve(t).then((s) => {
      e.dispose(), r(s);
    }, (s) => {
      e.dispose(), o(s);
    });
  });
  return new class {
    cancel() {
      e.cancel();
    }
    then(r, o) {
      return i.then(r, o);
    }
    catch(r) {
      return this.then(void 0, r);
    }
    finally(r) {
      return i.finally(r);
    }
  }();
}
function aye(n, e, t) {
  return Promise.race([n, new Promise((i) => e.onCancellationRequested(() => i(t)))]);
}
class Ire {
  constructor() {
    this.activePromise = null, this.queuedPromise = null, this.queuedPromiseFactory = null;
  }
  queue(e) {
    if (this.activePromise) {
      if (this.queuedPromiseFactory = e, !this.queuedPromise) {
        const t = () => {
          this.queuedPromise = null;
          const i = this.queue(this.queuedPromiseFactory);
          return this.queuedPromiseFactory = null, i;
        };
        this.queuedPromise = new Promise((i) => {
          this.activePromise.then(t, t).then(i);
        });
      }
      return new Promise((t, i) => {
        this.queuedPromise.then(t, i);
      });
    }
    return this.activePromise = e(), new Promise((t, i) => {
      this.activePromise.then((r) => {
        this.activePromise = null, t(r);
      }, (r) => {
        this.activePromise = null, i(r);
      });
    });
  }
}
class AN {
  constructor(e) {
    this.defaultDelay = e, this.timeout = null, this.completionPromise = null, this.doResolve = null, this.doReject = null, this.task = null;
  }
  trigger(e, t = this.defaultDelay) {
    return this.task = e, this.cancelTimeout(), this.completionPromise || (this.completionPromise = new Promise((i, r) => {
      this.doResolve = i, this.doReject = r;
    }).then(() => {
      if (this.completionPromise = null, this.doResolve = null, this.task) {
        const i = this.task;
        return this.task = null, i();
      }
    })), this.timeout = setTimeout(() => {
      this.timeout = null, this.doResolve && this.doResolve(null);
    }, t), this.completionPromise;
  }
  isTriggered() {
    return this.timeout !== null;
  }
  cancel() {
    this.cancelTimeout(), this.completionPromise && (this.doReject && this.doReject(ZS()), this.completionPromise = null);
  }
  cancelTimeout() {
    this.timeout !== null && (clearTimeout(this.timeout), this.timeout = null);
  }
  dispose() {
    this.cancelTimeout();
  }
}
class Pre {
  constructor(e) {
    this.delayer = new AN(e), this.throttler = new Ire();
  }
  trigger(e, t) {
    return this.delayer.trigger(() => this.throttler.queue(e), t);
  }
  cancel() {
    this.delayer.cancel();
  }
  dispose() {
    this.delayer.dispose();
  }
}
function $v(n, e) {
  return e ? new Promise((t, i) => {
    const r = setTimeout(t, n);
    e.onCancellationRequested(() => {
      clearTimeout(r), i(ZS());
    });
  }) : ZG((t) => $v(n, t));
}
function hT(n, e = 0) {
  const t = setTimeout(n, e);
  return Oi(() => clearTimeout(t));
}
function lye(n, e = (i) => !!i, t = null) {
  let i = 0;
  const r = n.length, o = () => {
    if (i >= r)
      return Promise.resolve(t);
    const s = n[i++];
    return Promise.resolve(s()).then((l) => e(l) ? Promise.resolve(l) : o());
  };
  return o();
}
class oc {
  constructor(e, t) {
    this._token = -1, typeof e == "function" && typeof t == "number" && this.setIfNotSet(e, t);
  }
  dispose() {
    this.cancel();
  }
  cancel() {
    this._token !== -1 && (clearTimeout(this._token), this._token = -1);
  }
  cancelAndSet(e, t) {
    this.cancel(), this._token = setTimeout(() => {
      this._token = -1, e();
    }, t);
  }
  setIfNotSet(e, t) {
    this._token === -1 && (this._token = setTimeout(() => {
      this._token = -1, e();
    }, t));
  }
}
class G_ {
  constructor() {
    this._token = -1;
  }
  dispose() {
    this.cancel();
  }
  cancel() {
    this._token !== -1 && (clearInterval(this._token), this._token = -1);
  }
  cancelAndSet(e, t) {
    this.cancel(), this._token = setInterval(() => {
      e();
    }, t);
  }
}
class ro {
  constructor(e, t) {
    this.timeoutToken = -1, this.runner = e, this.timeout = t, this.timeoutHandler = this.onTimeout.bind(this);
  }
  /**
   * Dispose RunOnceScheduler
   */
  dispose() {
    this.cancel(), this.runner = null;
  }
  /**
   * Cancel current scheduled runner (if any).
   */
  cancel() {
    this.isScheduled() && (clearTimeout(this.timeoutToken), this.timeoutToken = -1);
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */
  schedule(e = this.timeout) {
    this.cancel(), this.timeoutToken = setTimeout(this.timeoutHandler, e);
  }
  get delay() {
    return this.timeout;
  }
  set delay(e) {
    this.timeout = e;
  }
  /**
   * Returns true if scheduled.
   */
  isScheduled() {
    return this.timeoutToken !== -1;
  }
  onTimeout() {
    this.timeoutToken = -1, this.runner && this.doRun();
  }
  doRun() {
    this.runner && this.runner();
  }
}
let dT;
(function() {
  if (typeof requestIdleCallback != "function" || typeof cancelIdleCallback != "function") {
    const n = Object.freeze({
      didTimeout: !0,
      timeRemaining() {
        return 15;
      }
    });
    dT = (e) => {
      const t = setTimeout(() => e(n));
      let i = !1;
      return {
        dispose() {
          i || (i = !0, clearTimeout(t));
        }
      };
    };
  } else
    dT = (n, e) => {
      const t = requestIdleCallback(n, typeof e == "number" ? { timeout: e } : void 0);
      let i = !1;
      return {
        dispose() {
          i || (i = !0, cancelIdleCallback(t));
        }
      };
    };
})();
class QG {
  constructor(e) {
    this._didRun = !1, this._executor = () => {
      try {
        this._value = e();
      } catch (t) {
        this._error = t;
      } finally {
        this._didRun = !0;
      }
    }, this._handle = dT(() => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (this._didRun || (this._handle.dispose(), this._executor()), this._error)
      throw this._error;
    return this._value;
  }
}
var fT;
(function(n) {
  function e(o) {
    return fy(this, void 0, void 0, function* () {
      return typeof Promise.allSettled == "function" ? t(o) : i(o);
    });
  }
  n.allSettled = e;
  function t(o) {
    return fy(this, void 0, void 0, function* () {
      return Promise.allSettled(o);
    });
  }
  function i(o) {
    return fy(this, void 0, void 0, function* () {
      return Promise.all(o.map((s) => s.then((a) => ({ status: "fulfilled", value: a }), (a) => ({ status: "rejected", reason: a }))));
    });
  }
  function r(o) {
    return fy(this, void 0, void 0, function* () {
      let s;
      const a = yield Promise.all(o.map((l) => l.then((u) => u, (u) => {
        s || (s = u);
      })));
      if (typeof s < "u")
        throw s;
      return a;
    });
  }
  n.settled = r;
})(fT || (fT = {}));
var vi;
(function(n) {
  n.inMemory = "inmemory", n.vscode = "vscode", n.internal = "private", n.walkThrough = "walkThrough", n.walkThroughSnippet = "walkThroughSnippet", n.http = "http", n.https = "https", n.file = "file", n.mailto = "mailto", n.untitled = "untitled", n.data = "data", n.command = "command", n.vscodeRemote = "vscode-remote", n.vscodeRemoteResource = "vscode-remote-resource", n.userData = "vscode-userdata", n.vscodeCustomEditor = "vscode-custom-editor", n.vscodeNotebook = "vscode-notebook", n.vscodeNotebookCell = "vscode-notebook-cell", n.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", n.vscodeNotebookCellOutput = "vscode-notebook-cell-output", n.vscodeSettings = "vscode-settings", n.vscodeWorkspaceTrust = "vscode-workspace-trust", n.vscodeTerminal = "vscode-terminal", n.webviewPanel = "webview-panel", n.vscodeWebview = "vscode-webview", n.extension = "extension", n.vscodeFileResource = "vscode-file", n.tmp = "tmp";
})(vi || (vi = {}));
class Are {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null;
  }
  setPreferredWebSchema(e) {
    this._preferredWebSchema = e;
  }
  rewrite(e) {
    if (this._delegate)
      return this._delegate(e);
    const t = e.authority;
    let i = this._hosts[t];
    i && i.indexOf(":") !== -1 && (i = `[${i}]`);
    const r = this._ports[t], o = this._connectionTokens[t];
    let s = `path=${encodeURIComponent(e.path)}`;
    return typeof o == "string" && (s += `&tkn=${encodeURIComponent(o)}`), ft.from({
      scheme: XS ? this._preferredWebSchema : vi.vscodeRemoteResource,
      authority: `${i}:${r}`,
      path: "/vscode-remote-resource",
      query: s
    });
  }
}
const JG = new Are();
class Mre {
  constructor() {
    this.FALLBACK_AUTHORITY = "vscode-app";
  }
  asBrowserUri(e, t, i) {
    const r = this.toUri(e, t);
    return r.scheme === vi.vscodeRemote ? JG.rewrite(r) : cv && (i || sne) && r.scheme === vi.file ? r.with({
      scheme: vi.vscodeFileResource,
      // We need to provide an authority here so that it can serve
      // as origin for network and loading matters in chromium.
      // If the URI is not coming with an authority already, we
      // add our own
      authority: r.authority || this.FALLBACK_AUTHORITY,
      query: null,
      fragment: null
    }) : r;
  }
  toUri(e, t) {
    return ft.isUri(e) ? e : ft.parse(t.toUrl(e));
  }
}
const Fre = new Mre(), tE = {
  clipboard: {
    writeText: cv || document.queryCommandSupported && document.queryCommandSupported("copy") || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
    readText: cv || !!(navigator && navigator.clipboard && navigator.clipboard.readText)
  },
  keyboard: (() => cv || Ere ? 0 : navigator.keyboard || Vd ? 1 : 2)(),
  // 'ontouchstart' in window always evaluates to true with typescript's modern typings. This causes `window` to be
  // `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast
  touch: "ontouchstart" in window || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0,
  pointerEvents: window.PointerEvent && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0 || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0)
};
function Ps(n) {
  for (; n.firstChild; )
    n.firstChild.remove();
}
function e5(n) {
  var e;
  return (e = n == null ? void 0 : n.isConnected) !== null && e !== void 0 ? e : !1;
}
class kre {
  constructor(e, t, i, r) {
    this._node = e, this._type = t, this._handler = i, this._options = r || !1, this._node.addEventListener(this._type, this._handler, this._options);
  }
  dispose() {
    this._handler && (this._node.removeEventListener(this._type, this._handler, this._options), this._node = null, this._handler = null);
  }
}
function be(n, e, t, i) {
  return new kre(n, e, t, i);
}
function t5(n) {
  return function(e) {
    return n(new pa(e));
  };
}
function Wre(n) {
  return function(e) {
    return n(new Yi(e));
  };
}
let io = function(e, t, i, r) {
  let o = i;
  return t === "click" || t === "mousedown" ? o = t5(i) : (t === "keydown" || t === "keypress" || t === "keyup") && (o = Wre(i)), be(e, t, o, r);
}, uye = function(e, t, i) {
  let r = t5(t);
  return Vre(e, r, i);
};
function Vre(n, e, t) {
  return be(n, Tg && tE.pointerEvents ? Ge.POINTER_DOWN : Ge.MOUSE_DOWN, e, t);
}
function cye(n, e, t) {
  return be(n, Tg && tE.pointerEvents ? Ge.POINTER_UP : Ge.MOUSE_UP, e, t);
}
function i5(n, e) {
  return be(n, "mouseout", (t) => {
    let i = t.relatedTarget;
    for (; i && i !== n; )
      i = i.parentNode;
    i !== n && e(t);
  });
}
function Bre(n, e) {
  return be(n, "pointerout", (t) => {
    let i = t.relatedTarget;
    for (; i && i !== n; )
      i = i.parentNode;
    i !== n && e(t);
  });
}
let aD = null;
function Hre(n) {
  if (!aD) {
    const e = (t) => setTimeout(() => t((/* @__PURE__ */ new Date()).getTime()), 0);
    aD = self.requestAnimationFrame || self.msRequestAnimationFrame || self.webkitRequestAnimationFrame || self.mozRequestAnimationFrame || self.oRequestAnimationFrame || e;
  }
  return aD.call(self, n);
}
let n5, Zl;
class lD {
  constructor(e, t = 0) {
    this._runner = e, this.priority = t, this._canceled = !1;
  }
  dispose() {
    this._canceled = !0;
  }
  execute() {
    if (!this._canceled)
      try {
        this._runner();
      } catch (e) {
        Pi(e);
      }
  }
  // Sort by priority (largest to lowest)
  static sort(e, t) {
    return t.priority - e.priority;
  }
}
(function() {
  let n = [], e = null, t = !1, i = !1, r = () => {
    for (t = !1, e = n, n = [], i = !0; e.length > 0; )
      e.sort(lD.sort), e.shift().execute();
    i = !1;
  };
  Zl = (o, s = 0) => {
    let a = new lD(o, s);
    return n.push(a), t || (t = !0, Hre(r)), a;
  }, n5 = (o, s) => {
    if (i) {
      let a = new lD(o, s);
      return e.push(a), a;
    } else
      return Zl(o, s);
  };
})();
const Gre = 8, Ure = function(n, e) {
  return e;
};
class zre extends Ce {
  constructor(e, t, i, r = Ure, o = Gre) {
    super();
    let s = null, a = 0, l = this._register(new oc()), u = () => {
      a = (/* @__PURE__ */ new Date()).getTime(), i(s), s = null;
    };
    this._register(be(e, t, (c) => {
      s = r(s, c);
      let h = (/* @__PURE__ */ new Date()).getTime() - a;
      h >= o ? (l.cancel(), u()) : l.setIfNotSet(u, o - h);
    }));
  }
}
function MN(n, e, t, i, r) {
  return new zre(n, e, t, i, r);
}
function r5(n) {
  return document.defaultView.getComputedStyle(n, null);
}
function o5(n) {
  if (n !== document.body)
    return new $a(n.clientWidth, n.clientHeight);
  if (Tg && window.visualViewport)
    return new $a(window.visualViewport.width, window.visualViewport.height);
  if (window.innerWidth && window.innerHeight)
    return new $a(window.innerWidth, window.innerHeight);
  if (document.body && document.body.clientWidth && document.body.clientHeight)
    return new $a(document.body.clientWidth, document.body.clientHeight);
  if (document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight)
    return new $a(document.documentElement.clientWidth, document.documentElement.clientHeight);
  throw new Error("Unable to figure out browser width and height");
}
class Ii {
  // Adapted from WinJS
  // Converts a CSS positioning string for the specified element to pixels.
  static convertToPixels(e, t) {
    return parseFloat(t) || 0;
  }
  static getDimension(e, t, i) {
    let r = r5(e), o = "0";
    return r && (r.getPropertyValue ? o = r.getPropertyValue(t) : o = r.getAttribute(i)), Ii.convertToPixels(e, o);
  }
  static getBorderLeftWidth(e) {
    return Ii.getDimension(e, "border-left-width", "borderLeftWidth");
  }
  static getBorderRightWidth(e) {
    return Ii.getDimension(e, "border-right-width", "borderRightWidth");
  }
  static getBorderTopWidth(e) {
    return Ii.getDimension(e, "border-top-width", "borderTopWidth");
  }
  static getBorderBottomWidth(e) {
    return Ii.getDimension(e, "border-bottom-width", "borderBottomWidth");
  }
  static getPaddingLeft(e) {
    return Ii.getDimension(e, "padding-left", "paddingLeft");
  }
  static getPaddingRight(e) {
    return Ii.getDimension(e, "padding-right", "paddingRight");
  }
  static getPaddingTop(e) {
    return Ii.getDimension(e, "padding-top", "paddingTop");
  }
  static getPaddingBottom(e) {
    return Ii.getDimension(e, "padding-bottom", "paddingBottom");
  }
  static getMarginLeft(e) {
    return Ii.getDimension(e, "margin-left", "marginLeft");
  }
  static getMarginTop(e) {
    return Ii.getDimension(e, "margin-top", "marginTop");
  }
  static getMarginRight(e) {
    return Ii.getDimension(e, "margin-right", "marginRight");
  }
  static getMarginBottom(e) {
    return Ii.getDimension(e, "margin-bottom", "marginBottom");
  }
}
class $a {
  constructor(e, t) {
    this.width = e, this.height = t;
  }
  with(e = this.width, t = this.height) {
    return e !== this.width || t !== this.height ? new $a(e, t) : this;
  }
  static is(e) {
    return typeof e == "object" && typeof e.height == "number" && typeof e.width == "number";
  }
  static lift(e) {
    return e instanceof $a ? e : new $a(e.width, e.height);
  }
  static equals(e, t) {
    return e === t ? !0 : !e || !t ? !1 : e.width === t.width && e.height === t.height;
  }
}
function jre(n) {
  let e = n.offsetParent, t = n.offsetTop, i = n.offsetLeft;
  for (; (n = n.parentNode) !== null && n !== document.body && n !== document.documentElement; ) {
    t -= n.scrollTop;
    const r = a5(n) ? null : r5(n);
    r && (i -= r.direction !== "rtl" ? n.scrollLeft : -n.scrollLeft), n === e && (i += Ii.getBorderLeftWidth(n), t += Ii.getBorderTopWidth(n), t += n.offsetTop, i += n.offsetLeft, e = n.offsetParent);
  }
  return {
    left: i,
    top: t
  };
}
function hye(n, e, t) {
  typeof e == "number" && (n.style.width = `${e}px`), typeof t == "number" && (n.style.height = `${t}px`);
}
function qa(n) {
  let e = n.getBoundingClientRect();
  return {
    left: e.left + Ku.scrollX,
    top: e.top + Ku.scrollY,
    width: e.width,
    height: e.height
  };
}
const Ku = new class {
  get scrollX() {
    return typeof window.scrollX == "number" ? window.scrollX : document.body.scrollLeft + document.documentElement.scrollLeft;
  }
  get scrollY() {
    return typeof window.scrollY == "number" ? window.scrollY : document.body.scrollTop + document.documentElement.scrollTop;
  }
}();
function pT(n) {
  let e = Ii.getMarginLeft(n) + Ii.getMarginRight(n);
  return n.offsetWidth + e;
}
function uD(n) {
  let e = Ii.getBorderLeftWidth(n) + Ii.getBorderRightWidth(n), t = Ii.getPaddingLeft(n) + Ii.getPaddingRight(n);
  return n.offsetWidth - e - t;
}
function $re(n) {
  let e = Ii.getBorderTopWidth(n) + Ii.getBorderBottomWidth(n), t = Ii.getPaddingTop(n) + Ii.getPaddingBottom(n);
  return n.offsetHeight - e - t;
}
function gT(n) {
  let e = Ii.getMarginTop(n) + Ii.getMarginBottom(n);
  return n.offsetHeight + e;
}
function Ju(n, e) {
  for (; n; ) {
    if (n === e)
      return !0;
    n = n.parentNode;
  }
  return !1;
}
function s5(n, e, t) {
  for (; n && n.nodeType === n.ELEMENT_NODE; ) {
    if (n.classList.contains(e))
      return n;
    if (t) {
      if (typeof t == "string") {
        if (n.classList.contains(t))
          return null;
      } else if (n === t)
        return null;
    }
    n = n.parentNode;
  }
  return null;
}
function tk(n, e, t) {
  return !!s5(n, e, t);
}
function a5(n) {
  return n && !!n.host && !!n.mode;
}
function FN(n) {
  return !!U_(n);
}
function U_(n) {
  for (; n.parentNode; ) {
    if (n === document.body)
      return null;
    n = n.parentNode;
  }
  return a5(n) ? n : null;
}
function Lp() {
  let n = document.activeElement;
  for (; n != null && n.shadowRoot; )
    n = n.shadowRoot.activeElement;
  return n;
}
function As(n = document.getElementsByTagName("head")[0]) {
  let e = document.createElement("style");
  return e.type = "text/css", e.media = "screen", n.appendChild(e), e;
}
let cD = null;
function l5() {
  return cD || (cD = As()), cD;
}
function Kre(n) {
  var e, t;
  return !((e = n == null ? void 0 : n.sheet) === null || e === void 0) && e.rules ? n.sheet.rules : !((t = n == null ? void 0 : n.sheet) === null || t === void 0) && t.cssRules ? n.sheet.cssRules : [];
}
function ik(n, e, t = l5()) {
  !t || !e || t.sheet.insertRule(n + "{" + e + "}", 0);
}
function u5(n, e = l5()) {
  if (!e)
    return;
  let t = Kre(e), i = [];
  for (let r = 0; r < t.length; r++)
    t[r].selectorText.indexOf(n) !== -1 && i.push(r);
  for (let r = i.length - 1; r >= 0; r--)
    e.sheet.deleteRule(i[r]);
}
function c5(n) {
  return typeof HTMLElement == "object" ? n instanceof HTMLElement : n && typeof n == "object" && n.nodeType === 1 && typeof n.nodeName == "string";
}
const Ge = {
  // Mouse
  CLICK: "click",
  AUXCLICK: "auxclick",
  DBLCLICK: "dblclick",
  MOUSE_UP: "mouseup",
  MOUSE_DOWN: "mousedown",
  MOUSE_OVER: "mouseover",
  MOUSE_MOVE: "mousemove",
  MOUSE_OUT: "mouseout",
  MOUSE_ENTER: "mouseenter",
  MOUSE_LEAVE: "mouseleave",
  MOUSE_WHEEL: "wheel",
  POINTER_UP: "pointerup",
  POINTER_DOWN: "pointerdown",
  POINTER_MOVE: "pointermove",
  CONTEXT_MENU: "contextmenu",
  WHEEL: "wheel",
  // Keyboard
  KEY_DOWN: "keydown",
  KEY_PRESS: "keypress",
  KEY_UP: "keyup",
  // HTML Document
  LOAD: "load",
  BEFORE_UNLOAD: "beforeunload",
  UNLOAD: "unload",
  ABORT: "abort",
  ERROR: "error",
  RESIZE: "resize",
  SCROLL: "scroll",
  FULLSCREEN_CHANGE: "fullscreenchange",
  WK_FULLSCREEN_CHANGE: "webkitfullscreenchange",
  // Form
  SELECT: "select",
  CHANGE: "change",
  SUBMIT: "submit",
  RESET: "reset",
  FOCUS: "focus",
  FOCUS_IN: "focusin",
  FOCUS_OUT: "focusout",
  BLUR: "blur",
  INPUT: "input",
  // Local Storage
  STORAGE: "storage",
  // Drag
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "drop",
  DRAG_END: "dragend",
  // Animation
  ANIMATION_START: wd ? "webkitAnimationStart" : "animationstart",
  ANIMATION_END: wd ? "webkitAnimationEnd" : "animationend",
  ANIMATION_ITERATION: wd ? "webkitAnimationIteration" : "animationiteration"
}, gi = {
  stop: function(n, e) {
    n.preventDefault ? n.preventDefault() : n.returnValue = !1, e && (n.stopPropagation ? n.stopPropagation() : n.cancelBubble = !0);
  }
};
function qre(n) {
  let e = [];
  for (let t = 0; n && n.nodeType === n.ELEMENT_NODE; t++)
    e[t] = n.scrollTop, n = n.parentNode;
  return e;
}
function Yre(n, e) {
  for (let t = 0; n && n.nodeType === n.ELEMENT_NODE; t++)
    n.scrollTop !== e[t] && (n.scrollTop = e[t]), n = n.parentNode;
}
class Xre extends Ce {
  constructor(e) {
    super(), this._onDidFocus = this._register(new q()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new q()), this.onDidBlur = this._onDidBlur.event;
    let t = Ju(document.activeElement, e), i = !1;
    const r = () => {
      i = !1, t || (t = !0, this._onDidFocus.fire());
    }, o = () => {
      t && (i = !0, window.setTimeout(() => {
        i && (i = !1, t = !1, this._onDidBlur.fire());
      }, 0));
    };
    this._refreshStateHandler = () => {
      Ju(document.activeElement, e) !== t && (t ? o() : r());
    }, this._register(wt(e, Ge.FOCUS, !0)(r)), this._register(wt(e, Ge.BLUR, !0)(o));
  }
}
function iE(n) {
  return new Xre(n);
}
function Me(n, ...e) {
  if (n.append(...e), e.length === 1 && typeof e[0] != "string")
    return e[0];
}
function nE(n, ...e) {
  n.innerText = "", Me(n, ...e);
}
const Zre = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
var Kv;
(function(n) {
  n.HTML = "http://www.w3.org/1999/xhtml", n.SVG = "http://www.w3.org/2000/svg";
})(Kv || (Kv = {}));
function h5(n, e, t, ...i) {
  let r = Zre.exec(e);
  if (!r)
    throw new Error("Bad use of emmet");
  t = Object.assign({}, t || {});
  let o = r[1] || "div", s;
  return n !== Kv.HTML ? s = document.createElementNS(n, o) : s = document.createElement(o), r[3] && (s.id = r[3]), r[4] && (s.className = r[4].replace(/\./g, " ").trim()), Object.keys(t).forEach((a) => {
    const l = t[a];
    typeof l > "u" || (/^on\w+$/.test(a) ? s[a] = l : a === "selected" ? l && s.setAttribute(a, "true") : s.setAttribute(a, l));
  }), s.append(...i), s;
}
function Xe(n, e, ...t) {
  return h5(Kv.HTML, n, e, ...t);
}
Xe.SVG = function(n, e, ...t) {
  return h5(Kv.SVG, n, e, ...t);
};
function d5(...n) {
  for (let e of n)
    e.style.display = "", e.removeAttribute("aria-hidden");
}
function nk(...n) {
  for (let e of n)
    e.style.display = "none", e.setAttribute("aria-hidden", "true");
}
function rk(n) {
  return Array.prototype.slice.call(document.getElementsByTagName(n), 0);
}
function ok(n) {
  const e = window.devicePixelRatio * n;
  return Math.max(1, Math.floor(e)) / window.devicePixelRatio;
}
function f5(n) {
  window.open(n, "_blank", "noopener");
}
function Qre(n) {
  const e = () => {
    n(), t = Zl(e);
  };
  let t = Zl(e);
  return Oi(() => t.dispose());
}
JG.setPreferredWebSchema(/^https:/.test(window.location.href) ? "https" : "http");
function qv(n) {
  return n ? `url('${Fre.asBrowserUri(n).toString(!0).replace(/'/g, "%27")}')` : "url('')";
}
function sk(n) {
  return `'${n.replace(/'/g, "%27")}'`;
}
class rp extends q {
  constructor() {
    super(), this._subscriptions = new dt(), this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    }, this._subscriptions.add(wt(window, "keydown", !0)((e) => {
      if (e.defaultPrevented)
        return;
      const t = new Yi(e);
      if (!(t.keyCode === 6 && e.repeat)) {
        if (e.altKey && !this._keyStatus.altKey)
          this._keyStatus.lastKeyPressed = "alt";
        else if (e.ctrlKey && !this._keyStatus.ctrlKey)
          this._keyStatus.lastKeyPressed = "ctrl";
        else if (e.metaKey && !this._keyStatus.metaKey)
          this._keyStatus.lastKeyPressed = "meta";
        else if (e.shiftKey && !this._keyStatus.shiftKey)
          this._keyStatus.lastKeyPressed = "shift";
        else if (t.keyCode !== 6)
          this._keyStatus.lastKeyPressed = void 0;
        else
          return;
        this._keyStatus.altKey = e.altKey, this._keyStatus.ctrlKey = e.ctrlKey, this._keyStatus.metaKey = e.metaKey, this._keyStatus.shiftKey = e.shiftKey, this._keyStatus.lastKeyPressed && (this._keyStatus.event = e, this.fire(this._keyStatus));
      }
    })), this._subscriptions.add(wt(window, "keyup", !0)((e) => {
      e.defaultPrevented || (!e.altKey && this._keyStatus.altKey ? this._keyStatus.lastKeyReleased = "alt" : !e.ctrlKey && this._keyStatus.ctrlKey ? this._keyStatus.lastKeyReleased = "ctrl" : !e.metaKey && this._keyStatus.metaKey ? this._keyStatus.lastKeyReleased = "meta" : !e.shiftKey && this._keyStatus.shiftKey ? this._keyStatus.lastKeyReleased = "shift" : this._keyStatus.lastKeyReleased = void 0, this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased && (this._keyStatus.lastKeyPressed = void 0), this._keyStatus.altKey = e.altKey, this._keyStatus.ctrlKey = e.ctrlKey, this._keyStatus.metaKey = e.metaKey, this._keyStatus.shiftKey = e.shiftKey, this._keyStatus.lastKeyReleased && (this._keyStatus.event = e, this.fire(this._keyStatus)));
    })), this._subscriptions.add(wt(document.body, "mousedown", !0)((e) => {
      this._keyStatus.lastKeyPressed = void 0;
    })), this._subscriptions.add(wt(document.body, "mouseup", !0)((e) => {
      this._keyStatus.lastKeyPressed = void 0;
    })), this._subscriptions.add(wt(document.body, "mousemove", !0)((e) => {
      e.buttons && (this._keyStatus.lastKeyPressed = void 0);
    })), this._subscriptions.add(wt(window, "blur")((e) => {
      this.resetKeyStatus();
    }));
  }
  get keyStatus() {
    return this._keyStatus;
  }
  /**
   * Allows to explicitly reset the key status based on more knowledge (#109062)
   */
  resetKeyStatus() {
    this.doResetKeyStatus(), this.fire(this._keyStatus);
  }
  doResetKeyStatus() {
    this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    };
  }
  static getInstance() {
    return rp.instance || (rp.instance = new rp()), rp.instance;
  }
  dispose() {
    super.dispose(), this._subscriptions.dispose();
  }
}
function Jre(n, e) {
  const t = window.matchMedia(n);
  typeof t.addEventListener == "function" ? t.addEventListener("change", e) : t.addListener(e);
}
function eoe(n) {
  return !n || typeof n != "string" ? !0 : n.trim().length === 0;
}
const toe = /{(\d+)}/g;
function Fl(n, ...e) {
  return e.length === 0 ? n : n.replace(toe, function(t, i) {
    const r = parseInt(i, 10);
    return isNaN(r) || r < 0 || r >= e.length ? t : e[r];
  });
}
function p5(n) {
  return n.replace(/[<>&]/g, function(e) {
    switch (e) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      default:
        return e;
    }
  });
}
function Xp(n) {
  return n.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function dye(n, e = " ") {
  const t = kN(n, e);
  return g5(t, e);
}
function kN(n, e) {
  if (!n || !e)
    return n;
  const t = e.length;
  if (t === 0 || n.length === 0)
    return n;
  let i = 0;
  for (; n.indexOf(e, i) === i; )
    i = i + t;
  return n.substring(i);
}
function g5(n, e) {
  if (!n || !e)
    return n;
  const t = e.length, i = n.length;
  if (t === 0 || i === 0)
    return n;
  let r = i, o = -1;
  for (; o = n.lastIndexOf(e, r - 1), !(o === -1 || o + t !== r); ) {
    if (o === 0)
      return "";
    r = o;
  }
  return n.substring(0, r);
}
function ioe(n) {
  return n.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
}
function fye(n) {
  return n.replace(/\*/g, "");
}
function m5(n, e, t = {}) {
  if (!n)
    throw new Error("Cannot create regex from empty string");
  e || (n = Xp(n)), t.wholeWord && (/\B/.test(n.charAt(0)) || (n = "\\b" + n), /\B/.test(n.charAt(n.length - 1)) || (n = n + "\\b"));
  let i = "";
  return t.global && (i += "g"), t.matchCase || (i += "i"), t.multiline && (i += "m"), t.unicode && (i += "u"), new RegExp(n, i);
}
function noe(n) {
  return n.source === "^" || n.source === "^$" || n.source === "$" || n.source === "^\\s*$" ? !1 : !!(n.exec("") && n.lastIndex === 0);
}
function hD(n) {
  return (n.global ? "g" : "") + (n.ignoreCase ? "i" : "") + (n.multiline ? "m" : "") + (n.unicode ? "u" : "");
}
function z_(n) {
  return n.split(/\r\n|\r|\n/);
}
function Os(n) {
  for (let e = 0, t = n.length; e < t; e++) {
    const i = n.charCodeAt(e);
    if (i !== 32 && i !== 9)
      return e;
  }
  return -1;
}
function Fr(n, e = 0, t = n.length) {
  for (let i = e; i < t; i++) {
    const r = n.charCodeAt(i);
    if (r !== 32 && r !== 9)
      return n.substring(e, i);
  }
  return n.substring(e, t);
}
function Ng(n, e = n.length - 1) {
  for (let t = e; t >= 0; t--) {
    const i = n.charCodeAt(t);
    if (i !== 32 && i !== 9)
      return t;
  }
  return -1;
}
function mT(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
function WN(n, e, t = 0, i = n.length, r = 0, o = e.length) {
  for (; t < i && r < o; t++, r++) {
    let l = n.charCodeAt(t), u = e.charCodeAt(r);
    if (l < u)
      return -1;
    if (l > u)
      return 1;
  }
  const s = i - t, a = o - r;
  return s < a ? -1 : s > a ? 1 : 0;
}
function ak(n, e) {
  return VN(n, e, 0, n.length, 0, e.length);
}
function VN(n, e, t = 0, i = n.length, r = 0, o = e.length) {
  for (; t < i && r < o; t++, r++) {
    let l = n.charCodeAt(t), u = e.charCodeAt(r);
    if (l === u)
      continue;
    const c = l - u;
    if (!(c === 32 && Iu(u)) && !(c === -32 && Iu(l)))
      return ad(l) && ad(u) ? c : WN(n.toLowerCase(), e.toLowerCase(), t, i, r, o);
  }
  const s = i - t, a = o - r;
  return s < a ? -1 : s > a ? 1 : 0;
}
function ad(n) {
  return n >= 97 && n <= 122;
}
function Iu(n) {
  return n >= 65 && n <= 90;
}
function lk(n) {
  return ad(n) || Iu(n);
}
function Zm(n, e) {
  return n.length === e.length && v5(n, e);
}
function v5(n, e, t = n.length) {
  for (let i = 0; i < t; i++) {
    const r = n.charCodeAt(i), o = e.charCodeAt(i);
    if (r !== o) {
      if (lk(r) && lk(o)) {
        const s = Math.abs(r - o);
        if (s !== 0 && s !== 32)
          return !1;
      } else if (String.fromCharCode(r).toLowerCase() !== String.fromCharCode(o).toLowerCase())
        return !1;
    }
  }
  return !0;
}
function BN(n, e) {
  const t = e.length;
  return e.length > n.length ? !1 : v5(n, e, t);
}
function uk(n, e) {
  let t, i = Math.min(n.length, e.length);
  for (t = 0; t < i; t++)
    if (n.charCodeAt(t) !== e.charCodeAt(t))
      return t;
  return i;
}
function ck(n, e) {
  let t, i = Math.min(n.length, e.length);
  const r = n.length - 1, o = e.length - 1;
  for (t = 0; t < i; t++)
    if (n.charCodeAt(r - t) !== e.charCodeAt(o - t))
      return t;
  return i;
}
function Kn(n) {
  return 55296 <= n && n <= 56319;
}
function Yv(n) {
  return 56320 <= n && n <= 57343;
}
function HN(n, e) {
  return (n - 55296 << 10) + (e - 56320) + 65536;
}
function Pu(n, e, t) {
  const i = n.charCodeAt(t);
  if (Kn(i) && t + 1 < e) {
    const r = n.charCodeAt(t + 1);
    if (Yv(r))
      return HN(i, r);
  }
  return i;
}
function Dp(n, e) {
  const t = n.charCodeAt(e - 1);
  if (Yv(t) && e > 1) {
    const i = n.charCodeAt(e - 2);
    if (Kn(i))
      return HN(i, t);
  }
  return t;
}
function fb(n, e) {
  const t = ju.getInstance(), i = e, r = n.length, o = Pu(n, r, e);
  e += o >= 65536 ? 2 : 1;
  let s = t.getGraphemeBreakType(o);
  for (; e < r; ) {
    const a = Pu(n, r, e), l = t.getGraphemeBreakType(a);
    if (dv(s, l))
      break;
    e += a >= 65536 ? 2 : 1, s = l;
  }
  return e - i;
}
function roe(n, e) {
  const t = ju.getInstance(), i = e, r = Dp(n, e);
  e -= r >= 65536 ? 2 : 1;
  let o = t.getGraphemeBreakType(r);
  for (; e > 0; ) {
    const s = Dp(n, e), a = t.getGraphemeBreakType(s);
    if (dv(a, o))
      break;
    e -= s >= 65536 ? 2 : 1, o = a;
  }
  return i - e;
}
function ooe(n) {
  const e = n.byteLength, t = [];
  let i = 0;
  for (; i < e; ) {
    const r = n[i];
    let o;
    if (r >= 240 && i + 3 < e ? o = (n[i++] & 7) << 18 >>> 0 | (n[i++] & 63) << 12 >>> 0 | (n[i++] & 63) << 6 >>> 0 | (n[i++] & 63) << 0 >>> 0 : r >= 224 && i + 2 < e ? o = (n[i++] & 15) << 12 >>> 0 | (n[i++] & 63) << 6 >>> 0 | (n[i++] & 63) << 0 >>> 0 : r >= 192 && i + 1 < e ? o = (n[i++] & 31) << 6 >>> 0 | (n[i++] & 63) << 0 >>> 0 : o = n[i++], o >= 0 && o <= 55295 || o >= 57344 && o <= 65535)
      t.push(String.fromCharCode(o));
    else if (o >= 65536 && o <= 1114111) {
      const s = o - 65536, a = 55296 + ((s & 1047552) >>> 10), l = 56320 + ((s & 1023) >>> 0);
      t.push(String.fromCharCode(a)), t.push(String.fromCharCode(l));
    } else
      t.push(String.fromCharCode(65533));
  }
  return t.join("");
}
const soe = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
function GN(n) {
  return soe.test(n);
}
const aoe = /(?:[\u231A\u231B\u23F0\u23F3\u2600-\u27BF\u2B50\u2B55]|\uD83C[\uDDE6-\uDDFF\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F\uDE80-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD00-\uDDFF\uDE70-\uDED6])/;
function loe(n) {
  return aoe.test(n);
}
const uoe = /^[\t\n\r\x20-\x7E]*$/;
function _5(n) {
  return uoe.test(n);
}
const C5 = /[\u2028\u2029]/;
function y5(n) {
  return C5.test(n);
}
function coe(n) {
  for (let e = 0, t = n.length; e < t; e++)
    if (el(n.charCodeAt(e)))
      return !0;
  return !1;
}
function el(n) {
  return n = +n, n >= 11904 && n <= 55215 || n >= 63744 && n <= 64255 || n >= 65281 && n <= 65374;
}
function hv(n) {
  return n >= 127462 && n <= 127487 || n === 8986 || n === 8987 || n === 9200 || n === 9203 || n >= 9728 && n <= 10175 || n === 11088 || n === 11093 || n >= 127744 && n <= 128591 || n >= 128640 && n <= 128764 || n >= 128992 && n <= 129003 || n >= 129280 && n <= 129535 || n >= 129648 && n <= 129750;
}
const hoe = String.fromCharCode(
  65279
  /* UTF8_BOM */
);
function UN(n) {
  return !!(n && n.length > 0 && n.charCodeAt(0) === 65279);
}
function pye(n, e = !1) {
  return n ? (e && (n = n.replace(/\\./g, "")), n.toLowerCase() !== n) : !1;
}
function w5(n) {
  return n = n % (2 * 26), n < 26 ? String.fromCharCode(97 + n) : String.fromCharCode(65 + n - 26);
}
function Mf(n) {
  return ju.getInstance().getGraphemeBreakType(n);
}
function dv(n, e) {
  return n === 0 ? e !== 5 && e !== 7 : n === 2 && e === 3 ? !1 : n === 4 || n === 2 || n === 3 || e === 4 || e === 2 || e === 3 ? !0 : !(n === 8 && (e === 8 || e === 9 || e === 11 || e === 12) || (n === 11 || n === 9) && (e === 9 || e === 10) || (n === 12 || n === 10) && e === 10 || e === 5 || e === 13 || e === 7 || n === 1 || n === 13 && e === 14 || n === 6 && e === 6);
}
class ju {
  constructor() {
    this._data = doe();
  }
  static getInstance() {
    return ju._INSTANCE || (ju._INSTANCE = new ju()), ju._INSTANCE;
  }
  getGraphemeBreakType(e) {
    if (e < 32)
      return e === 10 ? 3 : e === 13 ? 2 : 4;
    if (e < 127)
      return 0;
    const t = this._data, i = t.length / 3;
    let r = 1;
    for (; r <= i; )
      if (e < t[3 * r])
        r = 2 * r;
      else if (e > t[3 * r + 1])
        r = 2 * r + 1;
      else
        return t[3 * r + 2];
    return 0;
  }
}
ju._INSTANCE = null;
function doe() {
  return JSON.parse("[0,0,0,51592,51592,11,44424,44424,11,72251,72254,5,7150,7150,7,48008,48008,11,55176,55176,11,128420,128420,14,3276,3277,5,9979,9980,14,46216,46216,11,49800,49800,11,53384,53384,11,70726,70726,5,122915,122916,5,129320,129327,14,2558,2558,5,5906,5908,5,9762,9763,14,43360,43388,8,45320,45320,11,47112,47112,11,48904,48904,11,50696,50696,11,52488,52488,11,54280,54280,11,70082,70083,1,71350,71350,7,73111,73111,5,127892,127893,14,128726,128727,14,129473,129474,14,2027,2035,5,2901,2902,5,3784,3789,5,6754,6754,5,8418,8420,5,9877,9877,14,11088,11088,14,44008,44008,5,44872,44872,11,45768,45768,11,46664,46664,11,47560,47560,11,48456,48456,11,49352,49352,11,50248,50248,11,51144,51144,11,52040,52040,11,52936,52936,11,53832,53832,11,54728,54728,11,69811,69814,5,70459,70460,5,71096,71099,7,71998,71998,5,72874,72880,5,119149,119149,7,127374,127374,14,128335,128335,14,128482,128482,14,128765,128767,14,129399,129400,14,129680,129685,14,1476,1477,5,2377,2380,7,2759,2760,5,3137,3140,7,3458,3459,7,4153,4154,5,6432,6434,5,6978,6978,5,7675,7679,5,9723,9726,14,9823,9823,14,9919,9923,14,10035,10036,14,42736,42737,5,43596,43596,5,44200,44200,11,44648,44648,11,45096,45096,11,45544,45544,11,45992,45992,11,46440,46440,11,46888,46888,11,47336,47336,11,47784,47784,11,48232,48232,11,48680,48680,11,49128,49128,11,49576,49576,11,50024,50024,11,50472,50472,11,50920,50920,11,51368,51368,11,51816,51816,11,52264,52264,11,52712,52712,11,53160,53160,11,53608,53608,11,54056,54056,11,54504,54504,11,54952,54952,11,68108,68111,5,69933,69940,5,70197,70197,7,70498,70499,7,70845,70845,5,71229,71229,5,71727,71735,5,72154,72155,5,72344,72345,5,73023,73029,5,94095,94098,5,121403,121452,5,126981,127182,14,127538,127546,14,127990,127990,14,128391,128391,14,128445,128449,14,128500,128505,14,128752,128752,14,129160,129167,14,129356,129356,14,129432,129442,14,129648,129651,14,129751,131069,14,173,173,4,1757,1757,1,2274,2274,1,2494,2494,5,2641,2641,5,2876,2876,5,3014,3016,7,3262,3262,7,3393,3396,5,3570,3571,7,3968,3972,5,4228,4228,7,6086,6086,5,6679,6680,5,6912,6915,5,7080,7081,5,7380,7392,5,8252,8252,14,9096,9096,14,9748,9749,14,9784,9786,14,9833,9850,14,9890,9894,14,9938,9938,14,9999,9999,14,10085,10087,14,12349,12349,14,43136,43137,7,43454,43456,7,43755,43755,7,44088,44088,11,44312,44312,11,44536,44536,11,44760,44760,11,44984,44984,11,45208,45208,11,45432,45432,11,45656,45656,11,45880,45880,11,46104,46104,11,46328,46328,11,46552,46552,11,46776,46776,11,47000,47000,11,47224,47224,11,47448,47448,11,47672,47672,11,47896,47896,11,48120,48120,11,48344,48344,11,48568,48568,11,48792,48792,11,49016,49016,11,49240,49240,11,49464,49464,11,49688,49688,11,49912,49912,11,50136,50136,11,50360,50360,11,50584,50584,11,50808,50808,11,51032,51032,11,51256,51256,11,51480,51480,11,51704,51704,11,51928,51928,11,52152,52152,11,52376,52376,11,52600,52600,11,52824,52824,11,53048,53048,11,53272,53272,11,53496,53496,11,53720,53720,11,53944,53944,11,54168,54168,11,54392,54392,11,54616,54616,11,54840,54840,11,55064,55064,11,65438,65439,5,69633,69633,5,69837,69837,1,70018,70018,7,70188,70190,7,70368,70370,7,70465,70468,7,70712,70719,5,70835,70840,5,70850,70851,5,71132,71133,5,71340,71340,7,71458,71461,5,71985,71989,7,72002,72002,7,72193,72202,5,72281,72283,5,72766,72766,7,72885,72886,5,73104,73105,5,92912,92916,5,113824,113827,4,119173,119179,5,121505,121519,5,125136,125142,5,127279,127279,14,127489,127490,14,127570,127743,14,127900,127901,14,128254,128254,14,128369,128370,14,128400,128400,14,128425,128432,14,128468,128475,14,128489,128494,14,128715,128720,14,128745,128745,14,128759,128760,14,129004,129023,14,129296,129304,14,129340,129342,14,129388,129392,14,129404,129407,14,129454,129455,14,129485,129487,14,129659,129663,14,129719,129727,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2363,2363,7,2402,2403,5,2507,2508,7,2622,2624,7,2691,2691,7,2786,2787,5,2881,2884,5,3006,3006,5,3072,3072,5,3170,3171,5,3267,3268,7,3330,3331,7,3406,3406,1,3538,3540,5,3655,3662,5,3897,3897,5,4038,4038,5,4184,4185,5,4352,4447,8,6068,6069,5,6155,6157,5,6448,6449,7,6742,6742,5,6783,6783,5,6966,6970,5,7042,7042,7,7143,7143,7,7212,7219,5,7412,7412,5,8206,8207,4,8294,8303,4,8596,8601,14,9410,9410,14,9742,9742,14,9757,9757,14,9770,9770,14,9794,9794,14,9828,9828,14,9855,9855,14,9882,9882,14,9900,9903,14,9929,9933,14,9963,9967,14,9987,9988,14,10006,10006,14,10062,10062,14,10175,10175,14,11744,11775,5,42607,42607,5,43043,43044,7,43263,43263,5,43444,43445,7,43569,43570,5,43698,43700,5,43766,43766,5,44032,44032,11,44144,44144,11,44256,44256,11,44368,44368,11,44480,44480,11,44592,44592,11,44704,44704,11,44816,44816,11,44928,44928,11,45040,45040,11,45152,45152,11,45264,45264,11,45376,45376,11,45488,45488,11,45600,45600,11,45712,45712,11,45824,45824,11,45936,45936,11,46048,46048,11,46160,46160,11,46272,46272,11,46384,46384,11,46496,46496,11,46608,46608,11,46720,46720,11,46832,46832,11,46944,46944,11,47056,47056,11,47168,47168,11,47280,47280,11,47392,47392,11,47504,47504,11,47616,47616,11,47728,47728,11,47840,47840,11,47952,47952,11,48064,48064,11,48176,48176,11,48288,48288,11,48400,48400,11,48512,48512,11,48624,48624,11,48736,48736,11,48848,48848,11,48960,48960,11,49072,49072,11,49184,49184,11,49296,49296,11,49408,49408,11,49520,49520,11,49632,49632,11,49744,49744,11,49856,49856,11,49968,49968,11,50080,50080,11,50192,50192,11,50304,50304,11,50416,50416,11,50528,50528,11,50640,50640,11,50752,50752,11,50864,50864,11,50976,50976,11,51088,51088,11,51200,51200,11,51312,51312,11,51424,51424,11,51536,51536,11,51648,51648,11,51760,51760,11,51872,51872,11,51984,51984,11,52096,52096,11,52208,52208,11,52320,52320,11,52432,52432,11,52544,52544,11,52656,52656,11,52768,52768,11,52880,52880,11,52992,52992,11,53104,53104,11,53216,53216,11,53328,53328,11,53440,53440,11,53552,53552,11,53664,53664,11,53776,53776,11,53888,53888,11,54000,54000,11,54112,54112,11,54224,54224,11,54336,54336,11,54448,54448,11,54560,54560,11,54672,54672,11,54784,54784,11,54896,54896,11,55008,55008,11,55120,55120,11,64286,64286,5,66272,66272,5,68900,68903,5,69762,69762,7,69817,69818,5,69927,69931,5,70003,70003,5,70070,70078,5,70094,70094,7,70194,70195,7,70206,70206,5,70400,70401,5,70463,70463,7,70475,70477,7,70512,70516,5,70722,70724,5,70832,70832,5,70842,70842,5,70847,70848,5,71088,71089,7,71102,71102,7,71219,71226,5,71231,71232,5,71342,71343,7,71453,71455,5,71463,71467,5,71737,71738,5,71995,71996,5,72000,72000,7,72145,72147,7,72160,72160,5,72249,72249,7,72273,72278,5,72330,72342,5,72752,72758,5,72850,72871,5,72882,72883,5,73018,73018,5,73031,73031,5,73109,73109,5,73461,73462,7,94031,94031,5,94192,94193,7,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,126976,126979,14,127184,127231,14,127344,127345,14,127405,127461,14,127514,127514,14,127561,127567,14,127778,127779,14,127896,127896,14,127985,127986,14,127995,127999,5,128326,128328,14,128360,128366,14,128378,128378,14,128394,128397,14,128405,128406,14,128422,128423,14,128435,128443,14,128453,128464,14,128479,128480,14,128484,128487,14,128496,128498,14,128640,128709,14,128723,128724,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129096,129103,14,129292,129292,14,129311,129311,14,129329,129330,14,129344,129349,14,129360,129374,14,129394,129394,14,129402,129402,14,129413,129425,14,129445,129450,14,129466,129471,14,129483,129483,14,129511,129535,14,129653,129655,14,129667,129670,14,129705,129711,14,129731,129743,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2307,2307,7,2366,2368,7,2382,2383,7,2434,2435,7,2497,2500,5,2519,2519,5,2563,2563,7,2631,2632,5,2677,2677,5,2750,2752,7,2763,2764,7,2817,2817,5,2879,2879,5,2891,2892,7,2914,2915,5,3008,3008,5,3021,3021,5,3076,3076,5,3146,3149,5,3202,3203,7,3264,3265,7,3271,3272,7,3298,3299,5,3390,3390,5,3402,3404,7,3426,3427,5,3535,3535,5,3544,3550,7,3635,3635,7,3763,3763,7,3893,3893,5,3953,3966,5,3981,3991,5,4145,4145,7,4157,4158,5,4209,4212,5,4237,4237,5,4520,4607,10,5970,5971,5,6071,6077,5,6089,6099,5,6277,6278,5,6439,6440,5,6451,6456,7,6683,6683,5,6744,6750,5,6765,6770,7,6846,6846,5,6964,6964,5,6972,6972,5,7019,7027,5,7074,7077,5,7083,7085,5,7146,7148,7,7154,7155,7,7222,7223,5,7394,7400,5,7416,7417,5,8204,8204,5,8233,8233,4,8288,8292,4,8413,8416,5,8482,8482,14,8986,8987,14,9193,9203,14,9654,9654,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9775,14,9792,9792,14,9800,9811,14,9825,9826,14,9831,9831,14,9852,9853,14,9872,9873,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9936,9936,14,9941,9960,14,9974,9974,14,9982,9985,14,9992,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10145,10145,14,11013,11015,14,11503,11505,5,12334,12335,5,12951,12951,14,42612,42621,5,43014,43014,5,43047,43047,7,43204,43205,5,43335,43345,5,43395,43395,7,43450,43451,7,43561,43566,5,43573,43574,5,43644,43644,5,43710,43711,5,43758,43759,7,44005,44005,5,44012,44012,7,44060,44060,11,44116,44116,11,44172,44172,11,44228,44228,11,44284,44284,11,44340,44340,11,44396,44396,11,44452,44452,11,44508,44508,11,44564,44564,11,44620,44620,11,44676,44676,11,44732,44732,11,44788,44788,11,44844,44844,11,44900,44900,11,44956,44956,11,45012,45012,11,45068,45068,11,45124,45124,11,45180,45180,11,45236,45236,11,45292,45292,11,45348,45348,11,45404,45404,11,45460,45460,11,45516,45516,11,45572,45572,11,45628,45628,11,45684,45684,11,45740,45740,11,45796,45796,11,45852,45852,11,45908,45908,11,45964,45964,11,46020,46020,11,46076,46076,11,46132,46132,11,46188,46188,11,46244,46244,11,46300,46300,11,46356,46356,11,46412,46412,11,46468,46468,11,46524,46524,11,46580,46580,11,46636,46636,11,46692,46692,11,46748,46748,11,46804,46804,11,46860,46860,11,46916,46916,11,46972,46972,11,47028,47028,11,47084,47084,11,47140,47140,11,47196,47196,11,47252,47252,11,47308,47308,11,47364,47364,11,47420,47420,11,47476,47476,11,47532,47532,11,47588,47588,11,47644,47644,11,47700,47700,11,47756,47756,11,47812,47812,11,47868,47868,11,47924,47924,11,47980,47980,11,48036,48036,11,48092,48092,11,48148,48148,11,48204,48204,11,48260,48260,11,48316,48316,11,48372,48372,11,48428,48428,11,48484,48484,11,48540,48540,11,48596,48596,11,48652,48652,11,48708,48708,11,48764,48764,11,48820,48820,11,48876,48876,11,48932,48932,11,48988,48988,11,49044,49044,11,49100,49100,11,49156,49156,11,49212,49212,11,49268,49268,11,49324,49324,11,49380,49380,11,49436,49436,11,49492,49492,11,49548,49548,11,49604,49604,11,49660,49660,11,49716,49716,11,49772,49772,11,49828,49828,11,49884,49884,11,49940,49940,11,49996,49996,11,50052,50052,11,50108,50108,11,50164,50164,11,50220,50220,11,50276,50276,11,50332,50332,11,50388,50388,11,50444,50444,11,50500,50500,11,50556,50556,11,50612,50612,11,50668,50668,11,50724,50724,11,50780,50780,11,50836,50836,11,50892,50892,11,50948,50948,11,51004,51004,11,51060,51060,11,51116,51116,11,51172,51172,11,51228,51228,11,51284,51284,11,51340,51340,11,51396,51396,11,51452,51452,11,51508,51508,11,51564,51564,11,51620,51620,11,51676,51676,11,51732,51732,11,51788,51788,11,51844,51844,11,51900,51900,11,51956,51956,11,52012,52012,11,52068,52068,11,52124,52124,11,52180,52180,11,52236,52236,11,52292,52292,11,52348,52348,11,52404,52404,11,52460,52460,11,52516,52516,11,52572,52572,11,52628,52628,11,52684,52684,11,52740,52740,11,52796,52796,11,52852,52852,11,52908,52908,11,52964,52964,11,53020,53020,11,53076,53076,11,53132,53132,11,53188,53188,11,53244,53244,11,53300,53300,11,53356,53356,11,53412,53412,11,53468,53468,11,53524,53524,11,53580,53580,11,53636,53636,11,53692,53692,11,53748,53748,11,53804,53804,11,53860,53860,11,53916,53916,11,53972,53972,11,54028,54028,11,54084,54084,11,54140,54140,11,54196,54196,11,54252,54252,11,54308,54308,11,54364,54364,11,54420,54420,11,54476,54476,11,54532,54532,11,54588,54588,11,54644,54644,11,54700,54700,11,54756,54756,11,54812,54812,11,54868,54868,11,54924,54924,11,54980,54980,11,55036,55036,11,55092,55092,11,55148,55148,11,55216,55238,9,65056,65071,5,65529,65531,4,68097,68099,5,68159,68159,5,69446,69456,5,69688,69702,5,69808,69810,7,69815,69816,7,69821,69821,1,69888,69890,5,69932,69932,7,69957,69958,7,70016,70017,5,70067,70069,7,70079,70080,7,70089,70092,5,70095,70095,5,70191,70193,5,70196,70196,5,70198,70199,5,70367,70367,5,70371,70378,5,70402,70403,7,70462,70462,5,70464,70464,5,70471,70472,7,70487,70487,5,70502,70508,5,70709,70711,7,70720,70721,7,70725,70725,7,70750,70750,5,70833,70834,7,70841,70841,7,70843,70844,7,70846,70846,7,70849,70849,7,71087,71087,5,71090,71093,5,71100,71101,5,71103,71104,5,71216,71218,7,71227,71228,7,71230,71230,7,71339,71339,5,71341,71341,5,71344,71349,5,71351,71351,5,71456,71457,7,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123628,123631,5,125252,125258,5,126980,126980,14,127183,127183,14,127245,127247,14,127340,127343,14,127358,127359,14,127377,127386,14,127462,127487,6,127491,127503,14,127535,127535,14,127548,127551,14,127568,127569,14,127744,127777,14,127780,127891,14,127894,127895,14,127897,127899,14,127902,127984,14,127987,127989,14,127991,127994,14,128000,128253,14,128255,128317,14,128329,128334,14,128336,128359,14,128367,128368,14,128371,128377,14,128379,128390,14,128392,128393,14,128398,128399,14,128401,128404,14,128407,128419,14,128421,128421,14,128424,128424,14,128433,128434,14,128444,128444,14,128450,128452,14,128465,128467,14,128476,128478,14,128481,128481,14,128483,128483,14,128488,128488,14,128495,128495,14,128499,128499,14,128506,128591,14,128710,128714,14,128721,128722,14,128725,128725,14,128728,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129664,129666,14,129671,129679,14,129686,129704,14,129712,129718,14,129728,129730,14,129744,129750,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2259,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3134,3136,5,3142,3144,5,3157,3158,5,3201,3201,5,3260,3260,5,3263,3263,5,3266,3266,5,3270,3270,5,3274,3275,7,3285,3286,5,3328,3329,5,3387,3388,5,3391,3392,7,3398,3400,7,3405,3405,5,3415,3415,5,3457,3457,5,3530,3530,5,3536,3537,7,3542,3542,5,3551,3551,5,3633,3633,5,3636,3642,5,3761,3761,5,3764,3772,5,3864,3865,5,3895,3895,5,3902,3903,7,3967,3967,7,3974,3975,5,3993,4028,5,4141,4144,5,4146,4151,5,4155,4156,7,4182,4183,7,4190,4192,5,4226,4226,5,4229,4230,5,4253,4253,5,4448,4519,9,4957,4959,5,5938,5940,5,6002,6003,5,6070,6070,7,6078,6085,7,6087,6088,7,6109,6109,5,6158,6158,4,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6848,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7673,5,8203,8203,4,8205,8205,13,8232,8232,4,8234,8238,4,8265,8265,14,8293,8293,4,8400,8412,5,8417,8417,5,8421,8432,5,8505,8505,14,8617,8618,14,9000,9000,14,9167,9167,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9776,9783,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9935,14,9937,9937,14,9939,9940,14,9961,9962,14,9968,9973,14,9975,9978,14,9981,9981,14,9986,9986,14,9989,9989,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10084,14,10133,10135,14,10160,10160,14,10548,10549,14,11035,11036,14,11093,11093,14,11647,11647,5,12330,12333,5,12336,12336,14,12441,12442,5,12953,12953,14,42608,42610,5,42654,42655,5,43010,43010,5,43019,43019,5,43045,43046,5,43052,43052,5,43188,43203,7,43232,43249,5,43302,43309,5,43346,43347,7,43392,43394,5,43443,43443,5,43446,43449,5,43452,43453,5,43493,43493,5,43567,43568,7,43571,43572,7,43587,43587,5,43597,43597,7,43696,43696,5,43703,43704,5,43713,43713,5,43756,43757,5,43765,43765,7,44003,44004,7,44006,44007,7,44009,44010,7,44013,44013,5,44033,44059,12,44061,44087,12,44089,44115,12,44117,44143,12,44145,44171,12,44173,44199,12,44201,44227,12,44229,44255,12,44257,44283,12,44285,44311,12,44313,44339,12,44341,44367,12,44369,44395,12,44397,44423,12,44425,44451,12,44453,44479,12,44481,44507,12,44509,44535,12,44537,44563,12,44565,44591,12,44593,44619,12,44621,44647,12,44649,44675,12,44677,44703,12,44705,44731,12,44733,44759,12,44761,44787,12,44789,44815,12,44817,44843,12,44845,44871,12,44873,44899,12,44901,44927,12,44929,44955,12,44957,44983,12,44985,45011,12,45013,45039,12,45041,45067,12,45069,45095,12,45097,45123,12,45125,45151,12,45153,45179,12,45181,45207,12,45209,45235,12,45237,45263,12,45265,45291,12,45293,45319,12,45321,45347,12,45349,45375,12,45377,45403,12,45405,45431,12,45433,45459,12,45461,45487,12,45489,45515,12,45517,45543,12,45545,45571,12,45573,45599,12,45601,45627,12,45629,45655,12,45657,45683,12,45685,45711,12,45713,45739,12,45741,45767,12,45769,45795,12,45797,45823,12,45825,45851,12,45853,45879,12,45881,45907,12,45909,45935,12,45937,45963,12,45965,45991,12,45993,46019,12,46021,46047,12,46049,46075,12,46077,46103,12,46105,46131,12,46133,46159,12,46161,46187,12,46189,46215,12,46217,46243,12,46245,46271,12,46273,46299,12,46301,46327,12,46329,46355,12,46357,46383,12,46385,46411,12,46413,46439,12,46441,46467,12,46469,46495,12,46497,46523,12,46525,46551,12,46553,46579,12,46581,46607,12,46609,46635,12,46637,46663,12,46665,46691,12,46693,46719,12,46721,46747,12,46749,46775,12,46777,46803,12,46805,46831,12,46833,46859,12,46861,46887,12,46889,46915,12,46917,46943,12,46945,46971,12,46973,46999,12,47001,47027,12,47029,47055,12,47057,47083,12,47085,47111,12,47113,47139,12,47141,47167,12,47169,47195,12,47197,47223,12,47225,47251,12,47253,47279,12,47281,47307,12,47309,47335,12,47337,47363,12,47365,47391,12,47393,47419,12,47421,47447,12,47449,47475,12,47477,47503,12,47505,47531,12,47533,47559,12,47561,47587,12,47589,47615,12,47617,47643,12,47645,47671,12,47673,47699,12,47701,47727,12,47729,47755,12,47757,47783,12,47785,47811,12,47813,47839,12,47841,47867,12,47869,47895,12,47897,47923,12,47925,47951,12,47953,47979,12,47981,48007,12,48009,48035,12,48037,48063,12,48065,48091,12,48093,48119,12,48121,48147,12,48149,48175,12,48177,48203,12,48205,48231,12,48233,48259,12,48261,48287,12,48289,48315,12,48317,48343,12,48345,48371,12,48373,48399,12,48401,48427,12,48429,48455,12,48457,48483,12,48485,48511,12,48513,48539,12,48541,48567,12,48569,48595,12,48597,48623,12,48625,48651,12,48653,48679,12,48681,48707,12,48709,48735,12,48737,48763,12,48765,48791,12,48793,48819,12,48821,48847,12,48849,48875,12,48877,48903,12,48905,48931,12,48933,48959,12,48961,48987,12,48989,49015,12,49017,49043,12,49045,49071,12,49073,49099,12,49101,49127,12,49129,49155,12,49157,49183,12,49185,49211,12,49213,49239,12,49241,49267,12,49269,49295,12,49297,49323,12,49325,49351,12,49353,49379,12,49381,49407,12,49409,49435,12,49437,49463,12,49465,49491,12,49493,49519,12,49521,49547,12,49549,49575,12,49577,49603,12,49605,49631,12,49633,49659,12,49661,49687,12,49689,49715,12,49717,49743,12,49745,49771,12,49773,49799,12,49801,49827,12,49829,49855,12,49857,49883,12,49885,49911,12,49913,49939,12,49941,49967,12,49969,49995,12,49997,50023,12,50025,50051,12,50053,50079,12,50081,50107,12,50109,50135,12,50137,50163,12,50165,50191,12,50193,50219,12,50221,50247,12,50249,50275,12,50277,50303,12,50305,50331,12,50333,50359,12,50361,50387,12,50389,50415,12,50417,50443,12,50445,50471,12,50473,50499,12,50501,50527,12,50529,50555,12,50557,50583,12,50585,50611,12,50613,50639,12,50641,50667,12,50669,50695,12,50697,50723,12,50725,50751,12,50753,50779,12,50781,50807,12,50809,50835,12,50837,50863,12,50865,50891,12,50893,50919,12,50921,50947,12,50949,50975,12,50977,51003,12,51005,51031,12,51033,51059,12,51061,51087,12,51089,51115,12,51117,51143,12,51145,51171,12,51173,51199,12,51201,51227,12,51229,51255,12,51257,51283,12,51285,51311,12,51313,51339,12,51341,51367,12,51369,51395,12,51397,51423,12,51425,51451,12,51453,51479,12,51481,51507,12,51509,51535,12,51537,51563,12,51565,51591,12,51593,51619,12,51621,51647,12,51649,51675,12,51677,51703,12,51705,51731,12,51733,51759,12,51761,51787,12,51789,51815,12,51817,51843,12,51845,51871,12,51873,51899,12,51901,51927,12,51929,51955,12,51957,51983,12,51985,52011,12,52013,52039,12,52041,52067,12,52069,52095,12,52097,52123,12,52125,52151,12,52153,52179,12,52181,52207,12,52209,52235,12,52237,52263,12,52265,52291,12,52293,52319,12,52321,52347,12,52349,52375,12,52377,52403,12,52405,52431,12,52433,52459,12,52461,52487,12,52489,52515,12,52517,52543,12,52545,52571,12,52573,52599,12,52601,52627,12,52629,52655,12,52657,52683,12,52685,52711,12,52713,52739,12,52741,52767,12,52769,52795,12,52797,52823,12,52825,52851,12,52853,52879,12,52881,52907,12,52909,52935,12,52937,52963,12,52965,52991,12,52993,53019,12,53021,53047,12,53049,53075,12,53077,53103,12,53105,53131,12,53133,53159,12,53161,53187,12,53189,53215,12,53217,53243,12,53245,53271,12,53273,53299,12,53301,53327,12,53329,53355,12,53357,53383,12,53385,53411,12,53413,53439,12,53441,53467,12,53469,53495,12,53497,53523,12,53525,53551,12,53553,53579,12,53581,53607,12,53609,53635,12,53637,53663,12,53665,53691,12,53693,53719,12,53721,53747,12,53749,53775,12,53777,53803,12,53805,53831,12,53833,53859,12,53861,53887,12,53889,53915,12,53917,53943,12,53945,53971,12,53973,53999,12,54001,54027,12,54029,54055,12,54057,54083,12,54085,54111,12,54113,54139,12,54141,54167,12,54169,54195,12,54197,54223,12,54225,54251,12,54253,54279,12,54281,54307,12,54309,54335,12,54337,54363,12,54365,54391,12,54393,54419,12,54421,54447,12,54449,54475,12,54477,54503,12,54505,54531,12,54533,54559,12,54561,54587,12,54589,54615,12,54617,54643,12,54645,54671,12,54673,54699,12,54701,54727,12,54729,54755,12,54757,54783,12,54785,54811,12,54813,54839,12,54841,54867,12,54869,54895,12,54897,54923,12,54925,54951,12,54953,54979,12,54981,55007,12,55009,55035,12,55037,55063,12,55065,55091,12,55093,55119,12,55121,55147,12,55149,55175,12,55177,55203,12,55243,55291,10,65024,65039,5,65279,65279,4,65520,65528,4,66045,66045,5,66422,66426,5,68101,68102,5,68152,68154,5,68325,68326,5,69291,69292,5,69632,69632,7,69634,69634,7,69759,69761,5]");
}
function foe(n, e) {
  if (n === 0)
    return 0;
  const t = poe(n, e);
  if (t !== void 0)
    return t;
  const i = Dp(e, n);
  return n -= ow(i), n;
}
function poe(n, e) {
  let t = Dp(e, n);
  for (n -= ow(t); goe(t) || t === 65039 || t === 8419; ) {
    if (n === 0)
      return;
    t = Dp(e, n), n -= ow(t);
  }
  if (hv(t)) {
    if (n >= 0) {
      const i = Dp(e, n);
      i === 8205 && (n -= ow(i));
    }
    return n;
  }
}
function ow(n) {
  return n >= 65536 ? 2 : 1;
}
function goe(n) {
  return 127995 <= n && n <= 127999;
}
var hk, dk;
class moe {
  constructor() {
    this._value = "", this._pos = 0;
  }
  reset(e) {
    return this._value = e, this._pos = 0, this;
  }
  next() {
    return this._pos += 1, this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(e) {
    const t = e.charCodeAt(0), i = this._value.charCodeAt(this._pos);
    return t - i;
  }
  value() {
    return this._value[this._pos];
  }
}
class voe {
  constructor(e = !0) {
    this._caseSensitive = e;
  }
  reset(e) {
    return this._value = e, this._from = 0, this._to = 0, this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._value.length; this._to++)
      if (this._value.charCodeAt(this._to) === 46)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? WN(e, this._value, 0, e.length, this._from, this._to) : VN(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class _oe {
  constructor(e = !0, t = !0) {
    this._splitOnBackslash = e, this._caseSensitive = t;
  }
  reset(e) {
    return this._value = e.replace(/\\$|\/$/, ""), this._from = 0, this._to = 0, this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._value.length; this._to++) {
      const t = this._value.charCodeAt(this._to);
      if (t === 47 || this._splitOnBackslash && t === 92)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    }
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? WN(e, this._value, 0, e.length, this._from, this._to) : VN(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class Coe {
  constructor(e) {
    this._ignorePathCasing = e, this._states = [], this._stateIdx = 0;
  }
  reset(e) {
    return this._value = e, this._states = [], this._value.scheme && this._states.push(
      1
      /* Scheme */
    ), this._value.authority && this._states.push(
      2
      /* Authority */
    ), this._value.path && (this._pathIterator = new _oe(!1, !this._ignorePathCasing(e)), this._pathIterator.reset(e.path), this._pathIterator.value() && this._states.push(
      3
      /* Path */
    )), this._value.query && this._states.push(
      4
      /* Query */
    ), this._value.fragment && this._states.push(
      5
      /* Fragment */
    ), this._stateIdx = 0, this;
  }
  next() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() ? this._pathIterator.next() : this._stateIdx += 1, this;
  }
  hasNext() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(e) {
    if (this._states[this._stateIdx] === 1)
      return ak(e, this._value.scheme);
    if (this._states[this._stateIdx] === 2)
      return ak(e, this._value.authority);
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.cmp(e);
    if (this._states[this._stateIdx] === 4)
      return mT(e, this._value.query);
    if (this._states[this._stateIdx] === 5)
      return mT(e, this._value.fragment);
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === 1)
      return this._value.scheme;
    if (this._states[this._stateIdx] === 2)
      return this._value.authority;
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.value();
    if (this._states[this._stateIdx] === 4)
      return this._value.query;
    if (this._states[this._stateIdx] === 5)
      return this._value.fragment;
    throw new Error();
  }
}
class py {
  isEmpty() {
    return !this.left && !this.mid && !this.right && !this.value;
  }
}
class fv {
  constructor(e) {
    this._iter = e;
  }
  static forUris(e = () => !1) {
    return new fv(new Coe(e));
  }
  static forStrings() {
    return new fv(new moe());
  }
  static forConfigKeys() {
    return new fv(new voe());
  }
  clear() {
    this._root = void 0;
  }
  set(e, t) {
    const i = this._iter.reset(e);
    let r;
    for (this._root || (this._root = new py(), this._root.segment = i.value()), r = this._root; ; ) {
      const s = i.cmp(r.segment);
      if (s > 0)
        r.left || (r.left = new py(), r.left.segment = i.value()), r = r.left;
      else if (s < 0)
        r.right || (r.right = new py(), r.right.segment = i.value()), r = r.right;
      else if (i.hasNext())
        i.next(), r.mid || (r.mid = new py(), r.mid.segment = i.value()), r = r.mid;
      else
        break;
    }
    const o = r.value;
    return r.value = t, r.key = e, o;
  }
  get(e) {
    var t;
    return (t = this._getNode(e)) === null || t === void 0 ? void 0 : t.value;
  }
  _getNode(e) {
    const t = this._iter.reset(e);
    let i = this._root;
    for (; i; ) {
      const r = t.cmp(i.segment);
      if (r > 0)
        i = i.left;
      else if (r < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), i = i.mid;
      else
        break;
    }
    return i;
  }
  has(e) {
    const t = this._getNode(e);
    return !((t == null ? void 0 : t.value) === void 0 && (t == null ? void 0 : t.mid) === void 0);
  }
  delete(e) {
    return this._delete(e, !1);
  }
  deleteSuperstr(e) {
    return this._delete(e, !0);
  }
  _delete(e, t) {
    const i = this._iter.reset(e), r = [];
    let o = this._root;
    for (; o; ) {
      const s = i.cmp(o.segment);
      if (s > 0)
        r.push([1, o]), o = o.left;
      else if (s < 0)
        r.push([-1, o]), o = o.right;
      else if (i.hasNext())
        i.next(), r.push([0, o]), o = o.mid;
      else {
        for (t ? (o.left = void 0, o.mid = void 0, o.right = void 0) : o.value = void 0; r.length > 0 && o.isEmpty(); ) {
          let [a, l] = r.pop();
          switch (a) {
            case 1:
              l.left = void 0;
              break;
            case 0:
              l.mid = void 0;
              break;
            case -1:
              l.right = void 0;
              break;
          }
          o = l;
        }
        break;
      }
    }
  }
  findSubstr(e) {
    const t = this._iter.reset(e);
    let i = this._root, r;
    for (; i; ) {
      const o = t.cmp(i.segment);
      if (o > 0)
        i = i.left;
      else if (o < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), r = i.value || r, i = i.mid;
      else
        break;
    }
    return i && i.value || r;
  }
  findSuperstr(e) {
    const t = this._iter.reset(e);
    let i = this._root;
    for (; i; ) {
      const r = t.cmp(i.segment);
      if (r > 0)
        i = i.left;
      else if (r < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), i = i.mid;
      else
        return i.mid ? this._entries(i.mid) : void 0;
    }
  }
  forEach(e) {
    for (const [t, i] of this)
      e(i, t);
  }
  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }
  *_entries(e, t = 0) {
    if (t > 5e3) {
      console.log("potential CYCLE detected", new Error().stack);
      return;
    }
    e && (yield* this._entries(e.left, t++), e.value && (yield [e.key, e.value]), yield* this._entries(e.mid, t++), yield* this._entries(e.right, t++));
  }
}
class So {
  constructor(e, t) {
    this[hk] = "ResourceMap", e instanceof So ? (this.map = new Map(e.map), this.toKey = t ?? So.defaultToKey) : (this.map = /* @__PURE__ */ new Map(), this.toKey = e ?? So.defaultToKey);
  }
  set(e, t) {
    return this.map.set(this.toKey(e), t), this;
  }
  get(e) {
    return this.map.get(this.toKey(e));
  }
  has(e) {
    return this.map.has(this.toKey(e));
  }
  get size() {
    return this.map.size;
  }
  clear() {
    this.map.clear();
  }
  delete(e) {
    return this.map.delete(this.toKey(e));
  }
  forEach(e, t) {
    typeof t < "u" && (e = e.bind(t));
    for (let [i, r] of this.map)
      e(r, ft.parse(i), this);
  }
  values() {
    return this.map.values();
  }
  *keys() {
    for (let e of this.map.keys())
      yield ft.parse(e);
  }
  *entries() {
    for (let e of this.map.entries())
      yield [ft.parse(e[0]), e[1]];
  }
  *[(hk = Symbol.toStringTag, Symbol.iterator)]() {
    for (let e of this.map)
      yield [ft.parse(e[0]), e[1]];
  }
}
So.defaultToKey = (n) => n.toString();
class yoe {
  constructor() {
    this[dk] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
  }
  clear() {
    this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    var e;
    return (e = this._head) === null || e === void 0 ? void 0 : e.value;
  }
  get last() {
    var e;
    return (e = this._tail) === null || e === void 0 ? void 0 : e.value;
  }
  has(e) {
    return this._map.has(e);
  }
  get(e, t = 0) {
    const i = this._map.get(e);
    if (i)
      return t !== 0 && this.touch(i, t), i.value;
  }
  set(e, t, i = 0) {
    let r = this._map.get(e);
    if (r)
      r.value = t, i !== 0 && this.touch(r, i);
    else {
      switch (r = { key: e, value: t, next: void 0, previous: void 0 }, i) {
        case 0:
          this.addItemLast(r);
          break;
        case 1:
          this.addItemFirst(r);
          break;
        case 2:
          this.addItemLast(r);
          break;
        default:
          this.addItemLast(r);
          break;
      }
      this._map.set(e, r), this._size++;
    }
    return this;
  }
  delete(e) {
    return !!this.remove(e);
  }
  remove(e) {
    const t = this._map.get(e);
    if (t)
      return this._map.delete(e), this.removeItem(t), this._size--, t.value;
  }
  shift() {
    if (!this._head && !this._tail)
      return;
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    const e = this._head;
    return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
  }
  forEach(e, t) {
    const i = this._state;
    let r = this._head;
    for (; r; ) {
      if (t ? e.bind(t)(r.value, r.key, this) : e(r.value, r.key, this), this._state !== i)
        throw new Error("LinkedMap got modified during iteration.");
      r = r.next;
    }
  }
  keys() {
    const e = this, t = this._state;
    let i = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: i.key, done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  values() {
    const e = this, t = this._state;
    let i = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: i.value, done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  entries() {
    const e = this, t = this._state;
    let i = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: [i.key, i.value], done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  [(dk = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let t = this._head, i = this.size;
    for (; t && i > e; )
      this._map.delete(t.key), t = t.next, i--;
    this._head = t, this._size = i, t && (t.previous = void 0), this._state++;
  }
  addItemFirst(e) {
    if (!this._head && !this._tail)
      this._tail = e;
    else if (this._head)
      e.next = this._head, this._head.previous = e;
    else
      throw new Error("Invalid list");
    this._head = e, this._state++;
  }
  addItemLast(e) {
    if (!this._head && !this._tail)
      this._head = e;
    else if (this._tail)
      e.previous = this._tail, this._tail.next = e;
    else
      throw new Error("Invalid list");
    this._tail = e, this._state++;
  }
  removeItem(e) {
    if (e === this._head && e === this._tail)
      this._head = void 0, this._tail = void 0;
    else if (e === this._head) {
      if (!e.next)
        throw new Error("Invalid list");
      e.next.previous = void 0, this._head = e.next;
    } else if (e === this._tail) {
      if (!e.previous)
        throw new Error("Invalid list");
      e.previous.next = void 0, this._tail = e.previous;
    } else {
      const t = e.next, i = e.previous;
      if (!t || !i)
        throw new Error("Invalid list");
      t.previous = i, i.next = t;
    }
    e.next = void 0, e.previous = void 0, this._state++;
  }
  touch(e, t) {
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    if (!(t !== 1 && t !== 2)) {
      if (t === 1) {
        if (e === this._head)
          return;
        const i = e.next, r = e.previous;
        e === this._tail ? (r.next = void 0, this._tail = r) : (i.previous = r, r.next = i), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
      } else if (t === 2) {
        if (e === this._tail)
          return;
        const i = e.next, r = e.previous;
        e === this._head ? (i.previous = void 0, this._head = i) : (i.previous = r, r.next = i), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
      }
    }
  }
  toJSON() {
    const e = [];
    return this.forEach((t, i) => {
      e.push([i, t]);
    }), e;
  }
  fromJSON(e) {
    this.clear();
    for (const [t, i] of e)
      this.set(t, i);
  }
}
class zN extends yoe {
  constructor(e, t = 1) {
    super(), this._limit = e, this._ratio = Math.min(Math.max(0, t), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(e) {
    this._limit = e, this.checkTrim();
  }
  get(e, t = 2) {
    return super.get(e, t);
  }
  peek(e) {
    return super.get(
      e,
      0
      /* None */
    );
  }
  set(e, t) {
    return super.set(
      e,
      t,
      2
      /* AsNew */
    ), this.checkTrim(), this;
  }
  checkTrim() {
    this.size > this._limit && this.trimOld(Math.round(this._limit * this._ratio));
  }
}
const fk = typeof Buffer < "u", woe = typeof TextDecoder < "u";
let dD;
class rE {
  constructor(e) {
    this.buffer = e, this.byteLength = this.buffer.byteLength;
  }
  static wrap(e) {
    return fk && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new rE(e);
  }
  toString() {
    return fk ? this.buffer.toString() : woe ? (dD || (dD = new TextDecoder()), dD.decode(this.buffer)) : ooe(this.buffer);
  }
}
function boe(n, e) {
  return n[e + 0] << 0 >>> 0 | n[e + 1] << 8 >>> 0;
}
function Soe(n, e, t) {
  n[t + 0] = e & 255, e = e >>> 8, n[t + 1] = e & 255;
}
function Aa(n, e) {
  return n[e] * Math.pow(2, 24) + n[e + 1] * Math.pow(2, 16) + n[e + 2] * Math.pow(2, 8) + n[e + 3];
}
function Ma(n, e, t) {
  n[t + 3] = e, e = e >>> 8, n[t + 2] = e, e = e >>> 8, n[t + 1] = e, e = e >>> 8, n[t] = e;
}
function pk(n, e) {
  return n[e];
}
function gk(n, e, t) {
  n[t] = e;
}
function mk(n) {
  let e = JSON.parse(n);
  return e = vT(e), e;
}
function vT(n, e = 0) {
  if (!n || e > 200)
    return n;
  if (typeof n == "object") {
    switch (n.$mid) {
      case 1:
        return ft.revive(n);
      case 2:
        return new RegExp(n.source, n.flags);
    }
    if (n instanceof rE || n instanceof Uint8Array)
      return n;
    if (Array.isArray(n))
      for (let t = 0; t < n.length; ++t)
        n[t] = vT(n[t], e + 1);
    else
      for (const t in n)
        Object.hasOwnProperty.call(n, t) && (n[t] = vT(n[t], e + 1));
  }
  return n;
}
function Eoe(n) {
  return n.replace(/[\\/]/g, _n.sep);
}
function Loe(n) {
  return n.indexOf("/") === -1 && (n = Eoe(n)), /^[a-zA-Z]:(\/|$)/.test(n) && (n = "/" + n), n;
}
function Doe(n, e, t, i = rw) {
  if (n === e)
    return !0;
  if (!n || !e || e.length > n.length)
    return !1;
  if (t) {
    if (!BN(n, e))
      return !1;
    if (e.length === n.length)
      return !0;
    let o = e.length;
    return e.charAt(e.length - 1) === i && o--, n.charAt(o) === i;
  }
  return e.charAt(e.length - 1) !== i && (e += i), n.indexOf(e) === 0;
}
function Roe(n) {
  return n >= 65 && n <= 90 || n >= 97 && n <= 122;
}
function gye(n) {
  const e = IN(n);
  return Ro ? n.length > 3 ? !1 : Toe(e) && (n.length === 2 || e.charCodeAt(2) === 92) : e === _n.sep;
}
function Toe(n) {
  return Ro ? Roe(n.charCodeAt(0)) && n.charCodeAt(1) === 58 : !1;
}
function fD(n) {
  return cb(n, !0);
}
class Ooe {
  constructor(e) {
    this._ignorePathCasing = e;
  }
  compare(e, t, i = !1) {
    return e === t ? 0 : mT(this.getComparisonKey(e, i), this.getComparisonKey(t, i));
  }
  isEqual(e, t, i = !1) {
    return e === t ? !0 : !e || !t ? !1 : this.getComparisonKey(e, i) === this.getComparisonKey(t, i);
  }
  getComparisonKey(e, t = !1) {
    return e.with({
      path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0,
      fragment: t ? null : void 0
    }).toString();
  }
  // --- path math
  joinPath(e, ...t) {
    return ft.joinPath(e, ...t);
  }
  basenameOrAuthority(e) {
    return b5(e) || e.authority;
  }
  basename(e) {
    return _n.basename(e.path);
  }
  dirname(e) {
    if (e.path.length === 0)
      return e;
    let t;
    return e.scheme === vi.file ? t = ft.file(cre(fD(e))).path : (t = _n.dirname(e.path), e.authority && t.length && t.charCodeAt(0) !== 47 && (console.error(`dirname("${e.toString})) resulted in a relative path`), t = "/")), e.with({
      path: t
    });
  }
  normalizePath(e) {
    if (!e.path.length)
      return e;
    let t;
    return e.scheme === vi.file ? t = ft.file(IN(fD(e))).path : t = _n.normalize(e.path), e.with({
      path: t
    });
  }
  resolvePath(e, t) {
    if (e.scheme === vi.file) {
      const i = ft.file(lre(fD(e), t));
      return e.with({
        authority: i.authority,
        path: i.path
      });
    }
    return t = Loe(t), e.with({
      path: _n.resolve(e.path, t)
    });
  }
}
const qo = new Ooe(() => !1), mye = qo.isEqual.bind(qo), vye = qo.basenameOrAuthority.bind(qo), b5 = qo.basename.bind(qo), _ye = qo.dirname.bind(qo), Cye = qo.joinPath.bind(qo), xoe = qo.normalizePath.bind(qo), yye = qo.resolvePath.bind(qo);
var pb;
(function(n) {
  n.META_DATA_LABEL = "label", n.META_DATA_DESCRIPTION = "description", n.META_DATA_SIZE = "size", n.META_DATA_MIME = "mime";
  function e(t) {
    const i = /* @__PURE__ */ new Map();
    t.path.substring(t.path.indexOf(";") + 1, t.path.lastIndexOf(";")).split(";").forEach((s) => {
      const [a, l] = s.split(":");
      a && l && i.set(a, l);
    });
    const o = t.path.substring(0, t.path.indexOf(";"));
    return o && i.set(n.META_DATA_MIME, o), i;
  }
  n.parseMetaData = e;
})(pb || (pb = {}));
function Noe(n) {
  return Array.isArray(n);
}
function il(n) {
  return typeof n == "string";
}
function Uo(n) {
  return typeof n == "object" && n !== null && !Array.isArray(n) && !(n instanceof RegExp) && !(n instanceof Date);
}
function j_(n) {
  return typeof n == "number" && !isNaN(n);
}
function S5(n) {
  return n === !0 || n === !1;
}
function xs(n) {
  return typeof n > "u";
}
function _s(n) {
  return xs(n) || n === null;
}
function $o(n, e) {
  if (!n)
    throw new Error(e ? `Unexpected type, expected '${e}'` : "Unexpected type");
}
function wye(n) {
  if (_s(n))
    throw new Error("Assertion Failed: argument is undefined or null");
  return n;
}
function pv(n) {
  return typeof n == "function";
}
function Ioe(n, e) {
  const t = Math.min(n.length, e.length);
  for (let i = 0; i < t; i++)
    Poe(n[i], e[i]);
}
function Poe(n, e) {
  if (il(e)) {
    if (typeof n !== e)
      throw new Error(`argument does not match constraint: typeof ${e}`);
  } else if (pv(e)) {
    try {
      if (n instanceof e)
        return;
    } catch {
    }
    if (!_s(n) && n.constructor === e || e.length === 1 && e.call(void 0, n) === !0)
      return;
    throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
  }
}
function Aoe(n) {
  let e = [], t = Object.getPrototypeOf(n);
  for (; Object.prototype !== t; )
    e = e.concat(Object.getOwnPropertyNames(t)), t = Object.getPrototypeOf(t);
  return e;
}
function jN(n) {
  const e = [];
  for (const t of Aoe(n))
    typeof n[t] == "function" && e.push(t);
  return e;
}
function E5(n, e) {
  const t = (r) => function() {
    const o = Array.prototype.slice.call(arguments, 0);
    return e(r, o);
  };
  let i = {};
  for (const r of n)
    i[r] = t(r);
  return i;
}
function op(n) {
  return n === null ? void 0 : n;
}
function Moe(n) {
  throw new Error("Unreachable");
}
const Xo = Vt("commandService"), Qn = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._onDidRegisterCommand = new q(), this.onDidRegisterCommand = this._onDidRegisterCommand.event;
  }
  registerCommand(n, e) {
    if (!n)
      throw new Error("invalid command");
    if (typeof n == "string") {
      if (!e)
        throw new Error("invalid command");
      return this.registerCommand({ id: n, handler: e });
    }
    if (n.description) {
      const s = [];
      for (let l of n.description.args)
        s.push(l.constraint);
      const a = n.handler;
      n.handler = function(l, ...u) {
        return Ioe(u, s), a(l, ...u);
      };
    }
    const { id: t } = n;
    let i = this._commands.get(t);
    i || (i = new fa(), this._commands.set(t, i));
    let r = i.unshift(n), o = Oi(() => {
      r();
      const s = this._commands.get(t);
      s != null && s.isEmpty() && this._commands.delete(t);
    });
    return this._onDidRegisterCommand.fire(t), o;
  }
  registerCommandAlias(n, e) {
    return Qn.registerCommand(n, (t, ...i) => t.get(Xo).executeCommand(e, ...i));
  }
  getCommand(n) {
    const e = this._commands.get(n);
    if (!(!e || e.isEmpty()))
      return Ct.first(e);
  }
  getCommands() {
    const n = /* @__PURE__ */ new Map();
    for (const e of this._commands.keys()) {
      const t = this.getCommand(e);
      t && n.set(e, t);
    }
    return n;
  }
}();
Qn.registerCommand("noop", () => {
});
var gb;
(function(n) {
  n[n.API = 0] = "API", n[n.USER = 1] = "USER";
})(gb || (gb = {}));
var vk = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
const _k = Vt("openerService"), bye = Object.freeze({
  _serviceBrand: void 0,
  registerOpener() {
    return Ce.None;
  },
  registerValidator() {
    return Ce.None;
  },
  registerExternalUriResolver() {
    return Ce.None;
  },
  setDefaultExternalOpener() {
  },
  registerExternalOpener() {
    return Ce.None;
  },
  open() {
    return vk(this, void 0, void 0, function* () {
      return !1;
    });
  },
  resolveExternalUri(n) {
    return vk(this, void 0, void 0, function* () {
      return { resolved: n, dispose() {
      } };
    });
  }
});
function Kf(n, e) {
  return ft.isUri(n) ? Zm(n.scheme, e) : BN(n, e + ":");
}
var $N = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, mb = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, Yh = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
let _T = class {
  constructor(e) {
    this._commandService = e;
  }
  open(e, t) {
    return Yh(this, void 0, void 0, function* () {
      if (!Kf(e, vi.command))
        return !1;
      if (!(t != null && t.allowCommands))
        return !0;
      typeof e == "string" && (e = ft.parse(e));
      let i = [];
      try {
        i = mk(decodeURIComponent(e.query));
      } catch {
        try {
          i = mk(e.query);
        } catch {
        }
      }
      return Array.isArray(i) || (i = [i]), yield this._commandService.executeCommand(e.path, ...i), !0;
    });
  }
};
_T = $N([
  mb(0, Xo)
], _T);
let CT = class {
  constructor(e) {
    this._editorService = e;
  }
  open(e, t) {
    return Yh(this, void 0, void 0, function* () {
      typeof e == "string" && (e = ft.parse(e));
      let i;
      const r = /^L?(\d+)(?:,(\d+))?/.exec(e.fragment);
      return r && (i = {
        startLineNumber: parseInt(r[1]),
        startColumn: r[2] ? parseInt(r[2]) : 1
      }, e = e.with({ fragment: "" })), e.scheme === vi.file && (e = xoe(e)), yield this._editorService.openCodeEditor({
        resource: e,
        options: Object.assign({ selection: i, context: t != null && t.fromUserGesture ? gb.USER : gb.API }, t == null ? void 0 : t.editorOptions)
      }, this._editorService.getFocusedCodeEditor(), t == null ? void 0 : t.openToSide), !0;
    });
  }
};
CT = $N([
  mb(0, mr)
], CT);
let yT = class {
  constructor(e, t) {
    this._openers = new fa(), this._validators = new fa(), this._resolvers = new fa(), this._resolvedUriTargets = new So((i) => i.with({ path: null, fragment: null, query: null }).toString()), this._externalOpeners = new fa(), this._defaultExternalOpener = {
      openExternal: (i) => Yh(this, void 0, void 0, function* () {
        return Kf(i, vi.http) || Kf(i, vi.https) ? f5(i) : window.location.href = i, !0;
      })
    }, this._openers.push({
      open: (i, r) => Yh(this, void 0, void 0, function* () {
        return r != null && r.openExternal || Kf(i, vi.mailto) || Kf(i, vi.http) || Kf(i, vi.https) ? (yield this._doOpenExternal(i, r), !0) : !1;
      })
    }), this._openers.push(new _T(t)), this._openers.push(new CT(e));
  }
  registerOpener(e) {
    return { dispose: this._openers.unshift(e) };
  }
  registerValidator(e) {
    return { dispose: this._validators.push(e) };
  }
  registerExternalUriResolver(e) {
    return { dispose: this._resolvers.push(e) };
  }
  setDefaultExternalOpener(e) {
    this._defaultExternalOpener = e;
  }
  registerExternalOpener(e) {
    return { dispose: this._externalOpeners.push(e) };
  }
  open(e, t) {
    var i;
    return Yh(this, void 0, void 0, function* () {
      const r = typeof e == "string" ? ft.parse(e) : e, o = (i = this._resolvedUriTargets.get(r)) !== null && i !== void 0 ? i : e;
      for (const s of this._validators)
        if (!(yield s.shouldOpen(o)))
          return !1;
      for (const s of this._openers)
        if (yield s.open(e, t))
          return !0;
      return !1;
    });
  }
  resolveExternalUri(e, t) {
    return Yh(this, void 0, void 0, function* () {
      for (const i of this._resolvers)
        try {
          const r = yield i.resolveExternalUri(e, t);
          if (r)
            return this._resolvedUriTargets.has(r.resolved) || this._resolvedUriTargets.set(r.resolved, e), r;
        } catch {
        }
      throw new Error("Could not resolve external URI: " + e.toString());
    });
  }
  _doOpenExternal(e, t) {
    return Yh(this, void 0, void 0, function* () {
      const i = typeof e == "string" ? ft.parse(e) : e;
      let r;
      try {
        r = (yield this.resolveExternalUri(i, t)).resolved;
      } catch {
        r = i;
      }
      let o;
      if (typeof e == "string" && i.toString() === r.toString() ? o = e : o = encodeURI(r.toString(!0)), t != null && t.allowContributedOpeners) {
        const s = typeof (t == null ? void 0 : t.allowContributedOpeners) == "string" ? t == null ? void 0 : t.allowContributedOpeners : void 0;
        for (const a of this._externalOpeners)
          if (yield a.openExternal(o, {
            sourceUri: i,
            preferredOpenerId: s
          }, Ko.None))
            return !0;
      }
      return this._defaultExternalOpener.openExternal(o, { sourceUri: i }, Ko.None);
    });
  }
  dispose() {
    this._validators.clear();
  }
};
yT = $N([
  mb(0, mr),
  mb(1, Xo)
], yT);
function sw(n, e) {
  if (!n)
    throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed");
}
function Xh(n) {
  if (!n || typeof n != "object" || n instanceof RegExp)
    return n;
  const e = Array.isArray(n) ? [] : {};
  return Object.keys(n).forEach((t) => {
    n[t] && typeof n[t] == "object" ? e[t] = Xh(n[t]) : e[t] = n[t];
  }), e;
}
function Foe(n) {
  if (!n || typeof n != "object")
    return n;
  const e = [n];
  for (; e.length > 0; ) {
    const t = e.shift();
    Object.freeze(t);
    for (const i in t)
      if (L5.call(t, i)) {
        const r = t[i];
        typeof r == "object" && !Object.isFrozen(r) && e.push(r);
      }
  }
  return n;
}
const L5 = Object.prototype.hasOwnProperty;
function Dye(n, e) {
  return wT(n, e, /* @__PURE__ */ new Set());
}
function wT(n, e, t) {
  if (_s(n))
    return n;
  const i = e(n);
  if (typeof i < "u")
    return i;
  if (Noe(n)) {
    const r = [];
    for (const o of n)
      r.push(wT(o, e, t));
    return r;
  }
  if (Uo(n)) {
    if (t.has(n))
      throw new Error("Cannot clone recursive data-structure");
    t.add(n);
    const r = {};
    for (let o in n)
      L5.call(n, o) && (r[o] = wT(n[o], e, t));
    return t.delete(n), r;
  }
  return n;
}
function vh(n, e, t = !0) {
  return Uo(n) ? (Uo(e) && Object.keys(e).forEach((i) => {
    i in n ? t && (Uo(n[i]) && Uo(e[i]) ? vh(n[i], e[i], t) : n[i] = e[i]) : n[i] = e[i];
  }), n) : e;
}
function qu(n, e) {
  if (n === e)
    return !0;
  if (n == null || e === null || e === void 0 || typeof n != typeof e || typeof n != "object" || Array.isArray(n) !== Array.isArray(e))
    return !1;
  let t, i;
  if (Array.isArray(n)) {
    if (n.length !== e.length)
      return !1;
    for (t = 0; t < n.length; t++)
      if (!qu(n[t], e[t]))
        return !1;
  } else {
    const r = [];
    for (i in n)
      r.push(i);
    r.sort();
    const o = [];
    for (i in e)
      o.push(i);
    if (o.sort(), !qu(r, o))
      return !1;
    for (t = 0; t < r.length; t++)
      if (!qu(n[r[t]], e[r[t]]))
        return !1;
  }
  return !0;
}
function Tl(n, e, t) {
  const i = e(n);
  return typeof i > "u" ? t : i;
}
const koe = {
  followsCaret: !0,
  ignoreCharChanges: !0,
  alwaysRevealFirst: !0
};
class Woe extends Ce {
  constructor(e, t = {}) {
    super(), this._onDidUpdate = this._register(new q()), this._editor = e, this._options = vh(t, koe, !1), this.disposed = !1, this.nextIdx = -1, this.ranges = [], this.ignoreSelectionChange = !1, this.revealFirst = !!this._options.alwaysRevealFirst, this._register(this._editor.onDidDispose(() => this.dispose())), this._register(this._editor.onDidUpdateDiff(() => this._onDiffUpdated())), this._options.followsCaret && this._register(this._editor.getModifiedEditor().onDidChangeCursorPosition((i) => {
      this.ignoreSelectionChange || (this.nextIdx = -1);
    })), this._options.alwaysRevealFirst && this._register(this._editor.getModifiedEditor().onDidChangeModel((i) => {
      this.revealFirst = !0;
    })), this._init();
  }
  _init() {
    this._editor.getLineChanges();
  }
  _onDiffUpdated() {
    this._init(), this._compute(this._editor.getLineChanges()), this.revealFirst && this._editor.getLineChanges() !== null && (this.revealFirst = !1, this.nextIdx = -1, this.next(
      1
      /* Immediate */
    ));
  }
  _compute(e) {
    this.ranges = [], e && e.forEach((t) => {
      !this._options.ignoreCharChanges && t.charChanges ? t.charChanges.forEach((i) => {
        this.ranges.push({
          rhs: !0,
          range: new G(i.modifiedStartLineNumber, i.modifiedStartColumn, i.modifiedEndLineNumber, i.modifiedEndColumn)
        });
      }) : this.ranges.push({
        rhs: !0,
        range: new G(t.modifiedStartLineNumber, 1, t.modifiedStartLineNumber, 1)
      });
    }), this.ranges.sort((t, i) => t.range.getStartPosition().isBeforeOrEqual(i.range.getStartPosition()) ? -1 : i.range.getStartPosition().isBeforeOrEqual(t.range.getStartPosition()) ? 1 : 0), this._onDidUpdate.fire(this);
  }
  _initIdx(e) {
    let t = !1, i = this._editor.getPosition();
    if (!i) {
      this.nextIdx = 0;
      return;
    }
    for (let r = 0, o = this.ranges.length; r < o && !t; r++) {
      let s = this.ranges[r].range;
      i.isBeforeOrEqual(s.getStartPosition()) && (this.nextIdx = r + (e ? 0 : -1), t = !0);
    }
    t || (this.nextIdx = e ? 0 : this.ranges.length - 1), this.nextIdx < 0 && (this.nextIdx = this.ranges.length - 1);
  }
  _move(e, t) {
    if (sw(!this.disposed, "Illegal State - diff navigator has been disposed"), !this.canNavigate())
      return;
    this.nextIdx === -1 ? this._initIdx(e) : e ? (this.nextIdx += 1, this.nextIdx >= this.ranges.length && (this.nextIdx = 0)) : (this.nextIdx -= 1, this.nextIdx < 0 && (this.nextIdx = this.ranges.length - 1));
    let i = this.ranges[this.nextIdx];
    this.ignoreSelectionChange = !0;
    try {
      let r = i.range.getStartPosition();
      this._editor.setPosition(r), this._editor.revealPositionInCenter(r, t);
    } finally {
      this.ignoreSelectionChange = !1;
    }
  }
  canNavigate() {
    return this.ranges && this.ranges.length > 0;
  }
  next(e = 0) {
    this._move(!0, e);
  }
  previous(e = 0) {
    this._move(!1, e);
  }
  dispose() {
    super.dispose(), this.ranges = [], this.disposed = !0;
  }
}
const vb = new class {
  constructor() {
    this._zoomLevel = 0, this._onDidChangeZoomLevel = new q(), this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  setZoomLevel(n) {
    n = Math.min(Math.max(-5, n), 20), this._zoomLevel !== n && (this._zoomLevel = n, this._onDidChangeZoomLevel.fire(this._zoomLevel));
  }
}(), Voe = kt ? 1.5 : 1.35, Ck = 8;
class Zp {
  /**
   * @internal
   */
  constructor(e) {
    this.zoomLevel = e.zoomLevel, this.pixelRatio = e.pixelRatio, this.fontFamily = String(e.fontFamily), this.fontWeight = String(e.fontWeight), this.fontSize = e.fontSize, this.fontFeatureSettings = e.fontFeatureSettings, this.lineHeight = e.lineHeight | 0, this.letterSpacing = e.letterSpacing;
  }
  /**
   * @internal
   */
  static createFromValidatedSettings(e, t, i, r) {
    const o = e.get(
      39
      /* fontFamily */
    ), s = e.get(
      43
      /* fontWeight */
    ), a = e.get(
      42
      /* fontSize */
    ), l = e.get(
      41
      /* fontLigatures */
    ), u = e.get(
      56
      /* lineHeight */
    ), c = e.get(
      53
      /* letterSpacing */
    );
    return Zp._create(o, s, a, l, u, c, t, i, r);
  }
  /**
   * @internal
   */
  static _create(e, t, i, r, o, s, a, l, u) {
    o === 0 ? o = Math.round(Voe * i) : o < Ck && (o = Ck);
    const c = 1 + (u ? 0 : vb.getZoomLevel() * 0.1);
    return i *= c, o *= c, new Zp({
      zoomLevel: a,
      pixelRatio: l,
      fontFamily: e,
      fontWeight: t,
      fontSize: i,
      fontFeatureSettings: r,
      lineHeight: o,
      letterSpacing: s
    });
  }
  /**
   * @internal
   */
  getId() {
    return this.zoomLevel + "-" + this.pixelRatio + "-" + this.fontFamily + "-" + this.fontWeight + "-" + this.fontSize + "-" + this.fontFeatureSettings + "-" + this.lineHeight + "-" + this.letterSpacing;
  }
  /**
   * @internal
   */
  getMassagedFontFamily() {
    return /[,"']/.test(this.fontFamily) ? this.fontFamily : /[+ ]/.test(this.fontFamily) ? `"${this.fontFamily}"` : this.fontFamily;
  }
}
const Boe = 1;
class bT extends Zp {
  /**
   * @internal
   */
  constructor(e, t) {
    super(e), this.version = Boe, this.isTrusted = t, this.isMonospace = e.isMonospace, this.typicalHalfwidthCharacterWidth = e.typicalHalfwidthCharacterWidth, this.typicalFullwidthCharacterWidth = e.typicalFullwidthCharacterWidth, this.canUseHalfwidthRightwardsArrow = e.canUseHalfwidthRightwardsArrow, this.spaceWidth = e.spaceWidth, this.middotWidth = e.middotWidth, this.wsmiddotWidth = e.wsmiddotWidth, this.maxDigitWidth = e.maxDigitWidth;
  }
  /**
   * @internal
   */
  equals(e) {
    return this.fontFamily === e.fontFamily && this.fontWeight === e.fontWeight && this.fontSize === e.fontSize && this.fontFeatureSettings === e.fontFeatureSettings && this.lineHeight === e.lineHeight && this.letterSpacing === e.letterSpacing && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === e.typicalFullwidthCharacterWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.maxDigitWidth === e.maxDigitWidth;
  }
}
function Hoe(n) {
  return n && typeof n.id == "string";
}
const $_ = {
  ICodeEditor: "vs.editor.ICodeEditor",
  IDiffEditor: "vs.editor.IDiffEditor"
};
var Xv;
(function(n) {
  n[n.Left = 1] = "Left", n[n.Center = 2] = "Center", n[n.Right = 4] = "Right", n[n.Full = 7] = "Full";
})(Xv || (Xv = {}));
var Qp;
(function(n) {
  n[n.Inline = 1] = "Inline", n[n.Gutter = 2] = "Gutter";
})(Qp || (Qp = {}));
class aw {
  /**
   * @internal
   */
  constructor(e) {
    this.tabSize = Math.max(1, e.tabSize | 0), this.indentSize = e.tabSize | 0, this.insertSpaces = !!e.insertSpaces, this.defaultEOL = e.defaultEOL | 0, this.trimAutoWhitespace = !!e.trimAutoWhitespace;
  }
  /**
   * @internal
   */
  equals(e) {
    return this.tabSize === e.tabSize && this.indentSize === e.indentSize && this.insertSpaces === e.insertSpaces && this.defaultEOL === e.defaultEOL && this.trimAutoWhitespace === e.trimAutoWhitespace;
  }
  /**
   * @internal
   */
  createChangeEvent(e) {
    return {
      tabSize: this.tabSize !== e.tabSize,
      indentSize: this.indentSize !== e.indentSize,
      insertSpaces: this.insertSpaces !== e.insertSpaces,
      trimAutoWhitespace: this.trimAutoWhitespace !== e.trimAutoWhitespace
    };
  }
}
class Zv {
  /**
   * @internal
   */
  constructor(e, t) {
    this.range = e, this.matches = t;
  }
}
class pD {
  constructor(e, t, i, r, o, s) {
    this.identifier = e, this.range = t, this.text = i, this.forceMoveMarkers = r, this.isAutoWhitespaceEdit = o, this._isTracked = s;
  }
}
class Goe {
  constructor(e, t, i) {
    this.reverseEdits = e, this.changes = t, this.trimAutoWhitespaceLineNumbers = i;
  }
}
function Uoe(n) {
  return KN(n, 0);
}
function KN(n, e) {
  switch (typeof n) {
    case "object":
      return n === null ? $u(349, e) : Array.isArray(n) ? joe(n, e) : $oe(n, e);
    case "string":
      return qN(n, e);
    case "boolean":
      return zoe(n, e);
    case "number":
      return $u(n, e);
    case "undefined":
      return $u(937, e);
    default:
      return $u(617, e);
  }
}
function $u(n, e) {
  return (e << 5) - e + n | 0;
}
function zoe(n, e) {
  return $u(n ? 433 : 863, e);
}
function qN(n, e) {
  e = $u(149417, e);
  for (let t = 0, i = n.length; t < i; t++)
    e = $u(n.charCodeAt(t), e);
  return e;
}
function joe(n, e) {
  return e = $u(104579, e), n.reduce((t, i) => KN(i, t), e);
}
function $oe(n, e) {
  return e = $u(181387, e), Object.keys(n).sort().reduce((t, i) => (t = qN(i, t), KN(n[i], t)), e);
}
function gD(n, e, t = 32) {
  const i = t - e, r = ~((1 << i) - 1);
  return (n << e | (r & n) >>> i) >>> 0;
}
function yk(n, e = 0, t = n.byteLength, i = 0) {
  for (let r = 0; r < t; r++)
    n[e + r] = i;
}
function Koe(n, e, t = "0") {
  for (; n.length < e; )
    n = t + n;
  return n;
}
function Am(n, e = 32) {
  return n instanceof ArrayBuffer ? Array.from(new Uint8Array(n)).map((t) => t.toString(16).padStart(2, "0")).join("") : Koe((n >>> 0).toString(16), e / 4);
}
class oE {
  constructor() {
    this._h0 = 1732584193, this._h1 = 4023233417, this._h2 = 2562383102, this._h3 = 271733878, this._h4 = 3285377520, this._buff = new Uint8Array(
      64 + 3
      /* to fit any utf-8 */
    ), this._buffDV = new DataView(this._buff.buffer), this._buffLen = 0, this._totalLen = 0, this._leftoverHighSurrogate = 0, this._finished = !1;
  }
  update(e) {
    const t = e.length;
    if (t === 0)
      return;
    const i = this._buff;
    let r = this._buffLen, o = this._leftoverHighSurrogate, s, a;
    for (o !== 0 ? (s = o, a = -1, o = 0) : (s = e.charCodeAt(0), a = 0); ; ) {
      let l = s;
      if (Kn(s))
        if (a + 1 < t) {
          const u = e.charCodeAt(a + 1);
          Yv(u) ? (a++, l = HN(s, u)) : l = 65533;
        } else {
          o = s;
          break;
        }
      else
        Yv(s) && (l = 65533);
      if (r = this._push(i, r, l), a++, a < t)
        s = e.charCodeAt(a);
      else
        break;
    }
    this._buffLen = r, this._leftoverHighSurrogate = o;
  }
  _push(e, t, i) {
    return i < 128 ? e[t++] = i : i < 2048 ? (e[t++] = 192 | (i & 1984) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : i < 65536 ? (e[t++] = 224 | (i & 61440) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : (e[t++] = 240 | (i & 1835008) >>> 18, e[t++] = 128 | (i & 258048) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0), t >= 64 && (this._step(), t -= 64, this._totalLen += 64, e[0] = e[64 + 0], e[1] = e[64 + 1], e[2] = e[64 + 2]), t;
  }
  digest() {
    return this._finished || (this._finished = !0, this._leftoverHighSurrogate && (this._leftoverHighSurrogate = 0, this._buffLen = this._push(
      this._buff,
      this._buffLen,
      65533
      /* UNICODE_REPLACEMENT */
    )), this._totalLen += this._buffLen, this._wrapUp()), Am(this._h0) + Am(this._h1) + Am(this._h2) + Am(this._h3) + Am(this._h4);
  }
  _wrapUp() {
    this._buff[this._buffLen++] = 128, yk(this._buff, this._buffLen), this._buffLen > 56 && (this._step(), yk(this._buff));
    const e = 8 * this._totalLen;
    this._buffDV.setUint32(56, Math.floor(e / 4294967296), !1), this._buffDV.setUint32(60, e % 4294967296, !1), this._step();
  }
  _step() {
    const e = oE._bigBlock32, t = this._buffDV;
    for (let h = 0; h < 64; h += 4)
      e.setUint32(h, t.getUint32(h, !1), !1);
    for (let h = 64; h < 320; h += 4)
      e.setUint32(h, gD(e.getUint32(h - 12, !1) ^ e.getUint32(h - 32, !1) ^ e.getUint32(h - 56, !1) ^ e.getUint32(h - 64, !1), 1), !1);
    let i = this._h0, r = this._h1, o = this._h2, s = this._h3, a = this._h4, l, u, c;
    for (let h = 0; h < 80; h++)
      h < 20 ? (l = r & o | ~r & s, u = 1518500249) : h < 40 ? (l = r ^ o ^ s, u = 1859775393) : h < 60 ? (l = r & o | r & s | o & s, u = 2400959708) : (l = r ^ o ^ s, u = 3395469782), c = gD(i, 5) + l + a + u + e.getUint32(h * 4, !1) & 4294967295, a = s, s = o, o = gD(r, 30), r = i, i = c;
    this._h0 = this._h0 + i & 4294967295, this._h1 = this._h1 + r & 4294967295, this._h2 = this._h2 + o & 4294967295, this._h3 = this._h3 + s & 4294967295, this._h4 = this._h4 + a & 4294967295;
  }
}
oE._bigBlock32 = new DataView(new ArrayBuffer(320));
function Fa(n, e, t) {
  return Math.min(Math.max(n, e), t);
}
class qoe {
  constructor() {
    this._n = 1, this._val = 0;
  }
  update(e) {
    return this._val = this._val + (e - this._val) / this._n, this._n += 1, this;
  }
  get value() {
    return this._val;
  }
}
const mD = "**", wk = "/", lw = "[/\\\\]", uw = "[^/\\\\]", Yoe = /\//g;
function bk(n) {
  switch (n) {
    case 0:
      return "";
    case 1:
      return `${uw}*?`;
    default:
      return `(?:${lw}|${uw}+${lw}|${lw}${uw}+)*?`;
  }
}
function Sk(n, e) {
  if (!n)
    return [];
  const t = [];
  let i = !1, r = !1, o = "";
  for (const s of n) {
    switch (s) {
      case e:
        if (!i && !r) {
          t.push(o), o = "";
          continue;
        }
        break;
      case "{":
        i = !0;
        break;
      case "}":
        i = !1;
        break;
      case "[":
        r = !0;
        break;
      case "]":
        r = !1;
        break;
    }
    o += s;
  }
  return o && t.push(o), t;
}
function D5(n) {
  if (!n)
    return "";
  let e = "";
  const t = Sk(n, wk);
  if (t.every((i) => i === mD))
    e = ".*";
  else {
    let i = !1;
    t.forEach((r, o) => {
      if (r === mD) {
        i || (e += bk(2), i = !0);
        return;
      }
      let s = !1, a = "", l = !1, u = "";
      for (const c of r) {
        if (c !== "}" && s) {
          a += c;
          continue;
        }
        if (l && (c !== "]" || !u)) {
          let h;
          c === "-" ? h = c : (c === "^" || c === "!") && !u ? h = "^" : c === wk ? h = "" : h = Xp(c), u += h;
          continue;
        }
        switch (c) {
          case "{":
            s = !0;
            continue;
          case "[":
            l = !0;
            continue;
          case "}":
            const d = `(?:${Sk(a, ",").map((f) => D5(f)).join("|")})`;
            e += d, s = !1, a = "";
            break;
          case "]":
            e += "[" + u + "]", l = !1, u = "";
            break;
          case "?":
            e += uw;
            continue;
          case "*":
            e += bk(1);
            continue;
          default:
            e += Xp(c);
        }
      }
      o < t.length - 1 && (t[o + 1] !== mD || o + 2 < t.length) && (e += lw), i = !1;
    });
  }
  return e;
}
const Xoe = /^\*\*\/\*\.[\w\.-]+$/, Zoe = /^\*\*\/([\w\.-]+)\/?$/, Qoe = /^{\*\*\/[\*\.]?[\w\.-]+\/?(,\*\*\/[\*\.]?[\w\.-]+\/?)*}$/, Joe = /^{\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?(,\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?)*}$/, ese = /^\*\*((\/[\w\.-]+)+)\/?$/, tse = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/, Ek = new zN(1e4), Lk = function() {
  return !1;
}, Ul = function() {
  return null;
};
function YN(n, e) {
  if (!n)
    return Ul;
  let t;
  typeof n != "string" ? t = n.pattern : t = n, t = t.trim();
  const i = `${t}_${!!e.trimForExclusions}`;
  let r = Ek.get(i);
  if (r)
    return Dk(r, n);
  let o;
  if (Xoe.test(t)) {
    const s = t.substr(4);
    r = function(a, l) {
      return typeof a == "string" && a.endsWith(s) ? t : null;
    };
  } else
    (o = Zoe.exec(vD(t, e))) ? r = ise(o[1], t) : (e.trimForExclusions ? Joe : Qoe).test(t) ? r = nse(t, e) : (o = ese.exec(vD(t, e))) ? r = Rk(o[1].substr(1), t, !0) : (o = tse.exec(vD(t, e))) ? r = Rk(o[1], t, !1) : r = rse(t);
  return Ek.set(i, r), Dk(r, n);
}
function Dk(n, e) {
  return typeof e == "string" ? n : function(t, i) {
    return Doe(t, e.base) ? n(ure(e.base, t), i) : null;
  };
}
function vD(n, e) {
  return e.trimForExclusions && n.endsWith("/**") ? n.substr(0, n.length - 2) : n;
}
function ise(n, e) {
  const t = `/${n}`, i = `\\${n}`, r = function(s, a) {
    return typeof s != "string" ? null : a ? a === n ? e : null : s === n || s.endsWith(t) || s.endsWith(i) ? e : null;
  }, o = [n];
  return r.basenames = o, r.patterns = [e], r.allBasenames = o, r;
}
function nse(n, e) {
  const t = T5(n.slice(1, -1).split(",").map((a) => YN(a, e)).filter((a) => a !== Ul), n), i = t.length;
  if (!i)
    return Ul;
  if (i === 1)
    return t[0];
  const r = function(a, l) {
    for (let u = 0, c = t.length; u < c; u++)
      if (t[u](a, l))
        return n;
    return null;
  }, o = t.find((a) => !!a.allBasenames);
  o && (r.allBasenames = o.allBasenames);
  const s = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return s.length && (r.allPaths = s), r;
}
function Rk(n, e, t) {
  const i = rw === _n.sep, r = i ? n : n.replace(Yoe, rw), o = rw + r, s = _n.sep + n, a = t ? function(l, u) {
    return typeof l == "string" && (l === r || l.endsWith(o) || !i && (l === n || l.endsWith(s))) ? e : null;
  } : function(l, u) {
    return typeof l == "string" && (l === r || !i && l === n) ? e : null;
  };
  return a.allPaths = [(t ? "*/" : "./") + n], a;
}
function rse(n) {
  try {
    const e = new RegExp(`^${D5(n)}$`);
    return function(t) {
      return e.lastIndex = 0, typeof t == "string" && e.test(t) ? n : null;
    };
  } catch {
    return Ul;
  }
}
function R5(n, e, t) {
  return !n || typeof e != "string" ? !1 : ose(n)(e, void 0, t);
}
function ose(n, e = {}) {
  if (!n)
    return Lk;
  if (typeof n == "string" || sse(n)) {
    const t = YN(n, e);
    if (t === Ul)
      return Lk;
    const i = function(r, o) {
      return !!t(r, o);
    };
    return t.allBasenames && (i.allBasenames = t.allBasenames), t.allPaths && (i.allPaths = t.allPaths), i;
  }
  return ase(n, e);
}
function sse(n) {
  const e = n;
  return e && typeof e.base == "string" && typeof e.pattern == "string";
}
function ase(n, e) {
  const t = T5(Object.getOwnPropertyNames(n).map((a) => lse(a, n[a], e)).filter((a) => a !== Ul)), i = t.length;
  if (!i)
    return Ul;
  if (!t.some((a) => !!a.requiresSiblings)) {
    if (i === 1)
      return t[0];
    const a = function(c, h) {
      for (let d = 0, f = t.length; d < f; d++) {
        const p = t[d](c, h);
        if (p)
          return p;
      }
      return null;
    }, l = t.find((c) => !!c.allBasenames);
    l && (a.allBasenames = l.allBasenames);
    const u = t.reduce((c, h) => h.allPaths ? c.concat(h.allPaths) : c, []);
    return u.length && (a.allPaths = u), a;
  }
  const r = function(a, l, u) {
    let c;
    for (let h = 0, d = t.length; h < d; h++) {
      const f = t[h];
      f.requiresSiblings && u && (l || (l = zG(a)), c || (c = l.substr(0, l.length - hre(a).length)));
      const p = f(a, l, c, u);
      if (p)
        return p;
    }
    return null;
  }, o = t.find((a) => !!a.allBasenames);
  o && (r.allBasenames = o.allBasenames);
  const s = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return s.length && (r.allPaths = s), r;
}
function lse(n, e, t) {
  if (e === !1)
    return Ul;
  const i = YN(n, t);
  if (i === Ul)
    return Ul;
  if (typeof e == "boolean")
    return i;
  if (e) {
    const r = e.when;
    if (typeof r == "string") {
      const o = (s, a, l, u) => {
        if (!u || !i(s, a))
          return null;
        const c = r.replace("$(basename)", l), h = u(c);
        return Nre(h) ? h.then((d) => d ? n : null) : h ? n : null;
      };
      return o.requiresSiblings = !0, o;
    }
  }
  return i;
}
function T5(n, e) {
  const t = n.filter((a) => !!a.basenames);
  if (t.length < 2)
    return n;
  const i = t.reduce((a, l) => {
    const u = l.basenames;
    return u ? a.concat(u) : a;
  }, []);
  let r;
  if (e) {
    r = [];
    for (let a = 0, l = i.length; a < l; a++)
      r.push(e);
  } else
    r = t.reduce((a, l) => {
      const u = l.patterns;
      return u ? a.concat(u) : a;
    }, []);
  const o = function(a, l) {
    if (typeof a != "string")
      return null;
    if (!l) {
      let c;
      for (c = a.length; c > 0; c--) {
        const h = a.charCodeAt(c - 1);
        if (h === 47 || h === 92)
          break;
      }
      l = a.substr(c);
    }
    const u = i.indexOf(l);
    return u !== -1 ? r[u] : null;
  };
  o.basenames = i, o.patterns = r, o.allBasenames = i;
  const s = n.filter((a) => !a.basenames);
  return s.push(o), s;
}
function O5(n, e, t, i) {
  if (Array.isArray(n)) {
    let r = 0;
    for (const o of n) {
      const s = O5(o, e, t, i);
      if (s === 10)
        return s;
      s > r && (r = s);
    }
    return r;
  } else {
    if (typeof n == "string")
      return i ? n === "*" ? 5 : n === t ? 10 : 0 : 0;
    if (n) {
      const { language: r, pattern: o, scheme: s, hasAccessToAllModels: a } = n;
      if (!i && !a)
        return 0;
      let l = 0;
      if (s)
        if (s === e.scheme)
          l = 10;
        else if (s === "*")
          l = 5;
        else
          return 0;
      if (r)
        if (r === t)
          l = 10;
        else if (r === "*")
          l = Math.max(l, 5);
        else
          return 0;
      if (o) {
        let u;
        if (typeof o == "string" ? u = o : u = Object.assign(Object.assign({}, o), { base: IN(o.base) }), u === e.fsPath || R5(u, e.fsPath))
          l = 10;
        else
          return 0;
      }
      return l;
    } else
      return 0;
  }
}
const ao = Vt("modelService");
function use(n) {
  return !n.isTooLargeForSyncing() && !n.isForSimpleWidget;
}
function x5(n) {
  return typeof n == "string" ? !1 : Array.isArray(n) ? n.every(x5) : !!n.exclusive;
}
class Gi {
  constructor() {
    this._clock = 0, this._entries = [], this._onDidChange = new q();
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  register(e, t) {
    let i = {
      selector: e,
      provider: t,
      _score: -1,
      _time: this._clock++
    };
    return this._entries.push(i), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), Oi(() => {
      if (i) {
        let r = this._entries.indexOf(i);
        r >= 0 && (this._entries.splice(r, 1), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), i = void 0);
      }
    });
  }
  has(e) {
    return this.all(e).length > 0;
  }
  all(e) {
    if (!e)
      return [];
    this._updateScores(e);
    const t = [];
    for (let i of this._entries)
      i._score > 0 && t.push(i.provider);
    return t;
  }
  ordered(e) {
    const t = [];
    return this._orderedForEach(e, (i) => t.push(i.provider)), t;
  }
  orderedGroups(e) {
    const t = [];
    let i, r;
    return this._orderedForEach(e, (o) => {
      i && r === o._score ? i.push(o.provider) : (r = o._score, i = [o.provider], t.push(i));
    }), t;
  }
  _orderedForEach(e, t) {
    if (e) {
      this._updateScores(e);
      for (const i of this._entries)
        i._score > 0 && t(i);
    }
  }
  _updateScores(e) {
    let t = {
      uri: e.uri.toString(),
      language: e.getLanguageIdentifier().language
    };
    if (!(this._lastCandidate && this._lastCandidate.language === t.language && this._lastCandidate.uri === t.uri)) {
      this._lastCandidate = t;
      for (let i of this._entries)
        if (i._score = O5(i.selector, e.uri, e.getLanguageIdentifier().language, use(e)), x5(i.selector) && i._score > 0) {
          for (let r of this._entries)
            r._score = 0;
          i._score = 1e3;
          break;
        }
      this._entries.sort(Gi._compareByScoreAndTime);
    }
  }
  static _compareByScoreAndTime(e, t) {
    return e._score < t._score ? 1 : e._score > t._score ? -1 : e._time < t._time ? 1 : e._time > t._time ? -1 : 0;
  }
}
class Rye {
  constructor(e, t, i = Number.MAX_SAFE_INTEGER) {
    this._registry = e, this.min = t, this.max = i, this._cache = new zN(50, 0.7);
  }
  _key(e) {
    return e.id + Uoe(this._registry.all(e));
  }
  _clamp(e) {
    return e === void 0 ? this.min : Math.min(this.max, Math.max(this.min, Math.floor(e * 1.3)));
  }
  get(e) {
    const t = this._key(e), i = this._cache.get(t);
    return this._clamp(i == null ? void 0 : i.value);
  }
  update(e, t) {
    const i = this._key(e);
    let r = this._cache.get(i);
    return r || (r = new qoe(), this._cache.set(i, r)), r.update(t), this.get(e);
  }
}
class cse {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._promises = /* @__PURE__ */ new Map(), this._onDidChange = new q(), this.onDidChange = this._onDidChange.event, this._colorMap = null;
  }
  fire(e) {
    this._onDidChange.fire({
      changedLanguages: e,
      changedColorMap: !1
    });
  }
  register(e, t) {
    return this._map.set(e, t), this.fire([e]), Oi(() => {
      this._map.get(e) === t && (this._map.delete(e), this.fire([e]));
    });
  }
  registerPromise(e, t) {
    let i = null, r = !1;
    return this._promises.set(e, t.then((o) => {
      this._promises.delete(e), !(r || !o) && (i = this.register(e, o));
    })), Oi(() => {
      r = !0, i && i.dispose();
    });
  }
  getPromise(e) {
    const t = this.get(e);
    if (t)
      return Promise.resolve(t);
    const i = this._promises.get(e);
    return i ? i.then((r) => this.get(e)) : null;
  }
  get(e) {
    return this._map.get(e) || null;
  }
  setColorMap(e) {
    this._colorMap = e, this._onDidChange.fire({
      changedLanguages: Array.from(this._map.keys()),
      changedColorMap: !0
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    return this._colorMap && this._colorMap.length > 2 ? this._colorMap[
      2
      /* DefaultBackground */
    ] : null;
  }
}
let hse = class {
  constructor() {
    this._icons = /* @__PURE__ */ new Map(), this._onDidRegister = new q();
  }
  add(e) {
    const t = this._icons.get(e.id);
    t ? e.description ? t.description = e.description : console.error(`Duplicate registration of codicon ${e.id}`) : (this._icons.set(e.id, e), this._onDidRegister.fire(e));
  }
  get(e) {
    return this._icons.get(e);
  }
  get all() {
    return this._icons.values();
  }
  get onDidRegister() {
    return this._onDidRegister.event;
  }
};
const N5 = new hse(), _b = N5;
function ya(n, e) {
  return new Hi(n, e);
}
function dse(n) {
  return n ? n.replace(/\$\((.*?)\)/g, (e, t) => ` ${t} `).trim() : "";
}
class Hi {
  constructor(e, t, i) {
    this.id = e, this.definition = t, this.description = i, N5.add(this);
  }
  get classNames() {
    return "codicon codicon-" + this.id;
  }
  // classNamesArray is useful for migrating to ES6 classlist
  get classNamesArray() {
    return ["codicon", "codicon-" + this.id];
  }
  get cssSelector() {
    return ".codicon.codicon-" + this.id;
  }
}
var Go;
(function(n) {
  n.iconNameSegment = "[A-Za-z0-9]+", n.iconNameExpression = "[A-Za-z0-9\\-]+", n.iconModifierExpression = "~[A-Za-z]+";
  const e = new RegExp(`^(${n.iconNameExpression})(${n.iconModifierExpression})?$`);
  function t(o) {
    if (o instanceof Hi)
      return ["codicon", "codicon-" + o.id];
    const s = e.exec(o.id);
    if (!s)
      return t(Hi.error);
    let [, a, l] = s;
    const u = ["codicon", "codicon-" + a];
    return l && u.push("codicon-modifier-" + l.substr(1)), u;
  }
  n.asClassNameArray = t;
  function i(o) {
    return t(o).join(" ");
  }
  n.asClassName = i;
  function r(o) {
    return "." + t(o).join(".");
  }
  n.asCSSSelector = r;
})(Go || (Go = {}));
(function(n) {
  n.add = new n("add", { fontCharacter: "\\ea60" }), n.plus = new n("plus", { fontCharacter: "\\ea60" }), n.gistNew = new n("gist-new", { fontCharacter: "\\ea60" }), n.repoCreate = new n("repo-create", { fontCharacter: "\\ea60" }), n.lightbulb = new n("lightbulb", { fontCharacter: "\\ea61" }), n.lightBulb = new n("light-bulb", { fontCharacter: "\\ea61" }), n.repo = new n("repo", { fontCharacter: "\\ea62" }), n.repoDelete = new n("repo-delete", { fontCharacter: "\\ea62" }), n.gistFork = new n("gist-fork", { fontCharacter: "\\ea63" }), n.repoForked = new n("repo-forked", { fontCharacter: "\\ea63" }), n.gitPullRequest = new n("git-pull-request", { fontCharacter: "\\ea64" }), n.gitPullRequestAbandoned = new n("git-pull-request-abandoned", { fontCharacter: "\\ea64" }), n.recordKeys = new n("record-keys", { fontCharacter: "\\ea65" }), n.keyboard = new n("keyboard", { fontCharacter: "\\ea65" }), n.tag = new n("tag", { fontCharacter: "\\ea66" }), n.tagAdd = new n("tag-add", { fontCharacter: "\\ea66" }), n.tagRemove = new n("tag-remove", { fontCharacter: "\\ea66" }), n.person = new n("person", { fontCharacter: "\\ea67" }), n.personFollow = new n("person-follow", { fontCharacter: "\\ea67" }), n.personOutline = new n("person-outline", { fontCharacter: "\\ea67" }), n.personFilled = new n("person-filled", { fontCharacter: "\\ea67" }), n.gitBranch = new n("git-branch", { fontCharacter: "\\ea68" }), n.gitBranchCreate = new n("git-branch-create", { fontCharacter: "\\ea68" }), n.gitBranchDelete = new n("git-branch-delete", { fontCharacter: "\\ea68" }), n.sourceControl = new n("source-control", { fontCharacter: "\\ea68" }), n.mirror = new n("mirror", { fontCharacter: "\\ea69" }), n.mirrorPublic = new n("mirror-public", { fontCharacter: "\\ea69" }), n.star = new n("star", { fontCharacter: "\\ea6a" }), n.starAdd = new n("star-add", { fontCharacter: "\\ea6a" }), n.starDelete = new n("star-delete", { fontCharacter: "\\ea6a" }), n.starEmpty = new n("star-empty", { fontCharacter: "\\ea6a" }), n.comment = new n("comment", { fontCharacter: "\\ea6b" }), n.commentAdd = new n("comment-add", { fontCharacter: "\\ea6b" }), n.alert = new n("alert", { fontCharacter: "\\ea6c" }), n.warning = new n("warning", { fontCharacter: "\\ea6c" }), n.search = new n("search", { fontCharacter: "\\ea6d" }), n.searchSave = new n("search-save", { fontCharacter: "\\ea6d" }), n.logOut = new n("log-out", { fontCharacter: "\\ea6e" }), n.signOut = new n("sign-out", { fontCharacter: "\\ea6e" }), n.logIn = new n("log-in", { fontCharacter: "\\ea6f" }), n.signIn = new n("sign-in", { fontCharacter: "\\ea6f" }), n.eye = new n("eye", { fontCharacter: "\\ea70" }), n.eyeUnwatch = new n("eye-unwatch", { fontCharacter: "\\ea70" }), n.eyeWatch = new n("eye-watch", { fontCharacter: "\\ea70" }), n.circleFilled = new n("circle-filled", { fontCharacter: "\\ea71" }), n.primitiveDot = new n("primitive-dot", { fontCharacter: "\\ea71" }), n.closeDirty = new n("close-dirty", { fontCharacter: "\\ea71" }), n.debugBreakpoint = new n("debug-breakpoint", { fontCharacter: "\\ea71" }), n.debugBreakpointDisabled = new n("debug-breakpoint-disabled", { fontCharacter: "\\ea71" }), n.debugHint = new n("debug-hint", { fontCharacter: "\\ea71" }), n.primitiveSquare = new n("primitive-square", { fontCharacter: "\\ea72" }), n.edit = new n("edit", { fontCharacter: "\\ea73" }), n.pencil = new n("pencil", { fontCharacter: "\\ea73" }), n.info = new n("info", { fontCharacter: "\\ea74" }), n.issueOpened = new n("issue-opened", { fontCharacter: "\\ea74" }), n.gistPrivate = new n("gist-private", { fontCharacter: "\\ea75" }), n.gitForkPrivate = new n("git-fork-private", { fontCharacter: "\\ea75" }), n.lock = new n("lock", { fontCharacter: "\\ea75" }), n.mirrorPrivate = new n("mirror-private", { fontCharacter: "\\ea75" }), n.close = new n("close", { fontCharacter: "\\ea76" }), n.removeClose = new n("remove-close", { fontCharacter: "\\ea76" }), n.x = new n("x", { fontCharacter: "\\ea76" }), n.repoSync = new n("repo-sync", { fontCharacter: "\\ea77" }), n.sync = new n("sync", { fontCharacter: "\\ea77" }), n.clone = new n("clone", { fontCharacter: "\\ea78" }), n.desktopDownload = new n("desktop-download", { fontCharacter: "\\ea78" }), n.beaker = new n("beaker", { fontCharacter: "\\ea79" }), n.microscope = new n("microscope", { fontCharacter: "\\ea79" }), n.vm = new n("vm", { fontCharacter: "\\ea7a" }), n.deviceDesktop = new n("device-desktop", { fontCharacter: "\\ea7a" }), n.file = new n("file", { fontCharacter: "\\ea7b" }), n.fileText = new n("file-text", { fontCharacter: "\\ea7b" }), n.more = new n("more", { fontCharacter: "\\ea7c" }), n.ellipsis = new n("ellipsis", { fontCharacter: "\\ea7c" }), n.kebabHorizontal = new n("kebab-horizontal", { fontCharacter: "\\ea7c" }), n.mailReply = new n("mail-reply", { fontCharacter: "\\ea7d" }), n.reply = new n("reply", { fontCharacter: "\\ea7d" }), n.organization = new n("organization", { fontCharacter: "\\ea7e" }), n.organizationFilled = new n("organization-filled", { fontCharacter: "\\ea7e" }), n.organizationOutline = new n("organization-outline", { fontCharacter: "\\ea7e" }), n.newFile = new n("new-file", { fontCharacter: "\\ea7f" }), n.fileAdd = new n("file-add", { fontCharacter: "\\ea7f" }), n.newFolder = new n("new-folder", { fontCharacter: "\\ea80" }), n.fileDirectoryCreate = new n("file-directory-create", { fontCharacter: "\\ea80" }), n.trash = new n("trash", { fontCharacter: "\\ea81" }), n.trashcan = new n("trashcan", { fontCharacter: "\\ea81" }), n.history = new n("history", { fontCharacter: "\\ea82" }), n.clock = new n("clock", { fontCharacter: "\\ea82" }), n.folder = new n("folder", { fontCharacter: "\\ea83" }), n.fileDirectory = new n("file-directory", { fontCharacter: "\\ea83" }), n.symbolFolder = new n("symbol-folder", { fontCharacter: "\\ea83" }), n.logoGithub = new n("logo-github", { fontCharacter: "\\ea84" }), n.markGithub = new n("mark-github", { fontCharacter: "\\ea84" }), n.github = new n("github", { fontCharacter: "\\ea84" }), n.terminal = new n("terminal", { fontCharacter: "\\ea85" }), n.console = new n("console", { fontCharacter: "\\ea85" }), n.repl = new n("repl", { fontCharacter: "\\ea85" }), n.zap = new n("zap", { fontCharacter: "\\ea86" }), n.symbolEvent = new n("symbol-event", { fontCharacter: "\\ea86" }), n.error = new n("error", { fontCharacter: "\\ea87" }), n.stop = new n("stop", { fontCharacter: "\\ea87" }), n.variable = new n("variable", { fontCharacter: "\\ea88" }), n.symbolVariable = new n("symbol-variable", { fontCharacter: "\\ea88" }), n.array = new n("array", { fontCharacter: "\\ea8a" }), n.symbolArray = new n("symbol-array", { fontCharacter: "\\ea8a" }), n.symbolModule = new n("symbol-module", { fontCharacter: "\\ea8b" }), n.symbolPackage = new n("symbol-package", { fontCharacter: "\\ea8b" }), n.symbolNamespace = new n("symbol-namespace", { fontCharacter: "\\ea8b" }), n.symbolObject = new n("symbol-object", { fontCharacter: "\\ea8b" }), n.symbolMethod = new n("symbol-method", { fontCharacter: "\\ea8c" }), n.symbolFunction = new n("symbol-function", { fontCharacter: "\\ea8c" }), n.symbolConstructor = new n("symbol-constructor", { fontCharacter: "\\ea8c" }), n.symbolBoolean = new n("symbol-boolean", { fontCharacter: "\\ea8f" }), n.symbolNull = new n("symbol-null", { fontCharacter: "\\ea8f" }), n.symbolNumeric = new n("symbol-numeric", { fontCharacter: "\\ea90" }), n.symbolNumber = new n("symbol-number", { fontCharacter: "\\ea90" }), n.symbolStructure = new n("symbol-structure", { fontCharacter: "\\ea91" }), n.symbolStruct = new n("symbol-struct", { fontCharacter: "\\ea91" }), n.symbolParameter = new n("symbol-parameter", { fontCharacter: "\\ea92" }), n.symbolTypeParameter = new n("symbol-type-parameter", { fontCharacter: "\\ea92" }), n.symbolKey = new n("symbol-key", { fontCharacter: "\\ea93" }), n.symbolText = new n("symbol-text", { fontCharacter: "\\ea93" }), n.symbolReference = new n("symbol-reference", { fontCharacter: "\\ea94" }), n.goToFile = new n("go-to-file", { fontCharacter: "\\ea94" }), n.symbolEnum = new n("symbol-enum", { fontCharacter: "\\ea95" }), n.symbolValue = new n("symbol-value", { fontCharacter: "\\ea95" }), n.symbolRuler = new n("symbol-ruler", { fontCharacter: "\\ea96" }), n.symbolUnit = new n("symbol-unit", { fontCharacter: "\\ea96" }), n.activateBreakpoints = new n("activate-breakpoints", { fontCharacter: "\\ea97" }), n.archive = new n("archive", { fontCharacter: "\\ea98" }), n.arrowBoth = new n("arrow-both", { fontCharacter: "\\ea99" }), n.arrowDown = new n("arrow-down", { fontCharacter: "\\ea9a" }), n.arrowLeft = new n("arrow-left", { fontCharacter: "\\ea9b" }), n.arrowRight = new n("arrow-right", { fontCharacter: "\\ea9c" }), n.arrowSmallDown = new n("arrow-small-down", { fontCharacter: "\\ea9d" }), n.arrowSmallLeft = new n("arrow-small-left", { fontCharacter: "\\ea9e" }), n.arrowSmallRight = new n("arrow-small-right", { fontCharacter: "\\ea9f" }), n.arrowSmallUp = new n("arrow-small-up", { fontCharacter: "\\eaa0" }), n.arrowUp = new n("arrow-up", { fontCharacter: "\\eaa1" }), n.bell = new n("bell", { fontCharacter: "\\eaa2" }), n.bold = new n("bold", { fontCharacter: "\\eaa3" }), n.book = new n("book", { fontCharacter: "\\eaa4" }), n.bookmark = new n("bookmark", { fontCharacter: "\\eaa5" }), n.debugBreakpointConditionalUnverified = new n("debug-breakpoint-conditional-unverified", { fontCharacter: "\\eaa6" }), n.debugBreakpointConditional = new n("debug-breakpoint-conditional", { fontCharacter: "\\eaa7" }), n.debugBreakpointConditionalDisabled = new n("debug-breakpoint-conditional-disabled", { fontCharacter: "\\eaa7" }), n.debugBreakpointDataUnverified = new n("debug-breakpoint-data-unverified", { fontCharacter: "\\eaa8" }), n.debugBreakpointData = new n("debug-breakpoint-data", { fontCharacter: "\\eaa9" }), n.debugBreakpointDataDisabled = new n("debug-breakpoint-data-disabled", { fontCharacter: "\\eaa9" }), n.debugBreakpointLogUnverified = new n("debug-breakpoint-log-unverified", { fontCharacter: "\\eaaa" }), n.debugBreakpointLog = new n("debug-breakpoint-log", { fontCharacter: "\\eaab" }), n.debugBreakpointLogDisabled = new n("debug-breakpoint-log-disabled", { fontCharacter: "\\eaab" }), n.briefcase = new n("briefcase", { fontCharacter: "\\eaac" }), n.broadcast = new n("broadcast", { fontCharacter: "\\eaad" }), n.browser = new n("browser", { fontCharacter: "\\eaae" }), n.bug = new n("bug", { fontCharacter: "\\eaaf" }), n.calendar = new n("calendar", { fontCharacter: "\\eab0" }), n.caseSensitive = new n("case-sensitive", { fontCharacter: "\\eab1" }), n.check = new n("check", { fontCharacter: "\\eab2" }), n.checklist = new n("checklist", { fontCharacter: "\\eab3" }), n.chevronDown = new n("chevron-down", { fontCharacter: "\\eab4" }), n.chevronLeft = new n("chevron-left", { fontCharacter: "\\eab5" }), n.chevronRight = new n("chevron-right", { fontCharacter: "\\eab6" }), n.chevronUp = new n("chevron-up", { fontCharacter: "\\eab7" }), n.chromeClose = new n("chrome-close", { fontCharacter: "\\eab8" }), n.chromeMaximize = new n("chrome-maximize", { fontCharacter: "\\eab9" }), n.chromeMinimize = new n("chrome-minimize", { fontCharacter: "\\eaba" }), n.chromeRestore = new n("chrome-restore", { fontCharacter: "\\eabb" }), n.circleOutline = new n("circle-outline", { fontCharacter: "\\eabc" }), n.debugBreakpointUnverified = new n("debug-breakpoint-unverified", { fontCharacter: "\\eabc" }), n.circleSlash = new n("circle-slash", { fontCharacter: "\\eabd" }), n.circuitBoard = new n("circuit-board", { fontCharacter: "\\eabe" }), n.clearAll = new n("clear-all", { fontCharacter: "\\eabf" }), n.clippy = new n("clippy", { fontCharacter: "\\eac0" }), n.closeAll = new n("close-all", { fontCharacter: "\\eac1" }), n.cloudDownload = new n("cloud-download", { fontCharacter: "\\eac2" }), n.cloudUpload = new n("cloud-upload", { fontCharacter: "\\eac3" }), n.code = new n("code", { fontCharacter: "\\eac4" }), n.collapseAll = new n("collapse-all", { fontCharacter: "\\eac5" }), n.colorMode = new n("color-mode", { fontCharacter: "\\eac6" }), n.commentDiscussion = new n("comment-discussion", { fontCharacter: "\\eac7" }), n.compareChanges = new n("compare-changes", { fontCharacter: "\\eafd" }), n.creditCard = new n("credit-card", { fontCharacter: "\\eac9" }), n.dash = new n("dash", { fontCharacter: "\\eacc" }), n.dashboard = new n("dashboard", { fontCharacter: "\\eacd" }), n.database = new n("database", { fontCharacter: "\\eace" }), n.debugContinue = new n("debug-continue", { fontCharacter: "\\eacf" }), n.debugDisconnect = new n("debug-disconnect", { fontCharacter: "\\ead0" }), n.debugPause = new n("debug-pause", { fontCharacter: "\\ead1" }), n.debugRestart = new n("debug-restart", { fontCharacter: "\\ead2" }), n.debugStart = new n("debug-start", { fontCharacter: "\\ead3" }), n.debugStepInto = new n("debug-step-into", { fontCharacter: "\\ead4" }), n.debugStepOut = new n("debug-step-out", { fontCharacter: "\\ead5" }), n.debugStepOver = new n("debug-step-over", { fontCharacter: "\\ead6" }), n.debugStop = new n("debug-stop", { fontCharacter: "\\ead7" }), n.debug = new n("debug", { fontCharacter: "\\ead8" }), n.deviceCameraVideo = new n("device-camera-video", { fontCharacter: "\\ead9" }), n.deviceCamera = new n("device-camera", { fontCharacter: "\\eada" }), n.deviceMobile = new n("device-mobile", { fontCharacter: "\\eadb" }), n.diffAdded = new n("diff-added", { fontCharacter: "\\eadc" }), n.diffIgnored = new n("diff-ignored", { fontCharacter: "\\eadd" }), n.diffModified = new n("diff-modified", { fontCharacter: "\\eade" }), n.diffRemoved = new n("diff-removed", { fontCharacter: "\\eadf" }), n.diffRenamed = new n("diff-renamed", { fontCharacter: "\\eae0" }), n.diff = new n("diff", { fontCharacter: "\\eae1" }), n.discard = new n("discard", { fontCharacter: "\\eae2" }), n.editorLayout = new n("editor-layout", { fontCharacter: "\\eae3" }), n.emptyWindow = new n("empty-window", { fontCharacter: "\\eae4" }), n.exclude = new n("exclude", { fontCharacter: "\\eae5" }), n.extensions = new n("extensions", { fontCharacter: "\\eae6" }), n.eyeClosed = new n("eye-closed", { fontCharacter: "\\eae7" }), n.fileBinary = new n("file-binary", { fontCharacter: "\\eae8" }), n.fileCode = new n("file-code", { fontCharacter: "\\eae9" }), n.fileMedia = new n("file-media", { fontCharacter: "\\eaea" }), n.filePdf = new n("file-pdf", { fontCharacter: "\\eaeb" }), n.fileSubmodule = new n("file-submodule", { fontCharacter: "\\eaec" }), n.fileSymlinkDirectory = new n("file-symlink-directory", { fontCharacter: "\\eaed" }), n.fileSymlinkFile = new n("file-symlink-file", { fontCharacter: "\\eaee" }), n.fileZip = new n("file-zip", { fontCharacter: "\\eaef" }), n.files = new n("files", { fontCharacter: "\\eaf0" }), n.filter = new n("filter", { fontCharacter: "\\eaf1" }), n.flame = new n("flame", { fontCharacter: "\\eaf2" }), n.foldDown = new n("fold-down", { fontCharacter: "\\eaf3" }), n.foldUp = new n("fold-up", { fontCharacter: "\\eaf4" }), n.fold = new n("fold", { fontCharacter: "\\eaf5" }), n.folderActive = new n("folder-active", { fontCharacter: "\\eaf6" }), n.folderOpened = new n("folder-opened", { fontCharacter: "\\eaf7" }), n.gear = new n("gear", { fontCharacter: "\\eaf8" }), n.gift = new n("gift", { fontCharacter: "\\eaf9" }), n.gistSecret = new n("gist-secret", { fontCharacter: "\\eafa" }), n.gist = new n("gist", { fontCharacter: "\\eafb" }), n.gitCommit = new n("git-commit", { fontCharacter: "\\eafc" }), n.gitCompare = new n("git-compare", { fontCharacter: "\\eafd" }), n.gitMerge = new n("git-merge", { fontCharacter: "\\eafe" }), n.githubAction = new n("github-action", { fontCharacter: "\\eaff" }), n.githubAlt = new n("github-alt", { fontCharacter: "\\eb00" }), n.globe = new n("globe", { fontCharacter: "\\eb01" }), n.grabber = new n("grabber", { fontCharacter: "\\eb02" }), n.graph = new n("graph", { fontCharacter: "\\eb03" }), n.gripper = new n("gripper", { fontCharacter: "\\eb04" }), n.heart = new n("heart", { fontCharacter: "\\eb05" }), n.home = new n("home", { fontCharacter: "\\eb06" }), n.horizontalRule = new n("horizontal-rule", { fontCharacter: "\\eb07" }), n.hubot = new n("hubot", { fontCharacter: "\\eb08" }), n.inbox = new n("inbox", { fontCharacter: "\\eb09" }), n.issueClosed = new n("issue-closed", { fontCharacter: "\\eb0a" }), n.issueReopened = new n("issue-reopened", { fontCharacter: "\\eb0b" }), n.issues = new n("issues", { fontCharacter: "\\eb0c" }), n.italic = new n("italic", { fontCharacter: "\\eb0d" }), n.jersey = new n("jersey", { fontCharacter: "\\eb0e" }), n.json = new n("json", { fontCharacter: "\\eb0f" }), n.kebabVertical = new n("kebab-vertical", { fontCharacter: "\\eb10" }), n.key = new n("key", { fontCharacter: "\\eb11" }), n.law = new n("law", { fontCharacter: "\\eb12" }), n.lightbulbAutofix = new n("lightbulb-autofix", { fontCharacter: "\\eb13" }), n.linkExternal = new n("link-external", { fontCharacter: "\\eb14" }), n.link = new n("link", { fontCharacter: "\\eb15" }), n.listOrdered = new n("list-ordered", { fontCharacter: "\\eb16" }), n.listUnordered = new n("list-unordered", { fontCharacter: "\\eb17" }), n.liveShare = new n("live-share", { fontCharacter: "\\eb18" }), n.loading = new n("loading", { fontCharacter: "\\eb19" }), n.location = new n("location", { fontCharacter: "\\eb1a" }), n.mailRead = new n("mail-read", { fontCharacter: "\\eb1b" }), n.mail = new n("mail", { fontCharacter: "\\eb1c" }), n.markdown = new n("markdown", { fontCharacter: "\\eb1d" }), n.megaphone = new n("megaphone", { fontCharacter: "\\eb1e" }), n.mention = new n("mention", { fontCharacter: "\\eb1f" }), n.milestone = new n("milestone", { fontCharacter: "\\eb20" }), n.mortarBoard = new n("mortar-board", { fontCharacter: "\\eb21" }), n.move = new n("move", { fontCharacter: "\\eb22" }), n.multipleWindows = new n("multiple-windows", { fontCharacter: "\\eb23" }), n.mute = new n("mute", { fontCharacter: "\\eb24" }), n.noNewline = new n("no-newline", { fontCharacter: "\\eb25" }), n.note = new n("note", { fontCharacter: "\\eb26" }), n.octoface = new n("octoface", { fontCharacter: "\\eb27" }), n.openPreview = new n("open-preview", { fontCharacter: "\\eb28" }), n.package_ = new n("package", { fontCharacter: "\\eb29" }), n.paintcan = new n("paintcan", { fontCharacter: "\\eb2a" }), n.pin = new n("pin", { fontCharacter: "\\eb2b" }), n.play = new n("play", { fontCharacter: "\\eb2c" }), n.run = new n("run", { fontCharacter: "\\eb2c" }), n.plug = new n("plug", { fontCharacter: "\\eb2d" }), n.preserveCase = new n("preserve-case", { fontCharacter: "\\eb2e" }), n.preview = new n("preview", { fontCharacter: "\\eb2f" }), n.project = new n("project", { fontCharacter: "\\eb30" }), n.pulse = new n("pulse", { fontCharacter: "\\eb31" }), n.question = new n("question", { fontCharacter: "\\eb32" }), n.quote = new n("quote", { fontCharacter: "\\eb33" }), n.radioTower = new n("radio-tower", { fontCharacter: "\\eb34" }), n.reactions = new n("reactions", { fontCharacter: "\\eb35" }), n.references = new n("references", { fontCharacter: "\\eb36" }), n.refresh = new n("refresh", { fontCharacter: "\\eb37" }), n.regex = new n("regex", { fontCharacter: "\\eb38" }), n.remoteExplorer = new n("remote-explorer", { fontCharacter: "\\eb39" }), n.remote = new n("remote", { fontCharacter: "\\eb3a" }), n.remove = new n("remove", { fontCharacter: "\\eb3b" }), n.replaceAll = new n("replace-all", { fontCharacter: "\\eb3c" }), n.replace = new n("replace", { fontCharacter: "\\eb3d" }), n.repoClone = new n("repo-clone", { fontCharacter: "\\eb3e" }), n.repoForcePush = new n("repo-force-push", { fontCharacter: "\\eb3f" }), n.repoPull = new n("repo-pull", { fontCharacter: "\\eb40" }), n.repoPush = new n("repo-push", { fontCharacter: "\\eb41" }), n.report = new n("report", { fontCharacter: "\\eb42" }), n.requestChanges = new n("request-changes", { fontCharacter: "\\eb43" }), n.rocket = new n("rocket", { fontCharacter: "\\eb44" }), n.rootFolderOpened = new n("root-folder-opened", { fontCharacter: "\\eb45" }), n.rootFolder = new n("root-folder", { fontCharacter: "\\eb46" }), n.rss = new n("rss", { fontCharacter: "\\eb47" }), n.ruby = new n("ruby", { fontCharacter: "\\eb48" }), n.saveAll = new n("save-all", { fontCharacter: "\\eb49" }), n.saveAs = new n("save-as", { fontCharacter: "\\eb4a" }), n.save = new n("save", { fontCharacter: "\\eb4b" }), n.screenFull = new n("screen-full", { fontCharacter: "\\eb4c" }), n.screenNormal = new n("screen-normal", { fontCharacter: "\\eb4d" }), n.searchStop = new n("search-stop", { fontCharacter: "\\eb4e" }), n.server = new n("server", { fontCharacter: "\\eb50" }), n.settingsGear = new n("settings-gear", { fontCharacter: "\\eb51" }), n.settings = new n("settings", { fontCharacter: "\\eb52" }), n.shield = new n("shield", { fontCharacter: "\\eb53" }), n.smiley = new n("smiley", { fontCharacter: "\\eb54" }), n.sortPrecedence = new n("sort-precedence", { fontCharacter: "\\eb55" }), n.splitHorizontal = new n("split-horizontal", { fontCharacter: "\\eb56" }), n.splitVertical = new n("split-vertical", { fontCharacter: "\\eb57" }), n.squirrel = new n("squirrel", { fontCharacter: "\\eb58" }), n.starFull = new n("star-full", { fontCharacter: "\\eb59" }), n.starHalf = new n("star-half", { fontCharacter: "\\eb5a" }), n.symbolClass = new n("symbol-class", { fontCharacter: "\\eb5b" }), n.symbolColor = new n("symbol-color", { fontCharacter: "\\eb5c" }), n.symbolConstant = new n("symbol-constant", { fontCharacter: "\\eb5d" }), n.symbolEnumMember = new n("symbol-enum-member", { fontCharacter: "\\eb5e" }), n.symbolField = new n("symbol-field", { fontCharacter: "\\eb5f" }), n.symbolFile = new n("symbol-file", { fontCharacter: "\\eb60" }), n.symbolInterface = new n("symbol-interface", { fontCharacter: "\\eb61" }), n.symbolKeyword = new n("symbol-keyword", { fontCharacter: "\\eb62" }), n.symbolMisc = new n("symbol-misc", { fontCharacter: "\\eb63" }), n.symbolOperator = new n("symbol-operator", { fontCharacter: "\\eb64" }), n.symbolProperty = new n("symbol-property", { fontCharacter: "\\eb65" }), n.wrench = new n("wrench", { fontCharacter: "\\eb65" }), n.wrenchSubaction = new n("wrench-subaction", { fontCharacter: "\\eb65" }), n.symbolSnippet = new n("symbol-snippet", { fontCharacter: "\\eb66" }), n.tasklist = new n("tasklist", { fontCharacter: "\\eb67" }), n.telescope = new n("telescope", { fontCharacter: "\\eb68" }), n.textSize = new n("text-size", { fontCharacter: "\\eb69" }), n.threeBars = new n("three-bars", { fontCharacter: "\\eb6a" }), n.thumbsdown = new n("thumbsdown", { fontCharacter: "\\eb6b" }), n.thumbsup = new n("thumbsup", { fontCharacter: "\\eb6c" }), n.tools = new n("tools", { fontCharacter: "\\eb6d" }), n.triangleDown = new n("triangle-down", { fontCharacter: "\\eb6e" }), n.triangleLeft = new n("triangle-left", { fontCharacter: "\\eb6f" }), n.triangleRight = new n("triangle-right", { fontCharacter: "\\eb70" }), n.triangleUp = new n("triangle-up", { fontCharacter: "\\eb71" }), n.twitter = new n("twitter", { fontCharacter: "\\eb72" }), n.unfold = new n("unfold", { fontCharacter: "\\eb73" }), n.unlock = new n("unlock", { fontCharacter: "\\eb74" }), n.unmute = new n("unmute", { fontCharacter: "\\eb75" }), n.unverified = new n("unverified", { fontCharacter: "\\eb76" }), n.verified = new n("verified", { fontCharacter: "\\eb77" }), n.versions = new n("versions", { fontCharacter: "\\eb78" }), n.vmActive = new n("vm-active", { fontCharacter: "\\eb79" }), n.vmOutline = new n("vm-outline", { fontCharacter: "\\eb7a" }), n.vmRunning = new n("vm-running", { fontCharacter: "\\eb7b" }), n.watch = new n("watch", { fontCharacter: "\\eb7c" }), n.whitespace = new n("whitespace", { fontCharacter: "\\eb7d" }), n.wholeWord = new n("whole-word", { fontCharacter: "\\eb7e" }), n.window = new n("window", { fontCharacter: "\\eb7f" }), n.wordWrap = new n("word-wrap", { fontCharacter: "\\eb80" }), n.zoomIn = new n("zoom-in", { fontCharacter: "\\eb81" }), n.zoomOut = new n("zoom-out", { fontCharacter: "\\eb82" }), n.listFilter = new n("list-filter", { fontCharacter: "\\eb83" }), n.listFlat = new n("list-flat", { fontCharacter: "\\eb84" }), n.listSelection = new n("list-selection", { fontCharacter: "\\eb85" }), n.selection = new n("selection", { fontCharacter: "\\eb85" }), n.listTree = new n("list-tree", { fontCharacter: "\\eb86" }), n.debugBreakpointFunctionUnverified = new n("debug-breakpoint-function-unverified", { fontCharacter: "\\eb87" }), n.debugBreakpointFunction = new n("debug-breakpoint-function", { fontCharacter: "\\eb88" }), n.debugBreakpointFunctionDisabled = new n("debug-breakpoint-function-disabled", { fontCharacter: "\\eb88" }), n.debugStackframeActive = new n("debug-stackframe-active", { fontCharacter: "\\eb89" }), n.debugStackframeDot = new n("debug-stackframe-dot", { fontCharacter: "\\eb8a" }), n.debugStackframe = new n("debug-stackframe", { fontCharacter: "\\eb8b" }), n.debugStackframeFocused = new n("debug-stackframe-focused", { fontCharacter: "\\eb8b" }), n.debugBreakpointUnsupported = new n("debug-breakpoint-unsupported", { fontCharacter: "\\eb8c" }), n.symbolString = new n("symbol-string", { fontCharacter: "\\eb8d" }), n.debugReverseContinue = new n("debug-reverse-continue", { fontCharacter: "\\eb8e" }), n.debugStepBack = new n("debug-step-back", { fontCharacter: "\\eb8f" }), n.debugRestartFrame = new n("debug-restart-frame", { fontCharacter: "\\eb90" }), n.callIncoming = new n("call-incoming", { fontCharacter: "\\eb92" }), n.callOutgoing = new n("call-outgoing", { fontCharacter: "\\eb93" }), n.menu = new n("menu", { fontCharacter: "\\eb94" }), n.expandAll = new n("expand-all", { fontCharacter: "\\eb95" }), n.feedback = new n("feedback", { fontCharacter: "\\eb96" }), n.groupByRefType = new n("group-by-ref-type", { fontCharacter: "\\eb97" }), n.ungroupByRefType = new n("ungroup-by-ref-type", { fontCharacter: "\\eb98" }), n.account = new n("account", { fontCharacter: "\\eb99" }), n.bellDot = new n("bell-dot", { fontCharacter: "\\eb9a" }), n.debugConsole = new n("debug-console", { fontCharacter: "\\eb9b" }), n.library = new n("library", { fontCharacter: "\\eb9c" }), n.output = new n("output", { fontCharacter: "\\eb9d" }), n.runAll = new n("run-all", { fontCharacter: "\\eb9e" }), n.syncIgnored = new n("sync-ignored", { fontCharacter: "\\eb9f" }), n.pinned = new n("pinned", { fontCharacter: "\\eba0" }), n.githubInverted = new n("github-inverted", { fontCharacter: "\\eba1" }), n.debugAlt = new n("debug-alt", { fontCharacter: "\\eb91" }), n.serverProcess = new n("server-process", { fontCharacter: "\\eba2" }), n.serverEnvironment = new n("server-environment", { fontCharacter: "\\eba3" }), n.pass = new n("pass", { fontCharacter: "\\eba4" }), n.stopCircle = new n("stop-circle", { fontCharacter: "\\eba5" }), n.playCircle = new n("play-circle", { fontCharacter: "\\eba6" }), n.record = new n("record", { fontCharacter: "\\eba7" }), n.debugAltSmall = new n("debug-alt-small", { fontCharacter: "\\eba8" }), n.vmConnect = new n("vm-connect", { fontCharacter: "\\eba9" }), n.cloud = new n("cloud", { fontCharacter: "\\ebaa" }), n.merge = new n("merge", { fontCharacter: "\\ebab" }), n.exportIcon = new n("export", { fontCharacter: "\\ebac" }), n.graphLeft = new n("graph-left", { fontCharacter: "\\ebad" }), n.magnet = new n("magnet", { fontCharacter: "\\ebae" }), n.notebook = new n("notebook", { fontCharacter: "\\ebaf" }), n.redo = new n("redo", { fontCharacter: "\\ebb0" }), n.checkAll = new n("check-all", { fontCharacter: "\\ebb1" }), n.pinnedDirty = new n("pinned-dirty", { fontCharacter: "\\ebb2" }), n.passFilled = new n("pass-filled", { fontCharacter: "\\ebb3" }), n.circleLargeFilled = new n("circle-large-filled", { fontCharacter: "\\ebb4" }), n.circleLargeOutline = new n("circle-large-outline", { fontCharacter: "\\ebb5" }), n.combine = new n("combine", { fontCharacter: "\\ebb6" }), n.gather = new n("gather", { fontCharacter: "\\ebb6" }), n.table = new n("table", { fontCharacter: "\\ebb7" }), n.variableGroup = new n("variable-group", { fontCharacter: "\\ebb8" }), n.typeHierarchy = new n("type-hierarchy", { fontCharacter: "\\ebb9" }), n.typeHierarchySub = new n("type-hierarchy-sub", { fontCharacter: "\\ebba" }), n.typeHierarchySuper = new n("type-hierarchy-super", { fontCharacter: "\\ebbb" }), n.gitPullRequestCreate = new n("git-pull-request-create", { fontCharacter: "\\ebbc" }), n.runAbove = new n("run-above", { fontCharacter: "\\ebbd" }), n.runBelow = new n("run-below", { fontCharacter: "\\ebbe" }), n.notebookTemplate = new n("notebook-template", { fontCharacter: "\\ebbf" }), n.debugRerun = new n("debug-rerun", { fontCharacter: "\\ebc0" }), n.workspaceTrusted = new n("workspace-trusted", { fontCharacter: "\\ebc1" }), n.workspaceUntrusted = new n("workspace-untrusted", { fontCharacter: "\\ebc2" }), n.workspaceUnspecified = new n("workspace-unspecified", { fontCharacter: "\\ebc3" }), n.terminalCmd = new n("terminal-cmd", { fontCharacter: "\\ebc4" }), n.terminalDebian = new n("terminal-debian", { fontCharacter: "\\ebc5" }), n.terminalLinux = new n("terminal-linux", { fontCharacter: "\\ebc6" }), n.terminalPowershell = new n("terminal-powershell", { fontCharacter: "\\ebc7" }), n.terminalTmux = new n("terminal-tmux", { fontCharacter: "\\ebc8" }), n.terminalUbuntu = new n("terminal-ubuntu", { fontCharacter: "\\ebc9" }), n.terminalBash = new n("terminal-bash", { fontCharacter: "\\ebca" }), n.arrowSwap = new n("arrow-swap", { fontCharacter: "\\ebcb" }), n.copy = new n("copy", { fontCharacter: "\\ebcc" }), n.personAdd = new n("person-add", { fontCharacter: "\\ebcd" }), n.filterFilled = new n("filter-filled", { fontCharacter: "\\ebce" }), n.wand = new n("wand", { fontCharacter: "\\ebcf" }), n.debugLineByLine = new n("debug-line-by-line", { fontCharacter: "\\ebd0" }), n.inspect = new n("inspect", { fontCharacter: "\\ebd1" }), n.dropDownButton = new n("drop-down-button", n.chevronDown.definition);
})(Hi || (Hi = {}));
class XN {
  constructor(e, t) {
    this.language = e, this.id = t;
  }
}
class la {
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 1792) >>> 8;
  }
  static getFontStyle(e) {
    return (e & 14336) >>> 11;
  }
  static getForeground(e) {
    return (e & 8372224) >>> 14;
  }
  static getBackground(e) {
    return (e & 4286578688) >>> 23;
  }
  static getClassNameFromMetadata(e) {
    let i = "mtk" + this.getForeground(e), r = this.getFontStyle(e);
    return r & 1 && (i += " mtki"), r & 2 && (i += " mtkb"), r & 4 && (i += " mtku"), i;
  }
  static getInlineStyleFromMetadata(e, t) {
    const i = this.getForeground(e), r = this.getFontStyle(e);
    let o = `color: ${t[i]};`;
    return r & 1 && (o += "font-style: italic;"), r & 2 && (o += "font-weight: bold;"), r & 4 && (o += "text-decoration: underline;"), o;
  }
}
const Oye = function() {
  let n = /* @__PURE__ */ Object.create(null);
  return n[
    0
    /* Method */
  ] = "symbol-method", n[
    1
    /* Function */
  ] = "symbol-function", n[
    2
    /* Constructor */
  ] = "symbol-constructor", n[
    3
    /* Field */
  ] = "symbol-field", n[
    4
    /* Variable */
  ] = "symbol-variable", n[
    5
    /* Class */
  ] = "symbol-class", n[
    6
    /* Struct */
  ] = "symbol-struct", n[
    7
    /* Interface */
  ] = "symbol-interface", n[
    8
    /* Module */
  ] = "symbol-module", n[
    9
    /* Property */
  ] = "symbol-property", n[
    10
    /* Event */
  ] = "symbol-event", n[
    11
    /* Operator */
  ] = "symbol-operator", n[
    12
    /* Unit */
  ] = "symbol-unit", n[
    13
    /* Value */
  ] = "symbol-value", n[
    14
    /* Constant */
  ] = "symbol-constant", n[
    15
    /* Enum */
  ] = "symbol-enum", n[
    16
    /* EnumMember */
  ] = "symbol-enum-member", n[
    17
    /* Keyword */
  ] = "symbol-keyword", n[
    27
    /* Snippet */
  ] = "symbol-snippet", n[
    18
    /* Text */
  ] = "symbol-text", n[
    19
    /* Color */
  ] = "symbol-color", n[
    20
    /* File */
  ] = "symbol-file", n[
    21
    /* Reference */
  ] = "symbol-reference", n[
    22
    /* Customcolor */
  ] = "symbol-customcolor", n[
    23
    /* Folder */
  ] = "symbol-folder", n[
    24
    /* TypeParameter */
  ] = "symbol-type-parameter", n[
    25
    /* User */
  ] = "account", n[
    26
    /* Issue */
  ] = "issues", function(e) {
    const t = n[e];
    let i = t && _b.get(t);
    return i || (console.info("No codicon found for CompletionItemKind " + e), i = Hi.symbolProperty), i.classNames;
  };
}();
let xye = function() {
  let n = /* @__PURE__ */ Object.create(null);
  return n.method = 0, n.function = 1, n.constructor = 2, n.field = 3, n.variable = 4, n.class = 5, n.struct = 6, n.interface = 7, n.module = 8, n.property = 9, n.event = 10, n.operator = 11, n.unit = 12, n.value = 13, n.constant = 14, n.enum = 15, n["enum-member"] = 16, n.enumMember = 16, n.keyword = 17, n.snippet = 27, n.text = 18, n.color = 19, n.file = 20, n.reference = 21, n.customcolor = 22, n.folder = 23, n["type-parameter"] = 24, n.typeParameter = 24, n.account = 25, n.issue = 26, function(e, t) {
    let i = n[e];
    return typeof i > "u" && !t && (i = 9), i;
  };
}();
var Tk;
(function(n) {
  n[n.Automatic = 0] = "Automatic", n[n.Explicit = 1] = "Explicit";
})(Tk || (Tk = {}));
var Ok;
(function(n) {
  n[n.Invoke = 1] = "Invoke", n[n.TriggerCharacter = 2] = "TriggerCharacter", n[n.ContentChange = 3] = "ContentChange";
})(Ok || (Ok = {}));
var xk;
(function(n) {
  n[n.Text = 0] = "Text", n[n.Read = 1] = "Read", n[n.Write = 2] = "Write";
})(xk || (xk = {}));
function Nye(n) {
  return n && ft.isUri(n.uri) && G.isIRange(n.range) && (G.isIRange(n.originSelectionRange) || G.isIRange(n.targetSelectionRange));
}
var Nk;
(function(n) {
  const e = /* @__PURE__ */ new Map();
  e.set(
    "file",
    0
    /* File */
  ), e.set(
    "module",
    1
    /* Module */
  ), e.set(
    "namespace",
    2
    /* Namespace */
  ), e.set(
    "package",
    3
    /* Package */
  ), e.set(
    "class",
    4
    /* Class */
  ), e.set(
    "method",
    5
    /* Method */
  ), e.set(
    "property",
    6
    /* Property */
  ), e.set(
    "field",
    7
    /* Field */
  ), e.set(
    "constructor",
    8
    /* Constructor */
  ), e.set(
    "enum",
    9
    /* Enum */
  ), e.set(
    "interface",
    10
    /* Interface */
  ), e.set(
    "function",
    11
    /* Function */
  ), e.set(
    "variable",
    12
    /* Variable */
  ), e.set(
    "constant",
    13
    /* Constant */
  ), e.set(
    "string",
    14
    /* String */
  ), e.set(
    "number",
    15
    /* Number */
  ), e.set(
    "boolean",
    16
    /* Boolean */
  ), e.set(
    "array",
    17
    /* Array */
  ), e.set(
    "object",
    18
    /* Object */
  ), e.set(
    "key",
    19
    /* Key */
  ), e.set(
    "null",
    20
    /* Null */
  ), e.set(
    "enum-member",
    21
    /* EnumMember */
  ), e.set(
    "struct",
    22
    /* Struct */
  ), e.set(
    "event",
    23
    /* Event */
  ), e.set(
    "operator",
    24
    /* Operator */
  ), e.set(
    "type-parameter",
    25
    /* TypeParameter */
  );
  const t = /* @__PURE__ */ new Map();
  t.set(0, "file"), t.set(1, "module"), t.set(2, "namespace"), t.set(3, "package"), t.set(4, "class"), t.set(5, "method"), t.set(6, "property"), t.set(7, "field"), t.set(8, "constructor"), t.set(9, "enum"), t.set(10, "interface"), t.set(11, "function"), t.set(12, "variable"), t.set(13, "constant"), t.set(14, "string"), t.set(15, "number"), t.set(16, "boolean"), t.set(17, "array"), t.set(18, "object"), t.set(19, "key"), t.set(20, "null"), t.set(21, "enum-member"), t.set(22, "struct"), t.set(23, "event"), t.set(24, "operator"), t.set(25, "type-parameter");
  function i(s) {
    return e.get(s);
  }
  n.fromString = i;
  function r(s) {
    return t.get(s);
  }
  n.toString = r;
  function o(s, a) {
    const l = t.get(s);
    let u = l && _b.get("symbol-" + l);
    return u || (console.info("No codicon found for SymbolKind " + s), u = Hi.symbolProperty), `${a ? "inline" : "block"} ${u.classNames}`;
  }
  n.toCssClassName = o;
})(Nk || (Nk = {}));
class Bd {
  /**
   * Creates a new {@link FoldingRangeKind}.
   *
   * @param value of the kind.
   */
  constructor(e) {
    this.value = e;
  }
}
Bd.Comment = new Bd("comment");
Bd.Imports = new Bd("imports");
Bd.Region = new Bd("region");
var Ik;
(function(n) {
  n[n.Other = 0] = "Other", n[n.Type = 1] = "Type", n[n.Parameter = 2] = "Parameter";
})(Ik || (Ik = {}));
const ST = new Gi(), ET = new Gi(), Cb = new Gi(), fse = new Gi(), LT = new Gi(), DT = new Gi(), RT = new Gi(), TT = new Gi(), pse = new Gi(), OT = new Gi(), xT = new Gi(), NT = new Gi(), IT = new Gi(), PT = new Gi(), Pk = new Gi(), AT = new Gi(), gv = new Gi(), Gu = new Gi(), I5 = new Gi(), P5 = new Gi(), gse = new Gi(), mse = new Gi(), vse = new Gi(), yb = new Gi(), A5 = new Gi(), cn = new cse();
class _se {
  clone() {
    return this;
  }
  equals(e) {
    return this === e;
  }
}
const sE = new _se(), ZN = "vs.editor.nullMode", wb = new XN(
  ZN,
  0
  /* Null */
);
function Cse(n, e, t, i) {
  return new PN([new JS(i, "", n)], t);
}
function M5(n, e, t, i) {
  let r = new Uint32Array(2);
  return r[0] = i, r[1] = (n << 0 | 0 << 8 | 0 << 11 | 1 << 14 | 2 << 23) >>> 0, new eE(r, t === null ? sE : t);
}
const yse = "editorWorkerService", sc = Vt(yse), QN = Vt("modeService"), bb = Vt("textModelService"), wse = "$initialize";
let Ak = !1;
function MT(n) {
  XS && (Ak || (Ak = !0, console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq")), console.warn(n.message));
}
class bse {
  constructor(e) {
    this._workerId = -1, this._handler = e, this._lastSentReq = 0, this._pendingReplies = /* @__PURE__ */ Object.create(null);
  }
  setWorkerId(e) {
    this._workerId = e;
  }
  sendMessage(e, t) {
    let i = String(++this._lastSentReq);
    return new Promise((r, o) => {
      this._pendingReplies[i] = {
        resolve: r,
        reject: o
      }, this._send({
        vsWorker: this._workerId,
        req: i,
        method: e,
        args: t
      });
    });
  }
  handleMessage(e) {
    !e || !e.vsWorker || this._workerId !== -1 && e.vsWorker !== this._workerId || this._handleMessage(e);
  }
  _handleMessage(e) {
    if (e.seq) {
      let o = e;
      if (!this._pendingReplies[o.seq]) {
        console.warn("Got reply to unknown seq");
        return;
      }
      let s = this._pendingReplies[o.seq];
      if (delete this._pendingReplies[o.seq], o.err) {
        let a = o.err;
        o.err.$isError && (a = new Error(), a.name = o.err.name, a.message = o.err.message, a.stack = o.err.stack), s.reject(a);
        return;
      }
      s.resolve(o.res);
      return;
    }
    let t = e, i = t.req;
    this._handler.handleMessage(t.method, t.args).then((o) => {
      this._send({
        vsWorker: this._workerId,
        seq: i,
        res: o,
        err: void 0
      });
    }, (o) => {
      o.detail instanceof Error && (o.detail = XF(o.detail)), this._send({
        vsWorker: this._workerId,
        seq: i,
        res: void 0,
        err: XF(o)
      });
    });
  }
  _send(e) {
    let t = [];
    if (e.req) {
      const i = e;
      for (let r = 0; r < i.args.length; r++)
        i.args[r] instanceof ArrayBuffer && t.push(i.args[r]);
    } else {
      const i = e;
      i.res instanceof ArrayBuffer && t.push(i.res);
    }
    this._handler.sendMessage(e, t);
  }
}
class Sse extends Ce {
  constructor(e, t, i) {
    super();
    let r = null;
    this._worker = this._register(e.create("vs/base/common/worker/simpleWorker", (l) => {
      this._protocol.handleMessage(l);
    }, (l) => {
      r && r(l);
    })), this._protocol = new bse({
      sendMessage: (l, u) => {
        this._worker.postMessage(l, u);
      },
      handleMessage: (l, u) => {
        if (typeof i[l] != "function")
          return Promise.reject(new Error("Missing method " + l + " on main thread host."));
        try {
          return Promise.resolve(i[l].apply(i, u));
        } catch (c) {
          return Promise.reject(c);
        }
      }
    }), this._protocol.setWorkerId(this._worker.getId());
    let o = null;
    typeof self.require < "u" && typeof self.require.getConfig == "function" ? o = self.require.getConfig() : typeof self.requirejs < "u" && (o = self.requirejs.s.contexts._.config);
    const s = jN(i);
    this._onModuleLoaded = this._protocol.sendMessage(wse, [
      this._worker.getId(),
      JSON.parse(JSON.stringify(o)),
      t,
      s
    ]);
    const a = (l, u) => this._request(l, u);
    this._lazyProxy = new Promise((l, u) => {
      r = u, this._onModuleLoaded.then((c) => {
        l(E5(c, a));
      }, (c) => {
        u(c), this._onError("Worker failed to load " + t, c);
      });
    });
  }
  getProxyObject() {
    return this._lazyProxy;
  }
  _request(e, t) {
    return new Promise((i, r) => {
      this._onModuleLoaded.then(() => {
        this._protocol.sendMessage(e, t).then(i, r);
      }, r);
    });
  }
  _onError(e, t) {
    console.error(e), console.info(t);
  }
}
var _D;
const Mk = (_D = window.trustedTypes) === null || _D === void 0 ? void 0 : _D.createPolicy("defaultWorkerFactory", { createScriptURL: (n) => n });
function Ese(n, e) {
  if (vn.MonacoEnvironment) {
    if (typeof vn.MonacoEnvironment.getWorker == "function")
      return vn.MonacoEnvironment.getWorker(n, e);
    if (typeof vn.MonacoEnvironment.getWorkerUrl == "function") {
      const t = vn.MonacoEnvironment.getWorkerUrl(n, e);
      return new Worker(Mk ? Mk.createScriptURL(t) : t, { name: e });
    }
  }
  throw new Error("You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker");
}
function Lse(n) {
  return typeof n.then == "function";
}
class Dse {
  constructor(e, t, i, r, o) {
    this.id = t;
    const s = Ese("workerMain.js", i);
    Lse(s) ? this.worker = s : this.worker = Promise.resolve(s), this.postMessage(e, []), this.worker.then((a) => {
      a.onmessage = function(l) {
        r(l.data);
      }, a.onmessageerror = o, typeof a.addEventListener == "function" && a.addEventListener("error", o);
    });
  }
  getId() {
    return this.id;
  }
  postMessage(e, t) {
    this.worker && this.worker.then((i) => i.postMessage(e, t));
  }
  dispose() {
    this.worker && this.worker.then((e) => e.terminate()), this.worker = null;
  }
}
class aE {
  constructor(e) {
    this._label = e, this._webWorkerFailedBeforeError = !1;
  }
  create(e, t, i) {
    let r = ++aE.LAST_WORKER_ID;
    if (this._webWorkerFailedBeforeError)
      throw this._webWorkerFailedBeforeError;
    return new Dse(e, r, this._label || "anonymous" + r, t, (o) => {
      MT(o), this._webWorkerFailedBeforeError = o, i(o);
    });
  }
}
aE.LAST_WORKER_ID = 0;
var Rn;
(function(n) {
  n[n.None = 0] = "None", n[n.Indent = 1] = "Indent", n[n.IndentOutdent = 2] = "IndentOutdent", n[n.Outdent = 3] = "Outdent";
})(Rn || (Rn = {}));
class CD {
  constructor(e) {
    if (this.open = e.open, this.close = e.close, this._standardTokenMask = 0, Array.isArray(e.notIn))
      for (let t = 0, i = e.notIn.length; t < i; t++)
        switch (e.notIn[t]) {
          case "string":
            this._standardTokenMask |= 2;
            break;
          case "comment":
            this._standardTokenMask |= 1;
            break;
          case "regex":
            this._standardTokenMask |= 4;
            break;
        }
  }
  isOK(e) {
    return (this._standardTokenMask & e) === 0;
  }
}
class Rse {
  constructor(e) {
    this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
    for (const t of e)
      Mm(this.autoClosingPairsOpenByStart, t.open.charAt(0), t), Mm(this.autoClosingPairsOpenByEnd, t.open.charAt(t.open.length - 1), t), Mm(this.autoClosingPairsCloseByStart, t.close.charAt(0), t), Mm(this.autoClosingPairsCloseByEnd, t.close.charAt(t.close.length - 1), t), t.close.length === 1 && t.open.length === 1 && Mm(this.autoClosingPairsCloseSingleChar, t.close, t);
  }
}
function Mm(n, e, t) {
  n.has(e) ? n.get(e).push(t) : n.set(e, [t]);
}
function gy(n, e) {
  let t = n.getCount(), i = n.findTokenIndexAtOffset(e), r = n.getLanguageId(i), o = i;
  for (; o + 1 < t && n.getLanguageId(o + 1) === r; )
    o++;
  let s = i;
  for (; s > 0 && n.getLanguageId(s - 1) === r; )
    s--;
  return new Tse(n, r, s, o + 1, n.getStartOffset(s), n.getEndOffset(o));
}
class Tse {
  constructor(e, t, i, r, o, s) {
    this._actual = e, this.languageId = t, this._firstTokenIndex = i, this._lastTokenIndex = r, this.firstCharOffset = o, this._lastCharOffset = s;
  }
  getLineContent() {
    return this._actual.getLineContent().substring(this.firstCharOffset, this._lastCharOffset);
  }
  getActualLineContentBefore(e) {
    return this._actual.getLineContent().substring(0, this.firstCharOffset + e);
  }
  getTokenCount() {
    return this._lastTokenIndex - this._firstTokenIndex;
  }
  findTokenIndexAtOffset(e) {
    return this._actual.findTokenIndexAtOffset(e + this.firstCharOffset) - this._firstTokenIndex;
  }
  getStandardTokenType(e) {
    return this._actual.getStandardTokenType(e + this._firstTokenIndex);
  }
}
function Nl(n) {
  return (n & 7) !== 0;
}
class Jp {
  constructor(e) {
    if (e.autoClosingPairs ? this._autoClosingPairs = e.autoClosingPairs.map((t) => new CD(t)) : e.brackets ? this._autoClosingPairs = e.brackets.map((t) => new CD({ open: t[0], close: t[1] })) : this._autoClosingPairs = [], e.__electricCharacterSupport && e.__electricCharacterSupport.docComment) {
      const t = e.__electricCharacterSupport.docComment;
      this._autoClosingPairs.push(new CD({ open: t.open, close: t.close || "" }));
    }
    this._autoCloseBefore = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : Jp.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED, this._surroundingPairs = e.surroundingPairs || this._autoClosingPairs;
  }
  getAutoClosingPairs() {
    return this._autoClosingPairs;
  }
  getAutoCloseBeforeSet() {
    return this._autoCloseBefore;
  }
  static shouldAutoClosePair(e, t, i) {
    if (t.getTokenCount() === 0)
      return !0;
    const r = t.findTokenIndexAtOffset(i - 2), o = t.getStandardTokenType(r);
    return e.isOK(o);
  }
  getSurroundingPairs() {
    return this._surroundingPairs;
  }
}
Jp.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = `;:.,=}])> 
	`;
let yD;
function F5() {
  return yD || (yD = new TextDecoder("UTF-16LE")), yD;
}
let wD;
function Ose() {
  return wD || (wD = new TextDecoder("UTF-16BE")), wD;
}
let bD;
function k5() {
  return bD || (bD = AG() ? F5() : Ose()), bD;
}
const W5 = typeof TextDecoder < "u";
let eg, FT;
W5 ? (eg = (n) => new Nse(n), FT = xse) : (eg = (n) => new Ise(), FT = V5);
function xse(n, e, t) {
  const i = new Uint16Array(n.buffer, e, t);
  return t > 0 && (i[0] === 65279 || i[0] === 65534) ? V5(n, e, t) : F5().decode(i);
}
function V5(n, e, t) {
  let i = [], r = 0;
  for (let o = 0; o < t; o++) {
    const s = boe(n, e);
    e += 2, i[r++] = String.fromCharCode(s);
  }
  return i.join("");
}
class Nse {
  constructor(e) {
    this._capacity = e | 0, this._buffer = new Uint16Array(this._capacity), this._completedStrings = null, this._bufferLength = 0;
  }
  reset() {
    this._completedStrings = null, this._bufferLength = 0;
  }
  build() {
    return this._completedStrings !== null ? (this._flushBuffer(), this._completedStrings.join("")) : this._buildBuffer();
  }
  _buildBuffer() {
    if (this._bufferLength === 0)
      return "";
    const e = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
    return k5().decode(e);
  }
  _flushBuffer() {
    const e = this._buildBuffer();
    this._bufferLength = 0, this._completedStrings === null ? this._completedStrings = [e] : this._completedStrings[this._completedStrings.length] = e;
  }
  write1(e) {
    const t = this._capacity - this._bufferLength;
    t <= 1 && (t === 0 || Kn(e)) && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  appendASCII(e) {
    this._bufferLength === this._capacity && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  appendASCIIString(e) {
    const t = e.length;
    if (this._bufferLength + t >= this._capacity) {
      this._flushBuffer(), this._completedStrings[this._completedStrings.length] = e;
      return;
    }
    for (let i = 0; i < t; i++)
      this._buffer[this._bufferLength++] = e.charCodeAt(i);
  }
}
class Ise {
  constructor() {
    this._pieces = [], this._piecesLen = 0;
  }
  reset() {
    this._pieces = [], this._piecesLen = 0;
  }
  build() {
    return this._pieces.join("");
  }
  write1(e) {
    this._pieces[this._piecesLen++] = String.fromCharCode(e);
  }
  appendASCII(e) {
    this._pieces[this._piecesLen++] = String.fromCharCode(e);
  }
  appendASCIIString(e) {
    this._pieces[this._piecesLen++] = e;
  }
}
class Sb {
  constructor(e, t, i, r, o, s) {
    this.languageIdentifier = e, this.index = t, this.open = i, this.close = r, this.forwardRegex = o, this.reversedRegex = s, this._openSet = Sb._toSet(this.open), this._closeSet = Sb._toSet(this.close);
  }
  isOpen(e) {
    return this._openSet.has(e);
  }
  isClose(e) {
    return this._closeSet.has(e);
  }
  static _toSet(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      t.add(i);
    return t;
  }
}
function Pse(n) {
  const e = n.length;
  n = n.map((s) => [s[0].toLowerCase(), s[1].toLowerCase()]);
  const t = [];
  for (let s = 0; s < e; s++)
    t[s] = s;
  const i = (s, a) => {
    const [l, u] = s, [c, h] = a;
    return l === c || l === h || u === c || u === h;
  }, r = (s, a) => {
    const l = Math.min(s, a), u = Math.max(s, a);
    for (let c = 0; c < e; c++)
      t[c] === u && (t[c] = l);
  };
  for (let s = 0; s < e; s++) {
    const a = n[s];
    for (let l = s + 1; l < e; l++) {
      const u = n[l];
      i(a, u) && r(t[s], t[l]);
    }
  }
  const o = [];
  for (let s = 0; s < e; s++) {
    let a = [], l = [];
    for (let u = 0; u < e; u++)
      if (t[u] === s) {
        const [c, h] = n[u];
        a.push(c), l.push(h);
      }
    a.length > 0 && o.push({
      open: a,
      close: l
    });
  }
  return o;
}
class Ase {
  constructor(e, t) {
    const i = Pse(t);
    this.brackets = i.map((r, o) => new Sb(e, o, r.open, r.close, Mse(r.open, r.close, i, o), Fse(r.open, r.close, i, o))), this.forwardRegex = kse(this.brackets), this.reversedRegex = Wse(this.brackets), this.textIsBracket = {}, this.textIsOpenBracket = {}, this.maxBracketLength = 0;
    for (const r of this.brackets) {
      for (const o of r.open)
        this.textIsBracket[o] = r, this.textIsOpenBracket[o] = !0, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
      for (const o of r.close)
        this.textIsBracket[o] = r, this.textIsOpenBracket[o] = !1, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
    }
  }
}
function B5(n, e, t, i) {
  for (let r = 0, o = e.length; r < o; r++) {
    if (r === t)
      continue;
    const s = e[r];
    for (const a of s.open)
      a.indexOf(n) >= 0 && i.push(a);
    for (const a of s.close)
      a.indexOf(n) >= 0 && i.push(a);
  }
}
function H5(n, e) {
  return n.length - e.length;
}
function lE(n) {
  if (n.length <= 1)
    return n;
  const e = [], t = /* @__PURE__ */ new Set();
  for (const i of n)
    t.has(i) || (e.push(i), t.add(i));
  return e;
}
function Mse(n, e, t, i) {
  let r = [];
  r = r.concat(n), r = r.concat(e);
  for (let o = 0, s = r.length; o < s; o++)
    B5(r[o], t, i, r);
  return r = lE(r), r.sort(H5), r.reverse(), uE(r);
}
function Fse(n, e, t, i) {
  let r = [];
  r = r.concat(n), r = r.concat(e);
  for (let o = 0, s = r.length; o < s; o++)
    B5(r[o], t, i, r);
  return r = lE(r), r.sort(H5), r.reverse(), uE(r.map(JN));
}
function kse(n) {
  let e = [];
  for (const t of n) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = lE(e), uE(e);
}
function Wse(n) {
  let e = [];
  for (const t of n) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = lE(e), uE(e.map(JN));
}
function Vse(n) {
  const e = /^[\w ]+$/.test(n);
  return n = Xp(n), e ? `\\b${n}\\b` : n;
}
function uE(n) {
  let e = `(${n.map(Vse).join(")|(")})`;
  return m5(e, !0);
}
const JN = function() {
  function n(i) {
    if (W5) {
      const r = new Uint16Array(i.length);
      let o = 0;
      for (let s = i.length - 1; s >= 0; s--)
        r[o++] = i.charCodeAt(s);
      return k5().decode(r);
    } else {
      let r = [], o = 0;
      for (let s = i.length - 1; s >= 0; s--)
        r[o++] = i.charAt(s);
      return r.join("");
    }
  }
  let e = null, t = null;
  return function(r) {
    return e !== r && (e = r, t = n(e)), t;
  };
}();
class ia {
  static _findPrevBracketInText(e, t, i, r) {
    let o = i.match(e);
    if (!o)
      return null;
    let s = i.length - (o.index || 0), a = o[0].length, l = r + s;
    return new G(t, l - a + 1, t, l + 1);
  }
  static findPrevBracketInRange(e, t, i, r, o) {
    const a = JN(i).substring(i.length - o, i.length - r);
    return this._findPrevBracketInText(e, t, a, r);
  }
  static findNextBracketInText(e, t, i, r) {
    let o = i.match(e);
    if (!o)
      return null;
    let s = o.index || 0, a = o[0].length;
    if (a === 0)
      return null;
    let l = r + s;
    return new G(t, l + 1, t, l + 1 + a);
  }
  static findNextBracketInRange(e, t, i, r, o) {
    const s = i.substring(r, o);
    return this.findNextBracketInText(e, t, s, r);
  }
}
class Bse {
  constructor(e) {
    this._richEditBrackets = e;
  }
  getElectricCharacters() {
    let e = [];
    if (this._richEditBrackets)
      for (const t of this._richEditBrackets.brackets)
        for (const i of t.close) {
          const r = i.charAt(i.length - 1);
          e.push(r);
        }
    return e = e.filter((t, i, r) => r.indexOf(t) === i), e;
  }
  onElectricCharacter(e, t, i) {
    if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0)
      return null;
    const r = t.findTokenIndexAtOffset(i - 1);
    if (Nl(t.getStandardTokenType(r)))
      return null;
    const o = this._richEditBrackets.reversedRegex, s = t.getLineContent().substring(0, i - 1) + e, a = ia.findPrevBracketInRange(o, 1, s, 0, s.length);
    if (!a)
      return null;
    const l = s.substring(a.startColumn - 1, a.endColumn - 1).toLowerCase();
    if (this._richEditBrackets.textIsOpenBracket[l])
      return null;
    const c = t.getActualLineContentBefore(a.startColumn - 1);
    return /^\s*$/.test(c) ? {
      matchOpenBracket: l
    } : null;
  }
}
function my(n) {
  return n.global && (n.lastIndex = 0), !0;
}
class Hse {
  constructor(e) {
    this._indentationRules = e;
  }
  shouldIncrease(e) {
    return !!(this._indentationRules && this._indentationRules.increaseIndentPattern && my(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(e));
  }
  shouldDecrease(e) {
    return !!(this._indentationRules && this._indentationRules.decreaseIndentPattern && my(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(e));
  }
  shouldIndentNextLine(e) {
    return !!(this._indentationRules && this._indentationRules.indentNextLinePattern && my(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(e));
  }
  shouldIgnore(e) {
    return !!(this._indentationRules && this._indentationRules.unIndentedLinePattern && my(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(e));
  }
  getIndentMetadata(e) {
    let t = 0;
    return this.shouldIncrease(e) && (t += 1), this.shouldDecrease(e) && (t += 2), this.shouldIndentNextLine(e) && (t += 4), this.shouldIgnore(e) && (t += 8), t;
  }
}
class sp {
  constructor(e) {
    e = e || {}, e.brackets = e.brackets || [
      ["(", ")"],
      ["{", "}"],
      ["[", "]"]
    ], this._brackets = [], e.brackets.forEach((t) => {
      const i = sp._createOpenBracketRegExp(t[0]), r = sp._createCloseBracketRegExp(t[1]);
      i && r && this._brackets.push({
        open: t[0],
        openRegExp: i,
        close: t[1],
        closeRegExp: r
      });
    }), this._regExpRules = e.onEnterRules || [];
  }
  onEnter(e, t, i, r) {
    if (e >= 3)
      for (let o = 0, s = this._regExpRules.length; o < s; o++) {
        let a = this._regExpRules[o];
        if ([{
          reg: a.beforeText,
          text: i
        }, {
          reg: a.afterText,
          text: r
        }, {
          reg: a.previousLineText,
          text: t
        }].every((u) => u.reg ? (u.reg.lastIndex = 0, u.reg.test(u.text)) : !0))
          return a.action;
      }
    if (e >= 2 && i.length > 0 && r.length > 0)
      for (let o = 0, s = this._brackets.length; o < s; o++) {
        let a = this._brackets[o];
        if (a.openRegExp.test(i) && a.closeRegExp.test(r))
          return { indentAction: Rn.IndentOutdent };
      }
    if (e >= 2 && i.length > 0) {
      for (let o = 0, s = this._brackets.length; o < s; o++)
        if (this._brackets[o].openRegExp.test(i))
          return { indentAction: Rn.Indent };
    }
    return null;
  }
  static _createOpenBracketRegExp(e) {
    let t = Xp(e);
    return /\B/.test(t.charAt(0)) || (t = "\\b" + t), t += "\\s*$", sp._safeRegExp(t);
  }
  static _createCloseBracketRegExp(e) {
    let t = Xp(e);
    return /\B/.test(t.charAt(t.length - 1)) || (t = t + "\\b"), t = "^\\s*" + t, sp._safeRegExp(t);
  }
  static _safeRegExp(e) {
    try {
      return new RegExp(e);
    } catch (t) {
      return Pi(t), null;
    }
  }
}
class eI {
  constructor(e, t) {
    this._languageIdentifier = e, this._brackets = null, this._electricCharacter = null, this._conf = t, this._onEnterSupport = this._conf.brackets || this._conf.indentationRules || this._conf.onEnterRules ? new sp(this._conf) : null, this.comments = eI._handleComments(this._conf), this.characterPair = new Jp(this._conf), this.wordDefinition = this._conf.wordPattern || FG, this.indentationRules = this._conf.indentationRules, this._conf.indentationRules ? this.indentRulesSupport = new Hse(this._conf.indentationRules) : this.indentRulesSupport = null, this.foldingRules = this._conf.folding || {};
  }
  get brackets() {
    return !this._brackets && this._conf.brackets && (this._brackets = new Ase(this._languageIdentifier, this._conf.brackets)), this._brackets;
  }
  get electricCharacter() {
    return this._electricCharacter || (this._electricCharacter = new Bse(this.brackets)), this._electricCharacter;
  }
  onEnter(e, t, i, r) {
    return this._onEnterSupport ? this._onEnterSupport.onEnter(e, t, i, r) : null;
  }
  static _handleComments(e) {
    let t = e.comments;
    if (!t)
      return null;
    let i = {};
    if (t.lineComment && (i.lineCommentToken = t.lineComment), t.blockComment) {
      let [r, o] = t.blockComment;
      i.blockCommentStartToken = r, i.blockCommentEndToken = o;
    }
    return i;
  }
}
class Fk {
  constructor(e) {
    this.languageIdentifier = e;
  }
}
class kk {
  constructor(e, t, i) {
    this.configuration = e, this.priority = t, this.order = i;
  }
  static cmp(e, t) {
    return e.priority === t.priority ? e.order - t.order : e.priority - t.priority;
  }
}
class Gse {
  constructor(e) {
    this.languageIdentifier = e, this._resolved = null, this._entries = [], this._order = 0, this._resolved = null;
  }
  register(e, t) {
    const i = new kk(e, t, ++this._order);
    return this._entries.push(i), this._resolved = null, Oi(() => {
      for (let r = 0; r < this._entries.length; r++)
        if (this._entries[r] === i) {
          this._entries.splice(r, 1), this._resolved = null;
          break;
        }
    });
  }
  getRichEditSupport() {
    if (!this._resolved) {
      const e = this._resolve();
      e && (this._resolved = new eI(this.languageIdentifier, e));
    }
    return this._resolved;
  }
  _resolve() {
    if (this._entries.length === 0)
      return null;
    this._entries.sort(kk.cmp);
    const e = {};
    for (const t of this._entries) {
      const i = t.configuration;
      e.comments = i.comments || e.comments, e.brackets = i.brackets || e.brackets, e.wordPattern = i.wordPattern || e.wordPattern, e.indentationRules = i.indentationRules || e.indentationRules, e.onEnterRules = i.onEnterRules || e.onEnterRules, e.autoClosingPairs = i.autoClosingPairs || e.autoClosingPairs, e.surroundingPairs = i.surroundingPairs || e.surroundingPairs, e.autoCloseBefore = i.autoCloseBefore || e.autoCloseBefore, e.folding = i.folding || e.folding, e.__electricCharacterSupport = i.__electricCharacterSupport || e.__electricCharacterSupport;
    }
    return e;
  }
}
class Use {
  constructor() {
    this._entries2 = /* @__PURE__ */ new Map(), this._onDidChange = new q(), this.onDidChange = this._onDidChange.event;
  }
  /**
   * @param priority Use a higher number for higher priority
   */
  register(e, t, i = 0) {
    let r = this._entries2.get(e.id);
    r || (r = new Gse(e), this._entries2.set(e.id, r));
    const o = r.register(t, i);
    return this._onDidChange.fire(new Fk(e)), Oi(() => {
      o.dispose(), this._onDidChange.fire(new Fk(e));
    });
  }
  _getRichEditSupport(e) {
    const t = this._entries2.get(e);
    return t ? t.getRichEditSupport() : null;
  }
  getIndentationRules(e) {
    const t = this._getRichEditSupport(e);
    return t && t.indentationRules || null;
  }
  // begin electricCharacter
  _getElectricCharacterSupport(e) {
    let t = this._getRichEditSupport(e);
    return t && t.electricCharacter || null;
  }
  getElectricCharacters(e) {
    let t = this._getElectricCharacterSupport(e);
    return t ? t.getElectricCharacters() : [];
  }
  /**
   * Should return opening bracket type to match indentation with
   */
  onElectricCharacter(e, t, i) {
    let r = gy(t, i - 1), o = this._getElectricCharacterSupport(r.languageId);
    return o ? o.onElectricCharacter(e, r, i - r.firstCharOffset) : null;
  }
  // end electricCharacter
  getComments(e) {
    let t = this._getRichEditSupport(e);
    return t && t.comments || null;
  }
  // begin characterPair
  _getCharacterPairSupport(e) {
    let t = this._getRichEditSupport(e);
    return t && t.characterPair || null;
  }
  getAutoClosingPairs(e) {
    const t = this._getCharacterPairSupport(e);
    return new Rse(t ? t.getAutoClosingPairs() : []);
  }
  getAutoCloseBeforeSet(e) {
    let t = this._getCharacterPairSupport(e);
    return t ? t.getAutoCloseBeforeSet() : Jp.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;
  }
  getSurroundingPairs(e) {
    let t = this._getCharacterPairSupport(e);
    return t ? t.getSurroundingPairs() : [];
  }
  shouldAutoClosePair(e, t, i) {
    const r = gy(t, i - 1);
    return Jp.shouldAutoClosePair(e, r, i - r.firstCharOffset);
  }
  // end characterPair
  getWordDefinition(e) {
    let t = this._getRichEditSupport(e);
    return pR(t && t.wordDefinition || null);
  }
  getFoldingRules(e) {
    let t = this._getRichEditSupport(e);
    return t ? t.foldingRules : {};
  }
  // begin Indent Rules
  getIndentRulesSupport(e) {
    let t = this._getRichEditSupport(e);
    return t && t.indentRulesSupport || null;
  }
  /**
   * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.
   * Result:
   * -1: run into the boundary of embedded languages
   * 0: every line above are invalid
   * else: nearest preceding line of the same language
   */
  getPrecedingValidLine(e, t, i) {
    let r = e.getLanguageIdAtPosition(t, 0);
    if (t > 1) {
      let o, s = -1;
      for (o = t - 1; o >= 1; o--) {
        if (e.getLanguageIdAtPosition(o, 0) !== r)
          return s;
        let a = e.getLineContent(o);
        if (i.shouldIgnore(a) || /^\s+$/.test(a) || a === "") {
          s = o;
          continue;
        }
        return o;
      }
    }
    return -1;
  }
  /**
   * Get inherited indentation from above lines.
   * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.
   * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.
   * 3. If this line doesn't match any indent rules
   *   a. check whether the line above it matches indentNextLinePattern
   *   b. If not, the indent level of this line is the result
   *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).
   * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`
   *
   * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.
   */
  getInheritIndentForLine(e, t, i, r = !0) {
    if (e < 4)
      return null;
    const o = this.getIndentRulesSupport(t.getLanguageIdentifier().id);
    if (!o)
      return null;
    if (i <= 1)
      return {
        indentation: "",
        action: null
      };
    const s = this.getPrecedingValidLine(t, i, o);
    if (s < 0)
      return null;
    if (s < 1)
      return {
        indentation: "",
        action: null
      };
    const a = t.getLineContent(s);
    if (o.shouldIncrease(a) || o.shouldIndentNextLine(a))
      return {
        indentation: Fr(a),
        action: Rn.Indent,
        line: s
      };
    if (o.shouldDecrease(a))
      return {
        indentation: Fr(a),
        action: null,
        line: s
      };
    {
      if (s === 1)
        return {
          indentation: Fr(t.getLineContent(s)),
          action: null,
          line: s
        };
      const l = s - 1, u = o.getIndentMetadata(t.getLineContent(l));
      if (!(u & 3) && u & 4) {
        let c = 0;
        for (let h = l - 1; h > 0; h--)
          if (!o.shouldIndentNextLine(t.getLineContent(h))) {
            c = h;
            break;
          }
        return {
          indentation: Fr(t.getLineContent(c + 1)),
          action: null,
          line: c + 1
        };
      }
      if (r)
        return {
          indentation: Fr(t.getLineContent(s)),
          action: null,
          line: s
        };
      for (let c = s; c > 0; c--) {
        const h = t.getLineContent(c);
        if (o.shouldIncrease(h))
          return {
            indentation: Fr(h),
            action: Rn.Indent,
            line: c
          };
        if (o.shouldIndentNextLine(h)) {
          let d = 0;
          for (let f = c - 1; f > 0; f--)
            if (!o.shouldIndentNextLine(t.getLineContent(c))) {
              d = f;
              break;
            }
          return {
            indentation: Fr(t.getLineContent(d + 1)),
            action: null,
            line: d + 1
          };
        } else if (o.shouldDecrease(h))
          return {
            indentation: Fr(h),
            action: null,
            line: c
          };
      }
      return {
        indentation: Fr(t.getLineContent(1)),
        action: null,
        line: 1
      };
    }
  }
  getGoodIndentForLine(e, t, i, r, o) {
    if (e < 4)
      return null;
    const s = this._getRichEditSupport(i);
    if (!s)
      return null;
    const a = this.getIndentRulesSupport(i);
    if (!a)
      return null;
    const l = this.getInheritIndentForLine(e, t, r), u = t.getLineContent(r);
    if (l) {
      const c = l.line;
      if (c !== void 0) {
        const h = s.onEnter(e, "", t.getLineContent(c), "");
        if (h) {
          let d = Fr(t.getLineContent(c));
          return h.removeText && (d = d.substring(0, d.length - h.removeText)), h.indentAction === Rn.Indent || h.indentAction === Rn.IndentOutdent ? d = o.shiftIndent(d) : h.indentAction === Rn.Outdent && (d = o.unshiftIndent(d)), a.shouldDecrease(u) && (d = o.unshiftIndent(d)), h.appendText && (d += h.appendText), Fr(d);
        }
      }
      return a.shouldDecrease(u) ? l.action === Rn.Indent ? l.indentation : o.unshiftIndent(l.indentation) : l.action === Rn.Indent ? o.shiftIndent(l.indentation) : l.indentation;
    }
    return null;
  }
  getIndentForEnter(e, t, i, r) {
    if (e < 4)
      return null;
    t.forceTokenization(i.startLineNumber);
    const o = t.getLineTokens(i.startLineNumber), s = gy(o, i.startColumn - 1), a = s.getLineContent();
    let l = !1, u;
    s.firstCharOffset > 0 && o.getLanguageId(0) !== s.languageId ? (l = !0, u = a.substr(0, i.startColumn - 1 - s.firstCharOffset)) : u = o.getLineContent().substring(0, i.startColumn - 1);
    let c;
    i.isEmpty() ? c = a.substr(i.startColumn - 1 - s.firstCharOffset) : c = this.getScopedLineTokens(t, i.endLineNumber, i.endColumn).getLineContent().substr(i.endColumn - 1 - s.firstCharOffset);
    const h = this.getIndentRulesSupport(s.languageId);
    if (!h)
      return null;
    const d = u, f = Fr(u), p = {
      getLineTokens: (v) => t.getLineTokens(v),
      getLanguageIdentifier: () => t.getLanguageIdentifier(),
      getLanguageIdAtPosition: (v, C) => t.getLanguageIdAtPosition(v, C),
      getLineContent: (v) => v === i.startLineNumber ? d : t.getLineContent(v)
    }, g = Fr(o.getLineContent()), _ = this.getInheritIndentForLine(e, p, i.startLineNumber + 1);
    if (!_) {
      const v = l ? g : f;
      return {
        beforeEnter: v,
        afterEnter: v
      };
    }
    let m = l ? g : _.indentation;
    return _.action === Rn.Indent && (m = r.shiftIndent(m)), h.shouldDecrease(c) && (m = r.unshiftIndent(m)), {
      beforeEnter: l ? g : f,
      afterEnter: m
    };
  }
  /**
   * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of
   * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.
   */
  getIndentActionForType(e, t, i, r, o) {
    if (e < 4)
      return null;
    const s = this.getScopedLineTokens(t, i.startLineNumber, i.startColumn);
    if (s.firstCharOffset)
      return null;
    const a = this.getIndentRulesSupport(s.languageId);
    if (!a)
      return null;
    const l = s.getLineContent(), u = l.substr(0, i.startColumn - 1 - s.firstCharOffset);
    let c;
    if (i.isEmpty() ? c = l.substr(i.startColumn - 1 - s.firstCharOffset) : c = this.getScopedLineTokens(t, i.endLineNumber, i.endColumn).getLineContent().substr(i.endColumn - 1 - s.firstCharOffset), !a.shouldDecrease(u + c) && a.shouldDecrease(u + r + c)) {
      const h = this.getInheritIndentForLine(e, t, i.startLineNumber, !1);
      if (!h)
        return null;
      let d = h.indentation;
      return h.action !== Rn.Indent && (d = o.unshiftIndent(d)), d;
    }
    return null;
  }
  getIndentMetadata(e, t) {
    const i = this.getIndentRulesSupport(e.getLanguageIdentifier().id);
    return !i || t < 1 || t > e.getLineCount() ? null : i.getIndentMetadata(e.getLineContent(t));
  }
  // end Indent Rules
  // begin onEnter
  getEnterAction(e, t, i) {
    const r = this.getScopedLineTokens(t, i.startLineNumber, i.startColumn), o = this._getRichEditSupport(r.languageId);
    if (!o)
      return null;
    const s = r.getLineContent(), a = s.substr(0, i.startColumn - 1 - r.firstCharOffset);
    let l;
    i.isEmpty() ? l = s.substr(i.startColumn - 1 - r.firstCharOffset) : l = this.getScopedLineTokens(t, i.endLineNumber, i.endColumn).getLineContent().substr(i.endColumn - 1 - r.firstCharOffset);
    let u = "";
    if (i.startLineNumber > 1 && r.firstCharOffset === 0) {
      const g = this.getScopedLineTokens(t, i.startLineNumber - 1);
      g.languageId === r.languageId && (u = g.getLineContent());
    }
    const c = o.onEnter(e, u, a, l);
    if (!c)
      return null;
    const h = c.indentAction;
    let d = c.appendText;
    const f = c.removeText || 0;
    d ? h === Rn.Indent && (d = "	" + d) : h === Rn.Indent || h === Rn.IndentOutdent ? d = "	" : d = "";
    let p = this.getIndentationAtPosition(t, i.startLineNumber, i.startColumn);
    return f && (p = p.substring(0, p.length - f)), {
      indentAction: h,
      appendText: d,
      removeText: f,
      indentation: p
    };
  }
  getIndentationAtPosition(e, t, i) {
    const r = e.getLineContent(t);
    let o = Fr(r);
    return o.length > i - 1 && (o = o.substring(0, i - 1)), o;
  }
  getScopedLineTokens(e, t, i) {
    e.forceTokenization(t);
    const r = e.getLineTokens(t), o = typeof i > "u" ? e.getLineMaxColumn(t) - 1 : i - 1;
    return gy(r, o);
  }
  // end onEnter
  getBracketsSupport(e) {
    const t = this._getRichEditSupport(e);
    return t && t.brackets || null;
  }
}
const ui = new Use();
class Pc {
  /**
   * Constructs a new DiffChange with the given sequence information
   * and content.
   */
  constructor(e, t, i, r) {
    this.originalStart = e, this.originalLength = t, this.modifiedStart = i, this.modifiedLength = r;
  }
  /**
   * The end point (exclusive) of the change in the original sequence.
   */
  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  /**
   * The end point (exclusive) of the change in the modified sequence.
   */
  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
}
class Wk {
  constructor(e) {
    this.source = e;
  }
  getElements() {
    const e = this.source, t = new Int32Array(e.length);
    for (let i = 0, r = e.length; i < r; i++)
      t[i] = e.charCodeAt(i);
    return t;
  }
}
function zse(n, e, t) {
  return new bd(new Wk(n), new Wk(e)).ComputeDiff(t).changes;
}
class Ff {
  static Assert(e, t) {
    if (!e)
      throw new Error(t);
  }
}
class kf {
  /**
   * Copies a range of elements from an Array starting at the specified source index and pastes
   * them to another Array starting at the specified destination index. The length and the indexes
   * are specified as 64-bit integers.
   * sourceArray:
   *		The Array that contains the data to copy.
   * sourceIndex:
   *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
   * destinationArray:
   *		The Array that receives the data.
   * destinationIndex:
   *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
   * length:
   *		A 64-bit integer that represents the number of elements to copy.
   */
  static Copy(e, t, i, r, o) {
    for (let s = 0; s < o; s++)
      i[r + s] = e[t + s];
  }
  static Copy2(e, t, i, r, o) {
    for (let s = 0; s < o; s++)
      i[r + s] = e[t + s];
  }
}
class Vk {
  /**
   * Constructs a new DiffChangeHelper for the given DiffSequences.
   */
  constructor() {
    this.m_changes = [], this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824, this.m_originalCount = 0, this.m_modifiedCount = 0;
  }
  /**
   * Marks the beginning of the next change in the set of differences.
   */
  MarkNextChange() {
    (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.m_changes.push(new Pc(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount)), this.m_originalCount = 0, this.m_modifiedCount = 0, this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824;
  }
  /**
   * Adds the original element at the given position to the elements
   * affected by the current change. The modified index gives context
   * to the change position with respect to the original sequence.
   * @param originalIndex The index of the original element to add.
   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
   */
  AddOriginalElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_originalCount++;
  }
  /**
   * Adds the modified element at the given position to the elements
   * affected by the current change. The original index gives context
   * to the change position with respect to the modified sequence.
   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
   * @param modifiedIndex The index of the modified element to add.
   */
  AddModifiedElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_modifiedCount++;
  }
  /**
   * Retrieves all of the changes marked by the class.
   */
  getChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes;
  }
  /**
   * Retrieves all of the changes marked by the class in the reverse order
   */
  getReverseChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes.reverse(), this.m_changes;
  }
}
class bd {
  /**
   * Constructs the DiffFinder
   */
  constructor(e, t, i = null) {
    this.ContinueProcessingPredicate = i;
    const [r, o, s] = bd._getElements(e), [a, l, u] = bd._getElements(t);
    this._hasStrings = s && u, this._originalStringElements = r, this._originalElementsOrHash = o, this._modifiedStringElements = a, this._modifiedElementsOrHash = l, this.m_forwardHistory = [], this.m_reverseHistory = [];
  }
  static _isStringArray(e) {
    return e.length > 0 && typeof e[0] == "string";
  }
  static _getElements(e) {
    const t = e.getElements();
    if (bd._isStringArray(t)) {
      const i = new Int32Array(t.length);
      for (let r = 0, o = t.length; r < o; r++)
        i[r] = qN(t[r], 0);
      return [t, i, !0];
    }
    return t instanceof Int32Array ? [[], t, !1] : [[], new Int32Array(t), !1];
  }
  ElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  OriginalElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._originalElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._originalStringElements[t] : !0;
  }
  ModifiedElementsAreEqual(e, t) {
    return this._modifiedElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._modifiedStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  ComputeDiff(e) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, e);
  }
  /**
   * Computes the differences between the original and modified input
   * sequences on the bounded range.
   * @returns An array of the differences between the two input sequences.
   */
  _ComputeDiff(e, t, i, r, o) {
    const s = [!1];
    let a = this.ComputeDiffRecursive(e, t, i, r, s);
    return o && (a = this.PrettifyChanges(a)), {
      quitEarly: s[0],
      changes: a
    };
  }
  /**
   * Private helper method which computes the differences on the bounded range
   * recursively.
   * @returns An array of the differences between the two input sequences.
   */
  ComputeDiffRecursive(e, t, i, r, o) {
    for (o[0] = !1; e <= t && i <= r && this.ElementsAreEqual(e, i); )
      e++, i++;
    for (; t >= e && r >= i && this.ElementsAreEqual(t, r); )
      t--, r--;
    if (e > t || i > r) {
      let h;
      return i <= r ? (Ff.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), h = [
        new Pc(e, 0, i, r - i + 1)
      ]) : e <= t ? (Ff.Assert(i === r + 1, "modifiedStart should only be one more than modifiedEnd"), h = [
        new Pc(e, t - e + 1, i, 0)
      ]) : (Ff.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), Ff.Assert(i === r + 1, "modifiedStart should only be one more than modifiedEnd"), h = []), h;
    }
    const s = [0], a = [0], l = this.ComputeRecursionPoint(e, t, i, r, s, a, o), u = s[0], c = a[0];
    if (l !== null)
      return l;
    if (!o[0]) {
      const h = this.ComputeDiffRecursive(e, u, i, c, o);
      let d = [];
      return o[0] ? d = [
        new Pc(u + 1, t - (u + 1) + 1, c + 1, r - (c + 1) + 1)
      ] : d = this.ComputeDiffRecursive(u + 1, t, c + 1, r, o), this.ConcatenateChanges(h, d);
    }
    return [
      new Pc(e, t - e + 1, i, r - i + 1)
    ];
  }
  WALKTRACE(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g, _, m, v) {
    let C = null, y = null, w = new Vk(), L = t, S = i, E = f[0] - _[0] - r, D = -1073741824, x = this.m_forwardHistory.length - 1;
    do {
      const R = E + e;
      R === L || R < S && u[R - 1] < u[R + 1] ? (h = u[R + 1], p = h - E - r, h < D && w.MarkNextChange(), D = h, w.AddModifiedElement(h + 1, p), E = R + 1 - e) : (h = u[R - 1] + 1, p = h - E - r, h < D && w.MarkNextChange(), D = h - 1, w.AddOriginalElement(h, p + 1), E = R - 1 - e), x >= 0 && (u = this.m_forwardHistory[x], e = u[0], L = 1, S = u.length - 1);
    } while (--x >= -1);
    if (C = w.getReverseChanges(), v[0]) {
      let R = f[0] + 1, A = _[0] + 1;
      if (C !== null && C.length > 0) {
        const M = C[C.length - 1];
        R = Math.max(R, M.getOriginalEnd()), A = Math.max(A, M.getModifiedEnd());
      }
      y = [
        new Pc(R, d - R + 1, A, g - A + 1)
      ];
    } else {
      w = new Vk(), L = s, S = a, E = f[0] - _[0] - l, D = 1073741824, x = m ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
      do {
        const R = E + o;
        R === L || R < S && c[R - 1] >= c[R + 1] ? (h = c[R + 1] - 1, p = h - E - l, h > D && w.MarkNextChange(), D = h + 1, w.AddOriginalElement(h + 1, p + 1), E = R + 1 - o) : (h = c[R - 1], p = h - E - l, h > D && w.MarkNextChange(), D = h, w.AddModifiedElement(h + 1, p + 1), E = R - 1 - o), x >= 0 && (c = this.m_reverseHistory[x], o = c[0], L = 1, S = c.length - 1);
      } while (--x >= -1);
      y = w.getChanges();
    }
    return this.ConcatenateChanges(C, y);
  }
  /**
   * Given the range to compute the diff on, this method finds the point:
   * (midOriginal, midModified)
   * that exists in the middle of the LCS of the two sequences and
   * is the point at which the LCS problem may be broken down recursively.
   * This method will try to keep the LCS trace in memory. If the LCS recursion
   * point is calculated and the full trace is available in memory, then this method
   * will return the change list.
   * @param originalStart The start bound of the original sequence range
   * @param originalEnd The end bound of the original sequence range
   * @param modifiedStart The start bound of the modified sequence range
   * @param modifiedEnd The end bound of the modified sequence range
   * @param midOriginal The middle point of the original sequence range
   * @param midModified The middle point of the modified sequence range
   * @returns The diff changes, if available, otherwise null
   */
  ComputeRecursionPoint(e, t, i, r, o, s, a) {
    let l = 0, u = 0, c = 0, h = 0, d = 0, f = 0;
    e--, i--, o[0] = 0, s[0] = 0, this.m_forwardHistory = [], this.m_reverseHistory = [];
    const p = t - e + (r - i), g = p + 1, _ = new Int32Array(g), m = new Int32Array(g), v = r - i, C = t - e, y = e - i, w = t - r, S = (C - v) % 2 === 0;
    _[v] = e, m[C] = t, a[0] = !1;
    for (let E = 1; E <= p / 2 + 1; E++) {
      let D = 0, x = 0;
      c = this.ClipDiagonalBound(v - E, E, v, g), h = this.ClipDiagonalBound(v + E, E, v, g);
      for (let A = c; A <= h; A += 2) {
        A === c || A < h && _[A - 1] < _[A + 1] ? l = _[A + 1] : l = _[A - 1] + 1, u = l - (A - v) - y;
        const M = l;
        for (; l < t && u < r && this.ElementsAreEqual(l + 1, u + 1); )
          l++, u++;
        if (_[A] = l, l + u > D + x && (D = l, x = u), !S && Math.abs(A - C) <= E - 1 && l >= m[A])
          return o[0] = l, s[0] = u, M <= m[A] && 1447 > 0 && E <= 1447 + 1 ? this.WALKTRACE(v, c, h, y, C, d, f, w, _, m, l, t, o, u, r, s, S, a) : null;
      }
      const R = (D - e + (x - i) - E) / 2;
      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(D, R))
        return a[0] = !0, o[0] = D, s[0] = x, R > 0 && 1447 > 0 && E <= 1447 + 1 ? this.WALKTRACE(v, c, h, y, C, d, f, w, _, m, l, t, o, u, r, s, S, a) : (e++, i++, [
          new Pc(e, t - e + 1, i, r - i + 1)
        ]);
      d = this.ClipDiagonalBound(C - E, E, C, g), f = this.ClipDiagonalBound(C + E, E, C, g);
      for (let A = d; A <= f; A += 2) {
        A === d || A < f && m[A - 1] >= m[A + 1] ? l = m[A + 1] - 1 : l = m[A - 1], u = l - (A - C) - w;
        const M = l;
        for (; l > e && u > i && this.ElementsAreEqual(l, u); )
          l--, u--;
        if (m[A] = l, S && Math.abs(A - v) <= E && l <= _[A])
          return o[0] = l, s[0] = u, M >= _[A] && 1447 > 0 && E <= 1447 + 1 ? this.WALKTRACE(v, c, h, y, C, d, f, w, _, m, l, t, o, u, r, s, S, a) : null;
      }
      if (E <= 1447) {
        let A = new Int32Array(h - c + 2);
        A[0] = v - c + 1, kf.Copy2(_, c, A, 1, h - c + 1), this.m_forwardHistory.push(A), A = new Int32Array(f - d + 2), A[0] = C - d + 1, kf.Copy2(m, d, A, 1, f - d + 1), this.m_reverseHistory.push(A);
      }
    }
    return this.WALKTRACE(v, c, h, y, C, d, f, w, _, m, l, t, o, u, r, s, S, a);
  }
  /**
   * Shifts the given changes to provide a more intuitive diff.
   * While the first element in a diff matches the first element after the diff,
   * we shift the diff down.
   *
   * @param changes The list of changes to shift
   * @returns The shifted changes
   */
  PrettifyChanges(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t], r = t < e.length - 1 ? e[t + 1].originalStart : this._originalElementsOrHash.length, o = t < e.length - 1 ? e[t + 1].modifiedStart : this._modifiedElementsOrHash.length, s = i.originalLength > 0, a = i.modifiedLength > 0;
      for (; i.originalStart + i.originalLength < r && i.modifiedStart + i.modifiedLength < o && (!s || this.OriginalElementsAreEqual(i.originalStart, i.originalStart + i.originalLength)) && (!a || this.ModifiedElementsAreEqual(i.modifiedStart, i.modifiedStart + i.modifiedLength)); )
        i.originalStart++, i.modifiedStart++;
      let l = [null];
      if (t < e.length - 1 && this.ChangesOverlap(e[t], e[t + 1], l)) {
        e[t] = l[0], e.splice(t + 1, 1), t--;
        continue;
      }
    }
    for (let t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      let r = 0, o = 0;
      if (t > 0) {
        const h = e[t - 1];
        r = h.originalStart + h.originalLength, o = h.modifiedStart + h.modifiedLength;
      }
      const s = i.originalLength > 0, a = i.modifiedLength > 0;
      let l = 0, u = this._boundaryScore(i.originalStart, i.originalLength, i.modifiedStart, i.modifiedLength);
      for (let h = 1; ; h++) {
        const d = i.originalStart - h, f = i.modifiedStart - h;
        if (d < r || f < o || s && !this.OriginalElementsAreEqual(d, d + i.originalLength) || a && !this.ModifiedElementsAreEqual(f, f + i.modifiedLength))
          break;
        const g = (d === r && f === o ? 5 : 0) + this._boundaryScore(d, i.originalLength, f, i.modifiedLength);
        g > u && (u = g, l = h);
      }
      i.originalStart -= l, i.modifiedStart -= l;
      const c = [null];
      if (t > 0 && this.ChangesOverlap(e[t - 1], e[t], c)) {
        e[t - 1] = c[0], e.splice(t, 1), t++;
        continue;
      }
    }
    if (this._hasStrings)
      for (let t = 1, i = e.length; t < i; t++) {
        const r = e[t - 1], o = e[t], s = o.originalStart - r.originalStart - r.originalLength, a = r.originalStart, l = o.originalStart + o.originalLength, u = l - a, c = r.modifiedStart, h = o.modifiedStart + o.modifiedLength, d = h - c;
        if (s < 5 && u < 20 && d < 20) {
          const f = this._findBetterContiguousSequence(a, u, c, d, s);
          if (f) {
            const [p, g] = f;
            (p !== r.originalStart + r.originalLength || g !== r.modifiedStart + r.modifiedLength) && (r.originalLength = p - r.originalStart, r.modifiedLength = g - r.modifiedStart, o.originalStart = p + s, o.modifiedStart = g + s, o.originalLength = l - o.originalStart, o.modifiedLength = h - o.modifiedStart);
          }
        }
      }
    return e;
  }
  _findBetterContiguousSequence(e, t, i, r, o) {
    if (t < o || r < o)
      return null;
    const s = e + t - o + 1, a = i + r - o + 1;
    let l = 0, u = 0, c = 0;
    for (let h = e; h < s; h++)
      for (let d = i; d < a; d++) {
        const f = this._contiguousSequenceScore(h, d, o);
        f > 0 && f > l && (l = f, u = h, c = d);
      }
    return l > 0 ? [u, c] : null;
  }
  _contiguousSequenceScore(e, t, i) {
    let r = 0;
    for (let o = 0; o < i; o++) {
      if (!this.ElementsAreEqual(e + o, t + o))
        return 0;
      r += this._originalStringElements[e + o].length;
    }
    return r;
  }
  _OriginalIsBoundary(e) {
    return e <= 0 || e >= this._originalElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._originalStringElements[e]);
  }
  _OriginalRegionIsBoundary(e, t) {
    if (this._OriginalIsBoundary(e) || this._OriginalIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._OriginalIsBoundary(i - 1) || this._OriginalIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _ModifiedIsBoundary(e) {
    return e <= 0 || e >= this._modifiedElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._modifiedStringElements[e]);
  }
  _ModifiedRegionIsBoundary(e, t) {
    if (this._ModifiedIsBoundary(e) || this._ModifiedIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._ModifiedIsBoundary(i - 1) || this._ModifiedIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _boundaryScore(e, t, i, r) {
    const o = this._OriginalRegionIsBoundary(e, t) ? 1 : 0, s = this._ModifiedRegionIsBoundary(i, r) ? 1 : 0;
    return o + s;
  }
  /**
   * Concatenates the two input DiffChange lists and returns the resulting
   * list.
   * @param The left changes
   * @param The right changes
   * @returns The concatenated list
   */
  ConcatenateChanges(e, t) {
    let i = [];
    if (e.length === 0 || t.length === 0)
      return t.length > 0 ? t : e;
    if (this.ChangesOverlap(e[e.length - 1], t[0], i)) {
      const r = new Array(e.length + t.length - 1);
      return kf.Copy(e, 0, r, 0, e.length - 1), r[e.length - 1] = i[0], kf.Copy(t, 1, r, e.length, t.length - 1), r;
    } else {
      const r = new Array(e.length + t.length);
      return kf.Copy(e, 0, r, 0, e.length), kf.Copy(t, 0, r, e.length, t.length), r;
    }
  }
  /**
   * Returns true if the two changes overlap and can be merged into a single
   * change
   * @param left The left change
   * @param right The right change
   * @param mergedChange The merged change if the two overlap, null otherwise
   * @returns True if the two changes overlap
   */
  ChangesOverlap(e, t, i) {
    if (Ff.Assert(e.originalStart <= t.originalStart, "Left change is not less than or equal to right change"), Ff.Assert(e.modifiedStart <= t.modifiedStart, "Left change is not less than or equal to right change"), e.originalStart + e.originalLength >= t.originalStart || e.modifiedStart + e.modifiedLength >= t.modifiedStart) {
      const r = e.originalStart;
      let o = e.originalLength;
      const s = e.modifiedStart;
      let a = e.modifiedLength;
      return e.originalStart + e.originalLength >= t.originalStart && (o = t.originalStart + t.originalLength - e.originalStart), e.modifiedStart + e.modifiedLength >= t.modifiedStart && (a = t.modifiedStart + t.modifiedLength - e.modifiedStart), i[0] = new Pc(r, o, s, a), !0;
    } else
      return i[0] = null, !1;
  }
  /**
   * Helper method used to clip a diagonal index to the range of valid
   * diagonals. This also decides whether or not the diagonal index,
   * if it exceeds the boundary, should be clipped to the boundary or clipped
   * one inside the boundary depending on the Even/Odd status of the boundary
   * and numDifferences.
   * @param diagonal The index of the diagonal to clip.
   * @param numDifferences The current number of differences being iterated upon.
   * @param diagonalBaseIndex The base reference diagonal.
   * @param numDiagonals The total number of diagonals.
   * @returns The clipped diagonal index.
   */
  ClipDiagonalBound(e, t, i, r) {
    if (e >= 0 && e < r)
      return e;
    const o = i, s = r - i - 1, a = t % 2 === 0;
    if (e < 0) {
      const l = o % 2 === 0;
      return a === l ? 0 : 1;
    } else {
      const l = s % 2 === 0;
      return a === l ? r - 1 : r - 2;
    }
  }
}
const jse = 3;
function G5(n, e, t, i) {
  return new bd(n, e, t).ComputeDiff(i);
}
class Bk {
  constructor(e) {
    const t = [], i = [];
    for (let r = 0, o = e.length; r < o; r++)
      t[r] = kT(e[r], 1), i[r] = WT(e[r], 1);
    this.lines = e, this._startColumns = t, this._endColumns = i;
  }
  getElements() {
    const e = [];
    for (let t = 0, i = this.lines.length; t < i; t++)
      e[t] = this.lines[t].substring(this._startColumns[t] - 1, this._endColumns[t] - 1);
    return e;
  }
  getStartLineNumber(e) {
    return e + 1;
  }
  getEndLineNumber(e) {
    return e + 1;
  }
  createCharSequence(e, t, i) {
    const r = [], o = [], s = [];
    let a = 0;
    for (let l = t; l <= i; l++) {
      const u = this.lines[l], c = e ? this._startColumns[l] : 1, h = e ? this._endColumns[l] : u.length + 1;
      for (let d = c; d < h; d++)
        r[a] = u.charCodeAt(d - 1), o[a] = l + 1, s[a] = d, a++;
    }
    return new $se(r, o, s);
  }
}
class $se {
  constructor(e, t, i) {
    this._charCodes = e, this._lineNumbers = t, this._columns = i;
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(e) {
    return this._lineNumbers[e];
  }
  getStartColumn(e) {
    return this._columns[e];
  }
  getEndLineNumber(e) {
    return this._lineNumbers[e];
  }
  getEndColumn(e) {
    return this._columns[e] + 1;
  }
}
class Qv {
  constructor(e, t, i, r, o, s, a, l) {
    this.originalStartLineNumber = e, this.originalStartColumn = t, this.originalEndLineNumber = i, this.originalEndColumn = r, this.modifiedStartLineNumber = o, this.modifiedStartColumn = s, this.modifiedEndLineNumber = a, this.modifiedEndColumn = l;
  }
  static createFromDiffChange(e, t, i) {
    let r, o, s, a, l, u, c, h;
    return e.originalLength === 0 ? (r = 0, o = 0, s = 0, a = 0) : (r = t.getStartLineNumber(e.originalStart), o = t.getStartColumn(e.originalStart), s = t.getEndLineNumber(e.originalStart + e.originalLength - 1), a = t.getEndColumn(e.originalStart + e.originalLength - 1)), e.modifiedLength === 0 ? (l = 0, u = 0, c = 0, h = 0) : (l = i.getStartLineNumber(e.modifiedStart), u = i.getStartColumn(e.modifiedStart), c = i.getEndLineNumber(e.modifiedStart + e.modifiedLength - 1), h = i.getEndColumn(e.modifiedStart + e.modifiedLength - 1)), new Qv(r, o, s, a, l, u, c, h);
  }
}
function Kse(n) {
  if (n.length <= 1)
    return n;
  const e = [n[0]];
  let t = e[0];
  for (let i = 1, r = n.length; i < r; i++) {
    const o = n[i], s = o.originalStart - (t.originalStart + t.originalLength), a = o.modifiedStart - (t.modifiedStart + t.modifiedLength);
    Math.min(s, a) < jse ? (t.originalLength = o.originalStart + o.originalLength - t.originalStart, t.modifiedLength = o.modifiedStart + o.modifiedLength - t.modifiedStart) : (e.push(o), t = o);
  }
  return e;
}
class mv {
  constructor(e, t, i, r, o) {
    this.originalStartLineNumber = e, this.originalEndLineNumber = t, this.modifiedStartLineNumber = i, this.modifiedEndLineNumber = r, this.charChanges = o;
  }
  static createFromDiffResult(e, t, i, r, o, s, a) {
    let l, u, c, h, d;
    if (t.originalLength === 0 ? (l = i.getStartLineNumber(t.originalStart) - 1, u = 0) : (l = i.getStartLineNumber(t.originalStart), u = i.getEndLineNumber(t.originalStart + t.originalLength - 1)), t.modifiedLength === 0 ? (c = r.getStartLineNumber(t.modifiedStart) - 1, h = 0) : (c = r.getStartLineNumber(t.modifiedStart), h = r.getEndLineNumber(t.modifiedStart + t.modifiedLength - 1)), s && t.originalLength > 0 && t.originalLength < 20 && t.modifiedLength > 0 && t.modifiedLength < 20 && o()) {
      const f = i.createCharSequence(e, t.originalStart, t.originalStart + t.originalLength - 1), p = r.createCharSequence(e, t.modifiedStart, t.modifiedStart + t.modifiedLength - 1);
      let g = G5(f, p, o, !0).changes;
      a && (g = Kse(g)), d = [];
      for (let _ = 0, m = g.length; _ < m; _++)
        d.push(Qv.createFromDiffChange(g[_], f, p));
    }
    return new mv(l, u, c, h, d);
  }
}
class qse {
  constructor(e, t, i) {
    this.shouldComputeCharChanges = i.shouldComputeCharChanges, this.shouldPostProcessCharChanges = i.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = i.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = i.shouldMakePrettyDiff, this.originalLines = e, this.modifiedLines = t, this.original = new Bk(e), this.modified = new Bk(t), this.continueLineDiff = Hk(i.maxComputationTime), this.continueCharDiff = Hk(i.maxComputationTime === 0 ? 0 : Math.min(i.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0)
      return this.modified.lines.length === 1 && this.modified.lines[0].length === 0 ? {
        quitEarly: !1,
        changes: []
      } : {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: [{
            modifiedEndColumn: 0,
            modifiedEndLineNumber: 0,
            modifiedStartColumn: 0,
            modifiedStartLineNumber: 0,
            originalEndColumn: 0,
            originalEndLineNumber: 0,
            originalStartColumn: 0,
            originalStartLineNumber: 0
          }]
        }]
      };
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0)
      return {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: [{
            modifiedEndColumn: 0,
            modifiedEndLineNumber: 0,
            modifiedStartColumn: 0,
            modifiedStartLineNumber: 0,
            originalEndColumn: 0,
            originalEndLineNumber: 0,
            originalStartColumn: 0,
            originalStartLineNumber: 0
          }]
        }]
      };
    const e = G5(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff), t = e.changes, i = e.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const a = [];
      for (let l = 0, u = t.length; l < u; l++)
        a.push(mv.createFromDiffResult(this.shouldIgnoreTrimWhitespace, t[l], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      return {
        quitEarly: i,
        changes: a
      };
    }
    const r = [];
    let o = 0, s = 0;
    for (let a = -1, l = t.length; a < l; a++) {
      const u = a + 1 < l ? t[a + 1] : null, c = u ? u.originalStart : this.originalLines.length, h = u ? u.modifiedStart : this.modifiedLines.length;
      for (; o < c && s < h; ) {
        const d = this.originalLines[o], f = this.modifiedLines[s];
        if (d !== f) {
          {
            let p = kT(d, 1), g = kT(f, 1);
            for (; p > 1 && g > 1; ) {
              const _ = d.charCodeAt(p - 2), m = f.charCodeAt(g - 2);
              if (_ !== m)
                break;
              p--, g--;
            }
            (p > 1 || g > 1) && this._pushTrimWhitespaceCharChange(r, o + 1, 1, p, s + 1, 1, g);
          }
          {
            let p = WT(d, 1), g = WT(f, 1);
            const _ = d.length + 1, m = f.length + 1;
            for (; p < _ && g < m; ) {
              const v = d.charCodeAt(p - 1), C = d.charCodeAt(g - 1);
              if (v !== C)
                break;
              p++, g++;
            }
            (p < _ || g < m) && this._pushTrimWhitespaceCharChange(r, o + 1, p, _, s + 1, g, m);
          }
        }
        o++, s++;
      }
      u && (r.push(mv.createFromDiffResult(this.shouldIgnoreTrimWhitespace, u, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), o += u.originalLength, s += u.modifiedLength);
    }
    return {
      quitEarly: i,
      changes: r
    };
  }
  _pushTrimWhitespaceCharChange(e, t, i, r, o, s, a) {
    if (this._mergeTrimWhitespaceCharChange(e, t, i, r, o, s, a))
      return;
    let l;
    this.shouldComputeCharChanges && (l = [new Qv(t, i, t, r, o, s, o, a)]), e.push(new mv(t, t, o, o, l));
  }
  _mergeTrimWhitespaceCharChange(e, t, i, r, o, s, a) {
    const l = e.length;
    if (l === 0)
      return !1;
    const u = e[l - 1];
    return u.originalEndLineNumber === 0 || u.modifiedEndLineNumber === 0 ? !1 : u.originalEndLineNumber + 1 === t && u.modifiedEndLineNumber + 1 === o ? (u.originalEndLineNumber = t, u.modifiedEndLineNumber = o, this.shouldComputeCharChanges && u.charChanges && u.charChanges.push(new Qv(t, i, t, r, o, s, o, a)), !0) : !1;
  }
}
function kT(n, e) {
  const t = Os(n);
  return t === -1 ? e : t + 1;
}
function WT(n, e) {
  const t = Ng(n);
  return t === -1 ? e : t + 2;
}
function Hk(n) {
  if (n === 0)
    return () => !0;
  const e = Date.now();
  return () => Date.now() - e < n;
}
function Eb(n) {
  return n < 0 ? 0 : n > 255 ? 255 : n | 0;
}
function Wf(n) {
  return n < 0 ? 0 : n > 4294967295 ? 4294967295 : n | 0;
}
class U5 {
  constructor(e, t) {
    this.index = e, this.remainder = t;
  }
}
class Yse {
  constructor(e) {
    this.values = e, this.prefixSum = new Uint32Array(e.length), this.prefixSumValidIndex = new Int32Array(1), this.prefixSumValidIndex[0] = -1;
  }
  insertValues(e, t) {
    e = Wf(e);
    const i = this.values, r = this.prefixSum, o = t.length;
    return o === 0 ? !1 : (this.values = new Uint32Array(i.length + o), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e), e + o), this.values.set(t, e), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSum = new Uint32Array(this.values.length), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  changeValue(e, t) {
    return e = Wf(e), t = Wf(t), this.values[e] === t ? !1 : (this.values[e] = t, e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), !0);
  }
  removeValues(e, t) {
    e = Wf(e), t = Wf(t);
    const i = this.values, r = this.prefixSum;
    if (e >= i.length)
      return !1;
    let o = i.length - e;
    return t >= o && (t = o), t === 0 ? !1 : (this.values = new Uint32Array(i.length - t), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e + t), e), this.prefixSum = new Uint32Array(this.values.length), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  getTotalValue() {
    return this.values.length === 0 ? 0 : this._getAccumulatedValue(this.values.length - 1);
  }
  getAccumulatedValue(e) {
    return e < 0 ? 0 : (e = Wf(e), this._getAccumulatedValue(e));
  }
  _getAccumulatedValue(e) {
    if (e <= this.prefixSumValidIndex[0])
      return this.prefixSum[e];
    let t = this.prefixSumValidIndex[0] + 1;
    t === 0 && (this.prefixSum[0] = this.values[0], t++), e >= this.values.length && (e = this.values.length - 1);
    for (let i = t; i <= e; i++)
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    return this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e), this.prefixSum[e];
  }
  getIndexOf(e) {
    e = Math.floor(e), this.getTotalValue();
    let t = 0, i = this.values.length - 1, r = 0, o = 0, s = 0;
    for (; t <= i; )
      if (r = t + (i - t) / 2 | 0, o = this.prefixSum[r], s = o - this.values[r], e < s)
        i = r - 1;
      else if (e >= o)
        t = r + 1;
      else
        break;
    return new U5(r, e - s);
  }
}
class Xse {
  constructor(e, t, i, r) {
    this._uri = e, this._lines = t, this._eol = i, this._versionId = r, this._lineStarts = null, this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    return this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)), this._cachedTextValue;
  }
  onEvents(e) {
    e.eol && e.eol !== this._eol && (this._eol = e.eol, this._lineStarts = null);
    const t = e.changes;
    for (const i of t)
      this._acceptDeleteRange(i.range), this._acceptInsertText(new ie(i.range.startLineNumber, i.range.startColumn), i.text);
    this._versionId = e.versionId, this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const e = this._eol.length, t = this._lines.length, i = new Uint32Array(t);
      for (let r = 0; r < t; r++)
        i[r] = this._lines[r].length + e;
      this._lineStarts = new Yse(i);
    }
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(e, t) {
    this._lines[e] = t, this._lineStarts && this._lineStarts.changeValue(e, this._lines[e].length + this._eol.length);
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.startLineNumber - 1].substring(e.endColumn - 1));
      return;
    }
    this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.endLineNumber - 1].substring(e.endColumn - 1)), this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t) {
    if (t.length === 0)
      return;
    let i = z_(t);
    if (i.length === 1) {
      this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0] + this._lines[e.lineNumber - 1].substring(e.column - 1));
      return;
    }
    i[i.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1), this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0]);
    let r = new Uint32Array(i.length - 1);
    for (let o = 1; o < i.length; o++)
      this._lines.splice(e.lineNumber + o - 1, 0, i[o]), r[o - 1] = i[o].length + this._eol.length;
    this._lineStarts && this._lineStarts.insertValues(e.lineNumber, r);
  }
}
class Ig {
  constructor(e) {
    let t = Eb(e);
    this._defaultValue = t, this._asciiMap = Ig._createAsciiMap(t), this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(e) {
    let t = new Uint8Array(256);
    for (let i = 0; i < 256; i++)
      t[i] = e;
    return t;
  }
  set(e, t) {
    let i = Eb(t);
    e >= 0 && e < 256 ? this._asciiMap[e] = i : this._map.set(e, i);
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue;
  }
}
class Iye {
  constructor() {
    this._actual = new Ig(
      0
      /* False */
    );
  }
  add(e) {
    this._actual.set(
      e,
      1
      /* True */
    );
  }
  has(e) {
    return this._actual.get(e) === 1;
  }
}
class Zse {
  constructor(e, t, i) {
    const r = new Uint8Array(e * t);
    for (let o = 0, s = e * t; o < s; o++)
      r[o] = i;
    this._data = r, this.rows = e, this.cols = t;
  }
  get(e, t) {
    return this._data[e * this.cols + t];
  }
  set(e, t, i) {
    this._data[e * this.cols + t] = i;
  }
}
class Qse {
  constructor(e) {
    let t = 0, i = 0;
    for (let o = 0, s = e.length; o < s; o++) {
      let [a, l, u] = e[o];
      l > t && (t = l), a > i && (i = a), u > i && (i = u);
    }
    t++, i++;
    let r = new Zse(
      i,
      t,
      0
      /* Invalid */
    );
    for (let o = 0, s = e.length; o < s; o++) {
      let [a, l, u] = e[o];
      r.set(a, l, u);
    }
    this._states = r, this._maxCharCode = t;
  }
  nextState(e, t) {
    return t < 0 || t >= this._maxCharCode ? 0 : this._states.get(e, t);
  }
}
let SD = null;
function Jse() {
  return SD === null && (SD = new Qse([
    [
      1,
      104,
      2
      /* H */
    ],
    [
      1,
      72,
      2
      /* H */
    ],
    [
      1,
      102,
      6
      /* F */
    ],
    [
      1,
      70,
      6
      /* F */
    ],
    [
      2,
      116,
      3
      /* HT */
    ],
    [
      2,
      84,
      3
      /* HT */
    ],
    [
      3,
      116,
      4
      /* HTT */
    ],
    [
      3,
      84,
      4
      /* HTT */
    ],
    [
      4,
      112,
      5
      /* HTTP */
    ],
    [
      4,
      80,
      5
      /* HTTP */
    ],
    [
      5,
      115,
      9
      /* BeforeColon */
    ],
    [
      5,
      83,
      9
      /* BeforeColon */
    ],
    [
      5,
      58,
      10
      /* AfterColon */
    ],
    [
      6,
      105,
      7
      /* FI */
    ],
    [
      6,
      73,
      7
      /* FI */
    ],
    [
      7,
      108,
      8
      /* FIL */
    ],
    [
      7,
      76,
      8
      /* FIL */
    ],
    [
      8,
      101,
      9
      /* BeforeColon */
    ],
    [
      8,
      69,
      9
      /* BeforeColon */
    ],
    [
      9,
      58,
      10
      /* AfterColon */
    ],
    [
      10,
      47,
      11
      /* AlmostThere */
    ],
    [
      11,
      47,
      12
      /* End */
    ]
  ])), SD;
}
let Fm = null;
function eae() {
  if (Fm === null) {
    Fm = new Ig(
      0
      /* None */
    );
    const n = ` 	<>'"`;
    for (let t = 0; t < n.length; t++)
      Fm.set(
        n.charCodeAt(t),
        1
        /* ForceTermination */
      );
    const e = ".,;";
    for (let t = 0; t < e.length; t++)
      Fm.set(
        e.charCodeAt(t),
        2
        /* CannotEndIn */
      );
  }
  return Fm;
}
class Lb {
  static _createLink(e, t, i, r, o) {
    let s = o - 1;
    do {
      const a = t.charCodeAt(s);
      if (e.get(a) !== 2)
        break;
      s--;
    } while (s > r);
    if (r > 0) {
      const a = t.charCodeAt(r - 1), l = t.charCodeAt(s);
      (a === 40 && l === 41 || a === 91 && l === 93 || a === 123 && l === 125) && s--;
    }
    return {
      range: {
        startLineNumber: i,
        startColumn: r + 1,
        endLineNumber: i,
        endColumn: s + 2
      },
      url: t.substring(r, s + 1)
    };
  }
  static computeLinks(e, t = Jse()) {
    const i = eae();
    let r = [];
    for (let o = 1, s = e.getLineCount(); o <= s; o++) {
      const a = e.getLineContent(o), l = a.length;
      let u = 0, c = 0, h = 0, d = 1, f = !1, p = !1, g = !1, _ = !1;
      for (; u < l; ) {
        let m = !1;
        const v = a.charCodeAt(u);
        if (d === 13) {
          let C;
          switch (v) {
            case 40:
              f = !0, C = 0;
              break;
            case 41:
              C = f ? 0 : 1;
              break;
            case 91:
              g = !0, p = !0, C = 0;
              break;
            case 93:
              g = !1, C = p ? 0 : 1;
              break;
            case 123:
              _ = !0, C = 0;
              break;
            case 125:
              C = _ ? 0 : 1;
              break;
            case 39:
              C = h === 34 || h === 96 ? 0 : 1;
              break;
            case 34:
              C = h === 39 || h === 96 ? 0 : 1;
              break;
            case 96:
              C = h === 39 || h === 34 ? 0 : 1;
              break;
            case 42:
              C = h === 42 ? 1 : 0;
              break;
            case 124:
              C = h === 124 ? 1 : 0;
              break;
            case 32:
              C = g ? 0 : 1;
              break;
            default:
              C = i.get(v);
          }
          C === 1 && (r.push(Lb._createLink(i, a, o, c, u)), m = !0);
        } else if (d === 12) {
          let C;
          v === 91 ? (p = !0, C = 0) : C = i.get(v), C === 1 ? m = !0 : d = 13;
        } else
          d = t.nextState(d, v), d === 0 && (m = !0);
        m && (d = 1, f = !1, p = !1, _ = !1, c = u + 1, h = v), u++;
      }
      d === 13 && r.push(Lb._createLink(i, a, o, c, l));
    }
    return r;
  }
}
function tae(n) {
  return !n || typeof n.getLineCount != "function" || typeof n.getLineContent != "function" ? [] : Lb.computeLinks(n);
}
class VT {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  navigateValueSet(e, t, i, r, o) {
    if (e && t) {
      let s = this.doNavigateValueSet(t, o);
      if (s)
        return {
          range: e,
          value: s
        };
    }
    if (i && r) {
      let s = this.doNavigateValueSet(r, o);
      if (s)
        return {
          range: i,
          value: s
        };
    }
    return null;
  }
  doNavigateValueSet(e, t) {
    let i = this.numberReplace(e, t);
    return i !== null ? i : this.textReplace(e, t);
  }
  numberReplace(e, t) {
    let i = Math.pow(10, e.length - (e.lastIndexOf(".") + 1)), r = Number(e), o = parseFloat(e);
    return !isNaN(r) && !isNaN(o) && r === o ? r === 0 && !t ? null : (r = Math.floor(r * i), r += t ? i : -i, String(r / i)) : null;
  }
  textReplace(e, t) {
    return this.valueSetsReplace(this._defaultValueSet, e, t);
  }
  valueSetsReplace(e, t, i) {
    let r = null;
    for (let o = 0, s = e.length; r === null && o < s; o++)
      r = this.valueSetReplace(e[o], t, i);
    return r;
  }
  valueSetReplace(e, t, i) {
    let r = e.indexOf(t);
    return r >= 0 ? (r += i ? 1 : -1, r < 0 ? r = e.length - 1 : r %= e.length, e[r]) : null;
  }
}
VT.INSTANCE = new VT();
var Vf = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class iae extends Xse {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(e) {
    return this._lines[e - 1];
  }
  getWordAtPosition(e, t) {
    let i = lb(e.column, pR(t), this._lines[e.lineNumber - 1], 0);
    return i ? new G(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn) : null;
  }
  words(e) {
    const t = this._lines, i = this._wordenize.bind(this);
    let r = 0, o = "", s = 0, a = [];
    return {
      *[Symbol.iterator]() {
        for (; ; )
          if (s < a.length) {
            const l = o.substring(a[s].start, a[s].end);
            s += 1, yield l;
          } else if (r < t.length)
            o = t[r], a = i(o, e), s = 0, r += 1;
          else
            break;
      }
    };
  }
  getLineWords(e, t) {
    let i = this._lines[e - 1], r = this._wordenize(i, t), o = [];
    for (const s of r)
      o.push({
        word: i.substring(s.start, s.end),
        startColumn: s.start + 1,
        endColumn: s.end + 1
      });
    return o;
  }
  _wordenize(e, t) {
    const i = [];
    let r;
    for (t.lastIndex = 0; (r = t.exec(e)) && r[0].length !== 0; )
      i.push({ start: r.index, end: r.index + r[0].length });
    return i;
  }
  getValueInRange(e) {
    if (e = this._validateRange(e), e.startLineNumber === e.endLineNumber)
      return this._lines[e.startLineNumber - 1].substring(e.startColumn - 1, e.endColumn - 1);
    let t = this._eol, i = e.startLineNumber - 1, r = e.endLineNumber - 1, o = [];
    o.push(this._lines[i].substring(e.startColumn - 1));
    for (let s = i + 1; s < r; s++)
      o.push(this._lines[s]);
    return o.push(this._lines[r].substring(0, e.endColumn - 1)), o.join(t);
  }
  offsetAt(e) {
    return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getAccumulatedValue(e.lineNumber - 2) + (e.column - 1);
  }
  positionAt(e) {
    e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
    let t = this._lineStarts.getIndexOf(e), i = this._lines[t.index].length;
    return {
      lineNumber: 1 + t.index,
      column: 1 + Math.min(t.remainder, i)
    };
  }
  _validateRange(e) {
    const t = this._validatePosition({ lineNumber: e.startLineNumber, column: e.startColumn }), i = this._validatePosition({ lineNumber: e.endLineNumber, column: e.endColumn });
    return t.lineNumber !== e.startLineNumber || t.column !== e.startColumn || i.lineNumber !== e.endLineNumber || i.column !== e.endColumn ? {
      startLineNumber: t.lineNumber,
      startColumn: t.column,
      endLineNumber: i.lineNumber,
      endColumn: i.column
    } : e;
  }
  _validatePosition(e) {
    if (!ie.isIPosition(e))
      throw new Error("bad position");
    let { lineNumber: t, column: i } = e, r = !1;
    if (t < 1)
      t = 1, i = 1, r = !0;
    else if (t > this._lines.length)
      t = this._lines.length, i = this._lines[t - 1].length + 1, r = !0;
    else {
      let o = this._lines[t - 1].length + 1;
      i < 1 ? (i = 1, r = !0) : i > o && (i = o, r = !0);
    }
    return r ? { lineNumber: t, column: i } : e;
  }
}
class Hd {
  constructor(e, t) {
    this._host = e, this._models = /* @__PURE__ */ Object.create(null), this._foreignModuleFactory = t, this._foreignModule = null;
  }
  dispose() {
    this._models = /* @__PURE__ */ Object.create(null);
  }
  _getModel(e) {
    return this._models[e];
  }
  _getModels() {
    let e = [];
    return Object.keys(this._models).forEach((t) => e.push(this._models[t])), e;
  }
  acceptNewModel(e) {
    this._models[e.url] = new iae(ft.parse(e.url), e.lines, e.EOL, e.versionId);
  }
  acceptModelChanged(e, t) {
    if (!this._models[e])
      return;
    this._models[e].onEvents(t);
  }
  acceptRemovedModel(e) {
    this._models[e] && delete this._models[e];
  }
  // ---- BEGIN diff --------------------------------------------------------------------------
  computeDiff(e, t, i, r) {
    return Vf(this, void 0, void 0, function* () {
      const o = this._getModel(e), s = this._getModel(t);
      if (!o || !s)
        return null;
      const a = o.getLinesContent(), l = s.getLinesContent(), c = new qse(a, l, {
        shouldComputeCharChanges: !0,
        shouldPostProcessCharChanges: !0,
        shouldIgnoreTrimWhitespace: i,
        shouldMakePrettyDiff: !0,
        maxComputationTime: r
      }).computeDiff(), h = c.changes.length > 0 ? !1 : this._modelsAreIdentical(o, s);
      return {
        quitEarly: c.quitEarly,
        identical: h,
        changes: c.changes
      };
    });
  }
  _modelsAreIdentical(e, t) {
    const i = e.getLineCount(), r = t.getLineCount();
    if (i !== r)
      return !1;
    for (let o = 1; o <= i; o++) {
      const s = e.getLineContent(o), a = t.getLineContent(o);
      if (s !== a)
        return !1;
    }
    return !0;
  }
  computeMoreMinimalEdits(e, t) {
    return Vf(this, void 0, void 0, function* () {
      const i = this._getModel(e);
      if (!i)
        return t;
      const r = [];
      let o;
      t = t.slice(0).sort((s, a) => {
        if (s.range && a.range)
          return G.compareRangesUsingStarts(s.range, a.range);
        let l = s.range ? 0 : 1, u = a.range ? 0 : 1;
        return l - u;
      });
      for (let { range: s, text: a, eol: l } of t) {
        if (typeof l == "number" && (o = l), G.isEmpty(s) && !a)
          continue;
        const u = i.getValueInRange(s);
        if (a = a.replace(/\r\n|\n|\r/g, i.eol), u === a)
          continue;
        if (Math.max(a.length, u.length) > Hd._diffLimit) {
          r.push({ range: s, text: a });
          continue;
        }
        const c = zse(u, a, !1), h = i.offsetAt(G.lift(s).getStartPosition());
        for (const d of c) {
          const f = i.positionAt(h + d.originalStart), p = i.positionAt(h + d.originalStart + d.originalLength), g = {
            text: a.substr(d.modifiedStart, d.modifiedLength),
            range: { startLineNumber: f.lineNumber, startColumn: f.column, endLineNumber: p.lineNumber, endColumn: p.column }
          };
          i.getValueInRange(g.range) !== g.text && r.push(g);
        }
      }
      return typeof o == "number" && r.push({ eol: o, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } }), r;
    });
  }
  // ---- END minimal edits ---------------------------------------------------------------
  computeLinks(e) {
    return Vf(this, void 0, void 0, function* () {
      let t = this._getModel(e);
      return t ? tae(t) : null;
    });
  }
  textualSuggest(e, t, i, r) {
    return Vf(this, void 0, void 0, function* () {
      const o = new xg(!0), s = new RegExp(i, r), a = /* @__PURE__ */ new Set();
      e:
        for (let l of e) {
          const u = this._getModel(l);
          if (u) {
            for (let c of u.words(s))
              if (!(c === t || !isNaN(Number(c))) && (a.add(c), a.size > Hd._suggestionsLimit))
                break e;
          }
        }
      return { words: Array.from(a), duration: o.elapsed() };
    });
  }
  // ---- END suggest --------------------------------------------------------------------------
  //#region -- word ranges --
  computeWordRanges(e, t, i, r) {
    return Vf(this, void 0, void 0, function* () {
      let o = this._getModel(e);
      if (!o)
        return /* @__PURE__ */ Object.create(null);
      const s = new RegExp(i, r), a = /* @__PURE__ */ Object.create(null);
      for (let l = t.startLineNumber; l < t.endLineNumber; l++) {
        let u = o.getLineWords(l, s);
        for (const c of u) {
          if (!isNaN(Number(c.word)))
            continue;
          let h = a[c.word];
          h || (h = [], a[c.word] = h), h.push({
            startLineNumber: l,
            startColumn: c.startColumn,
            endLineNumber: l,
            endColumn: c.endColumn
          });
        }
      }
      return a;
    });
  }
  //#endregion
  navigateValueSet(e, t, i, r, o) {
    return Vf(this, void 0, void 0, function* () {
      let s = this._getModel(e);
      if (!s)
        return null;
      let a = new RegExp(r, o);
      t.startColumn === t.endColumn && (t = {
        startLineNumber: t.startLineNumber,
        startColumn: t.startColumn,
        endLineNumber: t.endLineNumber,
        endColumn: t.endColumn + 1
      });
      let l = s.getValueInRange(t), u = s.getWordAtPosition({ lineNumber: t.startLineNumber, column: t.startColumn }, a);
      if (!u)
        return null;
      let c = s.getValueInRange(u);
      return VT.INSTANCE.navigateValueSet(t, l, u, c, i);
    });
  }
  // ---- BEGIN foreign module support --------------------------------------------------------------------------
  loadForeignModule(e, t, i) {
    let s = {
      host: E5(i, (a, l) => this._host.fhr(a, l)),
      getMirrorModels: () => this._getModels()
    };
    return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(s, t), Promise.resolve(jN(this._foreignModule))) : Promise.reject(new Error("Unexpected usage"));
  }
  // foreign method request
  fmr(e, t) {
    if (!this._foreignModule || typeof this._foreignModule[e] != "function")
      return Promise.reject(new Error("Missing requestHandler or method: " + e));
    try {
      return Promise.resolve(this._foreignModule[e].apply(this._foreignModule, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
}
Hd._diffLimit = 1e5;
Hd._suggestionsLimit = 1e4;
typeof importScripts == "function" && (vn.monaco = qG());
const z5 = Vt("textResourceConfigurationService"), j5 = Vt("textResourcePropertiesService");
function us(n, e = 0) {
  return n[n.length - (1 + e)];
}
function nae(n) {
  if (n.length === 0)
    throw new Error("Invalid tail call");
  return [n.slice(0, n.length - 1), n[n.length - 1]];
}
function Yu(n, e, t = (i, r) => i === r) {
  if (n === e)
    return !0;
  if (!n || !e || n.length !== e.length)
    return !1;
  for (let i = 0, r = n.length; i < r; i++)
    if (!t(n[i], e[i]))
      return !1;
  return !0;
}
function rae(n, e, t) {
  let i = 0, r = n.length - 1;
  for (; i <= r; ) {
    const o = (i + r) / 2 | 0, s = t(n[o], e);
    if (s < 0)
      i = o + 1;
    else if (s > 0)
      r = o - 1;
    else
      return o;
  }
  return -(i + 1);
}
function Pye(n, e) {
  let t = 0, i = n.length;
  if (i === 0)
    return 0;
  for (; t < i; ) {
    const r = Math.floor((t + i) / 2);
    e(n[r]) ? i = r : t = r + 1;
  }
  return t;
}
function Gk(n, e, t) {
  if (n = n | 0, n >= e.length)
    throw new TypeError("invalid index");
  let i = e[Math.floor(e.length * Math.random())], r = [], o = [], s = [];
  for (let a of e) {
    const l = t(a, i);
    l < 0 ? r.push(a) : l > 0 ? o.push(a) : s.push(a);
  }
  return n < r.length ? Gk(n, r, t) : n < r.length + s.length ? s[0] : Gk(n - (r.length + s.length), o, t);
}
function Aye(n, e) {
  const t = [];
  let i;
  for (const r of n.slice(0).sort(e))
    !i || e(i[0], r) !== 0 ? (i = [r], t.push(i)) : i.push(r);
  return t;
}
function oae(n) {
  return n.filter((e) => !!e);
}
function sae(n) {
  return !Array.isArray(n) || n.length === 0;
}
function tI(n) {
  return Array.isArray(n) && n.length > 0;
}
function $5(n, e) {
  if (!e)
    return n.filter((i, r) => n.indexOf(i) === r);
  const t = /* @__PURE__ */ Object.create(null);
  return n.filter((i) => {
    const r = e(i);
    return t[r] ? !1 : (t[r] = !0, !0);
  });
}
function Uk(n) {
  const e = /* @__PURE__ */ new Set();
  return n.filter((t) => e.has(t) ? !1 : (e.add(t), !0));
}
function BT(n, e) {
  return n.length > 0 ? n[0] : e;
}
function Mye(n) {
  return [].concat(...n);
}
function kr(n, e) {
  let t = typeof e == "number" ? n : 0;
  typeof e == "number" ? t = n : (t = 0, e = n);
  const i = [];
  if (t <= e)
    for (let r = t; r < e; r++)
      i.push(r);
  else
    for (let r = t; r > e; r--)
      i.push(r);
  return i;
}
function Jv(n, e, t) {
  const i = n.slice(0, e), r = n.slice(e);
  return i.concat(t, r);
}
function ED(n, e) {
  const t = n.indexOf(e);
  t > -1 && (n.splice(t, 1), n.unshift(e));
}
function vy(n, e) {
  const t = n.indexOf(e);
  t > -1 && (n.splice(t, 1), n.push(e));
}
function aae(n) {
  return Array.isArray(n) ? n : [n];
}
const K_ = Vt("logService");
var Ya;
(function(n) {
  n[n.Trace = 0] = "Trace", n[n.Debug = 1] = "Debug", n[n.Info = 2] = "Info", n[n.Warning = 3] = "Warning", n[n.Error = 4] = "Error", n[n.Critical = 5] = "Critical", n[n.Off = 6] = "Off";
})(Ya || (Ya = {}));
const K5 = Ya.Info;
class lae extends Ce {
  constructor() {
    super(...arguments), this.level = K5, this._onDidChangeLogLevel = this._register(new q());
  }
  setLevel(e) {
    this.level !== e && (this.level = e, this._onDidChangeLogLevel.fire(this.level));
  }
  getLevel() {
    return this.level;
  }
}
class uae extends lae {
  constructor(e = K5) {
    super(), this.setLevel(e);
  }
  trace(e, ...t) {
    this.getLevel() <= Ya.Trace && console.log("%cTRACE", "color: #888", e, ...t);
  }
  debug(e, ...t) {
    this.getLevel() <= Ya.Debug && console.log("%cDEBUG", "background: #eee; color: #888", e, ...t);
  }
  info(e, ...t) {
    this.getLevel() <= Ya.Info && console.log("%c INFO", "color: #33f", e, ...t);
  }
  error(e, ...t) {
    this.getLevel() <= Ya.Error && console.log("%c  ERR", "color: #f33", e, ...t);
  }
  dispose() {
  }
}
class cae extends Ce {
  constructor(e) {
    super(), this.logger = e, this._register(e);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(e, ...t) {
    this.logger.trace(e, ...t);
  }
  debug(e, ...t) {
    this.logger.debug(e, ...t);
  }
  info(e, ...t) {
    this.logger.info(e, ...t);
  }
  error(e, ...t) {
    this.logger.error(e, ...t);
  }
}
var hae = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, LD = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, q5 = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
const zk = 60 * 1e3, jk = 5 * 60 * 1e3;
function kc(n, e) {
  let t = n.getModel(e);
  return !(!t || t.isTooLargeForSyncing());
}
let HT = class extends Ce {
  constructor(e, t, i) {
    super(), this._modelService = e, this._workerManager = this._register(new fae(this._modelService)), this._logService = i, this._register(P5.register("*", {
      provideLinks: (r, o) => kc(this._modelService, r.uri) ? this._workerManager.withWorker().then((s) => s.computeLinks(r.uri)).then((s) => s && { links: s }) : Promise.resolve({ links: [] })
    })), this._register(Cb.register("*", new dae(this._workerManager, t, this._modelService)));
  }
  dispose() {
    super.dispose();
  }
  canComputeDiff(e, t) {
    return kc(this._modelService, e) && kc(this._modelService, t);
  }
  computeDiff(e, t, i, r) {
    return this._workerManager.withWorker().then((o) => o.computeDiff(e, t, i, r));
  }
  computeMoreMinimalEdits(e, t) {
    if (tI(t)) {
      if (!kc(this._modelService, e))
        return Promise.resolve(t);
      const i = xg.create(!0), r = this._workerManager.withWorker().then((o) => o.computeMoreMinimalEdits(e, t));
      return r.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", e.toString(!0), i.elapsed())), Promise.race([r, $v(1e3).then(() => t)]);
    } else
      return Promise.resolve(void 0);
  }
  canNavigateValueSet(e) {
    return kc(this._modelService, e);
  }
  navigateValueSet(e, t, i) {
    return this._workerManager.withWorker().then((r) => r.navigateValueSet(e, t, i));
  }
  canComputeWordRanges(e) {
    return kc(this._modelService, e);
  }
  computeWordRanges(e, t) {
    return this._workerManager.withWorker().then((i) => i.computeWordRanges(e, t));
  }
};
HT = hae([
  LD(0, ao),
  LD(1, z5),
  LD(2, K_)
], HT);
class dae {
  constructor(e, t, i) {
    this._debugDisplayName = "wordbasedCompletions", this._workerManager = e, this._configurationService = t, this._modelService = i;
  }
  provideCompletionItems(e, t) {
    return q5(this, void 0, void 0, function* () {
      const i = this._configurationService.getValue(e.uri, t, "editor");
      if (!i.wordBasedSuggestions)
        return;
      const r = [];
      if (i.wordBasedSuggestionsMode === "currentDocument")
        kc(this._modelService, e.uri) && r.push(e.uri);
      else
        for (const h of this._modelService.getModels())
          kc(this._modelService, h.uri) && (h === e ? r.unshift(h.uri) : (i.wordBasedSuggestionsMode === "allDocuments" || h.getLanguageIdentifier().id === e.getLanguageIdentifier().id) && r.push(h.uri));
      if (r.length === 0)
        return;
      const o = ui.getWordDefinition(e.getLanguageIdentifier().id), s = e.getWordAtPosition(t), a = s ? new G(t.lineNumber, s.startColumn, t.lineNumber, s.endColumn) : G.fromPositions(t), l = a.setEndPosition(t.lineNumber, t.column), c = yield (yield this._workerManager.withWorker()).textualSuggest(r, s == null ? void 0 : s.word, o);
      if (c)
        return {
          duration: c.duration,
          suggestions: c.words.map((h) => ({
            kind: 18,
            label: h,
            insertText: h,
            range: { insert: l, replace: a }
          }))
        };
    });
  }
}
class fae extends Ce {
  constructor(e) {
    super(), this._modelService = e, this._editorWorkerClient = null, this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._register(new G_()).cancelAndSet(() => this._checkStopIdleWorker(), Math.round(jk / 2)), this._register(this._modelService.onModelRemoved((i) => this._checkStopEmptyWorker()));
  }
  dispose() {
    this._editorWorkerClient && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null), super.dispose();
  }
  /**
   * Check if the model service has no more models and stop the worker if that is the case.
   */
  _checkStopEmptyWorker() {
    if (!this._editorWorkerClient)
      return;
    this._modelService.getModels().length === 0 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  /**
   * Check if the worker has been idle for a while and then stop it.
   */
  _checkStopIdleWorker() {
    if (!this._editorWorkerClient)
      return;
    (/* @__PURE__ */ new Date()).getTime() - this._lastWorkerUsedTime > jk && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  withWorker() {
    return this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._editorWorkerClient || (this._editorWorkerClient = new Y5(this._modelService, !1, "editorWorkerService")), Promise.resolve(this._editorWorkerClient);
  }
}
class pae extends Ce {
  constructor(e, t, i) {
    if (super(), this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), this._proxy = e, this._modelService = t, !i) {
      let r = new G_();
      r.cancelAndSet(() => this._checkStopModelSync(), Math.round(zk / 2)), this._register(r);
    }
  }
  dispose() {
    for (let e in this._syncedModels)
      bi(this._syncedModels[e]);
    this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), super.dispose();
  }
  ensureSyncedResources(e) {
    for (const t of e) {
      let i = t.toString();
      this._syncedModels[i] || this._beginModelSync(t), this._syncedModels[i] && (this._syncedModelsLastUsedTime[i] = (/* @__PURE__ */ new Date()).getTime());
    }
  }
  _checkStopModelSync() {
    let e = (/* @__PURE__ */ new Date()).getTime(), t = [];
    for (let i in this._syncedModelsLastUsedTime)
      e - this._syncedModelsLastUsedTime[i] > zk && t.push(i);
    for (const i of t)
      this._stopModelSync(i);
  }
  _beginModelSync(e) {
    let t = this._modelService.getModel(e);
    if (!t || t.isTooLargeForSyncing())
      return;
    let i = e.toString();
    this._proxy.acceptNewModel({
      url: t.uri.toString(),
      lines: t.getLinesContent(),
      EOL: t.getEOL(),
      versionId: t.getVersionId()
    });
    const r = new dt();
    r.add(t.onDidChangeContent((o) => {
      this._proxy.acceptModelChanged(i.toString(), o);
    })), r.add(t.onWillDispose(() => {
      this._stopModelSync(i);
    })), r.add(Oi(() => {
      this._proxy.acceptRemovedModel(i);
    })), this._syncedModels[i] = r;
  }
  _stopModelSync(e) {
    let t = this._syncedModels[e];
    delete this._syncedModels[e], delete this._syncedModelsLastUsedTime[e], bi(t);
  }
}
class $k {
  constructor(e) {
    this._instance = e, this._proxyObj = Promise.resolve(this._instance);
  }
  dispose() {
    this._instance.dispose();
  }
  getProxyObject() {
    return this._proxyObj;
  }
}
class DD {
  constructor(e) {
    this._workerClient = e;
  }
  // foreign host request
  fhr(e, t) {
    return this._workerClient.fhr(e, t);
  }
}
class Y5 extends Ce {
  constructor(e, t, i) {
    super(), this._disposed = !1, this._modelService = e, this._keepIdleModels = t, this._workerFactory = new aE(i), this._worker = null, this._modelManager = null;
  }
  // foreign host request
  fhr(e, t) {
    throw new Error("Not implemented!");
  }
  _getOrCreateWorker() {
    if (!this._worker)
      try {
        this._worker = this._register(new Sse(this._workerFactory, "vs/editor/common/services/editorSimpleWorker", new DD(this)));
      } catch (e) {
        MT(e), this._worker = new $k(new Hd(new DD(this), null));
      }
    return this._worker;
  }
  _getProxy() {
    return this._getOrCreateWorker().getProxyObject().then(void 0, (e) => (MT(e), this._worker = new $k(new Hd(new DD(this), null)), this._getOrCreateWorker().getProxyObject()));
  }
  _getOrCreateModelManager(e) {
    return this._modelManager || (this._modelManager = this._register(new pae(e, this._modelService, this._keepIdleModels))), this._modelManager;
  }
  _withSyncedResources(e) {
    return this._disposed ? Promise.reject(ZS()) : this._getProxy().then((t) => (this._getOrCreateModelManager(t).ensureSyncedResources(e), t));
  }
  computeDiff(e, t, i, r) {
    return this._withSyncedResources([e, t]).then((o) => o.computeDiff(e.toString(), t.toString(), i, r));
  }
  computeMoreMinimalEdits(e, t) {
    return this._withSyncedResources([e]).then((i) => i.computeMoreMinimalEdits(e.toString(), t));
  }
  computeLinks(e) {
    return this._withSyncedResources([e]).then((t) => t.computeLinks(e.toString()));
  }
  textualSuggest(e, t, i) {
    return q5(this, void 0, void 0, function* () {
      const r = yield this._withSyncedResources(e), o = i.source, s = hD(i);
      return r.textualSuggest(e.map((a) => a.toString()), t, o, s);
    });
  }
  computeWordRanges(e, t) {
    return this._withSyncedResources([e]).then((i) => {
      let r = this._modelService.getModel(e);
      if (!r)
        return Promise.resolve(null);
      let o = ui.getWordDefinition(r.getLanguageIdentifier().id), s = o.source, a = hD(o);
      return i.computeWordRanges(e.toString(), t, s, a);
    });
  }
  navigateValueSet(e, t, i) {
    return this._withSyncedResources([e]).then((r) => {
      let o = this._modelService.getModel(e);
      if (!o)
        return null;
      let s = ui.getWordDefinition(o.getLanguageIdentifier().id), a = s.source, l = hD(s);
      return r.navigateValueSet(e.toString(), t, i, a, l);
    });
  }
  dispose() {
    super.dispose(), this._disposed = !0;
  }
}
function gae(n, e) {
  return new mae(n, e);
}
class mae extends Y5 {
  constructor(e, t) {
    super(e, t.keepIdleModels || !1, t.label), this._foreignModuleId = t.moduleId, this._foreignModuleCreateData = t.createData || null, this._foreignModuleHost = t.host || null, this._foreignProxy = null;
  }
  // foreign host request
  fhr(e, t) {
    if (!this._foreignModuleHost || typeof this._foreignModuleHost[e] != "function")
      return Promise.reject(new Error("Missing method " + e + " or missing main thread foreign host."));
    try {
      return Promise.resolve(this._foreignModuleHost[e].apply(this._foreignModuleHost, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
  _getForeignProxy() {
    return this._foreignProxy || (this._foreignProxy = this._getProxy().then((e) => {
      const t = this._foreignModuleHost ? jN(this._foreignModuleHost) : [];
      return e.loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, t).then((i) => {
        this._foreignModuleCreateData = null;
        const r = (a, l) => e.fmr(a, l), o = (a, l) => function() {
          const u = Array.prototype.slice.call(arguments, 0);
          return l(a, u);
        };
        let s = {};
        for (const a of i)
          s[a] = o(a, r);
        return s;
      });
    })), this._foreignProxy;
  }
  getProxy() {
    return this._getForeignProxy();
  }
  withSyncedResources(e) {
    return this._withSyncedResources(e).then((t) => this.getProxy());
  }
}
class eo {
  constructor(e, t) {
    this._tokens = e, this._tokensCount = this._tokens.length >>> 1, this._text = t;
  }
  static createEmpty(e) {
    const i = new Uint32Array(2);
    return i[0] = e.length, i[1] = 16793600, new eo(i, e);
  }
  equals(e) {
    return e instanceof eo ? this.slicedEquals(e, 0, this._tokensCount) : !1;
  }
  slicedEquals(e, t, i) {
    if (this._text !== e._text || this._tokensCount !== e._tokensCount)
      return !1;
    const r = t << 1, o = r + (i << 1);
    for (let s = r; s < o; s++)
      if (this._tokens[s] !== e._tokens[s])
        return !1;
    return !0;
  }
  getLineContent() {
    return this._text;
  }
  getCount() {
    return this._tokensCount;
  }
  getStartOffset(e) {
    return e > 0 ? this._tokens[e - 1 << 1] : 0;
  }
  getMetadata(e) {
    return this._tokens[(e << 1) + 1];
  }
  getLanguageId(e) {
    const t = this._tokens[(e << 1) + 1];
    return la.getLanguageId(t);
  }
  getStandardTokenType(e) {
    const t = this._tokens[(e << 1) + 1];
    return la.getTokenType(t);
  }
  getForeground(e) {
    const t = this._tokens[(e << 1) + 1];
    return la.getForeground(t);
  }
  getClassName(e) {
    const t = this._tokens[(e << 1) + 1];
    return la.getClassNameFromMetadata(t);
  }
  getInlineStyle(e, t) {
    const i = this._tokens[(e << 1) + 1];
    return la.getInlineStyleFromMetadata(i, t);
  }
  getEndOffset(e) {
    return this._tokens[e << 1];
  }
  /**
   * Find the token containing offset `offset`.
   * @param offset The search offset
   * @return The index of the token containing the offset.
   */
  findTokenIndexAtOffset(e) {
    return eo.findIndexInTokensArray(this._tokens, e);
  }
  inflate() {
    return this;
  }
  sliceAndInflate(e, t, i) {
    return new iI(this, e, t, i);
  }
  static convertToEndOffset(e, t) {
    const r = (e.length >>> 1) - 1;
    for (let o = 0; o < r; o++)
      e[o << 1] = e[o + 1 << 1];
    e[r << 1] = t;
  }
  static findIndexInTokensArray(e, t) {
    if (e.length <= 2)
      return 0;
    let i = 0, r = (e.length >>> 1) - 1;
    for (; i < r; ) {
      const o = i + Math.floor((r - i) / 2), s = e[o << 1];
      if (s === t)
        return o + 1;
      s < t ? i = o + 1 : s > t && (r = o);
    }
    return i;
  }
}
class iI {
  constructor(e, t, i, r) {
    this._source = e, this._startOffset = t, this._endOffset = i, this._deltaOffset = r, this._firstTokenIndex = e.findTokenIndexAtOffset(t), this._tokensCount = 0;
    for (let o = this._firstTokenIndex, s = e.getCount(); o < s && !(e.getStartOffset(o) >= i); o++)
      this._tokensCount++;
  }
  equals(e) {
    return e instanceof iI ? this._startOffset === e._startOffset && this._endOffset === e._endOffset && this._deltaOffset === e._deltaOffset && this._source.slicedEquals(e._source, this._firstTokenIndex, this._tokensCount) : !1;
  }
  getCount() {
    return this._tokensCount;
  }
  getForeground(e) {
    return this._source.getForeground(this._firstTokenIndex + e);
  }
  getEndOffset(e) {
    const t = this._source.getEndOffset(this._firstTokenIndex + e);
    return Math.min(this._endOffset, t) - this._startOffset + this._deltaOffset;
  }
  getClassName(e) {
    return this._source.getClassName(this._firstTokenIndex + e);
  }
  getInlineStyle(e, t) {
    return this._source.getInlineStyle(this._firstTokenIndex + e, t);
  }
  findTokenIndexAtOffset(e) {
    return this._source.findTokenIndexAtOffset(e + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
  }
}
class ga {
  constructor(e, t, i, r) {
    this.startColumn = e, this.endColumn = t, this.className = i, this.type = r;
  }
  static _equals(e, t) {
    return e.startColumn === t.startColumn && e.endColumn === t.endColumn && e.className === t.className && e.type === t.type;
  }
  static equalsArr(e, t) {
    const i = e.length, r = t.length;
    if (i !== r)
      return !1;
    for (let o = 0; o < i; o++)
      if (!ga._equals(e[o], t[o]))
        return !1;
    return !0;
  }
  static extractWrapped(e, t, i) {
    if (e.length === 0)
      return e;
    const r = t + 1, o = i + 1, s = i - t, a = [];
    let l = 0;
    for (const u of e)
      u.endColumn <= r || u.startColumn >= o || (a[l++] = new ga(Math.max(1, u.startColumn - r + 1), Math.min(s + 1, u.endColumn - r + 1), u.className, u.type));
    return a;
  }
  static filter(e, t, i, r) {
    if (e.length === 0)
      return [];
    let o = [], s = 0;
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a], c = u.range;
      if (c.endLineNumber < t || c.startLineNumber > t || c.isEmpty() && (u.type === 0 || u.type === 3))
        continue;
      const h = c.startLineNumber === t ? c.startColumn : i, d = c.endLineNumber === t ? c.endColumn : r;
      o[s++] = new ga(h, d, u.inlineClassName, u.type);
    }
    return o;
  }
  static _typeCompare(e, t) {
    const i = [2, 0, 1, 3];
    return i[e] - i[t];
  }
  static compare(e, t) {
    if (e.startColumn === t.startColumn) {
      if (e.endColumn === t.endColumn) {
        const i = ga._typeCompare(e.type, t.type);
        return i === 0 ? e.className < t.className ? -1 : e.className > t.className ? 1 : 0 : i;
      }
      return e.endColumn - t.endColumn;
    }
    return e.startColumn - t.startColumn;
  }
}
class Kk {
  constructor(e, t, i, r) {
    this.startOffset = e, this.endOffset = t, this.className = i, this.metadata = r;
  }
}
class Db {
  constructor() {
    this.stopOffsets = [], this.classNames = [], this.metadata = [], this.count = 0;
  }
  static _metadata(e) {
    let t = 0;
    for (let i = 0, r = e.length; i < r; i++)
      t |= e[i];
    return t;
  }
  consumeLowerThan(e, t, i) {
    for (; this.count > 0 && this.stopOffsets[0] < e; ) {
      let r = 0;
      for (; r + 1 < this.count && this.stopOffsets[r] === this.stopOffsets[r + 1]; )
        r++;
      i.push(new Kk(t, this.stopOffsets[r], this.classNames.join(" "), Db._metadata(this.metadata))), t = this.stopOffsets[r] + 1, this.stopOffsets.splice(0, r + 1), this.classNames.splice(0, r + 1), this.metadata.splice(0, r + 1), this.count -= r + 1;
    }
    return this.count > 0 && t < e && (i.push(new Kk(t, e - 1, this.classNames.join(" "), Db._metadata(this.metadata))), t = e), t;
  }
  insert(e, t, i) {
    if (this.count === 0 || this.stopOffsets[this.count - 1] <= e)
      this.stopOffsets.push(e), this.classNames.push(t), this.metadata.push(i);
    else
      for (let r = 0; r < this.count; r++)
        if (this.stopOffsets[r] >= e) {
          this.stopOffsets.splice(r, 0, e), this.classNames.splice(r, 0, t), this.metadata.splice(r, 0, i);
          break;
        }
    this.count++;
  }
}
class vae {
  /**
   * Normalize line decorations. Overlapping decorations will generate multiple segments
   */
  static normalize(e, t) {
    if (t.length === 0)
      return [];
    let i = [];
    const r = new Db();
    let o = 0;
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      let u = l.startColumn, c = l.endColumn;
      const h = l.className, d = l.type === 1 ? 2 : l.type === 2 ? 4 : 0;
      if (u > 1) {
        const g = e.charCodeAt(u - 2);
        Kn(g) && u--;
      }
      if (c > 1) {
        const g = e.charCodeAt(c - 2);
        Kn(g) && c--;
      }
      const f = u - 1, p = c - 2;
      o = r.consumeLowerThan(f, o, i), r.count === 0 && (o = f), r.insert(p, h, d);
    }
    return r.consumeLowerThan(1073741824, o, i), i;
  }
}
class Rr {
  constructor(e, t, i) {
    this.endIndex = e, this.type = t, this.metadata = i;
  }
  isWhitespace() {
    return !!(this.metadata & 1);
  }
  isPseudoAfter() {
    return !!(this.metadata & 4);
  }
}
class _ae {
  constructor(e, t) {
    this.startOffset = e, this.endOffset = t;
  }
  equals(e) {
    return this.startOffset === e.startOffset && this.endOffset === e.endOffset;
  }
}
class Pg {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g, _, m, v, C) {
    this.useMonospaceOptimizations = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.continuesWithWrappedLine = r, this.isBasicASCII = o, this.containsRTL = s, this.fauxIndentLength = a, this.lineTokens = l, this.lineDecorations = u.sort(ga.compare), this.tabSize = c, this.startVisibleColumn = h, this.spaceWidth = d, this.stopRenderingLineAfter = g, this.renderWhitespace = _ === "all" ? 4 : _ === "boundary" ? 1 : _ === "selection" ? 2 : _ === "trailing" ? 3 : 0, this.renderControlCharacters = m, this.fontLigatures = v, this.selectionsOnLine = C && C.sort((L, S) => L.startOffset < S.startOffset ? -1 : 1);
    const y = Math.abs(p - d), w = Math.abs(f - d);
    y < w ? (this.renderSpaceWidth = p, this.renderSpaceCharCode = 11825) : (this.renderSpaceWidth = f, this.renderSpaceCharCode = 183);
  }
  sameSelection(e) {
    if (this.selectionsOnLine === null)
      return e === null;
    if (e === null || e.length !== this.selectionsOnLine.length)
      return !1;
    for (let t = 0; t < this.selectionsOnLine.length; t++)
      if (!this.selectionsOnLine[t].equals(e[t]))
        return !1;
    return !0;
  }
  equals(e) {
    return this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineContent === e.lineContent && this.continuesWithWrappedLine === e.continuesWithWrappedLine && this.isBasicASCII === e.isBasicASCII && this.containsRTL === e.containsRTL && this.fauxIndentLength === e.fauxIndentLength && this.tabSize === e.tabSize && this.startVisibleColumn === e.startVisibleColumn && this.spaceWidth === e.spaceWidth && this.renderSpaceWidth === e.renderSpaceWidth && this.renderSpaceCharCode === e.renderSpaceCharCode && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.fontLigatures === e.fontLigatures && ga.equalsArr(this.lineDecorations, e.lineDecorations) && this.lineTokens.equals(e.lineTokens) && this.sameSelection(e.selectionsOnLine);
  }
}
class Ho {
  constructor(e, t) {
    this.length = e, this._data = new Uint32Array(this.length), this._absoluteOffsets = new Uint32Array(this.length);
  }
  static getPartIndex(e) {
    return (e & 4294901760) >>> 16;
  }
  static getCharIndex(e) {
    return (e & 65535) >>> 0;
  }
  setPartData(e, t, i, r) {
    let o = (t << 16 | i << 0) >>> 0;
    this._data[e] = o, this._absoluteOffsets[e] = r + i;
  }
  getAbsoluteOffsets() {
    return this._absoluteOffsets;
  }
  charOffsetToPartData(e) {
    return this.length === 0 ? 0 : e < 0 ? this._data[0] : e >= this.length ? this._data[this.length - 1] : this._data[e];
  }
  partDataToCharOffset(e, t, i) {
    if (this.length === 0)
      return 0;
    let r = (e << 16 | i << 0) >>> 0, o = 0, s = this.length - 1;
    for (; o + 1 < s; ) {
      let g = o + s >>> 1, _ = this._data[g];
      if (_ === r)
        return g;
      _ > r ? s = g : o = g;
    }
    if (o === s)
      return o;
    let a = this._data[o], l = this._data[s];
    if (a === r)
      return o;
    if (l === r)
      return s;
    let u = Ho.getPartIndex(a), c = Ho.getCharIndex(a), h = Ho.getPartIndex(l), d;
    u !== h ? d = t : d = Ho.getCharIndex(l);
    let f = i - c, p = d - i;
    return f <= p ? o : s;
  }
}
class GT {
  constructor(e, t, i) {
    this.characterMapping = e, this.containsRTL = t, this.containsForeignElements = i;
  }
}
function nI(n, e) {
  if (n.lineContent.length === 0) {
    if (n.lineDecorations.length > 0) {
      e.appendASCIIString("<span>");
      let t = 0, i = 0, r = 0;
      for (const s of n.lineDecorations)
        (s.type === 1 || s.type === 2) && (e.appendASCIIString('<span class="'), e.appendASCIIString(s.className), e.appendASCIIString('"></span>'), s.type === 1 && (r |= 1, t++), s.type === 2 && (r |= 2, i++));
      e.appendASCIIString("</span>");
      const o = new Ho(1, t + i);
      return o.setPartData(0, t, 0, 0), new GT(o, !1, r);
    }
    return e.appendASCIIString("<span><span></span></span>"), new GT(
      new Ho(0, 0),
      !1,
      0
      /* None */
    );
  }
  return Dae(wae(n), e);
}
class Cae {
  constructor(e, t, i, r) {
    this.characterMapping = e, this.html = t, this.containsRTL = i, this.containsForeignElements = r;
  }
}
function cE(n) {
  let e = eg(1e4), t = nI(n, e);
  return new Cae(t.characterMapping, e.build(), t.containsRTL, t.containsForeignElements);
}
class yae {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g) {
    this.fontIsMonospace = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.len = r, this.isOverflowing = o, this.parts = s, this.containsForeignElements = a, this.fauxIndentLength = l, this.tabSize = u, this.startVisibleColumn = c, this.containsRTL = h, this.spaceWidth = d, this.renderSpaceCharCode = f, this.renderWhitespace = p, this.renderControlCharacters = g;
  }
}
function wae(n) {
  const e = n.lineContent;
  let t, i;
  n.stopRenderingLineAfter !== -1 && n.stopRenderingLineAfter < e.length ? (t = !0, i = n.stopRenderingLineAfter) : (t = !1, i = e.length);
  let r = bae(n.lineTokens, n.fauxIndentLength, i);
  (n.renderWhitespace === 4 || n.renderWhitespace === 1 || n.renderWhitespace === 2 && n.selectionsOnLine || n.renderWhitespace === 3) && (r = Eae(n, e, i, r));
  let o = 0;
  if (n.lineDecorations.length > 0) {
    for (let s = 0, a = n.lineDecorations.length; s < a; s++) {
      const l = n.lineDecorations[s];
      l.type === 3 || l.type === 1 ? o |= 1 : l.type === 2 && (o |= 2);
    }
    r = Lae(e, i, r, n.lineDecorations);
  }
  return n.containsRTL || (r = Sae(e, r, !n.isBasicASCII || n.fontLigatures)), new yae(n.useMonospaceOptimizations, n.canUseHalfwidthRightwardsArrow, e, i, t, r, o, n.fauxIndentLength, n.tabSize, n.startVisibleColumn, n.containsRTL, n.spaceWidth, n.renderSpaceCharCode, n.renderWhitespace, n.renderControlCharacters);
}
function bae(n, e, t) {
  let i = [], r = 0;
  e > 0 && (i[r++] = new Rr(e, "", 0));
  for (let o = 0, s = n.getCount(); o < s; o++) {
    const a = n.getEndOffset(o);
    if (a <= e)
      continue;
    const l = n.getClassName(o);
    if (a >= t) {
      i[r++] = new Rr(t, l, 0);
      break;
    }
    i[r++] = new Rr(a, l, 0);
  }
  return i;
}
function Sae(n, e, t) {
  let i = 0, r = [], o = 0;
  if (t)
    for (let s = 0, a = e.length; s < a; s++) {
      const l = e[s], u = l.endIndex;
      if (i + 50 < u) {
        const c = l.type, h = l.metadata;
        let d = -1, f = i;
        for (let p = i; p < u; p++)
          n.charCodeAt(p) === 32 && (d = p), d !== -1 && p - f >= 50 && (r[o++] = new Rr(d + 1, c, h), f = d + 1, d = -1);
        f !== u && (r[o++] = new Rr(u, c, h));
      } else
        r[o++] = l;
      i = u;
    }
  else
    for (let s = 0, a = e.length; s < a; s++) {
      const l = e[s], u = l.endIndex;
      let c = u - i;
      if (c > 50) {
        const h = l.type, d = l.metadata, f = Math.ceil(
          c / 50
          /* LongToken */
        );
        for (let p = 1; p < f; p++) {
          let g = i + p * 50;
          r[o++] = new Rr(g, h, d);
        }
        r[o++] = new Rr(u, h, d);
      } else
        r[o++] = l;
      i = u;
    }
  return r;
}
function Eae(n, e, t, i) {
  const r = n.continuesWithWrappedLine, o = n.fauxIndentLength, s = n.tabSize, a = n.startVisibleColumn, l = n.useMonospaceOptimizations, u = n.selectionsOnLine, c = n.renderWhitespace === 1, h = n.renderWhitespace === 3, d = n.renderSpaceWidth !== n.spaceWidth;
  let f = [], p = 0, g = 0, _ = i[g].type, m = i[g].endIndex;
  const v = i.length;
  let C = !1, y = Os(e), w;
  y === -1 ? (C = !0, y = t, w = t) : w = Ng(e);
  let L = !1, S = 0, E = u && u[S], D = a % s;
  for (let R = o; R < t; R++) {
    const A = e.charCodeAt(R);
    E && R >= E.endOffset && (S++, E = u && u[S]);
    let M;
    if (R < y || R > w)
      M = !0;
    else if (A === 9)
      M = !0;
    else if (A === 32)
      if (c)
        if (L)
          M = !0;
        else {
          const z = R + 1 < t ? e.charCodeAt(R + 1) : 0;
          M = z === 32 || z === 9;
        }
      else
        M = !0;
    else
      M = !1;
    if (M && u && (M = !!E && E.startOffset <= R && E.endOffset > R), M && h && (M = C || R > w), L) {
      if (!M || !l && D >= s) {
        if (d) {
          const z = p > 0 ? f[p - 1].endIndex : o;
          for (let j = z + 1; j <= R; j++)
            f[p++] = new Rr(
              j,
              "mtkw",
              1
              /* IS_WHITESPACE */
            );
        } else
          f[p++] = new Rr(
            R,
            "mtkw",
            1
            /* IS_WHITESPACE */
          );
        D = D % s;
      }
    } else
      (R === m || M && R > o) && (f[p++] = new Rr(R, _, 0), D = D % s);
    for (A === 9 ? D = s : el(A) ? D += 2 : D++, L = M; R === m; )
      g++, g < v && (_ = i[g].type, m = i[g].endIndex);
  }
  let x = !1;
  if (L)
    if (r && c) {
      let R = t > 0 ? e.charCodeAt(t - 1) : 0, A = t > 1 ? e.charCodeAt(t - 2) : 0;
      R === 32 && A !== 32 && A !== 9 || (x = !0);
    } else
      x = !0;
  if (x)
    if (d) {
      const R = p > 0 ? f[p - 1].endIndex : o;
      for (let A = R + 1; A <= t; A++)
        f[p++] = new Rr(
          A,
          "mtkw",
          1
          /* IS_WHITESPACE */
        );
    } else
      f[p++] = new Rr(
        t,
        "mtkw",
        1
        /* IS_WHITESPACE */
      );
  else
    f[p++] = new Rr(t, _, 0);
  return f;
}
function Lae(n, e, t, i) {
  i.sort(ga.compare);
  const r = vae.normalize(n, i), o = r.length;
  let s = 0, a = [], l = 0, u = 0;
  for (let h = 0, d = t.length; h < d; h++) {
    const f = t[h], p = f.endIndex, g = f.type, _ = f.metadata;
    for (; s < o && r[s].startOffset < p; ) {
      const m = r[s];
      if (m.startOffset > u && (u = m.startOffset, a[l++] = new Rr(u, g, _)), m.endOffset + 1 <= p)
        u = m.endOffset + 1, a[l++] = new Rr(u, g + " " + m.className, _ | m.metadata), s++;
      else {
        u = p, a[l++] = new Rr(u, g + " " + m.className, _ | m.metadata);
        break;
      }
    }
    p > u && (u = p, a[l++] = new Rr(u, g, _));
  }
  const c = t[t.length - 1].endIndex;
  if (s < o && r[s].startOffset === c)
    for (; s < o && r[s].startOffset === c; ) {
      const h = r[s];
      a[l++] = new Rr(u, h.className, h.metadata), s++;
    }
  return a;
}
function Dae(n, e) {
  const t = n.fontIsMonospace, i = n.canUseHalfwidthRightwardsArrow, r = n.containsForeignElements, o = n.lineContent, s = n.len, a = n.isOverflowing, l = n.parts, u = n.fauxIndentLength, c = n.tabSize, h = n.startVisibleColumn, d = n.containsRTL, f = n.spaceWidth, p = n.renderSpaceCharCode, g = n.renderWhitespace, _ = n.renderControlCharacters, m = new Ho(s + 1, l.length);
  let v = !1, C = 0, y = h, w = 0, L = 0, S = 0, E = 0;
  d ? e.appendASCIIString('<span dir="ltr">') : e.appendASCIIString("<span>");
  for (let D = 0, x = l.length; D < x; D++) {
    E += S;
    const R = l[D], A = R.endIndex, M = R.type, z = g !== 0 && R.isWhitespace(), j = z && !t && (M === "mtkw" || !r), $ = C === A && R.isPseudoAfter();
    if (w = 0, e.appendASCIIString('<span class="'), e.appendASCIIString(j ? "mtkz" : M), e.appendASCII(
      34
      /* DoubleQuote */
    ), z) {
      let k = 0;
      {
        let ae = C, re = y;
        for (; ae < A; ae++) {
          const K = (o.charCodeAt(ae) === 9 ? c - re % c : 1) | 0;
          k += K, ae >= u && (re += K);
        }
      }
      for (j && (e.appendASCIIString(' style="width:'), e.appendASCIIString(String(f * k)), e.appendASCIIString('px"')), e.appendASCII(
        62
        /* GreaterThan */
      ); C < A; C++) {
        m.setPartData(C, D - L, w, E), L = 0;
        const ae = o.charCodeAt(C);
        let re;
        if (ae === 9) {
          re = c - y % c | 0, !i || re > 1 ? e.write1(8594) : e.write1(65515);
          for (let Y = 2; Y <= re; Y++)
            e.write1(160);
        } else
          re = 1, e.write1(p);
        w += re, C >= u && (y += re);
      }
      S = k;
    } else {
      let k = 0;
      for (e.appendASCII(
        62
        /* GreaterThan */
      ); C < A; C++) {
        m.setPartData(C, D - L, w, E), L = 0;
        const ae = o.charCodeAt(C);
        let re = 1, Y = 1;
        switch (ae) {
          case 9:
            re = c - y % c, Y = re;
            for (let K = 1; K <= re; K++)
              e.write1(160);
            break;
          case 32:
            e.write1(160);
            break;
          case 60:
            e.appendASCIIString("&lt;");
            break;
          case 62:
            e.appendASCIIString("&gt;");
            break;
          case 38:
            e.appendASCIIString("&amp;");
            break;
          case 0:
            _ ? e.write1(9216) : e.appendASCIIString("&#00;");
            break;
          case 65279:
          case 8232:
          case 8233:
          case 133:
            e.write1(65533);
            break;
          default:
            el(ae) && Y++, _ && ae < 32 ? e.write1(9216 + ae) : _ && ae === 127 ? e.write1(9249) : e.write1(ae);
        }
        w += re, k += re, C >= u && (y += Y);
      }
      S = k;
    }
    $ ? L++ : L = 0, C >= s && !v && R.isPseudoAfter() && (v = !0, m.setPartData(C, D, w, E)), e.appendASCIIString("</span>");
  }
  return v || m.setPartData(s, l.length - 1, w, E), a && e.appendASCIIString("<span>&hellip;</span>"), e.appendASCIIString("</span>"), new GT(m, d, r);
}
class qk {
  constructor(e, t, i, r) {
    this.top = e | 0, this.left = t | 0, this.width = i | 0, this.height = r | 0;
  }
}
class Rae {
  constructor(e, t) {
    this.outputLineIndex = e, this.outputOffset = t;
  }
}
class Zh {
  constructor(e, t, i) {
    this.breakOffsets = e, this.breakOffsetsVisibleColumn = t, this.wrappedTextIndentLength = i;
  }
  static getInputOffsetOfOutputPosition(e, t, i) {
    return t === 0 ? i : e[t - 1] + i;
  }
  static getOutputPositionOfInputOffset(e, t) {
    let i = 0, r = e.length - 1, o = 0, s = 0;
    for (; i <= r; ) {
      o = i + (r - i) / 2 | 0;
      const a = e[o];
      if (s = o > 0 ? e[o - 1] : 0, t < s)
        r = o - 1;
      else if (t >= a)
        i = o + 1;
      else
        break;
    }
    return new Rae(o, t - s);
  }
}
class Tae {
  constructor(e, t) {
    this.tabSize = e, this.data = t;
  }
}
class rI {
  constructor(e, t, i, r, o, s) {
    this.content = e, this.continuesWithWrappedLine = t, this.minColumn = i, this.maxColumn = r, this.startVisibleColumn = o, this.tokens = s;
  }
}
class Yo {
  constructor(e, t, i, r, o, s, a, l, u, c) {
    this.minColumn = e, this.maxColumn = t, this.content = i, this.continuesWithWrappedLine = r, this.isBasicASCII = Yo.isBasicASCII(i, s), this.containsRTL = Yo.containsRTL(i, this.isBasicASCII, o), this.tokens = a, this.inlineDecorations = l, this.tabSize = u, this.startVisibleColumn = c;
  }
  static isBasicASCII(e, t) {
    return t ? _5(e) : !0;
  }
  static containsRTL(e, t, i) {
    return !t && i ? GN(e) : !1;
  }
}
class cw {
  constructor(e, t, i) {
    this.range = e, this.inlineClassName = t, this.type = i;
  }
}
class X5 {
  constructor(e, t) {
    this.range = e, this.options = t;
  }
}
function Oae(n) {
  return Array.isArray(n);
}
function xae(n) {
  return !Oae(n);
}
function Z5(n) {
  return typeof n == "string";
}
function Yk(n) {
  return !Z5(n);
}
function qf(n) {
  return !n;
}
function eh(n, e) {
  return n.ignoreCase && e ? e.toLowerCase() : e;
}
function Xk(n) {
  return n.replace(/[&<>'"_]/g, "-");
}
function Nae(n, e) {
  console.log(`${n.languageId}: ${e}`);
}
function ei(n, e) {
  return new Error(`${n.languageId}: ${e}`);
}
function Bc(n, e, t, i, r) {
  const o = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
  let s = null;
  return e.replace(o, function(a, l, u, c, h, d, f, p, g) {
    return qf(u) ? qf(c) ? !qf(h) && h < i.length ? eh(n, i[h]) : !qf(f) && n && typeof n[f] == "string" ? n[f] : (s === null && (s = r.split("."), s.unshift(r)), !qf(d) && d < s.length ? eh(n, s[d]) : "") : eh(n, t) : "$";
  });
}
function _y(n, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    const i = n.tokenizer[t];
    if (i)
      return i;
    const r = t.lastIndexOf(".");
    r < 0 ? t = null : t = t.substr(0, r);
  }
  return null;
}
function Iae(n, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    if (n.stateNames[t])
      return !0;
    const r = t.lastIndexOf(".");
    r < 0 ? t = null : t = t.substr(0, r);
  }
  return !1;
}
const Q5 = 5;
class e_ {
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  create(e, t) {
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new Rp(e, t);
    let i = Rp.getStackElementId(e);
    i.length > 0 && (i += "|"), i += t;
    let r = this._entries[i];
    return r || (r = new Rp(e, t), this._entries[i] = r, r);
  }
}
e_._INSTANCE = new e_(Q5);
class Rp {
  constructor(e, t) {
    this.parent = e, this.state = t, this.depth = (this.parent ? this.parent.depth : 0) + 1;
  }
  static getStackElementId(e) {
    let t = "";
    for (; e !== null; )
      t.length > 0 && (t += "|"), t += e.state, e = e.parent;
    return t;
  }
  static _equals(e, t) {
    for (; e !== null && t !== null; ) {
      if (e === t)
        return !0;
      if (e.state !== t.state)
        return !1;
      e = e.parent, t = t.parent;
    }
    return e === null && t === null;
  }
  equals(e) {
    return Rp._equals(this, e);
  }
  push(e) {
    return e_.create(this, e);
  }
  pop() {
    return this.parent;
  }
  popall() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  switchTo(e) {
    return e_.create(this.parent, e);
  }
}
class vv {
  constructor(e, t) {
    this.modeId = e, this.state = t;
  }
  equals(e) {
    return this.modeId === e.modeId && this.state.equals(e.state);
  }
  clone() {
    return this.state.clone() === this.state ? this : new vv(this.modeId, this.state);
  }
}
class Hc {
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  create(e, t) {
    if (t !== null)
      return new _v(e, t);
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new _v(e, t);
    let i = Rp.getStackElementId(e), r = this._entries[i];
    return r || (r = new _v(e, null), this._entries[i] = r, r);
  }
}
Hc._INSTANCE = new Hc(Q5);
class _v {
  constructor(e, t) {
    this.stack = e, this.embeddedModeData = t;
  }
  clone() {
    return (this.embeddedModeData ? this.embeddedModeData.clone() : null) === this.embeddedModeData ? this : Hc.create(this.stack, this.embeddedModeData);
  }
  equals(e) {
    return !(e instanceof _v) || !this.stack.equals(e.stack) ? !1 : this.embeddedModeData === null && e.embeddedModeData === null ? !0 : this.embeddedModeData === null || e.embeddedModeData === null ? !1 : this.embeddedModeData.equals(e.embeddedModeData);
  }
}
class Pae {
  constructor() {
    this._tokens = [], this._language = null, this._lastTokenType = null, this._lastTokenLanguage = null;
  }
  enterMode(e, t) {
    this._language = t;
  }
  emit(e, t) {
    this._lastTokenType === t && this._lastTokenLanguage === this._language || (this._lastTokenType = t, this._lastTokenLanguage = this._language, this._tokens.push(new JS(e, t, this._language)));
  }
  nestedModeTokenize(e, t, i, r) {
    const o = i.modeId, s = i.state, a = cn.get(o);
    if (!a)
      return this.enterMode(r, o), this.emit(r, ""), s;
    let l = a.tokenize(e, t, s, r);
    return this._tokens = this._tokens.concat(l.tokens), this._lastTokenType = null, this._lastTokenLanguage = null, this._language = null, l.endState;
  }
  finalize(e) {
    return new PN(this._tokens, e);
  }
}
class Rb {
  constructor(e, t) {
    this._modeService = e, this._theme = t, this._prependTokens = null, this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0;
  }
  enterMode(e, t) {
    this._currentLanguageId = this._modeService.getLanguageIdentifier(t).id;
  }
  emit(e, t) {
    let i = this._theme.match(this._currentLanguageId, t);
    this._lastTokenMetadata !== i && (this._lastTokenMetadata = i, this._tokens.push(e), this._tokens.push(i));
  }
  static _merge(e, t, i) {
    let r = e !== null ? e.length : 0, o = t.length, s = i !== null ? i.length : 0;
    if (r === 0 && o === 0 && s === 0)
      return new Uint32Array(0);
    if (r === 0 && o === 0)
      return i;
    if (o === 0 && s === 0)
      return e;
    let a = new Uint32Array(r + o + s);
    e !== null && a.set(e);
    for (let l = 0; l < o; l++)
      a[r + l] = t[l];
    return i !== null && a.set(i, r + o), a;
  }
  nestedModeTokenize(e, t, i, r) {
    const o = i.modeId, s = i.state, a = cn.get(o);
    if (!a)
      return this.enterMode(r, o), this.emit(r, ""), s;
    let l = a.tokenize2(e, t, s, r);
    return this._prependTokens = Rb._merge(this._prependTokens, this._tokens, l.tokens), this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0, l.endState;
  }
  finalize(e) {
    return new eE(Rb._merge(this._prependTokens, this._tokens, null), e);
  }
}
class hE {
  constructor(e, t, i, r) {
    this._modeService = e, this._standaloneThemeService = t, this._modeId = i, this._lexer = r, this._embeddedModes = /* @__PURE__ */ Object.create(null), this.embeddedLoaded = Promise.resolve(void 0);
    let o = !1;
    this._tokenizationRegistryListener = cn.onDidChange((s) => {
      if (o)
        return;
      let a = !1;
      for (let l = 0, u = s.changedLanguages.length; l < u; l++) {
        let c = s.changedLanguages[l];
        if (this._embeddedModes[c]) {
          a = !0;
          break;
        }
      }
      a && (o = !0, cn.fire([this._modeId]), o = !1);
    });
  }
  dispose() {
    this._tokenizationRegistryListener.dispose();
  }
  getLoadStatus() {
    let e = [];
    for (let t in this._embeddedModes) {
      const i = cn.get(t);
      if (i) {
        if (i instanceof hE) {
          const o = i.getLoadStatus();
          o.loaded === !1 && e.push(o.promise);
        }
        continue;
      }
      const r = cn.getPromise(t);
      r && e.push(r);
    }
    return e.length === 0 ? {
      loaded: !0
    } : {
      loaded: !1,
      promise: Promise.all(e).then((t) => {
      })
    };
  }
  getInitialState() {
    let e = e_.create(null, this._lexer.start);
    return Hc.create(e, null);
  }
  tokenize(e, t, i, r) {
    let o = new Pae(), s = this._tokenize(e, t, i, r, o);
    return o.finalize(s);
  }
  tokenize2(e, t, i, r) {
    let o = new Rb(this._modeService, this._standaloneThemeService.getColorTheme().tokenTheme), s = this._tokenize(e, t, i, r, o);
    return o.finalize(s);
  }
  _tokenize(e, t, i, r, o) {
    return i.embeddedModeData ? this._nestedTokenize(e, t, i, r, o) : this._myTokenize(e, t, i, r, o);
  }
  _findLeavingNestedModeOffset(e, t) {
    let i = this._lexer.tokenizer[t.stack.state];
    if (!i && (i = _y(this._lexer, t.stack.state), !i))
      throw ei(this._lexer, "tokenizer state is not defined: " + t.stack.state);
    let r = -1, o = !1;
    for (const s of i) {
      if (!Yk(s.action) || s.action.nextEmbedded !== "@pop")
        continue;
      o = !0;
      let a = s.regex, l = s.regex.source;
      if (l.substr(0, 4) === "^(?:" && l.substr(l.length - 1, 1) === ")") {
        let c = (a.ignoreCase ? "i" : "") + (a.unicode ? "u" : "");
        a = new RegExp(l.substr(4, l.length - 5), c);
      }
      let u = e.search(a);
      u === -1 || u !== 0 && s.matchOnlyAtLineStart || (r === -1 || u < r) && (r = u);
    }
    if (!o)
      throw ei(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + t.stack.state);
    return r;
  }
  _nestedTokenize(e, t, i, r, o) {
    let s = this._findLeavingNestedModeOffset(e, i);
    if (s === -1) {
      let u = o.nestedModeTokenize(e, t, i.embeddedModeData, r);
      return Hc.create(i.stack, new vv(i.embeddedModeData.modeId, u));
    }
    let a = e.substring(0, s);
    a.length > 0 && o.nestedModeTokenize(a, !1, i.embeddedModeData, r);
    let l = e.substring(s);
    return this._myTokenize(l, t, i, r + s, o);
  }
  _safeRuleName(e) {
    return e ? e.name : "(unknown)";
  }
  _myTokenize(e, t, i, r, o) {
    o.enterMode(r, this._modeId);
    const s = e.length, a = t && this._lexer.includeLF ? e + `
` : e, l = a.length;
    let u = i.embeddedModeData, c = i.stack, h = 0, d = null, f = !0;
    for (; f || h < l; ) {
      const p = h, g = c.depth, _ = d ? d.groups.length : 0, m = c.state;
      let v = null, C = null, y = null, w = null, L = null;
      if (d) {
        v = d.matches;
        const D = d.groups.shift();
        C = D.matched, y = D.action, w = d.rule, d.groups.length === 0 && (d = null);
      } else {
        if (!f && h >= l)
          break;
        f = !1;
        let D = this._lexer.tokenizer[m];
        if (!D && (D = _y(this._lexer, m), !D))
          throw ei(this._lexer, "tokenizer state is not defined: " + m);
        let x = a.substr(h);
        for (const R of D)
          if ((h === 0 || !R.matchOnlyAtLineStart) && (v = x.match(R.regex), v)) {
            C = v[0], y = R.action;
            break;
          }
      }
      if (v || (v = [""], C = ""), y || (h < l && (v = [a.charAt(h)], C = v[0]), y = this._lexer.defaultToken), C === null)
        break;
      for (h += C.length; xae(y) && Yk(y) && y.test; )
        y = y.test(C, v, m, h === l);
      let S = null;
      if (typeof y == "string" || Array.isArray(y))
        S = y;
      else if (y.group)
        S = y.group;
      else if (y.token !== null && y.token !== void 0) {
        if (y.tokenSubst ? S = Bc(this._lexer, y.token, C, v, m) : S = y.token, y.nextEmbedded)
          if (y.nextEmbedded === "@pop") {
            if (!u)
              throw ei(this._lexer, "cannot pop embedded mode if not inside one");
            u = null;
          } else {
            if (u)
              throw ei(this._lexer, "cannot enter embedded mode from within an embedded mode");
            L = Bc(this._lexer, y.nextEmbedded, C, v, m);
          }
        if (y.goBack && (h = Math.max(0, h - y.goBack)), y.switchTo && typeof y.switchTo == "string") {
          let D = Bc(this._lexer, y.switchTo, C, v, m);
          if (D[0] === "@" && (D = D.substr(1)), _y(this._lexer, D))
            c = c.switchTo(D);
          else
            throw ei(this._lexer, "trying to switch to a state '" + D + "' that is undefined in rule: " + this._safeRuleName(w));
        } else {
          if (y.transform && typeof y.transform == "function")
            throw ei(this._lexer, "action.transform not supported");
          if (y.next)
            if (y.next === "@push") {
              if (c.depth >= this._lexer.maxStack)
                throw ei(this._lexer, "maximum tokenizer stack size reached: [" + c.state + "," + c.parent.state + ",...]");
              c = c.push(m);
            } else if (y.next === "@pop") {
              if (c.depth <= 1)
                throw ei(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(w));
              c = c.pop();
            } else if (y.next === "@popall")
              c = c.popall();
            else {
              let D = Bc(this._lexer, y.next, C, v, m);
              if (D[0] === "@" && (D = D.substr(1)), _y(this._lexer, D))
                c = c.push(D);
              else
                throw ei(this._lexer, "trying to set a next state '" + D + "' that is undefined in rule: " + this._safeRuleName(w));
            }
        }
        y.log && typeof y.log == "string" && Nae(this._lexer, this._lexer.languageId + ": " + Bc(this._lexer, y.log, C, v, m));
      }
      if (S === null)
        throw ei(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(w));
      const E = (D) => {
        let x = this._modeService.getModeIdForLanguageName(D);
        x && (D = x);
        const R = this._getNestedEmbeddedModeData(D);
        if (h < l) {
          const A = e.substr(h);
          return this._nestedTokenize(A, t, Hc.create(c, R), r + h, o);
        } else
          return Hc.create(c, R);
      };
      if (Array.isArray(S)) {
        if (d && d.groups.length > 0)
          throw ei(this._lexer, "groups cannot be nested: " + this._safeRuleName(w));
        if (v.length !== S.length + 1)
          throw ei(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(w));
        let D = 0;
        for (let x = 1; x < v.length; x++)
          D += v[x].length;
        if (D !== C.length)
          throw ei(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(w));
        d = {
          rule: w,
          matches: v,
          groups: []
        };
        for (let x = 0; x < S.length; x++)
          d.groups[x] = {
            action: S[x],
            matched: v[x + 1]
          };
        h -= C.length;
        continue;
      } else {
        if (S === "@rematch" && (h -= C.length, C = "", v = null, S = "", L !== null))
          return E(L);
        if (C.length === 0) {
          if (l === 0 || g !== c.depth || m !== c.state || (d ? d.groups.length : 0) !== _)
            continue;
          throw ei(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(w));
        }
        let D = null;
        if (Z5(S) && S.indexOf("@brackets") === 0) {
          let x = S.substr(9), R = Aae(this._lexer, C);
          if (!R)
            throw ei(this._lexer, "@brackets token returned but no bracket defined as: " + C);
          D = Xk(R.token + x);
        } else {
          let x = S === "" ? "" : S + this._lexer.tokenPostfix;
          D = Xk(x);
        }
        p < s && o.emit(p + r, D);
      }
      if (L !== null)
        return E(L);
    }
    return Hc.create(c, u);
  }
  _getNestedEmbeddedModeData(e) {
    let t = this._locateMode(e);
    if (t) {
      let i = cn.get(t);
      if (i)
        return new vv(t, i.getInitialState());
    }
    return new vv(t || ZN, sE);
  }
  _locateMode(e) {
    if (!e || !this._modeService.isRegisteredMode(e))
      return null;
    if (e === this._modeId)
      return e;
    let t = this._modeService.getModeId(e);
    return t && (this._modeService.triggerMode(t), this._embeddedModes[t] = !0), t;
  }
}
function Aae(n, e) {
  if (!e)
    return null;
  e = eh(n, e);
  let t = n.brackets;
  for (const i of t) {
    if (i.open === e)
      return {
        token: i.token,
        bracketType: 1
        /* Open */
      };
    if (i.close === e)
      return {
        token: i.token,
        bracketType: -1
        /* Close */
      };
  }
  return null;
}
function Mae(n, e, t, i) {
  return new hE(n, e, t, i);
}
var RD;
const TD = (RD = window.trustedTypes) === null || RD === void 0 ? void 0 : RD.createPolicy("standaloneColorizer", { createHTML: (n) => n });
class oI {
  static colorizeElement(e, t, i, r) {
    r = r || {};
    let o = r.theme || "vs", s = r.mimeType || i.getAttribute("lang") || i.getAttribute("data-lang");
    if (!s)
      return console.error("Mode not detected"), Promise.resolve();
    e.setTheme(o);
    let a = i.firstChild ? i.firstChild.nodeValue : "";
    i.className += " " + o;
    let l = (u) => {
      var c;
      const h = (c = TD == null ? void 0 : TD.createHTML(u)) !== null && c !== void 0 ? c : u;
      i.innerHTML = h;
    };
    return this.colorize(t, a || "", s, r).then(l, (u) => console.error(u));
  }
  static colorize(e, t, i, r) {
    let o = 4;
    r && typeof r.tabSize == "number" && (o = r.tabSize), UN(t) && (t = t.substr(1));
    let s = z_(t), a = e.getModeId(i);
    if (!a)
      return Promise.resolve(Zk(s, o));
    e.triggerMode(a);
    const l = cn.get(a);
    if (l)
      return OD(s, o, l);
    const u = cn.getPromise(a);
    return u ? new Promise((c, h) => {
      u.then((d) => {
        OD(s, o, d).then(c, h);
      }, h);
    }) : new Promise((c, h) => {
      let d = null, f = null;
      const p = () => {
        d && (d.dispose(), d = null), f && (f.dispose(), f = null);
        const g = cn.get(a);
        if (g) {
          OD(s, o, g).then(c, h);
          return;
        }
        c(Zk(s, o));
      };
      f = new oc(), f.cancelAndSet(p, 500), d = cn.onDidChange((g) => {
        g.changedLanguages.indexOf(a) >= 0 && p();
      });
    });
  }
  static colorizeLine(e, t, i, r, o = 4) {
    const s = Yo.isBasicASCII(e, t), a = Yo.containsRTL(e, s, i);
    return cE(new Pg(!1, !0, e, !1, s, a, 0, r, [], o, 0, 0, 0, 0, -1, "none", !1, !1, null)).html;
  }
  static colorizeModelLine(e, t, i = 4) {
    let r = e.getLineContent(t);
    e.forceTokenization(t);
    let s = e.getLineTokens(t).inflate();
    return this.colorizeLine(r, e.mightContainNonBasicASCII(), e.mightContainRTL(), s, i);
  }
}
function OD(n, e, t) {
  return new Promise((i, r) => {
    const o = () => {
      const s = Fae(n, e, t);
      if (t instanceof hE) {
        const a = t.getLoadStatus();
        if (a.loaded === !1) {
          a.promise.then(o, r);
          return;
        }
      }
      i(s);
    };
    o();
  });
}
function Zk(n, e) {
  let t = [];
  const r = new Uint32Array(2);
  r[0] = 0, r[1] = 16793600;
  for (let o = 0, s = n.length; o < s; o++) {
    let a = n[o];
    r[0] = a.length;
    const l = new eo(r, a), u = Yo.isBasicASCII(
      a,
      /* check for basic ASCII */
      !0
    ), c = Yo.containsRTL(
      a,
      u,
      /* check for RTL */
      !0
    );
    let h = cE(new Pg(!1, !0, a, !1, u, c, 0, l, [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    t = t.concat(h.html), t.push("<br/>");
  }
  return t.join("");
}
function Fae(n, e, t) {
  let i = [], r = t.getInitialState();
  for (let o = 0, s = n.length; o < s; o++) {
    let a = n[o], l = t.tokenize2(a, !0, r, 0);
    eo.convertToEndOffset(l.tokens, a.length);
    let u = new eo(l.tokens, a);
    const c = Yo.isBasicASCII(
      a,
      /* check for basic ASCII */
      !0
    ), h = Yo.containsRTL(
      a,
      c,
      /* check for RTL */
      !0
    );
    let d = cE(new Pg(!1, !0, a, !1, c, h, 0, u.inflate(), [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    i = i.concat(d.html), i.push("<br/>"), r = l.endState;
  }
  return i.join("");
}
var t_;
(function(n) {
  n[n.Ignore = 0] = "Ignore", n[n.Info = 1] = "Info", n[n.Warning = 2] = "Warning", n[n.Error = 3] = "Error";
})(t_ || (t_ = {}));
(function(n) {
  const e = "error", t = "warning", i = "warn", r = "info", o = "ignore";
  function s(l) {
    return l ? Zm(e, l) ? n.Error : Zm(t, l) || Zm(i, l) ? n.Warning : Zm(r, l) ? n.Info : n.Ignore : n.Ignore;
  }
  n.fromValue = s;
  function a(l) {
    switch (l) {
      case n.Error:
        return e;
      case n.Warning:
        return t;
      case n.Info:
        return r;
      default:
        return o;
    }
  }
  n.toString = a;
})(t_ || (t_ = {}));
const mn = t_;
function uh(n) {
  return n && typeof n.getEditorType == "function" ? n.getEditorType() === $_.ICodeEditor : !1;
}
function kae(n) {
  return n && typeof n.getEditorType == "function" ? n.getEditorType() === $_.IDiffEditor : !1;
}
function kye(n) {
  return uh(n) ? n : kae(n) ? n.getModifiedEditor() : null;
}
const Wae = Vt("IWorkspaceEditService");
function Vae(n) {
  return Uo(n) && (!!n.newUri || !!n.oldUri);
}
function Bae(n) {
  return Uo(n) && ft.isUri(n.resource) && Uo(n.edit);
}
class J5 {
  constructor(e) {
    this.metadata = e;
  }
  static convert(e) {
    return e.edits.map((t) => {
      if (Bae(t))
        return new e3(t.resource, t.edit, t.modelVersionId, t.metadata);
      if (Vae(t))
        return new Hae(t.oldUri, t.newUri, t.options, t.metadata);
      throw new Error("Unsupported edit");
    });
  }
}
class e3 extends J5 {
  constructor(e, t, i, r) {
    super(r), this.resource = e, this.textEdit = t, this.versionId = i;
  }
}
class Hae extends J5 {
  constructor(e, t, i, r) {
    super(r), this.oldResource = e, this.newResource = t, this.options = i;
  }
}
class Gae {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    sw(il(e)), sw(Uo(t)), sw(!this.data.has(e), "There is already an extension with this id"), this.data.set(e, t);
  }
  as(e) {
    return this.data.get(e) || null;
  }
}
const Jn = new Gae(), dE = {
  JSONContribution: "base.contributions.json"
};
function Uae(n) {
  return n.length > 0 && n.charAt(n.length - 1) === "#" ? n.substring(0, n.length - 1) : n;
}
class zae {
  constructor() {
    this._onDidChangeSchema = new q(), this.schemasById = {};
  }
  registerSchema(e, t) {
    this.schemasById[Uae(e)] = t, this._onDidChangeSchema.fire(e);
  }
  notifySchemaChanged(e) {
    this._onDidChangeSchema.fire(e);
  }
}
const jae = new zae();
Jn.add(dE.JSONContribution, jae);
const Ag = {
  Configuration: "base.contributions.configuration"
}, xD = "vscode://schemas/settings/resourceLanguage", Qk = Jn.as(dE.JSONContribution);
class $ae {
  constructor() {
    this.overrideIdentifiers = /* @__PURE__ */ new Set(), this._onDidSchemaChange = new q(), this._onDidUpdateConfiguration = new q(), this.defaultValues = {}, this.defaultLanguageConfigurationOverridesNode = {
      id: "defaultOverrides",
      title: b("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
      properties: {}
    }, this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode], this.resourceLanguageSettingsSchema = { properties: {}, patternProperties: {}, additionalProperties: !1, errorMessage: "Unknown editor configuration setting", allowTrailingCommas: !0, allowComments: !0 }, this.configurationProperties = {}, this.excludedConfigurationProperties = {}, Qk.registerSchema(xD, this.resourceLanguageSettingsSchema);
  }
  registerConfiguration(e, t = !0) {
    this.registerConfigurations([e], t);
  }
  registerConfigurations(e, t = !0) {
    const i = [];
    e.forEach((r) => {
      i.push(...this.validateAndRegisterProperties(r, t, r.extensionInfo)), this.configurationContributors.push(r), this.registerJSONConfiguration(r);
    }), Qk.registerSchema(xD, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire(i);
  }
  registerOverrideIdentifiers(e) {
    for (const t of e)
      this.overrideIdentifiers.add(t);
    this.updateOverridePropertyPatternKey();
  }
  validateAndRegisterProperties(e, t = !0, i, r = 3) {
    var o;
    r = _s(e.scope) ? r : e.scope;
    let s = [], a = e.properties;
    if (a)
      for (let u in a) {
        if (t && Xae(u)) {
          delete a[u];
          continue;
        }
        const c = a[u];
        if (this.updatePropertyDefaultValue(u, c), sI.test(u) ? c.scope = void 0 : (c.scope = _s(c.scope) ? r : c.scope, c.restricted = _s(c.restricted) ? !!(!((o = i == null ? void 0 : i.restrictedConfigurations) === null || o === void 0) && o.includes(u)) : c.restricted), a[u].hasOwnProperty("included") && !a[u].included) {
          this.excludedConfigurationProperties[u] = a[u], delete a[u];
          continue;
        } else
          this.configurationProperties[u] = a[u];
        !a[u].deprecationMessage && a[u].markdownDeprecationMessage && (a[u].deprecationMessage = a[u].markdownDeprecationMessage), s.push(u);
      }
    let l = e.allOf;
    if (l)
      for (let u of l)
        s.push(...this.validateAndRegisterProperties(u, t, i, r));
    return s;
  }
  getConfigurationProperties() {
    return this.configurationProperties;
  }
  registerJSONConfiguration(e) {
    const t = (i) => {
      let r = i.properties;
      if (r)
        for (const s in r)
          this.updateSchema(s, r[s]);
      let o = i.allOf;
      o && o.forEach(t);
    };
    t(e);
  }
  updateSchema(e, t) {
    switch (t.scope) {
      case 1:
        break;
      case 2:
        break;
      case 6:
        break;
      case 3:
        break;
      case 4:
        break;
      case 5:
        this.resourceLanguageSettingsSchema.properties[e] = t;
        break;
    }
  }
  updateOverridePropertyPatternKey() {
    for (const e of this.overrideIdentifiers.values()) {
      const t = `[${e}]`, i = {
        type: "object",
        description: b("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
        errorMessage: b("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
        $ref: xD
      };
      this.updatePropertyDefaultValue(t, i);
    }
    this._onDidSchemaChange.fire();
  }
  updatePropertyDefaultValue(e, t) {
    let i = this.defaultValues[e];
    xs(i) && (i = t.default), xs(i) && (i = Yae(t.type)), t.default = i;
  }
}
const Kae = "\\[.*\\]$", sI = new RegExp(Kae);
function qae(n) {
  return n.substring(1, n.length - 1);
}
function Yae(n) {
  switch (Array.isArray(n) ? n[0] : n) {
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
const t3 = new $ae();
Jn.add(Ag.Configuration, t3);
function Xae(n) {
  return n.trim() ? sI.test(n) ? b("config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", n) : t3.getConfigurationProperties()[n] !== void 0 ? b("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", n) : null : b("config.property.empty", "Cannot register an empty property");
}
const Zae = Object.prototype.hasOwnProperty;
function Qae(n, e) {
  for (let t in n)
    if (Zae.call(n, t) && e({ key: t, value: n[t] }, function() {
      delete n[t];
    }) === !1)
      return;
}
class Jae {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    let i = this.map.get(e);
    i || (i = /* @__PURE__ */ new Set(), this.map.set(e, i)), i.add(t);
  }
  delete(e, t) {
    const i = this.map.get(e);
    i && (i.delete(t), i.size === 0 && this.map.delete(e));
  }
  forEach(e, t) {
    const i = this.map.get(e);
    i && i.forEach(t);
  }
}
const Jk = new class {
  constructor() {
    this._tabFocus = !1, this._onDidChangeTabFocus = new q(), this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
  }
  getTabFocusMode() {
    return this._tabFocus;
  }
  setTabFocusMode(n) {
    this._tabFocus !== n && (this._tabFocus = n, this._onDidChangeTabFocus.fire(this._tabFocus));
  }
}(), i3 = Object.hasOwnProperty;
class ele {
  constructor() {
    this._values = [];
  }
  _read(e) {
    return this._values[e];
  }
  get(e) {
    return this._values[e];
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class tle {
  constructor() {
    this._values = [];
  }
  _read(e) {
    return this._values[e];
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class Au {
  static readOptions(e) {
    const t = e, i = new tle();
    for (const r of np) {
      const o = r.name === "_never_" ? void 0 : t[r.name];
      i._write(r.id, o);
    }
    return i;
  }
  static validateOptions(e) {
    const t = new hne();
    for (const i of np)
      t._write(i.id, i.validate(e._read(i.id)));
    return t;
  }
  static computeOptions(e, t) {
    const i = new ele();
    for (const r of np)
      i._write(r.id, r.compute(t, i, e._read(r.id)));
    return i;
  }
  static _deepEquals(e, t) {
    if (typeof e != "object" || typeof t != "object")
      return e === t;
    if (Array.isArray(e) || Array.isArray(t))
      return Array.isArray(e) && Array.isArray(t) ? Yu(e, t) : !1;
    for (let i in e)
      if (!Au._deepEquals(e[i], t[i]))
        return !1;
    return !0;
  }
  static checkEquals(e, t) {
    const i = [];
    let r = !1;
    for (const o of np) {
      const s = !Au._deepEquals(e._read(o.id), t._read(o.id));
      i[o.id] = s, s && (r = !0);
    }
    return r ? new kG(i) : null;
  }
}
function ile(n) {
  const e = n.wordWrap;
  e === !0 ? n.wordWrap = "on" : e === !1 && (n.wordWrap = "off");
  const t = n.lineNumbers;
  t === !0 ? n.lineNumbers = "on" : t === !1 && (n.lineNumbers = "off"), n.autoClosingBrackets === !1 && (n.autoClosingBrackets = "never", n.autoClosingQuotes = "never", n.autoSurround = "never"), n.cursorBlinking === "visible" && (n.cursorBlinking = "solid");
  const o = n.renderWhitespace;
  o === !0 ? n.renderWhitespace = "boundary" : o === !1 && (n.renderWhitespace = "none");
  const s = n.renderLineHighlight;
  s === !0 ? n.renderLineHighlight = "line" : s === !1 && (n.renderLineHighlight = "none");
  const a = n.acceptSuggestionOnEnter;
  a === !0 ? n.acceptSuggestionOnEnter = "on" : a === !1 && (n.acceptSuggestionOnEnter = "off");
  const l = n.tabCompletion;
  l === !1 ? n.tabCompletion = "off" : l === !0 && (n.tabCompletion = "onlySnippets");
  const u = n.suggest;
  if (u && typeof u.filteredTypes == "object" && u.filteredTypes) {
    const p = {};
    p.method = "showMethods", p.function = "showFunctions", p.constructor = "showConstructors", p.deprecated = "showDeprecated", p.field = "showFields", p.variable = "showVariables", p.class = "showClasses", p.struct = "showStructs", p.interface = "showInterfaces", p.module = "showModules", p.property = "showProperties", p.event = "showEvents", p.operator = "showOperators", p.unit = "showUnits", p.value = "showValues", p.constant = "showConstants", p.enum = "showEnums", p.enumMember = "showEnumMembers", p.keyword = "showKeywords", p.text = "showWords", p.color = "showColors", p.file = "showFiles", p.reference = "showReferences", p.folder = "showFolders", p.typeParameter = "showTypeParameters", p.snippet = "showSnippets", Qae(p, (g) => {
      const _ = u.filteredTypes[g.key];
      _ === !1 && (u[g.value] = _);
    });
  }
  const c = n.hover;
  c === !0 ? n.hover = {
    enabled: !0
  } : c === !1 && (n.hover = {
    enabled: !1
  });
  const h = n.parameterHints;
  h === !0 ? n.parameterHints = {
    enabled: !0
  } : h === !1 && (n.parameterHints = {
    enabled: !1
  });
  const d = n.autoIndent;
  d === !0 ? n.autoIndent = "full" : d === !1 && (n.autoIndent = "advanced");
  const f = n.matchBrackets;
  f === !0 ? n.matchBrackets = "always" : f === !1 && (n.matchBrackets = "never");
}
function e2(n) {
  const e = Xh(n);
  return ile(e), e;
}
class Tb extends Ce {
  constructor(e, t) {
    super(), this._onDidChange = this._register(new q()), this.onDidChange = this._onDidChange.event, this._onDidChangeFast = this._register(new q()), this.onDidChangeFast = this._onDidChangeFast.event, this.isSimpleWidget = e, this._isDominatedByLongLines = !1, this._computeOptionsMemory = new WG(), this._viewLineCount = 1, this._lineNumbersDigitCount = 1, this._rawOptions = e2(t), this._readOptions = Au.readOptions(this._rawOptions), this._validatedOptions = Au.validateOptions(this._readOptions), this._register(vb.onDidChangeZoomLevel((i) => this._recomputeOptions())), this._register(Jk.onDidChangeTabFocus((i) => this._recomputeOptions()));
  }
  observeReferenceElement(e) {
  }
  updatePixelRatio() {
  }
  _recomputeOptions() {
    const e = this.options, t = this._computeInternalOptions();
    if (!e)
      this.options = t;
    else {
      const i = Au.checkEquals(e, t);
      if (i === null)
        return;
      this.options = t, this._onDidChangeFast.fire(i), this._onDidChange.fire(i);
    }
  }
  getRawOptions() {
    return this._rawOptions;
  }
  _computeInternalOptions() {
    const e = this._getEnvConfiguration(), t = Zp.createFromValidatedSettings(this._validatedOptions, e.zoomLevel, e.pixelRatio, this.isSimpleWidget), i = {
      memory: this._computeOptionsMemory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight,
      fontInfo: this.readConfiguration(t),
      extraEditorClassName: e.extraEditorClassName,
      isDominatedByLongLines: this._isDominatedByLongLines,
      viewLineCount: this._viewLineCount,
      lineNumbersDigitCount: this._lineNumbersDigitCount,
      emptySelectionClipboard: e.emptySelectionClipboard,
      pixelRatio: e.pixelRatio,
      tabFocusMode: Jk.getTabFocusMode(),
      accessibilitySupport: e.accessibilitySupport
    };
    return Au.computeOptions(this._validatedOptions, i);
  }
  static _subsetEquals(e, t) {
    for (const i in t)
      if (i3.call(t, i)) {
        const r = t[i], o = e[i];
        if (o === r)
          continue;
        if (Array.isArray(o) && Array.isArray(r)) {
          if (!Yu(o, r))
            return !1;
          continue;
        }
        if (o && typeof o == "object" && r && typeof r == "object") {
          if (!this._subsetEquals(o, r))
            return !1;
          continue;
        }
        return !1;
      }
    return !0;
  }
  updateOptions(e) {
    if (typeof e > "u")
      return;
    const t = e2(e);
    Tb._subsetEquals(this._rawOptions, t) || (this._rawOptions = vh(this._rawOptions, t || {}), this._readOptions = Au.readOptions(this._rawOptions), this._validatedOptions = Au.validateOptions(this._readOptions), this._recomputeOptions());
  }
  setIsDominatedByLongLines(e) {
    this._isDominatedByLongLines = e, this._recomputeOptions();
  }
  setMaxLineNumber(e) {
    const t = Tb._digitCount(e);
    this._lineNumbersDigitCount !== t && (this._lineNumbersDigitCount = t, this._recomputeOptions());
  }
  setViewLineCount(e) {
    this._viewLineCount !== e && (this._viewLineCount = e, this._recomputeOptions());
  }
  static _digitCount(e) {
    let t = 0;
    for (; e; )
      e = Math.floor(e / 10), t++;
    return t || 1;
  }
}
const nle = Object.freeze({
  id: "editor",
  order: 5,
  type: "object",
  title: b("editorConfigurationTitle", "Editor"),
  scope: 5
}), rle = Jn.as(Ag.Configuration), Ob = Object.assign(Object.assign({}, nle), { properties: {
  "editor.tabSize": {
    type: "number",
    default: bo.tabSize,
    minimum: 1,
    markdownDescription: b("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
  },
  // 'editor.indentSize': {
  // 	'anyOf': [
  // 		{
  // 			type: 'string',
  // 			enum: ['tabSize']
  // 		},
  // 		{
  // 			type: 'number',
  // 			minimum: 1
  // 		}
  // 	],
  // 	default: 'tabSize',
  // 	markdownDescription: nls.localize('indentSize', "The number of spaces used for indentation or 'tabSize' to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
  // },
  "editor.insertSpaces": {
    type: "boolean",
    default: bo.insertSpaces,
    markdownDescription: b("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.")
  },
  "editor.detectIndentation": {
    type: "boolean",
    default: bo.detectIndentation,
    markdownDescription: b("detectIndentation", "Controls whether `#editor.tabSize#` and `#editor.insertSpaces#` will be automatically detected when a file is opened based on the file contents.")
  },
  "editor.trimAutoWhitespace": {
    type: "boolean",
    default: bo.trimAutoWhitespace,
    description: b("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
  },
  "editor.largeFileOptimizations": {
    type: "boolean",
    default: bo.largeFileOptimizations,
    description: b("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
  },
  "editor.wordBasedSuggestions": {
    type: "boolean",
    default: !0,
    description: b("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document.")
  },
  "editor.wordBasedSuggestionsMode": {
    enum: ["currentDocument", "matchingDocuments", "allDocuments"],
    default: "matchingDocuments",
    enumDescriptions: [
      b("wordBasedSuggestionsMode.currentDocument", "Only suggest words from the active document."),
      b("wordBasedSuggestionsMode.matchingDocuments", "Suggest words from all open documents of the same language."),
      b("wordBasedSuggestionsMode.allDocuments", "Suggest words from all open documents.")
    ],
    description: b("wordBasedSuggestionsMode", "Controls from which documents word based completions are computed.")
  },
  "editor.semanticHighlighting.enabled": {
    enum: [!0, !1, "configuredByTheme"],
    enumDescriptions: [
      b("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
      b("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
      b("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
    ],
    default: "configuredByTheme",
    description: b("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
  },
  "editor.stablePeek": {
    type: "boolean",
    default: !1,
    markdownDescription: b("stablePeek", "Keep peek editors open even when double clicking their content or when hitting `Escape`.")
  },
  "editor.maxTokenizationLineLength": {
    type: "integer",
    default: 2e4,
    description: b("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
  },
  "diffEditor.maxComputationTime": {
    type: "number",
    default: 5e3,
    description: b("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
  },
  "diffEditor.renderSideBySide": {
    type: "boolean",
    default: !0,
    description: b("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
  },
  "diffEditor.ignoreTrimWhitespace": {
    type: "boolean",
    default: !0,
    description: b("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
  },
  "diffEditor.renderIndicators": {
    type: "boolean",
    default: !0,
    description: b("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
  },
  "diffEditor.codeLens": {
    type: "boolean",
    default: !1,
    description: b("codeLens", "Controls whether the editor shows CodeLens.")
  },
  "diffEditor.wordWrap": {
    type: "string",
    enum: ["off", "on", "inherit"],
    default: "inherit",
    markdownEnumDescriptions: [
      b("wordWrap.off", "Lines will never wrap."),
      b("wordWrap.on", "Lines will wrap at the viewport width."),
      b("wordWrap.inherit", "Lines will wrap according to the `#editor.wordWrap#` setting.")
    ]
  }
} });
function ole(n) {
  return typeof n.type < "u" || typeof n.anyOf < "u";
}
for (const n of np) {
  const e = n.schema;
  if (typeof e < "u")
    if (ole(e))
      Ob.properties[`editor.${n.name}`] = e;
    else
      for (let t in e)
        i3.call(e, t) && (Ob.properties[t] = e[t]);
}
let Cy = null;
function n3() {
  return Cy === null && (Cy = /* @__PURE__ */ Object.create(null), Object.keys(Ob.properties).forEach((n) => {
    Cy[n] = !0;
  })), Cy;
}
function sle(n) {
  return n3()[`editor.${n}`] || !1;
}
function ale(n) {
  return n3()[`diffEditor.${n}`] || !1;
}
rle.registerConfiguration(Ob);
class UT {
  static insert(e, t) {
    return {
      range: new G(e.lineNumber, e.column, e.lineNumber, e.column),
      text: t,
      forceMoveMarkers: !0
    };
  }
  static delete(e) {
    return {
      range: e,
      text: null
    };
  }
  static replace(e, t) {
    return {
      range: e,
      text: t
    };
  }
  static replaceMove(e, t) {
    return {
      range: e,
      text: t,
      forceMoveMarkers: !0
    };
  }
}
const _r = Vt("configurationService");
function r3(n, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (let i in n)
    aI(t, i, n[i], e);
  return t;
}
function aI(n, e, t, i) {
  const r = e.split("."), o = r.pop();
  let s = n;
  for (let a = 0; a < r.length; a++) {
    let l = r[a], u = s[l];
    switch (typeof u) {
      case "undefined":
        u = s[l] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        break;
      default:
        i(`Ignoring ${e} as ${r.slice(0, a + 1).join(".")} is ${JSON.stringify(u)}`);
        return;
    }
    s = u;
  }
  if (typeof s == "object" && s !== null)
    try {
      s[o] = t;
    } catch {
      i(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(s)}`);
    }
  else
    i(`Ignoring ${e} as ${r.join(".")} is ${JSON.stringify(s)}`);
}
function lle(n, e) {
  const t = e.split(".");
  o3(n, t);
}
function o3(n, e) {
  const t = e.shift();
  if (e.length === 0) {
    delete n[t];
    return;
  }
  if (Object.keys(n).indexOf(t) !== -1) {
    const i = n[t];
    typeof i == "object" && !Array.isArray(i) && (o3(i, e), Object.keys(i).length === 0 && delete n[t]);
  }
}
function ule(n, e, t) {
  function i(s, a) {
    let l = s;
    for (const u of a) {
      if (typeof l != "object" || l === null)
        return;
      l = l[u];
    }
    return l;
  }
  const r = e.split("."), o = i(n, r);
  return typeof o > "u" ? t : o;
}
function cle() {
  const n = Jn.as(Ag.Configuration).getConfigurationProperties();
  return Object.keys(n);
}
function hle() {
  const n = /* @__PURE__ */ Object.create(null), e = Jn.as(Ag.Configuration).getConfigurationProperties();
  for (let t in e) {
    let i = e[t].default;
    aI(n, t, i, (r) => console.error(`Conflict in default settings: ${r}`));
  }
  return n;
}
class ps {
  constructor(e = {}, t = [], i = []) {
    this._contents = e, this._keys = t, this._overrides = i, this.isFrozen = !1;
  }
  get contents() {
    return this.checkAndFreeze(this._contents);
  }
  get overrides() {
    return this.checkAndFreeze(this._overrides);
  }
  get keys() {
    return this.checkAndFreeze(this._keys);
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(e) {
    return e ? ule(this.contents, e) : this.contents;
  }
  override(e) {
    const t = this.getContentsForOverrideIdentifer(e);
    if (!t || typeof t != "object" || !Object.keys(t).length)
      return this;
    let i = {};
    for (const r of $5([...Object.keys(this.contents), ...Object.keys(t)])) {
      let o = this.contents[r], s = t[r];
      s && (typeof o == "object" && typeof s == "object" ? (o = Xh(o), this.mergeContents(o, s)) : o = s), i[r] = o;
    }
    return new ps(i, this.keys, this.overrides);
  }
  merge(...e) {
    const t = Xh(this.contents), i = Xh(this.overrides), r = [...this.keys];
    for (const o of e) {
      this.mergeContents(t, o.contents);
      for (const s of o.overrides) {
        const [a] = i.filter((l) => Yu(l.identifiers, s.identifiers));
        a ? this.mergeContents(a.contents, s.contents) : i.push(Xh(s));
      }
      for (const s of o.keys)
        r.indexOf(s) === -1 && r.push(s);
    }
    return new ps(t, r, i);
  }
  freeze() {
    return this.isFrozen = !0, this;
  }
  mergeContents(e, t) {
    for (const i of Object.keys(t)) {
      if (i in e && Uo(e[i]) && Uo(t[i])) {
        this.mergeContents(e[i], t[i]);
        continue;
      }
      e[i] = Xh(t[i]);
    }
  }
  checkAndFreeze(e) {
    return this.isFrozen && !Object.isFrozen(e) ? Foe(e) : e;
  }
  getContentsForOverrideIdentifer(e) {
    for (const t of this.overrides)
      if (t.identifiers.indexOf(e) !== -1)
        return t.contents;
    return null;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  // Update methods
  setValue(e, t) {
    this.addKey(e), aI(this.contents, e, t, (i) => {
      throw new Error(i);
    });
  }
  removeValue(e) {
    this.removeKey(e) && lle(this.contents, e);
  }
  addKey(e) {
    let t = this.keys.length;
    for (let i = 0; i < t; i++)
      e.indexOf(this.keys[i]) === 0 && (t = i);
    this.keys.splice(t, 1, e);
  }
  removeKey(e) {
    let t = this.keys.indexOf(e);
    return t !== -1 ? (this.keys.splice(t, 1), !0) : !1;
  }
}
class dle extends ps {
  constructor() {
    const e = hle(), t = cle(), i = [];
    for (const r of Object.keys(e))
      sI.test(r) && i.push({
        identifiers: [qae(r).trim()],
        keys: Object.keys(e[r]),
        contents: r3(e[r], (o) => console.error(`Conflict in default settings file: ${o}`))
      });
    super(e, t, i);
  }
}
let s3 = class a3 {
  constructor(e, t, i = new ps(), r = new ps(), o = new So(), s = new ps(), a = new So(), l = !0) {
    this._defaultConfiguration = e, this._localUserConfiguration = t, this._remoteUserConfiguration = i, this._workspaceConfiguration = r, this._folderConfigurations = o, this._memoryConfiguration = s, this._memoryConfigurationByResource = a, this._freeze = l, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations = new So(), this._userConfiguration = null;
  }
  getValue(e, t, i) {
    return this.getConsolidateConfigurationModel(t, i).getValue(e);
  }
  updateValue(e, t, i = {}) {
    let r;
    i.resource ? (r = this._memoryConfigurationByResource.get(i.resource), r || (r = new ps(), this._memoryConfigurationByResource.set(i.resource, r))) : r = this._memoryConfiguration, t === void 0 ? r.removeValue(e) : r.setValue(e, t), i.resource || (this._workspaceConsolidatedConfiguration = null);
  }
  get userConfiguration() {
    return this._userConfiguration || (this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration), this._freeze && this._userConfiguration.freeze()), this._userConfiguration;
  }
  getConsolidateConfigurationModel(e, t) {
    let i = this.getConsolidatedConfigurationModelForResource(e, t);
    return e.overrideIdentifier ? i.override(e.overrideIdentifier) : i;
  }
  getConsolidatedConfigurationModelForResource({ resource: e }, t) {
    let i = this.getWorkspaceConsolidatedConfiguration();
    if (t && e) {
      const r = t.getFolder(e);
      r && (i = this.getFolderConsolidatedConfiguration(r.uri) || i);
      const o = this._memoryConfigurationByResource.get(e);
      o && (i = i.merge(o));
    }
    return i;
  }
  getWorkspaceConsolidatedConfiguration() {
    return this._workspaceConsolidatedConfiguration || (this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration), this._freeze && (this._workspaceConfiguration = this._workspaceConfiguration.freeze())), this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(e) {
    let t = this._foldersConsolidatedConfigurations.get(e);
    if (!t) {
      const i = this.getWorkspaceConsolidatedConfiguration(), r = this._folderConfigurations.get(e);
      r ? (t = i.merge(r), this._freeze && (t = t.freeze()), this._foldersConsolidatedConfigurations.set(e, t)) : t = i;
    }
    return t;
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      user: {
        contents: this.userConfiguration.contents,
        overrides: this.userConfiguration.overrides,
        keys: this.userConfiguration.keys
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((e, t) => {
        const { contents: i, overrides: r, keys: o } = this._folderConfigurations.get(t);
        return e.push([t, { contents: i, overrides: r, keys: o }]), e;
      }, [])
    };
  }
  static parse(e) {
    const t = this.parseConfigurationModel(e.defaults), i = this.parseConfigurationModel(e.user), r = this.parseConfigurationModel(e.workspace), o = e.folders.reduce((s, a) => (s.set(ft.revive(a[0]), this.parseConfigurationModel(a[1])), s), new So());
    return new a3(t, i, new ps(), r, o, new ps(), new So(), !1);
  }
  static parseConfigurationModel(e) {
    return new ps(e.contents, e.keys, e.overrides).freeze();
  }
};
class fle {
  constructor(e, t, i, r) {
    this.change = e, this.previous = t, this.currentConfiguraiton = i, this.currentWorkspace = r, this._previousConfiguration = void 0;
    const o = /* @__PURE__ */ new Set();
    e.keys.forEach((a) => o.add(a)), e.overrides.forEach(([, a]) => a.forEach((l) => o.add(l))), this.affectedKeys = [...o.values()];
    const s = new ps();
    this.affectedKeys.forEach((a) => s.setValue(a, {})), this.affectedKeysTree = s.contents;
  }
  get previousConfiguration() {
    return !this._previousConfiguration && this.previous && (this._previousConfiguration = s3.parse(this.previous.data)), this._previousConfiguration;
  }
  affectsConfiguration(e, t) {
    var i;
    if (this.doesAffectedKeysTreeContains(this.affectedKeysTree, e)) {
      if (t) {
        const r = this.previousConfiguration ? this.previousConfiguration.getValue(e, t, (i = this.previous) === null || i === void 0 ? void 0 : i.workspace) : void 0, o = this.currentConfiguraiton.getValue(e, t, this.currentWorkspace);
        return !qu(r, o);
      }
      return !0;
    }
    return !1;
  }
  doesAffectedKeysTreeContains(e, t) {
    let i = r3({ [t]: !0 }, () => {
    }), r;
    for (; typeof i == "object" && (r = Object.keys(i)[0]); ) {
      if (e = e[r], !e)
        return !1;
      i = i[r];
    }
    return !0;
  }
}
class ple extends Ce {
  constructor(e, t, i, r, o) {
    super(), this._contextKeyService = e, this._commandService = t, this._telemetryService = i, this._notificationService = r, this._logService = o, this._onDidUpdateKeybindings = this._register(new q()), this._currentChord = null, this._currentChordChecker = new G_(), this._currentChordStatusMessage = null, this._currentSingleModifier = null, this._currentSingleModifierClearTimeout = new oc(), this._logging = !1;
  }
  get onDidUpdateKeybindings() {
    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : We.None;
  }
  dispose() {
    super.dispose();
  }
  _log(e) {
    this._logging && this._logService.info(`[KeybindingService]: ${e}`);
  }
  getKeybindings() {
    return this._getResolver().getKeybindings();
  }
  lookupKeybinding(e, t) {
    const i = this._getResolver().lookupPrimaryKeybinding(e, t);
    if (i)
      return i.resolvedKeybinding;
  }
  dispatchEvent(e, t) {
    return this._dispatch(e, t);
  }
  softDispatch(e, t) {
    const i = this.resolveKeyboardEvent(e);
    if (i.isChord())
      return console.warn("Unexpected keyboard event mapped to a chord"), null;
    const [r] = i.getDispatchParts();
    if (r === null)
      return null;
    const o = this._contextKeyService.getContext(t), s = this._currentChord ? this._currentChord.keypress : null;
    return this._getResolver().resolve(o, s, r);
  }
  _enterChordMode(e, t) {
    this._currentChord = {
      keypress: e,
      label: t
    }, this._currentChordStatusMessage = this._notificationService.status(b("first.chord", "({0}) was pressed. Waiting for second key of chord...", t));
    const i = Date.now();
    this._currentChordChecker.cancelAndSet(() => {
      if (!this._documentHasFocus()) {
        this._leaveChordMode();
        return;
      }
      Date.now() - i > 5e3 && this._leaveChordMode();
    }, 500);
  }
  _leaveChordMode() {
    this._currentChordStatusMessage && (this._currentChordStatusMessage.dispose(), this._currentChordStatusMessage = null), this._currentChordChecker.cancel(), this._currentChord = null;
  }
  _dispatch(e, t) {
    return this._doDispatch(
      this.resolveKeyboardEvent(e),
      t,
      /*isSingleModiferChord*/
      !1
    );
  }
  _singleModifierDispatch(e, t) {
    const i = this.resolveKeyboardEvent(e), [r] = i.getSingleModifierDispatchParts();
    return r !== null && this._currentSingleModifier === null ? (this._log(`+ Storing single modifier for possible chord ${r}.`), this._currentSingleModifier = r, this._currentSingleModifierClearTimeout.cancelAndSet(() => {
      this._log("+ Clearing single modifier due to 300ms elapsed."), this._currentSingleModifier = null;
    }, 300), !1) : r !== null && r === this._currentSingleModifier ? (this._log(`/ Dispatching single modifier chord ${r} ${r}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, this._doDispatch(
      i,
      t,
      /*isSingleModiferChord*/
      !0
    )) : (this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1);
  }
  _doDispatch(e, t, i = !1) {
    let r = !1;
    if (e.isChord())
      return console.warn("Unexpected keyboard event mapped to a chord"), !1;
    let o = null, s = null;
    if (i) {
      const [c] = e.getSingleModifierDispatchParts();
      o = c, s = c;
    } else
      [o] = e.getDispatchParts(), s = this._currentChord ? this._currentChord.keypress : null;
    if (o === null)
      return this._log("\\ Keyboard event cannot be dispatched in keydown phase."), r;
    const a = this._contextKeyService.getContext(t), l = e.getLabel(), u = this._getResolver().resolve(a, s, o);
    return this._logService.trace("KeybindingService#dispatch", l, u == null ? void 0 : u.commandId), u && u.enterChord ? (r = !0, this._enterChordMode(o, l), r) : (this._currentChord && (!u || !u.commandId) && (this._notificationService.status(b("missing.chord", "The key combination ({0}, {1}) is not a command.", this._currentChord.label, l), {
      hideAfter: 10 * 1e3
      /* 10s */
    }), r = !0), this._leaveChordMode(), u && u.commandId && (u.bubble || (r = !0), typeof u.commandArgs > "u" ? this._commandService.executeCommand(u.commandId).then(void 0, (c) => this._notificationService.warn(c)) : this._commandService.executeCommand(u.commandId, u.commandArgs).then(void 0, (c) => this._notificationService.warn(c)), this._telemetryService.publicLog2("workbenchActionExecuted", { id: u.commandId, from: "keybinding" })), r);
  }
  mightProducePrintableCharacter(e) {
    return e.ctrlKey || e.metaKey ? !1 : e.keyCode >= 31 && e.keyCode <= 56 || e.keyCode >= 21 && e.keyCode <= 30;
  }
}
class Tp {
  constructor(e, t, i) {
    this._log = i, this._defaultKeybindings = e, this._defaultBoundCommands = /* @__PURE__ */ new Map();
    for (let r = 0, o = e.length; r < o; r++) {
      const s = e[r].command;
      s && this._defaultBoundCommands.set(s, !0);
    }
    this._map = /* @__PURE__ */ new Map(), this._lookupMap = /* @__PURE__ */ new Map(), this._keybindings = Tp.combine(e, t);
    for (let r = 0, o = this._keybindings.length; r < o; r++) {
      let s = this._keybindings[r];
      s.keypressParts.length !== 0 && (s.when && s.when.type === 0 || this._addKeyPress(s.keypressParts[0], s));
    }
  }
  static _isTargetedForRemoval(e, t, i, r, o) {
    return !(e.command !== r || t && e.keypressParts[0] !== t || i && e.keypressParts[1] !== i || o && (!e.when || !o.equals(e.when)));
  }
  /**
   * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.
   */
  static combine(e, t) {
    e = e.slice(0);
    let i = [];
    for (const r of t) {
      if (!r.command || r.command.length === 0 || r.command.charAt(0) !== "-") {
        i.push(r);
        continue;
      }
      const o = r.command.substr(1), s = r.keypressParts[0], a = r.keypressParts[1], l = r.when;
      for (let u = e.length - 1; u >= 0; u--)
        this._isTargetedForRemoval(e[u], s, a, o, l) && e.splice(u, 1);
    }
    return e.concat(i);
  }
  _addKeyPress(e, t) {
    const i = this._map.get(e);
    if (typeof i > "u") {
      this._map.set(e, [t]), this._addToLookupMap(t);
      return;
    }
    for (let r = i.length - 1; r >= 0; r--) {
      let o = i[r];
      if (o.command === t.command)
        continue;
      const s = o.keypressParts.length > 1, a = t.keypressParts.length > 1;
      s && a && o.keypressParts[1] !== t.keypressParts[1] || Tp.whenIsEntirelyIncluded(o.when, t.when) && this._removeFromLookupMap(o);
    }
    i.push(t), this._addToLookupMap(t);
  }
  _addToLookupMap(e) {
    if (!e.command)
      return;
    let t = this._lookupMap.get(e.command);
    typeof t > "u" ? (t = [e], this._lookupMap.set(e.command, t)) : t.push(e);
  }
  _removeFromLookupMap(e) {
    if (!e.command)
      return;
    let t = this._lookupMap.get(e.command);
    if (!(typeof t > "u")) {
      for (let i = 0, r = t.length; i < r; i++)
        if (t[i] === e) {
          t.splice(i, 1);
          return;
        }
    }
  }
  /**
   * Returns true if it is provable `a` implies `b`.
   */
  static whenIsEntirelyIncluded(e, t) {
    return t ? e ? this._implies(e, t) : !1 : !0;
  }
  /**
   * Returns true if it is provable `p` implies `q`.
   */
  static _implies(e, t) {
    const i = e.negate(), r = (s) => s.type === 9 ? s.expr : [s];
    let o = r(i).concat(r(t));
    for (let s = 0; s < o.length; s++) {
      const l = o[s].negate();
      for (let u = s + 1; u < o.length; u++) {
        const c = o[u];
        if (l.equals(c))
          return !0;
      }
    }
    return !1;
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupPrimaryKeybinding(e, t) {
    let i = this._lookupMap.get(e);
    if (typeof i > "u" || i.length === 0)
      return null;
    const r = t && Array.from(i).reverse().find((o) => t.contextMatchesRules(o.when));
    return r ?? i[i.length - 1];
  }
  resolve(e, t, i) {
    this._log(`| Resolving ${i}${t ? ` chorded from ${t}` : ""}`);
    let r = null;
    if (t !== null) {
      const s = this._map.get(t);
      if (typeof s > "u")
        return this._log("\\ No keybinding entries."), null;
      r = [];
      for (let a = 0, l = s.length; a < l; a++) {
        let u = s[a];
        u.keypressParts[1] === i && r.push(u);
      }
    } else {
      const s = this._map.get(i);
      if (typeof s > "u")
        return this._log("\\ No keybinding entries."), null;
      r = s;
    }
    let o = this._findCommand(e, r);
    return o ? t === null && o.keypressParts.length > 1 && o.keypressParts[1] !== null ? (this._log(`\\ From ${r.length} keybinding entries, matched chord, when: ${t2(o.when)}, source: ${i2(o)}.`), {
      enterChord: !0,
      leaveChord: !1,
      commandId: null,
      commandArgs: null,
      bubble: !1
    }) : (this._log(`\\ From ${r.length} keybinding entries, matched ${o.command}, when: ${t2(o.when)}, source: ${i2(o)}.`), {
      enterChord: !1,
      leaveChord: o.keypressParts.length > 1,
      commandId: o.command,
      commandArgs: o.commandArgs,
      bubble: o.bubble
    }) : (this._log(`\\ From ${r.length} keybinding entries, no when clauses matched the context.`), null);
  }
  _findCommand(e, t) {
    for (let i = t.length - 1; i >= 0; i--) {
      let r = t[i];
      if (Tp.contextMatchesRules(e, r.when))
        return r;
    }
    return null;
  }
  static contextMatchesRules(e, t) {
    return t ? t.evaluate(e) : !0;
  }
}
function t2(n) {
  return n ? `${n.serialize()}` : "no when condition";
}
function i2(n) {
  return n.extensionId ? n.isBuiltinExtension ? `built-in extension ${n.extensionId}` : `user extension ${n.extensionId}` : n.isDefault ? "built-in" : "user";
}
class xb {
  constructor() {
    this._coreKeybindings = [], this._extensionKeybindings = [], this._cachedMergedKeybindings = null;
  }
  /**
   * Take current platform into account and reduce to primary & secondary.
   */
  static bindToCurrentPlatform(e) {
    if (ja === 1) {
      if (e && e.win)
        return e.win;
    } else if (ja === 2) {
      if (e && e.mac)
        return e.mac;
    } else if (e && e.linux)
      return e.linux;
    return e;
  }
  registerKeybindingRule(e) {
    const t = xb.bindToCurrentPlatform(e);
    if (t && t.primary) {
      const i = wR(t.primary, ja);
      i && this._registerDefaultKeybinding(i, e.id, e.args, e.weight, 0, e.when);
    }
    if (t && Array.isArray(t.secondary))
      for (let i = 0, r = t.secondary.length; i < r; i++) {
        const o = t.secondary[i], s = wR(o, ja);
        s && this._registerDefaultKeybinding(s, e.id, e.args, e.weight, -i - 1, e.when);
      }
  }
  registerCommandAndKeybindingRule(e) {
    this.registerKeybindingRule(e), Qn.registerCommand(e);
  }
  static _mightProduceChar(e) {
    return e >= 21 && e <= 30 || e >= 31 && e <= 56 ? !0 : e === 80 || e === 81 || e === 82 || e === 83 || e === 84 || e === 85 || e === 86 || e === 110 || e === 111 || e === 87 || e === 88 || e === 89 || e === 90 || e === 91 || e === 92;
  }
  _assertNoCtrlAlt(e, t) {
    e.ctrlKey && e.altKey && !e.metaKey && xb._mightProduceChar(e.keyCode) && console.warn("Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ", e, " for ", t);
  }
  _registerDefaultKeybinding(e, t, i, r, o, s) {
    ja === 1 && this._assertNoCtrlAlt(e.parts[0], t), this._coreKeybindings.push({
      keybinding: e,
      command: t,
      commandArgs: i,
      when: s,
      weight1: r,
      weight2: o,
      extensionId: null,
      isBuiltinExtension: !1
    }), this._cachedMergedKeybindings = null;
  }
  getDefaultKeybindings() {
    return this._cachedMergedKeybindings || (this._cachedMergedKeybindings = [].concat(this._coreKeybindings).concat(this._extensionKeybindings), this._cachedMergedKeybindings.sort(mle)), this._cachedMergedKeybindings.slice(0);
  }
}
const fE = new xb(), gle = {
  EditorModes: "platform.keybindingsRegistry"
};
Jn.add(gle.EditorModes, fE);
function mle(n, e) {
  return n.weight1 !== e.weight1 ? n.weight1 - e.weight1 : n.command < e.command ? -1 : n.command > e.command ? 1 : n.weight2 - e.weight2;
}
class n2 {
  constructor(e, t, i, r, o, s, a) {
    this.resolvedKeybinding = e, this.keypressParts = e ? r2(e.getDispatchParts()) : [], e && this.keypressParts.length === 0 && (this.keypressParts = r2(e.getSingleModifierDispatchParts())), this.bubble = t ? t.charCodeAt(0) === 94 : !1, this.command = this.bubble ? t.substr(1) : t, this.commandArgs = i, this.when = r, this.isDefault = o, this.extensionId = s, this.isBuiltinExtension = a;
  }
}
function r2(n) {
  let e = [];
  for (let t = 0, i = n.length; t < i; t++) {
    const r = n[t];
    if (!r)
      return e;
    e.push(r);
  }
  return e;
}
class l3 {
  constructor(e, t, i = t) {
    this.modifierLabels = [null], this.modifierLabels[
      2
      /* Macintosh */
    ] = e, this.modifierLabels[
      1
      /* Windows */
    ] = t, this.modifierLabels[
      3
      /* Linux */
    ] = i;
  }
  toLabel(e, t, i) {
    if (t.length === 0)
      return null;
    const r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = i(a);
      if (l === null)
        return null;
      r[o] = _le(a, l, this.modifierLabels[e]);
    }
    return r.join(" ");
  }
}
const u3 = new l3({
  ctrlKey: "",
  shiftKey: "",
  altKey: "",
  metaKey: "",
  separator: ""
}, {
  ctrlKey: b({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: b({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: b({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: b({ key: "windowsKey", comment: ["This is the short form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: b({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: b({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: b({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: b({ key: "superKey", comment: ["This is the short form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), vle = new l3({
  ctrlKey: b({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: b({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: b({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: b({ key: "cmdKey.long", comment: ["This is the long form for the Command key on the keyboard"] }, "Command"),
  separator: "+"
}, {
  ctrlKey: b({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: b({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: b({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: b({ key: "windowsKey.long", comment: ["This is the long form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: b({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: b({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: b({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: b({ key: "superKey.long", comment: ["This is the long form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
});
function _le(n, e, t) {
  if (e === null)
    return "";
  const i = [];
  return n.ctrlKey && i.push(t.ctrlKey), n.shiftKey && i.push(t.shiftKey), n.altKey && i.push(t.altKey), n.metaKey && i.push(t.metaKey), e !== "" && i.push(e), i.join(t.separator);
}
class Cle extends tre {
  constructor(e, t) {
    if (super(), t.length === 0)
      throw V_("parts");
    this._os = e, this._parts = t;
  }
  getLabel() {
    return u3.toLabel(this._os, this._parts, (e) => this._getLabel(e));
  }
  getAriaLabel() {
    return vle.toLabel(this._os, this._parts, (e) => this._getAriaLabel(e));
  }
  isChord() {
    return this._parts.length > 1;
  }
  getParts() {
    return this._parts.map((e) => this._getPart(e));
  }
  _getPart(e) {
    return new ere(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, this._getLabel(e), this._getAriaLabel(e));
  }
  getDispatchParts() {
    return this._parts.map((e) => this._getDispatchPart(e));
  }
  getSingleModifierDispatchParts() {
    return this._parts.map((e) => this._getSingleModifierDispatchPart(e));
  }
}
class Nb extends Cle {
  constructor(e, t) {
    super(t, e.parts);
  }
  _keyCodeToUILabel(e) {
    if (this._os === 2)
      switch (e) {
        case 15:
          return "";
        case 16:
          return "";
        case 17:
          return "";
        case 18:
          return "";
      }
    return Sp.toString(e);
  }
  _getLabel(e) {
    return e.isDuplicateModifierCase() ? "" : this._keyCodeToUILabel(e.keyCode);
  }
  _getAriaLabel(e) {
    return e.isDuplicateModifierCase() ? "" : Sp.toString(e.keyCode);
  }
  _getDispatchPart(e) {
    return Nb.getDispatchStr(e);
  }
  static getDispatchStr(e) {
    if (e.isModifierKey())
      return null;
    let t = "";
    return e.ctrlKey && (t += "ctrl+"), e.shiftKey && (t += "shift+"), e.altKey && (t += "alt+"), e.metaKey && (t += "meta+"), t += Sp.toString(e.keyCode), t;
  }
  _getSingleModifierDispatchPart(e) {
    return e.keyCode === 5 && !e.shiftKey && !e.altKey && !e.metaKey ? "ctrl" : e.keyCode === 4 && !e.ctrlKey && !e.altKey && !e.metaKey ? "shift" : e.keyCode === 6 && !e.ctrlKey && !e.shiftKey && !e.metaKey ? "alt" : e.keyCode === 57 && !e.ctrlKey && !e.shiftKey && !e.altKey ? "meta" : null;
  }
}
const al = Vt("notificationService");
class yle {
}
const wle = Vt("contextService");
class ble {
  constructor(e, t) {
    this.raw = t, this.uri = e.uri, this.index = e.index, this.name = e.name;
  }
  toJSON() {
    return { uri: this.uri, name: this.name, index: this.index };
  }
}
var o2;
(function(n) {
  n.noSelection = b("noSelection", "No selection"), n.singleSelectionRange = b("singleSelectionRange", "Line {0}, Column {1} ({2} selected)"), n.singleSelection = b("singleSelection", "Line {0}, Column {1}"), n.multiSelectionRange = b("multiSelectionRange", "{0} selections ({1} characters selected)"), n.multiSelection = b("multiSelection", "{0} selections"), n.emergencyConfOn = b("emergencyConfOn", "Now changing the setting `accessibilitySupport` to 'on'."), n.openingDocs = b("openingDocs", "Now opening the Editor Accessibility documentation page."), n.readonlyDiffEditor = b("readonlyDiffEditor", " in a read-only pane of a diff editor."), n.editableDiffEditor = b("editableDiffEditor", " in a pane of a diff editor."), n.readonlyEditor = b("readonlyEditor", " in a read-only code editor"), n.editableEditor = b("editableEditor", " in a code editor"), n.changeConfigToOnMac = b("changeConfigToOnMac", "To configure the editor to be optimized for usage with a Screen Reader press Command+E now."), n.changeConfigToOnWinLinux = b("changeConfigToOnWinLinux", "To configure the editor to be optimized for usage with a Screen Reader press Control+E now."), n.auto_on = b("auto_on", "The editor is configured to be optimized for usage with a Screen Reader."), n.auto_off = b("auto_off", "The editor is configured to never be optimized for usage with a Screen Reader, which is not the case at this time."), n.tabFocusModeOnMsg = b("tabFocusModeOnMsg", "Pressing Tab in the current editor will move focus to the next focusable element. Toggle this behavior by pressing {0}."), n.tabFocusModeOnMsgNoKb = b("tabFocusModeOnMsgNoKb", "Pressing Tab in the current editor will move focus to the next focusable element. The command {0} is currently not triggerable by a keybinding."), n.tabFocusModeOffMsg = b("tabFocusModeOffMsg", "Pressing Tab in the current editor will insert the tab character. Toggle this behavior by pressing {0}."), n.tabFocusModeOffMsgNoKb = b("tabFocusModeOffMsgNoKb", "Pressing Tab in the current editor will insert the tab character. The command {0} is currently not triggerable by a keybinding."), n.openDocMac = b("openDocMac", "Press Command+H now to open a browser window with more information related to editor accessibility."), n.openDocWinLinux = b("openDocWinLinux", "Press Control+H now to open a browser window with more information related to editor accessibility."), n.outroMsg = b("outroMsg", "You can dismiss this tooltip and return to the editor by pressing Escape or Shift+Escape."), n.showAccessibilityHelpAction = b("showAccessibilityHelpAction", "Show Accessibility Help");
})(o2 || (o2 = {}));
var s2;
(function(n) {
  n.inspectTokensAction = b("inspectTokens", "Developer: Inspect Tokens");
})(s2 || (s2 = {}));
var a2;
(function(n) {
  n.gotoLineActionLabel = b("gotoLineActionLabel", "Go to Line/Column...");
})(a2 || (a2 = {}));
var l2;
(function(n) {
  n.helpQuickAccessActionLabel = b("helpQuickAccess", "Show all Quick Access Providers");
})(l2 || (l2 = {}));
var u2;
(function(n) {
  n.quickCommandActionLabel = b("quickCommandActionLabel", "Command Palette"), n.quickCommandHelp = b("quickCommandActionHelp", "Show And Run Commands");
})(u2 || (u2 = {}));
var c2;
(function(n) {
  n.quickOutlineActionLabel = b("quickOutlineActionLabel", "Go to Symbol..."), n.quickOutlineByCategoryActionLabel = b("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
})(c2 || (c2 = {}));
var Ib;
(function(n) {
  n.editorViewAccessibleLabel = b("editorViewAccessibleLabel", "Editor content"), n.accessibilityHelpMessage = b("accessibilityHelpMessage", "Press Alt+F1 for Accessibility Options.");
})(Ib || (Ib = {}));
var h2;
(function(n) {
  n.toggleHighContrast = b("toggleHighContrast", "Toggle High Contrast Theme");
})(h2 || (h2 = {}));
var zT;
(function(n) {
  n.bulkEditServiceSummary = b("bulkEditServiceSummary", "Made {0} edits in {1} files");
})(zT || (zT = {}));
var c3 = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, h3 = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, d3 = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class Sle {
  constructor(e) {
    this.disposed = !1, this.model = e, this._onWillDispose = new q();
  }
  get textEditorModel() {
    return this.model;
  }
  dispose() {
    this.disposed = !0, this._onWillDispose.fire();
  }
}
function Ele(n, e, t) {
  return uh(n) ? e(n) : t(n);
}
let jT = class {
  constructor(e) {
    this.modelService = e;
  }
  setEditor(e) {
    this.editor = e;
  }
  createModelReference(e) {
    let t = null;
    return this.editor && (t = Ele(this.editor, (i) => this.findModel(i, e), (i) => this.findModel(i.getOriginalEditor(), e) || this.findModel(i.getModifiedEditor(), e))), t ? Promise.resolve(new Zne(new Sle(t))) : Promise.reject(new Error("Model not found"));
  }
  findModel(e, t) {
    let i = this.modelService.getModel(t);
    return i && i.uri.toString() !== t.toString() ? null : i;
  }
};
jT = c3([
  h3(0, ao)
], jT);
class pE {
  show() {
    return pE.NULL_PROGRESS_RUNNER;
  }
  showWhile(e, t) {
    return d3(this, void 0, void 0, function* () {
      yield e;
    });
  }
}
pE.NULL_PROGRESS_RUNNER = {
  done: () => {
  },
  total: () => {
  },
  worked: () => {
  }
};
class Lle {
  confirm(e) {
    return this.doConfirm(e).then((t) => ({
      confirmed: t,
      checkboxChecked: !1
      // unsupported
    }));
  }
  doConfirm(e) {
    let t = e.message;
    return e.detail && (t = t + `

` + e.detail), Promise.resolve(window.confirm(t));
  }
  show(e, t, i, r) {
    return Promise.resolve({ choice: 0 });
  }
}
class gE {
  info(e) {
    return this.notify({ severity: mn.Info, message: e });
  }
  warn(e) {
    return this.notify({ severity: mn.Warning, message: e });
  }
  error(e) {
    return this.notify({ severity: mn.Error, message: e });
  }
  notify(e) {
    switch (e.severity) {
      case mn.Error:
        console.error(e.message);
        break;
      case mn.Warning:
        console.warn(e.message);
        break;
      default:
        console.log(e.message);
        break;
    }
    return gE.NO_OP;
  }
  status(e, t) {
    return Ce.None;
  }
}
gE.NO_OP = new yle();
class Dle {
  constructor(e) {
    this._onWillExecuteCommand = new q(), this._onDidExecuteCommand = new q(), this.onDidExecuteCommand = this._onDidExecuteCommand.event, this._instantiationService = e;
  }
  executeCommand(e, ...t) {
    const i = Qn.getCommand(e);
    if (!i)
      return Promise.reject(new Error(`command '${e}' not found`));
    try {
      this._onWillExecuteCommand.fire({ commandId: e, args: t });
      const r = this._instantiationService.invokeFunction.apply(this._instantiationService, [i.handler, ...t]);
      return this._onDidExecuteCommand.fire({ commandId: e, args: t }), Promise.resolve(r);
    } catch (r) {
      return Promise.reject(r);
    }
  }
}
class f3 extends ple {
  constructor(e, t, i, r, o, s) {
    super(e, t, i, r, o), this._cachedResolver = null, this._dynamicKeybindings = [], this._register(be(s, Ge.KEY_DOWN, (a) => {
      const l = new Yi(a);
      this._dispatch(l, l.target) && (l.preventDefault(), l.stopPropagation());
    })), this._register(be(window, Ge.KEY_UP, (a) => {
      const l = new Yi(a);
      this._singleModifierDispatch(l, l.target) && l.preventDefault();
    }));
  }
  addDynamicKeybinding(e, t, i, r) {
    const o = wR(t, ja), s = new dt();
    return o && (this._dynamicKeybindings.push({
      keybinding: o,
      command: e,
      when: r,
      weight1: 1e3,
      weight2: 0,
      extensionId: null,
      isBuiltinExtension: !1
    }), s.add(Oi(() => {
      for (let a = 0; a < this._dynamicKeybindings.length; a++)
        if (this._dynamicKeybindings[a].command === e) {
          this._dynamicKeybindings.splice(a, 1), this.updateResolver({
            source: 1
            /* Default */
          });
          return;
        }
    }))), s.add(Qn.registerCommand(e, i)), this.updateResolver({
      source: 1
      /* Default */
    }), s;
  }
  updateResolver(e) {
    this._cachedResolver = null, this._onDidUpdateKeybindings.fire(e);
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const e = this._toNormalizedKeybindingItems(fE.getDefaultKeybindings(), !0), t = this._toNormalizedKeybindingItems(this._dynamicKeybindings, !1);
      this._cachedResolver = new Tp(e, t, (i) => this._log(i));
    }
    return this._cachedResolver;
  }
  _documentHasFocus() {
    return document.hasFocus();
  }
  _toNormalizedKeybindingItems(e, t) {
    let i = [], r = 0;
    for (const o of e) {
      const s = o.when || void 0, a = o.keybinding;
      if (!a)
        i[r++] = new n2(void 0, o.command, o.commandArgs, s, t, null, !1);
      else {
        const l = this.resolveKeybinding(a);
        for (const u of l)
          i[r++] = new n2(u, o.command, o.commandArgs, s, t, null, !1);
      }
    }
    return i;
  }
  resolveKeybinding(e) {
    return [new Nb(e, ja)];
  }
  resolveKeyboardEvent(e) {
    let t = new NN(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, e.keyCode).toChord();
    return new Nb(t, ja);
  }
}
function d2(n) {
  return n && typeof n == "object" && (!n.overrideIdentifier || typeof n.overrideIdentifier == "string") && (!n.resource || n.resource instanceof ft);
}
class p3 {
  constructor() {
    this._onDidChangeConfiguration = new q(), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._configuration = new s3(new dle(), new ps());
  }
  getValue(e, t) {
    const i = typeof e == "string" ? e : void 0, r = d2(e) ? e : d2(t) ? t : {};
    return this._configuration.getValue(i, r, void 0);
  }
  updateValues(e) {
    const t = { data: this._configuration.toData() };
    let i = [];
    for (const r of e) {
      const [o, s] = r;
      this.getValue(o) !== s && (this._configuration.updateValue(o, s), i.push(o));
    }
    if (i.length > 0) {
      const r = new fle({ keys: i, overrides: [] }, t, this._configuration);
      r.source = 7, r.sourceConfig = null, this._onDidChangeConfiguration.fire(r);
    }
    return Promise.resolve();
  }
}
class Rle {
  constructor(e) {
    this.configurationService = e, this._onDidChangeConfiguration = new q(), this.configurationService.onDidChangeConfiguration((t) => {
      this._onDidChangeConfiguration.fire({ affectedKeys: t.affectedKeys, affectsConfiguration: (i, r) => t.affectsConfiguration(r) });
    });
  }
  getValue(e, t, i) {
    const o = (ie.isIPosition(t) ? t : null) ? typeof i == "string" ? i : void 0 : typeof t == "string" ? t : void 0;
    return typeof o > "u" ? this.configurationService.getValue() : this.configurationService.getValue(o);
  }
}
let $T = class {
  constructor(e) {
    this.configurationService = e;
  }
  getEOL(e, t) {
    const i = this.configurationService.getValue("files.eol", { overrideIdentifier: t, resource: e });
    return i && i !== "auto" ? i : Is || kt ? `
` : `\r
`;
  }
};
$T = c3([
  h3(0, _r)
], $T);
class Tle {
  publicLog(e, t) {
    return Promise.resolve(void 0);
  }
  publicLog2(e, t) {
    return this.publicLog(e, t);
  }
}
class mE {
  constructor() {
    const e = ft.from({ scheme: mE.SCHEME, authority: "model", path: "/" });
    this.workspace = { id: "4064f6ec-cb38-4ad0-af64-ee6467e63c82", folders: [new ble({ uri: e, name: "", index: 0 })] };
  }
  getWorkspace() {
    return this.workspace;
  }
}
mE.SCHEME = "inmemory";
function Pb(n, e, t) {
  if (!e || !(n instanceof p3))
    return;
  let i = [];
  Object.keys(e).forEach((r) => {
    sle(r) && i.push([`editor.${r}`, e[r]]), t && ale(r) && i.push([`diffEditor.${r}`, e[r]]);
  }), i.length > 0 && n.updateValues(i);
}
class Ole {
  constructor(e) {
    this._modelService = e;
  }
  hasPreviewHandler() {
    return !1;
  }
  apply(e, t) {
    return d3(this, void 0, void 0, function* () {
      const i = /* @__PURE__ */ new Map();
      for (let s of e) {
        if (!(s instanceof e3))
          throw new Error("bad edit - only text edits are supported");
        const a = this._modelService.getModel(s.resource);
        if (!a)
          throw new Error("bad edit - model not found");
        if (typeof s.versionId == "number" && a.getVersionId() !== s.versionId)
          throw new Error("bad state - model changed in the meantime");
        let l = i.get(a);
        l || (l = [], i.set(a, l)), l.push(UT.replaceMove(G.lift(s.textEdit.range), s.textEdit.text));
      }
      let r = 0, o = 0;
      for (const [s, a] of i)
        s.pushStackElement(), s.pushEditOperations([], a, () => []), s.pushStackElement(), o += 1, r += a.length;
      return {
        ariaSummary: Fl(zT.bulkEditServiceSummary, r, o)
      };
    });
  }
}
class xle {
  getUriLabel(e, t) {
    return e.scheme === "file" ? e.fsPath : e.path;
  }
}
class Nle {
  constructor(e, t) {
    this._codeEditorService = e, this._container = t, this.onDidLayout = We.None;
  }
  get dimension() {
    return this._dimension || (this._dimension = o5(window.document.body)), this._dimension;
  }
  get container() {
    return this._container;
  }
  focus() {
    var e;
    (e = this._codeEditorService.getFocusedCodeEditor()) === null || e === void 0 || e.focus();
  }
}
const f2 = 2e4;
let Qh, hw, KT, dw, qT;
function Ile(n) {
  Qh = document.createElement("div"), Qh.className = "monaco-aria-container";
  const e = () => {
    const i = document.createElement("div");
    return i.className = "monaco-alert", i.setAttribute("role", "alert"), i.setAttribute("aria-atomic", "true"), Qh.appendChild(i), i;
  };
  hw = e(), KT = e();
  const t = () => {
    const i = document.createElement("div");
    return i.className = "monaco-status", i.setAttribute("role", "complementary"), i.setAttribute("aria-live", "polite"), i.setAttribute("aria-atomic", "true"), Qh.appendChild(i), i;
  };
  dw = t(), qT = t(), n.appendChild(Qh);
}
function ld(n) {
  Qh && (hw.textContent !== n ? (Ps(KT), Ab(hw, n)) : (Ps(hw), Ab(KT, n)));
}
function YT(n) {
  Qh && (kt ? ld(n) : dw.textContent !== n ? (Ps(qT), Ab(dw, n)) : (Ps(dw), Ab(qT, n)));
}
function Ab(n, e) {
  Ps(n), e.length > f2 && (e = e.substr(0, f2)), n.textContent = e, n.style.visibility = "hidden", n.style.visibility = "visible";
}
const g3 = Vt("markerDecorationsService");
var Mb = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class zl extends Ce {
  constructor(e, t = "", i = "", r = !0, o) {
    super(), this._onDidChange = this._register(new q()), this.onDidChange = this._onDidChange.event, this._enabled = !0, this._checked = !1, this._id = e, this._label = t, this._cssClass = i, this._enabled = r, this._actionCallback = o;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(e) {
    this._setLabel(e);
  }
  _setLabel(e) {
    this._label !== e && (this._label = e, this._onDidChange.fire({ label: e }));
  }
  get tooltip() {
    return this._tooltip || "";
  }
  set tooltip(e) {
    this._setTooltip(e);
  }
  _setTooltip(e) {
    this._tooltip !== e && (this._tooltip = e, this._onDidChange.fire({ tooltip: e }));
  }
  get class() {
    return this._cssClass;
  }
  set class(e) {
    this._setClass(e);
  }
  _setClass(e) {
    this._cssClass !== e && (this._cssClass = e, this._onDidChange.fire({ class: e }));
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._setEnabled(e);
  }
  _setEnabled(e) {
    this._enabled !== e && (this._enabled = e, this._onDidChange.fire({ enabled: e }));
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._setChecked(e);
  }
  _setChecked(e) {
    this._checked !== e && (this._checked = e, this._onDidChange.fire({ checked: e }));
  }
  run(e, t) {
    return Mb(this, void 0, void 0, function* () {
      this._actionCallback && (yield this._actionCallback(e));
    });
  }
}
class lI extends Ce {
  constructor() {
    super(...arguments), this._onBeforeRun = this._register(new q()), this.onBeforeRun = this._onBeforeRun.event, this._onDidRun = this._register(new q()), this.onDidRun = this._onDidRun.event;
  }
  run(e, t) {
    return Mb(this, void 0, void 0, function* () {
      if (!e.enabled)
        return;
      this._onBeforeRun.fire({ action: e });
      let i;
      try {
        yield this.runAction(e, t);
      } catch (r) {
        i = r;
      }
      this._onDidRun.fire({ action: e, error: i });
    });
  }
  runAction(e, t) {
    return Mb(this, void 0, void 0, function* () {
      yield e.run(t);
    });
  }
}
class lf extends zl {
  constructor(e) {
    super(lf.ID, e, e ? "separator text" : "separator"), this.checked = !1, this.enabled = !1;
  }
}
lf.ID = "vs.actions.separator";
class m3 {
  constructor(e, t, i, r) {
    this.tooltip = "", this.enabled = !0, this.checked = !1, this.id = e, this.label = t, this.class = r, this._actions = i;
  }
  get actions() {
    return this._actions;
  }
  dispose() {
  }
  run() {
    return Mb(this, void 0, void 0, function* () {
    });
  }
}
class vE extends zl {
  constructor() {
    super(vE.ID, b("submenu.empty", "(empty)"), void 0, !1);
  }
}
vE.ID = "vs.actions.empty";
let _E = ane || "";
const Oo = /* @__PURE__ */ new Map();
Oo.set("false", !1);
Oo.set("true", !0);
Oo.set("isMac", kt);
Oo.set("isLinux", Is);
Oo.set("isWindows", Ro);
Oo.set("isWeb", XS);
Oo.set("isMacNative", kt && !XS);
Oo.set("isEdge", _E.indexOf("Edg/") >= 0);
Oo.set("isFirefox", _E.indexOf("Firefox") >= 0);
Oo.set("isChrome", _E.indexOf("Chrome") >= 0);
Oo.set("isSafari", _E.indexOf("Safari") >= 0);
const Ple = Object.prototype.hasOwnProperty;
class fr {
  static has(e) {
    return ch.create(e);
  }
  static equals(e, t) {
    return i_.create(e, t);
  }
  static regex(e, t) {
    return Fb.create(e, t);
  }
  static not(e) {
    return Gd.create(e);
  }
  static and(...e) {
    return Op.create(e);
  }
  static or(...e) {
    return Ud.create(e);
  }
  static deserialize(e, t = !1) {
    if (e)
      return this._deserializeOrExpression(e, t);
  }
  static _deserializeOrExpression(e, t) {
    let i = e.split("||");
    return Ud.create(i.map((r) => this._deserializeAndExpression(r, t)));
  }
  static _deserializeAndExpression(e, t) {
    let i = e.split("&&");
    return Op.create(i.map((r) => this._deserializeOne(r, t)));
  }
  static _deserializeOne(e, t) {
    if (e = e.trim(), e.indexOf("!=") >= 0) {
      let i = e.split("!=");
      return CE.create(i[0].trim(), this._deserializeValue(i[1], t));
    }
    if (e.indexOf("==") >= 0) {
      let i = e.split("==");
      return i_.create(i[0].trim(), this._deserializeValue(i[1], t));
    }
    if (e.indexOf("=~") >= 0) {
      let i = e.split("=~");
      return Fb.create(i[0].trim(), this._deserializeRegexValue(i[1], t));
    }
    if (e.indexOf(" in ") >= 0) {
      let i = e.split(" in ");
      return uI.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+>=[^<=>]+$/.test(e)) {
      const i = e.split(">=");
      return wE.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+>[^<=>]+$/.test(e)) {
      const i = e.split(">");
      return yE.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+<=[^<=>]+$/.test(e)) {
      const i = e.split("<=");
      return SE.create(i[0].trim(), i[1].trim());
    }
    if (/^[^<=>]+<[^<=>]+$/.test(e)) {
      const i = e.split("<");
      return bE.create(i[0].trim(), i[1].trim());
    }
    return /^\!\s*/.test(e) ? Gd.create(e.substr(1).trim()) : ch.create(e);
  }
  static _deserializeValue(e, t) {
    if (e = e.trim(), e === "true")
      return !0;
    if (e === "false")
      return !1;
    let i = /^'([^']*)'$/.exec(e);
    return i ? i[1].trim() : e;
  }
  static _deserializeRegexValue(e, t) {
    if (eoe(e)) {
      if (t)
        throw new Error("missing regexp-value for =~-expression");
      return console.warn("missing regexp-value for =~-expression"), null;
    }
    let i = e.indexOf("/"), r = e.lastIndexOf("/");
    if (i === r || i < 0) {
      if (t)
        throw new Error(`bad regexp-value '${e}', missing /-enclosure`);
      return console.warn(`bad regexp-value '${e}', missing /-enclosure`), null;
    }
    let o = e.slice(i + 1, r), s = e[r + 1] === "i" ? "i" : "";
    try {
      return new RegExp(o, s);
    } catch (a) {
      if (t)
        throw new Error(`bad regexp-value '${e}', parse error: ${a}`);
      return console.warn(`bad regexp-value '${e}', parse error: ${a}`), null;
    }
  }
}
function Cv(n, e) {
  return n.cmp(e);
}
class ec {
  constructor() {
    this.type = 0;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  evaluate(e) {
    return !1;
  }
  serialize() {
    return "false";
  }
  keys() {
    return [];
  }
  negate() {
    return tc.INSTANCE;
  }
}
ec.INSTANCE = new ec();
class tc {
  constructor() {
    this.type = 1;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  evaluate(e) {
    return !0;
  }
  serialize() {
    return "true";
  }
  keys() {
    return [];
  }
  negate() {
    return ec.INSTANCE;
  }
}
tc.INSTANCE = new tc();
class ch {
  constructor(e) {
    this.key = e, this.type = 2;
  }
  static create(e) {
    const t = Oo.get(e);
    return typeof t == "boolean" ? t ? tc.INSTANCE : ec.INSTANCE : new ch(e);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : v3(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  evaluate(e) {
    return !!e.getValue(this.key);
  }
  serialize() {
    return this.key;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return Gd.create(this.key);
  }
}
class i_ {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 4;
  }
  static create(e, t) {
    if (typeof t == "boolean")
      return t ? ch.create(e) : Gd.create(e);
    const i = Oo.get(e);
    return typeof i == "boolean" ? t === (i ? "true" : "false") ? tc.INSTANCE : ec.INSTANCE : new i_(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : uf(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return e.getValue(this.key) == this.value;
  }
  serialize() {
    return `${this.key} == '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return CE.create(this.key, this.value);
  }
}
class uI {
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 10;
  }
  static create(e, t) {
    return new uI(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : uf(this.key, this.valueKey, e.key, e.valueKey);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : !1;
  }
  evaluate(e) {
    const t = e.getValue(this.valueKey), i = e.getValue(this.key);
    return Array.isArray(t) ? t.indexOf(i) >= 0 : typeof i == "string" && typeof t == "object" && t !== null ? Ple.call(t, i) : !1;
  }
  serialize() {
    return `${this.key} in '${this.valueKey}'`;
  }
  keys() {
    return [this.key, this.valueKey];
  }
  negate() {
    return cI.create(this);
  }
}
class cI {
  constructor(e) {
    this._actual = e, this.type = 11;
  }
  static create(e) {
    return new cI(e);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
  }
  equals(e) {
    return e.type === this.type ? this._actual.equals(e._actual) : !1;
  }
  evaluate(e) {
    return !this._actual.evaluate(e);
  }
  serialize() {
    throw new Error("Method not implemented.");
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
}
class CE {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 5;
  }
  static create(e, t) {
    if (typeof t == "boolean")
      return t ? Gd.create(e) : ch.create(e);
    const i = Oo.get(e);
    return typeof i == "boolean" ? t === (i ? "true" : "false") ? ec.INSTANCE : tc.INSTANCE : new CE(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : uf(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return e.getValue(this.key) != this.value;
  }
  serialize() {
    return `${this.key} != '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return i_.create(this.key, this.value);
  }
}
class Gd {
  constructor(e) {
    this.key = e, this.type = 3;
  }
  static create(e) {
    const t = Oo.get(e);
    return typeof t == "boolean" ? t ? ec.INSTANCE : tc.INSTANCE : new Gd(e);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : v3(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  evaluate(e) {
    return !e.getValue(this.key);
  }
  serialize() {
    return `!${this.key}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return ch.create(this.key);
  }
}
class yE {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 12;
  }
  static create(e, t) {
    return new yE(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : uf(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return parseFloat(e.getValue(this.key)) > parseFloat(this.value);
  }
  serialize() {
    return `${this.key} > ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return SE.create(this.key, this.value);
  }
}
class wE {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 13;
  }
  static create(e, t) {
    return new wE(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : uf(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return parseFloat(e.getValue(this.key)) >= parseFloat(this.value);
  }
  serialize() {
    return `${this.key} >= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return bE.create(this.key, this.value);
  }
}
class bE {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 14;
  }
  static create(e, t) {
    return new bE(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : uf(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return parseFloat(e.getValue(this.key)) < parseFloat(this.value);
  }
  serialize() {
    return `${this.key} < ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return wE.create(this.key, this.value);
  }
}
class SE {
  constructor(e, t) {
    this.key = e, this.value = t, this.type = 15;
  }
  static create(e, t) {
    return new SE(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : uf(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  evaluate(e) {
    return parseFloat(e.getValue(this.key)) <= parseFloat(this.value);
  }
  serialize() {
    return `${this.key} <= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return yE.create(this.key, this.value);
  }
}
class Fb {
  constructor(e, t) {
    this.key = e, this.regexp = t, this.type = 7;
  }
  static create(e, t) {
    return new Fb(e, t);
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.key < e.key)
      return -1;
    if (this.key > e.key)
      return 1;
    const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
    return t < i ? -1 : t > i ? 1 : 0;
  }
  equals(e) {
    if (e.type === this.type) {
      const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
      return this.key === e.key && t === i;
    }
    return !1;
  }
  evaluate(e) {
    let t = e.getValue(this.key);
    return this.regexp ? this.regexp.test(t) : !1;
  }
  serialize() {
    const e = this.regexp ? `/${this.regexp.source}/${this.regexp.ignoreCase ? "i" : ""}` : "/invalid/";
    return `${this.key} =~ ${e}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return hI.create(this);
  }
}
class hI {
  constructor(e) {
    this._actual = e, this.type = 8;
  }
  static create(e) {
    return new hI(e);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
  }
  equals(e) {
    return e.type === this.type ? this._actual.equals(e._actual) : !1;
  }
  evaluate(e) {
    return !this._actual.evaluate(e);
  }
  serialize() {
    throw new Error("Method not implemented.");
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
}
class Op {
  constructor(e) {
    this.expr = e, this.type = 6;
  }
  static create(e) {
    return Op._normalizeArr(e);
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const r = Cv(this.expr[t], e.expr[t]);
      if (r !== 0)
        return r;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (!this.expr[t].evaluate(e))
        return !1;
    return !0;
  }
  static _normalizeArr(e) {
    const t = [];
    let i = !1;
    for (const r of e)
      if (r) {
        if (r.type === 1) {
          i = !0;
          continue;
        }
        if (r.type === 0)
          return ec.INSTANCE;
        if (r.type === 6) {
          t.push(...r.expr);
          continue;
        }
        t.push(r);
      }
    if (t.length === 0 && i)
      return tc.INSTANCE;
    if (t.length !== 0) {
      if (t.length === 1)
        return t[0];
      for (t.sort(Cv); t.length > 1; ) {
        const r = t[t.length - 1];
        if (r.type !== 9)
          break;
        t.pop();
        const o = t.pop(), s = Ud.create(r.expr.map((a) => Op.create([a, o])));
        s && (t.push(s), t.sort(Cv));
      }
      return t.length === 1 ? t[0] : new Op(t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" && ");
  }
  keys() {
    const e = [];
    for (let t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    let e = [];
    for (let t of this.expr)
      e.push(t.negate());
    return Ud.create(e);
  }
}
class Ud {
  constructor(e) {
    this.expr = e, this.type = 9;
  }
  static create(e) {
    const t = Ud._normalizeArr(e);
    if (t.length !== 0)
      return t.length === 1 ? t[0] : new Ud(t);
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const r = Cv(this.expr[t], e.expr[t]);
      if (r !== 0)
        return r;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (this.expr[t].evaluate(e))
        return !0;
    return !1;
  }
  static _normalizeArr(e) {
    let t = [], i = !1;
    if (e) {
      for (let r = 0, o = e.length; r < o; r++) {
        const s = e[r];
        if (s) {
          if (s.type === 0) {
            i = !0;
            continue;
          }
          if (s.type === 1)
            return [tc.INSTANCE];
          if (s.type === 9) {
            t = t.concat(s.expr);
            continue;
          }
          t.push(s);
        }
      }
      if (t.length === 0 && i)
        return [ec.INSTANCE];
      t.sort(Cv);
    }
    return t;
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" || ");
  }
  keys() {
    const e = [];
    for (let t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    let e = [];
    for (let i of this.expr)
      e.push(i.negate());
    const t = (i) => i.type === 9 ? i.expr : [i];
    for (; e.length > 1; ) {
      const i = e.shift(), r = e.shift(), o = [];
      for (const s of t(i))
        for (const a of t(r))
          o.push(fr.and(s, a));
      e.unshift(fr.or(...o));
    }
    return e[0];
  }
}
class nt extends ch {
  constructor(e, t, i) {
    super(e), this._defaultValue = t, typeof i == "object" ? nt._info.push(Object.assign(Object.assign({}, i), { key: e })) : i !== !0 && nt._info.push({ key: e, description: i, type: t != null ? typeof t : void 0 });
  }
  static all() {
    return nt._info.values();
  }
  bindTo(e) {
    return e.createKey(this.key, this._defaultValue);
  }
  getValue(e) {
    return e.getContextKeyValue(this.key);
  }
  toNegated() {
    return fr.not(this.key);
  }
  isEqualTo(e) {
    return fr.equals(this.key, e);
  }
}
nt._info = [];
const xi = Vt("contextKeyService"), Ale = "setContext";
function v3(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
function uf(n, e, t, i) {
  return n < t ? -1 : n > t ? 1 : e < i ? -1 : e > i ? 1 : 0;
}
var jl;
(function(n) {
  n.DARK = "dark", n.LIGHT = "light", n.HIGH_CONTRAST = "hc";
})(jl || (jl = {}));
const er = Vt("themeService");
var XT;
(function(n) {
  function e(t) {
    return t && typeof t == "object" && typeof t.id == "string";
  }
  n.isThemeColor = e;
})(XT || (XT = {}));
function km(n) {
  return { id: n };
}
var ma;
(function(n) {
  function e(a) {
    return a && typeof a == "object" && typeof a.id == "string" && (typeof a.color > "u" || XT.isThemeColor(a.color));
  }
  n.isThemeIcon = e;
  const t = new RegExp(`^\\$\\((${Go.iconNameExpression}(?:${Go.iconModifierExpression})?)\\)$`);
  function i(a) {
    const l = t.exec(a);
    if (!l)
      return;
    let [, u] = l;
    return { id: u };
  }
  n.fromString = i;
  function r(a, l) {
    let u = a.id;
    const c = u.lastIndexOf("~");
    return c !== -1 && (u = u.substring(0, c)), l && (u = `${u}~${l}`), { id: u };
  }
  n.modify = r;
  function o(a, l) {
    var u, c;
    return a.id === l.id && ((u = a.color) === null || u === void 0 ? void 0 : u.id) === ((c = l.color) === null || c === void 0 ? void 0 : c.id);
  }
  n.isEqual = o;
  function s(a) {
    return { id: a.id };
  }
  n.asThemeIcon = s, n.asClassNameArray = Go.asClassNameArray, n.asClassName = Go.asClassName, n.asCSSSelector = Go.asCSSSelector;
})(ma || (ma = {}));
function kb(n) {
  switch (n) {
    case jl.DARK:
      return "vs-dark";
    case jl.HIGH_CONTRAST:
      return "hc-black";
    default:
      return "vs";
  }
}
const _3 = {
  ThemingContribution: "base.contributions.theming"
};
class Mle {
  constructor() {
    this.themingParticipants = [], this.themingParticipants = [], this.onThemingParticipantAddedEmitter = new q();
  }
  onColorThemeChange(e) {
    return this.themingParticipants.push(e), this.onThemingParticipantAddedEmitter.fire(e), Oi(() => {
      const t = this.themingParticipants.indexOf(e);
      this.themingParticipants.splice(t, 1);
    });
  }
  getThemingParticipants() {
    return this.themingParticipants;
  }
}
let C3 = new Mle();
Jn.add(_3.ThemingContribution, C3);
function wa(n) {
  return C3.onColorThemeChange(n);
}
class Fle extends Ce {
  constructor(e) {
    super(), this.themeService = e, this.theme = e.getColorTheme(), this._register(this.themeService.onDidColorThemeChange((t) => this.onThemeChange(t)));
  }
  onThemeChange(e) {
    this.theme = e, this.updateStyles();
  }
  updateStyles() {
  }
}
var kle = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, p2 = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
function Qm(n) {
  return n.command !== void 0;
}
class si {
  constructor(e) {
    this.id = si._idPool++, this._debugName = e;
  }
}
si._idPool = 0;
si.CommandPalette = new si("CommandPalette");
si.EditorContext = new si("EditorContext");
si.SimpleEditorContext = new si("SimpleEditorContext");
si.EditorContextCopy = new si("EditorContextCopy");
si.EditorContextPeek = new si("EditorContextPeek");
si.MenubarEditMenu = new si("MenubarEditMenu");
si.MenubarCopy = new si("MenubarCopy");
si.MenubarGoMenu = new si("MenubarGoMenu");
si.MenubarSelectionMenu = new si("MenubarSelectionMenu");
si.InlineCompletionsActions = new si("InlineCompletionsActions");
const y3 = Vt("menuService"), yv = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._menuItems = /* @__PURE__ */ new Map(), this._onDidChangeMenu = new q(), this.onDidChangeMenu = this._onDidChangeMenu.event, this._commandPaletteChangeEvent = {
      has: (n) => n === si.CommandPalette
    };
  }
  addCommand(n) {
    return this.addCommands(Ct.single(n));
  }
  addCommands(n) {
    for (const e of n)
      this._commands.set(e.id, e);
    return this._onDidChangeMenu.fire(this._commandPaletteChangeEvent), Oi(() => {
      let e = !1;
      for (const t of n)
        e = this._commands.delete(t.id) || e;
      e && this._onDidChangeMenu.fire(this._commandPaletteChangeEvent);
    });
  }
  getCommand(n) {
    return this._commands.get(n);
  }
  getCommands() {
    const n = /* @__PURE__ */ new Map();
    return this._commands.forEach((e, t) => n.set(t, e)), n;
  }
  appendMenuItem(n, e) {
    return this.appendMenuItems(Ct.single({ id: n, item: e }));
  }
  appendMenuItems(n) {
    const e = /* @__PURE__ */ new Set(), t = new fa();
    for (const { id: i, item: r } of n) {
      let o = this._menuItems.get(i);
      o || (o = new fa(), this._menuItems.set(i, o)), t.push(o.push(r)), e.add(i);
    }
    return this._onDidChangeMenu.fire(e), Oi(() => {
      if (t.size > 0) {
        for (let i of t)
          i();
        this._onDidChangeMenu.fire(e), t.clear();
      }
    });
  }
  getMenuItems(n) {
    let e;
    return this._menuItems.has(n) ? e = [...this._menuItems.get(n)] : e = [], n === si.CommandPalette && this._appendImplicitItems(e), e;
  }
  _appendImplicitItems(n) {
    const e = /* @__PURE__ */ new Set();
    for (const t of n)
      Qm(t) && (e.add(t.command.id), t.alt && e.add(t.alt.id));
    this._commands.forEach((t, i) => {
      e.has(i) || n.push({ command: t });
    });
  }
}();
class Wle extends m3 {
  constructor(e, t, i, r) {
    super(`submenuitem.${e.submenu.id}`, typeof e.title == "string" ? e.title : e.title.value, [], "submenu"), this.item = e, this._menuService = t, this._contextKeyService = i, this._options = r;
  }
  get actions() {
    const e = [], t = this._menuService.createMenu(this.item.submenu, this._contextKeyService), i = t.getActions(this._options);
    t.dispose();
    for (const [, r] of i)
      r.length > 0 && (e.push(...r), e.push(new lf()));
    return e.length && e.pop(), e;
  }
}
let ZT = class w3 {
  constructor(e, t, i, r, o) {
    var s;
    if (this._commandService = o, this.id = e.id, this.label = i != null && i.renderShortTitle && e.shortTitle ? typeof e.shortTitle == "string" ? e.shortTitle : e.shortTitle.value : typeof e.title == "string" ? e.title : e.title.value, this.tooltip = (s = e.tooltip) !== null && s !== void 0 ? s : "", this.enabled = !e.precondition || r.contextMatchesRules(e.precondition), this.checked = !1, e.toggled) {
      const a = e.toggled.condition ? e.toggled : { condition: e.toggled };
      this.checked = r.contextMatchesRules(a.condition), this.checked && a.tooltip && (this.tooltip = typeof a.tooltip == "string" ? a.tooltip : a.tooltip.value), a.title && (this.label = typeof a.title == "string" ? a.title : a.title.value);
    }
    this.item = e, this.alt = t ? new w3(t, void 0, i, r, o) : void 0, this._options = i, ma.isThemeIcon(e.icon) && (this.class = Go.asClassName(e.icon));
  }
  dispose() {
  }
  run(...e) {
    var t, i;
    let r = [];
    return !((t = this._options) === null || t === void 0) && t.arg && (r = [...r, this._options.arg]), !((i = this._options) === null || i === void 0) && i.shouldForwardArgs && (r = [...r, ...e]), this._commandService.executeCommand(this.id, ...r);
  }
};
ZT = kle([
  p2(3, xi),
  p2(4, Xo)
], ZT);
const EE = Vt("telemetryService");
class LE {
  constructor(e) {
    this.id = e.id, this.precondition = e.precondition, this._kbOpts = e.kbOpts, this._menuOpts = e.menuOpts, this._description = e.description;
  }
  register() {
    if (Array.isArray(this._menuOpts) ? this._menuOpts.forEach(this._registerMenuItem, this) : this._menuOpts && this._registerMenuItem(this._menuOpts), this._kbOpts) {
      const e = Array.isArray(this._kbOpts) ? this._kbOpts : [this._kbOpts];
      for (const t of e) {
        let i = t.kbExpr;
        this.precondition && (i ? i = fr.and(i, this.precondition) : i = this.precondition);
        const r = {
          id: this.id,
          weight: t.weight,
          args: t.args,
          when: i,
          primary: t.primary,
          secondary: t.secondary,
          win: t.win,
          linux: t.linux,
          mac: t.mac
        };
        fE.registerKeybindingRule(r);
      }
    }
    Qn.registerCommand({
      id: this.id,
      handler: (e, t) => this.runCommand(e, t),
      description: this._description
    });
  }
  _registerMenuItem(e) {
    yv.appendMenuItem(e.menuId, {
      group: e.group,
      command: {
        id: this.id,
        title: e.title,
        icon: e.icon,
        precondition: this.precondition
      },
      when: e.when,
      order: e.order
    });
  }
}
class dI extends LE {
  constructor() {
    super(...arguments), this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(e, t, i) {
    return this._implementations.push({ priority: e, name: t, implementation: i }), this._implementations.sort((r, o) => o.priority - r.priority), {
      dispose: () => {
        for (let r = 0; r < this._implementations.length; r++)
          if (this._implementations[r].implementation === i) {
            this._implementations.splice(r, 1);
            return;
          }
      }
    };
  }
  runCommand(e, t) {
    const i = e.get(K_);
    for (const r of this._implementations) {
      const o = r.implementation(e, t);
      if (o)
        return i.trace(`Command '${this.id}' was handled by '${r.name}'.`), typeof o == "boolean" ? void 0 : o;
    }
  }
}
class b3 extends LE {
  constructor(e, t) {
    super(t), this.command = e;
  }
  runCommand(e, t) {
    return this.command.runCommand(e, t);
  }
}
class Mg extends LE {
  /**
   * Create a command class that is bound to a certain editor contribution.
   */
  static bindToContribution(e) {
    return class extends Mg {
      constructor(i) {
        super(i), this._callback = i.handler;
      }
      runEditorCommand(i, r, o) {
        e(r) && this._callback(e(r), o);
      }
    };
  }
  runCommand(e, t) {
    const i = e.get(mr), r = i.getFocusedCodeEditor() || i.getActiveCodeEditor();
    if (r)
      return r.invokeWithinContext((o) => {
        if (o.get(xi).contextMatchesRules(op(this.precondition)))
          return this.runEditorCommand(o, r, t);
      });
  }
}
class q_ extends Mg {
  constructor(e) {
    super(q_.convertOptions(e)), this.label = e.label, this.alias = e.alias;
  }
  static convertOptions(e) {
    let t;
    Array.isArray(e.menuOpts) ? t = e.menuOpts : e.menuOpts ? t = [e.menuOpts] : t = [];
    function i(r) {
      return r.menuId || (r.menuId = si.EditorContext), r.title || (r.title = e.label), r.when = fr.and(e.precondition, r.when), r;
    }
    return Array.isArray(e.contextMenuOpts) ? t.push(...e.contextMenuOpts.map(i)) : e.contextMenuOpts && t.push(i(e.contextMenuOpts)), e.menuOpts = t, e;
  }
  runEditorCommand(e, t, i) {
    return this.reportTelemetry(e, t), this.run(e, t, i || {});
  }
  reportTelemetry(e, t) {
    e.get(EE).publicLog2("editorActionInvoked", { name: this.label, id: this.id });
  }
}
class Hye extends q_ {
  constructor() {
    super(...arguments), this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(e, t) {
    return this._implementations.push([e, t]), this._implementations.sort((i, r) => r[0] - i[0]), {
      dispose: () => {
        for (let i = 0; i < this._implementations.length; i++)
          if (this._implementations[i][1] === t) {
            this._implementations.splice(i, 1);
            return;
          }
      }
    };
  }
  run(e, t, i) {
    for (const r of this._implementations) {
      const o = r[1](e, t, i);
      if (o)
        return typeof o == "boolean" ? void 0 : o;
    }
  }
}
function Gye(n, e) {
  Qn.registerCommand(n, function(t, ...i) {
    const [r, o] = i;
    $o(ft.isUri(r)), $o(ie.isIPosition(o));
    const s = t.get(ao).getModel(r);
    if (s) {
      const a = ie.lift(o);
      return e(s, a, ...i.slice(2));
    }
    return t.get(bb).createModelReference(r).then((a) => new Promise((l, u) => {
      try {
        const c = e(a.object.textEditorModel, ie.lift(o), i.slice(2));
        l(c);
      } catch (c) {
        u(c);
      }
    }).finally(() => {
      a.dispose();
    }));
  });
}
function Uye(n, e) {
  Qn.registerCommand(n, function(t, ...i) {
    const [r] = i;
    $o(ft.isUri(r));
    const o = t.get(ao).getModel(r);
    return o ? e(o, ...i.slice(1)) : t.get(bb).createModelReference(r).then((s) => new Promise((a, l) => {
      try {
        const u = e(s.object.textEditorModel, i.slice(1));
        a(u);
      } catch (u) {
        l(u);
      }
    }).finally(() => {
      s.dispose();
    }));
  });
}
function Ze(n) {
  return Cs.INSTANCE.registerEditorCommand(n), n;
}
function S3(n) {
  const e = new n();
  return Cs.INSTANCE.registerEditorAction(e), e;
}
function zye(n) {
  return Cs.INSTANCE.registerEditorAction(n), n;
}
function jye(n) {
  Cs.INSTANCE.registerEditorAction(n);
}
function E3(n, e) {
  Cs.INSTANCE.registerEditorContribution(n, e);
}
var xp;
(function(n) {
  function e(s) {
    return Cs.INSTANCE.getEditorCommand(s);
  }
  n.getEditorCommand = e;
  function t() {
    return Cs.INSTANCE.getEditorActions();
  }
  n.getEditorActions = t;
  function i() {
    return Cs.INSTANCE.getEditorContributions();
  }
  n.getEditorContributions = i;
  function r(s) {
    return Cs.INSTANCE.getEditorContributions().filter((a) => s.indexOf(a.id) >= 0);
  }
  n.getSomeEditorContributions = r;
  function o() {
    return Cs.INSTANCE.getDiffEditorContributions();
  }
  n.getDiffEditorContributions = o;
})(xp || (xp = {}));
const Vle = {
  EditorCommonContributions: "editor.contributions"
};
class Cs {
  constructor() {
    this.editorContributions = [], this.diffEditorContributions = [], this.editorActions = [], this.editorCommands = /* @__PURE__ */ Object.create(null);
  }
  registerEditorContribution(e, t) {
    this.editorContributions.push({ id: e, ctor: t });
  }
  getEditorContributions() {
    return this.editorContributions.slice(0);
  }
  getDiffEditorContributions() {
    return this.diffEditorContributions.slice(0);
  }
  registerEditorAction(e) {
    e.register(), this.editorActions.push(e);
  }
  getEditorActions() {
    return this.editorActions.slice(0);
  }
  registerEditorCommand(e) {
    e.register(), this.editorCommands[e.id] = e;
  }
  getEditorCommand(e) {
    return this.editorCommands[e] || null;
  }
}
Cs.INSTANCE = new Cs();
Jn.add(Vle.EditorCommonContributions, Cs.INSTANCE);
function Y_(n) {
  return n.register(), n;
}
const L3 = Y_(new dI({
  id: "undo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2104
    /* KEY_Z */
  },
  menuOpts: [{
    menuId: si.MenubarEditMenu,
    group: "1_do",
    title: b({ key: "miUndo", comment: ["&& denotes a mnemonic"] }, "&&Undo"),
    order: 1
  }, {
    menuId: si.CommandPalette,
    group: "",
    title: b("undo", "Undo"),
    order: 1
  }]
}));
Y_(new b3(L3, { id: "default:undo", precondition: void 0 }));
const D3 = Y_(new dI({
  id: "redo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2103,
    secondary: [
      3128
      /* KEY_Z */
    ],
    mac: {
      primary: 3128
      /* KEY_Z */
    }
  },
  menuOpts: [{
    menuId: si.MenubarEditMenu,
    group: "1_do",
    title: b({ key: "miRedo", comment: ["&& denotes a mnemonic"] }, "&&Redo"),
    order: 2
  }, {
    menuId: si.CommandPalette,
    group: "",
    title: b("redo", "Redo"),
    order: 1
  }]
}));
Y_(new b3(D3, { id: "default:redo", precondition: void 0 }));
const Ble = Y_(new dI({
  id: "editor.action.selectAll",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    kbExpr: null,
    primary: 2079
    /* KEY_A */
  },
  menuOpts: [{
    menuId: si.MenubarSelectionMenu,
    group: "1_basic",
    title: b({ key: "miSelectAll", comment: ["&& denotes a mnemonic"] }, "&&Select All"),
    order: 1
  }, {
    menuId: si.CommandPalette,
    group: "",
    title: b("selectAll", "Select All"),
    order: 1
  }]
}));
var Hle = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Gle = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let n_ = class {
  constructor(e, t) {
  }
  dispose() {
  }
};
n_.ID = "editor.contrib.markerDecorations";
n_ = Hle([
  Gle(1, g3)
], n_);
E3(n_.ID, n_);
class Ule {
  constructor(e, t) {
    this.chr = e, this.type = t, this.width = 0;
  }
  fulfill(e) {
    this.width = e;
  }
}
class fI {
  constructor(e, t) {
    this._bareFontInfo = e, this._requests = t, this._container = null, this._testElements = null;
  }
  read() {
    this._createDomElements(), document.body.appendChild(this._container), this._readFromDomElements(), document.body.removeChild(this._container), this._container = null, this._testElements = null;
  }
  _createDomElements() {
    const e = document.createElement("div");
    e.style.position = "absolute", e.style.top = "-50000px", e.style.width = "50000px";
    const t = document.createElement("div");
    t.style.fontFamily = this._bareFontInfo.getMassagedFontFamily(), t.style.fontWeight = this._bareFontInfo.fontWeight, t.style.fontSize = this._bareFontInfo.fontSize + "px", t.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings, t.style.lineHeight = this._bareFontInfo.lineHeight + "px", t.style.letterSpacing = this._bareFontInfo.letterSpacing + "px", e.appendChild(t);
    const i = document.createElement("div");
    i.style.fontFamily = this._bareFontInfo.getMassagedFontFamily(), i.style.fontWeight = "bold", i.style.fontSize = this._bareFontInfo.fontSize + "px", i.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings, i.style.lineHeight = this._bareFontInfo.lineHeight + "px", i.style.letterSpacing = this._bareFontInfo.letterSpacing + "px", e.appendChild(i);
    const r = document.createElement("div");
    r.style.fontFamily = this._bareFontInfo.getMassagedFontFamily(), r.style.fontWeight = this._bareFontInfo.fontWeight, r.style.fontSize = this._bareFontInfo.fontSize + "px", r.style.fontFeatureSettings = this._bareFontInfo.fontFeatureSettings, r.style.lineHeight = this._bareFontInfo.lineHeight + "px", r.style.letterSpacing = this._bareFontInfo.letterSpacing + "px", r.style.fontStyle = "italic", e.appendChild(r);
    const o = [];
    for (const s of this._requests) {
      let a;
      s.type === 0 && (a = t), s.type === 2 && (a = i), s.type === 1 && (a = r), a.appendChild(document.createElement("br"));
      const l = document.createElement("span");
      fI._render(l, s), a.appendChild(l), o.push(l);
    }
    this._container = e, this._testElements = o;
  }
  static _render(e, t) {
    if (t.chr === " ") {
      let i = "";
      for (let r = 0; r < 8; r++)
        i += i;
      e.innerText = i;
    } else {
      let i = t.chr;
      for (let r = 0; r < 8; r++)
        i += i;
      e.textContent = i;
    }
  }
  _readFromDomElements() {
    for (let e = 0, t = this._requests.length; e < t; e++) {
      const i = this._requests[e], r = this._testElements[e];
      i.fulfill(r.offsetWidth / 256);
    }
  }
}
function zle(n, e) {
  new fI(n, e).read();
}
class R3 extends Ce {
  constructor(e, t, i) {
    super(), this.referenceDomElement = e, this.changeCallback = i, this.width = -1, this.height = -1, this.resizeObserver = null, this.measureReferenceDomElementToken = -1, this.measureReferenceDomElement(!1, t);
  }
  dispose() {
    this.stopObserving(), super.dispose();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  startObserving() {
    typeof ResizeObserver < "u" ? !this.resizeObserver && this.referenceDomElement && (this.resizeObserver = new ResizeObserver((e) => {
      e && e[0] && e[0].contentRect ? this.observe({ width: e[0].contentRect.width, height: e[0].contentRect.height }) : this.observe();
    }), this.resizeObserver.observe(this.referenceDomElement)) : this.measureReferenceDomElementToken === -1 && (this.measureReferenceDomElementToken = setInterval(() => this.observe(), 100));
  }
  stopObserving() {
    this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null), this.measureReferenceDomElementToken !== -1 && (clearInterval(this.measureReferenceDomElementToken), this.measureReferenceDomElementToken = -1);
  }
  observe(e) {
    this.measureReferenceDomElement(!0, e);
  }
  measureReferenceDomElement(e, t) {
    let i = 0, r = 0;
    t ? (i = t.width, r = t.height) : this.referenceDomElement && (i = this.referenceDomElement.clientWidth, r = this.referenceDomElement.clientHeight), i = Math.max(5, i), r = Math.max(5, r), (this.width !== i || this.height !== r) && (this.width = i, this.height = r, e && this.changeCallback());
  }
}
class g2 {
  constructor() {
    this._keys = /* @__PURE__ */ Object.create(null), this._values = /* @__PURE__ */ Object.create(null);
  }
  has(e) {
    const t = e.getId();
    return !!this._values[t];
  }
  get(e) {
    const t = e.getId();
    return this._values[t];
  }
  put(e, t) {
    const i = e.getId();
    this._keys[i] = e, this._values[i] = t;
  }
  remove(e) {
    const t = e.getId();
    delete this._keys[t], delete this._values[t];
  }
  getValues() {
    return Object.keys(this._keys).map((e) => this._values[e]);
  }
}
function jle() {
  zd.INSTANCE.clearCache();
}
class zd extends Ce {
  constructor() {
    super(), this._onDidChange = this._register(new q()), this.onDidChange = this._onDidChange.event, this._cache = new g2(), this._evictUntrustedReadingsTimeout = -1;
  }
  dispose() {
    this._evictUntrustedReadingsTimeout !== -1 && (clearTimeout(this._evictUntrustedReadingsTimeout), this._evictUntrustedReadingsTimeout = -1), super.dispose();
  }
  clearCache() {
    this._cache = new g2(), this._onDidChange.fire();
  }
  _writeToCache(e, t) {
    this._cache.put(e, t), !t.isTrusted && this._evictUntrustedReadingsTimeout === -1 && (this._evictUntrustedReadingsTimeout = setTimeout(() => {
      this._evictUntrustedReadingsTimeout = -1, this._evictUntrustedReadings();
    }, 5e3));
  }
  _evictUntrustedReadings() {
    const e = this._cache.getValues();
    let t = !1;
    for (const i of e)
      i.isTrusted || (t = !0, this._cache.remove(i));
    t && this._onDidChange.fire();
  }
  readConfiguration(e) {
    if (!this._cache.has(e)) {
      let t = zd._actualReadConfiguration(e);
      (t.typicalHalfwidthCharacterWidth <= 2 || t.typicalFullwidthCharacterWidth <= 2 || t.spaceWidth <= 2 || t.maxDigitWidth <= 2) && (t = new bT({
        zoomLevel: aT(),
        pixelRatio: hb(),
        fontFamily: t.fontFamily,
        fontWeight: t.fontWeight,
        fontSize: t.fontSize,
        fontFeatureSettings: t.fontFeatureSettings,
        lineHeight: t.lineHeight,
        letterSpacing: t.letterSpacing,
        isMonospace: t.isMonospace,
        typicalHalfwidthCharacterWidth: Math.max(t.typicalHalfwidthCharacterWidth, 5),
        typicalFullwidthCharacterWidth: Math.max(t.typicalFullwidthCharacterWidth, 5),
        canUseHalfwidthRightwardsArrow: t.canUseHalfwidthRightwardsArrow,
        spaceWidth: Math.max(t.spaceWidth, 5),
        middotWidth: Math.max(t.middotWidth, 5),
        wsmiddotWidth: Math.max(t.wsmiddotWidth, 5),
        maxDigitWidth: Math.max(t.maxDigitWidth, 5)
      }, !1)), this._writeToCache(e, t);
    }
    return this._cache.get(e);
  }
  static createRequest(e, t, i, r) {
    const o = new Ule(e, t);
    return i.push(o), r && r.push(o), o;
  }
  static _actualReadConfiguration(e) {
    const t = [], i = [], r = this.createRequest("n", 0, t, i), o = this.createRequest("", 0, t, null), s = this.createRequest(" ", 0, t, i), a = this.createRequest("0", 0, t, i), l = this.createRequest("1", 0, t, i), u = this.createRequest("2", 0, t, i), c = this.createRequest("3", 0, t, i), h = this.createRequest("4", 0, t, i), d = this.createRequest("5", 0, t, i), f = this.createRequest("6", 0, t, i), p = this.createRequest("7", 0, t, i), g = this.createRequest("8", 0, t, i), _ = this.createRequest("9", 0, t, i), m = this.createRequest("", 0, t, i), v = this.createRequest("", 0, t, null), C = this.createRequest("", 0, t, i), y = this.createRequest(String.fromCharCode(11825), 0, t, null);
    this.createRequest("|", 0, t, i), this.createRequest("/", 0, t, i), this.createRequest("-", 0, t, i), this.createRequest("_", 0, t, i), this.createRequest("i", 0, t, i), this.createRequest("l", 0, t, i), this.createRequest("m", 0, t, i), this.createRequest("|", 1, t, i), this.createRequest("_", 1, t, i), this.createRequest("i", 1, t, i), this.createRequest("l", 1, t, i), this.createRequest("m", 1, t, i), this.createRequest("n", 1, t, i), this.createRequest("|", 2, t, i), this.createRequest("_", 2, t, i), this.createRequest("i", 2, t, i), this.createRequest("l", 2, t, i), this.createRequest("m", 2, t, i), this.createRequest("n", 2, t, i), zle(e, t);
    const w = Math.max(a.width, l.width, u.width, c.width, h.width, d.width, f.width, p.width, g.width, _.width);
    let L = e.fontFeatureSettings === vs.OFF;
    const S = i[0].width;
    for (let x = 1, R = i.length; L && x < R; x++) {
      const A = S - i[x].width;
      if (A < -1e-3 || A > 1e-3) {
        L = !1;
        break;
      }
    }
    let E = !0;
    L && v.width !== S && (E = !1), v.width > m.width && (E = !1);
    const D = yre() > 2e3;
    return new bT({
      zoomLevel: aT(),
      pixelRatio: hb(),
      fontFamily: e.fontFamily,
      fontWeight: e.fontWeight,
      fontSize: e.fontSize,
      fontFeatureSettings: e.fontFeatureSettings,
      lineHeight: e.lineHeight,
      letterSpacing: e.letterSpacing,
      isMonospace: L,
      typicalHalfwidthCharacterWidth: r.width,
      typicalFullwidthCharacterWidth: o.width,
      canUseHalfwidthRightwardsArrow: E,
      spaceWidth: s.width,
      middotWidth: C.width,
      wsmiddotWidth: y.width,
      maxDigitWidth: w
    }, D);
  }
}
zd.INSTANCE = new zd();
class oo extends Tb {
  constructor(e, t, i = null, r) {
    super(e, t), this.accessibilityService = r, this._elementSizeObserver = this._register(new R3(i, t.dimension, () => this._recomputeOptions())), this._register(zd.INSTANCE.onDidChange(() => this._recomputeOptions())), this._validatedOptions.get(
      10
      /* automaticLayout */
    ) && this._elementSizeObserver.startObserving(), this._register(wre((o) => this._recomputeOptions())), this._register(this.accessibilityService.onDidChangeScreenReaderOptimized(() => this._recomputeOptions())), this._recomputeOptions();
  }
  static applyFontInfoSlow(e, t) {
    e.style.fontFamily = t.getMassagedFontFamily(), e.style.fontWeight = t.fontWeight, e.style.fontSize = t.fontSize + "px", e.style.fontFeatureSettings = t.fontFeatureSettings, e.style.lineHeight = t.lineHeight + "px", e.style.letterSpacing = t.letterSpacing + "px";
  }
  static applyFontInfo(e, t) {
    e.setFontFamily(t.getMassagedFontFamily()), e.setFontWeight(t.fontWeight), e.setFontSize(t.fontSize), e.setFontFeatureSettings(t.fontFeatureSettings), e.setLineHeight(t.lineHeight), e.setLetterSpacing(t.letterSpacing);
  }
  observeReferenceElement(e) {
    this._elementSizeObserver.observe(e);
  }
  updatePixelRatio() {
    this._recomputeOptions();
  }
  static _getExtraEditorClassName() {
    let e = "";
    return !Vd && !Sre && (e += "no-user-select "), Vd && (e += "no-minimap-shadow "), kt && (e += "mac "), e;
  }
  _getEnvConfiguration() {
    return {
      extraEditorClassName: oo._getExtraEditorClassName(),
      outerWidth: this._elementSizeObserver.getWidth(),
      outerHeight: this._elementSizeObserver.getHeight(),
      emptySelectionClipboard: wd || to,
      pixelRatio: hb(),
      zoomLevel: aT(),
      accessibilitySupport: this.accessibilityService.isScreenReaderOptimized() ? 2 : this.accessibilityService.getAccessibilitySupport()
    };
  }
  readConfiguration(e) {
    return zd.INSTANCE.readConfiguration(e);
  }
}
class T3 {
  constructor(e) {
    this.domNode = e, this._maxWidth = -1, this._width = -1, this._height = -1, this._top = -1, this._left = -1, this._bottom = -1, this._right = -1, this._fontFamily = "", this._fontWeight = "", this._fontSize = -1, this._fontFeatureSettings = "", this._lineHeight = -1, this._letterSpacing = -100, this._className = "", this._display = "", this._position = "", this._visibility = "", this._backgroundColor = "", this._layerHint = !1, this._contain = "none", this._boxShadow = "";
  }
  setMaxWidth(e) {
    this._maxWidth !== e && (this._maxWidth = e, this.domNode.style.maxWidth = this._maxWidth + "px");
  }
  setWidth(e) {
    this._width !== e && (this._width = e, this.domNode.style.width = this._width + "px");
  }
  setHeight(e) {
    this._height !== e && (this._height = e, this.domNode.style.height = this._height + "px");
  }
  setTop(e) {
    this._top !== e && (this._top = e, this.domNode.style.top = this._top + "px");
  }
  unsetTop() {
    this._top !== -1 && (this._top = -1, this.domNode.style.top = "");
  }
  setLeft(e) {
    this._left !== e && (this._left = e, this.domNode.style.left = this._left + "px");
  }
  setBottom(e) {
    this._bottom !== e && (this._bottom = e, this.domNode.style.bottom = this._bottom + "px");
  }
  setRight(e) {
    this._right !== e && (this._right = e, this.domNode.style.right = this._right + "px");
  }
  setFontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this.domNode.style.fontFamily = this._fontFamily);
  }
  setFontWeight(e) {
    this._fontWeight !== e && (this._fontWeight = e, this.domNode.style.fontWeight = this._fontWeight);
  }
  setFontSize(e) {
    this._fontSize !== e && (this._fontSize = e, this.domNode.style.fontSize = this._fontSize + "px");
  }
  setFontFeatureSettings(e) {
    this._fontFeatureSettings !== e && (this._fontFeatureSettings = e, this.domNode.style.fontFeatureSettings = this._fontFeatureSettings);
  }
  setLineHeight(e) {
    this._lineHeight !== e && (this._lineHeight = e, this.domNode.style.lineHeight = this._lineHeight + "px");
  }
  setLetterSpacing(e) {
    this._letterSpacing !== e && (this._letterSpacing = e, this.domNode.style.letterSpacing = this._letterSpacing + "px");
  }
  setClassName(e) {
    this._className !== e && (this._className = e, this.domNode.className = this._className);
  }
  toggleClassName(e, t) {
    this.domNode.classList.toggle(e, t), this._className = this.domNode.className;
  }
  setDisplay(e) {
    this._display !== e && (this._display = e, this.domNode.style.display = this._display);
  }
  setPosition(e) {
    this._position !== e && (this._position = e, this.domNode.style.position = this._position);
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this.domNode.style.visibility = this._visibility);
  }
  setBackgroundColor(e) {
    this._backgroundColor !== e && (this._backgroundColor = e, this.domNode.style.backgroundColor = this._backgroundColor);
  }
  setLayerHinting(e) {
    this._layerHint !== e && (this._layerHint = e, this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "");
  }
  setBoxShadow(e) {
    this._boxShadow !== e && (this._boxShadow = e, this.domNode.style.boxShadow = e);
  }
  setContain(e) {
    this._contain !== e && (this._contain = e, this.domNode.style.contain = this._contain);
  }
  setAttribute(e, t) {
    this.domNode.setAttribute(e, t);
  }
  removeAttribute(e) {
    this.domNode.removeAttribute(e);
  }
  appendChild(e) {
    this.domNode.appendChild(e.domNode);
  }
  removeChild(e) {
    this.domNode.removeChild(e.domNode);
  }
}
function St(n) {
  return new T3(n);
}
function Bn(n, e, t) {
  let i = null, r = null;
  if (typeof t.value == "function" ? (i = "value", r = t.value, r.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters")) : typeof t.get == "function" && (i = "get", r = t.get), !r)
    throw new Error("not supported");
  const o = `$memoize$${e}`;
  t[i] = function(...s) {
    return this.hasOwnProperty(o) || Object.defineProperty(this, o, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: r.apply(this, s)
    }), this[o];
  };
}
var $le = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Ri;
(function(n) {
  n.Tap = "-monaco-gesturetap", n.Change = "-monaco-gesturechange", n.Start = "-monaco-gesturestart", n.End = "-monaco-gesturesend", n.Contextmenu = "-monaco-gesturecontextmenu";
})(Ri || (Ri = {}));
class ri extends Ce {
  constructor() {
    super(), this.dispatched = !1, this.activeTouches = {}, this.handle = null, this.targets = [], this.ignoreTargets = [], this._lastSetTapCountTime = 0, this._register(be(document, "touchstart", (e) => this.onTouchStart(e), { passive: !1 })), this._register(be(document, "touchend", (e) => this.onTouchEnd(e))), this._register(be(document, "touchmove", (e) => this.onTouchMove(e), { passive: !1 }));
  }
  static addTarget(e) {
    return ri.isTouchDevice() ? (ri.INSTANCE || (ri.INSTANCE = new ri()), ri.INSTANCE.targets.push(e), {
      dispose: () => {
        ri.INSTANCE.targets = ri.INSTANCE.targets.filter((t) => t !== e);
      }
    }) : Ce.None;
  }
  static ignoreTarget(e) {
    return ri.isTouchDevice() ? (ri.INSTANCE || (ri.INSTANCE = new ri()), ri.INSTANCE.ignoreTargets.push(e), {
      dispose: () => {
        ri.INSTANCE.ignoreTargets = ri.INSTANCE.ignoreTargets.filter((t) => t !== e);
      }
    }) : Ce.None;
  }
  static isTouchDevice() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0;
  }
  dispose() {
    this.handle && (this.handle.dispose(), this.handle = null), super.dispose();
  }
  onTouchStart(e) {
    let t = Date.now();
    this.handle && (this.handle.dispose(), this.handle = null);
    for (let i = 0, r = e.targetTouches.length; i < r; i++) {
      let o = e.targetTouches.item(i);
      this.activeTouches[o.identifier] = {
        id: o.identifier,
        initialTarget: o.target,
        initialTimeStamp: t,
        initialPageX: o.pageX,
        initialPageY: o.pageY,
        rollingTimestamps: [t],
        rollingPageX: [o.pageX],
        rollingPageY: [o.pageY]
      };
      let s = this.newGestureEvent(Ri.Start, o.target);
      s.pageX = o.pageX, s.pageY = o.pageY, this.dispatchEvent(s);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
  onTouchEnd(e) {
    let t = Date.now(), i = Object.keys(this.activeTouches).length;
    for (let r = 0, o = e.changedTouches.length; r < o; r++) {
      let s = e.changedTouches.item(r);
      if (!this.activeTouches.hasOwnProperty(String(s.identifier))) {
        console.warn("move of an UNKNOWN touch", s);
        continue;
      }
      let a = this.activeTouches[s.identifier], l = Date.now() - a.initialTimeStamp;
      if (l < ri.HOLD_DELAY && Math.abs(a.initialPageX - us(a.rollingPageX)) < 30 && Math.abs(a.initialPageY - us(a.rollingPageY)) < 30) {
        let u = this.newGestureEvent(Ri.Tap, a.initialTarget);
        u.pageX = us(a.rollingPageX), u.pageY = us(a.rollingPageY), this.dispatchEvent(u);
      } else if (l >= ri.HOLD_DELAY && Math.abs(a.initialPageX - us(a.rollingPageX)) < 30 && Math.abs(a.initialPageY - us(a.rollingPageY)) < 30) {
        let u = this.newGestureEvent(Ri.Contextmenu, a.initialTarget);
        u.pageX = us(a.rollingPageX), u.pageY = us(a.rollingPageY), this.dispatchEvent(u);
      } else if (i === 1) {
        let u = us(a.rollingPageX), c = us(a.rollingPageY), h = us(a.rollingTimestamps) - a.rollingTimestamps[0], d = u - a.rollingPageX[0], f = c - a.rollingPageY[0];
        const p = this.targets.filter((g) => a.initialTarget instanceof Node && g.contains(a.initialTarget));
        this.inertia(
          p,
          t,
          // time now
          Math.abs(d) / h,
          // speed
          d > 0 ? 1 : -1,
          // x direction
          u,
          // x now
          Math.abs(f) / h,
          // y speed
          f > 0 ? 1 : -1,
          // y direction
          c
          // y now
        );
      }
      this.dispatchEvent(this.newGestureEvent(Ri.End, a.initialTarget)), delete this.activeTouches[s.identifier];
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
  newGestureEvent(e, t) {
    let i = document.createEvent("CustomEvent");
    return i.initEvent(e, !1, !0), i.initialTarget = t, i.tapCount = 0, i;
  }
  dispatchEvent(e) {
    if (e.type === Ri.Tap) {
      const t = (/* @__PURE__ */ new Date()).getTime();
      let i = 0;
      t - this._lastSetTapCountTime > ri.CLEAR_TAP_COUNT_TIME ? i = 1 : i = 2, this._lastSetTapCountTime = t, e.tapCount = i;
    } else
      (e.type === Ri.Change || e.type === Ri.Contextmenu) && (this._lastSetTapCountTime = 0);
    for (let t = 0; t < this.ignoreTargets.length; t++)
      if (e.initialTarget instanceof Node && this.ignoreTargets[t].contains(e.initialTarget))
        return;
    this.targets.forEach((t) => {
      e.initialTarget instanceof Node && t.contains(e.initialTarget) && (t.dispatchEvent(e), this.dispatched = !0);
    });
  }
  inertia(e, t, i, r, o, s, a, l) {
    this.handle = Zl(() => {
      let u = Date.now(), c = u - t, h = 0, d = 0, f = !0;
      i += ri.SCROLL_FRICTION * c, s += ri.SCROLL_FRICTION * c, i > 0 && (f = !1, h = r * i * c), s > 0 && (f = !1, d = a * s * c);
      let p = this.newGestureEvent(Ri.Change);
      p.translationX = h, p.translationY = d, e.forEach((g) => g.dispatchEvent(p)), f || this.inertia(e, u, i, r, o + h, s, a, l + d);
    });
  }
  onTouchMove(e) {
    let t = Date.now();
    for (let i = 0, r = e.changedTouches.length; i < r; i++) {
      let o = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(o.identifier))) {
        console.warn("end of an UNKNOWN touch", o);
        continue;
      }
      let s = this.activeTouches[o.identifier], a = this.newGestureEvent(Ri.Change, s.initialTarget);
      a.translationX = o.pageX - us(s.rollingPageX), a.translationY = o.pageY - us(s.rollingPageY), a.pageX = o.pageX, a.pageY = o.pageY, this.dispatchEvent(a), s.rollingPageX.length > 3 && (s.rollingPageX.shift(), s.rollingPageY.shift(), s.rollingTimestamps.shift()), s.rollingPageX.push(o.pageX), s.rollingPageY.push(o.pageY), s.rollingTimestamps.push(t);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
}
ri.SCROLL_FRICTION = -5e-3;
ri.HOLD_DELAY = 700;
ri.CLEAR_TAP_COUNT_TIME = 400;
$le([
  Bn
], ri, "isTouchDevice", null);
function pI(n, e) {
  let t = new pa(e);
  return t.preventDefault(), {
    leftButton: t.leftButton,
    buttons: t.buttons,
    posx: t.posx,
    posy: t.posy
  };
}
class DE {
  constructor() {
    this._hooks = new dt(), this._mouseMoveEventMerger = null, this._mouseMoveCallback = null, this._onStopCallback = null;
  }
  dispose() {
    this.stopMonitoring(!1), this._hooks.dispose();
  }
  stopMonitoring(e, t) {
    if (!this.isMonitoring())
      return;
    this._hooks.clear(), this._mouseMoveEventMerger = null, this._mouseMoveCallback = null;
    const i = this._onStopCallback;
    this._onStopCallback = null, e && i && i(t);
  }
  isMonitoring() {
    return !!this._mouseMoveEventMerger;
  }
  startMonitoring(e, t, i, r, o) {
    if (this.isMonitoring())
      return;
    this._mouseMoveEventMerger = i, this._mouseMoveCallback = r, this._onStopCallback = o;
    const s = cT.getSameOriginWindowChain(), a = Tg ? "pointermove" : "mousemove", l = "mouseup", u = s.map((h) => h.window.document), c = U_(e);
    c && u.unshift(c);
    for (const h of u)
      this._hooks.add(MN(h, a, (d) => {
        if (d.buttons !== t) {
          this.stopMonitoring(!0);
          return;
        }
        this._mouseMoveCallback(d);
      }, (d, f) => this._mouseMoveEventMerger(d, f))), this._hooks.add(be(h, l, (d) => this.stopMonitoring(!0)));
    if (cT.hasDifferentOriginAncestor()) {
      let h = s[s.length - 1];
      this._hooks.add(be(h.window.document, "mouseout", (d) => {
        new pa(d).target.tagName.toLowerCase() === "html" && this.stopMonitoring(!0);
      })), this._hooks.add(be(h.window.document, "mouseover", (d) => {
        new pa(d).target.tagName.toLowerCase() === "html" && this.stopMonitoring(!0);
      })), this._hooks.add(be(h.window.document.body, "mouseleave", (d) => {
        this.stopMonitoring(!0);
      }));
    }
  }
}
class gI {
  constructor(e, t) {
    this.x = e, this.y = t;
  }
  toClientCoordinates() {
    return new O3(this.x - Ku.scrollX, this.y - Ku.scrollY);
  }
}
class O3 {
  constructor(e, t) {
    this.clientX = e, this.clientY = t;
  }
  toPageCoordinates() {
    return new gI(this.clientX + Ku.scrollX, this.clientY + Ku.scrollY);
  }
}
class Kle {
  constructor(e, t, i, r) {
    this.x = e, this.y = t, this.width = i, this.height = r;
  }
}
function x3(n) {
  const e = qa(n);
  return new Kle(e.left, e.top, e.width, e.height);
}
class jd extends pa {
  constructor(e, t) {
    super(e), this.pos = new gI(this.posx, this.posy), this.editorPos = x3(t);
  }
}
class qle {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new jd(e, this._editorViewDomNode);
  }
  onContextMenu(e, t) {
    return be(e, "contextmenu", (i) => {
      t(this._create(i));
    });
  }
  onMouseUp(e, t) {
    return be(e, "mouseup", (i) => {
      t(this._create(i));
    });
  }
  onMouseDown(e, t) {
    return be(e, "mousedown", (i) => {
      t(this._create(i));
    });
  }
  onMouseLeave(e, t) {
    return i5(e, (i) => {
      t(this._create(i));
    });
  }
  onMouseMoveThrottled(e, t, i, r) {
    return MN(e, "mousemove", t, (s, a) => i(s, this._create(a)), r);
  }
}
class Yle {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new jd(e, this._editorViewDomNode);
  }
  onPointerUp(e, t) {
    return be(e, "pointerup", (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return be(e, "pointerdown", (i) => {
      t(this._create(i));
    });
  }
  onPointerLeave(e, t) {
    return Bre(e, (i) => {
      t(this._create(i));
    });
  }
  onPointerMoveThrottled(e, t, i, r) {
    return MN(e, "pointermove", t, (s, a) => i(s, this._create(a)), r);
  }
}
class Xle extends Ce {
  constructor(e) {
    super(), this._editorViewDomNode = e, this._globalMouseMoveMonitor = this._register(new DE()), this._keydownListener = null;
  }
  startMonitoring(e, t, i, r, o) {
    this._keydownListener = io(document, "keydown", (a) => {
      a.toKeybinding().isModifierKey() || this._globalMouseMoveMonitor.stopMonitoring(!0, a.browserEvent);
    }, !0);
    const s = (a, l) => i(a, new jd(l, this._editorViewDomNode));
    this._globalMouseMoveMonitor.startMonitoring(e, t, s, r, (a) => {
      this._keydownListener.dispose(), o(a);
    });
  }
  stopMonitoring() {
    this._globalMouseMoveMonitor.stopMonitoring(!0);
  }
}
class X_ extends Ce {
  constructor() {
    super(), this._shouldRender = !0;
  }
  shouldRender() {
    return this._shouldRender;
  }
  forceShouldRender() {
    this._shouldRender = !0;
  }
  setShouldRender() {
    this._shouldRender = !0;
  }
  onDidRender() {
    this._shouldRender = !1;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return !1;
  }
  onCompositionEnd(e) {
    return !1;
  }
  onConfigurationChanged(e) {
    return !1;
  }
  onCursorStateChanged(e) {
    return !1;
  }
  onDecorationsChanged(e) {
    return !1;
  }
  onFlushed(e) {
    return !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  onLanguageConfigurationChanged(e) {
    return !1;
  }
  onLineMappingChanged(e) {
    return !1;
  }
  onLinesChanged(e) {
    return !1;
  }
  onLinesDeleted(e) {
    return !1;
  }
  onLinesInserted(e) {
    return !1;
  }
  onRevealRangeRequest(e) {
    return !1;
  }
  onScrollChanged(e) {
    return !1;
  }
  onThemeChanged(e) {
    return !1;
  }
  onTokensChanged(e) {
    return !1;
  }
  onTokensColorsChanged(e) {
    return !1;
  }
  onZonesChanged(e) {
    return !1;
  }
  // --- end event handlers
  handleEvents(e) {
    let t = !1;
    for (let i = 0, r = e.length; i < r; i++) {
      let o = e[i];
      switch (o.type) {
        case 0:
          this.onCompositionStart(o) && (t = !0);
          break;
        case 1:
          this.onCompositionEnd(o) && (t = !0);
          break;
        case 2:
          this.onConfigurationChanged(o) && (t = !0);
          break;
        case 3:
          this.onCursorStateChanged(o) && (t = !0);
          break;
        case 4:
          this.onDecorationsChanged(o) && (t = !0);
          break;
        case 5:
          this.onFlushed(o) && (t = !0);
          break;
        case 6:
          this.onFocusChanged(o) && (t = !0);
          break;
        case 7:
          this.onLanguageConfigurationChanged(o) && (t = !0);
          break;
        case 8:
          this.onLineMappingChanged(o) && (t = !0);
          break;
        case 9:
          this.onLinesChanged(o) && (t = !0);
          break;
        case 10:
          this.onLinesDeleted(o) && (t = !0);
          break;
        case 11:
          this.onLinesInserted(o) && (t = !0);
          break;
        case 12:
          this.onRevealRangeRequest(o) && (t = !0);
          break;
        case 13:
          this.onScrollChanged(o) && (t = !0);
          break;
        case 15:
          this.onTokensChanged(o) && (t = !0);
          break;
        case 14:
          this.onThemeChanged(o) && (t = !0);
          break;
        case 16:
          this.onTokensColorsChanged(o) && (t = !0);
          break;
        case 17:
          this.onZonesChanged(o) && (t = !0);
          break;
        default:
          console.info("View received unknown event: "), console.info(o);
      }
    }
    t && (this._shouldRender = !0);
  }
}
class Fs extends X_ {
  constructor(e) {
    super(), this._context = e, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
}
class Ql {
  static write(e, t) {
    e instanceof T3, e.setAttribute("data-mprt", String(t));
  }
  static read(e) {
    const t = e.getAttribute("data-mprt");
    return t === null ? 0 : parseInt(t, 10);
  }
  static collect(e, t) {
    let i = [], r = 0;
    for (; e && e !== document.body && e !== t; )
      e.nodeType === e.ELEMENT_NODE && (i[r++] = this.read(e)), e = e.parentElement;
    const o = new Uint8Array(r);
    for (let s = 0; s < r; s++)
      o[s] = i[r - s - 1];
    return o;
  }
}
class Zle {
  constructor(e, t) {
    this._viewLayout = e, this.viewportData = t, this.scrollWidth = this._viewLayout.getScrollWidth(), this.scrollHeight = this._viewLayout.getScrollHeight(), this.visibleRange = this.viewportData.visibleRange, this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
    const i = this._viewLayout.getCurrentViewport();
    this.scrollTop = i.top, this.scrollLeft = i.left, this.viewportWidth = i.width, this.viewportHeight = i.height;
  }
  getScrolledTopFromAbsoluteTop(e) {
    return e - this.scrollTop;
  }
  getVerticalOffsetForLineNumber(e) {
    return this._viewLayout.getVerticalOffsetForLineNumber(e);
  }
  getDecorationsInViewport() {
    return this.viewportData.getDecorationsInViewport();
  }
}
class Qle extends Zle {
  constructor(e, t, i) {
    super(e, t), this._viewLines = i;
  }
  linesVisibleRangesForRange(e, t) {
    return this._viewLines.linesVisibleRangesForRange(e, t);
  }
  visibleRangeForPosition(e) {
    return this._viewLines.visibleRangeForPosition(e);
  }
}
class Jle {
  constructor(e, t, i) {
    this.outsideRenderedLine = e, this.lineNumber = t, this.ranges = i;
  }
}
class th {
  constructor(e, t) {
    this.left = Math.round(e), this.width = Math.round(t);
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
}
class eue {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.left = Math.round(t);
  }
}
class tue {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.ranges = t;
  }
}
class m2 {
  constructor(e, t) {
    this.left = e, this.width = t;
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
  static compare(e, t) {
    return e.left - t.left;
  }
}
class ND {
  static _createRange() {
    return this._handyReadyRange || (this._handyReadyRange = document.createRange()), this._handyReadyRange;
  }
  static _detachRange(e, t) {
    e.selectNodeContents(t);
  }
  static _readClientRects(e, t, i, r, o) {
    const s = this._createRange();
    try {
      return s.setStart(e, t), s.setEnd(i, r), s.getClientRects();
    } catch {
      return null;
    } finally {
      this._detachRange(s, o);
    }
  }
  static _mergeAdjacentRanges(e) {
    if (e.length === 1)
      return [new th(e[0].left, e[0].width)];
    e.sort(m2.compare);
    let t = [], i = 0, r = e[0].left, o = e[0].width;
    for (let s = 1, a = e.length; s < a; s++) {
      const l = e[s], u = l.left, c = l.width;
      r + o + 0.9 >= u ? o = Math.max(o, u + c - r) : (t[i++] = new th(r, o), r = u, o = c);
    }
    return t[i++] = new th(r, o), t;
  }
  static _createHorizontalRangesFromClientRects(e, t) {
    if (!e || e.length === 0)
      return null;
    const i = [];
    for (let r = 0, o = e.length; r < o; r++) {
      const s = e[r];
      i[r] = new m2(Math.max(0, s.left - t), s.width);
    }
    return this._mergeAdjacentRanges(i);
  }
  static readHorizontalRanges(e, t, i, r, o, s, a) {
    const u = e.children.length - 1;
    if (0 > u)
      return null;
    if (t = Math.min(u, Math.max(0, t)), r = Math.min(u, Math.max(0, r)), t === r && i === o && i === 0 && !e.children[t].firstChild) {
      const f = e.children[t].getClientRects();
      return this._createHorizontalRangesFromClientRects(f, s);
    }
    t !== r && r > 0 && o === 0 && (r--, o = 1073741824);
    let c = e.children[t].firstChild, h = e.children[r].firstChild;
    if ((!c || !h) && (!c && i === 0 && t > 0 && (c = e.children[t - 1].firstChild, i = 1073741824), !h && o === 0 && r > 0 && (h = e.children[r - 1].firstChild, o = 1073741824)), !c || !h)
      return null;
    i = Math.min(c.textContent.length, Math.max(0, i)), o = Math.min(h.textContent.length, Math.max(0, o));
    const d = this._readClientRects(c, i, h, o, a);
    return this._createHorizontalRangesFromClientRects(d, s);
  }
}
const iue = function() {
  return cv ? !0 : !(Is || to || Vd);
}();
let Np = !0;
class v2 {
  constructor(e, t) {
    this._domNode = e, this._clientRectDeltaLeft = 0, this._clientRectDeltaLeftRead = !1, this.endNode = t;
  }
  get clientRectDeltaLeft() {
    return this._clientRectDeltaLeftRead || (this._clientRectDeltaLeftRead = !0, this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left), this._clientRectDeltaLeft;
  }
}
class _2 {
  constructor(e, t) {
    this.themeType = t;
    const i = e.options, r = i.get(
      40
      /* fontInfo */
    );
    this.renderWhitespace = i.get(
      86
      /* renderWhitespace */
    ), this.renderControlCharacters = i.get(
      80
      /* renderControlCharacters */
    ), this.spaceWidth = r.spaceWidth, this.middotWidth = r.middotWidth, this.wsmiddotWidth = r.wsmiddotWidth, this.useMonospaceOptimizations = r.isMonospace && !i.get(
      27
      /* disableMonospaceOptimizations */
    ), this.canUseHalfwidthRightwardsArrow = r.canUseHalfwidthRightwardsArrow, this.lineHeight = i.get(
      56
      /* lineHeight */
    ), this.stopRenderingLineAfter = i.get(
      103
      /* stopRenderingLineAfter */
    ), this.fontLigatures = i.get(
      41
      /* fontLigatures */
    );
  }
  equals(e) {
    return this.themeType === e.themeType && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.fontLigatures === e.fontLigatures;
  }
}
class Wl {
  constructor(e) {
    this._options = e, this._isMaybeInvalid = !0, this._renderedViewLine = null;
  }
  // --- begin IVisibleLineData
  getDomNode() {
    return this._renderedViewLine && this._renderedViewLine.domNode ? this._renderedViewLine.domNode.domNode : null;
  }
  setDomNode(e) {
    if (this._renderedViewLine)
      this._renderedViewLine.domNode = St(e);
    else
      throw new Error("I have no rendered view line to set the dom node to...");
  }
  onContentChanged() {
    this._isMaybeInvalid = !0;
  }
  onTokensChanged() {
    this._isMaybeInvalid = !0;
  }
  onDecorationsChanged() {
    this._isMaybeInvalid = !0;
  }
  onOptionsChanged(e) {
    this._isMaybeInvalid = !0, this._options = e;
  }
  onSelectionChanged() {
    return this._options.themeType === jl.HIGH_CONTRAST || this._options.renderWhitespace === "selection" ? (this._isMaybeInvalid = !0, !0) : !1;
  }
  renderLine(e, t, i, r) {
    if (this._isMaybeInvalid === !1)
      return !1;
    this._isMaybeInvalid = !1;
    const o = i.getViewLineRenderingData(e), s = this._options, a = ga.filter(o.inlineDecorations, e, o.minColumn, o.maxColumn);
    let l = null;
    if (s.themeType === jl.HIGH_CONTRAST || this._options.renderWhitespace === "selection") {
      const d = i.selections;
      for (const f of d) {
        if (f.endLineNumber < e || f.startLineNumber > e)
          continue;
        const p = f.startLineNumber === e ? f.startColumn : o.minColumn, g = f.endLineNumber === e ? f.endColumn : o.maxColumn;
        p < g && (s.themeType === jl.HIGH_CONTRAST || this._options.renderWhitespace !== "selection" ? a.push(new ga(
          p,
          g,
          "inline-selected-text",
          0
          /* Regular */
        )) : (l || (l = []), l.push(new _ae(p - 1, g - 1))));
      }
    }
    const u = new Pg(s.useMonospaceOptimizations, s.canUseHalfwidthRightwardsArrow, o.content, o.continuesWithWrappedLine, o.isBasicASCII, o.containsRTL, o.minColumn - 1, o.tokens, a, o.tabSize, o.startVisibleColumn, s.spaceWidth, s.middotWidth, s.wsmiddotWidth, s.stopRenderingLineAfter, s.renderWhitespace, s.renderControlCharacters, s.fontLigatures !== vs.OFF, l);
    if (this._renderedViewLine && this._renderedViewLine.input.equals(u))
      return !1;
    r.appendASCIIString('<div style="top:'), r.appendASCIIString(String(t)), r.appendASCIIString("px;height:"), r.appendASCIIString(String(this._options.lineHeight)), r.appendASCIIString('px;" class="'), r.appendASCIIString(Wl.CLASS_NAME), r.appendASCIIString('">');
    const c = nI(u, r);
    r.appendASCIIString("</div>");
    let h = null;
    return Np && iue && o.isBasicASCII && s.useMonospaceOptimizations && c.containsForeignElements === 0 && o.content.length < 300 && u.lineTokens.getCount() < 100 && (h = new yy(this._renderedViewLine ? this._renderedViewLine.domNode : null, u, c.characterMapping)), h || (h = I3(this._renderedViewLine ? this._renderedViewLine.domNode : null, u, c.characterMapping, c.containsRTL, c.containsForeignElements)), this._renderedViewLine = h, !0;
  }
  layoutLine(e, t) {
    this._renderedViewLine && this._renderedViewLine.domNode && (this._renderedViewLine.domNode.setTop(t), this._renderedViewLine.domNode.setHeight(this._options.lineHeight));
  }
  // --- end IVisibleLineData
  getWidth() {
    return this._renderedViewLine ? this._renderedViewLine.getWidth() : 0;
  }
  getWidthIsFast() {
    return this._renderedViewLine ? this._renderedViewLine.getWidthIsFast() : !0;
  }
  needsMonospaceFontCheck() {
    return this._renderedViewLine ? this._renderedViewLine instanceof yy : !1;
  }
  monospaceAssumptionsAreValid() {
    return this._renderedViewLine && this._renderedViewLine instanceof yy ? this._renderedViewLine.monospaceAssumptionsAreValid() : Np;
  }
  onMonospaceAssumptionsInvalidated() {
    this._renderedViewLine && this._renderedViewLine instanceof yy && (this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine());
  }
  getVisibleRangesForRange(e, t, i) {
    if (!this._renderedViewLine)
      return null;
    e = e | 0, t = t | 0, e = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, e)), t = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, t));
    const r = this._renderedViewLine.input.stopRenderingLineAfter | 0;
    let o = !1;
    r !== -1 && e > r + 1 && t > r + 1 && (o = !0), r !== -1 && e > r + 1 && (e = r + 1), r !== -1 && t > r + 1 && (t = r + 1);
    const s = this._renderedViewLine.getVisibleRangesForRange(e, t, i);
    return s && s.length > 0 ? new tue(o, s) : null;
  }
  getColumnOfNodeOffset(e, t, i) {
    return this._renderedViewLine ? this._renderedViewLine.getColumnOfNodeOffset(e, t, i) : 1;
  }
}
Wl.CLASS_NAME = "view-line";
class yy {
  constructor(e, t, i) {
    this.domNode = e, this.input = t, this._characterMapping = i, this._charWidth = t.spaceWidth;
  }
  getWidth() {
    return this._getCharPosition(this._characterMapping.length);
  }
  getWidthIsFast() {
    return !0;
  }
  monospaceAssumptionsAreValid() {
    if (!this.domNode)
      return Np;
    const e = this.getWidth(), t = this.domNode.domNode.firstChild.offsetWidth;
    return Math.abs(e - t) >= 2 && (console.warn("monospace assumptions have been violated, therefore disabling monospace optimizations!"), Np = !1), Np;
  }
  toSlowRenderedLine() {
    return I3(
      this.domNode,
      this.input,
      this._characterMapping,
      !1,
      0
      /* None */
    );
  }
  getVisibleRangesForRange(e, t, i) {
    const r = this._getCharPosition(e), o = this._getCharPosition(t);
    return [new th(r, o - r)];
  }
  _getCharPosition(e) {
    const t = this._characterMapping.getAbsoluteOffsets();
    return t.length === 0 ? 0 : Math.round(this._charWidth * t[e - 1]);
  }
  getColumnOfNodeOffset(e, t, i) {
    const r = t.textContent.length;
    let o = -1;
    for (; t; )
      t = t.previousSibling, o++;
    return this._characterMapping.partDataToCharOffset(o, r, i) + 1;
  }
}
class N3 {
  constructor(e, t, i, r, o) {
    if (this.domNode = e, this.input = t, this._characterMapping = i, this._isWhitespaceOnly = /^\s*$/.test(t.lineContent), this._containsForeignElements = o, this._cachedWidth = -1, this._pixelOffsetCache = null, !r || this._characterMapping.length === 0) {
      this._pixelOffsetCache = new Int32Array(Math.max(2, this._characterMapping.length + 1));
      for (let s = 0, a = this._characterMapping.length; s <= a; s++)
        this._pixelOffsetCache[s] = -1;
    }
  }
  // --- Reading from the DOM methods
  _getReadingTarget(e) {
    return e.domNode.firstChild;
  }
  /**
   * Width of the line in pixels
   */
  getWidth() {
    return this.domNode ? (this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth), this._cachedWidth) : 0;
  }
  getWidthIsFast() {
    return this._cachedWidth !== -1;
  }
  /**
   * Visible ranges for a model range
   */
  getVisibleRangesForRange(e, t, i) {
    if (!this.domNode)
      return null;
    if (this._pixelOffsetCache !== null) {
      const r = this._readPixelOffset(this.domNode, e, i);
      if (r === -1)
        return null;
      const o = this._readPixelOffset(this.domNode, t, i);
      return o === -1 ? null : [new th(r, o - r)];
    }
    return this._readVisibleRangesForRange(this.domNode, e, t, i);
  }
  _readVisibleRangesForRange(e, t, i, r) {
    if (t === i) {
      const o = this._readPixelOffset(e, t, r);
      return o === -1 ? null : [new th(o, 0)];
    } else
      return this._readRawVisibleRangesForRange(e, t, i, r);
  }
  _readPixelOffset(e, t, i) {
    if (this._characterMapping.length === 0) {
      if (this._containsForeignElements === 0 || this._containsForeignElements === 2)
        return 0;
      if (this._containsForeignElements === 1)
        return this.getWidth();
      const r = this._getReadingTarget(e);
      return r.firstChild ? r.firstChild.offsetWidth : 0;
    }
    if (this._pixelOffsetCache !== null) {
      const r = this._pixelOffsetCache[t];
      if (r !== -1)
        return r;
      const o = this._actualReadPixelOffset(e, t, i);
      return this._pixelOffsetCache[t] = o, o;
    }
    return this._actualReadPixelOffset(e, t, i);
  }
  _actualReadPixelOffset(e, t, i) {
    if (this._characterMapping.length === 0) {
      const u = ND.readHorizontalRanges(this._getReadingTarget(e), 0, 0, 0, 0, i.clientRectDeltaLeft, i.endNode);
      return !u || u.length === 0 ? -1 : u[0].left;
    }
    if (t === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0)
      return this.getWidth();
    const r = this._characterMapping.charOffsetToPartData(t - 1), o = Ho.getPartIndex(r), s = Ho.getCharIndex(r), a = ND.readHorizontalRanges(this._getReadingTarget(e), o, s, o, s, i.clientRectDeltaLeft, i.endNode);
    if (!a || a.length === 0)
      return -1;
    const l = a[0].left;
    if (this.input.isBasicASCII) {
      const u = this._characterMapping.getAbsoluteOffsets(), c = Math.round(this.input.spaceWidth * u[t - 1]);
      if (Math.abs(c - l) <= 1)
        return c;
    }
    return l;
  }
  _readRawVisibleRangesForRange(e, t, i, r) {
    if (t === 1 && i === this._characterMapping.length)
      return [new th(0, this.getWidth())];
    const o = this._characterMapping.charOffsetToPartData(t - 1), s = Ho.getPartIndex(o), a = Ho.getCharIndex(o), l = this._characterMapping.charOffsetToPartData(i - 1), u = Ho.getPartIndex(l), c = Ho.getCharIndex(l);
    return ND.readHorizontalRanges(this._getReadingTarget(e), s, a, u, c, r.clientRectDeltaLeft, r.endNode);
  }
  /**
   * Returns the column for the text found at a specific offset inside a rendered dom node
   */
  getColumnOfNodeOffset(e, t, i) {
    const r = t.textContent.length;
    let o = -1;
    for (; t; )
      t = t.previousSibling, o++;
    return this._characterMapping.partDataToCharOffset(o, r, i) + 1;
  }
}
class nue extends N3 {
  _readVisibleRangesForRange(e, t, i, r) {
    const o = super._readVisibleRangesForRange(e, t, i, r);
    if (!o || o.length === 0 || t === i || t === 1 && i === this._characterMapping.length)
      return o;
    if (!this.input.containsRTL) {
      const s = this._readPixelOffset(e, i, r);
      if (s !== -1) {
        const a = o[o.length - 1];
        a.left < s && (a.width = s - a.left);
      }
    }
    return o;
  }
}
const I3 = function() {
  return wd ? rue : oue;
}();
function rue(n, e, t, i, r) {
  return new nue(n, e, t, i, r);
}
function oue(n, e, t, i, r) {
  return new N3(n, e, t, i, r);
}
function wy(n) {
  return n.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
}
class $n {
  constructor(e, t, i, r) {
    this.oldPosition = e, this.oldText = t, this.newPosition = i, this.newText = r;
  }
  get oldLength() {
    return this.oldText.length;
  }
  get oldEnd() {
    return this.oldPosition + this.oldText.length;
  }
  get newLength() {
    return this.newText.length;
  }
  get newEnd() {
    return this.newPosition + this.newText.length;
  }
  toString() {
    return this.oldText.length === 0 ? `(insert@${this.oldPosition} "${wy(this.newText)}")` : this.newText.length === 0 ? `(delete@${this.oldPosition} "${wy(this.oldText)}")` : `(replace@${this.oldPosition} "${wy(this.oldText)}" with "${wy(this.newText)}")`;
  }
  static _writeStringSize(e) {
    return 4 + 2 * e.length;
  }
  static _writeString(e, t, i) {
    const r = t.length;
    Ma(e, r, i), i += 4;
    for (let o = 0; o < r; o++)
      Soe(e, t.charCodeAt(o), i), i += 2;
    return i;
  }
  static _readString(e, t) {
    const i = Aa(e, t);
    return t += 4, FT(e, t, i);
  }
  writeSize() {
    return 4 + 4 + $n._writeStringSize(this.oldText) + $n._writeStringSize(this.newText);
  }
  write(e, t) {
    return Ma(e, this.oldPosition, t), t += 4, Ma(e, this.newPosition, t), t += 4, t = $n._writeString(e, this.oldText, t), t = $n._writeString(e, this.newText, t), t;
  }
  static read(e, t, i) {
    const r = Aa(e, t);
    t += 4;
    const o = Aa(e, t);
    t += 4;
    const s = $n._readString(e, t);
    t += $n._writeStringSize(s);
    const a = $n._readString(e, t);
    return t += $n._writeStringSize(a), i.push(new $n(r, s, o, a)), t;
  }
}
function sue(n, e) {
  return n === null || n.length === 0 ? e : new Pl(n, e).compress();
}
class Pl {
  constructor(e, t) {
    this._prevEdits = e, this._currEdits = t, this._result = [], this._resultLen = 0, this._prevLen = this._prevEdits.length, this._prevDeltaOffset = 0, this._currLen = this._currEdits.length, this._currDeltaOffset = 0;
  }
  compress() {
    let e = 0, t = 0, i = this._getPrev(e), r = this._getCurr(t);
    for (; e < this._prevLen || t < this._currLen; ) {
      if (i === null) {
        this._acceptCurr(r), r = this._getCurr(++t);
        continue;
      }
      if (r === null) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (r.oldEnd <= i.newPosition) {
        this._acceptCurr(r), r = this._getCurr(++t);
        continue;
      }
      if (i.newEnd <= r.oldPosition) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (r.oldPosition < i.newPosition) {
        const [u, c] = Pl._splitCurr(r, i.newPosition - r.oldPosition);
        this._acceptCurr(u), r = c;
        continue;
      }
      if (i.newPosition < r.oldPosition) {
        const [u, c] = Pl._splitPrev(i, r.oldPosition - i.newPosition);
        this._acceptPrev(u), i = c;
        continue;
      }
      let a, l;
      if (r.oldEnd === i.newEnd)
        a = i, l = r, i = this._getPrev(++e), r = this._getCurr(++t);
      else if (r.oldEnd < i.newEnd) {
        const [u, c] = Pl._splitPrev(i, r.oldLength);
        a = u, l = r, i = c, r = this._getCurr(++t);
      } else {
        const [u, c] = Pl._splitCurr(r, i.newLength);
        a = i, l = u, i = this._getPrev(++e), r = c;
      }
      this._result[this._resultLen++] = new $n(a.oldPosition, a.oldText, l.newPosition, l.newText), this._prevDeltaOffset += a.newLength - a.oldLength, this._currDeltaOffset += l.newLength - l.oldLength;
    }
    const o = Pl._merge(this._result);
    return Pl._removeNoOps(o);
  }
  _acceptCurr(e) {
    this._result[this._resultLen++] = Pl._rebaseCurr(this._prevDeltaOffset, e), this._currDeltaOffset += e.newLength - e.oldLength;
  }
  _getCurr(e) {
    return e < this._currLen ? this._currEdits[e] : null;
  }
  _acceptPrev(e) {
    this._result[this._resultLen++] = Pl._rebasePrev(this._currDeltaOffset, e), this._prevDeltaOffset += e.newLength - e.oldLength;
  }
  _getPrev(e) {
    return e < this._prevLen ? this._prevEdits[e] : null;
  }
  static _rebaseCurr(e, t) {
    return new $n(t.oldPosition - e, t.oldText, t.newPosition, t.newText);
  }
  static _rebasePrev(e, t) {
    return new $n(t.oldPosition, t.oldText, t.newPosition + e, t.newText);
  }
  static _splitPrev(e, t) {
    const i = e.newText.substr(0, t), r = e.newText.substr(t);
    return [
      new $n(e.oldPosition, e.oldText, e.newPosition, i),
      new $n(e.oldEnd, "", e.newPosition + t, r)
    ];
  }
  static _splitCurr(e, t) {
    const i = e.oldText.substr(0, t), r = e.oldText.substr(t);
    return [
      new $n(e.oldPosition, i, e.newPosition, e.newText),
      new $n(e.oldPosition + t, r, e.newEnd, "")
    ];
  }
  static _merge(e) {
    if (e.length === 0)
      return e;
    let t = [], i = 0, r = e[0];
    for (let o = 1; o < e.length; o++) {
      const s = e[o];
      r.oldEnd === s.oldPosition ? r = new $n(r.oldPosition, r.oldText + s.oldText, r.newPosition, r.newText + s.newText) : (t[i++] = r, r = s);
    }
    return t[i++] = r, t;
  }
  static _removeNoOps(e) {
    if (e.length === 0)
      return e;
    let t = [], i = 0;
    for (let r = 0; r < e.length; r++) {
      const o = e[r];
      o.oldText !== o.newText && (t[i++] = o);
    }
    return t;
  }
}
function Bf(n) {
  return n.toString();
}
class Dn {
  constructor(e, t, i, r, o, s, a) {
    this.beforeVersionId = e, this.afterVersionId = t, this.beforeEOL = i, this.afterEOL = r, this.beforeCursorState = o, this.afterCursorState = s, this.changes = a;
  }
  static create(e, t) {
    const i = e.getAlternativeVersionId(), r = QT(e);
    return new Dn(i, i, r, r, t, t, []);
  }
  append(e, t, i, r, o) {
    t.length > 0 && (this.changes = sue(this.changes, t)), this.afterEOL = i, this.afterVersionId = r, this.afterCursorState = o;
  }
  static _writeSelectionsSize(e) {
    return 4 + 4 * 4 * (e ? e.length : 0);
  }
  static _writeSelections(e, t, i) {
    if (Ma(e, t ? t.length : 0, i), i += 4, t)
      for (const r of t)
        Ma(e, r.selectionStartLineNumber, i), i += 4, Ma(e, r.selectionStartColumn, i), i += 4, Ma(e, r.positionLineNumber, i), i += 4, Ma(e, r.positionColumn, i), i += 4;
    return i;
  }
  static _readSelections(e, t, i) {
    const r = Aa(e, t);
    t += 4;
    for (let o = 0; o < r; o++) {
      const s = Aa(e, t);
      t += 4;
      const a = Aa(e, t);
      t += 4;
      const l = Aa(e, t);
      t += 4;
      const u = Aa(e, t);
      t += 4, i.push(new Ut(s, a, l, u));
    }
    return t;
  }
  serialize() {
    let e = 10 + Dn._writeSelectionsSize(this.beforeCursorState) + Dn._writeSelectionsSize(this.afterCursorState) + 4;
    for (const r of this.changes)
      e += r.writeSize();
    const t = new Uint8Array(e);
    let i = 0;
    Ma(t, this.beforeVersionId, i), i += 4, Ma(t, this.afterVersionId, i), i += 4, gk(t, this.beforeEOL, i), i += 1, gk(t, this.afterEOL, i), i += 1, i = Dn._writeSelections(t, this.beforeCursorState, i), i = Dn._writeSelections(t, this.afterCursorState, i), Ma(t, this.changes.length, i), i += 4;
    for (const r of this.changes)
      i = r.write(t, i);
    return t.buffer;
  }
  static deserialize(e) {
    const t = new Uint8Array(e);
    let i = 0;
    const r = Aa(t, i);
    i += 4;
    const o = Aa(t, i);
    i += 4;
    const s = pk(t, i);
    i += 1;
    const a = pk(t, i);
    i += 1;
    const l = [];
    i = Dn._readSelections(t, i, l);
    const u = [];
    i = Dn._readSelections(t, i, u);
    const c = Aa(t, i);
    i += 4;
    const h = [];
    for (let d = 0; d < c; d++)
      i = $n.read(t, i, h);
    return new Dn(r, o, s, a, l, u, h);
  }
}
class P3 {
  constructor(e, t) {
    this.model = e, this._data = Dn.create(e, t);
  }
  get type() {
    return 0;
  }
  get resource() {
    return ft.isUri(this.model) ? this.model : this.model.uri;
  }
  get label() {
    return b("edit", "Typing");
  }
  toString() {
    return (this._data instanceof Dn ? this._data : Dn.deserialize(this._data)).changes.map((t) => t.toString()).join(", ");
  }
  matchesResource(e) {
    return (ft.isUri(this.model) ? this.model : this.model.uri).toString() === e.toString();
  }
  setModel(e) {
    this.model = e;
  }
  canAppend(e) {
    return this.model === e && this._data instanceof Dn;
  }
  append(e, t, i, r, o) {
    this._data instanceof Dn && this._data.append(e, t, i, r, o);
  }
  close() {
    this._data instanceof Dn && (this._data = this._data.serialize());
  }
  open() {
    this._data instanceof Dn || (this._data = Dn.deserialize(this._data));
  }
  undo() {
    if (ft.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof Dn && (this._data = this._data.serialize());
    const e = Dn.deserialize(this._data);
    this.model._applyUndo(e.changes, e.beforeEOL, e.beforeVersionId, e.beforeCursorState);
  }
  redo() {
    if (ft.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof Dn && (this._data = this._data.serialize());
    const e = Dn.deserialize(this._data);
    this.model._applyRedo(e.changes, e.afterEOL, e.afterVersionId, e.afterCursorState);
  }
  heapSize() {
    return this._data instanceof Dn && (this._data = this._data.serialize()), this._data.byteLength + 168;
  }
}
class aue {
  constructor(e, t) {
    this.type = 1, this.label = e, this._isOpen = !0, this._editStackElementsArr = t.slice(0), this._editStackElementsMap = /* @__PURE__ */ new Map();
    for (const i of this._editStackElementsArr) {
      const r = Bf(i.resource);
      this._editStackElementsMap.set(r, i);
    }
    this._delegate = null;
  }
  get resources() {
    return this._editStackElementsArr.map((e) => e.resource);
  }
  prepareUndoRedo() {
    if (this._delegate)
      return this._delegate.prepareUndoRedo(this);
  }
  matchesResource(e) {
    const t = Bf(e);
    return this._editStackElementsMap.has(t);
  }
  setModel(e) {
    const t = Bf(ft.isUri(e) ? e : e.uri);
    this._editStackElementsMap.has(t) && this._editStackElementsMap.get(t).setModel(e);
  }
  canAppend(e) {
    if (!this._isOpen)
      return !1;
    const t = Bf(e.uri);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).canAppend(e) : !1;
  }
  append(e, t, i, r, o) {
    const s = Bf(e.uri);
    this._editStackElementsMap.get(s).append(e, t, i, r, o);
  }
  close() {
    this._isOpen = !1;
  }
  open() {
  }
  undo() {
    this._isOpen = !1;
    for (const e of this._editStackElementsArr)
      e.undo();
  }
  redo() {
    for (const e of this._editStackElementsArr)
      e.redo();
  }
  heapSize(e) {
    const t = Bf(e);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).heapSize() : 0;
  }
  split() {
    return this._editStackElementsArr;
  }
  toString() {
    let e = [];
    for (const t of this._editStackElementsArr)
      e.push(`${b5(t.resource)}: ${t}`);
    return `{${e.join(", ")}}`;
  }
}
function QT(n) {
  return n.getEOL() === `
` ? 0 : 1;
}
function Mu(n) {
  return n ? n instanceof P3 || n instanceof aue : !1;
}
class mI {
  constructor(e, t) {
    this._model = e, this._undoRedoService = t;
  }
  pushStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    Mu(e) && e.close();
  }
  popStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    Mu(e) && e.open();
  }
  clear() {
    this._undoRedoService.removeElements(this._model.uri);
  }
  _getOrCreateEditStackElement(e) {
    const t = this._undoRedoService.getLastElement(this._model.uri);
    if (Mu(t) && t.canAppend(this._model))
      return t;
    const i = new P3(this._model, e);
    return this._undoRedoService.pushElement(i), i;
  }
  pushEOL(e) {
    const t = this._getOrCreateEditStackElement(null);
    this._model.setEOL(e), t.append(this._model, [], QT(this._model), this._model.getAlternativeVersionId(), null);
  }
  pushEditOperation(e, t, i) {
    const r = this._getOrCreateEditStackElement(e), o = this._model.applyEdits(t, !0), s = mI._computeCursorState(i, o), a = o.map((l, u) => ({ index: u, textChange: l.textChange }));
    return a.sort((l, u) => l.textChange.oldPosition === u.textChange.oldPosition ? l.index - u.index : l.textChange.oldPosition - u.textChange.oldPosition), r.append(this._model, a.map((l) => l.textChange), QT(this._model), this._model.getAlternativeVersionId(), s), s;
  }
  static _computeCursorState(e, t) {
    try {
      return e ? e(t) : null;
    } catch (i) {
      return Pi(i), null;
    }
  }
}
class lue {
  constructor() {
    this.spacesDiff = 0, this.looksLikeAlignment = !1;
  }
}
function uue(n, e, t, i, r) {
  r.spacesDiff = 0, r.looksLikeAlignment = !1;
  let o;
  for (o = 0; o < e && o < i; o++) {
    let d = n.charCodeAt(o), f = t.charCodeAt(o);
    if (d !== f)
      break;
  }
  let s = 0, a = 0;
  for (let d = o; d < e; d++)
    n.charCodeAt(d) === 32 ? s++ : a++;
  let l = 0, u = 0;
  for (let d = o; d < i; d++)
    t.charCodeAt(d) === 32 ? l++ : u++;
  if (s > 0 && a > 0 || l > 0 && u > 0)
    return;
  let c = Math.abs(a - u), h = Math.abs(s - l);
  if (c === 0) {
    r.spacesDiff = h, h > 0 && 0 <= l - 1 && l - 1 < n.length && l < t.length && t.charCodeAt(l) !== 32 && n.charCodeAt(l - 1) === 32 && n.charCodeAt(n.length - 1) === 44 && (r.looksLikeAlignment = !0);
    return;
  }
  if (h % c === 0) {
    r.spacesDiff = h / c;
    return;
  }
}
function C2(n, e, t) {
  const i = Math.min(n.getLineCount(), 1e4);
  let r = 0, o = 0, s = "", a = 0;
  const l = [2, 4, 6, 8, 3, 5, 7], u = 8;
  let c = [0, 0, 0, 0, 0, 0, 0, 0, 0], h = new lue();
  for (let p = 1; p <= i; p++) {
    let g = n.getLineLength(p), _ = n.getLineContent(p);
    const m = g <= 65536;
    let v = !1, C = 0, y = 0, w = 0;
    for (let S = 0, E = g; S < E; S++) {
      let D = m ? _.charCodeAt(S) : n.getLineCharCode(p, S);
      if (D === 9)
        w++;
      else if (D === 32)
        y++;
      else {
        v = !0, C = S;
        break;
      }
    }
    if (!v || (w > 0 ? r++ : y > 1 && o++, uue(s, a, _, C, h), h.looksLikeAlignment && !(t && e === h.spacesDiff)))
      continue;
    let L = h.spacesDiff;
    L <= u && c[L]++, s = _, a = C;
  }
  let d = t;
  r !== o && (d = r < o);
  let f = e;
  if (d) {
    let p = d ? 0 : 0.1 * i;
    l.forEach((g) => {
      let _ = c[g];
      _ > p && (p = _, f = g);
    }), f === 4 && c[4] > 0 && c[2] > 0 && c[2] >= c[4] / 2 && (f = 2);
  }
  return {
    insertSpaces: d,
    tabSize: f
  };
}
function Kr(n) {
  return (n.metadata & 1) >>> 0;
}
function Jt(n, e) {
  n.metadata = n.metadata & 254 | e << 0;
}
function Xn(n) {
  return (n.metadata & 2) >>> 1 === 1;
}
function qt(n, e) {
  n.metadata = n.metadata & 253 | (e ? 1 : 0) << 1;
}
function A3(n) {
  return (n.metadata & 4) >>> 2 === 1;
}
function y2(n, e) {
  n.metadata = n.metadata & 251 | (e ? 1 : 0) << 2;
}
function ID(n) {
  return (n.metadata & 8) >>> 3 === 1;
}
function w2(n, e) {
  n.metadata = n.metadata & 247 | (e ? 1 : 0) << 3;
}
function cue(n) {
  return (n.metadata & 48) >>> 4;
}
function b2(n, e) {
  n.metadata = n.metadata & 207 | e << 4;
}
function hue(n) {
  return (n.metadata & 64) >>> 6 === 1;
}
function S2(n, e) {
  n.metadata = n.metadata & 191 | (e ? 1 : 0) << 6;
}
class M3 {
  constructor(e, t, i) {
    this.metadata = 0, this.parent = this, this.left = this, this.right = this, Jt(
      this,
      1
      /* Red */
    ), this.start = t, this.end = i, this.delta = 0, this.maxEnd = i, this.id = e, this.ownerId = 0, this.options = null, y2(this, !1), b2(
      this,
      1
      /* NeverGrowsWhenTypingAtEdges */
    ), w2(this, !1), S2(this, !1), this.cachedVersionId = 0, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = null, qt(this, !1);
  }
  reset(e, t, i, r) {
    this.start = t, this.end = i, this.maxEnd = i, this.cachedVersionId = e, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = r;
  }
  setOptions(e) {
    this.options = e;
    let t = this.options.className;
    y2(this, t === "squiggly-error" || t === "squiggly-warning" || t === "squiggly-info"), b2(this, this.options.stickiness), w2(this, !!(this.options.overviewRuler && this.options.overviewRuler.color)), S2(this, this.options.collapseOnReplaceEdit);
  }
  setCachedOffsets(e, t, i) {
    this.cachedVersionId !== i && (this.range = null), this.cachedVersionId = i, this.cachedAbsoluteStart = e, this.cachedAbsoluteEnd = t;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const et = new M3(null, 0, 0);
et.parent = et;
et.left = et;
et.right = et;
Jt(
  et,
  0
  /* Black */
);
class E2 {
  constructor() {
    this.root = et, this.requestNormalizeDelta = !1;
  }
  intervalSearch(e, t, i, r, o) {
    return this.root === et ? [] : Cue(this, e, t, i, r, o);
  }
  search(e, t, i) {
    return this.root === et ? [] : _ue(this, e, t, i);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesFromOwner(e) {
    return mue(this, e);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesPostOrder() {
    return vue(this);
  }
  insert(e) {
    L2(this, e), this._normalizeDeltaIfNecessary();
  }
  delete(e) {
    D2(this, e), this._normalizeDeltaIfNecessary();
  }
  resolveNode(e, t) {
    const i = e;
    let r = 0;
    for (; e !== this.root; )
      e === e.parent.right && (r += e.parent.delta), e = e.parent;
    const o = i.start + r, s = i.end + r;
    i.setCachedOffsets(o, s, t);
  }
  acceptReplace(e, t, i, r) {
    const o = pue(this, e, e + t);
    for (let s = 0, a = o.length; s < a; s++) {
      const l = o[s];
      D2(this, l);
    }
    this._normalizeDeltaIfNecessary(), gue(this, e, e + t, i), this._normalizeDeltaIfNecessary();
    for (let s = 0, a = o.length; s < a; s++) {
      const l = o[s];
      l.start = l.cachedAbsoluteStart, l.end = l.cachedAbsoluteEnd, fue(l, e, e + t, i, r), l.maxEnd = l.end, L2(this, l);
    }
    this._normalizeDeltaIfNecessary();
  }
  _normalizeDeltaIfNecessary() {
    this.requestNormalizeDelta && (this.requestNormalizeDelta = !1, due(this));
  }
}
function due(n) {
  let e = n.root, t = 0;
  for (; e !== et; ) {
    if (e.left !== et && !Xn(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== et && !Xn(e.right)) {
      t += e.delta, e = e.right;
      continue;
    }
    e.start = t + e.start, e.end = t + e.end, e.delta = 0, hh(e), qt(e, !0), qt(e.left, !1), qt(e.right, !1), e === e.parent.right && (t -= e.parent.delta), e = e.parent;
  }
  qt(n.root, !1);
}
function Hf(n, e, t, i) {
  return n < t ? !0 : n > t || i === 1 ? !1 : i === 2 ? !0 : e;
}
function fue(n, e, t, i, r) {
  const o = cue(n), s = o === 0 || o === 2, a = o === 1 || o === 2, l = t - e, u = i, c = Math.min(l, u), h = n.start;
  let d = !1;
  const f = n.end;
  let p = !1;
  e <= h && f <= t && hue(n) && (n.start = e, d = !0, n.end = e, p = !0);
  {
    const _ = r ? 1 : l > 0 ? 2 : 0;
    !d && Hf(h, s, e, _) && (d = !0), !p && Hf(f, a, e, _) && (p = !0);
  }
  if (c > 0 && !r) {
    const _ = l > u ? 2 : 0;
    !d && Hf(h, s, e + c, _) && (d = !0), !p && Hf(f, a, e + c, _) && (p = !0);
  }
  {
    const _ = r ? 1 : 0;
    !d && Hf(h, s, t, _) && (n.start = e + u, d = !0), !p && Hf(f, a, t, _) && (n.end = e + u, p = !0);
  }
  const g = u - l;
  d || (n.start = Math.max(0, h + g)), p || (n.end = Math.max(0, f + g)), n.start > n.end && (n.end = n.start);
}
function pue(n, e, t) {
  let i = n.root, r = 0, o = 0, s = 0, a = 0, l = [], u = 0;
  for (; i !== et; ) {
    if (Xn(i)) {
      qt(i.left, !1), qt(i.right, !1), i === i.parent.right && (r -= i.parent.delta), i = i.parent;
      continue;
    }
    if (!Xn(i.left)) {
      if (o = r + i.maxEnd, o < e) {
        qt(i, !0);
        continue;
      }
      if (i.left !== et) {
        i = i.left;
        continue;
      }
    }
    if (s = r + i.start, s > t) {
      qt(i, !0);
      continue;
    }
    if (a = r + i.end, a >= e && (i.setCachedOffsets(s, a, 0), l[u++] = i), qt(i, !0), i.right !== et && !Xn(i.right)) {
      r += i.delta, i = i.right;
      continue;
    }
  }
  return qt(n.root, !1), l;
}
function gue(n, e, t, i) {
  let r = n.root, o = 0, s = 0, a = 0;
  const l = i - (t - e);
  for (; r !== et; ) {
    if (Xn(r)) {
      qt(r.left, !1), qt(r.right, !1), r === r.parent.right && (o -= r.parent.delta), hh(r), r = r.parent;
      continue;
    }
    if (!Xn(r.left)) {
      if (s = o + r.maxEnd, s < e) {
        qt(r, !0);
        continue;
      }
      if (r.left !== et) {
        r = r.left;
        continue;
      }
    }
    if (a = o + r.start, a > t) {
      r.start += l, r.end += l, r.delta += l, (r.delta < -1073741824 || r.delta > 1073741824) && (n.requestNormalizeDelta = !0), qt(r, !0);
      continue;
    }
    if (qt(r, !0), r.right !== et && !Xn(r.right)) {
      o += r.delta, r = r.right;
      continue;
    }
  }
  qt(n.root, !1);
}
function mue(n, e) {
  let t = n.root, i = [], r = 0;
  for (; t !== et; ) {
    if (Xn(t)) {
      qt(t.left, !1), qt(t.right, !1), t = t.parent;
      continue;
    }
    if (t.left !== et && !Xn(t.left)) {
      t = t.left;
      continue;
    }
    if (t.ownerId === e && (i[r++] = t), qt(t, !0), t.right !== et && !Xn(t.right)) {
      t = t.right;
      continue;
    }
  }
  return qt(n.root, !1), i;
}
function vue(n) {
  let e = n.root, t = [], i = 0;
  for (; e !== et; ) {
    if (Xn(e)) {
      qt(e.left, !1), qt(e.right, !1), e = e.parent;
      continue;
    }
    if (e.left !== et && !Xn(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== et && !Xn(e.right)) {
      e = e.right;
      continue;
    }
    t[i++] = e, qt(e, !0);
  }
  return qt(n.root, !1), t;
}
function _ue(n, e, t, i) {
  let r = n.root, o = 0, s = 0, a = 0, l = [], u = 0;
  for (; r !== et; ) {
    if (Xn(r)) {
      qt(r.left, !1), qt(r.right, !1), r === r.parent.right && (o -= r.parent.delta), r = r.parent;
      continue;
    }
    if (r.left !== et && !Xn(r.left)) {
      r = r.left;
      continue;
    }
    s = o + r.start, a = o + r.end, r.setCachedOffsets(s, a, i);
    let c = !0;
    if (e && r.ownerId && r.ownerId !== e && (c = !1), t && A3(r) && (c = !1), c && (l[u++] = r), qt(r, !0), r.right !== et && !Xn(r.right)) {
      o += r.delta, r = r.right;
      continue;
    }
  }
  return qt(n.root, !1), l;
}
function Cue(n, e, t, i, r, o) {
  let s = n.root, a = 0, l = 0, u = 0, c = 0, h = [], d = 0;
  for (; s !== et; ) {
    if (Xn(s)) {
      qt(s.left, !1), qt(s.right, !1), s === s.parent.right && (a -= s.parent.delta), s = s.parent;
      continue;
    }
    if (!Xn(s.left)) {
      if (l = a + s.maxEnd, l < e) {
        qt(s, !0);
        continue;
      }
      if (s.left !== et) {
        s = s.left;
        continue;
      }
    }
    if (u = a + s.start, u > t) {
      qt(s, !0);
      continue;
    }
    if (c = a + s.end, c >= e) {
      s.setCachedOffsets(u, c, o);
      let f = !0;
      i && s.ownerId && s.ownerId !== i && (f = !1), r && A3(s) && (f = !1), f && (h[d++] = s);
    }
    if (qt(s, !0), s.right !== et && !Xn(s.right)) {
      a += s.delta, s = s.right;
      continue;
    }
  }
  return qt(n.root, !1), h;
}
function L2(n, e) {
  if (n.root === et)
    return e.parent = et, e.left = et, e.right = et, Jt(
      e,
      0
      /* Black */
    ), n.root = e, n.root;
  yue(n, e), Ac(e.parent);
  let t = e;
  for (; t !== n.root && Kr(t.parent) === 1; )
    if (t.parent === t.parent.parent.left) {
      const i = t.parent.parent.right;
      Kr(i) === 1 ? (Jt(
        t.parent,
        0
        /* Black */
      ), Jt(
        i,
        0
        /* Black */
      ), Jt(
        t.parent.parent,
        1
        /* Red */
      ), t = t.parent.parent) : (t === t.parent.right && (t = t.parent, wv(n, t)), Jt(
        t.parent,
        0
        /* Black */
      ), Jt(
        t.parent.parent,
        1
        /* Red */
      ), bv(n, t.parent.parent));
    } else {
      const i = t.parent.parent.left;
      Kr(i) === 1 ? (Jt(
        t.parent,
        0
        /* Black */
      ), Jt(
        i,
        0
        /* Black */
      ), Jt(
        t.parent.parent,
        1
        /* Red */
      ), t = t.parent.parent) : (t === t.parent.left && (t = t.parent, bv(n, t)), Jt(
        t.parent,
        0
        /* Black */
      ), Jt(
        t.parent.parent,
        1
        /* Red */
      ), wv(n, t.parent.parent));
    }
  return Jt(
    n.root,
    0
    /* Black */
  ), e;
}
function yue(n, e) {
  let t = 0, i = n.root;
  const r = e.start, o = e.end;
  for (; ; )
    if (bue(r, o, i.start + t, i.end + t) < 0)
      if (i.left === et) {
        e.start -= t, e.end -= t, e.maxEnd -= t, i.left = e;
        break;
      } else
        i = i.left;
    else if (i.right === et) {
      e.start -= t + i.delta, e.end -= t + i.delta, e.maxEnd -= t + i.delta, i.right = e;
      break;
    } else
      t += i.delta, i = i.right;
  e.parent = i, e.left = et, e.right = et, Jt(
    e,
    1
    /* Red */
  );
}
function D2(n, e) {
  let t, i;
  if (e.left === et ? (t = e.right, i = e, t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (n.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta) : e.right === et ? (t = e.left, i = e) : (i = wue(e.right), t = i.right, t.start += i.delta, t.end += i.delta, t.delta += i.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (n.requestNormalizeDelta = !0), i.start += e.delta, i.end += e.delta, i.delta = e.delta, (i.delta < -1073741824 || i.delta > 1073741824) && (n.requestNormalizeDelta = !0)), i === n.root) {
    n.root = t, Jt(
      t,
      0
      /* Black */
    ), e.detach(), PD(), hh(t), n.root.parent = et;
    return;
  }
  let r = Kr(i) === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? t.parent = i.parent : (i.parent === e ? t.parent = i : t.parent = i.parent, i.left = e.left, i.right = e.right, i.parent = e.parent, Jt(i, Kr(e)), e === n.root ? n.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== et && (i.left.parent = i), i.right !== et && (i.right.parent = i)), e.detach(), r) {
    Ac(t.parent), i !== e && (Ac(i), Ac(i.parent)), PD();
    return;
  }
  Ac(t), Ac(t.parent), i !== e && (Ac(i), Ac(i.parent));
  let o;
  for (; t !== n.root && Kr(t) === 0; )
    t === t.parent.left ? (o = t.parent.right, Kr(o) === 1 && (Jt(
      o,
      0
      /* Black */
    ), Jt(
      t.parent,
      1
      /* Red */
    ), wv(n, t.parent), o = t.parent.right), Kr(o.left) === 0 && Kr(o.right) === 0 ? (Jt(
      o,
      1
      /* Red */
    ), t = t.parent) : (Kr(o.right) === 0 && (Jt(
      o.left,
      0
      /* Black */
    ), Jt(
      o,
      1
      /* Red */
    ), bv(n, o), o = t.parent.right), Jt(o, Kr(t.parent)), Jt(
      t.parent,
      0
      /* Black */
    ), Jt(
      o.right,
      0
      /* Black */
    ), wv(n, t.parent), t = n.root)) : (o = t.parent.left, Kr(o) === 1 && (Jt(
      o,
      0
      /* Black */
    ), Jt(
      t.parent,
      1
      /* Red */
    ), bv(n, t.parent), o = t.parent.left), Kr(o.left) === 0 && Kr(o.right) === 0 ? (Jt(
      o,
      1
      /* Red */
    ), t = t.parent) : (Kr(o.left) === 0 && (Jt(
      o.right,
      0
      /* Black */
    ), Jt(
      o,
      1
      /* Red */
    ), wv(n, o), o = t.parent.left), Jt(o, Kr(t.parent)), Jt(
      t.parent,
      0
      /* Black */
    ), Jt(
      o.left,
      0
      /* Black */
    ), bv(n, t.parent), t = n.root));
  Jt(
    t,
    0
    /* Black */
  ), PD();
}
function wue(n) {
  for (; n.left !== et; )
    n = n.left;
  return n;
}
function PD() {
  et.parent = et, et.delta = 0, et.start = 0, et.end = 0;
}
function wv(n, e) {
  const t = e.right;
  t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (n.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta, e.right = t.left, t.left !== et && (t.left.parent = e), t.parent = e.parent, e.parent === et ? n.root = t : e === e.parent.left ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t, hh(e), hh(t);
}
function bv(n, e) {
  const t = e.left;
  e.delta -= t.delta, (e.delta < -1073741824 || e.delta > 1073741824) && (n.requestNormalizeDelta = !0), e.start -= t.delta, e.end -= t.delta, e.left = t.right, t.right !== et && (t.right.parent = e), t.parent = e.parent, e.parent === et ? n.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t, hh(e), hh(t);
}
function F3(n) {
  let e = n.end;
  if (n.left !== et) {
    const t = n.left.maxEnd;
    t > e && (e = t);
  }
  if (n.right !== et) {
    const t = n.right.maxEnd + n.delta;
    t > e && (e = t);
  }
  return e;
}
function hh(n) {
  n.maxEnd = F3(n);
}
function Ac(n) {
  for (; n !== et; ) {
    const e = F3(n);
    if (n.maxEnd === e)
      return;
    n.maxEnd = e, n = n.parent;
  }
}
function bue(n, e, t, i) {
  return n === t ? e - i : n - t;
}
class JT {
  constructor(e, t) {
    this.piece = e, this.color = t, this.size_left = 0, this.lf_left = 0, this.parent = this, this.left = this, this.right = this;
  }
  next() {
    if (this.right !== je)
      return vI(this.right);
    let e = this;
    for (; e.parent !== je && e.parent.left !== e; )
      e = e.parent;
    return e.parent === je ? je : e.parent;
  }
  prev() {
    if (this.left !== je)
      return k3(this.left);
    let e = this;
    for (; e.parent !== je && e.parent.right !== e; )
      e = e.parent;
    return e.parent === je ? je : e.parent;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const je = new JT(
  null,
  0
  /* Black */
);
je.parent = je;
je.left = je;
je.right = je;
je.color = 0;
function vI(n) {
  for (; n.left !== je; )
    n = n.left;
  return n;
}
function k3(n) {
  for (; n.right !== je; )
    n = n.right;
  return n;
}
function _I(n) {
  return n === je ? 0 : n.size_left + n.piece.length + _I(n.right);
}
function CI(n) {
  return n === je ? 0 : n.lf_left + n.piece.lineFeedCnt + CI(n.right);
}
function AD() {
  je.parent = je;
}
function Sv(n, e) {
  let t = e.right;
  t.size_left += e.size_left + (e.piece ? e.piece.length : 0), t.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0), e.right = t.left, t.left !== je && (t.left.parent = e), t.parent = e.parent, e.parent === je ? n.root = t : e.parent.left === e ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t;
}
function Ev(n, e) {
  let t = e.left;
  e.left = t.right, t.right !== je && (t.right.parent = e), t.parent = e.parent, e.size_left -= t.size_left + (t.piece ? t.piece.length : 0), e.lf_left -= t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0), e.parent === je ? n.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t;
}
function by(n, e) {
  let t, i;
  if (e.left === je ? (i = e, t = i.right) : e.right === je ? (i = e, t = i.left) : (i = vI(e.right), t = i.right), i === n.root) {
    n.root = t, t.color = 0, e.detach(), AD(), n.root.parent = je;
    return;
  }
  let r = i.color === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? (t.parent = i.parent, Jm(n, t)) : (i.parent === e ? t.parent = i : t.parent = i.parent, Jm(n, t), i.left = e.left, i.right = e.right, i.parent = e.parent, i.color = e.color, e === n.root ? n.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== je && (i.left.parent = i), i.right !== je && (i.right.parent = i), i.size_left = e.size_left, i.lf_left = e.lf_left, Jm(n, i)), e.detach(), t.parent.left === t) {
    let s = _I(t), a = CI(t);
    if (s !== t.parent.size_left || a !== t.parent.lf_left) {
      let l = s - t.parent.size_left, u = a - t.parent.lf_left;
      t.parent.size_left = s, t.parent.lf_left = a, Ru(n, t.parent, l, u);
    }
  }
  if (Jm(n, t.parent), r) {
    AD();
    return;
  }
  let o;
  for (; t !== n.root && t.color === 0; )
    t === t.parent.left ? (o = t.parent.right, o.color === 1 && (o.color = 0, t.parent.color = 1, Sv(n, t.parent), o = t.parent.right), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.right.color === 0 && (o.left.color = 0, o.color = 1, Ev(n, o), o = t.parent.right), o.color = t.parent.color, t.parent.color = 0, o.right.color = 0, Sv(n, t.parent), t = n.root)) : (o = t.parent.left, o.color === 1 && (o.color = 0, t.parent.color = 1, Ev(n, t.parent), o = t.parent.left), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.left.color === 0 && (o.right.color = 0, o.color = 1, Sv(n, o), o = t.parent.left), o.color = t.parent.color, t.parent.color = 0, o.left.color = 0, Ev(n, t.parent), t = n.root));
  t.color = 0, AD();
}
function R2(n, e) {
  for (Jm(n, e); e !== n.root && e.parent.color === 1; )
    if (e.parent === e.parent.parent.left) {
      const t = e.parent.parent.right;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, Sv(n, e)), e.parent.color = 0, e.parent.parent.color = 1, Ev(n, e.parent.parent));
    } else {
      const t = e.parent.parent.left;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, Ev(n, e)), e.parent.color = 0, e.parent.parent.color = 1, Sv(n, e.parent.parent));
    }
  n.root.color = 0;
}
function Ru(n, e, t, i) {
  for (; e !== n.root && e !== je; )
    e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
}
function Jm(n, e) {
  let t = 0, i = 0;
  if (e !== n.root) {
    if (t === 0) {
      for (; e !== n.root && e === e.parent.right; )
        e = e.parent;
      if (e === n.root)
        return;
      e = e.parent, t = _I(e.left) - e.size_left, i = CI(e.left) - e.lf_left, e.size_left += t, e.lf_left += i;
    }
    for (; e !== n.root && (t !== 0 || i !== 0); )
      e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
  }
}
class Sue extends Ig {
  constructor(e) {
    super(
      0
      /* Regular */
    );
    for (let t = 0, i = e.length; t < i; t++)
      this.set(
        e.charCodeAt(t),
        2
        /* WordSeparator */
      );
    this.set(
      32,
      1
      /* Whitespace */
    ), this.set(
      9,
      1
      /* Whitespace */
    );
  }
}
function Eue(n) {
  let e = {};
  return (t) => (e.hasOwnProperty(t) || (e[t] = n(t)), e[t]);
}
const tg = Eue((n) => new Sue(n)), Lue = 999;
class Gf {
  constructor(e, t, i, r) {
    this.searchString = e, this.isRegex = t, this.matchCase = i, this.wordSeparators = r;
  }
  parseSearchRequest() {
    if (this.searchString === "")
      return null;
    let e;
    this.isRegex ? e = Due(this.searchString) : e = this.searchString.indexOf(`
`) >= 0;
    let t = null;
    try {
      t = m5(this.searchString, this.isRegex, {
        matchCase: this.matchCase,
        wholeWord: !1,
        multiline: e,
        global: !0,
        unicode: !0
      });
    } catch {
      return null;
    }
    if (!t)
      return null;
    let i = !this.isRegex && !e;
    return i && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (i = this.matchCase), new Rue(t, this.wordSeparators ? tg(this.wordSeparators) : null, i ? this.searchString : null);
  }
}
function Due(n) {
  if (!n || n.length === 0)
    return !1;
  for (let e = 0, t = n.length; e < t; e++)
    if (n.charCodeAt(e) === 92) {
      if (e++, e >= t)
        break;
      const r = n.charCodeAt(e);
      if (r === 110 || r === 114 || r === 87 || r === 119)
        return !0;
    }
  return !1;
}
class Rue {
  constructor(e, t, i) {
    this.regex = e, this.wordSeparators = t, this.simpleSearch = i;
  }
}
function Jh(n, e, t) {
  if (!t)
    return new Zv(n, null);
  let i = [];
  for (let r = 0, o = e.length; r < o; r++)
    i[r] = e[r];
  return new Zv(n, i);
}
class T2 {
  constructor(e) {
    let t = [], i = 0;
    for (let r = 0, o = e.length; r < o; r++)
      e.charCodeAt(r) === 10 && (t[i++] = r);
    this._lineFeedsOffsets = t;
  }
  findLineFeedCountBeforeOffset(e) {
    const t = this._lineFeedsOffsets;
    let i = 0, r = t.length - 1;
    if (r === -1 || e <= t[0])
      return 0;
    for (; i < r; ) {
      const o = i + ((r - i) / 2 >> 0);
      t[o] >= e ? r = o - 1 : t[o + 1] >= e ? (i = o, r = o) : i = o + 1;
    }
    return i + 1;
  }
}
class Sy {
  static findMatches(e, t, i, r, o) {
    const s = t.parseSearchRequest();
    return s ? s.regex.multiline ? this._doFindMatchesMultiline(e, i, new ev(s.wordSeparators, s.regex), r, o) : this._doFindMatchesLineByLine(e, i, s, r, o) : [];
  }
  /**
   * Multiline search always executes on the lines concatenated with \n.
   * We must therefore compensate for the count of \n in case the model is CRLF
   */
  static _getMultilineMatchRange(e, t, i, r, o, s) {
    let a, l = 0;
    r ? (l = r.findLineFeedCountBeforeOffset(o), a = t + o + l) : a = t + o;
    let u;
    if (r) {
      let f = r.findLineFeedCountBeforeOffset(o + s.length) - l;
      u = a + s.length + f;
    } else
      u = a + s.length;
    const c = e.getPositionAt(a), h = e.getPositionAt(u);
    return new G(c.lineNumber, c.column, h.lineNumber, h.column);
  }
  static _doFindMatchesMultiline(e, t, i, r, o) {
    const s = e.getOffsetAt(t.getStartPosition()), a = e.getValueInRange(
      t,
      1
      /* LF */
    ), l = e.getEOL() === `\r
` ? new T2(a) : null, u = [];
    let c = 0, h;
    for (i.reset(0); h = i.next(a); )
      if (u[c++] = Jh(this._getMultilineMatchRange(e, s, a, l, h.index, h[0]), h, r), c >= o)
        return u;
    return u;
  }
  static _doFindMatchesLineByLine(e, t, i, r, o) {
    const s = [];
    let a = 0;
    if (t.startLineNumber === t.endLineNumber) {
      const u = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1, t.endColumn - 1);
      return a = this._findMatchesInLine(i, u, t.startLineNumber, t.startColumn - 1, a, s, r, o), s;
    }
    const l = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1);
    a = this._findMatchesInLine(i, l, t.startLineNumber, t.startColumn - 1, a, s, r, o);
    for (let u = t.startLineNumber + 1; u < t.endLineNumber && a < o; u++)
      a = this._findMatchesInLine(i, e.getLineContent(u), u, 0, a, s, r, o);
    if (a < o) {
      const u = e.getLineContent(t.endLineNumber).substring(0, t.endColumn - 1);
      a = this._findMatchesInLine(i, u, t.endLineNumber, 0, a, s, r, o);
    }
    return s;
  }
  static _findMatchesInLine(e, t, i, r, o, s, a, l) {
    const u = e.wordSeparators;
    if (!a && e.simpleSearch) {
      const d = e.simpleSearch, f = d.length, p = t.length;
      let g = -f;
      for (; (g = t.indexOf(d, g + f)) !== -1; )
        if ((!u || yI(u, t, p, g, f)) && (s[o++] = new Zv(new G(i, g + 1 + r, i, g + 1 + f + r), null), o >= l))
          return o;
      return o;
    }
    const c = new ev(e.wordSeparators, e.regex);
    let h;
    c.reset(0);
    do
      if (h = c.next(t), h && (s[o++] = Jh(new G(i, h.index + 1 + r, i, h.index + 1 + h[0].length + r), h, a), o >= l))
        return o;
    while (h);
    return o;
  }
  static findNextMatch(e, t, i, r) {
    const o = t.parseSearchRequest();
    if (!o)
      return null;
    const s = new ev(o.wordSeparators, o.regex);
    return o.regex.multiline ? this._doFindNextMatchMultiline(e, i, s, r) : this._doFindNextMatchLineByLine(e, i, s, r);
  }
  static _doFindNextMatchMultiline(e, t, i, r) {
    const o = new ie(t.lineNumber, 1), s = e.getOffsetAt(o), a = e.getLineCount(), l = e.getValueInRange(
      new G(o.lineNumber, o.column, a, e.getLineMaxColumn(a)),
      1
      /* LF */
    ), u = e.getEOL() === `\r
` ? new T2(l) : null;
    i.reset(t.column - 1);
    let c = i.next(l);
    return c ? Jh(this._getMultilineMatchRange(e, s, l, u, c.index, c[0]), c, r) : t.lineNumber !== 1 || t.column !== 1 ? this._doFindNextMatchMultiline(e, new ie(1, 1), i, r) : null;
  }
  static _doFindNextMatchLineByLine(e, t, i, r) {
    const o = e.getLineCount(), s = t.lineNumber, a = e.getLineContent(s), l = this._findFirstMatchInLine(i, a, s, t.column, r);
    if (l)
      return l;
    for (let u = 1; u <= o; u++) {
      const c = (s + u - 1) % o, h = e.getLineContent(c + 1), d = this._findFirstMatchInLine(i, h, c + 1, 1, r);
      if (d)
        return d;
    }
    return null;
  }
  static _findFirstMatchInLine(e, t, i, r, o) {
    e.reset(r - 1);
    const s = e.next(t);
    return s ? Jh(new G(i, s.index + 1, i, s.index + 1 + s[0].length), s, o) : null;
  }
  static findPreviousMatch(e, t, i, r) {
    const o = t.parseSearchRequest();
    if (!o)
      return null;
    const s = new ev(o.wordSeparators, o.regex);
    return o.regex.multiline ? this._doFindPreviousMatchMultiline(e, i, s, r) : this._doFindPreviousMatchLineByLine(e, i, s, r);
  }
  static _doFindPreviousMatchMultiline(e, t, i, r) {
    const o = this._doFindMatchesMultiline(e, new G(1, 1, t.lineNumber, t.column), i, r, 10 * Lue);
    if (o.length > 0)
      return o[o.length - 1];
    const s = e.getLineCount();
    return t.lineNumber !== s || t.column !== e.getLineMaxColumn(s) ? this._doFindPreviousMatchMultiline(e, new ie(s, e.getLineMaxColumn(s)), i, r) : null;
  }
  static _doFindPreviousMatchLineByLine(e, t, i, r) {
    const o = e.getLineCount(), s = t.lineNumber, a = e.getLineContent(s).substring(0, t.column - 1), l = this._findLastMatchInLine(i, a, s, r);
    if (l)
      return l;
    for (let u = 1; u <= o; u++) {
      const c = (o + s - u - 1) % o, h = e.getLineContent(c + 1), d = this._findLastMatchInLine(i, h, c + 1, r);
      if (d)
        return d;
    }
    return null;
  }
  static _findLastMatchInLine(e, t, i, r) {
    let o = null, s;
    for (e.reset(0); s = e.next(t); )
      o = Jh(new G(i, s.index + 1, i, s.index + 1 + s[0].length), s, r);
    return o;
  }
}
function Tue(n, e, t, i, r) {
  if (i === 0)
    return !0;
  const o = e.charCodeAt(i - 1);
  if (n.get(o) !== 0 || o === 13 || o === 10)
    return !0;
  if (r > 0) {
    const s = e.charCodeAt(i);
    if (n.get(s) !== 0)
      return !0;
  }
  return !1;
}
function Oue(n, e, t, i, r) {
  if (i + r === t)
    return !0;
  const o = e.charCodeAt(i + r);
  if (n.get(o) !== 0 || o === 13 || o === 10)
    return !0;
  if (r > 0) {
    const s = e.charCodeAt(i + r - 1);
    if (n.get(s) !== 0)
      return !0;
  }
  return !1;
}
function yI(n, e, t, i, r) {
  return Tue(n, e, t, i, r) && Oue(n, e, t, i, r);
}
class ev {
  constructor(e, t) {
    this._wordSeparators = e, this._searchRegex = t, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  reset(e) {
    this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  next(e) {
    const t = e.length;
    let i;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === t || (i = this._searchRegex.exec(e), !i))
        return null;
      const r = i.index, o = i[0].length;
      if (r === this._prevMatchStartIndex && o === this._prevMatchLength) {
        if (o === 0) {
          Pu(e, t, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
          continue;
        }
        return null;
      }
      if (this._prevMatchStartIndex = r, this._prevMatchLength = o, !this._wordSeparators || yI(this._wordSeparators, e, t, r, o))
        return i;
    } while (i);
    return null;
  }
}
const bu = 65535;
function W3(n) {
  let e;
  return n[n.length - 1] < 65536 ? e = new Uint16Array(n.length) : e = new Uint32Array(n.length), e.set(n, 0), e;
}
class xue {
  constructor(e, t, i, r, o) {
    this.lineStarts = e, this.cr = t, this.lf = i, this.crlf = r, this.isBasicASCII = o;
  }
}
function Ou(n, e = !0) {
  let t = [0], i = 1;
  for (let r = 0, o = n.length; r < o; r++) {
    const s = n.charCodeAt(r);
    s === 13 ? r + 1 < o && n.charCodeAt(r + 1) === 10 ? (t[i++] = r + 2, r++) : t[i++] = r + 1 : s === 10 && (t[i++] = r + 1);
  }
  return e ? W3(t) : t;
}
function Nue(n, e) {
  n.length = 0, n[0] = 0;
  let t = 1, i = 0, r = 0, o = 0, s = !0;
  for (let l = 0, u = e.length; l < u; l++) {
    const c = e.charCodeAt(l);
    c === 13 ? l + 1 < u && e.charCodeAt(l + 1) === 10 ? (o++, n[t++] = l + 2, l++) : (i++, n[t++] = l + 1) : c === 10 ? (r++, n[t++] = l + 1) : s && c !== 9 && (c < 32 || c > 126) && (s = !1);
  }
  const a = new xue(W3(n), i, r, o, s);
  return n.length = 0, a;
}
class mo {
  constructor(e, t, i, r, o) {
    this.bufferIndex = e, this.start = t, this.end = i, this.lineFeedCnt = r, this.length = o;
  }
}
class ed {
  constructor(e, t) {
    this.buffer = e, this.lineStarts = t;
  }
}
class Iue {
  constructor(e, t) {
    this._pieces = [], this._tree = e, this._BOM = t, this._index = 0, e.root !== je && e.iterate(e.root, (i) => (i !== je && this._pieces.push(i.piece), !0));
  }
  read() {
    return this._pieces.length === 0 ? this._index === 0 ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : this._index === 0 ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++]);
  }
}
class Pue {
  constructor(e) {
    this._limit = e, this._cache = [];
  }
  get(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      let i = this._cache[t];
      if (i.nodeStartOffset <= e && i.nodeStartOffset + i.node.piece.length >= e)
        return i;
    }
    return null;
  }
  get2(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      let i = this._cache[t];
      if (i.nodeStartLineNumber && i.nodeStartLineNumber < e && i.nodeStartLineNumber + i.node.piece.lineFeedCnt >= e)
        return i;
    }
    return null;
  }
  set(e) {
    this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e);
  }
  validate(e) {
    let t = !1, i = this._cache;
    for (let r = 0; r < i.length; r++) {
      let o = i[r];
      if (o.node.parent === null || o.nodeStartOffset >= e) {
        i[r] = null, t = !0;
        continue;
      }
    }
    if (t) {
      let r = [];
      for (const o of i)
        o !== null && r.push(o);
      this._cache = r;
    }
  }
}
class Aue {
  constructor(e, t, i) {
    this.create(e, t, i);
  }
  create(e, t, i) {
    this._buffers = [
      new ed("", [0])
    ], this._lastChangeBufferPos = { line: 0, column: 0 }, this.root = je, this._lineCnt = 1, this._length = 0, this._EOL = t, this._EOLLength = t.length, this._EOLNormalized = i;
    let r = null;
    for (let o = 0, s = e.length; o < s; o++)
      if (e[o].buffer.length > 0) {
        e[o].lineStarts || (e[o].lineStarts = Ou(e[o].buffer));
        let a = new mo(o + 1, { line: 0, column: 0 }, { line: e[o].lineStarts.length - 1, column: e[o].buffer.length - e[o].lineStarts[e[o].lineStarts.length - 1] }, e[o].lineStarts.length - 1, e[o].buffer.length);
        this._buffers.push(e[o]), r = this.rbInsertRight(r, a);
      }
    this._searchCache = new Pue(1), this._lastVisitedLine = { lineNumber: 0, value: "" }, this.computeBufferMetadata();
  }
  normalizeEOL(e) {
    let t = bu, i = t - Math.floor(t / 3), r = i * 2, o = "", s = 0, a = [];
    if (this.iterate(this.root, (l) => {
      let u = this.getNodeContent(l), c = u.length;
      if (s <= i || s + c < r)
        return o += u, s += c, !0;
      let h = o.replace(/\r\n|\r|\n/g, e);
      return a.push(new ed(h, Ou(h))), o = u, s = c, !0;
    }), s > 0) {
      let l = o.replace(/\r\n|\r|\n/g, e);
      a.push(new ed(l, Ou(l)));
    }
    this.create(a, e, !0);
  }
  // #region Buffer API
  getEOL() {
    return this._EOL;
  }
  setEOL(e) {
    this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL(e);
  }
  createSnapshot(e) {
    return new Iue(this, e);
  }
  getOffsetAt(e, t) {
    let i = 0, r = this.root;
    for (; r !== je; )
      if (r.left !== je && r.lf_left + 1 >= e)
        r = r.left;
      else if (r.lf_left + r.piece.lineFeedCnt + 1 >= e) {
        i += r.size_left;
        let o = this.getAccumulatedValue(r, e - r.lf_left - 2);
        return i += o + t - 1;
      } else
        e -= r.lf_left + r.piece.lineFeedCnt, i += r.size_left + r.piece.length, r = r.right;
    return i;
  }
  getPositionAt(e) {
    e = Math.floor(e), e = Math.max(0, e);
    let t = this.root, i = 0, r = e;
    for (; t !== je; )
      if (t.size_left !== 0 && t.size_left >= e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        let o = this.getIndexOf(t, e - t.size_left);
        if (i += t.lf_left + o.index, o.index === 0) {
          let s = this.getOffsetAt(i + 1, 1), a = r - s;
          return new ie(i + 1, a + 1);
        }
        return new ie(i + 1, o.remainder + 1);
      } else if (e -= t.size_left + t.piece.length, i += t.lf_left + t.piece.lineFeedCnt, t.right === je) {
        let o = this.getOffsetAt(i + 1, 1), s = r - e - o;
        return new ie(i + 1, s + 1);
      } else
        t = t.right;
    return new ie(1, 1);
  }
  getValueInRange(e, t) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return "";
    let i = this.nodeAt2(e.startLineNumber, e.startColumn), r = this.nodeAt2(e.endLineNumber, e.endColumn), o = this.getValueInRange2(i, r);
    return t ? t !== this._EOL || !this._EOLNormalized ? o.replace(/\r\n|\r|\n/g, t) : t === this.getEOL() && this._EOLNormalized ? o : o.replace(/\r\n|\r|\n/g, t) : o;
  }
  getValueInRange2(e, t) {
    if (e.node === t.node) {
      let a = e.node, l = this._buffers[a.piece.bufferIndex].buffer, u = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start);
      return l.substring(u + e.remainder, u + t.remainder);
    }
    let i = e.node, r = this._buffers[i.piece.bufferIndex].buffer, o = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start), s = r.substring(o + e.remainder, o + i.piece.length);
    for (i = i.next(); i !== je; ) {
      let a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (i === t.node) {
        s += a.substring(l, l + t.remainder);
        break;
      } else
        s += a.substr(l, i.piece.length);
      i = i.next();
    }
    return s;
  }
  getLinesContent() {
    let e = [], t = 0, i = "", r = !1;
    return this.iterate(this.root, (o) => {
      if (o === je)
        return !0;
      const s = o.piece;
      let a = s.length;
      if (a === 0)
        return !0;
      const l = this._buffers[s.bufferIndex].buffer, u = this._buffers[s.bufferIndex].lineStarts, c = s.start.line, h = s.end.line;
      let d = u[c] + s.start.column;
      if (r && (l.charCodeAt(d) === 10 && (d++, a--), e[t++] = i, i = "", r = !1, a === 0))
        return !0;
      if (c === h)
        return !this._EOLNormalized && l.charCodeAt(d + a - 1) === 13 ? (r = !0, i += l.substr(d, a - 1)) : i += l.substr(d, a), !0;
      i += this._EOLNormalized ? l.substring(d, Math.max(d, u[c + 1] - this._EOLLength)) : l.substring(d, u[c + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      for (let f = c + 1; f < h; f++)
        i = this._EOLNormalized ? l.substring(u[f], u[f + 1] - this._EOLLength) : l.substring(u[f], u[f + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      return !this._EOLNormalized && l.charCodeAt(u[h] + s.end.column - 1) === 13 ? (r = !0, s.end.column === 0 ? t-- : i = l.substr(u[h], s.end.column - 1)) : i = l.substr(u[h], s.end.column), !0;
    }), r && (e[t++] = i, i = ""), e[t++] = i, e;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(e) {
    return this._lastVisitedLine.lineNumber === e ? this._lastVisitedLine.value : (this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent(e) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength) : this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, ""), this._lastVisitedLine.value);
  }
  _getCharCode(e) {
    if (e.remainder === e.node.piece.length) {
      let t = e.node.next();
      if (!t)
        return 0;
      let i = this._buffers[t.piece.bufferIndex], r = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start);
      return i.buffer.charCodeAt(r);
    } else {
      let t = this._buffers[e.node.piece.bufferIndex], r = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder;
      return t.buffer.charCodeAt(r);
    }
  }
  getLineCharCode(e, t) {
    let i = this.nodeAt2(e, t + 1);
    return this._getCharCode(i);
  }
  getLineLength(e) {
    if (e === this.getLineCount()) {
      let t = this.getOffsetAt(e, 1);
      return this.getLength() - t;
    }
    return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength;
  }
  findMatchesInNode(e, t, i, r, o, s, a, l, u, c, h) {
    let d = this._buffers[e.piece.bufferIndex], f = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start), p = this.offsetInBuffer(e.piece.bufferIndex, o), g = this.offsetInBuffer(e.piece.bufferIndex, s), _, m = { line: 0, column: 0 }, v, C;
    t._wordSeparators ? (v = d.buffer.substring(p, g), C = (y) => y + p, t.reset(0)) : (v = d.buffer, C = (y) => y, t.reset(p));
    do
      if (_ = t.next(v), _) {
        if (C(_.index) >= g)
          return c;
        this.positionInBuffer(e, C(_.index) - f, m);
        let y = this.getLineFeedCnt(e.piece.bufferIndex, o, m), w = m.line === o.line ? m.column - o.column + r : m.column + 1, L = w + _[0].length;
        if (h[c++] = Jh(new G(i + y, w, i + y, L), _, l), C(_.index) + _[0].length >= g || c >= u)
          return c;
      }
    while (_);
    return c;
  }
  findMatchesLineByLine(e, t, i, r) {
    const o = [];
    let s = 0;
    const a = new ev(t.wordSeparators, t.regex);
    let l = this.nodeAt2(e.startLineNumber, e.startColumn);
    if (l === null)
      return [];
    let u = this.nodeAt2(e.endLineNumber, e.endColumn);
    if (u === null)
      return [];
    let c = this.positionInBuffer(l.node, l.remainder), h = this.positionInBuffer(u.node, u.remainder);
    if (l.node === u.node)
      return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, c, h, t, i, r, s, o), o;
    let d = e.startLineNumber, f = l.node;
    for (; f !== u.node; ) {
      let g = this.getLineFeedCnt(f.piece.bufferIndex, c, f.piece.end);
      if (g >= 1) {
        let m = this._buffers[f.piece.bufferIndex].lineStarts, v = this.offsetInBuffer(f.piece.bufferIndex, f.piece.start), C = m[c.line + g], y = d === e.startLineNumber ? e.startColumn : 1;
        if (s = this.findMatchesInNode(f, a, d, y, c, this.positionInBuffer(f, C - v), t, i, r, s, o), s >= r)
          return o;
        d += g;
      }
      let _ = d === e.startLineNumber ? e.startColumn - 1 : 0;
      if (d === e.endLineNumber) {
        const m = this.getLineContent(d).substring(_, e.endColumn - 1);
        return s = this._findMatchesInLine(t, a, m, e.endLineNumber, _, s, o, i, r), o;
      }
      if (s = this._findMatchesInLine(t, a, this.getLineContent(d).substr(_), d, _, s, o, i, r), s >= r)
        return o;
      d++, l = this.nodeAt2(d, 1), f = l.node, c = this.positionInBuffer(l.node, l.remainder);
    }
    if (d === e.endLineNumber) {
      let g = d === e.startLineNumber ? e.startColumn - 1 : 0;
      const _ = this.getLineContent(d).substring(g, e.endColumn - 1);
      return s = this._findMatchesInLine(t, a, _, e.endLineNumber, g, s, o, i, r), o;
    }
    let p = d === e.startLineNumber ? e.startColumn : 1;
    return s = this.findMatchesInNode(u.node, a, d, p, c, h, t, i, r, s, o), o;
  }
  _findMatchesInLine(e, t, i, r, o, s, a, l, u) {
    const c = e.wordSeparators;
    if (!l && e.simpleSearch) {
      const d = e.simpleSearch, f = d.length, p = i.length;
      let g = -f;
      for (; (g = i.indexOf(d, g + f)) !== -1; )
        if ((!c || yI(c, i, p, g, f)) && (a[s++] = new Zv(new G(r, g + 1 + o, r, g + 1 + f + o), null), s >= u))
          return s;
      return s;
    }
    let h;
    t.reset(0);
    do
      if (h = t.next(i), h && (a[s++] = Jh(new G(r, h.index + 1 + o, r, h.index + 1 + h[0].length + o), h, l), s >= u))
        return s;
    while (h);
    return s;
  }
  // #endregion
  // #region Piece Table
  insert(e, t, i = !1) {
    if (this._EOLNormalized = this._EOLNormalized && i, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", this.root !== je) {
      let { node: r, remainder: o, nodeStartOffset: s } = this.nodeAt(e), a = r.piece, l = a.bufferIndex, u = this.positionInBuffer(r, o);
      if (r.piece.bufferIndex === 0 && a.end.line === this._lastChangeBufferPos.line && a.end.column === this._lastChangeBufferPos.column && s + a.length === e && t.length < bu) {
        this.appendToNode(r, t), this.computeBufferMetadata();
        return;
      }
      if (s === e)
        this.insertContentToNodeLeft(t, r), this._searchCache.validate(e);
      else if (s + r.piece.length > e) {
        let c = [], h = new mo(a.bufferIndex, u, a.end, this.getLineFeedCnt(a.bufferIndex, u, a.end), this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, u));
        if (this.shouldCheckCRLF() && this.endWithCR(t) && this.nodeCharCodeAt(r, o) === 10) {
          let g = { line: h.start.line + 1, column: 0 };
          h = new mo(h.bufferIndex, g, h.end, this.getLineFeedCnt(h.bufferIndex, g, h.end), h.length - 1), t += `
`;
        }
        if (this.shouldCheckCRLF() && this.startWithLF(t))
          if (this.nodeCharCodeAt(r, o - 1) === 13) {
            let g = this.positionInBuffer(r, o - 1);
            this.deleteNodeTail(r, g), t = "\r" + t, r.piece.length === 0 && c.push(r);
          } else
            this.deleteNodeTail(r, u);
        else
          this.deleteNodeTail(r, u);
        let d = this.createNewPieces(t);
        h.length > 0 && this.rbInsertRight(r, h);
        let f = r;
        for (let p = 0; p < d.length; p++)
          f = this.rbInsertRight(f, d[p]);
        this.deleteNodes(c);
      } else
        this.insertContentToNodeRight(t, r);
    } else {
      let r = this.createNewPieces(t), o = this.rbInsertLeft(null, r[0]);
      for (let s = 1; s < r.length; s++)
        o = this.rbInsertRight(o, r[s]);
    }
    this.computeBufferMetadata();
  }
  delete(e, t) {
    if (this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", t <= 0 || this.root === je)
      return;
    let i = this.nodeAt(e), r = this.nodeAt(e + t), o = i.node, s = r.node;
    if (o === s) {
      let d = this.positionInBuffer(o, i.remainder), f = this.positionInBuffer(o, r.remainder);
      if (i.nodeStartOffset === e) {
        if (t === o.piece.length) {
          let p = o.next();
          by(this, o), this.validateCRLFWithPrevNode(p), this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(o, f), this._searchCache.validate(e), this.validateCRLFWithPrevNode(o), this.computeBufferMetadata();
        return;
      }
      if (i.nodeStartOffset + o.piece.length === e + t) {
        this.deleteNodeTail(o, d), this.validateCRLFWithNextNode(o), this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(o, d, f), this.computeBufferMetadata();
      return;
    }
    let a = [], l = this.positionInBuffer(o, i.remainder);
    this.deleteNodeTail(o, l), this._searchCache.validate(e), o.piece.length === 0 && a.push(o);
    let u = this.positionInBuffer(s, r.remainder);
    this.deleteNodeHead(s, u), s.piece.length === 0 && a.push(s);
    let c = o.next();
    for (let d = c; d !== je && d !== s; d = d.next())
      a.push(d);
    let h = o.piece.length === 0 ? o.prev() : o;
    this.deleteNodes(a), this.validateCRLFWithNextNode(h), this.computeBufferMetadata();
  }
  insertContentToNodeLeft(e, t) {
    let i = [];
    if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
      let s = t.piece, a = { line: s.start.line + 1, column: 0 }, l = new mo(s.bufferIndex, a, s.end, this.getLineFeedCnt(s.bufferIndex, a, s.end), s.length - 1);
      t.piece = l, e += `
`, Ru(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    }
    let r = this.createNewPieces(e), o = this.rbInsertLeft(t, r[r.length - 1]);
    for (let s = r.length - 2; s >= 0; s--)
      o = this.rbInsertLeft(o, r[s]);
    this.validateCRLFWithPrevNode(o), this.deleteNodes(i);
  }
  insertContentToNodeRight(e, t) {
    this.adjustCarriageReturnFromNext(e, t) && (e += `
`);
    let i = this.createNewPieces(e), r = this.rbInsertRight(t, i[0]), o = r;
    for (let s = 1; s < i.length; s++)
      o = this.rbInsertRight(o, i[s]);
    this.validateCRLFWithPrevNode(r);
  }
  positionInBuffer(e, t, i) {
    let r = e.piece, o = e.piece.bufferIndex, s = this._buffers[o].lineStarts, l = s[r.start.line] + r.start.column + t, u = r.start.line, c = r.end.line, h = 0, d = 0, f = 0;
    for (; u <= c && (h = u + (c - u) / 2 | 0, f = s[h], h !== c); )
      if (d = s[h + 1], l < f)
        c = h - 1;
      else if (l >= d)
        u = h + 1;
      else
        break;
    return i ? (i.line = h, i.column = l - f, null) : {
      line: h,
      column: l - f
    };
  }
  getLineFeedCnt(e, t, i) {
    if (i.column === 0)
      return i.line - t.line;
    let r = this._buffers[e].lineStarts;
    if (i.line === r.length - 1)
      return i.line - t.line;
    let o = r[i.line + 1], s = r[i.line] + i.column;
    if (o > s + 1)
      return i.line - t.line;
    let a = s - 1;
    return this._buffers[e].buffer.charCodeAt(a) === 13 ? i.line - t.line + 1 : i.line - t.line;
  }
  offsetInBuffer(e, t) {
    return this._buffers[e].lineStarts[t.line] + t.column;
  }
  deleteNodes(e) {
    for (let t = 0; t < e.length; t++)
      by(this, e[t]);
  }
  createNewPieces(e) {
    if (e.length > bu) {
      let c = [];
      for (; e.length > bu; ) {
        const d = e.charCodeAt(bu - 1);
        let f;
        d === 13 || d >= 55296 && d <= 56319 ? (f = e.substring(0, bu - 1), e = e.substring(bu - 1)) : (f = e.substring(0, bu), e = e.substring(bu));
        let p = Ou(f);
        c.push(new mo(
          this._buffers.length,
          /* buffer index */
          { line: 0, column: 0 },
          { line: p.length - 1, column: f.length - p[p.length - 1] },
          p.length - 1,
          f.length
        )), this._buffers.push(new ed(f, p));
      }
      let h = Ou(e);
      return c.push(new mo(
        this._buffers.length,
        /* buffer index */
        { line: 0, column: 0 },
        { line: h.length - 1, column: e.length - h[h.length - 1] },
        h.length - 1,
        e.length
      )), this._buffers.push(new ed(e, h)), c;
    }
    let t = this._buffers[0].buffer.length;
    const i = Ou(e, !1);
    let r = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t && t !== 0 && this.startWithLF(e) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 }, r = this._lastChangeBufferPos;
      for (let c = 0; c < i.length; c++)
        i[c] += t + 1;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += "_" + e, t += 1;
    } else {
      if (t !== 0)
        for (let c = 0; c < i.length; c++)
          i[c] += t;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += e;
    }
    const o = this._buffers[0].buffer.length;
    let s = this._buffers[0].lineStarts.length - 1, a = o - this._buffers[0].lineStarts[s], l = { line: s, column: a }, u = new mo(
      0,
      /** todo@peng */
      r,
      l,
      this.getLineFeedCnt(0, r, l),
      o - t
    );
    return this._lastChangeBufferPos = l, [u];
  }
  getLineRawContent(e, t = 0) {
    let i = this.root, r = "", o = this._searchCache.get2(e);
    if (o) {
      i = o.node;
      let s = this.getAccumulatedValue(i, e - o.nodeStartLineNumber - 1), a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (o.nodeStartLineNumber + i.piece.lineFeedCnt === e)
        r = a.substring(l + s, l + i.piece.length);
      else {
        let u = this.getAccumulatedValue(i, e - o.nodeStartLineNumber);
        return a.substring(l + s, l + u - t);
      }
    } else {
      let s = 0;
      const a = e;
      for (; i !== je; )
        if (i.left !== je && i.lf_left >= e - 1)
          i = i.left;
        else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
          let l = this.getAccumulatedValue(i, e - i.lf_left - 2), u = this.getAccumulatedValue(i, e - i.lf_left - 1), c = this._buffers[i.piece.bufferIndex].buffer, h = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          return s += i.size_left, this._searchCache.set({
            node: i,
            nodeStartOffset: s,
            nodeStartLineNumber: a - (e - 1 - i.lf_left)
          }), c.substring(h + l, h + u - t);
        } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
          let l = this.getAccumulatedValue(i, e - i.lf_left - 2), u = this._buffers[i.piece.bufferIndex].buffer, c = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          r = u.substring(c + l, c + i.piece.length);
          break;
        } else
          e -= i.lf_left + i.piece.lineFeedCnt, s += i.size_left + i.piece.length, i = i.right;
    }
    for (i = i.next(); i !== je; ) {
      let s = this._buffers[i.piece.bufferIndex].buffer;
      if (i.piece.lineFeedCnt > 0) {
        let a = this.getAccumulatedValue(i, 0), l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        return r += s.substring(l, l + a - t), r;
      } else {
        let a = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        r += s.substr(a, i.piece.length);
      }
      i = i.next();
    }
    return r;
  }
  computeBufferMetadata() {
    let e = this.root, t = 1, i = 0;
    for (; e !== je; )
      t += e.lf_left + e.piece.lineFeedCnt, i += e.size_left + e.piece.length, e = e.right;
    this._lineCnt = t, this._length = i, this._searchCache.validate(this._length);
  }
  // #region node operations
  getIndexOf(e, t) {
    let i = e.piece, r = this.positionInBuffer(e, t), o = r.line - i.start.line;
    if (this.offsetInBuffer(i.bufferIndex, i.end) - this.offsetInBuffer(i.bufferIndex, i.start) === t) {
      let s = this.getLineFeedCnt(e.piece.bufferIndex, i.start, r);
      if (s !== o)
        return { index: s, remainder: 0 };
    }
    return { index: o, remainder: r.column };
  }
  getAccumulatedValue(e, t) {
    if (t < 0)
      return 0;
    let i = e.piece, r = this._buffers[i.bufferIndex].lineStarts, o = i.start.line + t + 1;
    return o > i.end.line ? r[i.end.line] + i.end.column - r[i.start.line] - i.start.column : r[o] - r[i.start.line] - i.start.column;
  }
  deleteNodeTail(e, t) {
    const i = e.piece, r = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.end), s = t, a = this.offsetInBuffer(i.bufferIndex, s), l = this.getLineFeedCnt(i.bufferIndex, i.start, s), u = l - r, c = a - o, h = i.length + c;
    e.piece = new mo(i.bufferIndex, i.start, s, l, h), Ru(this, e, c, u);
  }
  deleteNodeHead(e, t) {
    const i = e.piece, r = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.start), s = t, a = this.getLineFeedCnt(i.bufferIndex, s, i.end), l = this.offsetInBuffer(i.bufferIndex, s), u = a - r, c = o - l, h = i.length + c;
    e.piece = new mo(i.bufferIndex, s, i.end, a, h), Ru(this, e, c, u);
  }
  shrinkNode(e, t, i) {
    const r = e.piece, o = r.start, s = r.end, a = r.length, l = r.lineFeedCnt, u = t, c = this.getLineFeedCnt(r.bufferIndex, r.start, u), h = this.offsetInBuffer(r.bufferIndex, t) - this.offsetInBuffer(r.bufferIndex, o);
    e.piece = new mo(r.bufferIndex, r.start, u, c, h), Ru(this, e, h - a, c - l);
    let d = new mo(r.bufferIndex, i, s, this.getLineFeedCnt(r.bufferIndex, i, s), this.offsetInBuffer(r.bufferIndex, s) - this.offsetInBuffer(r.bufferIndex, i)), f = this.rbInsertRight(e, d);
    this.validateCRLFWithPrevNode(f);
  }
  appendToNode(e, t) {
    this.adjustCarriageReturnFromNext(t, e) && (t += `
`);
    const i = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e), r = this._buffers[0].buffer.length;
    this._buffers[0].buffer += t;
    const o = Ou(t, !1);
    for (let f = 0; f < o.length; f++)
      o[f] += r;
    if (i) {
      let f = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: r - f };
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(o.slice(1));
    const s = this._buffers[0].lineStarts.length - 1, a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[s], l = { line: s, column: a }, u = e.piece.length + t.length, c = e.piece.lineFeedCnt, h = this.getLineFeedCnt(0, e.piece.start, l), d = h - c;
    e.piece = new mo(e.piece.bufferIndex, e.piece.start, l, h, u), this._lastChangeBufferPos = l, Ru(this, e, t.length, d);
  }
  nodeAt(e) {
    let t = this.root, i = this._searchCache.get(e);
    if (i)
      return {
        node: i.node,
        nodeStartOffset: i.nodeStartOffset,
        remainder: e - i.nodeStartOffset
      };
    let r = 0;
    for (; t !== je; )
      if (t.size_left > e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        r += t.size_left;
        let o = {
          node: t,
          remainder: e - t.size_left,
          nodeStartOffset: r
        };
        return this._searchCache.set(o), o;
      } else
        e -= t.size_left + t.piece.length, r += t.size_left + t.piece.length, t = t.right;
    return null;
  }
  nodeAt2(e, t) {
    let i = this.root, r = 0;
    for (; i !== je; )
      if (i.left !== je && i.lf_left >= e - 1)
        i = i.left;
      else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
        let o = this.getAccumulatedValue(i, e - i.lf_left - 2), s = this.getAccumulatedValue(i, e - i.lf_left - 1);
        return r += i.size_left, {
          node: i,
          remainder: Math.min(o + t - 1, s),
          nodeStartOffset: r
        };
      } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
        let o = this.getAccumulatedValue(i, e - i.lf_left - 2);
        if (o + t - 1 <= i.piece.length)
          return {
            node: i,
            remainder: o + t - 1,
            nodeStartOffset: r
          };
        t -= i.piece.length - o;
        break;
      } else
        e -= i.lf_left + i.piece.lineFeedCnt, r += i.size_left + i.piece.length, i = i.right;
    for (i = i.next(); i !== je; ) {
      if (i.piece.lineFeedCnt > 0) {
        let o = this.getAccumulatedValue(i, 0), s = this.offsetOfNode(i);
        return {
          node: i,
          remainder: Math.min(t - 1, o),
          nodeStartOffset: s
        };
      } else if (i.piece.length >= t - 1) {
        let o = this.offsetOfNode(i);
        return {
          node: i,
          remainder: t - 1,
          nodeStartOffset: o
        };
      } else
        t -= i.piece.length;
      i = i.next();
    }
    return null;
  }
  nodeCharCodeAt(e, t) {
    if (e.piece.lineFeedCnt < 1)
      return -1;
    let i = this._buffers[e.piece.bufferIndex], r = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t;
    return i.buffer.charCodeAt(r);
  }
  offsetOfNode(e) {
    if (!e)
      return 0;
    let t = e.size_left;
    for (; e !== this.root; )
      e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), e = e.parent;
    return t;
  }
  // #endregion
  // #region CRLF
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === `
`);
  }
  startWithLF(e) {
    if (typeof e == "string")
      return e.charCodeAt(0) === 10;
    if (e === je || e.piece.lineFeedCnt === 0)
      return !1;
    let t = e.piece, i = this._buffers[t.bufferIndex].lineStarts, r = t.start.line, o = i[r] + t.start.column;
    return r === i.length - 1 || i[r + 1] > o + 1 ? !1 : this._buffers[t.bufferIndex].buffer.charCodeAt(o) === 10;
  }
  endWithCR(e) {
    return typeof e == "string" ? e.charCodeAt(e.length - 1) === 13 : e === je || e.piece.lineFeedCnt === 0 ? !1 : this.nodeCharCodeAt(e, e.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(e) {
    if (this.shouldCheckCRLF() && this.startWithLF(e)) {
      let t = e.prev();
      this.endWithCR(t) && this.fixCRLF(t, e);
    }
  }
  validateCRLFWithNextNode(e) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      let t = e.next();
      this.startWithLF(t) && this.fixCRLF(e, t);
    }
  }
  fixCRLF(e, t) {
    let i = [], r = this._buffers[e.piece.bufferIndex].lineStarts, o;
    e.piece.end.column === 0 ? o = { line: e.piece.end.line - 1, column: r[e.piece.end.line] - r[e.piece.end.line - 1] - 1 } : o = { line: e.piece.end.line, column: e.piece.end.column - 1 };
    const s = e.piece.length - 1, a = e.piece.lineFeedCnt - 1;
    e.piece = new mo(e.piece.bufferIndex, e.piece.start, o, a, s), Ru(this, e, -1, -1), e.piece.length === 0 && i.push(e);
    let l = { line: t.piece.start.line + 1, column: 0 };
    const u = t.piece.length - 1, c = this.getLineFeedCnt(t.piece.bufferIndex, l, t.piece.end);
    t.piece = new mo(t.piece.bufferIndex, l, t.piece.end, c, u), Ru(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    let h = this.createNewPieces(`\r
`);
    this.rbInsertRight(e, h[0]);
    for (let d = 0; d < i.length; d++)
      by(this, i[d]);
  }
  adjustCarriageReturnFromNext(e, t) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      let i = t.next();
      if (this.startWithLF(i)) {
        if (e += `
`, i.piece.length === 1)
          by(this, i);
        else {
          const r = i.piece, o = { line: r.start.line + 1, column: 0 }, s = r.length - 1, a = this.getLineFeedCnt(r.bufferIndex, o, r.end);
          i.piece = new mo(r.bufferIndex, o, r.end, a, s), Ru(this, i, -1, -1);
        }
        return !0;
      }
    }
    return !1;
  }
  // #endregion
  // #endregion
  // #region Tree operations
  iterate(e, t) {
    if (e === je)
      return t(je);
    let i = this.iterate(e.left, t);
    return i && t(e) && this.iterate(e.right, t);
  }
  getNodeContent(e) {
    if (e === je)
      return "";
    let t = this._buffers[e.piece.bufferIndex], i, r = e.piece, o = this.offsetInBuffer(r.bufferIndex, r.start), s = this.offsetInBuffer(r.bufferIndex, r.end);
    return i = t.buffer.substring(o, s), i;
  }
  getPieceContent(e) {
    let t = this._buffers[e.bufferIndex], i = this.offsetInBuffer(e.bufferIndex, e.start), r = this.offsetInBuffer(e.bufferIndex, e.end);
    return t.buffer.substring(i, r);
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b    <----   a    b
   *                         /
   *                        z
   */
  rbInsertRight(e, t) {
    let i = new JT(
      t,
      1
      /* Red */
    );
    if (i.left = je, i.right = je, i.parent = je, i.size_left = 0, i.lf_left = 0, this.root === je)
      this.root = i, i.color = 0;
    else if (e.right === je)
      e.right = i, i.parent = e;
    else {
      let o = vI(e.right);
      o.left = i, i.parent = o;
    }
    return R2(this, i), i;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b     ---->   a    b
   *                       \
   *                        z
   */
  rbInsertLeft(e, t) {
    let i = new JT(
      t,
      1
      /* Red */
    );
    if (i.left = je, i.right = je, i.parent = je, i.size_left = 0, i.lf_left = 0, this.root === je)
      this.root = i, i.color = 0;
    else if (e.left === je)
      e.left = i, i.parent = e;
    else {
      let r = k3(e.left);
      r.right = i, i.parent = r;
    }
    return R2(this, i), i;
  }
}
function r_(n) {
  let e = 0, t = 0, i = 0, r = 0;
  for (let o = 0, s = n.length; o < s; o++) {
    const a = n.charCodeAt(o);
    a === 13 ? (e === 0 && (t = o), e++, o + 1 < s && n.charCodeAt(o + 1) === 10 ? (r |= 2, o++) : r |= 3, i = o + 1) : a === 10 && (r |= 1, e === 0 && (t = o), e++, i = o + 1);
  }
  return e === 0 && (t = n.length), [e, t, n.length - i, r];
}
function O2(n) {
  return (n << 0 | 0 << 8 | 0 << 11 | 1 << 14 | 2 << 23) >>> 0;
}
const Su = new Uint32Array(0).buffer;
class MD {
  constructor() {
    this.tokens = [];
  }
  add(e, t) {
    if (this.tokens.length > 0) {
      const i = this.tokens[this.tokens.length - 1];
      if (i.startLineNumber + i.tokens.length - 1 + 1 === e) {
        i.tokens.push(t);
        return;
      }
    }
    this.tokens.push(new Mue(e, [t]));
  }
}
class Wb {
  constructor(e) {
    this._tokens = e, this._tokenCount = e.length / 4;
  }
  toString(e) {
    let t = [];
    for (let i = 0; i < this._tokenCount; i++)
      t.push(`(${this._getDeltaLine(i) + e},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);
    return `[${t.join(",")}]`;
  }
  getMaxDeltaLine() {
    const e = this._getTokenCount();
    return e === 0 ? -1 : this._getDeltaLine(e - 1);
  }
  getRange() {
    const e = this._getTokenCount();
    if (e === 0)
      return null;
    const t = this._getStartCharacter(0), i = this._getDeltaLine(e - 1), r = this._getEndCharacter(e - 1);
    return new G(0, t + 1, i, r + 1);
  }
  _getTokenCount() {
    return this._tokenCount;
  }
  _getDeltaLine(e) {
    return this._tokens[4 * e];
  }
  _getStartCharacter(e) {
    return this._tokens[4 * e + 1];
  }
  _getEndCharacter(e) {
    return this._tokens[4 * e + 2];
  }
  isEmpty() {
    return this._getTokenCount() === 0;
  }
  getLineTokens(e) {
    let t = 0, i = this._getTokenCount() - 1;
    for (; t < i; ) {
      const r = t + Math.floor((i - t) / 2), o = this._getDeltaLine(r);
      if (o < e)
        t = r + 1;
      else if (o > e)
        i = r - 1;
      else {
        let s = r;
        for (; s > t && this._getDeltaLine(s - 1) === e; )
          s--;
        let a = r;
        for (; a < i && this._getDeltaLine(a + 1) === e; )
          a++;
        return new x2(this._tokens.subarray(4 * s, 4 * a + 4));
      }
    }
    return this._getDeltaLine(t) === e ? new x2(this._tokens.subarray(4 * t, 4 * t + 4)) : null;
  }
  clear() {
    this._tokenCount = 0;
  }
  removeTokens(e, t, i, r) {
    const o = this._tokens, s = this._tokenCount;
    let a = 0, l = !1, u = 0;
    for (let c = 0; c < s; c++) {
      const h = 4 * c, d = o[h], f = o[h + 1], p = o[h + 2], g = o[h + 3];
      if ((d > e || d === e && p >= t) && (d < i || d === i && f <= r))
        l = !0;
      else {
        if (a === 0 && (u = d), l) {
          const _ = 4 * a;
          o[_] = d - u, o[_ + 1] = f, o[_ + 2] = p, o[_ + 3] = g;
        }
        a++;
      }
    }
    return this._tokenCount = a, u;
  }
  split(e, t, i, r) {
    const o = this._tokens, s = this._tokenCount;
    let a = [], l = [], u = a, c = 0, h = 0;
    for (let d = 0; d < s; d++) {
      const f = 4 * d, p = o[f], g = o[f + 1], _ = o[f + 2], m = o[f + 3];
      if (p > e || p === e && _ >= t) {
        if (p < i || p === i && g <= r)
          continue;
        u !== l && (u = l, c = 0, h = p);
      }
      u[c++] = p - h, u[c++] = g, u[c++] = _, u[c++] = m;
    }
    return [new Wb(new Uint32Array(a)), new Wb(new Uint32Array(l)), h];
  }
  acceptDeleteRange(e, t, i, r, o) {
    const s = this._tokens, a = this._tokenCount, l = r - t;
    let u = 0, c = !1;
    for (let h = 0; h < a; h++) {
      const d = 4 * h;
      let f = s[d], p = s[d + 1], g = s[d + 2];
      const _ = s[d + 3];
      if (f < t || f === t && g <= i) {
        u++;
        continue;
      } else if (f === t && p < i)
        f === r && g > o ? g -= o - i : g = i;
      else if (f === t && p === i)
        if (f === r && g > o)
          g -= o - i;
        else {
          c = !0;
          continue;
        }
      else if (f < r || f === r && p < o)
        if (f === r && g > o)
          f === t ? (p = i, g = p + (g - o)) : (p = 0, g = p + (g - o));
        else {
          c = !0;
          continue;
        }
      else if (f > r) {
        if (l === 0 && !c) {
          u = a;
          break;
        }
        f -= l;
      } else if (f === r && p >= o)
        e && f === 0 && (p += e, g += e), f -= l, p -= o - i, g -= o - i;
      else
        throw new Error("Not possible!");
      const m = 4 * u;
      s[m] = f, s[m + 1] = p, s[m + 2] = g, s[m + 3] = _, u++;
    }
    this._tokenCount = u;
  }
  acceptInsertText(e, t, i, r, o, s) {
    const a = i === 0 && r === 1 && (s >= 48 && s <= 57 || s >= 65 && s <= 90 || s >= 97 && s <= 122), l = this._tokens, u = this._tokenCount;
    for (let c = 0; c < u; c++) {
      const h = 4 * c;
      let d = l[h], f = l[h + 1], p = l[h + 2];
      if (!(d < e || d === e && p < t)) {
        if (d === e && p === t)
          if (a)
            p += 1;
          else
            continue;
        else if (d === e && f < t && t < p)
          i === 0 ? p += r : p = t;
        else {
          if (d === e && f === t && a)
            continue;
          if (d === e)
            if (d += i, i === 0)
              f += r, p += r;
            else {
              const g = p - f;
              f = o + (f - t), p = f + g;
            }
          else
            d += i;
        }
        l[h] = d, l[h + 1] = f, l[h + 2] = p;
      }
    }
  }
}
class x2 {
  constructor(e) {
    this._tokens = e;
  }
  getCount() {
    return this._tokens.length / 4;
  }
  getStartCharacter(e) {
    return this._tokens[4 * e + 1];
  }
  getEndCharacter(e) {
    return this._tokens[4 * e + 2];
  }
  getMetadata(e) {
    return this._tokens[4 * e + 3];
  }
}
class Vb {
  constructor(e, t) {
    this.startLineNumber = e, this.tokens = t, this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();
  }
  toString() {
    return this.tokens.toString(this.startLineNumber);
  }
  _updateEndLineNumber() {
    this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();
  }
  isEmpty() {
    return this.tokens.isEmpty();
  }
  getLineTokens(e) {
    return this.startLineNumber <= e && e <= this.endLineNumber ? this.tokens.getLineTokens(e - this.startLineNumber) : null;
  }
  getRange() {
    const e = this.tokens.getRange();
    return e && new G(this.startLineNumber + e.startLineNumber, e.startColumn, this.startLineNumber + e.endLineNumber, e.endColumn);
  }
  removeTokens(e) {
    const t = e.startLineNumber - this.startLineNumber, i = e.endLineNumber - this.startLineNumber;
    this.startLineNumber += this.tokens.removeTokens(t, e.startColumn - 1, i, e.endColumn - 1), this._updateEndLineNumber();
  }
  split(e) {
    const t = e.startLineNumber - this.startLineNumber, i = e.endLineNumber - this.startLineNumber, [r, o, s] = this.tokens.split(t, e.startColumn - 1, i, e.endColumn - 1);
    return [new Vb(this.startLineNumber, r), new Vb(this.startLineNumber + s, o)];
  }
  applyEdit(e, t) {
    const [i, r, o] = r_(t);
    this.acceptEdit(
      e,
      i,
      r,
      o,
      t.length > 0 ? t.charCodeAt(0) : 0
      /* Null */
    );
  }
  acceptEdit(e, t, i, r, o) {
    this._acceptDeleteRange(e), this._acceptInsertText(new ie(e.startLineNumber, e.startColumn), t, i, r, o), this._updateEndLineNumber();
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return;
    const t = e.startLineNumber - this.startLineNumber, i = e.endLineNumber - this.startLineNumber;
    if (i < 0) {
      const o = i - t;
      this.startLineNumber -= o;
      return;
    }
    const r = this.tokens.getMaxDeltaLine();
    if (!(t >= r + 1)) {
      if (t < 0 && i >= r + 1) {
        this.startLineNumber = 0, this.tokens.clear();
        return;
      }
      if (t < 0) {
        const o = -t;
        this.startLineNumber -= o, this.tokens.acceptDeleteRange(e.startColumn - 1, 0, 0, i, e.endColumn - 1);
      } else
        this.tokens.acceptDeleteRange(0, t, e.startColumn - 1, i, e.endColumn - 1);
    }
  }
  _acceptInsertText(e, t, i, r, o) {
    if (t === 0 && i === 0)
      return;
    const s = e.lineNumber - this.startLineNumber;
    if (s < 0) {
      this.startLineNumber += t;
      return;
    }
    const a = this.tokens.getMaxDeltaLine();
    s >= a + 1 || this.tokens.acceptInsertText(s, e.column - 1, t, i, r, o);
  }
}
class Mue {
  constructor(e, t) {
    this.startLineNumber = e, this.tokens = t;
  }
}
function Eu(n) {
  return n instanceof Uint32Array ? n : new Uint32Array(n);
}
class wI {
  constructor() {
    this._pieces = [], this._isComplete = !1;
  }
  flush() {
    this._pieces = [], this._isComplete = !1;
  }
  isEmpty() {
    return this._pieces.length === 0;
  }
  set(e, t) {
    this._pieces = e || [], this._isComplete = t;
  }
  setPartial(e, t) {
    let i = e;
    if (t.length > 0) {
      const o = t[0].getRange(), s = t[t.length - 1].getRange();
      if (!o || !s)
        return e;
      i = e.plusRange(o).plusRange(s);
    }
    let r = null;
    for (let o = 0, s = this._pieces.length; o < s; o++) {
      const a = this._pieces[o];
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        r = r || { index: o };
        break;
      }
      if (a.removeTokens(i), a.isEmpty()) {
        this._pieces.splice(o, 1), o--, s--;
        continue;
      }
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        r = r || { index: o };
        continue;
      }
      const [l, u] = a.split(i);
      if (l.isEmpty()) {
        r = r || { index: o };
        continue;
      }
      u.isEmpty() || (this._pieces.splice(o, 1, l, u), o++, s++, r = r || { index: o });
    }
    return r = r || { index: this._pieces.length }, t.length > 0 && (this._pieces = Jv(this._pieces, r.index, t)), i;
  }
  isComplete() {
    return this._isComplete;
  }
  addSemanticTokens(e, t) {
    const i = this._pieces;
    if (i.length === 0)
      return t;
    const r = wI._findFirstPieceWithLine(i, e), o = i[r].getLineTokens(e);
    if (!o)
      return t;
    const s = t.getCount(), a = o.getCount();
    let l = 0, u = [], c = 0, h = 0;
    const d = (f, p) => {
      f !== h && (h = f, u[c++] = f, u[c++] = p);
    };
    for (let f = 0; f < a; f++) {
      const p = o.getStartCharacter(f), g = o.getEndCharacter(f), _ = o.getMetadata(f), m = ((_ & 1 ? 2048 : 0) | (_ & 2 ? 4096 : 0) | (_ & 4 ? 8192 : 0) | (_ & 8 ? 8372224 : 0) | (_ & 16 ? 4286578688 : 0)) >>> 0, v = ~m >>> 0;
      for (; l < s && t.getEndOffset(l) <= p; )
        d(t.getEndOffset(l), t.getMetadata(l)), l++;
      for (l < s && t.getStartOffset(l) < p && d(p, t.getMetadata(l)); l < s && t.getEndOffset(l) < g; )
        d(t.getEndOffset(l), t.getMetadata(l) & v | _ & m), l++;
      if (l < s)
        d(g, t.getMetadata(l) & v | _ & m), t.getEndOffset(l) === g && l++;
      else {
        const C = Math.min(Math.max(0, l - 1), s - 1);
        d(g, t.getMetadata(C) & v | _ & m);
      }
    }
    for (; l < s; )
      d(t.getEndOffset(l), t.getMetadata(l)), l++;
    return new eo(new Uint32Array(u), t.getLineContent());
  }
  static _findFirstPieceWithLine(e, t) {
    let i = 0, r = e.length - 1;
    for (; i < r; ) {
      let o = i + Math.floor((r - i) / 2);
      if (e[o].endLineNumber < t)
        i = o + 1;
      else if (e[o].startLineNumber > t)
        r = o - 1;
      else {
        for (; o > i && e[o - 1].startLineNumber <= t && t <= e[o - 1].endLineNumber; )
          o--;
        return o;
      }
    }
    return i;
  }
  //#region Editing
  acceptEdit(e, t, i, r, o) {
    for (const s of this._pieces)
      s.acceptEdit(e, t, i, r, o);
  }
}
class hs {
  constructor() {
    this._lineTokens = [], this._len = 0;
  }
  flush() {
    this._lineTokens = [], this._len = 0;
  }
  getTokens(e, t, i) {
    let r = null;
    if (t < this._len && (r = this._lineTokens[t]), r !== null && r !== Su)
      return new eo(Eu(r), i);
    let o = new Uint32Array(2);
    return o[0] = i.length, o[1] = O2(e), new eo(o, i);
  }
  static _massageTokens(e, t, i) {
    const r = i ? Eu(i) : null;
    if (t === 0) {
      let o = !1;
      if (r && r.length > 1 && (o = la.getLanguageId(r[1]) !== e), !o)
        return Su;
    }
    if (!r || r.length === 0) {
      const o = new Uint32Array(2);
      return o[0] = t, o[1] = O2(e), o.buffer;
    }
    return r[r.length - 2] = t, r.byteOffset === 0 && r.byteLength === r.buffer.byteLength ? r.buffer : r;
  }
  _ensureLine(e) {
    for (; e >= this._len; )
      this._lineTokens[this._len] = null, this._len++;
  }
  _deleteLines(e, t) {
    t !== 0 && (e + t > this._len && (t = this._len - e), this._lineTokens.splice(e, t), this._len -= t);
  }
  _insertLines(e, t) {
    if (t === 0)
      return;
    let i = [];
    for (let r = 0; r < t; r++)
      i[r] = null;
    this._lineTokens = Jv(this._lineTokens, e, i), this._len += t;
  }
  setTokens(e, t, i, r, o) {
    const s = hs._massageTokens(e, i, r);
    this._ensureLine(t);
    const a = this._lineTokens[t];
    return this._lineTokens[t] = s, o ? !hs._equals(a, s) : !1;
  }
  static _equals(e, t) {
    if (!e || !t)
      return !e && !t;
    const i = Eu(e), r = Eu(t);
    if (i.length !== r.length)
      return !1;
    for (let o = 0, s = i.length; o < s; o++)
      if (i[o] !== r[o])
        return !1;
    return !0;
  }
  //#region Editing
  acceptEdit(e, t, i) {
    this._acceptDeleteRange(e), this._acceptInsertText(new ie(e.startLineNumber, e.startColumn), t, i);
  }
  _acceptDeleteRange(e) {
    const t = e.startLineNumber - 1;
    if (t >= this._len)
      return;
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._lineTokens[t] = hs._delete(this._lineTokens[t], e.startColumn - 1, e.endColumn - 1);
      return;
    }
    this._lineTokens[t] = hs._deleteEnding(this._lineTokens[t], e.startColumn - 1);
    const i = e.endLineNumber - 1;
    let r = null;
    i < this._len && (r = hs._deleteBeginning(this._lineTokens[i], e.endColumn - 1)), this._lineTokens[t] = hs._append(this._lineTokens[t], r), this._deleteLines(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t, i) {
    if (t === 0 && i === 0)
      return;
    const r = e.lineNumber - 1;
    if (!(r >= this._len)) {
      if (t === 0) {
        this._lineTokens[r] = hs._insert(this._lineTokens[r], e.column - 1, i);
        return;
      }
      this._lineTokens[r] = hs._deleteEnding(this._lineTokens[r], e.column - 1), this._lineTokens[r] = hs._insert(this._lineTokens[r], e.column - 1, i), this._insertLines(e.lineNumber, t);
    }
  }
  static _deleteBeginning(e, t) {
    return e === null || e === Su ? e : hs._delete(e, 0, t);
  }
  static _deleteEnding(e, t) {
    if (e === null || e === Su)
      return e;
    const i = Eu(e), r = i[i.length - 2];
    return hs._delete(e, t, r);
  }
  static _delete(e, t, i) {
    if (e === null || e === Su || t === i)
      return e;
    const r = Eu(e), o = r.length >>> 1;
    if (t === 0 && r[r.length - 2] === i)
      return Su;
    const s = eo.findIndexInTokensArray(r, t), a = s > 0 ? r[s - 1 << 1] : 0, l = r[s << 1];
    if (i < l) {
      const f = i - t;
      for (let p = s; p < o; p++)
        r[p << 1] -= f;
      return e;
    }
    let u, c;
    a !== t ? (r[s << 1] = t, u = s + 1 << 1, c = t) : (u = s << 1, c = a);
    const h = i - t;
    for (let f = s + 1; f < o; f++) {
      const p = r[f << 1] - h;
      p > c && (r[u++] = p, r[u++] = r[(f << 1) + 1], c = p);
    }
    if (u === r.length)
      return e;
    let d = new Uint32Array(u);
    return d.set(r.subarray(0, u), 0), d.buffer;
  }
  static _append(e, t) {
    if (t === Su)
      return e;
    if (e === Su)
      return t;
    if (e === null)
      return e;
    if (t === null)
      return null;
    const i = Eu(e), r = Eu(t), o = r.length >>> 1;
    let s = new Uint32Array(i.length + r.length);
    s.set(i, 0);
    let a = i.length;
    const l = i[i.length - 2];
    for (let u = 0; u < o; u++)
      s[a++] = r[u << 1] + l, s[a++] = r[(u << 1) + 1];
    return s.buffer;
  }
  static _insert(e, t, i) {
    if (e === null || e === Su)
      return e;
    const r = Eu(e), o = r.length >>> 1;
    let s = eo.findIndexInTokensArray(r, t);
    s > 0 && r[s - 1 << 1] === t && s--;
    for (let a = s; a < o; a++)
      r[a << 1] += i;
    return e;
  }
}
class Ip extends Ce {
  constructor(e, t, i, r, o, s, a) {
    super(), this._onDidChangeContent = this._register(new q()), this._BOM = t, this._mightContainNonBasicASCII = !s, this._mightContainRTL = r, this._mightContainUnusualLineTerminators = o, this._pieceTree = new Aue(e, i, a);
  }
  mightContainRTL() {
    return this._mightContainRTL;
  }
  mightContainUnusualLineTerminators() {
    return this._mightContainUnusualLineTerminators;
  }
  resetMightContainUnusualLineTerminators() {
    this._mightContainUnusualLineTerminators = !1;
  }
  mightContainNonBasicASCII() {
    return this._mightContainNonBasicASCII;
  }
  getBOM() {
    return this._BOM;
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  createSnapshot(e) {
    return this._pieceTree.createSnapshot(e ? this._BOM : "");
  }
  getOffsetAt(e, t) {
    return this._pieceTree.getOffsetAt(e, t);
  }
  getPositionAt(e) {
    return this._pieceTree.getPositionAt(e);
  }
  getRangeAt(e, t) {
    let i = e + t;
    const r = this.getPositionAt(e), o = this.getPositionAt(i);
    return new G(r.lineNumber, r.column, o.lineNumber, o.column);
  }
  getValueInRange(e, t = 0) {
    if (e.isEmpty())
      return "";
    const i = this._getEndOfLine(t);
    return this._pieceTree.getValueInRange(e, i);
  }
  getValueLengthInRange(e, t = 0) {
    if (e.isEmpty())
      return 0;
    if (e.startLineNumber === e.endLineNumber)
      return e.endColumn - e.startColumn;
    let i = this.getOffsetAt(e.startLineNumber, e.startColumn);
    return this.getOffsetAt(e.endLineNumber, e.endColumn) - i;
  }
  getCharacterCountInRange(e, t = 0) {
    if (this._mightContainNonBasicASCII) {
      let i = 0;
      const r = e.startLineNumber, o = e.endLineNumber;
      for (let s = r; s <= o; s++) {
        const a = this.getLineContent(s), l = s === r ? e.startColumn - 1 : 0, u = s === o ? e.endColumn - 1 : a.length;
        for (let c = l; c < u; c++)
          Kn(a.charCodeAt(c)) ? (i = i + 1, c = c + 1) : i = i + 1;
      }
      return i += this._getEndOfLine(t).length * (o - r), i;
    }
    return this.getValueLengthInRange(e, t);
  }
  getLength() {
    return this._pieceTree.getLength();
  }
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  getLinesContent() {
    return this._pieceTree.getLinesContent();
  }
  getLineContent(e) {
    return this._pieceTree.getLineContent(e);
  }
  getLineCharCode(e, t) {
    return this._pieceTree.getLineCharCode(e, t);
  }
  getLineLength(e) {
    return this._pieceTree.getLineLength(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = Os(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = Ng(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  _getEndOfLine(e) {
    switch (e) {
      case 1:
        return `
`;
      case 2:
        return `\r
`;
      case 0:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  setEOL(e) {
    this._pieceTree.setEOL(e);
  }
  applyEdits(e, t, i) {
    let r = this._mightContainRTL, o = this._mightContainUnusualLineTerminators, s = this._mightContainNonBasicASCII, a = !0, l = [];
    for (let g = 0; g < e.length; g++) {
      let _ = e[g];
      a && _._isTracked && (a = !1);
      let m = _.range;
      if (_.text) {
        let L = !0;
        s || (L = !_5(_.text), s = L), !r && L && (r = GN(_.text)), !o && L && (o = y5(_.text));
      }
      let v = "", C = 0, y = 0, w = 0;
      if (_.text) {
        let L;
        [C, y, w, L] = r_(_.text);
        const S = this.getEOL();
        L === 0 || L === (S === `\r
` ? 2 : 1) ? v = _.text : v = _.text.replace(/\r\n|\r|\n/g, S);
      }
      l[g] = {
        sortIndex: g,
        identifier: _.identifier || null,
        range: m,
        rangeOffset: this.getOffsetAt(m.startLineNumber, m.startColumn),
        rangeLength: this.getValueLengthInRange(m),
        text: v,
        eolCount: C,
        firstLineLength: y,
        lastLineLength: w,
        forceMoveMarkers: !!_.forceMoveMarkers,
        isAutoWhitespaceEdit: _.isAutoWhitespaceEdit || !1
      };
    }
    l.sort(Ip._sortOpsAscending);
    let u = !1;
    for (let g = 0, _ = l.length - 1; g < _; g++) {
      let m = l[g].range.getEndPosition(), v = l[g + 1].range.getStartPosition();
      if (v.isBeforeOrEqual(m)) {
        if (v.isBefore(m))
          throw new Error("Overlapping ranges are not allowed!");
        u = !0;
      }
    }
    a && (l = this._reduceOperations(l));
    let c = i || t ? Ip._getInverseEditRanges(l) : [], h = [];
    if (t)
      for (let g = 0; g < l.length; g++) {
        let _ = l[g], m = c[g];
        if (_.isAutoWhitespaceEdit && _.range.isEmpty())
          for (let v = m.startLineNumber; v <= m.endLineNumber; v++) {
            let C = "";
            v === m.startLineNumber && (C = this.getLineContent(_.range.startLineNumber), Os(C) !== -1) || h.push({ lineNumber: v, oldContent: C });
          }
      }
    let d = null;
    if (i) {
      let g = 0;
      d = [];
      for (let _ = 0; _ < l.length; _++) {
        const m = l[_], v = c[_], C = this.getValueInRange(m.range), y = m.rangeOffset + g;
        g += m.text.length - C.length, d[_] = {
          sortIndex: m.sortIndex,
          identifier: m.identifier,
          range: v,
          text: C,
          textChange: new $n(m.rangeOffset, C, y, m.text)
        };
      }
      u || d.sort((_, m) => _.sortIndex - m.sortIndex);
    }
    this._mightContainRTL = r, this._mightContainUnusualLineTerminators = o, this._mightContainNonBasicASCII = s;
    const f = this._doApplyEdits(l);
    let p = null;
    if (t && h.length > 0) {
      h.sort((g, _) => _.lineNumber - g.lineNumber), p = [];
      for (let g = 0, _ = h.length; g < _; g++) {
        let m = h[g].lineNumber;
        if (g > 0 && h[g - 1].lineNumber === m)
          continue;
        let v = h[g].oldContent, C = this.getLineContent(m);
        C.length === 0 || C === v || Os(C) !== -1 || p.push(m);
      }
    }
    return this._onDidChangeContent.fire(), new Goe(d, f, p);
  }
  /**
   * Transform operations such that they represent the same logic edit,
   * but that they also do not cause OOM crashes.
   */
  _reduceOperations(e) {
    return e.length < 1e3 ? e : [this._toSingleEditOperation(e)];
  }
  _toSingleEditOperation(e) {
    let t = !1;
    const i = e[0].range, r = e[e.length - 1].range, o = new G(i.startLineNumber, i.startColumn, r.endLineNumber, r.endColumn);
    let s = i.startLineNumber, a = i.startColumn;
    const l = [];
    for (let f = 0, p = e.length; f < p; f++) {
      const g = e[f], _ = g.range;
      t = t || g.forceMoveMarkers, l.push(this.getValueInRange(new G(s, a, _.startLineNumber, _.startColumn))), g.text.length > 0 && l.push(g.text), s = _.endLineNumber, a = _.endColumn;
    }
    const u = l.join(""), [c, h, d] = r_(u);
    return {
      sortIndex: 0,
      identifier: e[0].identifier,
      range: o,
      rangeOffset: this.getOffsetAt(o.startLineNumber, o.startColumn),
      rangeLength: this.getValueLengthInRange(
        o,
        0
        /* TextDefined */
      ),
      text: u,
      eolCount: c,
      firstLineLength: h,
      lastLineLength: d,
      forceMoveMarkers: t,
      isAutoWhitespaceEdit: !1
    };
  }
  _doApplyEdits(e) {
    e.sort(Ip._sortOpsDescending);
    let t = [];
    for (let i = 0; i < e.length; i++) {
      let r = e[i];
      const o = r.range.startLineNumber, s = r.range.startColumn, a = r.range.endLineNumber, l = r.range.endColumn;
      if (o === a && s === l && r.text.length === 0)
        continue;
      r.text ? (this._pieceTree.delete(r.rangeOffset, r.rangeLength), this._pieceTree.insert(r.rangeOffset, r.text, !0)) : this._pieceTree.delete(r.rangeOffset, r.rangeLength);
      const u = new G(o, s, a, l);
      t.push({
        range: u,
        rangeLength: r.rangeLength,
        text: r.text,
        rangeOffset: r.rangeOffset,
        forceMoveMarkers: r.forceMoveMarkers
      });
    }
    return t;
  }
  findMatchesLineByLine(e, t, i, r) {
    return this._pieceTree.findMatchesLineByLine(e, t, i, r);
  }
  /**
   * Assumes `operations` are validated and sorted ascending
   */
  static _getInverseEditRanges(e) {
    let t = [], i = 0, r = 0, o = null;
    for (let s = 0, a = e.length; s < a; s++) {
      let l = e[s], u, c;
      o ? o.range.endLineNumber === l.range.startLineNumber ? (u = i, c = r + (l.range.startColumn - o.range.endColumn)) : (u = i + (l.range.startLineNumber - o.range.endLineNumber), c = l.range.startColumn) : (u = l.range.startLineNumber, c = l.range.startColumn);
      let h;
      if (l.text.length > 0) {
        const d = l.eolCount + 1;
        d === 1 ? h = new G(u, c, u, c + l.firstLineLength) : h = new G(u, c, u + d - 1, l.lastLineLength + 1);
      } else
        h = new G(u, c, u, c);
      i = h.endLineNumber, r = h.endColumn, t.push(h), o = l;
    }
    return t;
  }
  static _sortOpsAscending(e, t) {
    let i = G.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? e.sortIndex - t.sortIndex : i;
  }
  static _sortOpsDescending(e, t) {
    let i = G.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? t.sortIndex - e.sortIndex : -i;
  }
}
class Fue {
  constructor(e, t, i, r, o, s, a, l, u) {
    this._chunks = e, this._bom = t, this._cr = i, this._lf = r, this._crlf = o, this._containsRTL = s, this._containsUnusualLineTerminators = a, this._isBasicASCII = l, this._normalizeEOL = u;
  }
  _getEOL(e) {
    const t = this._cr + this._lf + this._crlf, i = this._cr + this._crlf;
    return t === 0 ? e === 1 ? `
` : `\r
` : i > t / 2 ? `\r
` : `
`;
  }
  create(e) {
    const t = this._getEOL(e);
    let i = this._chunks;
    if (this._normalizeEOL && (t === `\r
` && (this._cr > 0 || this._lf > 0) || t === `
` && (this._cr > 0 || this._crlf > 0)))
      for (let o = 0, s = i.length; o < s; o++) {
        let a = i[o].buffer.replace(/\r\n|\r|\n/g, t), l = Ou(a);
        i[o] = new ed(a, l);
      }
    const r = new Ip(i, this._bom, t, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
    return { textBuffer: r, disposable: r };
  }
}
class kue {
  constructor() {
    this.chunks = [], this.BOM = "", this._hasPreviousChar = !1, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = !1, this.containsUnusualLineTerminators = !1, this.isBasicASCII = !0;
  }
  acceptChunk(e) {
    if (e.length === 0)
      return;
    this.chunks.length === 0 && UN(e) && (this.BOM = hoe, e = e.substr(1));
    const t = e.charCodeAt(e.length - 1);
    t === 13 || t >= 55296 && t <= 56319 ? (this._acceptChunk1(e.substr(0, e.length - 1), !1), this._hasPreviousChar = !0, this._previousChar = t) : (this._acceptChunk1(e, !1), this._hasPreviousChar = !1, this._previousChar = t);
  }
  _acceptChunk1(e, t) {
    !t && e.length === 0 || (this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + e) : this._acceptChunk2(e));
  }
  _acceptChunk2(e) {
    const t = Nue(this._tmpLineStarts, e);
    this.chunks.push(new ed(e, t.lineStarts)), this.cr += t.cr, this.lf += t.lf, this.crlf += t.crlf, this.isBasicASCII && (this.isBasicASCII = t.isBasicASCII), !this.isBasicASCII && !this.containsRTL && (this.containsRTL = GN(e)), !this.isBasicASCII && !this.containsUnusualLineTerminators && (this.containsUnusualLineTerminators = y5(e));
  }
  finish(e = !0) {
    return this._finish(), new Fue(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, e);
  }
  _finish() {
    if (this.chunks.length === 0 && this._acceptChunk1("", !0), this._hasPreviousChar) {
      this._hasPreviousChar = !1;
      let e = this.chunks[this.chunks.length - 1];
      e.buffer += String.fromCharCode(this._previousChar);
      let t = Ou(e.buffer);
      e.lineStarts = t, this._previousChar === 13 && this.cr++;
    }
  }
}
class Wue {
  constructor() {
    this.changeType = 1;
  }
}
class Vue {
  constructor(e, t) {
    this.changeType = 2, this.lineNumber = e, this.detail = t;
  }
}
class Bue {
  constructor(e, t) {
    this.changeType = 3, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class Hue {
  constructor(e, t, i) {
    this.changeType = 4, this.fromLineNumber = e, this.toLineNumber = t, this.detail = i;
  }
}
class Gue {
  constructor() {
    this.changeType = 5;
  }
}
class Pp {
  constructor(e, t, i, r) {
    this.changes = e, this.versionId = t, this.isUndoing = i, this.isRedoing = r, this.resultingSelection = null;
  }
  containsEvent(e) {
    for (let t = 0, i = this.changes.length; t < i; t++)
      if (this.changes[t].changeType === e)
        return !0;
    return !1;
  }
  static merge(e, t) {
    const i = [].concat(e.changes).concat(t.changes), r = t.versionId, o = e.isUndoing || t.isUndoing, s = e.isRedoing || t.isRedoing;
    return new Pp(i, r, o, s);
  }
}
class Bb {
  constructor(e, t) {
    this.rawContentChangedEvent = e, this.contentChangedEvent = t;
  }
  merge(e) {
    const t = Pp.merge(this.rawContentChangedEvent, e.rawContentChangedEvent), i = Bb._mergeChangeEvents(this.contentChangedEvent, e.contentChangedEvent);
    return new Bb(t, i);
  }
  static _mergeChangeEvents(e, t) {
    const i = [].concat(e.changes).concat(t.changes), r = t.eol, o = t.versionId, s = e.isUndoing || t.isUndoing, a = e.isRedoing || t.isRedoing, l = e.isFlush || t.isFlush;
    return {
      changes: i,
      eol: r,
      versionId: o,
      isUndoing: s,
      isRedoing: a,
      isFlush: l
    };
  }
}
class Uue {
  constructor() {
    this._beginState = [], this._valid = [], this._len = 0, this._invalidLineStartIndex = 0;
  }
  _reset(e) {
    this._beginState = [], this._valid = [], this._len = 0, this._invalidLineStartIndex = 0, e && this._setBeginState(0, e);
  }
  flush(e) {
    this._reset(e);
  }
  get invalidLineStartIndex() {
    return this._invalidLineStartIndex;
  }
  _invalidateLine(e) {
    e < this._len && (this._valid[e] = !1), e < this._invalidLineStartIndex && (this._invalidLineStartIndex = e);
  }
  _isValid(e) {
    return e < this._len ? this._valid[e] : !1;
  }
  getBeginState(e) {
    return e < this._len ? this._beginState[e] : null;
  }
  _ensureLine(e) {
    for (; e >= this._len; )
      this._beginState[this._len] = null, this._valid[this._len] = !1, this._len++;
  }
  _deleteLines(e, t) {
    t !== 0 && (e + t > this._len && (t = this._len - e), this._beginState.splice(e, t), this._valid.splice(e, t), this._len -= t);
  }
  _insertLines(e, t) {
    if (t === 0)
      return;
    let i = [], r = [];
    for (let o = 0; o < t; o++)
      i[o] = null, r[o] = !1;
    this._beginState = Jv(this._beginState, e, i), this._valid = Jv(this._valid, e, r), this._len += t;
  }
  _setValid(e, t) {
    this._ensureLine(e), this._valid[e] = t;
  }
  _setBeginState(e, t) {
    this._ensureLine(e), this._beginState[e] = t;
  }
  setEndState(e, t, i) {
    if (this._setValid(t, !0), this._invalidLineStartIndex = t + 1, t === e - 1)
      return;
    const r = this.getBeginState(t + 1);
    if (r === null || !i.equals(r)) {
      this._setBeginState(t + 1, i), this._invalidateLine(t + 1);
      return;
    }
    let o = t + 1;
    for (; o < e && this._isValid(o); )
      o++;
    this._invalidLineStartIndex = o;
  }
  setFakeTokens(e) {
    this._setValid(e, !1);
  }
  //#region Editing
  applyEdits(e, t) {
    const i = e.endLineNumber - e.startLineNumber, o = Math.min(i, t);
    for (let s = o; s >= 0; s--)
      this._invalidateLine(e.startLineNumber + s - 1);
    this._acceptDeleteRange(e), this._acceptInsertText(new ie(e.startLineNumber, e.startColumn), t);
  }
  _acceptDeleteRange(e) {
    e.startLineNumber - 1 >= this._len || this._deleteLines(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t) {
    e.lineNumber - 1 >= this._len || this._insertLines(e.lineNumber, t);
  }
}
class zue extends Ce {
  constructor(e) {
    super(), this._isDisposed = !1, this._textModel = e, this._tokenizationStateStore = new Uue(), this._tokenizationSupport = null, this._register(cn.onDidChange((t) => {
      const i = this._textModel.getLanguageIdentifier();
      t.changedLanguages.indexOf(i.language) !== -1 && (this._resetTokenizationState(), this._textModel.clearTokens());
    })), this._register(this._textModel.onDidChangeRawContentFast((t) => {
      if (t.containsEvent(
        1
        /* Flush */
      )) {
        this._resetTokenizationState();
        return;
      }
    })), this._register(this._textModel.onDidChangeContentFast((t) => {
      for (let i = 0, r = t.changes.length; i < r; i++) {
        const o = t.changes[i], [s] = r_(o.text);
        this._tokenizationStateStore.applyEdits(o.range, s);
      }
      this._beginBackgroundTokenization();
    })), this._register(this._textModel.onDidChangeAttached(() => {
      this._beginBackgroundTokenization();
    })), this._register(this._textModel.onDidChangeLanguage(() => {
      this._resetTokenizationState(), this._textModel.clearTokens();
    })), this._resetTokenizationState();
  }
  dispose() {
    this._isDisposed = !0, super.dispose();
  }
  _resetTokenizationState() {
    const [e, t] = jue(this._textModel);
    this._tokenizationSupport = e, this._tokenizationStateStore.flush(t), this._beginBackgroundTokenization();
  }
  _beginBackgroundTokenization() {
    this._textModel.isAttachedToEditor() && this._hasLinesToTokenize() && ab(() => {
      this._isDisposed || this._revalidateTokensNow();
    });
  }
  _revalidateTokensNow(e = this._textModel.getLineCount()) {
    const i = new MD(), r = xg.create(!1);
    for (; this._hasLinesToTokenize() && !(r.elapsed() > 1 || this._tokenizeOneInvalidLine(i) >= e); )
      ;
    this._beginBackgroundTokenization(), this._textModel.setTokens(i.tokens);
  }
  tokenizeViewport(e, t) {
    const i = new MD();
    this._tokenizeViewport(i, e, t), this._textModel.setTokens(i.tokens);
  }
  reset() {
    this._resetTokenizationState(), this._textModel.clearTokens();
  }
  forceTokenization(e) {
    const t = new MD();
    this._updateTokensUntilLine(t, e), this._textModel.setTokens(t.tokens);
  }
  isCheapToTokenize(e) {
    if (!this._tokenizationSupport)
      return !0;
    const t = this._tokenizationStateStore.invalidLineStartIndex + 1;
    return e > t ? !1 : e < t || this._textModel.getLineLength(e) < 2048;
  }
  _hasLinesToTokenize() {
    return this._tokenizationSupport ? this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount() : !1;
  }
  _tokenizeOneInvalidLine(e) {
    if (!this._hasLinesToTokenize())
      return this._textModel.getLineCount() + 1;
    const t = this._tokenizationStateStore.invalidLineStartIndex + 1;
    return this._updateTokensUntilLine(e, t), t;
  }
  _updateTokensUntilLine(e, t) {
    if (!this._tokenizationSupport)
      return;
    const i = this._textModel.getLanguageIdentifier(), r = this._textModel.getLineCount(), o = t - 1;
    for (let s = this._tokenizationStateStore.invalidLineStartIndex; s <= o; s++) {
      const a = this._textModel.getLineContent(s + 1), l = this._tokenizationStateStore.getBeginState(s), u = FD(i, this._tokenizationSupport, a, !0, l);
      e.add(s + 1, u.tokens), this._tokenizationStateStore.setEndState(r, s, u.endState), s = this._tokenizationStateStore.invalidLineStartIndex - 1;
    }
  }
  _tokenizeViewport(e, t, i) {
    if (!this._tokenizationSupport || i <= this._tokenizationStateStore.invalidLineStartIndex)
      return;
    if (t <= this._tokenizationStateStore.invalidLineStartIndex) {
      this._updateTokensUntilLine(e, i);
      return;
    }
    let r = this._textModel.getLineFirstNonWhitespaceColumn(t), o = [], s = null;
    for (let u = t - 1; r > 0 && u >= 1; u--) {
      let c = this._textModel.getLineFirstNonWhitespaceColumn(u);
      if (c !== 0 && c < r) {
        if (s = this._tokenizationStateStore.getBeginState(u - 1), s)
          break;
        o.push(this._textModel.getLineContent(u)), r = c;
      }
    }
    s || (s = this._tokenizationSupport.getInitialState());
    const a = this._textModel.getLanguageIdentifier();
    let l = s;
    for (let u = o.length - 1; u >= 0; u--)
      l = FD(a, this._tokenizationSupport, o[u], !1, l).endState;
    for (let u = t; u <= i; u++) {
      let c = this._textModel.getLineContent(u), h = FD(a, this._tokenizationSupport, c, !0, l);
      e.add(u, h.tokens), this._tokenizationStateStore.setFakeTokens(u - 1), l = h.endState;
    }
  }
}
function jue(n) {
  const e = n.getLanguageIdentifier();
  let t = n.isTooLargeForTokenization() ? null : cn.get(e.language), i = null;
  if (t)
    try {
      i = t.getInitialState();
    } catch (r) {
      Pi(r), t = null;
    }
  return [t, i];
}
function FD(n, e, t, i, r) {
  let o = null;
  if (e)
    try {
      o = e.tokenize2(t, i, r.clone(), 0);
    } catch (s) {
      Pi(s);
    }
  return o || (o = M5(n.id, t, r, 0)), eo.convertToEndOffset(o.tokens, t.length), o;
}
function ih(n, e) {
  const t = Math.pow(10, e);
  return Math.round(n * t) / t;
}
class Nt {
  constructor(e, t, i, r = 1) {
    this.r = Math.min(255, Math.max(0, e)) | 0, this.g = Math.min(255, Math.max(0, t)) | 0, this.b = Math.min(255, Math.max(0, i)) | 0, this.a = ih(Math.max(Math.min(1, r), 0), 3);
  }
  static equals(e, t) {
    return e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a;
  }
}
class Ua {
  constructor(e, t, i, r) {
    this.h = Math.max(Math.min(360, e), 0) | 0, this.s = ih(Math.max(Math.min(1, t), 0), 3), this.l = ih(Math.max(Math.min(1, i), 0), 3), this.a = ih(Math.max(Math.min(1, r), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.l === t.l && e.a === t.a;
  }
  /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h in the set [0, 360], s, and l in the set [0, 1].
   */
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, r = e.b / 255, o = e.a, s = Math.max(t, i, r), a = Math.min(t, i, r);
    let l = 0, u = 0;
    const c = (a + s) / 2, h = s - a;
    if (h > 0) {
      switch (u = Math.min(c <= 0.5 ? h / (2 * c) : h / (2 - 2 * c), 1), s) {
        case t:
          l = (i - r) / h + (i < r ? 6 : 0);
          break;
        case i:
          l = (r - t) / h + 2;
          break;
        case r:
          l = (t - i) / h + 4;
          break;
      }
      l *= 60, l = Math.round(l);
    }
    return new Ua(l, u, c, o);
  }
  static _hue2rgb(e, t, i) {
    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (t - e) * 6 * i : i < 1 / 2 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e;
  }
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   */
  static toRGBA(e) {
    const t = e.h / 360, { s: i, l: r, a: o } = e;
    let s, a, l;
    if (i === 0)
      s = a = l = r;
    else {
      const u = r < 0.5 ? r * (1 + i) : r + i - r * i, c = 2 * r - u;
      s = Ua._hue2rgb(c, u, t + 1 / 3), a = Ua._hue2rgb(c, u, t), l = Ua._hue2rgb(c, u, t - 1 / 3);
    }
    return new Nt(Math.round(s * 255), Math.round(a * 255), Math.round(l * 255), o);
  }
}
class ap {
  constructor(e, t, i, r) {
    this.h = Math.max(Math.min(360, e), 0) | 0, this.s = ih(Math.max(Math.min(1, t), 0), 3), this.v = ih(Math.max(Math.min(1, i), 0), 3), this.a = ih(Math.max(Math.min(1, r), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.v === t.v && e.a === t.a;
  }
  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, r = e.b / 255, o = Math.max(t, i, r), s = Math.min(t, i, r), a = o - s, l = o === 0 ? 0 : a / o;
    let u;
    return a === 0 ? u = 0 : o === t ? u = ((i - r) / a % 6 + 6) % 6 : o === i ? u = (r - t) / a + 2 : u = (t - i) / a + 4, new ap(Math.round(u * 60), l, o, e.a);
  }
  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
  static toRGBA(e) {
    const { h: t, s: i, v: r, a: o } = e, s = r * i, a = s * (1 - Math.abs(t / 60 % 2 - 1)), l = r - s;
    let [u, c, h] = [0, 0, 0];
    return t < 60 ? (u = s, c = a) : t < 120 ? (u = a, c = s) : t < 180 ? (c = s, h = a) : t < 240 ? (c = a, h = s) : t < 300 ? (u = a, h = s) : t <= 360 && (u = s, h = a), u = Math.round((u + l) * 255), c = Math.round((c + l) * 255), h = Math.round((h + l) * 255), new Nt(u, c, h, o);
  }
}
class ne {
  constructor(e) {
    if (e)
      if (e instanceof Nt)
        this.rgba = e;
      else if (e instanceof Ua)
        this._hsla = e, this.rgba = Ua.toRGBA(e);
      else if (e instanceof ap)
        this._hsva = e, this.rgba = ap.toRGBA(e);
      else
        throw new Error("Invalid color ctor argument");
    else
      throw new Error("Color needs a value");
  }
  static fromHex(e) {
    return ne.Format.CSS.parseHex(e) || ne.red;
  }
  get hsla() {
    return this._hsla ? this._hsla : Ua.fromRGBA(this.rgba);
  }
  get hsva() {
    return this._hsva ? this._hsva : ap.fromRGBA(this.rgba);
  }
  equals(e) {
    return !!e && Nt.equals(this.rgba, e.rgba) && Ua.equals(this.hsla, e.hsla) && ap.equals(this.hsva, e.hsva);
  }
  /**
   * http://www.w3.org/TR/WCAG20/#relativeluminancedef
   * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
   */
  getRelativeLuminance() {
    const e = ne._relativeLuminanceForComponent(this.rgba.r), t = ne._relativeLuminanceForComponent(this.rgba.g), i = ne._relativeLuminanceForComponent(this.rgba.b), r = 0.2126 * e + 0.7152 * t + 0.0722 * i;
    return ih(r, 4);
  }
  static _relativeLuminanceForComponent(e) {
    const t = e / 255;
    return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
  }
  /**
   *	http://24ways.org/2010/calculating-color-contrast
   *  Return 'true' if lighter color otherwise 'false'
   */
  isLighter() {
    return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 >= 128;
  }
  isLighterThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t > i;
  }
  isDarkerThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t < i;
  }
  lighten(e) {
    return new ne(new Ua(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * e, this.hsla.a));
  }
  darken(e) {
    return new ne(new Ua(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * e, this.hsla.a));
  }
  transparent(e) {
    const { r: t, g: i, b: r, a: o } = this.rgba;
    return new ne(new Nt(t, i, r, o * e));
  }
  isTransparent() {
    return this.rgba.a === 0;
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  opposite() {
    return new ne(new Nt(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }
  toString() {
    return "" + ne.Format.CSS.format(this);
  }
  static getLighterColor(e, t, i) {
    if (e.isLighterThan(t))
      return e;
    i = i || 0.5;
    const r = e.getRelativeLuminance(), o = t.getRelativeLuminance();
    return i = i * (o - r) / o, e.lighten(i);
  }
  static getDarkerColor(e, t, i) {
    if (e.isDarkerThan(t))
      return e;
    i = i || 0.5;
    const r = e.getRelativeLuminance(), o = t.getRelativeLuminance();
    return i = i * (r - o) / r, e.darken(i);
  }
}
ne.white = new ne(new Nt(255, 255, 255, 1));
ne.black = new ne(new Nt(0, 0, 0, 1));
ne.red = new ne(new Nt(255, 0, 0, 1));
ne.blue = new ne(new Nt(0, 0, 255, 1));
ne.cyan = new ne(new Nt(0, 255, 255, 1));
ne.lightgrey = new ne(new Nt(211, 211, 211, 1));
ne.transparent = new ne(new Nt(0, 0, 0, 0));
(function(n) {
  (function(e) {
    (function(t) {
      function i(f) {
        return f.rgba.a === 1 ? `rgb(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b})` : n.Format.CSS.formatRGBA(f);
      }
      t.formatRGB = i;
      function r(f) {
        return `rgba(${f.rgba.r}, ${f.rgba.g}, ${f.rgba.b}, ${+f.rgba.a.toFixed(2)})`;
      }
      t.formatRGBA = r;
      function o(f) {
        return f.hsla.a === 1 ? `hsl(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%)` : n.Format.CSS.formatHSLA(f);
      }
      t.formatHSL = o;
      function s(f) {
        return `hsla(${f.hsla.h}, ${(f.hsla.s * 100).toFixed(2)}%, ${(f.hsla.l * 100).toFixed(2)}%, ${f.hsla.a.toFixed(2)})`;
      }
      t.formatHSLA = s;
      function a(f) {
        const p = f.toString(16);
        return p.length !== 2 ? "0" + p : p;
      }
      function l(f) {
        return `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}`;
      }
      t.formatHex = l;
      function u(f, p = !1) {
        return p && f.rgba.a === 1 ? n.Format.CSS.formatHex(f) : `#${a(f.rgba.r)}${a(f.rgba.g)}${a(f.rgba.b)}${a(Math.round(f.rgba.a * 255))}`;
      }
      t.formatHexA = u;
      function c(f) {
        return f.isOpaque() ? n.Format.CSS.formatHex(f) : n.Format.CSS.formatRGBA(f);
      }
      t.format = c;
      function h(f) {
        const p = f.length;
        if (p === 0 || f.charCodeAt(0) !== 35)
          return null;
        if (p === 7) {
          const g = 16 * d(f.charCodeAt(1)) + d(f.charCodeAt(2)), _ = 16 * d(f.charCodeAt(3)) + d(f.charCodeAt(4)), m = 16 * d(f.charCodeAt(5)) + d(f.charCodeAt(6));
          return new n(new Nt(g, _, m, 1));
        }
        if (p === 9) {
          const g = 16 * d(f.charCodeAt(1)) + d(f.charCodeAt(2)), _ = 16 * d(f.charCodeAt(3)) + d(f.charCodeAt(4)), m = 16 * d(f.charCodeAt(5)) + d(f.charCodeAt(6)), v = 16 * d(f.charCodeAt(7)) + d(f.charCodeAt(8));
          return new n(new Nt(g, _, m, v / 255));
        }
        if (p === 4) {
          const g = d(f.charCodeAt(1)), _ = d(f.charCodeAt(2)), m = d(f.charCodeAt(3));
          return new n(new Nt(16 * g + g, 16 * _ + _, 16 * m + m));
        }
        if (p === 5) {
          const g = d(f.charCodeAt(1)), _ = d(f.charCodeAt(2)), m = d(f.charCodeAt(3)), v = d(f.charCodeAt(4));
          return new n(new Nt(16 * g + g, 16 * _ + _, 16 * m + m, (16 * v + v) / 255));
        }
        return null;
      }
      t.parseHex = h;
      function d(f) {
        switch (f) {
          case 48:
            return 0;
          case 49:
            return 1;
          case 50:
            return 2;
          case 51:
            return 3;
          case 52:
            return 4;
          case 53:
            return 5;
          case 54:
            return 6;
          case 55:
            return 7;
          case 56:
            return 8;
          case 57:
            return 9;
          case 97:
            return 10;
          case 65:
            return 10;
          case 98:
            return 11;
          case 66:
            return 11;
          case 99:
            return 12;
          case 67:
            return 12;
          case 100:
            return 13;
          case 68:
            return 13;
          case 101:
            return 14;
          case 69:
            return 14;
          case 102:
            return 15;
          case 70:
            return 15;
        }
        return 0;
      }
    })(e.CSS || (e.CSS = {}));
  })(n.Format || (n.Format = {}));
})(ne || (ne = {}));
function $ue() {
  return new kue();
}
function Kue(n) {
  const e = $ue();
  return e.acceptChunk(n), e.finish();
}
function N2(n, e) {
  return (typeof n == "string" ? Kue(n) : n).create(e);
}
let Ey = 0;
const que = 999, Yue = 1e4;
class Xue {
  constructor(e) {
    this._source = e, this._eos = !1;
  }
  read() {
    if (this._eos)
      return null;
    let e = [], t = 0, i = 0;
    do {
      let r = this._source.read();
      if (r === null)
        return this._eos = !0, t === 0 ? null : e.join("");
      if (r.length > 0 && (e[t++] = r, i += r.length), i >= 64 * 1024)
        return e.join("");
    } while (!0);
  }
}
const Wm = () => {
  throw new Error("Invalid change accessor");
};
class Fu {
  constructor() {
    this._searchCanceledBrand = void 0;
  }
}
Fu.INSTANCE = new Fu();
function Ly(n) {
  return n instanceof Fu ? null : n;
}
class Xr extends Ce {
  //#endregion
  constructor(e, t, i, r = null, o) {
    super(), this._onWillDispose = this._register(new q()), this.onWillDispose = this._onWillDispose.event, this._onDidChangeDecorations = this._register(new ece()), this.onDidChangeDecorations = this._onDidChangeDecorations.event, this._onDidChangeLanguage = this._register(new q()), this.onDidChangeLanguage = this._onDidChangeLanguage.event, this._onDidChangeLanguageConfiguration = this._register(new q()), this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event, this._onDidChangeTokens = this._register(new q()), this.onDidChangeTokens = this._onDidChangeTokens.event, this._onDidChangeOptions = this._register(new q()), this.onDidChangeOptions = this._onDidChangeOptions.event, this._onDidChangeAttached = this._register(new q()), this.onDidChangeAttached = this._onDidChangeAttached.event, this._eventEmitter = this._register(new tce()), Ey++, this.id = "$model" + Ey, this.isForSimpleWidget = t.isForSimpleWidget, typeof r > "u" || r === null ? this._associatedResource = ft.parse("inmemory://model/" + Ey) : this._associatedResource = r, this._undoRedoService = o, this._attachedEditorCount = 0;
    const { textBuffer: s, disposable: a } = N2(e, t.defaultEOL);
    this._buffer = s, this._bufferDisposable = a, this._options = Xr.resolveOptions(this._buffer, t);
    const l = this._buffer.getLineCount(), u = this._buffer.getValueLengthInRange(
      new G(1, 1, l, this._buffer.getLineLength(l) + 1),
      0
      /* TextDefined */
    );
    t.largeFileOptimizations ? this._isTooLargeForTokenization = u > Xr.LARGE_FILE_SIZE_THRESHOLD || l > Xr.LARGE_FILE_LINE_COUNT_THRESHOLD : this._isTooLargeForTokenization = !1, this._isTooLargeForSyncing = u > Xr.MODEL_SYNC_LIMIT, this._versionId = 1, this._alternativeVersionId = 1, this._initialUndoRedoSnapshot = null, this._isDisposed = !1, this._isDisposing = !1, this._languageIdentifier = i || wb, this._languageRegistryListener = ui.onDidChange((c) => {
      c.languageIdentifier.id === this._languageIdentifier.id && this._onDidChangeLanguageConfiguration.fire({});
    }), this._instanceId = w5(Ey), this._lastDecorationId = 0, this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new I2(), this._commandManager = new mI(this, o), this._isUndoing = !1, this._isRedoing = !1, this._trimAutoWhitespaceLines = null, this._tokens = new hs(), this._tokens2 = new wI(), this._tokenization = new zue(this);
  }
  static resolveOptions(e, t) {
    if (t.detectIndentation) {
      const i = C2(e, t.tabSize, t.insertSpaces);
      return new aw({
        tabSize: i.tabSize,
        indentSize: i.tabSize,
        insertSpaces: i.insertSpaces,
        trimAutoWhitespace: t.trimAutoWhitespace,
        defaultEOL: t.defaultEOL
      });
    }
    return new aw({
      tabSize: t.tabSize,
      indentSize: t.indentSize,
      insertSpaces: t.insertSpaces,
      trimAutoWhitespace: t.trimAutoWhitespace,
      defaultEOL: t.defaultEOL
    });
  }
  onDidChangeRawContentFast(e) {
    return this._eventEmitter.fastEvent((t) => e(t.rawContentChangedEvent));
  }
  onDidChangeContentFast(e) {
    return this._eventEmitter.fastEvent((t) => e(t.contentChangedEvent));
  }
  onDidChangeContent(e) {
    return this._eventEmitter.slowEvent((t) => e(t.contentChangedEvent));
  }
  dispose() {
    this._isDisposing = !0, this._onWillDispose.fire(), this._languageRegistryListener.dispose(), this._tokenization.dispose(), this._isDisposed = !0, super.dispose(), this._bufferDisposable.dispose(), this._isDisposing = !1;
    const e = new Ip([], "", `
`, !1, !1, !0, !0);
    e.dispose(), this._buffer = e;
  }
  _assertNotDisposed() {
    if (this._isDisposed)
      throw new Error("Model is disposed!");
  }
  _emitContentChangedEvent(e, t) {
    this._isDisposing || this._eventEmitter.fire(new Bb(e, t));
  }
  setValue(e) {
    if (this._assertNotDisposed(), e === null)
      return;
    const { textBuffer: t, disposable: i } = N2(e, this._options.defaultEOL);
    this._setValueFromTextBuffer(t, i);
  }
  _createContentChanged2(e, t, i, r, o, s, a) {
    return {
      changes: [{
        range: e,
        rangeOffset: t,
        rangeLength: i,
        text: r
      }],
      eol: this._buffer.getEOL(),
      versionId: this.getVersionId(),
      isUndoing: o,
      isRedoing: s,
      isFlush: a
    };
  }
  _setValueFromTextBuffer(e, t) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), r = this.getValueLengthInRange(i), o = this.getLineCount(), s = this.getLineMaxColumn(o);
    this._buffer = e, this._bufferDisposable.dispose(), this._bufferDisposable = t, this._increaseVersionId(), this._tokens.flush(), this._tokens2.flush(), this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new I2(), this._commandManager.clear(), this._trimAutoWhitespaceLines = null, this._emitContentChangedEvent(new Pp([
      new Wue()
    ], this._versionId, !1, !1), this._createContentChanged2(new G(1, 1, o, s), 0, r, this.getValue(), !1, !1, !0));
  }
  setEOL(e) {
    this._assertNotDisposed();
    const t = e === 1 ? `\r
` : `
`;
    if (this._buffer.getEOL() === t)
      return;
    const i = this.getFullModelRange(), r = this.getValueLengthInRange(i), o = this.getLineCount(), s = this.getLineMaxColumn(o);
    this._onBeforeEOLChange(), this._buffer.setEOL(t), this._increaseVersionId(), this._onAfterEOLChange(), this._emitContentChangedEvent(new Pp([
      new Gue()
    ], this._versionId, !1, !1), this._createContentChanged2(new G(1, 1, o, s), 0, r, this.getValue(), !1, !1, !1));
  }
  _onBeforeEOLChange() {
    const e = this.getVersionId(), t = this._decorationsTree.search(0, !1, !1, e);
    this._ensureNodesHaveRanges(t);
  }
  _onAfterEOLChange() {
    const e = this.getVersionId(), t = this._decorationsTree.collectNodesPostOrder();
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i], s = o.cachedAbsoluteStart - o.start, a = this._buffer.getOffsetAt(o.range.startLineNumber, o.range.startColumn), l = this._buffer.getOffsetAt(o.range.endLineNumber, o.range.endColumn);
      o.cachedAbsoluteStart = a, o.cachedAbsoluteEnd = l, o.cachedVersionId = e, o.start = a - s, o.end = l - s, hh(o);
    }
  }
  onBeforeAttached() {
    this._attachedEditorCount++, this._attachedEditorCount === 1 && this._onDidChangeAttached.fire(void 0);
  }
  onBeforeDetached() {
    this._attachedEditorCount--, this._attachedEditorCount === 0 && this._onDidChangeAttached.fire(void 0);
  }
  isAttachedToEditor() {
    return this._attachedEditorCount > 0;
  }
  getAttachedEditorCount() {
    return this._attachedEditorCount;
  }
  isTooLargeForSyncing() {
    return this._isTooLargeForSyncing;
  }
  isTooLargeForTokenization() {
    return this._isTooLargeForTokenization;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isDominatedByLongLines() {
    if (this._assertNotDisposed(), this.isTooLargeForTokenization())
      return !1;
    let e = 0, t = 0;
    const i = this._buffer.getLineCount();
    for (let r = 1; r <= i; r++) {
      const o = this._buffer.getLineLength(r);
      o >= Yue ? t += o : e += o;
    }
    return t > e;
  }
  get uri() {
    return this._associatedResource;
  }
  //#region Options
  getOptions() {
    return this._assertNotDisposed(), this._options;
  }
  getFormattingOptions() {
    return {
      tabSize: this._options.indentSize,
      insertSpaces: this._options.insertSpaces
    };
  }
  updateOptions(e) {
    this._assertNotDisposed();
    let t = typeof e.tabSize < "u" ? e.tabSize : this._options.tabSize, i = typeof e.indentSize < "u" ? e.indentSize : this._options.indentSize, r = typeof e.insertSpaces < "u" ? e.insertSpaces : this._options.insertSpaces, o = typeof e.trimAutoWhitespace < "u" ? e.trimAutoWhitespace : this._options.trimAutoWhitespace, s = new aw({
      tabSize: t,
      indentSize: i,
      insertSpaces: r,
      defaultEOL: this._options.defaultEOL,
      trimAutoWhitespace: o
    });
    if (this._options.equals(s))
      return;
    let a = this._options.createChangeEvent(s);
    this._options = s, this._onDidChangeOptions.fire(a);
  }
  detectIndentation(e, t) {
    this._assertNotDisposed();
    let i = C2(this._buffer, t, e);
    this.updateOptions({
      insertSpaces: i.insertSpaces,
      tabSize: i.tabSize,
      indentSize: i.tabSize
      // TODO@Alex: guess indentSize independent of tabSize
    });
  }
  static _normalizeIndentationFromWhitespace(e, t, i) {
    let r = 0;
    for (let s = 0; s < e.length; s++)
      e.charAt(s) === "	" ? r += t : r++;
    let o = "";
    if (!i) {
      let s = Math.floor(r / t);
      r = r % t;
      for (let a = 0; a < s; a++)
        o += "	";
    }
    for (let s = 0; s < r; s++)
      o += " ";
    return o;
  }
  static normalizeIndentation(e, t, i) {
    let r = Os(e);
    return r === -1 && (r = e.length), Xr._normalizeIndentationFromWhitespace(e.substring(0, r), t, i) + e.substring(r);
  }
  normalizeIndentation(e) {
    return this._assertNotDisposed(), Xr.normalizeIndentation(e, this._options.indentSize, this._options.insertSpaces);
  }
  //#endregion
  //#region Reading
  getVersionId() {
    return this._assertNotDisposed(), this._versionId;
  }
  mightContainRTL() {
    return this._buffer.mightContainRTL();
  }
  mightContainUnusualLineTerminators() {
    return this._buffer.mightContainUnusualLineTerminators();
  }
  removeUnusualLineTerminators(e = null) {
    const t = this.findMatches(
      C5.source,
      !1,
      !0,
      !1,
      null,
      !1,
      1073741824
      /* MAX_SAFE_SMALL_INTEGER */
    );
    this._buffer.resetMightContainUnusualLineTerminators(), this.pushEditOperations(e, t.map((i) => ({ range: i.range, text: null })), () => null);
  }
  mightContainNonBasicASCII() {
    return this._buffer.mightContainNonBasicASCII();
  }
  getAlternativeVersionId() {
    return this._assertNotDisposed(), this._alternativeVersionId;
  }
  getInitialUndoRedoSnapshot() {
    return this._assertNotDisposed(), this._initialUndoRedoSnapshot;
  }
  getOffsetAt(e) {
    this._assertNotDisposed();
    let t = this._validatePosition(
      e.lineNumber,
      e.column,
      0
      /* Relaxed */
    );
    return this._buffer.getOffsetAt(t.lineNumber, t.column);
  }
  getPositionAt(e) {
    this._assertNotDisposed();
    let t = Math.min(this._buffer.getLength(), Math.max(0, e));
    return this._buffer.getPositionAt(t);
  }
  _increaseVersionId() {
    this._versionId = this._versionId + 1, this._alternativeVersionId = this._versionId;
  }
  _overwriteVersionId(e) {
    this._versionId = e;
  }
  _overwriteAlternativeVersionId(e) {
    this._alternativeVersionId = e;
  }
  _overwriteInitialUndoRedoSnapshot(e) {
    this._initialUndoRedoSnapshot = e;
  }
  getValue(e, t = !1) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), r = this.getValueInRange(i, e);
    return t ? this._buffer.getBOM() + r : r;
  }
  createSnapshot(e = !1) {
    return new Xue(this._buffer.createSnapshot(e));
  }
  getValueLength(e, t = !1) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), r = this.getValueLengthInRange(i, e);
    return t ? this._buffer.getBOM().length + r : r;
  }
  getValueInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueInRange(this.validateRange(e), t);
  }
  getValueLengthInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueLengthInRange(this.validateRange(e), t);
  }
  getCharacterCountInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getCharacterCountInRange(this.validateRange(e), t);
  }
  getLineCount() {
    return this._assertNotDisposed(), this._buffer.getLineCount();
  }
  getLineContent(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineContent(e);
  }
  getLineLength(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineLength(e);
  }
  getLinesContent() {
    return this._assertNotDisposed(), this._buffer.getLinesContent();
  }
  getEOL() {
    return this._assertNotDisposed(), this._buffer.getEOL();
  }
  getEndOfLineSequence() {
    return this._assertNotDisposed(), this._buffer.getEOL() === `
` ? 0 : 1;
  }
  getLineMinColumn(e) {
    return this._assertNotDisposed(), 1;
  }
  getLineMaxColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineLength(e) + 1;
  }
  getLineFirstNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineFirstNonWhitespaceColumn(e);
  }
  getLineLastNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._buffer.getLineLastNonWhitespaceColumn(e);
  }
  /**
   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
   * Will try to not allocate if possible.
   */
  _validateRangeRelaxedNoAllocations(e) {
    const t = this._buffer.getLineCount(), i = e.startLineNumber, r = e.startColumn;
    let o = Math.floor(typeof i == "number" && !isNaN(i) ? i : 1), s = Math.floor(typeof r == "number" && !isNaN(r) ? r : 1);
    if (o < 1)
      o = 1, s = 1;
    else if (o > t)
      o = t, s = this.getLineMaxColumn(o);
    else if (s <= 1)
      s = 1;
    else {
      const h = this.getLineMaxColumn(o);
      s >= h && (s = h);
    }
    const a = e.endLineNumber, l = e.endColumn;
    let u = Math.floor(typeof a == "number" && !isNaN(a) ? a : 1), c = Math.floor(typeof l == "number" && !isNaN(l) ? l : 1);
    if (u < 1)
      u = 1, c = 1;
    else if (u > t)
      u = t, c = this.getLineMaxColumn(u);
    else if (c <= 1)
      c = 1;
    else {
      const h = this.getLineMaxColumn(u);
      c >= h && (c = h);
    }
    return i === o && r === s && a === u && l === c && e instanceof G && !(e instanceof Ut) ? e : new G(o, s, u, c);
  }
  _isValidPosition(e, t, i) {
    if (typeof e != "number" || typeof t != "number" || isNaN(e) || isNaN(t) || e < 1 || t < 1 || (e | 0) !== e || (t | 0) !== t)
      return !1;
    const r = this._buffer.getLineCount();
    if (e > r)
      return !1;
    if (t === 1)
      return !0;
    const o = this.getLineMaxColumn(e);
    if (t > o)
      return !1;
    if (i === 1) {
      const s = this._buffer.getLineCharCode(e, t - 2);
      if (Kn(s))
        return !1;
    }
    return !0;
  }
  _validatePosition(e, t, i) {
    const r = Math.floor(typeof e == "number" && !isNaN(e) ? e : 1), o = Math.floor(typeof t == "number" && !isNaN(t) ? t : 1), s = this._buffer.getLineCount();
    if (r < 1)
      return new ie(1, 1);
    if (r > s)
      return new ie(s, this.getLineMaxColumn(s));
    if (o <= 1)
      return new ie(r, 1);
    const a = this.getLineMaxColumn(r);
    if (o >= a)
      return new ie(r, a);
    if (i === 1) {
      const l = this._buffer.getLineCharCode(r, o - 2);
      if (Kn(l))
        return new ie(r, o - 1);
    }
    return new ie(r, o);
  }
  validatePosition(e) {
    return this._assertNotDisposed(), e instanceof ie && this._isValidPosition(e.lineNumber, e.column, 1) ? e : this._validatePosition(e.lineNumber, e.column, 1);
  }
  _isValidRange(e, t) {
    const i = e.startLineNumber, r = e.startColumn, o = e.endLineNumber, s = e.endColumn;
    if (!this._isValidPosition(
      i,
      r,
      0
      /* Relaxed */
    ) || !this._isValidPosition(
      o,
      s,
      0
      /* Relaxed */
    ))
      return !1;
    if (t === 1) {
      const a = r > 1 ? this._buffer.getLineCharCode(i, r - 2) : 0, l = s > 1 && s <= this._buffer.getLineLength(o) ? this._buffer.getLineCharCode(o, s - 2) : 0, u = Kn(a), c = Kn(l);
      return !u && !c;
    }
    return !0;
  }
  validateRange(e) {
    if (this._assertNotDisposed(), e instanceof G && !(e instanceof Ut) && this._isValidRange(e, 1))
      return e;
    const i = this._validatePosition(
      e.startLineNumber,
      e.startColumn,
      0
      /* Relaxed */
    ), r = this._validatePosition(
      e.endLineNumber,
      e.endColumn,
      0
      /* Relaxed */
    ), o = i.lineNumber, s = i.column, a = r.lineNumber, l = r.column;
    {
      const u = s > 1 ? this._buffer.getLineCharCode(o, s - 2) : 0, c = l > 1 && l <= this._buffer.getLineLength(a) ? this._buffer.getLineCharCode(a, l - 2) : 0, h = Kn(u), d = Kn(c);
      return !h && !d ? new G(o, s, a, l) : o === a && s === l ? new G(o, s - 1, a, l - 1) : h && d ? new G(o, s - 1, a, l + 1) : h ? new G(o, s - 1, a, l) : new G(o, s, a, l + 1);
    }
  }
  modifyPosition(e, t) {
    this._assertNotDisposed();
    let i = this.getOffsetAt(e) + t;
    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, i)));
  }
  getFullModelRange() {
    this._assertNotDisposed();
    const e = this.getLineCount();
    return new G(1, 1, e, this.getLineMaxColumn(e));
  }
  findMatchesLineByLine(e, t, i, r) {
    return this._buffer.findMatchesLineByLine(e, t, i, r);
  }
  findMatches(e, t, i, r, o, s, a = que) {
    this._assertNotDisposed();
    let l = null;
    t !== null && (Array.isArray(t) || (t = [t]), t.every((h) => G.isIRange(h)) && (l = t.map((h) => this.validateRange(h)))), l === null && (l = [this.getFullModelRange()]), l = l.sort((h, d) => h.startLineNumber - d.startLineNumber || h.startColumn - d.startColumn);
    const u = [];
    u.push(l.reduce((h, d) => G.areIntersecting(h, d) ? h.plusRange(d) : (u.push(h), d)));
    let c;
    if (!i && e.indexOf(`
`) < 0) {
      const d = new Gf(e, i, r, o).parseSearchRequest();
      if (!d)
        return [];
      c = (f) => this.findMatchesLineByLine(f, d, s, a);
    } else
      c = (h) => Sy.findMatches(this, new Gf(e, i, r, o), h, s, a);
    return u.map(c).reduce((h, d) => h.concat(d), []);
  }
  findNextMatch(e, t, i, r, o, s) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    if (!i && e.indexOf(`
`) < 0) {
      const u = new Gf(e, i, r, o).parseSearchRequest();
      if (!u)
        return null;
      const c = this.getLineCount();
      let h = new G(a.lineNumber, a.column, c, this.getLineMaxColumn(c)), d = this.findMatchesLineByLine(h, u, s, 1);
      return Sy.findNextMatch(this, new Gf(e, i, r, o), a, s), d.length > 0 || (h = new G(1, 1, a.lineNumber, this.getLineMaxColumn(a.lineNumber)), d = this.findMatchesLineByLine(h, u, s, 1), d.length > 0) ? d[0] : null;
    }
    return Sy.findNextMatch(this, new Gf(e, i, r, o), a, s);
  }
  findPreviousMatch(e, t, i, r, o, s) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    return Sy.findPreviousMatch(this, new Gf(e, i, r, o), a, s);
  }
  //#endregion
  //#region Editing
  pushStackElement() {
    this._commandManager.pushStackElement();
  }
  popStackElement() {
    this._commandManager.popStackElement();
  }
  pushEOL(e) {
    if ((this.getEOL() === `
` ? 0 : 1) !== e)
      try {
        this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEOL(e);
      } finally {
        this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
      }
  }
  _validateEditOperation(e) {
    return e instanceof pD ? e : new pD(e.identifier || null, this.validateRange(e.range), e.text, e.forceMoveMarkers || !1, e.isAutoWhitespaceEdit || !1, e._isTracked || !1);
  }
  _validateEditOperations(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++)
      t[i] = this._validateEditOperation(e[i]);
    return t;
  }
  pushEditOperations(e, t, i) {
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._pushEditOperations(e, this._validateEditOperations(t), i);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _pushEditOperations(e, t, i) {
    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
      let r = t.map((s) => ({
        range: this.validateRange(s.range),
        text: s.text
      })), o = !0;
      if (e)
        for (let s = 0, a = e.length; s < a; s++) {
          let l = e[s], u = !1;
          for (let c = 0, h = r.length; c < h; c++) {
            let d = r[c].range, f = d.startLineNumber > l.endLineNumber, p = l.startLineNumber > d.endLineNumber;
            if (!f && !p) {
              u = !0;
              break;
            }
          }
          if (!u) {
            o = !1;
            break;
          }
        }
      if (o)
        for (let s = 0, a = this._trimAutoWhitespaceLines.length; s < a; s++) {
          let l = this._trimAutoWhitespaceLines[s], u = this.getLineMaxColumn(l), c = !0;
          for (let h = 0, d = r.length; h < d; h++) {
            let f = r[h].range, p = r[h].text;
            if (!(l < f.startLineNumber || l > f.endLineNumber) && !(l === f.startLineNumber && f.startColumn === u && f.isEmpty() && p && p.length > 0 && p.charAt(0) === `
`) && !(l === f.startLineNumber && f.startColumn === 1 && f.isEmpty() && p && p.length > 0 && p.charAt(p.length - 1) === `
`)) {
              c = !1;
              break;
            }
          }
          if (c) {
            const h = new G(l, 1, l, u);
            t.push(new pD(null, h, null, !1, !1, !1));
          }
        }
      this._trimAutoWhitespaceLines = null;
    }
    return this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEditOperation(e, t, i);
  }
  _applyUndo(e, t, i, r) {
    const o = e.map((s) => {
      const a = this.getPositionAt(s.newPosition), l = this.getPositionAt(s.newEnd);
      return {
        range: new G(a.lineNumber, a.column, l.lineNumber, l.column),
        text: s.oldText
      };
    });
    this._applyUndoRedoEdits(o, t, !0, !1, i, r);
  }
  _applyRedo(e, t, i, r) {
    const o = e.map((s) => {
      const a = this.getPositionAt(s.oldPosition), l = this.getPositionAt(s.oldEnd);
      return {
        range: new G(a.lineNumber, a.column, l.lineNumber, l.column),
        text: s.newText
      };
    });
    this._applyUndoRedoEdits(o, t, !1, !0, i, r);
  }
  _applyUndoRedoEdits(e, t, i, r, o, s) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._isUndoing = i, this._isRedoing = r, this.applyEdits(e, !1), this.setEOL(t), this._overwriteAlternativeVersionId(o);
    } finally {
      this._isUndoing = !1, this._isRedoing = !1, this._eventEmitter.endDeferredEmit(s), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  applyEdits(e, t = !1) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit();
      const i = this._validateEditOperations(e);
      return this._doApplyEdits(i, t);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _doApplyEdits(e, t) {
    const i = this._buffer.getLineCount(), r = this._buffer.applyEdits(e, this._options.trimAutoWhitespace, t), o = this._buffer.getLineCount(), s = r.changes;
    if (this._trimAutoWhitespaceLines = r.trimAutoWhitespaceLineNumbers, s.length !== 0) {
      let a = [], l = i;
      for (let u = 0, c = s.length; u < c; u++) {
        const h = s[u], [d, f, p] = r_(h.text);
        this._tokens.acceptEdit(h.range, d, f), this._tokens2.acceptEdit(
          h.range,
          d,
          f,
          p,
          h.text.length > 0 ? h.text.charCodeAt(0) : 0
          /* Null */
        ), this._onDidChangeDecorations.fire(), this._decorationsTree.acceptReplace(h.rangeOffset, h.rangeLength, h.text.length, h.forceMoveMarkers);
        const g = h.range.startLineNumber, _ = h.range.endLineNumber, m = _ - g, v = d, C = Math.min(m, v), y = v - m;
        for (let w = C; w >= 0; w--) {
          const L = g + w, S = o - l - y + L;
          a.push(new Vue(L, this.getLineContent(S)));
        }
        if (C < m) {
          const w = g + C;
          a.push(new Bue(w + 1, _));
        }
        if (C < v) {
          const w = g + C, L = v - C, S = o - l - L + w + 1;
          let E = [];
          for (let D = 0; D < L; D++) {
            let x = S + D;
            E[x - S] = this.getLineContent(x);
          }
          a.push(new Hue(w + 1, g + v, E));
        }
        l += y;
      }
      this._increaseVersionId(), this._emitContentChangedEvent(new Pp(a, this.getVersionId(), this._isUndoing, this._isRedoing), {
        changes: s,
        eol: this._buffer.getEOL(),
        versionId: this.getVersionId(),
        isUndoing: this._isUndoing,
        isRedoing: this._isRedoing,
        isFlush: !1
      });
    }
    return r.reverseEdits === null ? void 0 : r.reverseEdits;
  }
  undo() {
    return this._undoRedoService.undo(this.uri);
  }
  canUndo() {
    return this._undoRedoService.canUndo(this.uri);
  }
  redo() {
    return this._undoRedoService.redo(this.uri);
  }
  canRedo() {
    return this._undoRedoService.canRedo(this.uri);
  }
  //#endregion
  //#region Decorations
  changeDecorations(e, t = 0) {
    this._assertNotDisposed();
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._changeDecorations(t, e);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _changeDecorations(e, t) {
    let i = {
      addDecoration: (o, s) => this._deltaDecorationsImpl(e, [], [{ range: o, options: s }])[0],
      changeDecoration: (o, s) => {
        this._changeDecorationImpl(o, s);
      },
      changeDecorationOptions: (o, s) => {
        this._changeDecorationOptionsImpl(o, A2(s));
      },
      removeDecoration: (o) => {
        this._deltaDecorationsImpl(e, [o], []);
      },
      deltaDecorations: (o, s) => o.length === 0 && s.length === 0 ? [] : this._deltaDecorationsImpl(e, o, s)
    }, r = null;
    try {
      r = t(i);
    } catch (o) {
      Pi(o);
    }
    return i.addDecoration = Wm, i.changeDecoration = Wm, i.changeDecorationOptions = Wm, i.removeDecoration = Wm, i.deltaDecorations = Wm, r;
  }
  deltaDecorations(e, t, i = 0) {
    if (this._assertNotDisposed(), e || (e = []), e.length === 0 && t.length === 0)
      return [];
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._deltaDecorationsImpl(i, e, t);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _getTrackedRange(e) {
    return this.getDecorationRange(e);
  }
  _setTrackedRange(e, t, i) {
    const r = e ? this._decorations[e] : null;
    if (!r)
      return t ? this._deltaDecorationsImpl(0, [], [{ range: t, options: P2[i] }])[0] : null;
    if (!t)
      return this._decorationsTree.delete(r), delete this._decorations[r.id], null;
    const o = this._validateRangeRelaxedNoAllocations(t), s = this._buffer.getOffsetAt(o.startLineNumber, o.startColumn), a = this._buffer.getOffsetAt(o.endLineNumber, o.endColumn);
    return this._decorationsTree.delete(r), r.reset(this.getVersionId(), s, a, o), r.setOptions(P2[i]), this._decorationsTree.insert(r), r.id;
  }
  removeAllDecorationsWithOwnerId(e) {
    if (this._isDisposed)
      return;
    const t = this._decorationsTree.collectNodesFromOwner(e);
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      this._decorationsTree.delete(o), delete this._decorations[o.id];
    }
  }
  getDecorationOptions(e) {
    const t = this._decorations[e];
    return t ? t.options : null;
  }
  getDecorationRange(e) {
    const t = this._decorations[e];
    if (!t)
      return null;
    const i = this.getVersionId();
    return t.cachedVersionId !== i && this._decorationsTree.resolveNode(t, i), t.range === null && (t.range = this._getRangeAt(t.cachedAbsoluteStart, t.cachedAbsoluteEnd)), t.range;
  }
  getLineDecorations(e, t = 0, i = !1) {
    return e < 1 || e > this.getLineCount() ? [] : this.getLinesDecorations(e, e, t, i);
  }
  getLinesDecorations(e, t, i = 0, r = !1) {
    let o = this.getLineCount(), s = Math.min(o, Math.max(1, e)), a = Math.min(o, Math.max(1, t)), l = this.getLineMaxColumn(a);
    return this._getDecorationsInRange(new G(s, 1, a, l), i, r);
  }
  getDecorationsInRange(e, t = 0, i = !1) {
    let r = this.validateRange(e);
    return this._getDecorationsInRange(r, t, i);
  }
  getOverviewRulerDecorations(e = 0, t = !1) {
    const i = this.getVersionId(), r = this._decorationsTree.search(e, t, !0, i);
    return this._ensureNodesHaveRanges(r);
  }
  getAllDecorations(e = 0, t = !1) {
    const i = this.getVersionId(), r = this._decorationsTree.search(e, t, !1, i);
    return this._ensureNodesHaveRanges(r);
  }
  _getDecorationsInRange(e, t, i) {
    const r = this._buffer.getOffsetAt(e.startLineNumber, e.startColumn), o = this._buffer.getOffsetAt(e.endLineNumber, e.endColumn), s = this.getVersionId(), a = this._decorationsTree.intervalSearch(r, o, t, i, s);
    return this._ensureNodesHaveRanges(a);
  }
  _ensureNodesHaveRanges(e) {
    for (let t = 0, i = e.length; t < i; t++) {
      const r = e[t];
      r.range === null && (r.range = this._getRangeAt(r.cachedAbsoluteStart, r.cachedAbsoluteEnd));
    }
    return e;
  }
  _getRangeAt(e, t) {
    return this._buffer.getRangeAt(e, t - e);
  }
  _changeDecorationImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    const r = this._validateRangeRelaxedNoAllocations(t), o = this._buffer.getOffsetAt(r.startLineNumber, r.startColumn), s = this._buffer.getOffsetAt(r.endLineNumber, r.endColumn);
    this._decorationsTree.delete(i), i.reset(this.getVersionId(), o, s, r), this._decorationsTree.insert(i), this._onDidChangeDecorations.checkAffectedAndFire(i.options);
  }
  _changeDecorationOptionsImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    const r = !!(i.options.overviewRuler && i.options.overviewRuler.color), o = !!(t.overviewRuler && t.overviewRuler.color);
    this._onDidChangeDecorations.checkAffectedAndFire(i.options), this._onDidChangeDecorations.checkAffectedAndFire(t), r !== o ? (this._decorationsTree.delete(i), i.setOptions(t), this._decorationsTree.insert(i)) : i.setOptions(t);
  }
  _deltaDecorationsImpl(e, t, i) {
    const r = this.getVersionId(), o = t.length;
    let s = 0;
    const a = i.length;
    let l = 0, u = new Array(a);
    for (; s < o || l < a; ) {
      let c = null;
      if (s < o) {
        do
          c = this._decorations[t[s++]];
        while (!c && s < o);
        c && (this._decorationsTree.delete(c), this._onDidChangeDecorations.checkAffectedAndFire(c.options));
      }
      if (l < a) {
        if (!c) {
          const _ = ++this._lastDecorationId, m = `${this._instanceId};${_}`;
          c = new M3(m, 0, 0), this._decorations[m] = c;
        }
        const h = i[l], d = this._validateRangeRelaxedNoAllocations(h.range), f = A2(h.options), p = this._buffer.getOffsetAt(d.startLineNumber, d.startColumn), g = this._buffer.getOffsetAt(d.endLineNumber, d.endColumn);
        c.ownerId = e, c.reset(r, p, g, d), c.setOptions(f), this._onDidChangeDecorations.checkAffectedAndFire(f), this._decorationsTree.insert(c), u[l] = c.id, l++;
      } else
        c && delete this._decorations[c.id];
    }
    return u;
  }
  setTokens(e) {
    if (e.length === 0)
      return;
    let t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i];
      let s = 0, a = 0, l = !1;
      for (let u = 0, c = o.tokens.length; u < c; u++) {
        const h = o.startLineNumber + u;
        l ? (this._tokens.setTokens(this._languageIdentifier.id, h - 1, this._buffer.getLineLength(h), o.tokens[u], !1), a = h) : this._tokens.setTokens(this._languageIdentifier.id, h - 1, this._buffer.getLineLength(h), o.tokens[u], !0) && (l = !0, s = h, a = h);
      }
      l && t.push({ fromLineNumber: s, toLineNumber: a });
    }
    t.length > 0 && this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: !1,
      semanticTokensApplied: !1,
      ranges: t
    });
  }
  setSemanticTokens(e, t) {
    this._tokens2.set(e, t), this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: !1,
      semanticTokensApplied: e !== null,
      ranges: [{ fromLineNumber: 1, toLineNumber: this.getLineCount() }]
    });
  }
  hasCompleteSemanticTokens() {
    return this._tokens2.isComplete();
  }
  hasSomeSemanticTokens() {
    return !this._tokens2.isEmpty();
  }
  setPartialSemanticTokens(e, t) {
    if (this.hasCompleteSemanticTokens())
      return;
    const i = this._tokens2.setPartial(e, t);
    this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: !1,
      semanticTokensApplied: !0,
      ranges: [{ fromLineNumber: i.startLineNumber, toLineNumber: i.endLineNumber }]
    });
  }
  tokenizeViewport(e, t) {
    e = Math.max(1, e), t = Math.min(this._buffer.getLineCount(), t), this._tokenization.tokenizeViewport(e, t);
  }
  clearTokens() {
    this._tokens.flush(), this._emitModelTokensChangedEvent({
      tokenizationSupportChanged: !0,
      semanticTokensApplied: !1,
      ranges: [{
        fromLineNumber: 1,
        toLineNumber: this._buffer.getLineCount()
      }]
    });
  }
  _emitModelTokensChangedEvent(e) {
    this._isDisposing || this._onDidChangeTokens.fire(e);
  }
  resetTokenization() {
    this._tokenization.reset();
  }
  forceTokenization(e) {
    if (e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    this._tokenization.forceTokenization(e);
  }
  isCheapToTokenize(e) {
    return this._tokenization.isCheapToTokenize(e);
  }
  tokenizeIfCheap(e) {
    this.isCheapToTokenize(e) && this.forceTokenization(e);
  }
  getLineTokens(e) {
    if (e < 1 || e > this.getLineCount())
      throw new Error("Illegal value for lineNumber");
    return this._getLineTokens(e);
  }
  _getLineTokens(e) {
    const t = this.getLineContent(e), i = this._tokens.getTokens(this._languageIdentifier.id, e - 1, t);
    return this._tokens2.addSemanticTokens(e, i);
  }
  getLanguageIdentifier() {
    return this._languageIdentifier;
  }
  getModeId() {
    return this._languageIdentifier.language;
  }
  setMode(e) {
    if (this._languageIdentifier.id === e.id)
      return;
    let t = {
      oldLanguage: this._languageIdentifier.language,
      newLanguage: e.language
    };
    this._languageIdentifier = e, this._onDidChangeLanguage.fire(t), this._onDidChangeLanguageConfiguration.fire({});
  }
  getLanguageIdAtPosition(e, t) {
    const i = this.validatePosition(new ie(e, t)), r = this.getLineTokens(i.lineNumber);
    return r.getLanguageId(r.findTokenIndexAtOffset(i.column - 1));
  }
  // Having tokens allows implementing additional helper methods
  getWordAtPosition(e) {
    this._assertNotDisposed();
    const t = this.validatePosition(e), i = this.getLineContent(t.lineNumber), r = this._getLineTokens(t.lineNumber), o = r.findTokenIndexAtOffset(t.column - 1), [s, a] = Xr._findLanguageBoundaries(r, o), l = lb(t.column, ui.getWordDefinition(r.getLanguageId(o)), i.substring(s, a), s);
    if (l && l.startColumn <= e.column && e.column <= l.endColumn)
      return l;
    if (o > 0 && s === t.column - 1) {
      const [u, c] = Xr._findLanguageBoundaries(r, o - 1), h = lb(t.column, ui.getWordDefinition(r.getLanguageId(o - 1)), i.substring(u, c), u);
      if (h && h.startColumn <= e.column && e.column <= h.endColumn)
        return h;
    }
    return null;
  }
  static _findLanguageBoundaries(e, t) {
    const i = e.getLanguageId(t);
    let r = 0;
    for (let s = t; s >= 0 && e.getLanguageId(s) === i; s--)
      r = e.getStartOffset(s);
    let o = e.getLineContent().length;
    for (let s = t, a = e.getCount(); s < a && e.getLanguageId(s) === i; s++)
      o = e.getEndOffset(s);
    return [r, o];
  }
  getWordUntilPosition(e) {
    const t = this.getWordAtPosition(e);
    return t ? {
      word: t.word.substr(0, e.column - t.startColumn),
      startColumn: t.startColumn,
      endColumn: e.column
    } : {
      word: "",
      startColumn: e.column,
      endColumn: e.column
    };
  }
  findMatchingBracketUp(e, t) {
    let i = e.toLowerCase(), r = this.validatePosition(t), o = this._getLineTokens(r.lineNumber), s = o.getLanguageId(o.findTokenIndexAtOffset(r.column - 1)), a = ui.getBracketsSupport(s);
    if (!a)
      return null;
    let l = a.textIsBracket[i];
    return l ? Ly(this._findMatchingBracketUp(l, r, null)) : null;
  }
  matchBracket(e) {
    return this._matchBracket(this.validatePosition(e));
  }
  _establishBracketSearchOffsets(e, t, i, r) {
    const o = t.getCount(), s = t.getLanguageId(r);
    let a = Math.max(0, e.column - 1 - i.maxBracketLength);
    for (let u = r - 1; u >= 0; u--) {
      const c = t.getEndOffset(u);
      if (c <= a)
        break;
      if (Nl(t.getStandardTokenType(u)) || t.getLanguageId(u) !== s) {
        a = c;
        break;
      }
    }
    let l = Math.min(t.getLineContent().length, e.column - 1 + i.maxBracketLength);
    for (let u = r + 1; u < o; u++) {
      const c = t.getStartOffset(u);
      if (c >= l)
        break;
      if (Nl(t.getStandardTokenType(u)) || t.getLanguageId(u) !== s) {
        l = c;
        break;
      }
    }
    return { searchStartOffset: a, searchEndOffset: l };
  }
  _matchBracket(e) {
    const t = e.lineNumber, i = this._getLineTokens(t), r = this._buffer.getLineContent(t), o = i.findTokenIndexAtOffset(e.column - 1);
    if (o < 0)
      return null;
    const s = ui.getBracketsSupport(i.getLanguageId(o));
    if (s && !Nl(i.getStandardTokenType(o))) {
      let { searchStartOffset: a, searchEndOffset: l } = this._establishBracketSearchOffsets(e, i, s, o), u = null;
      for (; ; ) {
        const c = ia.findNextBracketInRange(s.forwardRegex, t, r, a, l);
        if (!c)
          break;
        if (c.startColumn <= e.column && e.column <= c.endColumn) {
          const h = r.substring(c.startColumn - 1, c.endColumn - 1).toLowerCase(), d = this._matchFoundBracket(c, s.textIsBracket[h], s.textIsOpenBracket[h], null);
          if (d) {
            if (d instanceof Fu)
              return null;
            u = d;
          }
        }
        a = c.endColumn - 1;
      }
      if (u)
        return u;
    }
    if (o > 0 && i.getStartOffset(o) === e.column - 1) {
      const a = o - 1, l = ui.getBracketsSupport(i.getLanguageId(a));
      if (l && !Nl(i.getStandardTokenType(a))) {
        let { searchStartOffset: u, searchEndOffset: c } = this._establishBracketSearchOffsets(e, i, l, a);
        const h = ia.findPrevBracketInRange(l.reversedRegex, t, r, u, c);
        if (h && h.startColumn <= e.column && e.column <= h.endColumn) {
          const d = r.substring(h.startColumn - 1, h.endColumn - 1).toLowerCase(), f = this._matchFoundBracket(h, l.textIsBracket[d], l.textIsOpenBracket[d], null);
          if (f)
            return f instanceof Fu ? null : f;
        }
      }
    }
    return null;
  }
  _matchFoundBracket(e, t, i, r) {
    if (!t)
      return null;
    const o = i ? this._findMatchingBracketDown(t, e.getEndPosition(), r) : this._findMatchingBracketUp(t, e.getStartPosition(), r);
    return o ? o instanceof Fu ? o : [e, o] : null;
  }
  _findMatchingBracketUp(e, t, i) {
    const r = e.languageIdentifier.id, o = e.reversedRegex;
    let s = -1, a = 0;
    const l = (u, c, h, d) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return Fu.INSTANCE;
        const f = ia.findPrevBracketInRange(o, u, c, h, d);
        if (!f)
          break;
        const p = c.substring(f.startColumn - 1, f.endColumn - 1).toLowerCase();
        if (e.isOpen(p) ? s++ : e.isClose(p) && s--, s === 0)
          return f;
        d = f.startColumn - 1;
      }
      return null;
    };
    for (let u = t.lineNumber; u >= 1; u--) {
      const c = this._getLineTokens(u), h = c.getCount(), d = this._buffer.getLineContent(u);
      let f = h - 1, p = d.length, g = d.length;
      u === t.lineNumber && (f = c.findTokenIndexAtOffset(t.column - 1), p = t.column - 1, g = t.column - 1);
      let _ = !0;
      for (; f >= 0; f--) {
        const m = c.getLanguageId(f) === r && !Nl(c.getStandardTokenType(f));
        if (m)
          _ ? p = c.getStartOffset(f) : (p = c.getStartOffset(f), g = c.getEndOffset(f));
        else if (_ && p !== g) {
          const v = l(u, d, p, g);
          if (v)
            return v;
        }
        _ = m;
      }
      if (_ && p !== g) {
        const m = l(u, d, p, g);
        if (m)
          return m;
      }
    }
    return null;
  }
  _findMatchingBracketDown(e, t, i) {
    const r = e.languageIdentifier.id, o = e.forwardRegex;
    let s = 1, a = 0;
    const l = (c, h, d, f) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return Fu.INSTANCE;
        const p = ia.findNextBracketInRange(o, c, h, d, f);
        if (!p)
          break;
        const g = h.substring(p.startColumn - 1, p.endColumn - 1).toLowerCase();
        if (e.isOpen(g) ? s++ : e.isClose(g) && s--, s === 0)
          return p;
        d = p.endColumn - 1;
      }
      return null;
    }, u = this.getLineCount();
    for (let c = t.lineNumber; c <= u; c++) {
      const h = this._getLineTokens(c), d = h.getCount(), f = this._buffer.getLineContent(c);
      let p = 0, g = 0, _ = 0;
      c === t.lineNumber && (p = h.findTokenIndexAtOffset(t.column - 1), g = t.column - 1, _ = t.column - 1);
      let m = !0;
      for (; p < d; p++) {
        const v = h.getLanguageId(p) === r && !Nl(h.getStandardTokenType(p));
        if (v)
          m || (g = h.getStartOffset(p)), _ = h.getEndOffset(p);
        else if (m && g !== _) {
          const C = l(c, f, g, _);
          if (C)
            return C;
        }
        m = v;
      }
      if (m && g !== _) {
        const v = l(c, f, g, _);
        if (v)
          return v;
      }
    }
    return null;
  }
  findPrevBracket(e) {
    const t = this.validatePosition(e);
    let i = -1, r = null;
    for (let o = t.lineNumber; o >= 1; o--) {
      const s = this._getLineTokens(o), a = s.getCount(), l = this._buffer.getLineContent(o);
      let u = a - 1, c = l.length, h = l.length;
      if (o === t.lineNumber) {
        u = s.findTokenIndexAtOffset(t.column - 1), c = t.column - 1, h = t.column - 1;
        const f = s.getLanguageId(u);
        i !== f && (i = f, r = ui.getBracketsSupport(i));
      }
      let d = !0;
      for (; u >= 0; u--) {
        const f = s.getLanguageId(u);
        if (i !== f) {
          if (r && d && c !== h) {
            const g = ia.findPrevBracketInRange(r.reversedRegex, o, l, c, h);
            if (g)
              return this._toFoundBracket(r, g);
            d = !1;
          }
          i = f, r = ui.getBracketsSupport(i);
        }
        const p = !!r && !Nl(s.getStandardTokenType(u));
        if (p)
          d ? c = s.getStartOffset(u) : (c = s.getStartOffset(u), h = s.getEndOffset(u));
        else if (r && d && c !== h) {
          const g = ia.findPrevBracketInRange(r.reversedRegex, o, l, c, h);
          if (g)
            return this._toFoundBracket(r, g);
        }
        d = p;
      }
      if (r && d && c !== h) {
        const f = ia.findPrevBracketInRange(r.reversedRegex, o, l, c, h);
        if (f)
          return this._toFoundBracket(r, f);
      }
    }
    return null;
  }
  findNextBracket(e) {
    const t = this.validatePosition(e), i = this.getLineCount();
    let r = -1, o = null;
    for (let s = t.lineNumber; s <= i; s++) {
      const a = this._getLineTokens(s), l = a.getCount(), u = this._buffer.getLineContent(s);
      let c = 0, h = 0, d = 0;
      if (s === t.lineNumber) {
        c = a.findTokenIndexAtOffset(t.column - 1), h = t.column - 1, d = t.column - 1;
        const p = a.getLanguageId(c);
        r !== p && (r = p, o = ui.getBracketsSupport(r));
      }
      let f = !0;
      for (; c < l; c++) {
        const p = a.getLanguageId(c);
        if (r !== p) {
          if (o && f && h !== d) {
            const _ = ia.findNextBracketInRange(o.forwardRegex, s, u, h, d);
            if (_)
              return this._toFoundBracket(o, _);
            f = !1;
          }
          r = p, o = ui.getBracketsSupport(r);
        }
        const g = !!o && !Nl(a.getStandardTokenType(c));
        if (g)
          f || (h = a.getStartOffset(c)), d = a.getEndOffset(c);
        else if (o && f && h !== d) {
          const _ = ia.findNextBracketInRange(o.forwardRegex, s, u, h, d);
          if (_)
            return this._toFoundBracket(o, _);
        }
        f = g;
      }
      if (o && f && h !== d) {
        const p = ia.findNextBracketInRange(o.forwardRegex, s, u, h, d);
        if (p)
          return this._toFoundBracket(o, p);
      }
    }
    return null;
  }
  findEnclosingBrackets(e, t) {
    let i;
    if (typeof t > "u")
      i = null;
    else {
      const f = Date.now();
      i = () => Date.now() - f <= t;
    }
    const r = this.validatePosition(e), o = this.getLineCount(), s = /* @__PURE__ */ new Map();
    let a = [];
    const l = (f, p) => {
      if (!s.has(f)) {
        let g = [];
        for (let _ = 0, m = p ? p.brackets.length : 0; _ < m; _++)
          g[_] = 0;
        s.set(f, g);
      }
      a = s.get(f);
    };
    let u = 0;
    const c = (f, p, g, _, m) => {
      for (; ; ) {
        if (i && ++u % 100 === 0 && !i())
          return Fu.INSTANCE;
        const v = ia.findNextBracketInRange(f.forwardRegex, p, g, _, m);
        if (!v)
          break;
        const C = g.substring(v.startColumn - 1, v.endColumn - 1).toLowerCase(), y = f.textIsBracket[C];
        if (y && (y.isOpen(C) ? a[y.index]++ : y.isClose(C) && a[y.index]--, a[y.index] === -1))
          return this._matchFoundBracket(v, y, !1, i);
        _ = v.endColumn - 1;
      }
      return null;
    };
    let h = -1, d = null;
    for (let f = r.lineNumber; f <= o; f++) {
      const p = this._getLineTokens(f), g = p.getCount(), _ = this._buffer.getLineContent(f);
      let m = 0, v = 0, C = 0;
      if (f === r.lineNumber) {
        m = p.findTokenIndexAtOffset(r.column - 1), v = r.column - 1, C = r.column - 1;
        const w = p.getLanguageId(m);
        h !== w && (h = w, d = ui.getBracketsSupport(h), l(h, d));
      }
      let y = !0;
      for (; m < g; m++) {
        const w = p.getLanguageId(m);
        if (h !== w) {
          if (d && y && v !== C) {
            const S = c(d, f, _, v, C);
            if (S)
              return Ly(S);
            y = !1;
          }
          h = w, d = ui.getBracketsSupport(h), l(h, d);
        }
        const L = !!d && !Nl(p.getStandardTokenType(m));
        if (L)
          y || (v = p.getStartOffset(m)), C = p.getEndOffset(m);
        else if (d && y && v !== C) {
          const S = c(d, f, _, v, C);
          if (S)
            return Ly(S);
        }
        y = L;
      }
      if (d && y && v !== C) {
        const w = c(d, f, _, v, C);
        if (w)
          return Ly(w);
      }
    }
    return null;
  }
  _toFoundBracket(e, t) {
    if (!t)
      return null;
    let i = this.getValueInRange(t);
    i = i.toLowerCase();
    let r = e.textIsBracket[i];
    return r ? {
      range: t,
      open: r.open,
      close: r.close,
      isOpen: e.textIsOpenBracket[i]
    } : null;
  }
  /**
   * Returns:
   *  - -1 => the line consists of whitespace
   *  - otherwise => the indent level is returned value
   */
  static computeIndentLevel(e, t) {
    let i = 0, r = 0, o = e.length;
    for (; r < o; ) {
      let s = e.charCodeAt(r);
      if (s === 32)
        i++;
      else if (s === 9)
        i = i - i % t + t;
      else
        break;
      r++;
    }
    return r === o ? -1 : i;
  }
  _computeIndentLevel(e) {
    return Xr.computeIndentLevel(this._buffer.getLineContent(e + 1), this._options.tabSize);
  }
  getActiveIndentGuide(e, t, i) {
    this._assertNotDisposed();
    const r = this.getLineCount();
    if (e < 1 || e > r)
      throw new Error("Illegal value for lineNumber");
    const o = ui.getFoldingRules(this._languageIdentifier.id), s = !!(o && o.offSide);
    let a = -2, l = -1, u = -2, c = -1;
    const h = (S) => {
      if (a !== -1 && (a === -2 || a > S - 1)) {
        a = -1, l = -1;
        for (let E = S - 2; E >= 0; E--) {
          let D = this._computeIndentLevel(E);
          if (D >= 0) {
            a = E, l = D;
            break;
          }
        }
      }
      if (u === -2) {
        u = -1, c = -1;
        for (let E = S; E < r; E++) {
          let D = this._computeIndentLevel(E);
          if (D >= 0) {
            u = E, c = D;
            break;
          }
        }
      }
    };
    let d = -2, f = -1, p = -2, g = -1;
    const _ = (S) => {
      if (d === -2) {
        d = -1, f = -1;
        for (let E = S - 2; E >= 0; E--) {
          let D = this._computeIndentLevel(E);
          if (D >= 0) {
            d = E, f = D;
            break;
          }
        }
      }
      if (p !== -1 && (p === -2 || p < S - 1)) {
        p = -1, g = -1;
        for (let E = S; E < r; E++) {
          let D = this._computeIndentLevel(E);
          if (D >= 0) {
            p = E, g = D;
            break;
          }
        }
      }
    };
    let m = 0, v = !0, C = 0, y = !0, w = 0, L = 0;
    for (let S = 0; v || y; S++) {
      const E = e - S, D = e + S;
      S > 1 && (E < 1 || E < t) && (v = !1), S > 1 && (D > r || D > i) && (y = !1), S > 5e4 && (v = !1, y = !1);
      let x = -1;
      if (v) {
        const A = this._computeIndentLevel(E - 1);
        A >= 0 ? (u = E - 1, c = A, x = Math.ceil(A / this._options.indentSize)) : (h(E), x = this._getIndentLevelForWhitespaceLine(s, l, c));
      }
      let R = -1;
      if (y) {
        const A = this._computeIndentLevel(D - 1);
        A >= 0 ? (d = D - 1, f = A, R = Math.ceil(A / this._options.indentSize)) : (_(D), R = this._getIndentLevelForWhitespaceLine(s, f, g));
      }
      if (S === 0) {
        L = x;
        continue;
      }
      if (S === 1) {
        if (D <= r && R >= 0 && L + 1 === R) {
          v = !1, m = D, C = D, w = R;
          continue;
        }
        if (E >= 1 && x >= 0 && x - 1 === L) {
          y = !1, m = E, C = E, w = x;
          continue;
        }
        if (m = e, C = e, w = L, w === 0)
          return { startLineNumber: m, endLineNumber: C, indent: w };
      }
      v && (x >= w ? m = E : v = !1), y && (R >= w ? C = D : y = !1);
    }
    return { startLineNumber: m, endLineNumber: C, indent: w };
  }
  getLinesIndentGuides(e, t) {
    this._assertNotDisposed();
    const i = this.getLineCount();
    if (e < 1 || e > i)
      throw new Error("Illegal value for startLineNumber");
    if (t < 1 || t > i)
      throw new Error("Illegal value for endLineNumber");
    const r = ui.getFoldingRules(this._languageIdentifier.id), o = !!(r && r.offSide);
    let s = new Array(t - e + 1), a = -2, l = -1, u = -2, c = -1;
    for (let h = e; h <= t; h++) {
      let d = h - e;
      const f = this._computeIndentLevel(h - 1);
      if (f >= 0) {
        a = h - 1, l = f, s[d] = Math.ceil(f / this._options.indentSize);
        continue;
      }
      if (a === -2) {
        a = -1, l = -1;
        for (let p = h - 2; p >= 0; p--) {
          let g = this._computeIndentLevel(p);
          if (g >= 0) {
            a = p, l = g;
            break;
          }
        }
      }
      if (u !== -1 && (u === -2 || u < h - 1)) {
        u = -1, c = -1;
        for (let p = h; p < i; p++) {
          let g = this._computeIndentLevel(p);
          if (g >= 0) {
            u = p, c = g;
            break;
          }
        }
      }
      s[d] = this._getIndentLevelForWhitespaceLine(o, l, c);
    }
    return s;
  }
  _getIndentLevelForWhitespaceLine(e, t, i) {
    return t === -1 || i === -1 ? 0 : t < i ? 1 + Math.floor(t / this._options.indentSize) : t === i ? Math.ceil(i / this._options.indentSize) : e ? Math.ceil(i / this._options.indentSize) : 1 + Math.floor(i / this._options.indentSize);
  }
  //#endregion
  normalizePosition(e, t) {
    return e;
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return Zue(this.getLineContent(e)) + 1;
  }
}
Xr.MODEL_SYNC_LIMIT = 50 * 1024 * 1024;
Xr.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024;
Xr.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3;
Xr.DEFAULT_CREATION_OPTIONS = {
  isForSimpleWidget: !1,
  tabSize: bo.tabSize,
  indentSize: bo.indentSize,
  insertSpaces: bo.insertSpaces,
  detectIndentation: !1,
  defaultEOL: 1,
  trimAutoWhitespace: bo.trimAutoWhitespace,
  largeFileOptimizations: bo.largeFileOptimizations
};
function Zue(n) {
  let e = 0;
  for (const t of n)
    if (t === " " || t === "	")
      e++;
    else
      break;
  return e;
}
class I2 {
  constructor() {
    this._decorationsTree0 = new E2(), this._decorationsTree1 = new E2();
  }
  intervalSearch(e, t, i, r, o) {
    const s = this._decorationsTree0.intervalSearch(e, t, i, r, o), a = this._decorationsTree1.intervalSearch(e, t, i, r, o);
    return s.concat(a);
  }
  search(e, t, i, r) {
    if (i)
      return this._decorationsTree1.search(e, t, r);
    {
      const o = this._decorationsTree0.search(e, t, r), s = this._decorationsTree1.search(e, t, r);
      return o.concat(s);
    }
  }
  collectNodesFromOwner(e) {
    const t = this._decorationsTree0.collectNodesFromOwner(e), i = this._decorationsTree1.collectNodesFromOwner(e);
    return t.concat(i);
  }
  collectNodesPostOrder() {
    const e = this._decorationsTree0.collectNodesPostOrder(), t = this._decorationsTree1.collectNodesPostOrder();
    return e.concat(t);
  }
  insert(e) {
    ID(e) ? this._decorationsTree1.insert(e) : this._decorationsTree0.insert(e);
  }
  delete(e) {
    ID(e) ? this._decorationsTree1.delete(e) : this._decorationsTree0.delete(e);
  }
  resolveNode(e, t) {
    ID(e) ? this._decorationsTree1.resolveNode(e, t) : this._decorationsTree0.resolveNode(e, t);
  }
  acceptReplace(e, t, i, r) {
    this._decorationsTree0.acceptReplace(e, t, i, r), this._decorationsTree1.acceptReplace(e, t, i, r);
  }
}
function Oc(n) {
  return n.replace(/[^a-z0-9\-_]/gi, " ");
}
class V3 {
  constructor(e) {
    this.color = e.color || "", this.darkColor = e.darkColor || "";
  }
}
class Que extends V3 {
  constructor(e) {
    super(e), this._resolvedColor = null, this.position = typeof e.position == "number" ? e.position : Xv.Center;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = null;
  }
  _resolveColor(e, t) {
    if (typeof e == "string")
      return e;
    let i = e ? t.getColor(e.id) : null;
    return i ? i.toString() : "";
  }
}
class Jue extends V3 {
  constructor(e) {
    super(e), this.position = e.position;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = void 0;
  }
  _resolveColor(e, t) {
    return typeof e == "string" ? ne.fromHex(e) : t.getColor(e.id);
  }
}
class kn {
  constructor(e) {
    this.description = e.description, this.stickiness = e.stickiness || 0, this.zIndex = e.zIndex || 0, this.className = e.className ? Oc(e.className) : null, this.hoverMessage = e.hoverMessage || null, this.glyphMarginHoverMessage = e.glyphMarginHoverMessage || null, this.isWholeLine = e.isWholeLine || !1, this.showIfCollapsed = e.showIfCollapsed || !1, this.collapseOnReplaceEdit = e.collapseOnReplaceEdit || !1, this.overviewRuler = e.overviewRuler ? new Que(e.overviewRuler) : null, this.minimap = e.minimap ? new Jue(e.minimap) : null, this.glyphMarginClassName = e.glyphMarginClassName ? Oc(e.glyphMarginClassName) : null, this.linesDecorationsClassName = e.linesDecorationsClassName ? Oc(e.linesDecorationsClassName) : null, this.firstLineDecorationClassName = e.firstLineDecorationClassName ? Oc(e.firstLineDecorationClassName) : null, this.marginClassName = e.marginClassName ? Oc(e.marginClassName) : null, this.inlineClassName = e.inlineClassName ? Oc(e.inlineClassName) : null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.beforeContentClassName = e.beforeContentClassName ? Oc(e.beforeContentClassName) : null, this.afterContentClassName = e.afterContentClassName ? Oc(e.afterContentClassName) : null;
  }
  static register(e) {
    return new kn(e);
  }
  static createDynamic(e) {
    return new kn(e);
  }
}
kn.EMPTY = kn.register({ description: "empty" });
const P2 = [
  kn.register({
    description: "tracked-range-always-grows-when-typing-at-edges",
    stickiness: 0
    /* AlwaysGrowsWhenTypingAtEdges */
  }),
  kn.register({
    description: "tracked-range-never-grows-when-typing-at-edges",
    stickiness: 1
    /* NeverGrowsWhenTypingAtEdges */
  }),
  kn.register({
    description: "tracked-range-grows-only-when-typing-before",
    stickiness: 2
    /* GrowsOnlyWhenTypingBefore */
  }),
  kn.register({
    description: "tracked-range-grows-only-when-typing-after",
    stickiness: 3
    /* GrowsOnlyWhenTypingAfter */
  })
];
function A2(n) {
  return n instanceof kn ? n : kn.createDynamic(n);
}
class ece extends Ce {
  constructor() {
    super(), this._actual = this._register(new q()), this.event = this._actual.event, this._deferredCnt = 0, this._shouldFire = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit() {
    if (this._deferredCnt--, this._deferredCnt === 0 && this._shouldFire) {
      const e = {
        affectsMinimap: this._affectsMinimap,
        affectsOverviewRuler: this._affectsOverviewRuler
      };
      this._shouldFire = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._actual.fire(e);
    }
  }
  checkAffectedAndFire(e) {
    this._affectsMinimap || (this._affectsMinimap = !!(e.minimap && e.minimap.position)), this._affectsOverviewRuler || (this._affectsOverviewRuler = !!(e.overviewRuler && e.overviewRuler.color)), this._shouldFire = !0;
  }
  fire() {
    this._affectsMinimap = !0, this._affectsOverviewRuler = !0, this._shouldFire = !0;
  }
}
class tce extends Ce {
  constructor() {
    super(), this._fastEmitter = this._register(new q()), this.fastEvent = this._fastEmitter.event, this._slowEmitter = this._register(new q()), this.slowEvent = this._slowEmitter.event, this._deferredCnt = 0, this._deferredEvent = null;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit(e = null) {
    if (this._deferredCnt--, this._deferredCnt === 0 && this._deferredEvent !== null) {
      this._deferredEvent.rawContentChangedEvent.resultingSelection = e;
      const t = this._deferredEvent;
      this._deferredEvent = null, this._fastEmitter.fire(t), this._slowEmitter.fire(t);
    }
  }
  fire(e) {
    if (this._deferredCnt > 0) {
      this._deferredEvent ? this._deferredEvent = this._deferredEvent.merge(e) : this._deferredEvent = e;
      return;
    }
    this._fastEmitter.fire(e), this._slowEmitter.fire(e);
  }
}
const ice = () => !0, M2 = () => !1, nce = (n) => n === " " || n === "	";
class aa {
  constructor(e, t, i) {
    this._languageIdentifier = e;
    const r = i.options, o = r.get(
      128
      /* layoutInfo */
    );
    this.readOnly = r.get(
      78
      /* readOnly */
    ), this.tabSize = t.tabSize, this.indentSize = t.indentSize, this.insertSpaces = t.insertSpaces, this.stickyTabStops = r.get(
      102
      /* stickyTabStops */
    ), this.lineHeight = r.get(
      56
      /* lineHeight */
    ), this.pageSize = Math.max(1, Math.floor(o.height / this.lineHeight) - 2), this.useTabStops = r.get(
      113
      /* useTabStops */
    ), this.wordSeparators = r.get(
      114
      /* wordSeparators */
    ), this.emptySelectionClipboard = r.get(
      30
      /* emptySelectionClipboard */
    ), this.copyWithSyntaxHighlighting = r.get(
      19
      /* copyWithSyntaxHighlighting */
    ), this.multiCursorMergeOverlapping = r.get(
      66
      /* multiCursorMergeOverlapping */
    ), this.multiCursorPaste = r.get(
      68
      /* multiCursorPaste */
    ), this.autoClosingBrackets = r.get(
      5
      /* autoClosingBrackets */
    ), this.autoClosingQuotes = r.get(
      8
      /* autoClosingQuotes */
    ), this.autoClosingDelete = r.get(
      6
      /* autoClosingDelete */
    ), this.autoClosingOvertype = r.get(
      7
      /* autoClosingOvertype */
    ), this.autoSurround = r.get(
      11
      /* autoSurround */
    ), this.autoIndent = r.get(
      9
      /* autoIndent */
    ), this.surroundingPairs = {}, this._electricChars = null, this.shouldAutoCloseBefore = {
      quote: aa._getShouldAutoClose(e, this.autoClosingQuotes),
      bracket: aa._getShouldAutoClose(e, this.autoClosingBrackets)
    }, this.autoClosingPairs = ui.getAutoClosingPairs(e.id);
    let s = aa._getSurroundingPairs(e);
    if (s)
      for (const a of s)
        this.surroundingPairs[a.open] = a.close;
  }
  static shouldRecreate(e) {
    return e.hasChanged(
      128
      /* layoutInfo */
    ) || e.hasChanged(
      114
      /* wordSeparators */
    ) || e.hasChanged(
      30
      /* emptySelectionClipboard */
    ) || e.hasChanged(
      66
      /* multiCursorMergeOverlapping */
    ) || e.hasChanged(
      68
      /* multiCursorPaste */
    ) || e.hasChanged(
      5
      /* autoClosingBrackets */
    ) || e.hasChanged(
      8
      /* autoClosingQuotes */
    ) || e.hasChanged(
      6
      /* autoClosingDelete */
    ) || e.hasChanged(
      7
      /* autoClosingOvertype */
    ) || e.hasChanged(
      11
      /* autoSurround */
    ) || e.hasChanged(
      113
      /* useTabStops */
    ) || e.hasChanged(
      56
      /* lineHeight */
    ) || e.hasChanged(
      78
      /* readOnly */
    );
  }
  get electricChars() {
    if (!this._electricChars) {
      this._electricChars = {};
      let e = aa._getElectricCharacters(this._languageIdentifier);
      if (e)
        for (const t of e)
          this._electricChars[t] = !0;
    }
    return this._electricChars;
  }
  normalizeIndentation(e) {
    return Xr.normalizeIndentation(e, this.indentSize, this.insertSpaces);
  }
  static _getElectricCharacters(e) {
    try {
      return ui.getElectricCharacters(e.id);
    } catch (t) {
      return Pi(t), null;
    }
  }
  static _getShouldAutoClose(e, t) {
    switch (t) {
      case "beforeWhitespace":
        return nce;
      case "languageDefined":
        return aa._getLanguageDefinedShouldAutoClose(e);
      case "always":
        return ice;
      case "never":
        return M2;
    }
  }
  static _getLanguageDefinedShouldAutoClose(e) {
    try {
      const t = ui.getAutoCloseBeforeSet(e.id);
      return (i) => t.indexOf(i) !== -1;
    } catch (t) {
      return Pi(t), M2;
    }
  }
  static _getSurroundingPairs(e) {
    try {
      return ui.getSurroundingPairs(e.id);
    } catch (t) {
      return Pi(t), null;
    }
  }
}
class qn {
  constructor(e, t, i, r) {
    this.selectionStart = e, this.selectionStartLeftoverVisibleColumns = t, this.position = i, this.leftoverVisibleColumns = r, this.selection = qn._computeSelection(this.selectionStart, this.position);
  }
  equals(e) {
    return this.selectionStartLeftoverVisibleColumns === e.selectionStartLeftoverVisibleColumns && this.leftoverVisibleColumns === e.leftoverVisibleColumns && this.position.equals(e.position) && this.selectionStart.equalsRange(e.selectionStart);
  }
  hasSelection() {
    return !this.selection.isEmpty() || !this.selectionStart.isEmpty();
  }
  move(e, t, i, r) {
    return e ? new qn(this.selectionStart, this.selectionStartLeftoverVisibleColumns, new ie(t, i), r) : new qn(new G(t, i, t, i), r, new ie(t, i), r);
  }
  static _computeSelection(e, t) {
    let i, r, o, s;
    return e.isEmpty() ? (i = e.startLineNumber, r = e.startColumn, o = t.lineNumber, s = t.column) : t.isBeforeOrEqual(e.getStartPosition()) ? (i = e.endLineNumber, r = e.endColumn, o = t.lineNumber, s = t.column) : (i = e.startLineNumber, r = e.startColumn, o = t.lineNumber, s = t.column), new Ut(i, r, o, s);
  }
}
class F2 {
  constructor(e, t, i) {
    this.model = e, this.coordinatesConverter = t, this.cursorConfig = i;
  }
}
class rce {
  constructor(e) {
    this.modelState = e, this.viewState = null;
  }
}
class oce {
  constructor(e) {
    this.modelState = null, this.viewState = e;
  }
}
class at {
  constructor(e, t) {
    this.modelState = e, this.viewState = t;
  }
  static fromModelState(e) {
    return new rce(e);
  }
  static fromViewState(e) {
    return new oce(e);
  }
  static fromModelSelection(e) {
    const t = e.selectionStartLineNumber, i = e.selectionStartColumn, r = e.positionLineNumber, o = e.positionColumn, s = new qn(new G(t, i, t, i), 0, new ie(r, o), 0);
    return at.fromModelState(s);
  }
  static fromModelSelections(e) {
    let t = [];
    for (let i = 0, r = e.length; i < r; i++)
      t[i] = this.fromModelSelection(e[i]);
    return t;
  }
  equals(e) {
    return this.viewState.equals(e.viewState) && this.modelState.equals(e.modelState);
  }
}
class vo {
  constructor(e, t, i) {
    this.type = e, this.commands = t, this.shouldPushStackElementBefore = i.shouldPushStackElementBefore, this.shouldPushStackElementAfter = i.shouldPushStackElementAfter;
  }
}
class Kt {
  static visibleColumnFromColumn(e, t, i) {
    const r = e.length, o = t - 1 < r ? t - 1 : r;
    let s = 0, a = 0;
    for (; a < o; ) {
      const l = Pu(e, o, a);
      if (a += l >= 65536 ? 2 : 1, l === 9)
        s = Kt.nextRenderTabStop(s, i);
      else {
        let u = Mf(l);
        for (; a < o; ) {
          const c = Pu(e, o, a), h = Mf(c);
          if (dv(u, h))
            break;
          a += c >= 65536 ? 2 : 1, u = h;
        }
        el(l) || hv(l) ? s = s + 2 : s = s + 1;
      }
    }
    return s;
  }
  /**
   * Returns an array that maps one based columns to one based visible columns. The entry at position 0 is -1.
  */
  static visibleColumnsByColumns(e, t) {
    const i = e.length;
    let r = new Array();
    r.push(-1);
    let o = 0, s = 0;
    for (; s < i; ) {
      const a = Pu(e, i, s);
      if (s += a >= 65536 ? 2 : 1, r.push(o), a >= 65536 && r.push(o), a === 9)
        o = Kt.nextRenderTabStop(o, t);
      else {
        let l = Mf(a);
        for (; s < i; ) {
          const u = Pu(e, i, s), c = Mf(u);
          if (dv(l, c))
            break;
          s += u >= 65536 ? 2 : 1, r.push(o), a >= 65536 && r.push(o), l = c;
        }
        el(a) || hv(a) ? o = o + 2 : o = o + 1;
      }
    }
    return r.push(o), r;
  }
  static visibleColumnFromColumn2(e, t, i) {
    return this.visibleColumnFromColumn(t.getLineContent(i.lineNumber), i.column, e.tabSize);
  }
  static columnFromVisibleColumn(e, t, i) {
    if (t <= 0)
      return 1;
    const r = e.length;
    let o = 0, s = 1, a = 0;
    for (; a < r; ) {
      const l = Pu(e, r, a);
      a += l >= 65536 ? 2 : 1;
      let u;
      if (l === 9)
        u = Kt.nextRenderTabStop(o, i);
      else {
        let h = Mf(l);
        for (; a < r; ) {
          const d = Pu(e, r, a), f = Mf(d);
          if (dv(h, f))
            break;
          a += d >= 65536 ? 2 : 1, h = f;
        }
        el(l) || hv(l) ? u = o + 2 : u = o + 1;
      }
      const c = a + 1;
      if (u >= t) {
        const h = t - o;
        return u - t < h ? c : s;
      }
      o = u, s = c;
    }
    return r + 1;
  }
  static columnFromVisibleColumn2(e, t, i, r) {
    let o = this.columnFromVisibleColumn(t.getLineContent(i), r, e.tabSize), s = t.getLineMinColumn(i);
    if (o < s)
      return s;
    let a = t.getLineMaxColumn(i);
    return o > a ? a : o;
  }
  /**
   * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
   */
  static nextRenderTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
   */
  static nextIndentTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   */
  static prevRenderTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   */
  static prevIndentTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
}
function Yf(n) {
  return n === "'" || n === '"' || n === "`";
}
class o_ {
  /**
   * Get the visible column at the position. If we get to a non-whitespace character first
   * or past the end of string then return -1.
   *
   * **Note** `position` and the return value are 0-based.
   */
  static whitespaceVisibleColumn(e, t, i) {
    const r = e.length;
    let o = 0, s = -1, a = -1;
    for (let l = 0; l < r; l++) {
      if (l === t)
        return [s, a, o];
      switch (o % i === 0 && (s = l, a = o), e.charCodeAt(l)) {
        case 32:
          o += 1;
          break;
        case 9:
          o = Kt.nextRenderTabStop(o, i);
          break;
        default:
          return [-1, -1, -1];
      }
    }
    return t === r ? [s, a, o] : [-1, -1, -1];
  }
  /**
   * Return the position that should result from a move left, right or to the
   * nearest tab, if atomic tabs are enabled. Left and right are used for the
   * arrow key movements, nearest is used for mouse selection. It returns
   * -1 if atomic tabs are not relevant and you should fall back to normal
   * behaviour.
   *
   * **Note**: `position` and the return value are 0-based.
   */
  static atomicPosition(e, t, i, r) {
    const o = e.length, [s, a, l] = o_.whitespaceVisibleColumn(e, t, i);
    if (l === -1)
      return -1;
    let u;
    switch (r) {
      case 0:
        u = !0;
        break;
      case 1:
        u = !1;
        break;
      case 2:
        if (l % i === 0)
          return t;
        u = l % i <= i / 2;
        break;
    }
    if (u) {
      if (s === -1)
        return -1;
      let d = a;
      for (let f = s; f < o; ++f) {
        if (d === a + i)
          return s;
        switch (e.charCodeAt(f)) {
          case 32:
            d += 1;
            break;
          case 9:
            d = Kt.nextRenderTabStop(d, i);
            break;
          default:
            return -1;
        }
      }
      return d === a + i ? s : -1;
    }
    const c = Kt.nextRenderTabStop(l, i);
    let h = l;
    for (let d = t; d < o; d++) {
      if (h === c)
        return d;
      switch (e.charCodeAt(d)) {
        case 32:
          h += 1;
          break;
        case 9:
          h = Kt.nextRenderTabStop(h, i);
          break;
        default:
          return -1;
      }
    }
    return h === c ? o : -1;
  }
}
class Mc {
  constructor(e = null) {
    this.hitTarget = e, this.type = 0;
  }
}
class B3 {
  constructor(e, t) {
    this.position = e, this.spanNode = t, this.type = 1;
  }
}
var td;
(function(n) {
  function e(t, i, r) {
    const o = t.getPositionFromDOMInfo(i, r);
    return o ? new B3(o, i) : new Mc(i);
  }
  n.createFromDOMInfo = e;
})(td || (td = {}));
class sce {
  constructor(e, t) {
    this.lastViewCursorsRenderData = e, this.lastTextareaPosition = t;
  }
}
class Wa {
  constructor(e, t, i = 0, r = null, o = null, s = null) {
    this.element = e, this.type = t, this.mouseColumn = i, this.position = r, !o && r && (o = new G(r.lineNumber, r.column, r.lineNumber, r.column)), this.range = o, this.detail = s;
  }
  static _typeToString(e) {
    return e === 1 ? "TEXTAREA" : e === 2 ? "GUTTER_GLYPH_MARGIN" : e === 3 ? "GUTTER_LINE_NUMBERS" : e === 4 ? "GUTTER_LINE_DECORATIONS" : e === 5 ? "GUTTER_VIEW_ZONE" : e === 6 ? "CONTENT_TEXT" : e === 7 ? "CONTENT_EMPTY" : e === 8 ? "CONTENT_VIEW_ZONE" : e === 9 ? "CONTENT_WIDGET" : e === 10 ? "OVERVIEW_RULER" : e === 11 ? "SCROLLBAR" : e === 12 ? "OVERLAY_WIDGET" : "UNKNOWN";
  }
  static toString(e) {
    return this._typeToString(e.type) + ": " + e.position + " - " + e.range + " - " + e.detail;
  }
  toString() {
    return Wa.toString(this);
  }
}
class ea {
  static isTextArea(e) {
    return e.length === 2 && e[0] === 3 && e[1] === 6;
  }
  static isChildOfViewLines(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 7;
  }
  static isStrictChildOfViewLines(e) {
    return e.length > 4 && e[0] === 3 && e[3] === 7;
  }
  static isChildOfScrollableElement(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 5;
  }
  static isChildOfMinimap(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 8;
  }
  static isChildOfContentWidgets(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 1;
  }
  static isChildOfOverflowingContentWidgets(e) {
    return e.length >= 1 && e[0] === 2;
  }
  static isChildOfOverlayWidgets(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 4;
  }
}
class ig {
  constructor(e, t, i) {
    this.model = e.model;
    const r = e.configuration.options;
    this.layoutInfo = r.get(
      128
      /* layoutInfo */
    ), this.viewDomNode = t.viewDomNode, this.lineHeight = r.get(
      56
      /* lineHeight */
    ), this.stickyTabStops = r.get(
      102
      /* stickyTabStops */
    ), this.typicalHalfwidthCharacterWidth = r.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, this.lastRenderData = i, this._context = e, this._viewHelper = t;
  }
  getZoneAtCoord(e) {
    return ig.getZoneAtCoord(this._context, e);
  }
  static getZoneAtCoord(e, t) {
    const i = e.viewLayout.getWhitespaceAtVerticalOffset(t);
    if (i) {
      const r = i.verticalOffset + i.height / 2, o = e.model.getLineCount();
      let s = null, a, l = null;
      return i.afterLineNumber !== o && (l = new ie(i.afterLineNumber + 1, 1)), i.afterLineNumber > 0 && (s = new ie(i.afterLineNumber, e.model.getLineMaxColumn(i.afterLineNumber))), l === null ? a = s : s === null ? a = l : t < r ? a = s : a = l, {
        viewZoneId: i.id,
        afterLineNumber: i.afterLineNumber,
        positionBefore: s,
        positionAfter: l,
        position: a
      };
    }
    return null;
  }
  getFullLineRangeAtCoord(e) {
    if (this._context.viewLayout.isAfterLines(e)) {
      const r = this._context.model.getLineCount(), o = this._context.model.getLineMaxColumn(r);
      return {
        range: new G(r, o, r, o),
        isAfterLines: !0
      };
    }
    const t = this._context.viewLayout.getLineNumberAtVerticalOffset(e), i = this._context.model.getLineMaxColumn(t);
    return {
      range: new G(t, 1, t, i),
      isAfterLines: !1
    };
  }
  getLineNumberAtVerticalOffset(e) {
    return this._context.viewLayout.getLineNumberAtVerticalOffset(e);
  }
  isAfterLines(e) {
    return this._context.viewLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._context.viewLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._context.viewLayout.isInBottomPadding(e);
  }
  getVerticalOffsetForLineNumber(e) {
    return this._context.viewLayout.getVerticalOffsetForLineNumber(e);
  }
  findAttribute(e, t) {
    return ig._findAttribute(e, t, this._viewHelper.viewDomNode);
  }
  static _findAttribute(e, t, i) {
    for (; e && e !== document.body; ) {
      if (e.hasAttribute && e.hasAttribute(t))
        return e.getAttribute(t);
      if (e === i)
        return null;
      e = e.parentNode;
    }
    return null;
  }
  getLineWidth(e) {
    return this._viewHelper.getLineWidth(e);
  }
  visibleRangeForPosition(e, t) {
    return this._viewHelper.visibleRangeForPosition(e, t);
  }
  getPositionFromDOMInfo(e, t) {
    return this._viewHelper.getPositionFromDOMInfo(e, t);
  }
  getCurrentScrollTop() {
    return this._context.viewLayout.getCurrentScrollTop();
  }
  getCurrentScrollLeft() {
    return this._context.viewLayout.getCurrentScrollLeft();
  }
}
class ace {
  constructor(e, t, i) {
    this.editorPos = t, this.pos = i, this.mouseVerticalOffset = Math.max(0, e.getCurrentScrollTop() + i.y - t.y), this.mouseContentHorizontalOffset = e.getCurrentScrollLeft() + i.x - t.x - e.layoutInfo.contentLeft, this.isInMarginArea = i.x - t.x < e.layoutInfo.contentLeft && i.x - t.x >= e.layoutInfo.glyphMarginLeft, this.isInContentArea = !this.isInMarginArea, this.mouseColumn = Math.max(0, ur._getMouseColumn(this.mouseContentHorizontalOffset, e.typicalHalfwidthCharacterWidth));
  }
}
class bI extends ace {
  constructor(e, t, i, r) {
    super(e, t, i), this._ctx = e, r ? (this.target = r, this.targetPath = Ql.collect(r, e.viewDomNode)) : (this.target = null, this.targetPath = new Uint8Array(0));
  }
  toString() {
    return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}
	target: ${this.target ? this.target.outerHTML : null}`;
  }
  // public fulfill(type: MouseTargetType.OVERVIEW_RULER, position?: Position | null, range?: EditorRange | null, detail?: any): MouseTarget;
  // public fulfill(type: MouseTargetType.OUTSIDE_EDITOR, position?: Position | null, range?: EditorRange | null, detail?: any): MouseTarget;
  fulfill(e, t = null, i = null, r = null) {
    let o = this.mouseColumn;
    return t && t.column < this._ctx.model.getLineMaxColumn(t.lineNumber) && (o = Kt.visibleColumnFromColumn(this._ctx.model.getLineContent(t.lineNumber), t.column, this._ctx.model.getTextModelOptions().tabSize) + 1), new Wa(this.target, e, o, t, i, r);
  }
  withTarget(e) {
    return new bI(this._ctx, this.editorPos, this.pos, e);
  }
}
const k2 = { isAfterLines: !0 };
function kD(n) {
  return {
    isAfterLines: !1,
    horizontalDistanceToText: n
  };
}
class ur {
  constructor(e, t) {
    this._context = e, this._viewHelper = t;
  }
  mouseTargetIsWidget(e) {
    const t = e.target, i = Ql.collect(t, this._viewHelper.viewDomNode);
    return !!(ea.isChildOfContentWidgets(i) || ea.isChildOfOverflowingContentWidgets(i) || ea.isChildOfOverlayWidgets(i));
  }
  createMouseTarget(e, t, i, r) {
    const o = new ig(this._context, this._viewHelper, e), s = new bI(o, t, i, r);
    try {
      return ur._createMouseTarget(o, s, !1);
    } catch {
      return s.fulfill(
        0
        /* UNKNOWN */
      );
    }
  }
  static _createMouseTarget(e, t, i) {
    if (t.target === null) {
      if (i)
        return t.fulfill(
          0
          /* UNKNOWN */
        );
      const s = ur._doHitTest(e, t);
      return s.type === 1 ? ur.createMouseTargetFromHitTestPosition(e, t, s.spanNode, s.position) : this._createMouseTarget(e, t.withTarget(s.hitTarget), !0);
    }
    const r = t;
    let o = null;
    return o = o || ur._hitTestContentWidget(e, r), o = o || ur._hitTestOverlayWidget(e, r), o = o || ur._hitTestMinimap(e, r), o = o || ur._hitTestScrollbarSlider(e, r), o = o || ur._hitTestViewZone(e, r), o = o || ur._hitTestMargin(e, r), o = o || ur._hitTestViewCursor(e, r), o = o || ur._hitTestTextArea(e, r), o = o || ur._hitTestViewLines(e, r, i), o = o || ur._hitTestScrollbar(e, r), o || t.fulfill(
      0
      /* UNKNOWN */
    );
  }
  static _hitTestContentWidget(e, t) {
    if (ea.isChildOfContentWidgets(t.targetPath) || ea.isChildOfOverflowingContentWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfill(9, null, null, i) : t.fulfill(
        0
        /* UNKNOWN */
      );
    }
    return null;
  }
  static _hitTestOverlayWidget(e, t) {
    if (ea.isChildOfOverlayWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfill(12, null, null, i) : t.fulfill(
        0
        /* UNKNOWN */
      );
    }
    return null;
  }
  static _hitTestViewCursor(e, t) {
    if (t.target) {
      const i = e.lastRenderData.lastViewCursorsRenderData;
      for (const r of i)
        if (t.target === r.domNode)
          return t.fulfill(6, r.position, null, { mightBeForeignElement: !1 });
    }
    if (t.isInContentArea) {
      const i = e.lastRenderData.lastViewCursorsRenderData, r = t.mouseContentHorizontalOffset, o = t.mouseVerticalOffset;
      for (const s of i) {
        if (r < s.contentLeft || r > s.contentLeft + s.width)
          continue;
        const a = e.getVerticalOffsetForLineNumber(s.position.lineNumber);
        if (a <= o && o <= a + s.height)
          return t.fulfill(6, s.position, null, { mightBeForeignElement: !1 });
      }
    }
    return null;
  }
  static _hitTestViewZone(e, t) {
    const i = e.getZoneAtCoord(t.mouseVerticalOffset);
    if (i) {
      const r = t.isInContentArea ? 8 : 5;
      return t.fulfill(r, i.position, null, i);
    }
    return null;
  }
  static _hitTestTextArea(e, t) {
    return ea.isTextArea(t.targetPath) ? e.lastRenderData.lastTextareaPosition ? t.fulfill(6, e.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: !1 }) : t.fulfill(1, e.lastRenderData.lastTextareaPosition) : null;
  }
  static _hitTestMargin(e, t) {
    if (t.isInMarginArea) {
      const i = e.getFullLineRangeAtCoord(t.mouseVerticalOffset), r = i.range.getStartPosition();
      let o = Math.abs(t.pos.x - t.editorPos.x);
      const s = {
        isAfterLines: i.isAfterLines,
        glyphMarginLeft: e.layoutInfo.glyphMarginLeft,
        glyphMarginWidth: e.layoutInfo.glyphMarginWidth,
        lineNumbersWidth: e.layoutInfo.lineNumbersWidth,
        offsetX: o
      };
      return o -= e.layoutInfo.glyphMarginLeft, o <= e.layoutInfo.glyphMarginWidth ? t.fulfill(2, r, i.range, s) : (o -= e.layoutInfo.glyphMarginWidth, o <= e.layoutInfo.lineNumbersWidth ? t.fulfill(3, r, i.range, s) : (o -= e.layoutInfo.lineNumbersWidth, t.fulfill(4, r, i.range, s)));
    }
    return null;
  }
  static _hitTestViewLines(e, t, i) {
    if (!ea.isChildOfViewLines(t.targetPath))
      return null;
    if (e.isInTopPadding(t.mouseVerticalOffset))
      return t.fulfill(7, new ie(1, 1), null, k2);
    if (e.isAfterLines(t.mouseVerticalOffset) || e.isInBottomPadding(t.mouseVerticalOffset)) {
      const o = e.model.getLineCount(), s = e.model.getLineMaxColumn(o);
      return t.fulfill(7, new ie(o, s), null, k2);
    }
    if (i) {
      if (ea.isStrictChildOfViewLines(t.targetPath)) {
        const o = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset);
        if (e.model.getLineLength(o) === 0) {
          const a = e.getLineWidth(o), l = kD(t.mouseContentHorizontalOffset - a);
          return t.fulfill(7, new ie(o, 1), null, l);
        }
        const s = e.getLineWidth(o);
        if (t.mouseContentHorizontalOffset >= s) {
          const a = kD(t.mouseContentHorizontalOffset - s), l = new ie(o, e.model.getLineMaxColumn(o));
          return t.fulfill(7, l, null, a);
        }
      }
      return t.fulfill(
        0
        /* UNKNOWN */
      );
    }
    const r = ur._doHitTest(e, t);
    return r.type === 1 ? ur.createMouseTargetFromHitTestPosition(e, t, r.spanNode, r.position) : this._createMouseTarget(e, t.withTarget(r.hitTarget), !0);
  }
  static _hitTestMinimap(e, t) {
    if (ea.isChildOfMinimap(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), r = e.model.getLineMaxColumn(i);
      return t.fulfill(11, new ie(i, r));
    }
    return null;
  }
  static _hitTestScrollbarSlider(e, t) {
    if (ea.isChildOfScrollableElement(t.targetPath) && t.target && t.target.nodeType === 1) {
      const i = t.target.className;
      if (i && /\b(slider|scrollbar)\b/.test(i)) {
        const r = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), o = e.model.getLineMaxColumn(r);
        return t.fulfill(11, new ie(r, o));
      }
    }
    return null;
  }
  static _hitTestScrollbar(e, t) {
    if (ea.isChildOfScrollableElement(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), r = e.model.getLineMaxColumn(i);
      return t.fulfill(11, new ie(i, r));
    }
    return null;
  }
  getMouseColumn(e, t) {
    const i = this._context.configuration.options, r = i.get(
      128
      /* layoutInfo */
    ), o = this._context.viewLayout.getCurrentScrollLeft() + t.x - e.x - r.contentLeft;
    return ur._getMouseColumn(o, i.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth);
  }
  static _getMouseColumn(e, t) {
    return e < 0 ? 1 : Math.round(e / t) + 1;
  }
  static createMouseTargetFromHitTestPosition(e, t, i, r) {
    const o = r.lineNumber, s = r.column, a = e.getLineWidth(o);
    if (t.mouseContentHorizontalOffset > a) {
      const g = kD(t.mouseContentHorizontalOffset - a);
      return t.fulfill(7, r, null, g);
    }
    const l = e.visibleRangeForPosition(o, s);
    if (!l)
      return t.fulfill(0, r);
    const u = l.left;
    if (t.mouseContentHorizontalOffset === u)
      return t.fulfill(6, r, null, { mightBeForeignElement: !1 });
    const c = [];
    if (c.push({ offset: l.left, column: s }), s > 1) {
      const g = e.visibleRangeForPosition(o, s - 1);
      g && c.push({ offset: g.left, column: s - 1 });
    }
    const h = e.model.getLineMaxColumn(o);
    if (s < h) {
      const g = e.visibleRangeForPosition(o, s + 1);
      g && c.push({ offset: g.left, column: s + 1 });
    }
    c.sort((g, _) => g.offset - _.offset);
    const d = t.pos.toClientCoordinates(), f = i.getBoundingClientRect(), p = f.left <= d.clientX && d.clientX <= f.right;
    for (let g = 1; g < c.length; g++) {
      const _ = c[g - 1], m = c[g];
      if (_.offset <= t.mouseContentHorizontalOffset && t.mouseContentHorizontalOffset <= m.offset) {
        const v = new G(o, _.column, o, m.column);
        return t.fulfill(6, r, v, { mightBeForeignElement: !p });
      }
    }
    return t.fulfill(6, r, null, { mightBeForeignElement: !p });
  }
  /**
   * Most probably WebKit browsers and Edge
   */
  static _doHitTestWithCaretRangeFromPoint(e, t) {
    const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), o = e.getVerticalOffsetForLineNumber(i) + Math.floor(e.lineHeight / 2);
    let s = t.pos.y + (o - t.mouseVerticalOffset);
    s <= t.editorPos.y && (s = t.editorPos.y + 1), s >= t.editorPos.y + e.layoutInfo.height && (s = t.editorPos.y + e.layoutInfo.height - 1);
    const a = new gI(t.pos.x, s), l = this._actualDoHitTestWithCaretRangeFromPoint(e, a.toClientCoordinates());
    return l.type === 1 ? l : this._actualDoHitTestWithCaretRangeFromPoint(e, t.pos.toClientCoordinates());
  }
  static _actualDoHitTestWithCaretRangeFromPoint(e, t) {
    const i = U_(e.viewDomNode);
    let r;
    if (i ? typeof i.caretRangeFromPoint > "u" ? r = lce(i, t.clientX, t.clientY) : r = i.caretRangeFromPoint(t.clientX, t.clientY) : r = document.caretRangeFromPoint(t.clientX, t.clientY), !r || !r.startContainer)
      return new Mc();
    const o = r.startContainer;
    if (o.nodeType === o.TEXT_NODE) {
      const s = o.parentNode, a = s ? s.parentNode : null, l = a ? a.parentNode : null;
      return (l && l.nodeType === l.ELEMENT_NODE ? l.className : null) === Wl.CLASS_NAME ? td.createFromDOMInfo(e, s, r.startOffset) : new Mc(o.parentNode);
    } else if (o.nodeType === o.ELEMENT_NODE) {
      const s = o.parentNode, a = s ? s.parentNode : null;
      return (a && a.nodeType === a.ELEMENT_NODE ? a.className : null) === Wl.CLASS_NAME ? td.createFromDOMInfo(e, o, o.textContent.length) : new Mc(o);
    }
    return new Mc();
  }
  /**
   * Most probably Gecko
   */
  static _doHitTestWithCaretPositionFromPoint(e, t) {
    const i = document.caretPositionFromPoint(t.clientX, t.clientY);
    if (i.offsetNode.nodeType === i.offsetNode.TEXT_NODE) {
      const r = i.offsetNode.parentNode, o = r ? r.parentNode : null, s = o ? o.parentNode : null;
      return (s && s.nodeType === s.ELEMENT_NODE ? s.className : null) === Wl.CLASS_NAME ? td.createFromDOMInfo(e, i.offsetNode.parentNode, i.offset) : new Mc(i.offsetNode.parentNode);
    }
    if (i.offsetNode.nodeType === i.offsetNode.ELEMENT_NODE) {
      const r = i.offsetNode.parentNode, o = r && r.nodeType === r.ELEMENT_NODE ? r.className : null, s = r ? r.parentNode : null, a = s && s.nodeType === s.ELEMENT_NODE ? s.className : null;
      if (o === Wl.CLASS_NAME) {
        const l = i.offsetNode.childNodes[Math.min(i.offset, i.offsetNode.childNodes.length - 1)];
        if (l)
          return td.createFromDOMInfo(e, l, 0);
      } else if (a === Wl.CLASS_NAME)
        return td.createFromDOMInfo(e, i.offsetNode, 0);
    }
    return new Mc(i.offsetNode);
  }
  static _snapToSoftTabBoundary(e, t) {
    const i = t.getLineContent(e.lineNumber), { tabSize: r } = t.getTextModelOptions(), o = o_.atomicPosition(
      i,
      e.column - 1,
      r,
      2
      /* Nearest */
    );
    return o !== -1 ? new ie(e.lineNumber, o + 1) : e;
  }
  static _doHitTest(e, t) {
    let i = new Mc();
    return typeof document.caretRangeFromPoint == "function" ? i = this._doHitTestWithCaretRangeFromPoint(e, t) : document.caretPositionFromPoint && (i = this._doHitTestWithCaretPositionFromPoint(e, t.pos.toClientCoordinates())), i.type === 1 && e.stickyTabStops && (i = new B3(this._snapToSoftTabBoundary(i.position, e.model), i.spanNode)), i;
  }
}
function lce(n, e, t) {
  const i = document.createRange();
  let r = n.elementFromPoint(e, t);
  if (r !== null) {
    for (; r && r.firstChild && r.firstChild.nodeType !== r.firstChild.TEXT_NODE && r.lastChild && r.lastChild.firstChild; )
      r = r.lastChild;
    const o = r.getBoundingClientRect(), s = window.getComputedStyle(r, null).getPropertyValue("font"), a = r.innerText;
    let l = o.left, u = 0, c;
    if (e > o.left + o.width)
      u = a.length;
    else {
      const h = ud.getInstance();
      for (let d = 0; d < a.length + 1; d++) {
        if (c = h.getCharWidth(a.charAt(d), s) / 2, l += c, e < l) {
          u = d;
          break;
        }
        l += c;
      }
    }
    i.setStart(r.firstChild, u), i.setEnd(r.firstChild, u);
  }
  return i;
}
class ud {
  constructor() {
    this._cache = {}, this._canvas = document.createElement("canvas");
  }
  static getInstance() {
    return ud._INSTANCE || (ud._INSTANCE = new ud()), ud._INSTANCE;
  }
  getCharWidth(e, t) {
    const i = e + t;
    if (this._cache[i])
      return this._cache[i];
    const r = this._canvas.getContext("2d");
    r.font = t;
    const s = r.measureText(e).width;
    return this._cache[i] = s, s;
  }
}
ud._INSTANCE = null;
function Hb(n) {
  return function(e, t) {
    let i = !1;
    return n && (i = n.mouseTargetIsWidget(t)), i || t.preventDefault(), t;
  };
}
class $d extends X_ {
  constructor(e, t, i) {
    super(), this._context = e, this.viewController = t, this.viewHelper = i, this.mouseTargetFactory = new ur(this._context, i), this._mouseDownOperation = this._register(new uce(this._context, this.viewController, this.viewHelper, (s, a) => this._createMouseTarget(s, a), (s) => this._getMouseColumn(s))), this.lastMouseLeaveTime = -1, this._height = this._context.configuration.options.get(
      128
      /* layoutInfo */
    ).height;
    const r = new qle(this.viewHelper.viewDomNode);
    this._register(r.onContextMenu(this.viewHelper.viewDomNode, (s) => this._onContextMenu(s, !0))), this._register(r.onMouseMoveThrottled(this.viewHelper.viewDomNode, (s) => this._onMouseMove(s), Hb(this.mouseTargetFactory), $d.MOUSE_MOVE_MINIMUM_TIME)), this._register(r.onMouseUp(this.viewHelper.viewDomNode, (s) => this._onMouseUp(s))), this._register(r.onMouseLeave(this.viewHelper.viewDomNode, (s) => this._onMouseLeave(s))), this._register(r.onMouseDown(this.viewHelper.viewDomNode, (s) => this._onMouseDown(s)));
    const o = (s) => {
      if (this.viewController.emitMouseWheel(s), !this._context.configuration.options.get(
        65
        /* mouseWheelZoom */
      ))
        return;
      const a = new Yp(s);
      if (kt ? (s.metaKey || s.ctrlKey) && !s.shiftKey && !s.altKey : s.ctrlKey && !s.metaKey && !s.shiftKey && !s.altKey) {
        const u = vb.getZoomLevel(), c = a.deltaY > 0 ? 1 : -1;
        vb.setZoomLevel(u + c), a.preventDefault(), a.stopPropagation();
      }
    };
    this._register(be(this.viewHelper.viewDomNode, Ge.MOUSE_WHEEL, o, { capture: !0, passive: !1 })), this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      128
      /* layoutInfo */
    )) {
      const t = this._context.configuration.options.get(
        128
        /* layoutInfo */
      ).height;
      this._height !== t && (this._height = t, this._mouseDownOperation.onHeightChanged());
    }
    return !1;
  }
  onCursorStateChanged(e) {
    return this._mouseDownOperation.onCursorStateChanged(e), !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  onScrollChanged(e) {
    return this._mouseDownOperation.onScrollChanged(), !1;
  }
  // --- end event handlers
  getTargetAtClientPoint(e, t) {
    const r = new O3(e, t).toPageCoordinates(), o = x3(this.viewHelper.viewDomNode);
    return r.y < o.y || r.y > o.y + o.height || r.x < o.x || r.x > o.x + o.width ? null : this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), o, r, null);
  }
  _createMouseTarget(e, t) {
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, t ? e.target : null);
  }
  _getMouseColumn(e) {
    return this.mouseTargetFactory.getMouseColumn(e.editorPos, e.pos);
  }
  _onContextMenu(e, t) {
    this.viewController.emitContextMenu({
      event: e,
      target: this._createMouseTarget(e, t)
    });
  }
  _onMouseMove(e) {
    this._mouseDownOperation.isActive() || e.timestamp < this.lastMouseLeaveTime || this.viewController.emitMouseMove({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseLeave(e) {
    this.lastMouseLeaveTime = (/* @__PURE__ */ new Date()).getTime(), this.viewController.emitMouseLeave({
      event: e,
      target: null
    });
  }
  _onMouseUp(e) {
    this.viewController.emitMouseUp({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseDown(e) {
    const t = this._createMouseTarget(e, !0), i = t.type === 6 || t.type === 7, r = t.type === 2 || t.type === 3 || t.type === 4, o = t.type === 3, s = this._context.configuration.options.get(
      96
      /* selectOnLineNumbers */
    ), a = t.type === 8 || t.type === 5, l = t.type === 9;
    let u = e.leftButton || e.middleButton;
    kt && e.leftButton && e.ctrlKey && (u = !1);
    const c = () => {
      e.preventDefault(), this.viewHelper.focusTextArea();
    };
    if (u && (i || o && s))
      c(), this._mouseDownOperation.start(t.type, e);
    else if (r)
      e.preventDefault();
    else if (a) {
      const h = t.detail;
      this.viewHelper.shouldSuppressMouseDownOnViewZone(h.viewZoneId) && (c(), this._mouseDownOperation.start(t.type, e), e.preventDefault());
    } else
      l && this.viewHelper.shouldSuppressMouseDownOnWidget(t.detail) && (c(), e.preventDefault());
    this.viewController.emitMouseDown({
      event: e,
      target: t
    });
  }
}
$d.MOUSE_MOVE_MINIMUM_TIME = 100;
class uce extends Ce {
  constructor(e, t, i, r, o) {
    super(), this._context = e, this._viewController = t, this._viewHelper = i, this._createMouseTarget = r, this._getMouseColumn = o, this._mouseMoveMonitor = this._register(new Xle(this._viewHelper.viewDomNode)), this._onScrollTimeout = this._register(new oc()), this._mouseState = new RE(), this._currentSelection = new Ut(1, 1, 1, 1), this._isActive = !1, this._lastMouseEvent = null;
  }
  dispose() {
    super.dispose();
  }
  isActive() {
    return this._isActive;
  }
  _onMouseDownThenMove(e) {
    this._lastMouseEvent = e, this._mouseState.setModifiers(e);
    const t = this._findMousePosition(e, !0);
    t && (this._mouseState.isDragAndDrop ? this._viewController.emitMouseDrag({
      event: e,
      target: t
    }) : this._dispatchMouse(t, !0));
  }
  start(e, t) {
    this._lastMouseEvent = t, this._mouseState.setStartedOnLineNumbers(
      e === 3
      /* GUTTER_LINE_NUMBERS */
    ), this._mouseState.setStartButtons(t), this._mouseState.setModifiers(t);
    const i = this._findMousePosition(t, !0);
    if (!i || !i.position)
      return;
    this._mouseState.trySetCount(t.detail, i.position), t.detail = this._mouseState.count;
    const r = this._context.configuration.options;
    if (!r.get(
      78
      /* readOnly */
    ) && r.get(
      29
      /* dragAndDrop */
    ) && !r.get(
      16
      /* columnSelection */
    ) && !this._mouseState.altKey && t.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && i.type === 6 && i.position && this._currentSelection.containsPosition(i.position)) {
      this._mouseState.isDragAndDrop = !0, this._isActive = !0, this._mouseMoveMonitor.startMonitoring(t.target, t.buttons, Hb(null), (o) => this._onMouseDownThenMove(o), (o) => {
        const s = this._findMousePosition(this._lastMouseEvent, !0);
        o && o instanceof KeyboardEvent ? this._viewController.emitMouseDropCanceled() : this._viewController.emitMouseDrop({
          event: this._lastMouseEvent,
          target: s ? this._createMouseTarget(this._lastMouseEvent, !0) : null
          // Ignoring because position is unknown, e.g., Content View Zone
        }), this._stop();
      });
      return;
    }
    this._mouseState.isDragAndDrop = !1, this._dispatchMouse(i, t.shiftKey), this._isActive || (this._isActive = !0, this._mouseMoveMonitor.startMonitoring(t.target, t.buttons, Hb(null), (o) => this._onMouseDownThenMove(o), () => this._stop()));
  }
  _stop() {
    this._isActive = !1, this._onScrollTimeout.cancel();
  }
  onHeightChanged() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onScrollChanged() {
    this._isActive && this._onScrollTimeout.setIfNotSet(() => {
      if (!this._lastMouseEvent)
        return;
      const e = this._findMousePosition(this._lastMouseEvent, !1);
      e && (this._mouseState.isDragAndDrop || this._dispatchMouse(e, !0));
    }, 10);
  }
  onCursorStateChanged(e) {
    this._currentSelection = e.selections[0];
  }
  _getPositionOutsideEditor(e) {
    const t = e.editorPos, i = this._context.model, r = this._context.viewLayout, o = this._getMouseColumn(e);
    if (e.posy < t.y) {
      const a = Math.max(r.getCurrentScrollTop() - (t.y - e.posy), 0), l = ig.getZoneAtCoord(this._context, a);
      if (l) {
        const c = this._helpPositionJumpOverViewZone(l);
        if (c)
          return new Wa(null, 13, o, c);
      }
      const u = r.getLineNumberAtVerticalOffset(a);
      return new Wa(null, 13, o, new ie(u, 1));
    }
    if (e.posy > t.y + t.height) {
      const a = r.getCurrentScrollTop() + (e.posy - t.y), l = ig.getZoneAtCoord(this._context, a);
      if (l) {
        const c = this._helpPositionJumpOverViewZone(l);
        if (c)
          return new Wa(null, 13, o, c);
      }
      const u = r.getLineNumberAtVerticalOffset(a);
      return new Wa(null, 13, o, new ie(u, i.getLineMaxColumn(u)));
    }
    const s = r.getLineNumberAtVerticalOffset(r.getCurrentScrollTop() + (e.posy - t.y));
    return e.posx < t.x ? new Wa(null, 13, o, new ie(s, 1)) : e.posx > t.x + t.width ? new Wa(null, 13, o, new ie(s, i.getLineMaxColumn(s))) : null;
  }
  _findMousePosition(e, t) {
    const i = this._getPositionOutsideEditor(e);
    if (i)
      return i;
    const r = this._createMouseTarget(e, t);
    if (!r.position)
      return null;
    if (r.type === 8 || r.type === 5) {
      const s = this._helpPositionJumpOverViewZone(r.detail);
      if (s)
        return new Wa(r.element, r.type, r.mouseColumn, s, null, r.detail);
    }
    return r;
  }
  _helpPositionJumpOverViewZone(e) {
    const t = new ie(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn), i = e.positionBefore, r = e.positionAfter;
    return i && r ? i.isBefore(t) ? i : r : null;
  }
  _dispatchMouse(e, t) {
    e.position && this._viewController.dispatchMouse({
      position: e.position,
      mouseColumn: e.mouseColumn,
      startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
      inSelectionMode: t,
      mouseDownCount: this._mouseState.count,
      altKey: this._mouseState.altKey,
      ctrlKey: this._mouseState.ctrlKey,
      metaKey: this._mouseState.metaKey,
      shiftKey: this._mouseState.shiftKey,
      leftButton: this._mouseState.leftButton,
      middleButton: this._mouseState.middleButton
    });
  }
}
class RE {
  constructor() {
    this._altKey = !1, this._ctrlKey = !1, this._metaKey = !1, this._shiftKey = !1, this._leftButton = !1, this._middleButton = !1, this._startedOnLineNumbers = !1, this._lastMouseDownPosition = null, this._lastMouseDownPositionEqualCount = 0, this._lastMouseDownCount = 0, this._lastSetMouseDownCountTime = 0, this.isDragAndDrop = !1;
  }
  get altKey() {
    return this._altKey;
  }
  get ctrlKey() {
    return this._ctrlKey;
  }
  get metaKey() {
    return this._metaKey;
  }
  get shiftKey() {
    return this._shiftKey;
  }
  get leftButton() {
    return this._leftButton;
  }
  get middleButton() {
    return this._middleButton;
  }
  get startedOnLineNumbers() {
    return this._startedOnLineNumbers;
  }
  get count() {
    return this._lastMouseDownCount;
  }
  setModifiers(e) {
    this._altKey = e.altKey, this._ctrlKey = e.ctrlKey, this._metaKey = e.metaKey, this._shiftKey = e.shiftKey;
  }
  setStartButtons(e) {
    this._leftButton = e.leftButton, this._middleButton = e.middleButton;
  }
  setStartedOnLineNumbers(e) {
    this._startedOnLineNumbers = e;
  }
  trySetCount(e, t) {
    const i = (/* @__PURE__ */ new Date()).getTime();
    i - this._lastSetMouseDownCountTime > RE.CLEAR_MOUSE_DOWN_COUNT_TIME && (e = 1), this._lastSetMouseDownCountTime = i, e > this._lastMouseDownCount + 1 && (e = this._lastMouseDownCount + 1), this._lastMouseDownPosition && this._lastMouseDownPosition.equals(t) ? this._lastMouseDownPositionEqualCount++ : this._lastMouseDownPositionEqualCount = 1, this._lastMouseDownPosition = t, this._lastMouseDownCount = Math.min(e, this._lastMouseDownPositionEqualCount);
  }
}
RE.CLEAR_MOUSE_DOWN_COUNT_TIME = 400;
class On {
  constructor(e, t, i, r, o) {
    this.value = e, this.selectionStart = t, this.selectionEnd = i, this.selectionStartPosition = r, this.selectionEndPosition = o;
  }
  toString() {
    return "[ <" + this.value + ">, selectionStart: " + this.selectionStart + ", selectionEnd: " + this.selectionEnd + "]";
  }
  static readFromTextArea(e) {
    return new On(e.getValue(), e.getSelectionStart(), e.getSelectionEnd(), null, null);
  }
  collapseSelection() {
    return new On(this.value, this.value.length, this.value.length, null, null);
  }
  writeToTextArea(e, t, i) {
    t.setValue(e, this.value), i && t.setSelectionRange(e, this.selectionStart, this.selectionEnd);
  }
  deduceEditorPosition(e) {
    if (e <= this.selectionStart) {
      const r = this.value.substring(e, this.selectionStart);
      return this._finishDeduceEditorPosition(this.selectionStartPosition, r, -1);
    }
    if (e >= this.selectionEnd) {
      const r = this.value.substring(this.selectionEnd, e);
      return this._finishDeduceEditorPosition(this.selectionEndPosition, r, 1);
    }
    const t = this.value.substring(this.selectionStart, e);
    if (t.indexOf(String.fromCharCode(8230)) === -1)
      return this._finishDeduceEditorPosition(this.selectionStartPosition, t, 1);
    const i = this.value.substring(e, this.selectionEnd);
    return this._finishDeduceEditorPosition(this.selectionEndPosition, i, -1);
  }
  _finishDeduceEditorPosition(e, t, i) {
    let r = 0, o = -1;
    for (; (o = t.indexOf(`
`, o + 1)) !== -1; )
      r++;
    return [e, i * t.length, r];
  }
  static selectedText(e) {
    return new On(e, 0, e.length, null, null);
  }
  static deduceInput(e, t, i) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    let r = e.value, o = e.selectionStart, s = e.selectionEnd, a = t.value, l = t.selectionStart, u = t.selectionEnd;
    const c = r.substring(s), h = a.substring(u), d = ck(c, h);
    a = a.substring(0, a.length - d), r = r.substring(0, r.length - d);
    const f = r.substring(0, o), p = a.substring(0, l), g = uk(f, p);
    if (a = a.substring(g), r = r.substring(g), l -= g, o -= g, u -= g, s -= g, i && l === u && r.length > 0) {
      let m = null;
      if (l === a.length ? a.startsWith(r) && (m = a.substring(r.length)) : a.endsWith(r) && (m = a.substring(0, a.length - r.length)), m !== null && m.length > 0 && (/\uFE0F/.test(m) || loe(m)))
        return {
          text: m,
          replacePrevCharCnt: 0,
          replaceNextCharCnt: 0,
          positionDelta: 0
        };
    }
    if (l === u) {
      if (r === a && o === 0 && s === r.length && l === a.length && a.indexOf(`
`) === -1 && coe(a))
        return {
          text: "",
          replacePrevCharCnt: 0,
          replaceNextCharCnt: 0,
          positionDelta: 0
        };
      const m = f.length - g;
      return {
        text: a,
        replacePrevCharCnt: m,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    }
    const _ = s - o;
    return {
      text: a,
      replacePrevCharCnt: _,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
  }
  static deduceAndroidCompositionInput(e, t) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    if (e.value === t.value)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: t.selectionEnd - e.selectionEnd
      };
    const i = Math.min(uk(e.value, t.value), e.selectionEnd), r = Math.min(ck(e.value, t.value), e.value.length - e.selectionEnd), o = e.value.substring(i, e.value.length - r), s = t.value.substring(i, t.value.length - r);
    e.selectionStart - i;
    const a = e.selectionEnd - i;
    t.selectionStart - i;
    const l = t.selectionEnd - i;
    return {
      text: s,
      replacePrevCharCnt: a,
      replaceNextCharCnt: o.length - a,
      positionDelta: l - s.length
    };
  }
}
On.EMPTY = new On("", 0, 0, null, null);
class lp {
  static _getPageOfLine(e, t) {
    return Math.floor((e - 1) / t);
  }
  static _getRangeForPage(e, t) {
    const i = e * t, r = i + 1, o = i + t;
    return new G(r, 1, o + 1, 1);
  }
  static fromEditorSelection(e, t, i, r, o) {
    const s = lp._getPageOfLine(i.startLineNumber, r), a = lp._getRangeForPage(s, r), l = lp._getPageOfLine(i.endLineNumber, r), u = lp._getRangeForPage(l, r), c = a.intersectRanges(new G(1, 1, i.startLineNumber, i.startColumn));
    let h = t.getValueInRange(
      c,
      1
      /* LF */
    );
    const d = t.getLineCount(), f = t.getLineMaxColumn(d), p = u.intersectRanges(new G(i.endLineNumber, i.endColumn, d, f));
    let g = t.getValueInRange(
      p,
      1
      /* LF */
    ), _;
    if (s === l || s + 1 === l)
      _ = t.getValueInRange(
        i,
        1
        /* LF */
      );
    else {
      const m = a.intersectRanges(i), v = u.intersectRanges(i);
      _ = t.getValueInRange(
        m,
        1
        /* LF */
      ) + String.fromCharCode(8230) + t.getValueInRange(
        v,
        1
        /* LF */
      );
    }
    return o && (h.length > 500 && (h = h.substring(h.length - 500, h.length)), g.length > 500 && (g = g.substring(0, 500)), _.length > 2 * 500 && (_ = _.substring(0, 500) + String.fromCharCode(8230) + _.substring(_.length - 500, _.length))), new On(h + _ + g, h.length, h.length + _.length, new ie(i.startLineNumber, i.startColumn), new ie(i.endLineNumber, i.endColumn));
  }
}
var Gb;
(function(n) {
  n.Tap = "-monaco-textarea-synthetic-tap";
})(Gb || (Gb = {}));
const cce = {
  forceCopyWithSyntaxHighlighting: !1
};
class Ub {
  constructor() {
    this._lastState = null;
  }
  set(e, t) {
    this._lastState = { lastCopiedValue: e, data: t };
  }
  get(e) {
    return this._lastState && this._lastState.lastCopiedValue === e ? this._lastState.data : (this._lastState = null, null);
  }
}
Ub.INSTANCE = new Ub();
class hce extends Ce {
  constructor(e, t) {
    super(), this.textArea = t, this._onFocus = this._register(new q()), this.onFocus = this._onFocus.event, this._onBlur = this._register(new q()), this.onBlur = this._onBlur.event, this._onKeyDown = this._register(new q()), this.onKeyDown = this._onKeyDown.event, this._onKeyUp = this._register(new q()), this.onKeyUp = this._onKeyUp.event, this._onCut = this._register(new q()), this.onCut = this._onCut.event, this._onPaste = this._register(new q()), this.onPaste = this._onPaste.event, this._onType = this._register(new q()), this.onType = this._onType.event, this._onCompositionStart = this._register(new q()), this.onCompositionStart = this._onCompositionStart.event, this._onCompositionUpdate = this._register(new q()), this.onCompositionUpdate = this._onCompositionUpdate.event, this._onCompositionEnd = this._register(new q()), this.onCompositionEnd = this._onCompositionEnd.event, this._onSelectionChangeRequest = this._register(new q()), this.onSelectionChangeRequest = this._onSelectionChangeRequest.event, this._host = e, this._textArea = this._register(new dce(t)), this._asyncTriggerCut = this._register(new ro(() => this._onCut.fire(), 0)), this._asyncFocusGainWriteScreenReaderContent = this._register(new ro(() => this.writeScreenReaderContent("asyncFocusGain"), 0)), this._textAreaState = On.EMPTY, this._selectionChangeListener = null, this.writeScreenReaderContent("ctor"), this._hasFocus = !1, this._isDoingComposition = !1, this._nextCommand = 0;
    let i = null;
    this._register(io(t.domNode, "keydown", (a) => {
      (a.keyCode === 109 || this._isDoingComposition && a.keyCode === 1) && a.stopPropagation(), a.equals(
        9
        /* Escape */
      ) && a.preventDefault(), i = a, this._onKeyDown.fire(a);
    })), this._register(io(t.domNode, "keyup", (a) => {
      this._onKeyUp.fire(a);
    })), this._register(be(t.domNode, "compositionstart", (a) => {
      if (!this._isDoingComposition) {
        if (this._isDoingComposition = !0, kt && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === a.data && (i && i.equals(
          109
          /* KEY_IN_COMPOSITION */
        ) && (i.code === "ArrowRight" || i.code === "ArrowLeft") || to)) {
          this._textAreaState = new On(this._textAreaState.value, this._textAreaState.selectionStart - 1, this._textAreaState.selectionEnd, this._textAreaState.selectionStartPosition ? new ie(this._textAreaState.selectionStartPosition.lineNumber, this._textAreaState.selectionStartPosition.column - 1) : null, this._textAreaState.selectionEndPosition), this._onCompositionStart.fire({ revealDeltaColumns: -1 });
          return;
        }
        if (Xm) {
          this._onCompositionStart.fire({ revealDeltaColumns: -this._textAreaState.selectionStart });
          return;
        }
        this._setAndWriteTextAreaState("compositionstart", On.EMPTY), this._onCompositionStart.fire({ revealDeltaColumns: 0 });
      }
    }));
    const r = (a) => {
      const l = this._textAreaState, u = On.readFromTextArea(this._textArea);
      return [u, On.deduceInput(l, u, a)];
    }, o = () => {
      const a = this._textAreaState, l = On.readFromTextArea(this._textArea);
      return [l, On.deduceAndroidCompositionInput(a, l)];
    }, s = (a) => {
      const l = this._textAreaState, u = On.selectedText(a), c = {
        text: u.value,
        replacePrevCharCnt: l.selectionEnd - l.selectionStart,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
      return [u, c];
    };
    this._register(be(t.domNode, "compositionupdate", (a) => {
      if (Xm) {
        const [c, h] = o();
        this._textAreaState = c, this._onType.fire(h), this._onCompositionUpdate.fire(a);
        return;
      }
      const [l, u] = s(a.data || "");
      this._textAreaState = l, this._onType.fire(u), this._onCompositionUpdate.fire(a);
    })), this._register(be(t.domNode, "compositionend", (a) => {
      if (!this._isDoingComposition)
        return;
      if (this._isDoingComposition = !1, Xm) {
        const [c, h] = o();
        this._textAreaState = c, this._onType.fire(h), this._onCompositionEnd.fire();
        return;
      }
      const [l, u] = s(a.data || "");
      this._textAreaState = l, this._onType.fire(u), (db || to) && (this._textAreaState = On.readFromTextArea(this._textArea)), this._onCompositionEnd.fire();
    })), this._register(be(t.domNode, "input", () => {
      if (this._textArea.setIgnoreSelectionChangeTime("received input event"), this._isDoingComposition)
        return;
      const [a, l] = r(
        /*couldBeEmojiInput*/
        kt
      );
      l.replacePrevCharCnt === 0 && l.text.length === 1 && Kn(l.text.charCodeAt(0)) || (this._textAreaState = a, this._nextCommand === 0 ? (l.text !== "" || l.replacePrevCharCnt !== 0) && this._onType.fire(l) : ((l.text !== "" || l.replacePrevCharCnt !== 0) && this._firePaste(l.text, null), this._nextCommand = 0));
    })), this._register(be(t.domNode, "cut", (a) => {
      this._textArea.setIgnoreSelectionChangeTime("received cut event"), this._ensureClipboardGetsEditorSelection(a), this._asyncTriggerCut.schedule();
    })), this._register(be(t.domNode, "copy", (a) => {
      this._ensureClipboardGetsEditorSelection(a);
    })), this._register(be(t.domNode, "paste", (a) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received paste event"), Vm.canUseTextData(a)) {
        const [l, u] = Vm.getTextData(a);
        l !== "" && this._firePaste(l, u);
      } else
        this._textArea.getSelectionStart() !== this._textArea.getSelectionEnd() && this._setAndWriteTextAreaState("paste", On.EMPTY), this._nextCommand = 1;
    })), this._register(be(t.domNode, "focus", () => {
      const a = this._hasFocus;
      this._setHasFocus(!0), Vd && !a && this._hasFocus && this._asyncFocusGainWriteScreenReaderContent.schedule();
    })), this._register(be(t.domNode, "blur", () => {
      this._isDoingComposition && (this._isDoingComposition = !1, this.writeScreenReaderContent("blurWithoutCompositionEnd"), this._onCompositionEnd.fire()), this._setHasFocus(!1);
    })), this._register(be(t.domNode, Gb.Tap, () => {
      Xm && this._isDoingComposition && (this._isDoingComposition = !1, this.writeScreenReaderContent("tapWithoutCompositionEnd"), this._onCompositionEnd.fire());
    }));
  }
  _installSelectionChangeListener() {
    let e = 0;
    return be(document, "selectionchange", (t) => {
      if (!this._hasFocus || this._isDoingComposition || !db)
        return;
      const i = Date.now(), r = i - e;
      if (e = i, r < 5)
        return;
      const o = i - this._textArea.getIgnoreSelectionChangeTime();
      if (this._textArea.resetSelectionChangeTime(), o < 100 || !this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition)
        return;
      const s = this._textArea.getValue();
      if (this._textAreaState.value !== s)
        return;
      const a = this._textArea.getSelectionStart(), l = this._textArea.getSelectionEnd();
      if (this._textAreaState.selectionStart === a && this._textAreaState.selectionEnd === l)
        return;
      const u = this._textAreaState.deduceEditorPosition(a), c = this._host.deduceModelPosition(u[0], u[1], u[2]), h = this._textAreaState.deduceEditorPosition(l), d = this._host.deduceModelPosition(h[0], h[1], h[2]), f = new Ut(c.lineNumber, c.column, d.lineNumber, d.column);
      this._onSelectionChangeRequest.fire(f);
    });
  }
  dispose() {
    super.dispose(), this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null);
  }
  focusTextArea() {
    this._setHasFocus(!0), this.refreshFocusState();
  }
  isFocused() {
    return this._hasFocus;
  }
  refreshFocusState() {
    const e = U_(this.textArea.domNode);
    e ? this._setHasFocus(e.activeElement === this.textArea.domNode) : e5(this.textArea.domNode) ? this._setHasFocus(document.activeElement === this.textArea.domNode) : this._setHasFocus(!1);
  }
  _setHasFocus(e) {
    this._hasFocus !== e && (this._hasFocus = e, this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null), this._hasFocus && (this._selectionChangeListener = this._installSelectionChangeListener()), this._hasFocus && this.writeScreenReaderContent("focusgain"), this._hasFocus ? this._onFocus.fire() : this._onBlur.fire());
  }
  _setAndWriteTextAreaState(e, t) {
    this._hasFocus || (t = t.collapseSelection()), t.writeToTextArea(e, this._textArea, this._hasFocus), this._textAreaState = t;
  }
  writeScreenReaderContent(e) {
    this._isDoingComposition || this._setAndWriteTextAreaState(e, this._host.getScreenReaderContent(this._textAreaState));
  }
  _ensureClipboardGetsEditorSelection(e) {
    const t = this._host.getDataToCopy(Vm.canUseTextData(e)), i = {
      version: 1,
      isFromEmptySelection: t.isFromEmptySelection,
      multicursorText: t.multicursorText,
      mode: t.mode
    };
    if (Ub.INSTANCE.set(
      // When writing "LINE\r\n" to the clipboard and then pasting,
      // Firefox pastes "LINE\n", so let's work around this quirk
      to ? t.text.replace(/\r\n/g, `
`) : t.text,
      i
    ), !Vm.canUseTextData(e)) {
      this._setAndWriteTextAreaState("copy or cut", On.selectedText(t.text));
      return;
    }
    Vm.setTextData(e, t.text, t.html, i);
  }
  _firePaste(e, t) {
    t || (t = Ub.INSTANCE.get(e)), this._onPaste.fire({
      text: e,
      metadata: t
    });
  }
}
class Vm {
  static canUseTextData(e) {
    return !!(e.clipboardData || window.clipboardData);
  }
  static getTextData(e) {
    if (e.clipboardData) {
      e.preventDefault();
      const t = e.clipboardData.getData("text/plain");
      let i = null;
      const r = e.clipboardData.getData("vscode-editor-data");
      if (typeof r == "string")
        try {
          i = JSON.parse(r), i.version !== 1 && (i = null);
        } catch {
        }
      return [t, i];
    }
    if (window.clipboardData)
      return e.preventDefault(), [window.clipboardData.getData("Text"), null];
    throw new Error("ClipboardEventUtils.getTextData: Cannot use text data!");
  }
  static setTextData(e, t, i, r) {
    if (e.clipboardData) {
      e.clipboardData.setData("text/plain", t), typeof i == "string" && e.clipboardData.setData("text/html", i), e.clipboardData.setData("vscode-editor-data", JSON.stringify(r)), e.preventDefault();
      return;
    }
    if (window.clipboardData) {
      window.clipboardData.setData("Text", t), e.preventDefault();
      return;
    }
    throw new Error("ClipboardEventUtils.setTextData: Cannot use text data!");
  }
}
class dce extends Ce {
  constructor(e) {
    super(), this._actual = e, this._ignoreSelectionChangeTime = 0;
  }
  setIgnoreSelectionChangeTime(e) {
    this._ignoreSelectionChangeTime = Date.now();
  }
  getIgnoreSelectionChangeTime() {
    return this._ignoreSelectionChangeTime;
  }
  resetSelectionChangeTime() {
    this._ignoreSelectionChangeTime = 0;
  }
  getValue() {
    return this._actual.domNode.value;
  }
  setValue(e, t) {
    const i = this._actual.domNode;
    i.value !== t && (this.setIgnoreSelectionChangeTime("setValue"), i.value = t);
  }
  getSelectionStart() {
    return this._actual.domNode.selectionDirection === "backward" ? this._actual.domNode.selectionEnd : this._actual.domNode.selectionStart;
  }
  getSelectionEnd() {
    return this._actual.domNode.selectionDirection === "backward" ? this._actual.domNode.selectionStart : this._actual.domNode.selectionEnd;
  }
  setSelectionRange(e, t, i) {
    const r = this._actual.domNode;
    let o = null;
    const s = U_(r);
    s ? o = s.activeElement : o = document.activeElement;
    const a = o === r, l = r.selectionStart, u = r.selectionEnd;
    if (a && l === t && u === i) {
      to && window.parent !== window && r.focus();
      return;
    }
    if (a) {
      this.setIgnoreSelectionChangeTime("setSelectionRange"), r.setSelectionRange(t, i), to && window.parent !== window && r.focus();
      return;
    }
    try {
      const c = qre(r);
      this.setIgnoreSelectionChangeTime("setSelectionRange"), r.focus(), r.setSelectionRange(t, i), Yre(r, c);
    } catch {
    }
  }
}
class fce extends $d {
  constructor(e, t, i) {
    super(e, t, i), this._register(ri.addTarget(this.viewHelper.linesContentDomNode)), this._register(be(this.viewHelper.linesContentDomNode, Ri.Tap, (o) => this.onTap(o))), this._register(be(this.viewHelper.linesContentDomNode, Ri.Change, (o) => this.onChange(o))), this._register(be(this.viewHelper.linesContentDomNode, Ri.Contextmenu, (o) => this._onContextMenu(new jd(o, this.viewHelper.viewDomNode), !1))), this._lastPointerType = "mouse", this._register(be(this.viewHelper.linesContentDomNode, "pointerdown", (o) => {
      const s = o.pointerType;
      if (s === "mouse") {
        this._lastPointerType = "mouse";
        return;
      } else
        s === "touch" ? this._lastPointerType = "touch" : this._lastPointerType = "pen";
    }));
    const r = new Yle(this.viewHelper.viewDomNode);
    this._register(r.onPointerMoveThrottled(this.viewHelper.viewDomNode, (o) => this._onMouseMove(o), Hb(this.mouseTargetFactory), $d.MOUSE_MOVE_MINIMUM_TIME)), this._register(r.onPointerUp(this.viewHelper.viewDomNode, (o) => this._onMouseUp(o))), this._register(r.onPointerLeave(this.viewHelper.viewDomNode, (o) => this._onMouseLeave(o))), this._register(r.onPointerDown(this.viewHelper.viewDomNode, (o) => this._onMouseDown(o)));
  }
  onTap(e) {
    if (!e.initialTarget || !this.viewHelper.linesContentDomNode.contains(e.initialTarget))
      return;
    e.preventDefault(), this.viewHelper.focusTextArea();
    const t = this._createMouseTarget(new jd(e, this.viewHelper.viewDomNode), !1);
    t.position && this.viewController.dispatchMouse({
      position: t.position,
      mouseColumn: t.position.column,
      startedOnLineNumbers: !1,
      mouseDownCount: e.tapCount,
      inSelectionMode: !1,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      shiftKey: !1,
      leftButton: !1,
      middleButton: !1
    });
  }
  onChange(e) {
    this._lastPointerType === "touch" && this._context.model.deltaScrollNow(-e.translationX, -e.translationY);
  }
  _onMouseDown(e) {
    e.browserEvent.pointerType !== "touch" && super._onMouseDown(e);
  }
}
class pce extends $d {
  constructor(e, t, i) {
    super(e, t, i), this._register(ri.addTarget(this.viewHelper.linesContentDomNode)), this._register(be(this.viewHelper.linesContentDomNode, Ri.Tap, (r) => this.onTap(r))), this._register(be(this.viewHelper.linesContentDomNode, Ri.Change, (r) => this.onChange(r))), this._register(be(this.viewHelper.linesContentDomNode, Ri.Contextmenu, (r) => this._onContextMenu(new jd(r, this.viewHelper.viewDomNode), !1)));
  }
  onTap(e) {
    e.preventDefault(), this.viewHelper.focusTextArea();
    const t = this._createMouseTarget(new jd(e, this.viewHelper.viewDomNode), !1);
    if (t.position) {
      const i = document.createEvent("CustomEvent");
      i.initEvent(Gb.Tap, !1, !0), this.viewHelper.dispatchTextAreaEvent(i), this.viewController.moveTo(t.position);
    }
  }
  onChange(e) {
    this._context.model.deltaScrollNow(-e.translationX, -e.translationY);
  }
}
class gce extends Ce {
  constructor(e, t, i) {
    super(), Tg && tE.pointerEvents ? this.handler = this._register(new fce(e, t, i)) : window.TouchEvent ? this.handler = this._register(new pce(e, t, i)) : this.handler = this._register(new $d(e, t, i));
  }
  getTargetAtClientPoint(e, t) {
    return this.handler.getTargetAtClientPoint(e, t);
  }
}
class Fg extends X_ {
}
const H3 = {
  ColorContribution: "base.contributions.colors"
};
class mce {
  constructor() {
    this._onDidChangeSchema = new q(), this.onDidChangeSchema = this._onDidChangeSchema.event, this.colorSchema = { type: "object", properties: {} }, this.colorReferenceSchema = { type: "string", enum: [], enumDescriptions: [] }, this.colorsById = {};
  }
  registerColor(e, t, i, r = !1, o) {
    let s = { id: e, description: i, defaults: t, needsTransparency: r, deprecationMessage: o };
    this.colorsById[e] = s;
    let a = { type: "string", description: i, format: "color-hex", defaultSnippets: [{ body: "${1:#ff0000}" }] };
    return o && (a.deprecationMessage = o), this.colorSchema.properties[e] = a, this.colorReferenceSchema.enum.push(e), this.colorReferenceSchema.enumDescriptions.push(i), this._onDidChangeSchema.fire(), e;
  }
  resolveDefaultColor(e, t) {
    const i = this.colorsById[e];
    if (i && i.defaults) {
      const r = i.defaults[t.type];
      return Wc(r, t);
    }
  }
  getColorSchema() {
    return this.colorSchema;
  }
  toString() {
    let e = (t, i) => {
      let r = t.indexOf(".") === -1 ? 0 : 1, o = i.indexOf(".") === -1 ? 0 : 1;
      return r !== o ? r - o : t.localeCompare(i);
    };
    return Object.keys(this.colorsById).sort(e).map((t) => `- \`${t}\`: ${this.colorsById[t].description}`).join(`
`);
  }
}
const TE = new mce();
Jn.add(H3.ColorContribution, TE);
function ee(n, e, t, i, r) {
  return TE.registerColor(n, e, t, i, r);
}
const Sd = ee("foreground", { dark: "#CCCCCC", light: "#616161", hc: "#FFFFFF" }, b("foreground", "Overall foreground color. This color is only used if not overridden by a component.")), Kye = ee("errorForeground", { dark: "#F48771", light: "#A1260D", hc: "#F48771" }, b("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component.")), qye = ee("icon.foreground", { dark: "#C5C5C5", light: "#424242", hc: "#FFFFFF" }, b("iconForeground", "The default color for icons in the workbench.")), ng = ee("focusBorder", { dark: "#007FD4", light: "#0090F1", hc: "#F38518" }, b("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component.")), pr = ee("contrastBorder", { light: null, dark: null, hc: "#6FC3DF" }, b("contrastBorder", "An extra border around elements to separate them from others for greater contrast.")), Ms = ee("contrastActiveBorder", { light: null, dark: null, hc: ng }, b("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast.")), Yye = ee("textLink.foreground", { light: "#006AB1", dark: "#3794FF", hc: "#3794FF" }, b("textLinkForeground", "Foreground color for links in text.")), Xye = ee("textCodeBlock.background", { light: "#dcdcdc66", dark: "#0a0a0a66", hc: ne.black }, b("textCodeBlockBackground", "Background color for code blocks in text.")), zb = ee("widget.shadow", { dark: gr(ne.black, 0.36), light: gr(ne.black, 0.16), hc: null }, b("widgetShadow", "Shadow color of widgets such as find/replace inside the editor.")), vce = ee("input.background", { dark: "#3C3C3C", light: ne.white, hc: ne.black }, b("inputBoxBackground", "Input box background.")), _ce = ee("input.foreground", { dark: Sd, light: Sd, hc: Sd }, b("inputBoxForeground", "Input box foreground.")), Cce = ee("input.border", { dark: null, light: null, hc: pr }, b("inputBoxBorder", "Input box border.")), Zye = ee("inputOption.activeBorder", { dark: "#007ACC00", light: "#007ACC00", hc: pr }, b("inputBoxActiveOptionBorder", "Border color of activated options in input fields.")), Qye = ee("inputOption.activeBackground", { dark: gr(ng, 0.4), light: gr(ng, 0.2), hc: ne.transparent }, b("inputOption.activeBackground", "Background color of activated options in input fields.")), Jye = ee("inputOption.activeForeground", { dark: ne.white, light: ne.black, hc: null }, b("inputOption.activeForeground", "Foreground color of activated options in input fields.")), yce = ee("inputValidation.infoBackground", { dark: "#063B49", light: "#D6ECF2", hc: ne.black }, b("inputValidationInfoBackground", "Input validation background color for information severity.")), wce = ee("inputValidation.infoForeground", { dark: null, light: null, hc: null }, b("inputValidationInfoForeground", "Input validation foreground color for information severity.")), bce = ee("inputValidation.infoBorder", { dark: "#007acc", light: "#007acc", hc: pr }, b("inputValidationInfoBorder", "Input validation border color for information severity.")), Sce = ee("inputValidation.warningBackground", { dark: "#352A05", light: "#F6F5D2", hc: ne.black }, b("inputValidationWarningBackground", "Input validation background color for warning severity.")), Ece = ee("inputValidation.warningForeground", { dark: null, light: null, hc: null }, b("inputValidationWarningForeground", "Input validation foreground color for warning severity.")), Lce = ee("inputValidation.warningBorder", { dark: "#B89500", light: "#B89500", hc: pr }, b("inputValidationWarningBorder", "Input validation border color for warning severity.")), Dce = ee("inputValidation.errorBackground", { dark: "#5A1D1D", light: "#F2DEDE", hc: ne.black }, b("inputValidationErrorBackground", "Input validation background color for error severity.")), Rce = ee("inputValidation.errorForeground", { dark: null, light: null, hc: null }, b("inputValidationErrorForeground", "Input validation foreground color for error severity.")), Tce = ee("inputValidation.errorBorder", { dark: "#BE1100", light: "#BE1100", hc: pr }, b("inputValidationErrorBorder", "Input validation border color for error severity.")), WD = ee("dropdown.background", { dark: "#3C3C3C", light: ne.white, hc: ne.black }, b("dropdownBackground", "Dropdown background.")), W2 = ee("dropdown.foreground", { dark: "#F0F0F0", light: null, hc: ne.white }, b("dropdownForeground", "Dropdown foreground.")), Oce = ee("button.foreground", { dark: ne.white, light: ne.white, hc: ne.white }, b("buttonForeground", "Button foreground color.")), eO = ee("button.background", { dark: "#0E639C", light: "#007ACC", hc: null }, b("buttonBackground", "Button background color.")), xce = ee("button.hoverBackground", { dark: X3(eO, 0.2), light: Y3(eO, 0.2), hc: null }, b("buttonHoverBackground", "Button background color when hovering.")), G3 = ee("badge.background", { dark: "#4D4D4D", light: "#C4C4C4", hc: ne.black }, b("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count.")), U3 = ee("badge.foreground", { dark: ne.white, light: "#333", hc: ne.white }, b("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count.")), OE = ee("scrollbar.shadow", { dark: "#000000", light: "#DDDDDD", hc: null }, b("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled.")), fw = ee("scrollbarSlider.background", { dark: ne.fromHex("#797979").transparent(0.4), light: ne.fromHex("#646464").transparent(0.4), hc: gr(pr, 0.6) }, b("scrollbarSliderBackground", "Scrollbar slider background color.")), pw = ee("scrollbarSlider.hoverBackground", { dark: ne.fromHex("#646464").transparent(0.7), light: ne.fromHex("#646464").transparent(0.7), hc: gr(pr, 0.8) }, b("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering.")), gw = ee("scrollbarSlider.activeBackground", { dark: ne.fromHex("#BFBFBF").transparent(0.4), light: ne.fromHex("#000000").transparent(0.6), hc: pr }, b("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on.")), Nce = ee("progressBar.background", { dark: ne.fromHex("#0E70C0"), light: ne.fromHex("#0E70C0"), hc: pr }, b("progressBarBackground", "Background color of the progress bar that can show for long running operations.")), Ice = ee("editorError.background", { dark: null, light: null, hc: null }, b("editorError.background", "Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), mw = ee("editorError.foreground", { dark: "#F48771", light: "#E51400", hc: null }, b("editorError.foreground", "Foreground color of error squigglies in the editor.")), Pce = ee("editorError.border", { dark: null, light: null, hc: ne.fromHex("#E47777").transparent(0.8) }, b("errorBorder", "Border color of error boxes in the editor.")), Ace = ee("editorWarning.background", { dark: null, light: null, hc: null }, b("editorWarning.background", "Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), nh = ee("editorWarning.foreground", { dark: "#CCA700", light: "#BF8803", hc: null }, b("editorWarning.foreground", "Foreground color of warning squigglies in the editor.")), SI = ee("editorWarning.border", { dark: null, light: null, hc: ne.fromHex("#FFCC00").transparent(0.8) }, b("warningBorder", "Border color of warning boxes in the editor.")), Mce = ee("editorInfo.background", { dark: null, light: null, hc: null }, b("editorInfo.background", "Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), Ap = ee("editorInfo.foreground", { dark: "#75BEFF", light: "#75BEFF", hc: null }, b("editorInfo.foreground", "Foreground color of info squigglies in the editor.")), z3 = ee("editorInfo.border", { dark: null, light: null, hc: ne.fromHex("#75BEFF").transparent(0.8) }, b("infoBorder", "Border color of info boxes in the editor.")), Fce = ee("editorHint.foreground", { dark: ne.fromHex("#eeeeee").transparent(0.7), light: "#6c6c6c", hc: null }, b("editorHint.foreground", "Foreground color of hint squigglies in the editor.")), kce = ee("editorHint.border", { dark: null, light: null, hc: ne.fromHex("#eeeeee").transparent(0.8) }, b("hintBorder", "Border color of hint boxes in the editor.")), Xu = ee("editor.background", { light: "#fffffe", dark: "#1E1E1E", hc: ne.black }, b("editorBackground", "Editor background color.")), Z_ = ee("editor.foreground", { light: "#333333", dark: "#BBBBBB", hc: ne.white }, b("editorForeground", "Editor default foreground color.")), $l = ee("editorWidget.background", { dark: "#252526", light: "#F3F3F3", hc: "#0C141F" }, b("editorWidgetBackground", "Background color of editor widgets, such as find/replace.")), Zu = ee("editorWidget.foreground", { dark: Sd, light: Sd, hc: Sd }, b("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace.")), VD = ee("editorWidget.border", { dark: "#454545", light: "#C8C8C8", hc: pr }, b("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget.")), ewe = ee("editorWidget.resizeBorder", { light: null, dark: null, hc: null }, b("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget.")), V2 = ee("quickInput.background", { dark: $l, light: $l, hc: $l }, b("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette.")), Wce = ee("quickInput.foreground", { dark: Zu, light: Zu, hc: Zu }, b("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.")), Vce = ee("quickInputTitle.background", { dark: new ne(new Nt(255, 255, 255, 0.105)), light: new ne(new Nt(0, 0, 0, 0.06)), hc: "#000000" }, b("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette.")), Bce = ee("pickerGroup.foreground", { dark: "#3794FF", light: "#0066BF", hc: ne.white }, b("pickerGroupForeground", "Quick picker color for grouping labels.")), Hce = ee("pickerGroup.border", { dark: "#3F3F46", light: "#CCCEDB", hc: ne.white }, b("pickerGroupBorder", "Quick picker color for grouping borders.")), Gce = ee("keybindingLabel.background", { dark: new ne(new Nt(128, 128, 128, 0.17)), light: new ne(new Nt(221, 221, 221, 0.4)), hc: ne.transparent }, b("keybindingLabelBackground", "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.")), Uce = ee("keybindingLabel.foreground", { dark: ne.fromHex("#CCCCCC"), light: ne.fromHex("#555555"), hc: ne.white }, b("keybindingLabelForeground", "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.")), zce = ee("keybindingLabel.border", { dark: new ne(new Nt(51, 51, 51, 0.6)), light: new ne(new Nt(204, 204, 204, 0.4)), hc: new ne(new Nt(111, 195, 223)) }, b("keybindingLabelBorder", "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.")), jce = ee("keybindingLabel.bottomBorder", { dark: new ne(new Nt(68, 68, 68, 0.6)), light: new ne(new Nt(187, 187, 187, 0.4)), hc: new ne(new Nt(111, 195, 223)) }, b("keybindingLabelBottomBorder", "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.")), Mp = ee("editor.selectionBackground", { light: "#ADD6FF", dark: "#264F78", hc: "#f3f518" }, b("editorSelectionBackground", "Color of the editor selection.")), $ce = ee("editor.selectionForeground", { light: null, dark: null, hc: "#000000" }, b("editorSelectionForeground", "Color of the selected text for high contrast.")), EI = ee("editor.inactiveSelectionBackground", { light: gr(Mp, 0.5), dark: gr(Mp, 0.5), hc: gr(Mp, 0.5) }, b("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), !0), j3 = ee("editor.selectionHighlightBackground", { light: j2(Mp, Xu, 0.3, 0.6), dark: j2(Mp, Xu, 0.3, 0.6), hc: null }, b("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), !0), twe = ee("editor.selectionHighlightBorder", { light: null, dark: null, hc: Ms }, b("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection.")), iwe = ee("editor.findMatchBackground", { light: "#A8AC94", dark: "#515C6A", hc: null }, b("editorFindMatch", "Color of the current search match.")), B2 = ee("editor.findMatchHighlightBackground", { light: "#EA5C0055", dark: "#EA5C0055", hc: null }, b("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), !0), nwe = ee("editor.findRangeHighlightBackground", { dark: "#3a3d4166", light: "#b4b4b44d", hc: null }, b("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0), rwe = ee("editor.findMatchBorder", { light: null, dark: null, hc: Ms }, b("editorFindMatchBorder", "Border color of the current search match.")), owe = ee("editor.findMatchHighlightBorder", { light: null, dark: null, hc: Ms }, b("findMatchHighlightBorder", "Border color of the other search matches.")), swe = ee("editor.findRangeHighlightBorder", { dark: null, light: null, hc: gr(Ms, 0.4) }, b("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0), awe = ee("editor.hoverHighlightBackground", { light: "#ADD6FF26", dark: "#264f7840", hc: "#ADD6FF26" }, b("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), !0), H2 = ee("editorHoverWidget.background", { light: $l, dark: $l, hc: $l }, b("hoverBackground", "Background color of the editor hover.")), lwe = ee("editorHoverWidget.foreground", { light: Zu, dark: Zu, hc: Zu }, b("hoverForeground", "Foreground color of the editor hover.")), uwe = ee("editorHoverWidget.border", { light: VD, dark: VD, hc: VD }, b("hoverBorder", "Border color of the editor hover.")), cwe = ee("editorHoverWidget.statusBarBackground", { dark: X3(H2, 0.2), light: Y3(H2, 0.05), hc: $l }, b("statusBarBackground", "Background color of the editor hover status bar.")), hwe = ee("editorLink.activeForeground", { dark: "#4E94CE", light: ne.blue, hc: ne.cyan }, b("activeLinkForeground", "Color of active links.")), dwe = ee("editorInlayHint.foreground", { dark: $l, light: Zu, hc: $l }, b("editorInlayHintForeground", "Foreground color of inline hints")), fwe = ee("editorInlayHint.background", { dark: Zu, light: $l, hc: Zu }, b("editorInlayHintBackground", "Background color of inline hints")), pwe = ee("editorLightBulb.foreground", { dark: "#FFCC00", light: "#DDB100", hc: "#FFCC00" }, b("editorLightBulbForeground", "The color used for the lightbulb actions icon.")), gwe = ee("editorLightBulbAutoFix.foreground", { dark: "#75BEFF", light: "#007ACC", hc: "#75BEFF" }, b("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon.")), tO = new ne(new Nt(155, 185, 85, 0.2)), iO = new ne(new Nt(255, 0, 0, 0.2)), $3 = ee("diffEditor.insertedTextBackground", { dark: tO, light: tO, hc: null }, b("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0), K3 = ee("diffEditor.removedTextBackground", { dark: iO, light: iO, hc: null }, b("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), !0), Kce = ee("diffEditor.insertedTextBorder", { dark: null, light: null, hc: "#33ff2eff" }, b("diffEditorInsertedOutline", "Outline color for the text that got inserted.")), qce = ee("diffEditor.removedTextBorder", { dark: null, light: null, hc: "#FF008F" }, b("diffEditorRemovedOutline", "Outline color for text that got removed.")), Yce = ee("diffEditor.border", { dark: null, light: null, hc: pr }, b("diffEditorBorder", "Border color between the two text editors.")), Xce = ee("diffEditor.diagonalFill", { dark: "#cccccc33", light: "#22222233", hc: null }, b("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views.")), Zce = ee("list.focusBackground", { dark: null, light: null, hc: null }, b("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), Qce = ee("list.focusForeground", { dark: null, light: null, hc: null }, b("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), Jce = ee("list.focusOutline", { dark: ng, light: ng, hc: Ms }, b("listFocusOutline", "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), Ed = ee("list.activeSelectionBackground", { dark: "#094771", light: "#0060C0", hc: null }, b("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), rh = ee("list.activeSelectionForeground", { dark: ne.white, light: ne.white, hc: null }, b("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), ehe = ee("list.inactiveSelectionBackground", { dark: "#37373D", light: "#E4E6F1", hc: null }, b("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), the = ee("list.inactiveSelectionForeground", { dark: null, light: null, hc: null }, b("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), ihe = ee("list.inactiveFocusBackground", { dark: null, light: null, hc: null }, b("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), nhe = ee("list.inactiveFocusOutline", { dark: null, light: null, hc: null }, b("listInactiveFocusOutline", "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), rhe = ee("list.hoverBackground", { dark: "#2A2D2E", light: "#F0F0F0", hc: null }, b("listHoverBackground", "List/Tree background when hovering over items using the mouse.")), ohe = ee("list.hoverForeground", { dark: null, light: null, hc: null }, b("listHoverForeground", "List/Tree foreground when hovering over items using the mouse.")), she = ee("list.dropBackground", { dark: "#062F4A", light: "#D6EBFF", hc: null }, b("listDropBackground", "List/Tree drag and drop background when moving items around using the mouse.")), BD = ee("list.highlightForeground", { dark: "#18A3FF", light: "#0066BF", hc: ng }, b("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree.")), ahe = ee("list.focusHighlightForeground", { dark: BD, light: BD, hc: BD }, b("listFocusHighlightForeground", "List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree.")), lhe = ee("listFilterWidget.background", { light: "#efc1ad", dark: "#653723", hc: ne.black }, b("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees.")), uhe = ee("listFilterWidget.outline", { dark: ne.transparent, light: ne.transparent, hc: "#f38518" }, b("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees.")), che = ee("listFilterWidget.noMatchesOutline", { dark: "#BE1100", light: "#BE1100", hc: pr }, b("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches.")), hhe = ee("tree.indentGuidesStroke", { dark: "#585858", light: "#a9a9a9", hc: "#a9a9a9" }, b("treeIndentGuidesStroke", "Tree stroke color for the indentation guides.")), dhe = ee("tree.tableColumnsBorder", { dark: "#CCCCCC20", light: "#61616120", hc: null }, b("treeIndentGuidesStroke", "Tree stroke color for the indentation guides.")), G2 = ee("quickInput.list.focusBackground", { dark: null, light: null, hc: null }, "", void 0, b("quickInput.list.focusBackground deprecation", "Please use quickInputList.focusBackground instead")), fhe = ee("quickInputList.focusForeground", { dark: rh, light: rh, hc: rh }, b("quickInput.listFocusForeground", "Quick picker foreground color for the focused item.")), phe = ee("quickInputList.focusBackground", { dark: z2(G2, Ed, "#062F4A"), light: z2(G2, Ed, "#D6EBFF"), hc: null }, b("quickInput.listFocusBackground", "Quick picker background color for the focused item.")), ghe = ee("menu.border", { dark: null, light: null, hc: pr }, b("menuBorder", "Border color of menus.")), mhe = ee("menu.foreground", { dark: W2, light: Sd, hc: W2 }, b("menuForeground", "Foreground color of menu items.")), vhe = ee("menu.background", { dark: WD, light: WD, hc: WD }, b("menuBackground", "Background color of menu items.")), _he = ee("menu.selectionForeground", { dark: rh, light: rh, hc: rh }, b("menuSelectionForeground", "Foreground color of the selected menu item in menus.")), Che = ee("menu.selectionBackground", { dark: Ed, light: Ed, hc: Ed }, b("menuSelectionBackground", "Background color of the selected menu item in menus.")), yhe = ee("menu.selectionBorder", { dark: null, light: null, hc: Ms }, b("menuSelectionBorder", "Border color of the selected menu item in menus.")), whe = ee("menu.separatorBackground", { dark: "#BBBBBB", light: "#888888", hc: pr }, b("menuSeparatorBackground", "Color of a separator menu item in menus.")), mwe = ee("editor.snippetTabstopHighlightBackground", { dark: new ne(new Nt(124, 124, 124, 0.3)), light: new ne(new Nt(10, 50, 100, 0.2)), hc: new ne(new Nt(124, 124, 124, 0.3)) }, b("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop.")), vwe = ee("editor.snippetTabstopHighlightBorder", { dark: null, light: null, hc: null }, b("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop.")), _we = ee("editor.snippetFinalTabstopHighlightBackground", { dark: null, light: null, hc: null }, b("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet.")), Cwe = ee("editor.snippetFinalTabstopHighlightBorder", { dark: "#525252", light: new ne(new Nt(10, 50, 100, 0.5)), hc: "#525252" }, b("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet.")), ywe = ee("editorOverviewRuler.findMatchForeground", { dark: "#d186167e", light: "#d186167e", hc: "#AB5A00" }, b("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), !0), wwe = ee("editorOverviewRuler.selectionHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hc: "#A0A0A0CC" }, b("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), !0), bwe = ee("minimap.findMatchHighlight", { light: "#d18616", dark: "#d18616", hc: "#AB5A00" }, b("minimapFindMatchHighlight", "Minimap marker color for find matches."), !0), U2 = ee("minimap.selectionHighlight", { light: "#ADD6FF", dark: "#264F78", hc: "#ffffff" }, b("minimapSelectionHighlight", "Minimap marker color for the editor selection."), !0), bhe = ee("minimap.errorHighlight", { dark: new ne(new Nt(255, 18, 18, 0.7)), light: new ne(new Nt(255, 18, 18, 0.7)), hc: new ne(new Nt(255, 50, 50, 1)) }, b("minimapError", "Minimap marker color for errors.")), She = ee("minimap.warningHighlight", { dark: nh, light: nh, hc: SI }, b("overviewRuleWarning", "Minimap marker color for warnings.")), q3 = ee("minimap.background", { dark: null, light: null, hc: null }, b("minimapBackground", "Minimap background color.")), Ehe = ee("minimapSlider.background", { light: gr(fw, 0.5), dark: gr(fw, 0.5), hc: gr(fw, 0.5) }, b("minimapSliderBackground", "Minimap slider background color.")), Lhe = ee("minimapSlider.hoverBackground", { light: gr(pw, 0.5), dark: gr(pw, 0.5), hc: gr(pw, 0.5) }, b("minimapSliderHoverBackground", "Minimap slider background color when hovering.")), Dhe = ee("minimapSlider.activeBackground", { light: gr(gw, 0.5), dark: gr(gw, 0.5), hc: gr(gw, 0.5) }, b("minimapSliderActiveBackground", "Minimap slider background color when clicked on.")), Swe = ee("problemsErrorIcon.foreground", { dark: mw, light: mw, hc: mw }, b("problemsErrorIconForeground", "The color used for the problems error icon.")), Ewe = ee("problemsWarningIcon.foreground", { dark: nh, light: nh, hc: nh }, b("problemsWarningIconForeground", "The color used for the problems warning icon.")), Lwe = ee("problemsInfoIcon.foreground", { dark: Ap, light: Ap, hc: Ap }, b("problemsInfoIconForeground", "The color used for the problems info icon."));
function Rhe(n, e) {
  var t, i, r;
  switch (n.op) {
    case 0:
      return (t = Wc(n.value, e)) === null || t === void 0 ? void 0 : t.darken(n.factor);
    case 1:
      return (i = Wc(n.value, e)) === null || i === void 0 ? void 0 : i.lighten(n.factor);
    case 2:
      return (r = Wc(n.value, e)) === null || r === void 0 ? void 0 : r.transparent(n.factor);
    case 3:
      for (const a of n.values) {
        const l = Wc(a, e);
        if (l)
          return l;
      }
      return;
    case 4:
      const o = Wc(n.value, e);
      if (!o)
        return;
      const s = Wc(n.background, e);
      return s ? o.isDarkerThan(s) ? ne.getLighterColor(o, s, n.factor).transparent(n.transparency) : ne.getDarkerColor(o, s, n.factor).transparent(n.transparency) : o.transparent(n.factor * n.transparency);
    default:
      throw Moe();
  }
}
function Y3(n, e) {
  return { op: 0, value: n, factor: e };
}
function X3(n, e) {
  return { op: 1, value: n, factor: e };
}
function gr(n, e) {
  return { op: 2, value: n, factor: e };
}
function z2(...n) {
  return { op: 3, values: n };
}
function j2(n, e, t, i) {
  return { op: 4, value: n, background: e, factor: t, transparency: i };
}
function Wc(n, e) {
  if (n !== null) {
    if (typeof n == "string")
      return n[0] === "#" ? ne.fromHex(n) : e.getColor(n);
    if (n instanceof ne)
      return n;
    if (typeof n == "object")
      return Rhe(n, e);
  }
}
const Z3 = "vscode://schemas/workbench-colors";
let Q3 = Jn.as(dE.JSONContribution);
Q3.registerSchema(Z3, TE.getColorSchema());
const $2 = new ro(() => Q3.notifySchemaChanged(Z3), 200);
TE.onDidChangeSchema(() => {
  $2.isScheduled() || $2.schedule();
});
const The = ee("editor.lineHighlightBackground", { dark: null, light: null, hc: null }, b("lineHighlight", "Background color for the highlight of line at the cursor position.")), K2 = ee("editor.lineHighlightBorder", { dark: "#282828", light: "#eeeeee", hc: "#f38518" }, b("lineHighlightBorderBox", "Background color for the border around the line at the cursor position.")), Ohe = ee("editor.rangeHighlightBackground", { dark: "#ffffff0b", light: "#fdff0033", hc: null }, b("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), !0), xhe = ee("editor.rangeHighlightBorder", { dark: null, light: null, hc: Ms }, b("rangeHighlightBorder", "Background color of the border around highlighted ranges."), !0), Nhe = ee("editor.symbolHighlightBackground", { dark: B2, light: B2, hc: null }, b("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), !0), Ihe = ee("editor.symbolHighlightBorder", { dark: null, light: null, hc: Ms }, b("symbolHighlightBorder", "Background color of the border around highlighted symbols."), !0), J3 = ee("editorCursor.foreground", { dark: "#AEAFAD", light: ne.black, hc: ne.white }, b("caret", "Color of the editor cursor.")), Phe = ee("editorCursor.background", null, b("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.")), Ld = ee("editorWhitespace.foreground", { dark: "#e3e4e229", light: "#33333333", hc: "#e3e4e229" }, b("editorWhitespaces", "Color of whitespace characters in the editor.")), xE = ee("editorIndentGuide.background", { dark: Ld, light: Ld, hc: Ld }, b("editorIndentGuides", "Color of the editor indentation guides.")), NE = ee("editorIndentGuide.activeBackground", { dark: Ld, light: Ld, hc: Ld }, b("editorActiveIndentGuide", "Color of the active editor indentation guides.")), e7 = ee("editorLineNumber.foreground", { dark: "#858585", light: "#237893", hc: ne.white }, b("editorLineNumbers", "Color of editor line numbers.")), HD = ee("editorActiveLineNumber.foreground", { dark: "#c6c6c6", light: "#0B216F", hc: Ms }, b("editorActiveLineNumber", "Color of editor active line number"), !1, b("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead.")), Ahe = ee("editorLineNumber.activeForeground", { dark: HD, light: HD, hc: HD }, b("editorActiveLineNumber", "Color of editor active line number")), Mhe = ee("editorRuler.foreground", { dark: "#5A5A5A", light: ne.lightgrey, hc: ne.white }, b("editorRuler", "Color of the editor rulers.")), Dwe = ee("editorCodeLens.foreground", { dark: "#999999", light: "#999999", hc: "#999999" }, b("editorCodeLensForeground", "Foreground color of editor CodeLens")), Rwe = ee("editorBracketMatch.background", { dark: "#0064001a", light: "#0064001a", hc: "#0064001a" }, b("editorBracketMatchBackground", "Background color behind matching brackets")), Twe = ee("editorBracketMatch.border", { dark: "#888", light: "#B9B9B9", hc: pr }, b("editorBracketMatchBorder", "Color for matching brackets boxes")), Fhe = ee("editorOverviewRuler.border", { dark: "#7f7f7f4d", light: "#7f7f7f4d", hc: "#7f7f7f4d" }, b("editorOverviewRulerBorder", "Color of the overview ruler border.")), khe = ee("editorOverviewRuler.background", null, b("editorOverviewRulerBackground", "Background color of the editor overview ruler. Only used when the minimap is enabled and placed on the right side of the editor.")), Whe = ee("editorGutter.background", { dark: Xu, light: Xu, hc: Xu }, b("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.")), Vhe = ee("editorUnnecessaryCode.border", { dark: null, light: null, hc: ne.fromHex("#fff").transparent(0.8) }, b("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor.")), Bhe = ee("editorUnnecessaryCode.opacity", { dark: ne.fromHex("#000a"), light: ne.fromHex("#0007"), hc: null }, b("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`)), Owe = ee("editorGhostText.border", { dark: null, light: null, hc: ne.fromHex("#fff").transparent(0.8) }, b("editorGhostTextBorder", "Border color of ghost text in the editor.")), xwe = ee("editorGhostText.foreground", { dark: ne.fromHex("#ffffff56"), light: ne.fromHex("#0007"), hc: null }, b("editorGhostTextForeground", "Foreground color of the ghost text in the editor.")), GD = new ne(new Nt(0, 122, 204, 0.6)), Nwe = ee("editorOverviewRuler.rangeHighlightForeground", { dark: GD, light: GD, hc: GD }, b("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), !0), Hhe = ee("editorOverviewRuler.errorForeground", { dark: new ne(new Nt(255, 18, 18, 0.7)), light: new ne(new Nt(255, 18, 18, 0.7)), hc: new ne(new Nt(255, 50, 50, 1)) }, b("overviewRuleError", "Overview ruler marker color for errors.")), Ghe = ee("editorOverviewRuler.warningForeground", { dark: nh, light: nh, hc: SI }, b("overviewRuleWarning", "Overview ruler marker color for warnings.")), Uhe = ee("editorOverviewRuler.infoForeground", { dark: Ap, light: Ap, hc: z3 }, b("overviewRuleInfo", "Overview ruler marker color for infos."));
wa((n, e) => {
  const t = n.getColor(Xu);
  t && e.addRule(`.monaco-editor, .monaco-editor-background, .monaco-editor .inputarea.ime-input { background-color: ${t}; }`);
  const i = n.getColor(Z_);
  i && e.addRule(`.monaco-editor, .monaco-editor .inputarea.ime-input { color: ${i}; }`);
  const r = n.getColor(Whe);
  r && e.addRule(`.monaco-editor .margin { background-color: ${r}; }`);
  const o = n.getColor(Ohe);
  o && e.addRule(`.monaco-editor .rangeHighlight { background-color: ${o}; }`);
  const s = n.getColor(xhe);
  s && e.addRule(`.monaco-editor .rangeHighlight { border: 1px ${n.type === "hc" ? "dotted" : "solid"} ${s}; }`);
  const a = n.getColor(Nhe);
  a && e.addRule(`.monaco-editor .symbolHighlight { background-color: ${a}; }`);
  const l = n.getColor(Ihe);
  l && e.addRule(`.monaco-editor .symbolHighlight { border: 1px ${n.type === "hc" ? "dotted" : "solid"} ${l}; }`);
  const u = n.getColor(Ld);
  u && (e.addRule(`.monaco-editor .mtkw { color: ${u} !important; }`), e.addRule(`.monaco-editor .mtkz { color: ${u} !important; }`));
});
class rg extends Fg {
  constructor(e) {
    super(), this._context = e, this._readConfig(), this._lastCursorModelPosition = new ie(1, 1), this._renderResult = null, this._activeLineNumber = 1, this._context.addEventHandler(this);
  }
  _readConfig() {
    const e = this._context.configuration.options;
    this._lineHeight = e.get(
      56
      /* lineHeight */
    );
    const t = e.get(
      57
      /* lineNumbers */
    );
    this._renderLineNumbers = t.renderType, this._renderCustomLineNumbers = t.renderFn, this._renderFinalNewline = e.get(
      82
      /* renderFinalNewline */
    );
    const i = e.get(
      128
      /* layoutInfo */
    );
    this._lineNumbersLeft = i.lineNumbersLeft, this._lineNumbersWidth = i.lineNumbersWidth;
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return this._readConfig(), !0;
  }
  onCursorStateChanged(e) {
    const t = e.selections[0].getPosition();
    this._lastCursorModelPosition = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(t);
    let i = !1;
    return this._activeLineNumber !== t.lineNumber && (this._activeLineNumber = t.lineNumber, i = !0), (this._renderLineNumbers === 2 || this._renderLineNumbers === 3) && (i = !0), i;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getLineRenderLineNumber(e) {
    const t = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new ie(e, 1));
    if (t.column !== 1)
      return "";
    const i = t.lineNumber;
    if (this._renderCustomLineNumbers)
      return this._renderCustomLineNumbers(i);
    if (this._renderLineNumbers === 2) {
      const r = Math.abs(this._lastCursorModelPosition.lineNumber - i);
      return r === 0 ? '<span class="relative-current-line-number">' + i + "</span>" : String(r);
    }
    return this._renderLineNumbers === 3 ? this._lastCursorModelPosition.lineNumber === i || i % 10 === 0 ? String(i) : "" : String(i);
  }
  prepareRender(e) {
    if (this._renderLineNumbers === 0) {
      this._renderResult = null;
      return;
    }
    const t = Is ? this._lineHeight % 2 === 0 ? " lh-even" : " lh-odd" : "", i = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber, o = '<div class="' + rg.CLASS_NAME + t + '" style="left:' + this._lineNumbersLeft + "px;width:" + this._lineNumbersWidth + 'px;">', s = this._context.model.getLineCount(), a = [];
    for (let l = i; l <= r; l++) {
      const u = l - i;
      if (!this._renderFinalNewline && l === s && this._context.model.getLineLength(l) === 0) {
        a[u] = "";
        continue;
      }
      const c = this._getLineRenderLineNumber(l);
      c ? l === this._activeLineNumber ? a[u] = '<div class="active-line-number ' + rg.CLASS_NAME + t + '" style="left:' + this._lineNumbersLeft + "px;width:" + this._lineNumbersWidth + 'px;">' + c + "</div>" : a[u] = o + c + "</div>" : a[u] = "";
    }
    this._renderResult = a;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
rg.CLASS_NAME = "line-numbers";
wa((n, e) => {
  const t = n.getColor(e7);
  t && e.addRule(`.monaco-editor .line-numbers { color: ${t}; }`);
  const i = n.getColor(Ahe);
  i && e.addRule(`.monaco-editor .line-numbers.active-line-number { color: ${i}; }`);
});
class Kd extends Fs {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    this._canUseLayerHinting = !t.get(
      26
      /* disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._domNode = St(document.createElement("div")), this._domNode.setClassName(Kd.OUTER_CLASS_NAME), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._glyphMarginBackgroundDomNode = St(document.createElement("div")), this._glyphMarginBackgroundDomNode.setClassName(Kd.CLASS_NAME), this._domNode.appendChild(this._glyphMarginBackgroundDomNode);
  }
  dispose() {
    super.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    return this._canUseLayerHinting = !t.get(
      26
      /* disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollTopChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setLayerHinting(this._canUseLayerHinting), this._domNode.setContain("strict");
    const t = e.scrollTop - e.bigNumbersDelta;
    this._domNode.setTop(-t);
    const i = Math.min(e.scrollHeight, 1e6);
    this._domNode.setHeight(i), this._domNode.setWidth(this._contentLeft), this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft), this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth), this._glyphMarginBackgroundDomNode.setHeight(i);
  }
}
Kd.CLASS_NAME = "glyph-margin";
Kd.OUTER_CLASS_NAME = "margin";
const Dd = "monaco-mouse-cursor-text";
class LI {
  constructor(e, t, i) {
    this.top = e, this.left = t, this.width = i;
  }
  setWidth(e) {
    return new LI(this.top, this.left, e);
  }
}
const Bm = to;
class zhe extends Fs {
  constructor(e, t, i) {
    super(e), this._primaryCursorPosition = new ie(1, 1), this._primaryCursorVisibleRange = null, this._viewController = t, this._viewHelper = i, this._scrollLeft = 0, this._scrollTop = 0;
    const r = this._context.configuration.options, o = r.get(
      128
      /* layoutInfo */
    );
    this._setAccessibilityOptions(r), this._contentLeft = o.contentLeft, this._contentWidth = o.contentWidth, this._contentHeight = o.height, this._fontInfo = r.get(
      40
      /* fontInfo */
    ), this._lineHeight = r.get(
      56
      /* lineHeight */
    ), this._emptySelectionClipboard = r.get(
      30
      /* emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = r.get(
      19
      /* copyWithSyntaxHighlighting */
    ), this._visibleTextArea = null, this._selections = [new Ut(1, 1, 1, 1)], this._modelSelections = [new Ut(1, 1, 1, 1)], this._lastRenderPosition = null, this.textArea = St(document.createElement("textarea")), Ql.write(
      this.textArea,
      6
      /* TextArea */
    ), this.textArea.setClassName(`inputarea ${Dd}`), this.textArea.setAttribute("wrap", "off"), this.textArea.setAttribute("autocorrect", "off"), this.textArea.setAttribute("autocapitalize", "off"), this.textArea.setAttribute("autocomplete", "off"), this.textArea.setAttribute("spellcheck", "false"), this.textArea.setAttribute("aria-label", this._getAriaLabel(r)), this.textArea.setAttribute("tabindex", String(r.get(
      110
      /* tabIndex */
    ))), this.textArea.setAttribute("role", "textbox"), this.textArea.setAttribute("aria-roledescription", b("editor", "editor")), this.textArea.setAttribute("aria-multiline", "true"), this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), r.get(
      28
      /* domReadOnly */
    ) && r.get(
      78
      /* readOnly */
    ) && this.textArea.setAttribute("readonly", "true"), this.textAreaCover = St(document.createElement("div")), this.textAreaCover.setPosition("absolute");
    const s = {
      getLineCount: () => this._context.model.getLineCount(),
      getLineMaxColumn: (l) => this._context.model.getLineMaxColumn(l),
      getValueInRange: (l, u) => this._context.model.getValueInRange(l, u)
    }, a = {
      getDataToCopy: (l) => {
        const u = this._context.model.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, Ro), c = this._context.model.getEOL(), h = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty(), d = Array.isArray(u) ? u : null, f = Array.isArray(u) ? u.join(c) : u;
        let p, g = null;
        if (l && (cce.forceCopyWithSyntaxHighlighting || this._copyWithSyntaxHighlighting && f.length < 65536)) {
          const _ = this._context.model.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);
          _ && (p = _.html, g = _.mode);
        }
        return {
          isFromEmptySelection: h,
          multicursorText: d,
          text: f,
          html: p,
          mode: g
        };
      },
      getScreenReaderContent: (l) => {
        if (this._accessibilitySupport === 1) {
          if (kt) {
            const u = this._selections[0];
            if (u.isEmpty()) {
              const c = u.getStartPosition();
              let h = this._getWordBeforePosition(c);
              if (h.length === 0 && (h = this._getCharacterBeforePosition(c)), h.length > 0)
                return new On(h, h.length, h.length, c, c);
            }
          }
          return On.EMPTY;
        }
        if (Xm) {
          const u = this._selections[0];
          if (u.isEmpty()) {
            const c = u.getStartPosition(), [h, d] = this._getAndroidWordAtPosition(c);
            if (h.length > 0)
              return new On(h, d, d, c, c);
          }
          return On.EMPTY;
        }
        return lp.fromEditorSelection(
          l,
          s,
          this._selections[0],
          this._accessibilityPageSize,
          this._accessibilitySupport === 0
          /* Unknown */
        );
      },
      deduceModelPosition: (l, u, c) => this._context.model.deduceModelPositionRelativeToViewPosition(l, u, c)
    };
    this._textAreaInput = this._register(new hce(a, this.textArea)), this._register(this._textAreaInput.onKeyDown((l) => {
      this._viewController.emitKeyDown(l);
    })), this._register(this._textAreaInput.onKeyUp((l) => {
      this._viewController.emitKeyUp(l);
    })), this._register(this._textAreaInput.onPaste((l) => {
      let u = !1, c = null, h = null;
      l.metadata && (u = this._emptySelectionClipboard && !!l.metadata.isFromEmptySelection, c = typeof l.metadata.multicursorText < "u" ? l.metadata.multicursorText : null, h = l.metadata.mode), this._viewController.paste(l.text, u, c, h);
    })), this._register(this._textAreaInput.onCut(() => {
      this._viewController.cut();
    })), this._register(this._textAreaInput.onType((l) => {
      l.replacePrevCharCnt || l.replaceNextCharCnt || l.positionDelta ? this._viewController.compositionType(l.text, l.replacePrevCharCnt, l.replaceNextCharCnt, l.positionDelta) : this._viewController.type(l.text);
    })), this._register(this._textAreaInput.onSelectionChangeRequest((l) => {
      this._viewController.setSelection(l);
    })), this._register(this._textAreaInput.onCompositionStart((l) => {
      const u = this._selections[0].startLineNumber, c = this._selections[0].startColumn + l.revealDeltaColumns;
      this._context.model.revealRange(
        "keyboard",
        !0,
        new G(u, c, u, c),
        0,
        1
        /* Immediate */
      );
      const h = this._viewHelper.visibleRangeForPositionRelativeToEditor(u, c);
      h && (this._visibleTextArea = new LI(this._context.viewLayout.getVerticalOffsetForLineNumber(u), h.left, Bm ? 0 : 1), this._render()), this.textArea.setClassName(`inputarea ${Dd} ime-input`), this._viewController.compositionStart(), this._context.model.onCompositionStart();
    })), this._register(this._textAreaInput.onCompositionUpdate((l) => {
      this._visibleTextArea && (this._visibleTextArea = this._visibleTextArea.setWidth(jhe(l.data, this._fontInfo)), this._render());
    })), this._register(this._textAreaInput.onCompositionEnd(() => {
      this._visibleTextArea = null, this._render(), this.textArea.setClassName(`inputarea ${Dd}`), this._viewController.compositionEnd(), this._context.model.onCompositionEnd();
    })), this._register(this._textAreaInput.onFocus(() => {
      this._context.model.setHasFocus(!0);
    })), this._register(this._textAreaInput.onBlur(() => {
      this._context.model.setHasFocus(!1);
    }));
  }
  dispose() {
    super.dispose();
  }
  _getAndroidWordAtPosition(e) {
    const t = '`~!@#$%^&*()-=+[{]}\\|;:",.<>/?', i = this._context.model.getLineContent(e.lineNumber), r = tg(t);
    let o = !0, s = e.column, a = !0, l = e.column, u = 0;
    for (; u < 50 && (o || a); ) {
      if (o && s <= 1 && (o = !1), o) {
        const c = i.charCodeAt(s - 2);
        r.get(c) !== 0 ? o = !1 : s--;
      }
      if (a && l > i.length && (a = !1), a) {
        const c = i.charCodeAt(l - 1);
        r.get(c) !== 0 ? a = !1 : l++;
      }
      u++;
    }
    return [i.substring(s - 1, l - 1), e.column - s];
  }
  _getWordBeforePosition(e) {
    const t = this._context.model.getLineContent(e.lineNumber), i = tg(this._context.configuration.options.get(
      114
      /* wordSeparators */
    ));
    let r = e.column, o = 0;
    for (; r > 1; ) {
      const s = t.charCodeAt(r - 2);
      if (i.get(s) !== 0 || o > 50)
        return t.substring(r - 1, e.column - 1);
      o++, r--;
    }
    return t.substring(0, e.column - 1);
  }
  _getCharacterBeforePosition(e) {
    if (e.column > 1) {
      const i = this._context.model.getLineContent(e.lineNumber).charAt(e.column - 2);
      if (!Kn(i.charCodeAt(0)))
        return i;
    }
    return "";
  }
  _getAriaLabel(e) {
    return e.get(
      2
      /* accessibilitySupport */
    ) === 1 ? b("accessibilityOffAriaLabel", "The editor is not accessible at this time. Press {0} for options.", Is ? "Shift+Alt+F1" : "Alt+F1") : e.get(
      4
      /* ariaLabel */
    );
  }
  _setAccessibilityOptions(e) {
    this._accessibilitySupport = e.get(
      2
      /* accessibilitySupport */
    );
    const t = e.get(
      3
      /* accessibilityPageSize */
    );
    this._accessibilitySupport === 2 && t === sf.accessibilityPageSize.defaultValue ? this._accessibilityPageSize = 500 : this._accessibilityPageSize = t;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    return this._setAccessibilityOptions(t), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._contentHeight = i.height, this._fontInfo = t.get(
      40
      /* fontInfo */
    ), this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._emptySelectionClipboard = t.get(
      30
      /* emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = t.get(
      19
      /* copyWithSyntaxHighlighting */
    ), this.textArea.setAttribute("aria-label", this._getAriaLabel(t)), this.textArea.setAttribute("tabindex", String(t.get(
      110
      /* tabIndex */
    ))), (e.hasChanged(
      28
      /* domReadOnly */
    ) || e.hasChanged(
      78
      /* readOnly */
    )) && (t.get(
      28
      /* domReadOnly */
    ) && t.get(
      78
      /* readOnly */
    ) ? this.textArea.setAttribute("readonly", "true") : this.textArea.removeAttribute("readonly")), e.hasChanged(
      2
      /* accessibilitySupport */
    ) && this._textAreaInput.writeScreenReaderContent("strategy changed"), !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), this._modelSelections = e.modelSelections.slice(0), this._textAreaInput.writeScreenReaderContent("selection changed"), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return this._scrollLeft = e.scrollLeft, this._scrollTop = e.scrollTop, !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // --- begin view API
  isFocused() {
    return this._textAreaInput.isFocused();
  }
  focusTextArea() {
    this._textAreaInput.focusTextArea();
  }
  getLastRenderData() {
    return this._lastRenderPosition;
  }
  setAriaOptions(e) {
    e.activeDescendant ? (this.textArea.setAttribute("aria-haspopup", "true"), this.textArea.setAttribute("aria-autocomplete", "list"), this.textArea.setAttribute("aria-activedescendant", e.activeDescendant)) : (this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), this.textArea.removeAttribute("aria-activedescendant")), e.role && this.textArea.setAttribute("role", e.role);
  }
  prepareRender(e) {
    this._primaryCursorPosition = new ie(this._selections[0].positionLineNumber, this._selections[0].positionColumn), this._primaryCursorVisibleRange = e.visibleRangeForPosition(this._primaryCursorPosition);
  }
  render(e) {
    this._textAreaInput.writeScreenReaderContent("render"), this._render();
  }
  _render() {
    if (this._visibleTextArea) {
      this._renderInsideEditor(null, this._visibleTextArea.top - this._scrollTop, this._contentLeft + this._visibleTextArea.left - this._scrollLeft, this._visibleTextArea.width, this._lineHeight);
      return;
    }
    if (!this._primaryCursorVisibleRange) {
      this._renderAtTopLeft();
      return;
    }
    const e = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
    if (e < this._contentLeft || e > this._contentLeft + this._contentWidth) {
      this._renderAtTopLeft();
      return;
    }
    const t = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;
    if (t < 0 || t > this._contentHeight) {
      this._renderAtTopLeft();
      return;
    }
    if (kt) {
      this._renderInsideEditor(this._primaryCursorPosition, t, e, Bm ? 0 : 1, this._lineHeight);
      return;
    }
    this._renderInsideEditor(this._primaryCursorPosition, t, e, Bm ? 0 : 1, Bm ? 0 : 1);
  }
  _renderInsideEditor(e, t, i, r, o) {
    this._lastRenderPosition = e;
    const s = this.textArea, a = this.textAreaCover;
    oo.applyFontInfo(s, this._fontInfo), s.setTop(t), s.setLeft(i), s.setWidth(r), s.setHeight(o), a.setTop(0), a.setLeft(0), a.setWidth(0), a.setHeight(0);
  }
  _renderAtTopLeft() {
    this._lastRenderPosition = null;
    const e = this.textArea, t = this.textAreaCover;
    if (oo.applyFontInfo(e, this._fontInfo), e.setTop(0), e.setLeft(0), t.setTop(0), t.setLeft(0), Bm) {
      e.setWidth(0), e.setHeight(0), t.setWidth(0), t.setHeight(0);
      return;
    }
    e.setWidth(1), e.setHeight(1), t.setWidth(1), t.setHeight(1);
    const i = this._context.configuration.options;
    i.get(
      46
      /* glyphMargin */
    ) ? t.setClassName("monaco-editor-background textAreaCover " + Kd.OUTER_CLASS_NAME) : i.get(
      57
      /* lineNumbers */
    ).renderType !== 0 ? t.setClassName("monaco-editor-background textAreaCover " + rg.CLASS_NAME) : t.setClassName("monaco-editor-background textAreaCover");
  }
}
function jhe(n, e) {
  const i = document.createElement("canvas").getContext("2d");
  i.font = $he(e);
  const r = i.measureText(n);
  return to ? r.width + 2 : r.width;
}
function $he(n) {
  return Khe("normal", n.fontWeight, n.fontSize, n.lineHeight, n.fontFamily);
}
function Khe(n, e, t, i, r) {
  return `${n} normal ${e} ${t}px / ${i}px ${r}`;
}
class id {
  static columnSelect(e, t, i, r, o, s) {
    let a = Math.abs(o - i) + 1, l = i > o, u = r > s, c = r < s, h = [];
    for (let d = 0; d < a; d++) {
      let f = i + (l ? -d : d), p = Kt.columnFromVisibleColumn2(e, t, f, r), g = Kt.columnFromVisibleColumn2(e, t, f, s), _ = Kt.visibleColumnFromColumn2(e, t, new ie(f, p)), m = Kt.visibleColumnFromColumn2(e, t, new ie(f, g));
      c && (_ > s || m < r) || u && (m > r || _ < s) || h.push(new qn(new G(f, p, f, p), 0, new ie(f, g), 0));
    }
    if (h.length === 0)
      for (let d = 0; d < a; d++) {
        const f = i + (l ? -d : d), p = t.getLineMaxColumn(f);
        h.push(new qn(new G(f, p, f, p), 0, new ie(f, p), 0));
      }
    return {
      viewStates: h,
      reversed: l,
      fromLineNumber: i,
      fromVisualColumn: r,
      toLineNumber: o,
      toVisualColumn: s
    };
  }
  static columnSelectLeft(e, t, i) {
    let r = i.toViewVisualColumn;
    return r > 0 && r--, id.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, r);
  }
  static columnSelectRight(e, t, i) {
    let r = 0;
    const o = Math.min(i.fromViewLineNumber, i.toViewLineNumber), s = Math.max(i.fromViewLineNumber, i.toViewLineNumber);
    for (let l = o; l <= s; l++) {
      const u = t.getLineMaxColumn(l), c = Kt.visibleColumnFromColumn2(e, t, new ie(l, u));
      r = Math.max(r, c);
    }
    let a = i.toViewVisualColumn;
    return a < r && a++, this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, a);
  }
  static columnSelectUp(e, t, i, r) {
    const o = r ? e.pageSize : 1, s = Math.max(1, i.toViewLineNumber - o);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, s, i.toViewVisualColumn);
  }
  static columnSelectDown(e, t, i, r) {
    const o = r ? e.pageSize : 1, s = Math.min(t.getLineCount(), i.toViewLineNumber + o);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, s, i.toViewVisualColumn);
  }
}
class _o {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    let r = t.getInverseEditOperations()[0].range;
    return new Ut(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn);
  }
}
class Iwe {
  constructor(e, t) {
    this._range = e, this._text = t;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const r = t.getInverseEditOperations()[0].range;
    return new Ut(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn);
  }
}
class Dy {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    let r = t.getInverseEditOperations()[0].range;
    return new Ut(r.startLineNumber, r.startColumn, r.startLineNumber, r.startColumn);
  }
}
class vw {
  constructor(e, t, i, r, o = !1) {
    this._range = e, this._text = t, this._columnDeltaOffset = r, this._lineNumberDeltaOffset = i, this.insertsAutoWhitespace = o;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    let r = t.getInverseEditOperations()[0].range;
    return new Ut(r.endLineNumber + this._lineNumberDeltaOffset, r.endColumn + this._columnDeltaOffset, r.endLineNumber + this._lineNumberDeltaOffset, r.endColumn + this._columnDeltaOffset);
  }
}
class qhe {
  constructor(e, t, i, r = !1) {
    this._range = e, this._text = t, this._initialSelection = i, this._forceMoveMarkers = r, this._selectionId = null;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers), this._selectionId = t.trackSelection(this._initialSelection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._selectionId);
  }
}
class Ry {
  constructor(e, t, i) {
    this.lineNumber = e, this.column = t, this.leftoverVisibleColumns = i;
  }
}
class Mt {
  static leftPosition(e, t) {
    if (t.column > e.getLineMinColumn(t.lineNumber))
      return t.delta(void 0, -roe(e.getLineContent(t.lineNumber), t.column - 1));
    if (t.lineNumber > 1) {
      const i = t.lineNumber - 1;
      return new ie(i, e.getLineMaxColumn(i));
    } else
      return t;
  }
  static leftPositionAtomicSoftTabs(e, t, i) {
    if (t.column <= e.getLineIndentColumn(t.lineNumber)) {
      const r = e.getLineMinColumn(t.lineNumber), o = e.getLineContent(t.lineNumber), s = o_.atomicPosition(
        o,
        t.column - 1,
        i,
        0
        /* Left */
      );
      if (s !== -1 && s + 1 >= r)
        return new ie(t.lineNumber, s + 1);
    }
    return this.leftPosition(e, t);
  }
  static left(e, t, i) {
    const r = e.stickyTabStops ? Mt.leftPositionAtomicSoftTabs(t, i, e.tabSize) : Mt.leftPosition(t, i);
    return new Ry(r.lineNumber, r.column, 0);
  }
  /**
   * @param noOfColumns Must be either `1`
   * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).
  */
  static moveLeft(e, t, i, r, o) {
    let s, a;
    if (i.hasSelection() && !r)
      s = i.selection.startLineNumber, a = i.selection.startColumn;
    else {
      const l = i.position.delta(void 0, -(o - 1)), u = t.normalizePosition(
        Mt.clipPositionColumn(l, t),
        0
        /* Left */
      ), c = Mt.left(e, t, u);
      s = c.lineNumber, a = c.column;
    }
    return i.move(r, s, a, 0);
  }
  /**
   * Adjusts the column so that it is within min/max of the line.
  */
  static clipPositionColumn(e, t) {
    return new ie(e.lineNumber, Mt.clipRange(e.column, t.getLineMinColumn(e.lineNumber), t.getLineMaxColumn(e.lineNumber)));
  }
  static clipRange(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static rightPosition(e, t, i) {
    return i < e.getLineMaxColumn(t) ? i = i + fb(e.getLineContent(t), i - 1) : t < e.getLineCount() && (t = t + 1, i = e.getLineMinColumn(t)), new ie(t, i);
  }
  static rightPositionAtomicSoftTabs(e, t, i, r, o) {
    if (i < e.getLineIndentColumn(t)) {
      const s = e.getLineContent(t), a = o_.atomicPosition(
        s,
        i - 1,
        r,
        1
        /* Right */
      );
      if (a !== -1)
        return new ie(t, a + 1);
    }
    return this.rightPosition(e, t, i);
  }
  static right(e, t, i) {
    const r = e.stickyTabStops ? Mt.rightPositionAtomicSoftTabs(t, i.lineNumber, i.column, e.tabSize, e.indentSize) : Mt.rightPosition(t, i.lineNumber, i.column);
    return new Ry(r.lineNumber, r.column, 0);
  }
  static moveRight(e, t, i, r, o) {
    let s, a;
    if (i.hasSelection() && !r)
      s = i.selection.endLineNumber, a = i.selection.endColumn;
    else {
      const l = i.position.delta(void 0, o - 1), u = t.normalizePosition(
        Mt.clipPositionColumn(l, t),
        1
        /* Right */
      ), c = Mt.right(e, t, u);
      s = c.lineNumber, a = c.column;
    }
    return i.move(r, s, a, 0);
  }
  static down(e, t, i, r, o, s, a) {
    const l = Kt.visibleColumnFromColumn(t.getLineContent(i), r, e.tabSize) + o, u = t.getLineCount(), c = i === u && r === t.getLineMaxColumn(i);
    return i = i + s, i > u ? (i = u, a ? r = t.getLineMaxColumn(i) : r = Math.min(t.getLineMaxColumn(i), r)) : r = Kt.columnFromVisibleColumn2(e, t, i, l), c ? o = 0 : o = l - Kt.visibleColumnFromColumn(t.getLineContent(i), r, e.tabSize), new Ry(i, r, o);
  }
  static moveDown(e, t, i, r, o) {
    let s, a;
    i.hasSelection() && !r ? (s = i.selection.endLineNumber, a = i.selection.endColumn) : (s = i.position.lineNumber, a = i.position.column);
    let l = Mt.down(e, t, s, a, i.leftoverVisibleColumns, o, !0);
    return i.move(r, l.lineNumber, l.column, l.leftoverVisibleColumns);
  }
  static translateDown(e, t, i) {
    let r = i.selection, o = Mt.down(e, t, r.selectionStartLineNumber, r.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), s = Mt.down(e, t, r.positionLineNumber, r.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new qn(new G(o.lineNumber, o.column, o.lineNumber, o.column), o.leftoverVisibleColumns, new ie(s.lineNumber, s.column), s.leftoverVisibleColumns);
  }
  static up(e, t, i, r, o, s, a) {
    const l = Kt.visibleColumnFromColumn(t.getLineContent(i), r, e.tabSize) + o, u = i === 1 && r === 1;
    return i = i - s, i < 1 ? (i = 1, a ? r = t.getLineMinColumn(i) : r = Math.min(t.getLineMaxColumn(i), r)) : r = Kt.columnFromVisibleColumn2(e, t, i, l), u ? o = 0 : o = l - Kt.visibleColumnFromColumn(t.getLineContent(i), r, e.tabSize), new Ry(i, r, o);
  }
  static moveUp(e, t, i, r, o) {
    let s, a;
    i.hasSelection() && !r ? (s = i.selection.startLineNumber, a = i.selection.startColumn) : (s = i.position.lineNumber, a = i.position.column);
    let l = Mt.up(e, t, s, a, i.leftoverVisibleColumns, o, !0);
    return i.move(r, l.lineNumber, l.column, l.leftoverVisibleColumns);
  }
  static translateUp(e, t, i) {
    let r = i.selection, o = Mt.up(e, t, r.selectionStartLineNumber, r.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), s = Mt.up(e, t, r.positionLineNumber, r.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new qn(new G(o.lineNumber, o.column, o.lineNumber, o.column), o.leftoverVisibleColumns, new ie(s.lineNumber, s.column), s.leftoverVisibleColumns);
  }
  static _isBlankLine(e, t) {
    return e.getLineFirstNonWhitespaceColumn(t) === 0;
  }
  static moveToPrevBlankLine(e, t, i, r) {
    let o = i.position.lineNumber;
    for (; o > 1 && this._isBlankLine(t, o); )
      o--;
    for (; o > 1 && !this._isBlankLine(t, o); )
      o--;
    return i.move(r, o, t.getLineMinColumn(o), 0);
  }
  static moveToNextBlankLine(e, t, i, r) {
    const o = t.getLineCount();
    let s = i.position.lineNumber;
    for (; s < o && this._isBlankLine(t, s); )
      s++;
    for (; s < o && !this._isBlankLine(t, s); )
      s++;
    return i.move(r, s, t.getLineMinColumn(s), 0);
  }
  static moveToBeginningOfLine(e, t, i, r) {
    let o = i.position.lineNumber, s = t.getLineMinColumn(o), a = t.getLineFirstNonWhitespaceColumn(o) || s, l;
    return i.position.column === a ? l = s : l = a, i.move(r, o, l, 0);
  }
  static moveToEndOfLine(e, t, i, r, o) {
    let s = i.position.lineNumber, a = t.getLineMaxColumn(s);
    return i.move(r, s, a, o ? 1073741824 - a : 0);
  }
  static moveToBeginningOfBuffer(e, t, i, r) {
    return i.move(r, 1, 1, 0);
  }
  static moveToEndOfBuffer(e, t, i, r) {
    let o = t.getLineCount(), s = t.getLineMaxColumn(o);
    return i.move(r, o, s, 0);
  }
}
class qd {
  static deleteRight(e, t, i, r) {
    let o = [], s = e !== 3;
    for (let a = 0, l = r.length; a < l; a++) {
      const u = r[a];
      let c = u;
      if (c.isEmpty()) {
        let h = u.getPosition(), d = Mt.right(t, i, h);
        c = new G(d.lineNumber, d.column, h.lineNumber, h.column);
      }
      if (c.isEmpty()) {
        o[a] = null;
        continue;
      }
      c.startLineNumber !== c.endLineNumber && (s = !0), o[a] = new _o(c, "");
    }
    return [s, o];
  }
  static isAutoClosingPairDelete(e, t, i, r, o, s, a) {
    if (t === "never" && i === "never" || e === "never")
      return !1;
    for (let l = 0, u = s.length; l < u; l++) {
      const c = s[l], h = c.getPosition();
      if (!c.isEmpty())
        return !1;
      const d = o.getLineContent(h.lineNumber);
      if (h.column < 2 || h.column >= d.length + 1)
        return !1;
      const f = d.charAt(h.column - 2), p = r.get(f);
      if (!p)
        return !1;
      if (Yf(f)) {
        if (i === "never")
          return !1;
      } else if (t === "never")
        return !1;
      const g = d.charAt(h.column - 1);
      let _ = !1;
      for (const m of p)
        m.open === f && m.close === g && (_ = !0);
      if (!_)
        return !1;
      if (e === "auto") {
        let m = !1;
        for (let v = 0, C = a.length; v < C; v++) {
          const y = a[v];
          if (h.lineNumber === y.startLineNumber && h.column === y.startColumn) {
            m = !0;
            break;
          }
        }
        if (!m)
          return !1;
      }
    }
    return !0;
  }
  static _runAutoClosingPairDelete(e, t, i) {
    let r = [];
    for (let o = 0, s = i.length; o < s; o++) {
      const a = i[o].getPosition(), l = new G(a.lineNumber, a.column - 1, a.lineNumber, a.column + 1);
      r[o] = new _o(l, "");
    }
    return [!0, r];
  }
  static deleteLeft(e, t, i, r, o) {
    if (this.isAutoClosingPairDelete(t.autoClosingDelete, t.autoClosingBrackets, t.autoClosingQuotes, t.autoClosingPairs.autoClosingPairsOpenByEnd, i, r, o))
      return this._runAutoClosingPairDelete(t, i, r);
    const s = [];
    let a = e !== 2;
    for (let l = 0, u = r.length; l < u; l++) {
      let c = qd.getDeleteRange(r[l], i, t);
      if (c.isEmpty()) {
        s[l] = null;
        continue;
      }
      c.startLineNumber !== c.endLineNumber && (a = !0), s[l] = new _o(c, "");
    }
    return [a, s];
  }
  static getDeleteRange(e, t, i) {
    if (!e.isEmpty())
      return e;
    const r = e.getPosition();
    if (i.useTabStops && r.column > 1) {
      const o = t.getLineContent(r.lineNumber), s = Os(o), a = s === -1 ? (
        /* entire string is whitespace */
        o.length + 1
      ) : s + 1;
      if (r.column <= a) {
        const l = Kt.visibleColumnFromColumn2(i, t, r), u = Kt.prevIndentTabStop(l, i.indentSize), c = Kt.columnFromVisibleColumn2(i, t, r.lineNumber, u);
        return new G(r.lineNumber, c, r.lineNumber, r.column);
      }
    }
    return G.fromPositions(qd.getPositionAfterDeleteLeft(r, t), r);
  }
  static getPositionAfterDeleteLeft(e, t) {
    if (e.column > 1) {
      const i = foe(e.column - 1, t.getLineContent(e.lineNumber));
      return e.with(void 0, i + 1);
    } else if (e.lineNumber > 1) {
      const i = e.lineNumber - 1;
      return new ie(i, t.getLineMaxColumn(i));
    } else
      return e;
  }
  static cut(e, t, i) {
    let r = [];
    for (let o = 0, s = i.length; o < s; o++) {
      const a = i[o];
      if (a.isEmpty())
        if (e.emptySelectionClipboard) {
          let l = a.getPosition(), u, c, h, d;
          l.lineNumber < t.getLineCount() ? (u = l.lineNumber, c = 1, h = l.lineNumber + 1, d = 1) : l.lineNumber > 1 ? (u = l.lineNumber - 1, c = t.getLineMaxColumn(l.lineNumber - 1), h = l.lineNumber, d = t.getLineMaxColumn(l.lineNumber)) : (u = l.lineNumber, c = 1, h = l.lineNumber, d = t.getLineMaxColumn(l.lineNumber));
          let f = new G(u, c, h, d);
          f.isEmpty() ? r[o] = null : r[o] = new _o(f, "");
        } else
          r[o] = null;
      else
        r[o] = new _o(a, "");
    }
    return new vo(0, r, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
}
class xt {
  static _createWord(e, t, i, r, o) {
    return { start: r, end: o, wordType: t, nextCharClass: i };
  }
  static _findPreviousWordOnLine(e, t, i) {
    let r = t.getLineContent(i.lineNumber);
    return this._doFindPreviousWordOnLine(r, e, i);
  }
  static _doFindPreviousWordOnLine(e, t, i) {
    let r = 0;
    for (let o = i.column - 2; o >= 0; o--) {
      let s = e.charCodeAt(o), a = t.get(s);
      if (a === 0) {
        if (r === 2)
          return this._createWord(e, r, a, o + 1, this._findEndOfWord(e, t, r, o + 1));
        r = 1;
      } else if (a === 2) {
        if (r === 1)
          return this._createWord(e, r, a, o + 1, this._findEndOfWord(e, t, r, o + 1));
        r = 2;
      } else if (a === 1 && r !== 0)
        return this._createWord(e, r, a, o + 1, this._findEndOfWord(e, t, r, o + 1));
    }
    return r !== 0 ? this._createWord(e, r, 1, 0, this._findEndOfWord(e, t, r, 0)) : null;
  }
  static _findEndOfWord(e, t, i, r) {
    let o = e.length;
    for (let s = r; s < o; s++) {
      let a = e.charCodeAt(s), l = t.get(a);
      if (l === 1 || i === 1 && l === 2 || i === 2 && l === 0)
        return s;
    }
    return o;
  }
  static _findNextWordOnLine(e, t, i) {
    let r = t.getLineContent(i.lineNumber);
    return this._doFindNextWordOnLine(r, e, i);
  }
  static _doFindNextWordOnLine(e, t, i) {
    let r = 0, o = e.length;
    for (let s = i.column - 1; s < o; s++) {
      let a = e.charCodeAt(s), l = t.get(a);
      if (l === 0) {
        if (r === 2)
          return this._createWord(e, r, l, this._findStartOfWord(e, t, r, s - 1), s);
        r = 1;
      } else if (l === 2) {
        if (r === 1)
          return this._createWord(e, r, l, this._findStartOfWord(e, t, r, s - 1), s);
        r = 2;
      } else if (l === 1 && r !== 0)
        return this._createWord(e, r, l, this._findStartOfWord(e, t, r, s - 1), s);
    }
    return r !== 0 ? this._createWord(e, r, 1, this._findStartOfWord(e, t, r, o - 1), o) : null;
  }
  static _findStartOfWord(e, t, i, r) {
    for (let o = r; o >= 0; o--) {
      let s = e.charCodeAt(o), a = t.get(s);
      if (a === 1 || i === 1 && a === 2 || i === 2 && a === 0)
        return o + 1;
    }
    return 0;
  }
  static moveWordLeft(e, t, i, r) {
    let o = i.lineNumber, s = i.column;
    s === 1 && o > 1 && (o = o - 1, s = t.getLineMaxColumn(o));
    let a = xt._findPreviousWordOnLine(e, t, new ie(o, s));
    if (r === 0)
      return new ie(o, a ? a.start + 1 : 1);
    if (r === 1)
      return a && a.wordType === 2 && a.end - a.start === 1 && a.nextCharClass === 0 && (a = xt._findPreviousWordOnLine(e, t, new ie(o, a.start + 1))), new ie(o, a ? a.start + 1 : 1);
    if (r === 3) {
      for (; a && a.wordType === 2; )
        a = xt._findPreviousWordOnLine(e, t, new ie(o, a.start + 1));
      return new ie(o, a ? a.start + 1 : 1);
    }
    return a && s <= a.end + 1 && (a = xt._findPreviousWordOnLine(e, t, new ie(o, a.start + 1))), new ie(o, a ? a.end + 1 : 1);
  }
  static _moveWordPartLeft(e, t) {
    const i = t.lineNumber, r = e.getLineMaxColumn(i);
    if (t.column === 1)
      return i > 1 ? new ie(i - 1, e.getLineMaxColumn(i - 1)) : t;
    const o = e.getLineContent(i);
    for (let s = t.column - 1; s > 1; s--) {
      const a = o.charCodeAt(s - 2), l = o.charCodeAt(s - 1);
      if (a === 95 && l !== 95)
        return new ie(i, s);
      if (ad(a) && Iu(l))
        return new ie(i, s);
      if (Iu(a) && Iu(l) && s + 1 < r) {
        const u = o.charCodeAt(s);
        if (ad(u))
          return new ie(i, s);
      }
    }
    return new ie(i, 1);
  }
  static moveWordRight(e, t, i, r) {
    let o = i.lineNumber, s = i.column, a = !1;
    s === t.getLineMaxColumn(o) && o < t.getLineCount() && (a = !0, o = o + 1, s = 1);
    let l = xt._findNextWordOnLine(e, t, new ie(o, s));
    if (r === 2)
      l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = xt._findNextWordOnLine(e, t, new ie(o, l.end + 1))), l ? s = l.end + 1 : s = t.getLineMaxColumn(o);
    else if (r === 3) {
      for (a && (s = 0); l && (l.wordType === 2 || l.start + 1 <= s); )
        l = xt._findNextWordOnLine(e, t, new ie(o, l.end + 1));
      l ? s = l.start + 1 : s = t.getLineMaxColumn(o);
    } else
      l && !a && s >= l.start + 1 && (l = xt._findNextWordOnLine(e, t, new ie(o, l.end + 1))), l ? s = l.start + 1 : s = t.getLineMaxColumn(o);
    return new ie(o, s);
  }
  static _moveWordPartRight(e, t) {
    const i = t.lineNumber, r = e.getLineMaxColumn(i);
    if (t.column === r)
      return i < e.getLineCount() ? new ie(i + 1, 1) : t;
    const o = e.getLineContent(i);
    for (let s = t.column + 1; s < r; s++) {
      const a = o.charCodeAt(s - 2), l = o.charCodeAt(s - 1);
      if (a !== 95 && l === 95)
        return new ie(i, s);
      if (ad(a) && Iu(l))
        return new ie(i, s);
      if (Iu(a) && Iu(l) && s + 1 < r) {
        const u = o.charCodeAt(s);
        if (ad(u))
          return new ie(i, s);
      }
    }
    return new ie(i, r);
  }
  static _deleteWordLeftWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), r = t.column - 2, o = Ng(i, r);
    return o + 1 < r ? new G(t.lineNumber, o + 2, t.lineNumber, t.column) : null;
  }
  static deleteWordLeft(e, t) {
    const i = e.wordSeparators, r = e.model, o = e.selection, s = e.whitespaceHeuristics;
    if (!o.isEmpty())
      return o;
    if (qd.isAutoClosingPairDelete(e.autoClosingDelete, e.autoClosingBrackets, e.autoClosingQuotes, e.autoClosingPairs.autoClosingPairsOpenByEnd, e.model, [e.selection], e.autoClosedCharacters)) {
      const h = e.selection.getPosition();
      return new G(h.lineNumber, h.column - 1, h.lineNumber, h.column + 1);
    }
    const a = new ie(o.positionLineNumber, o.positionColumn);
    let l = a.lineNumber, u = a.column;
    if (l === 1 && u === 1)
      return null;
    if (s) {
      let h = this._deleteWordLeftWhitespace(r, a);
      if (h)
        return h;
    }
    let c = xt._findPreviousWordOnLine(i, r, a);
    return t === 0 ? c ? u = c.start + 1 : u > 1 ? u = 1 : (l--, u = r.getLineMaxColumn(l)) : (c && u <= c.end + 1 && (c = xt._findPreviousWordOnLine(i, r, new ie(l, c.start + 1))), c ? u = c.end + 1 : u > 1 ? u = 1 : (l--, u = r.getLineMaxColumn(l))), new G(l, u, a.lineNumber, a.column);
  }
  static deleteInsideWord(e, t, i) {
    if (!i.isEmpty())
      return i;
    const r = new ie(i.positionLineNumber, i.positionColumn);
    let o = this._deleteInsideWordWhitespace(t, r);
    return o || this._deleteInsideWordDetermineDeleteRange(e, t, r);
  }
  static _charAtIsWhitespace(e, t) {
    const i = e.charCodeAt(t);
    return i === 32 || i === 9;
  }
  static _deleteInsideWordWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), r = i.length;
    if (r === 0)
      return null;
    let o = Math.max(t.column - 2, 0);
    if (!this._charAtIsWhitespace(i, o))
      return null;
    let s = Math.min(t.column - 1, r - 1);
    if (!this._charAtIsWhitespace(i, s))
      return null;
    for (; o > 0 && this._charAtIsWhitespace(i, o - 1); )
      o--;
    for (; s + 1 < r && this._charAtIsWhitespace(i, s + 1); )
      s++;
    return new G(t.lineNumber, o + 1, t.lineNumber, s + 2);
  }
  static _deleteInsideWordDetermineDeleteRange(e, t, i) {
    const r = t.getLineContent(i.lineNumber), o = r.length;
    if (o === 0)
      return i.lineNumber > 1 ? new G(i.lineNumber - 1, t.getLineMaxColumn(i.lineNumber - 1), i.lineNumber, 1) : i.lineNumber < t.getLineCount() ? new G(i.lineNumber, 1, i.lineNumber + 1, 1) : new G(i.lineNumber, 1, i.lineNumber, 1);
    const s = (h) => h.start + 1 <= i.column && i.column <= h.end + 1, a = (h, d) => (h = Math.min(h, i.column), d = Math.max(d, i.column), new G(i.lineNumber, h, i.lineNumber, d)), l = (h) => {
      let d = h.start + 1, f = h.end + 1, p = !1;
      for (; f - 1 < o && this._charAtIsWhitespace(r, f - 1); )
        p = !0, f++;
      if (!p)
        for (; d > 1 && this._charAtIsWhitespace(r, d - 2); )
          d--;
      return a(d, f);
    }, u = xt._findPreviousWordOnLine(e, t, i);
    if (u && s(u))
      return l(u);
    const c = xt._findNextWordOnLine(e, t, i);
    return c && s(c) ? l(c) : u && c ? a(u.end + 1, c.start + 1) : u ? a(u.start + 1, u.end + 1) : c ? a(c.start + 1, c.end + 1) : a(1, o + 1);
  }
  static _deleteWordPartLeft(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), r = xt._moveWordPartLeft(e, i);
    return new G(i.lineNumber, i.column, r.lineNumber, r.column);
  }
  static _findFirstNonWhitespaceChar(e, t) {
    let i = e.length;
    for (let r = t; r < i; r++) {
      let o = e.charAt(r);
      if (o !== " " && o !== "	")
        return r;
    }
    return i;
  }
  static _deleteWordRightWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), r = t.column - 1, o = this._findFirstNonWhitespaceChar(i, r);
    return r + 1 < o ? new G(t.lineNumber, t.column, t.lineNumber, o + 1) : null;
  }
  static deleteWordRight(e, t) {
    const i = e.wordSeparators, r = e.model, o = e.selection, s = e.whitespaceHeuristics;
    if (!o.isEmpty())
      return o;
    const a = new ie(o.positionLineNumber, o.positionColumn);
    let l = a.lineNumber, u = a.column;
    const c = r.getLineCount(), h = r.getLineMaxColumn(l);
    if (l === c && u === h)
      return null;
    if (s) {
      let f = this._deleteWordRightWhitespace(r, a);
      if (f)
        return f;
    }
    let d = xt._findNextWordOnLine(i, r, a);
    return t === 2 ? d ? u = d.end + 1 : u < h || l === c ? u = h : (l++, d = xt._findNextWordOnLine(i, r, new ie(l, 1)), d ? u = d.start + 1 : u = r.getLineMaxColumn(l)) : (d && u >= d.start + 1 && (d = xt._findNextWordOnLine(i, r, new ie(l, d.end + 1))), d ? u = d.start + 1 : u < h || l === c ? u = h : (l++, d = xt._findNextWordOnLine(i, r, new ie(l, 1)), d ? u = d.start + 1 : u = r.getLineMaxColumn(l))), new G(l, u, a.lineNumber, a.column);
  }
  static _deleteWordPartRight(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), r = xt._moveWordPartRight(e, i);
    return new G(i.lineNumber, i.column, r.lineNumber, r.column);
  }
  static _createWordAtPosition(e, t, i) {
    const r = new G(t, i.start + 1, t, i.end + 1);
    return {
      word: e.getValueInRange(r),
      startColumn: r.startColumn,
      endColumn: r.endColumn
    };
  }
  static getWordAtPosition(e, t, i) {
    const r = tg(t), o = xt._findPreviousWordOnLine(r, e, i);
    if (o && o.wordType === 1 && o.start <= i.column - 1 && i.column - 1 <= o.end)
      return xt._createWordAtPosition(e, i.lineNumber, o);
    const s = xt._findNextWordOnLine(r, e, i);
    return s && s.wordType === 1 && s.start <= i.column - 1 && i.column - 1 <= s.end ? xt._createWordAtPosition(e, i.lineNumber, s) : null;
  }
  static word(e, t, i, r, o) {
    const s = tg(e.wordSeparators);
    let a = xt._findPreviousWordOnLine(s, t, o), l = xt._findNextWordOnLine(s, t, o);
    if (!r) {
      let f, p;
      return a && a.wordType === 1 && a.start <= o.column - 1 && o.column - 1 <= a.end ? (f = a.start + 1, p = a.end + 1) : l && l.wordType === 1 && l.start <= o.column - 1 && o.column - 1 <= l.end ? (f = l.start + 1, p = l.end + 1) : (a ? f = a.end + 1 : f = 1, l ? p = l.start + 1 : p = t.getLineMaxColumn(o.lineNumber)), new qn(new G(o.lineNumber, f, o.lineNumber, p), 0, new ie(o.lineNumber, p), 0);
    }
    let u, c;
    a && a.wordType === 1 && a.start < o.column - 1 && o.column - 1 < a.end ? (u = a.start + 1, c = a.end + 1) : l && l.wordType === 1 && l.start < o.column - 1 && o.column - 1 < l.end ? (u = l.start + 1, c = l.end + 1) : (u = o.column, c = o.column);
    let h = o.lineNumber, d;
    if (i.selectionStart.containsPosition(o))
      d = i.selectionStart.endColumn;
    else if (o.isBeforeOrEqual(i.selectionStart.getStartPosition())) {
      d = u;
      let f = new ie(h, d);
      i.selectionStart.containsPosition(f) && (d = i.selectionStart.endColumn);
    } else {
      d = c;
      let f = new ie(h, d);
      i.selectionStart.containsPosition(f) && (d = i.selectionStart.startColumn);
    }
    return i.move(!0, h, d, 0);
  }
}
class Pwe extends xt {
  static deleteWordPartLeft(e) {
    const t = Ty([
      xt.deleteWordLeft(
        e,
        0
        /* WordStart */
      ),
      xt.deleteWordLeft(
        e,
        2
        /* WordEnd */
      ),
      xt._deleteWordPartLeft(e.model, e.selection)
    ]);
    return t.sort(G.compareRangesUsingEnds), t[2];
  }
  static deleteWordPartRight(e) {
    const t = Ty([
      xt.deleteWordRight(
        e,
        0
        /* WordStart */
      ),
      xt.deleteWordRight(
        e,
        2
        /* WordEnd */
      ),
      xt._deleteWordPartRight(e.model, e.selection)
    ]);
    return t.sort(G.compareRangesUsingStarts), t[0];
  }
  static moveWordPartLeft(e, t, i) {
    const r = Ty([
      xt.moveWordLeft(
        e,
        t,
        i,
        0
        /* WordStart */
      ),
      xt.moveWordLeft(
        e,
        t,
        i,
        2
        /* WordEnd */
      ),
      xt._moveWordPartLeft(t, i)
    ]);
    return r.sort(ie.compare), r[2];
  }
  static moveWordPartRight(e, t, i) {
    const r = Ty([
      xt.moveWordRight(
        e,
        t,
        i,
        0
        /* WordStart */
      ),
      xt.moveWordRight(
        e,
        t,
        i,
        2
        /* WordEnd */
      ),
      xt._moveWordPartRight(t, i)
    ]);
    return r.sort(ie.compare), r[0];
  }
}
function Ty(n) {
  return n.filter((e) => !!e);
}
class sr {
  static addCursorDown(e, t, i) {
    let r = [], o = 0;
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      r[o++] = new at(l.modelState, l.viewState), i ? r[o++] = at.fromModelState(Mt.translateDown(e.cursorConfig, e.model, l.modelState)) : r[o++] = at.fromViewState(Mt.translateDown(e.cursorConfig, e, l.viewState));
    }
    return r;
  }
  static addCursorUp(e, t, i) {
    let r = [], o = 0;
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      r[o++] = new at(l.modelState, l.viewState), i ? r[o++] = at.fromModelState(Mt.translateUp(e.cursorConfig, e.model, l.modelState)) : r[o++] = at.fromViewState(Mt.translateUp(e.cursorConfig, e, l.viewState));
    }
    return r;
  }
  static moveToBeginningOfLine(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o];
      r[o] = this._moveToLineStart(e, a, i);
    }
    return r;
  }
  static _moveToLineStart(e, t, i) {
    const r = t.viewState.position.column, o = t.modelState.position.column, s = r === o, a = t.viewState.position.lineNumber, l = e.getLineFirstNonWhitespaceColumn(a);
    return !s && !(r === l) ? this._moveToLineStartByView(e, t, i) : this._moveToLineStartByModel(e, t, i);
  }
  static _moveToLineStartByView(e, t, i) {
    return at.fromViewState(Mt.moveToBeginningOfLine(e.cursorConfig, e, t.viewState, i));
  }
  static _moveToLineStartByModel(e, t, i) {
    return at.fromModelState(Mt.moveToBeginningOfLine(e.cursorConfig, e.model, t.modelState, i));
  }
  static moveToEndOfLine(e, t, i, r) {
    let o = [];
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      o[s] = this._moveToLineEnd(e, l, i, r);
    }
    return o;
  }
  static _moveToLineEnd(e, t, i, r) {
    const o = t.viewState.position, s = e.getLineMaxColumn(o.lineNumber), a = o.column === s, l = t.modelState.position, u = e.model.getLineMaxColumn(l.lineNumber), c = s - o.column === u - l.column;
    return a || c ? this._moveToLineEndByModel(e, t, i, r) : this._moveToLineEndByView(e, t, i, r);
  }
  static _moveToLineEndByView(e, t, i, r) {
    return at.fromViewState(Mt.moveToEndOfLine(e.cursorConfig, e, t.viewState, i, r));
  }
  static _moveToLineEndByModel(e, t, i, r) {
    return at.fromModelState(Mt.moveToEndOfLine(e.cursorConfig, e.model, t.modelState, i, r));
  }
  static expandLineSelection(e, t) {
    let i = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const s = t[r], a = s.modelState.selection.startLineNumber, l = e.model.getLineCount();
      let u = s.modelState.selection.endLineNumber, c;
      u === l ? c = e.model.getLineMaxColumn(l) : (u++, c = 1), i[r] = at.fromModelState(new qn(new G(a, 1, a, 1), 0, new ie(u, c), 0));
    }
    return i;
  }
  static moveToBeginningOfBuffer(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o];
      r[o] = at.fromModelState(Mt.moveToBeginningOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return r;
  }
  static moveToEndOfBuffer(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o];
      r[o] = at.fromModelState(Mt.moveToEndOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return r;
  }
  static selectAll(e, t) {
    const i = e.model.getLineCount(), r = e.model.getLineMaxColumn(i);
    return at.fromModelState(new qn(new G(1, 1, 1, 1), 0, new ie(i, r), 0));
  }
  static line(e, t, i, r, o) {
    const s = e.model.validatePosition(r), a = o ? e.coordinatesConverter.validateViewPosition(new ie(o.lineNumber, o.column), s) : e.coordinatesConverter.convertModelPositionToViewPosition(s);
    if (!i || !t.modelState.hasSelection()) {
      const u = e.model.getLineCount();
      let c = s.lineNumber + 1, h = 1;
      return c > u && (c = u, h = e.model.getLineMaxColumn(c)), at.fromModelState(new qn(new G(s.lineNumber, 1, c, h), 0, new ie(c, h), 0));
    }
    const l = t.modelState.selectionStart.getStartPosition().lineNumber;
    if (s.lineNumber < l)
      return at.fromViewState(t.viewState.move(t.modelState.hasSelection(), a.lineNumber, 1, 0));
    if (s.lineNumber > l) {
      const u = e.getLineCount();
      let c = a.lineNumber + 1, h = 1;
      return c > u && (c = u, h = e.getLineMaxColumn(c)), at.fromViewState(t.viewState.move(t.modelState.hasSelection(), c, h, 0));
    } else {
      const u = t.modelState.selectionStart.getEndPosition();
      return at.fromModelState(t.modelState.move(t.modelState.hasSelection(), u.lineNumber, u.column, 0));
    }
  }
  static word(e, t, i, r) {
    const o = e.model.validatePosition(r);
    return at.fromModelState(xt.word(e.cursorConfig, e.model, t.modelState, i, o));
  }
  static cancelSelection(e, t) {
    if (!t.modelState.hasSelection())
      return new at(t.modelState, t.viewState);
    const i = t.viewState.position.lineNumber, r = t.viewState.position.column;
    return at.fromViewState(new qn(new G(i, r, i, r), 0, new ie(i, r), 0));
  }
  static moveTo(e, t, i, r, o) {
    const s = e.model.validatePosition(r), a = o ? e.coordinatesConverter.validateViewPosition(new ie(o.lineNumber, o.column), s) : e.coordinatesConverter.convertModelPositionToViewPosition(s);
    return at.fromViewState(t.viewState.move(i, a.lineNumber, a.column, 0));
  }
  static simpleMove(e, t, i, r, o, s) {
    switch (i) {
      case 0:
        return s === 4 ? this._moveHalfLineLeft(e, t, r) : this._moveLeft(e, t, r, o);
      case 1:
        return s === 4 ? this._moveHalfLineRight(e, t, r) : this._moveRight(e, t, r, o);
      case 2:
        return s === 2 ? this._moveUpByViewLines(e, t, r, o) : this._moveUpByModelLines(e, t, r, o);
      case 3:
        return s === 2 ? this._moveDownByViewLines(e, t, r, o) : this._moveDownByModelLines(e, t, r, o);
      case 4:
        return s === 2 ? t.map((a) => at.fromViewState(Mt.moveToPrevBlankLine(e.cursorConfig, e, a.viewState, r))) : t.map((a) => at.fromModelState(Mt.moveToPrevBlankLine(e.cursorConfig, e.model, a.modelState, r)));
      case 5:
        return s === 2 ? t.map((a) => at.fromViewState(Mt.moveToNextBlankLine(e.cursorConfig, e, a.viewState, r))) : t.map((a) => at.fromModelState(Mt.moveToNextBlankLine(e.cursorConfig, e.model, a.modelState, r)));
      case 6:
        return this._moveToViewMinColumn(e, t, r);
      case 7:
        return this._moveToViewFirstNonWhitespaceColumn(e, t, r);
      case 8:
        return this._moveToViewCenterColumn(e, t, r);
      case 9:
        return this._moveToViewMaxColumn(e, t, r);
      case 10:
        return this._moveToViewLastNonWhitespaceColumn(e, t, r);
      default:
        return null;
    }
  }
  static viewportMove(e, t, i, r, o) {
    const s = e.getCompletelyVisibleViewRange(), a = e.coordinatesConverter.convertViewRangeToModelRange(s);
    switch (i) {
      case 11: {
        const l = this._firstLineNumberInRange(e.model, a, o), u = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], r, l, u)];
      }
      case 13: {
        const l = this._lastLineNumberInRange(e.model, a, o), u = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], r, l, u)];
      }
      case 12: {
        const l = Math.round((a.startLineNumber + a.endLineNumber) / 2), u = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], r, l, u)];
      }
      case 14: {
        let l = [];
        for (let u = 0, c = t.length; u < c; u++) {
          const h = t[u];
          l[u] = this.findPositionInViewportIfOutside(e, h, s, r);
        }
        return l;
      }
      default:
        return null;
    }
  }
  static findPositionInViewportIfOutside(e, t, i, r) {
    let o = t.viewState.position.lineNumber;
    if (i.startLineNumber <= o && o <= i.endLineNumber - 1)
      return new at(t.modelState, t.viewState);
    {
      o > i.endLineNumber - 1 && (o = i.endLineNumber - 1), o < i.startLineNumber && (o = i.startLineNumber);
      const s = e.getLineFirstNonWhitespaceColumn(o);
      return this._moveToViewPosition(e, t, r, o, s);
    }
  }
  /**
   * Find the nth line start included in the range (from the start).
   */
  static _firstLineNumberInRange(e, t, i) {
    let r = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(r) && r++, Math.min(t.endLineNumber, r + i - 1);
  }
  /**
   * Find the nth line start included in the range (from the end).
   */
  static _lastLineNumberInRange(e, t, i) {
    let r = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(r) && r++, Math.max(r, t.endLineNumber - i + 1);
  }
  static _moveLeft(e, t, i, r) {
    return t.map((o) => at.fromViewState(Mt.moveLeft(e.cursorConfig, e, o.viewState, i, r)));
  }
  static _moveHalfLineLeft(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = Math.round(e.getLineContent(l).length / 2);
      r[o] = at.fromViewState(Mt.moveLeft(e.cursorConfig, e, a.viewState, i, u));
    }
    return r;
  }
  static _moveRight(e, t, i, r) {
    return t.map((o) => at.fromViewState(Mt.moveRight(e.cursorConfig, e, o.viewState, i, r)));
  }
  static _moveHalfLineRight(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = Math.round(e.getLineContent(l).length / 2);
      r[o] = at.fromViewState(Mt.moveRight(e.cursorConfig, e, a.viewState, i, u));
    }
    return r;
  }
  static _moveDownByViewLines(e, t, i, r) {
    let o = [];
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      o[s] = at.fromViewState(Mt.moveDown(e.cursorConfig, e, l.viewState, i, r));
    }
    return o;
  }
  static _moveDownByModelLines(e, t, i, r) {
    let o = [];
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      o[s] = at.fromModelState(Mt.moveDown(e.cursorConfig, e.model, l.modelState, i, r));
    }
    return o;
  }
  static _moveUpByViewLines(e, t, i, r) {
    let o = [];
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      o[s] = at.fromViewState(Mt.moveUp(e.cursorConfig, e, l.viewState, i, r));
    }
    return o;
  }
  static _moveUpByModelLines(e, t, i, r) {
    let o = [];
    for (let s = 0, a = t.length; s < a; s++) {
      const l = t[s];
      o[s] = at.fromModelState(Mt.moveUp(e.cursorConfig, e.model, l.modelState, i, r));
    }
    return o;
  }
  static _moveToViewPosition(e, t, i, r, o) {
    return at.fromViewState(t.viewState.move(i, r, o, 0));
  }
  static _moveToModelPosition(e, t, i, r, o) {
    return at.fromModelState(t.modelState.move(i, r, o, 0));
  }
  static _moveToViewMinColumn(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineMinColumn(l);
      r[o] = this._moveToViewPosition(e, a, i, l, u);
    }
    return r;
  }
  static _moveToViewFirstNonWhitespaceColumn(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineFirstNonWhitespaceColumn(l);
      r[o] = this._moveToViewPosition(e, a, i, l, u);
    }
    return r;
  }
  static _moveToViewCenterColumn(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = Math.round((e.getLineMaxColumn(l) + e.getLineMinColumn(l)) / 2);
      r[o] = this._moveToViewPosition(e, a, i, l, u);
    }
    return r;
  }
  static _moveToViewMaxColumn(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineMaxColumn(l);
      r[o] = this._moveToViewPosition(e, a, i, l, u);
    }
    return r;
  }
  static _moveToViewLastNonWhitespaceColumn(e, t, i) {
    let r = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, u = e.getLineLastNonWhitespaceColumn(l);
      r[o] = this._moveToViewPosition(e, a, i, l, u);
    }
    return r;
  }
}
var jb;
(function(n) {
  const e = function(i) {
    if (!Uo(i))
      return !1;
    let r = i;
    return !(!il(r.to) || !xs(r.select) && !S5(r.select) || !xs(r.by) && !il(r.by) || !xs(r.value) && !j_(r.value));
  };
  n.description = {
    description: "Move cursor to a logical position in the view",
    args: [
      {
        name: "Cursor move argument object",
        description: `Property-value pairs that can be passed through this argument:
					* 'to': A mandatory logical position value providing where to move the cursor.
						\`\`\`
						'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',
						'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
						'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
						'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'character', 'halfLine'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'select': If 'true' makes the selection. Default is 'false'.
				`,
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["left", "right", "up", "down", "prevBlankLine", "nextBlankLine", "wrappedLineStart", "wrappedLineEnd", "wrappedLineColumnCenter", "wrappedLineFirstNonWhitespaceCharacter", "wrappedLineLastNonWhitespaceCharacter", "viewPortTop", "viewPortCenter", "viewPortBottom", "viewPortIfOutside"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "character", "halfLine"]
            },
            value: {
              type: "number",
              default: 1
            },
            select: {
              type: "boolean",
              default: !1
            }
          }
        }
      }
    ]
  }, n.RawDirection = {
    Left: "left",
    Right: "right",
    Up: "up",
    Down: "down",
    PrevBlankLine: "prevBlankLine",
    NextBlankLine: "nextBlankLine",
    WrappedLineStart: "wrappedLineStart",
    WrappedLineFirstNonWhitespaceCharacter: "wrappedLineFirstNonWhitespaceCharacter",
    WrappedLineColumnCenter: "wrappedLineColumnCenter",
    WrappedLineEnd: "wrappedLineEnd",
    WrappedLineLastNonWhitespaceCharacter: "wrappedLineLastNonWhitespaceCharacter",
    ViewPortTop: "viewPortTop",
    ViewPortCenter: "viewPortCenter",
    ViewPortBottom: "viewPortBottom",
    ViewPortIfOutside: "viewPortIfOutside"
  }, n.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Character: "character",
    HalfLine: "halfLine"
  };
  function t(i) {
    if (!i.to)
      return null;
    let r;
    switch (i.to) {
      case n.RawDirection.Left:
        r = 0;
        break;
      case n.RawDirection.Right:
        r = 1;
        break;
      case n.RawDirection.Up:
        r = 2;
        break;
      case n.RawDirection.Down:
        r = 3;
        break;
      case n.RawDirection.PrevBlankLine:
        r = 4;
        break;
      case n.RawDirection.NextBlankLine:
        r = 5;
        break;
      case n.RawDirection.WrappedLineStart:
        r = 6;
        break;
      case n.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
        r = 7;
        break;
      case n.RawDirection.WrappedLineColumnCenter:
        r = 8;
        break;
      case n.RawDirection.WrappedLineEnd:
        r = 9;
        break;
      case n.RawDirection.WrappedLineLastNonWhitespaceCharacter:
        r = 10;
        break;
      case n.RawDirection.ViewPortTop:
        r = 11;
        break;
      case n.RawDirection.ViewPortBottom:
        r = 13;
        break;
      case n.RawDirection.ViewPortCenter:
        r = 12;
        break;
      case n.RawDirection.ViewPortIfOutside:
        r = 14;
        break;
      default:
        return null;
    }
    let o = 0;
    switch (i.by) {
      case n.RawUnit.Line:
        o = 1;
        break;
      case n.RawUnit.WrappedLine:
        o = 2;
        break;
      case n.RawUnit.Character:
        o = 3;
        break;
      case n.RawUnit.HalfLine:
        o = 4;
        break;
    }
    return {
      direction: r,
      unit: o,
      select: !!i.select,
      value: i.value || 1
    };
  }
  n.parse = t;
})(jb || (jb = {}));
const UD = /* @__PURE__ */ Object.create(null);
function Hh(n, e) {
  if (e <= 0)
    return "";
  UD[n] || (UD[n] = ["", n]);
  const t = UD[n];
  for (let i = t.length; i <= e; i++)
    t[i] = t[i - 1] + n;
  return t[e];
}
class Gc {
  constructor(e, t) {
    this._opts = t, this._selection = e, this._selectionId = null, this._useLastEditRangeForCursorEndPosition = !1, this._selectionStartColumnStaysPut = !1;
  }
  static unshiftIndent(e, t, i, r, o) {
    const s = Kt.visibleColumnFromColumn(e, t, i);
    if (o) {
      const a = Hh(" ", r), u = Kt.prevIndentTabStop(s, r) / r;
      return Hh(a, u);
    } else {
      const a = "	", u = Kt.prevRenderTabStop(s, i) / i;
      return Hh(a, u);
    }
  }
  static shiftIndent(e, t, i, r, o) {
    const s = Kt.visibleColumnFromColumn(e, t, i);
    if (o) {
      const a = Hh(" ", r), u = Kt.nextIndentTabStop(s, r) / r;
      return Hh(a, u);
    } else {
      const a = "	", u = Kt.nextRenderTabStop(s, i) / i;
      return Hh(a, u);
    }
  }
  _addEditOperation(e, t, i) {
    this._useLastEditRangeForCursorEndPosition ? e.addTrackedEditOperation(t, i) : e.addEditOperation(t, i);
  }
  getEditOperations(e, t) {
    const i = this._selection.startLineNumber;
    let r = this._selection.endLineNumber;
    this._selection.endColumn === 1 && i !== r && (r = r - 1);
    const { tabSize: o, indentSize: s, insertSpaces: a } = this._opts, l = i === r;
    if (this._opts.useTabStops) {
      this._selection.isEmpty() && /^\s*$/.test(e.getLineContent(i)) && (this._useLastEditRangeForCursorEndPosition = !0);
      let u = 0, c = 0;
      for (let h = i; h <= r; h++, u = c) {
        c = 0;
        let d = e.getLineContent(h), f = Os(d);
        if (this._opts.isUnshift && (d.length === 0 || f === 0) || !l && !this._opts.isUnshift && d.length === 0)
          continue;
        if (f === -1 && (f = d.length), h > 1 && Kt.visibleColumnFromColumn(d, f + 1, o) % s !== 0 && e.isCheapToTokenize(h - 1)) {
          let _ = ui.getEnterAction(this._opts.autoIndent, e, new G(h - 1, e.getLineMaxColumn(h - 1), h - 1, e.getLineMaxColumn(h - 1)));
          if (_) {
            if (c = u, _.appendText)
              for (let m = 0, v = _.appendText.length; m < v && c < s && _.appendText.charCodeAt(m) === 32; m++)
                c++;
            _.removeText && (c = Math.max(0, c - _.removeText));
            for (let m = 0; m < c && !(f === 0 || d.charCodeAt(f - 1) !== 32); m++)
              f--;
          }
        }
        if (this._opts.isUnshift && f === 0)
          continue;
        let p;
        this._opts.isUnshift ? p = Gc.unshiftIndent(d, f + 1, o, s, a) : p = Gc.shiftIndent(d, f + 1, o, s, a), this._addEditOperation(t, new G(h, 1, h, f + 1), p), h === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn <= f + 1);
      }
    } else {
      !this._opts.isUnshift && this._selection.isEmpty() && e.getLineLength(i) === 0 && (this._useLastEditRangeForCursorEndPosition = !0);
      const u = a ? Hh(" ", s) : "	";
      for (let c = i; c <= r; c++) {
        const h = e.getLineContent(c);
        let d = Os(h);
        if (!(this._opts.isUnshift && (h.length === 0 || d === 0)) && !(!l && !this._opts.isUnshift && h.length === 0) && (d === -1 && (d = h.length), !(this._opts.isUnshift && d === 0)))
          if (this._opts.isUnshift) {
            d = Math.min(d, s);
            for (let f = 0; f < d; f++)
              if (h.charCodeAt(f) === 9) {
                d = f + 1;
                break;
              }
            this._addEditOperation(t, new G(c, 1, c, d + 1), "");
          } else
            this._addEditOperation(t, new G(c, 1, c, 1), u), c === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn === 1);
      }
    }
    this._selectionId = t.trackSelection(this._selection);
  }
  computeCursorState(e, t) {
    if (this._useLastEditRangeForCursorEndPosition) {
      let r = t.getInverseEditOperations()[0];
      return new Ut(r.range.endLineNumber, r.range.endColumn, r.range.endLineNumber, r.range.endColumn);
    }
    const i = t.getTrackedSelection(this._selectionId);
    if (this._selectionStartColumnStaysPut) {
      let r = this._selection.startColumn;
      return i.startColumn <= r ? i : i.getDirection() === 0 ? new Ut(i.startLineNumber, r, i.endLineNumber, i.endColumn) : new Ut(i.endLineNumber, i.endColumn, i.startLineNumber, r);
    }
    return i;
  }
}
class Yhe {
  constructor(e, t, i) {
    this._range = e, this._charBeforeSelection = t, this._charAfterSelection = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new G(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection), t.addTrackedEditOperation(new G(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
  }
  computeCursorState(e, t) {
    let i = t.getInverseEditOperations(), r = i[0].range, o = i[1].range;
    return new Ut(r.endLineNumber, r.endColumn, o.endLineNumber, o.endColumn - this._charAfterSelection.length);
  }
}
class Vi {
  static indent(e, t, i) {
    if (t === null || i === null)
      return [];
    let r = [];
    for (let o = 0, s = i.length; o < s; o++)
      r[o] = new Gc(i[o], {
        isUnshift: !1,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      });
    return r;
  }
  static outdent(e, t, i) {
    let r = [];
    for (let o = 0, s = i.length; o < s; o++)
      r[o] = new Gc(i[o], {
        isUnshift: !0,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      });
    return r;
  }
  static shiftIndent(e, t, i) {
    return i = i || 1, Gc.shiftIndent(t, t.length + i, e.tabSize, e.indentSize, e.insertSpaces);
  }
  static unshiftIndent(e, t, i) {
    return i = i || 1, Gc.unshiftIndent(t, t.length + i, e.tabSize, e.indentSize, e.insertSpaces);
  }
  static _distributedPaste(e, t, i, r) {
    let o = [];
    for (let s = 0, a = i.length; s < a; s++)
      o[s] = new _o(i[s], r[s]);
    return new vo(0, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _simplePaste(e, t, i, r, o) {
    let s = [];
    for (let a = 0, l = i.length; a < l; a++) {
      const u = i[a];
      let c = u.getPosition();
      if (o && !u.isEmpty() && (o = !1), o && r.indexOf(`
`) !== r.length - 1 && (o = !1), o) {
        let h = new G(c.lineNumber, 1, c.lineNumber, 1);
        s[a] = new qhe(h, r, u, !0);
      } else
        s[a] = new _o(u, r);
    }
    return new vo(0, s, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _distributePasteToCursors(e, t, i, r, o) {
    if (r || t.length === 1)
      return null;
    if (o && o.length === t.length)
      return o;
    if (e.multiCursorPaste === "spread") {
      i.charCodeAt(i.length - 1) === 10 && (i = i.substr(0, i.length - 1)), i.charCodeAt(i.length - 1) === 13 && (i = i.substr(0, i.length - 1));
      let s = z_(i);
      if (s.length === t.length)
        return s;
    }
    return null;
  }
  static paste(e, t, i, r, o, s) {
    const a = this._distributePasteToCursors(e, i, r, o, s);
    return a ? (i = i.sort(G.compareRangesUsingStarts), this._distributedPaste(e, t, i, a)) : this._simplePaste(e, t, i, r, o);
  }
  static _goodIndentForLine(e, t, i) {
    let r = null, o = "";
    const s = ui.getInheritIndentForLine(e.autoIndent, t, i, !1);
    if (s)
      r = s.action, o = s.indentation;
    else if (i > 1) {
      let a;
      for (a = i - 1; a >= 1; a--) {
        const c = t.getLineContent(a);
        if (Ng(c) >= 0)
          break;
      }
      if (a < 1)
        return null;
      const l = t.getLineMaxColumn(a), u = ui.getEnterAction(e.autoIndent, t, new G(a, l, a, l));
      u && (o = u.indentation + u.appendText);
    }
    return r && (r === Rn.Indent && (o = Vi.shiftIndent(e, o)), r === Rn.Outdent && (o = Vi.unshiftIndent(e, o)), o = e.normalizeIndentation(o)), o || null;
  }
  static _replaceJumpToNextIndent(e, t, i, r) {
    let o = "", s = i.getStartPosition();
    if (e.insertSpaces) {
      let a = Kt.visibleColumnFromColumn2(e, t, s), l = e.indentSize, u = l - a % l;
      for (let c = 0; c < u; c++)
        o += " ";
    } else
      o = "	";
    return new _o(i, o, r);
  }
  static tab(e, t, i) {
    let r = [];
    for (let o = 0, s = i.length; o < s; o++) {
      const a = i[o];
      if (a.isEmpty()) {
        let l = t.getLineContent(a.startLineNumber);
        if (/^\s*$/.test(l) && t.isCheapToTokenize(a.startLineNumber)) {
          let u = this._goodIndentForLine(e, t, a.startLineNumber);
          u = u || "	";
          let c = e.normalizeIndentation(u);
          if (!l.startsWith(c)) {
            r[o] = new _o(new G(a.startLineNumber, 1, a.startLineNumber, l.length + 1), c, !0);
            continue;
          }
        }
        r[o] = this._replaceJumpToNextIndent(e, t, a, !0);
      } else {
        if (a.startLineNumber === a.endLineNumber) {
          let l = t.getLineMaxColumn(a.startLineNumber);
          if (a.startColumn !== 1 || a.endColumn !== l) {
            r[o] = this._replaceJumpToNextIndent(e, t, a, !1);
            continue;
          }
        }
        r[o] = new Gc(a, {
          isUnshift: !1,
          tabSize: e.tabSize,
          indentSize: e.indentSize,
          insertSpaces: e.insertSpaces,
          useTabStops: e.useTabStops,
          autoIndent: e.autoIndent
        });
      }
    }
    return r;
  }
  static compositionType(e, t, i, r, o, s, a, l) {
    const u = r.map((c) => this._compositionType(i, c, o, s, a, l));
    return new vo(4, u, {
      shouldPushStackElementBefore: Oy(
        e,
        4
        /* TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
  static _compositionType(e, t, i, r, o, s) {
    if (!t.isEmpty())
      return null;
    const a = t.getPosition(), l = Math.max(1, a.column - r), u = Math.min(e.getLineMaxColumn(a.lineNumber), a.column + o), c = new G(a.lineNumber, l, a.lineNumber, u);
    return e.getValueInRange(c) === i && s === 0 ? null : new vw(c, i, 0, s);
  }
  static _typeCommand(e, t, i) {
    return i ? new Dy(e, t, !0) : new _o(e, t, !0);
  }
  static _enter(e, t, i, r) {
    if (e.autoIndent === 0)
      return Vi._typeCommand(r, `
`, i);
    if (!t.isCheapToTokenize(r.getStartPosition().lineNumber) || e.autoIndent === 1) {
      let l = t.getLineContent(r.startLineNumber), u = Fr(l).substring(0, r.startColumn - 1);
      return Vi._typeCommand(r, `
` + e.normalizeIndentation(u), i);
    }
    const o = ui.getEnterAction(e.autoIndent, t, r);
    if (o) {
      if (o.indentAction === Rn.None)
        return Vi._typeCommand(r, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
      if (o.indentAction === Rn.Indent)
        return Vi._typeCommand(r, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
      if (o.indentAction === Rn.IndentOutdent) {
        const l = e.normalizeIndentation(o.indentation), u = e.normalizeIndentation(o.indentation + o.appendText), c = `
` + u + `
` + l;
        return i ? new Dy(r, c, !0) : new vw(r, c, -1, u.length - l.length, !0);
      } else if (o.indentAction === Rn.Outdent) {
        const l = Vi.unshiftIndent(e, o.indentation);
        return Vi._typeCommand(r, `
` + e.normalizeIndentation(l + o.appendText), i);
      }
    }
    const s = t.getLineContent(r.startLineNumber), a = Fr(s).substring(0, r.startColumn - 1);
    if (e.autoIndent >= 4) {
      const l = ui.getIndentForEnter(e.autoIndent, t, r, {
        unshiftIndent: (u) => Vi.unshiftIndent(e, u),
        shiftIndent: (u) => Vi.shiftIndent(e, u),
        normalizeIndentation: (u) => e.normalizeIndentation(u)
      });
      if (l) {
        let u = Kt.visibleColumnFromColumn2(e, t, r.getEndPosition());
        const c = r.endColumn, h = t.getLineContent(r.endLineNumber), d = Os(h);
        if (d >= 0 ? r = r.setEndPosition(r.endLineNumber, Math.max(r.endColumn, d + 1)) : r = r.setEndPosition(r.endLineNumber, t.getLineMaxColumn(r.endLineNumber)), i)
          return new Dy(r, `
` + e.normalizeIndentation(l.afterEnter), !0);
        {
          let f = 0;
          return c <= d + 1 && (e.insertSpaces || (u = Math.ceil(u / e.indentSize)), f = Math.min(u + 1 - e.normalizeIndentation(l.afterEnter).length - 1, 0)), new vw(r, `
` + e.normalizeIndentation(l.afterEnter), 0, f, !0);
        }
      }
    }
    return Vi._typeCommand(r, `
` + e.normalizeIndentation(a), i);
  }
  static _isAutoIndentType(e, t, i) {
    if (e.autoIndent < 4)
      return !1;
    for (let r = 0, o = i.length; r < o; r++)
      if (!t.isCheapToTokenize(i[r].getEndPosition().lineNumber))
        return !1;
    return !0;
  }
  static _runAutoIndentType(e, t, i, r) {
    const o = ui.getIndentationAtPosition(t, i.startLineNumber, i.startColumn), s = ui.getIndentActionForType(e.autoIndent, t, i, r, {
      shiftIndent: (a) => Vi.shiftIndent(e, a),
      unshiftIndent: (a) => Vi.unshiftIndent(e, a)
    });
    if (s === null)
      return null;
    if (s !== e.normalizeIndentation(o)) {
      const a = t.getLineFirstNonWhitespaceColumn(i.startLineNumber);
      return a === 0 ? Vi._typeCommand(new G(i.startLineNumber, 1, i.endLineNumber, i.endColumn), e.normalizeIndentation(s) + r, !1) : Vi._typeCommand(new G(i.startLineNumber, 1, i.endLineNumber, i.endColumn), e.normalizeIndentation(s) + t.getLineContent(i.startLineNumber).substring(a - 1, i.startColumn - 1) + r, !1);
    }
    return null;
  }
  static _isAutoClosingOvertype(e, t, i, r, o) {
    if (e.autoClosingOvertype === "never" || !e.autoClosingPairs.autoClosingPairsCloseSingleChar.has(o))
      return !1;
    for (let s = 0, a = i.length; s < a; s++) {
      const l = i[s];
      if (!l.isEmpty())
        return !1;
      const u = l.getPosition(), c = t.getLineContent(u.lineNumber);
      if (c.charAt(u.column - 1) !== o)
        return !1;
      const d = Yf(o);
      if ((u.column > 2 ? c.charCodeAt(u.column - 2) : 0) === 92 && d)
        return !1;
      if (e.autoClosingOvertype === "auto") {
        let p = !1;
        for (let g = 0, _ = r.length; g < _; g++) {
          const m = r[g];
          if (u.lineNumber === m.startLineNumber && u.column === m.startColumn) {
            p = !0;
            break;
          }
        }
        if (!p)
          return !1;
      }
    }
    return !0;
  }
  static _runAutoClosingOvertype(e, t, i, r, o) {
    let s = [];
    for (let a = 0, l = r.length; a < l; a++) {
      const c = r[a].getPosition(), h = new G(c.lineNumber, c.column, c.lineNumber, c.column + 1);
      s[a] = new _o(h, o);
    }
    return new vo(4, s, {
      shouldPushStackElementBefore: Oy(
        e,
        4
        /* TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
  static _isBeforeClosingBrace(e, t) {
    const i = t.charAt(0), r = e.autoClosingPairs.autoClosingPairsOpenByStart.get(i) || [], o = e.autoClosingPairs.autoClosingPairsCloseByStart.get(i) || [], s = r.some((l) => t.startsWith(l.open)), a = o.some((l) => t.startsWith(l.close));
    return !s && a;
  }
  static _findAutoClosingPairOpen(e, t, i, r) {
    const o = e.autoClosingPairs.autoClosingPairsOpenByEnd.get(r);
    if (!o)
      return null;
    let s = null;
    for (const a of o)
      if (s === null || a.open.length > s.open.length) {
        let l = !0;
        for (const u of i)
          if (t.getValueInRange(new G(u.lineNumber, u.column - a.open.length + 1, u.lineNumber, u.column)) + r !== a.open) {
            l = !1;
            break;
          }
        l && (s = a);
      }
    return s;
  }
  static _findSubAutoClosingPairClose(e, t) {
    if (t.open.length <= 1)
      return "";
    const i = t.close.charAt(t.close.length - 1), r = e.autoClosingPairs.autoClosingPairsCloseByEnd.get(i) || [];
    let o = null;
    for (const s of r)
      s.open !== t.open && t.open.includes(s.open) && t.close.endsWith(s.close) && (!o || s.open.length > o.open.length) && (o = s);
    return o ? o.close : "";
  }
  static _getAutoClosingPairClose(e, t, i, r, o) {
    const s = Yf(r), a = s ? e.autoClosingQuotes : e.autoClosingBrackets;
    if (a === "never")
      return null;
    const l = this._findAutoClosingPairOpen(e, t, i.map((d) => d.getPosition()), r);
    if (!l)
      return null;
    const u = this._findSubAutoClosingPairClose(e, l);
    let c = !0;
    const h = s ? e.shouldAutoCloseBefore.quote : e.shouldAutoCloseBefore.bracket;
    for (let d = 0, f = i.length; d < f; d++) {
      const p = i[d];
      if (!p.isEmpty())
        return null;
      const g = p.getPosition(), _ = t.getLineContent(g.lineNumber), m = _.substring(g.column - 1);
      if (m.startsWith(u) || (c = !1), _.length > g.column - 1) {
        const y = _.charAt(g.column - 1);
        if (!Vi._isBeforeClosingBrace(e, m) && !h(y))
          return null;
      }
      if (!t.isCheapToTokenize(g.lineNumber))
        return null;
      if (l.open.length === 1 && s && a !== "always") {
        const y = tg(e.wordSeparators);
        if (o && g.column > 1 && y.get(_.charCodeAt(g.column - 2)) === 0 || !o && g.column > 2 && y.get(_.charCodeAt(g.column - 3)) === 0)
          return null;
      }
      t.forceTokenization(g.lineNumber);
      const v = t.getLineTokens(g.lineNumber);
      let C = !1;
      try {
        C = ui.shouldAutoClosePair(l, v, o ? g.column : g.column - 1);
      } catch (y) {
        Pi(y);
      }
      if (!C)
        return null;
    }
    return c ? l.close.substring(0, l.close.length - u.length) : l.close;
  }
  static _runAutoClosingOpenCharType(e, t, i, r, o, s, a) {
    let l = [];
    for (let u = 0, c = r.length; u < c; u++) {
      const h = r[u];
      l[u] = new t7(h, o, s, a);
    }
    return new vo(4, l, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !1
    });
  }
  static _shouldSurroundChar(e, t) {
    return Yf(t) ? e.autoSurround === "quotes" || e.autoSurround === "languageDefined" : e.autoSurround === "brackets" || e.autoSurround === "languageDefined";
  }
  static _isSurroundSelectionType(e, t, i, r) {
    if (!Vi._shouldSurroundChar(e, r) || !e.surroundingPairs.hasOwnProperty(r))
      return !1;
    const o = Yf(r);
    for (let s = 0, a = i.length; s < a; s++) {
      const l = i[s];
      if (l.isEmpty())
        return !1;
      let u = !0;
      for (let c = l.startLineNumber; c <= l.endLineNumber; c++) {
        const h = t.getLineContent(c), d = c === l.startLineNumber ? l.startColumn - 1 : 0, f = c === l.endLineNumber ? l.endColumn - 1 : h.length, p = h.substring(d, f);
        if (/[^ \t]/.test(p)) {
          u = !1;
          break;
        }
      }
      if (u)
        return !1;
      if (o && l.startLineNumber === l.endLineNumber && l.startColumn + 1 === l.endColumn) {
        const c = t.getValueInRange(l);
        if (Yf(c))
          return !1;
      }
    }
    return !0;
  }
  static _runSurroundSelectionType(e, t, i, r, o) {
    let s = [];
    for (let a = 0, l = r.length; a < l; a++) {
      const u = r[a], c = t.surroundingPairs[o];
      s[a] = new Yhe(u, o, c);
    }
    return new vo(0, s, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _isTypeInterceptorElectricChar(e, t, i) {
    return !!(i.length === 1 && t.isCheapToTokenize(i[0].getEndPosition().lineNumber));
  }
  static _typeInterceptorElectricChar(e, t, i, r, o) {
    if (!t.electricChars.hasOwnProperty(o) || !r.isEmpty())
      return null;
    let s = r.getPosition();
    i.forceTokenization(s.lineNumber);
    let a = i.getLineTokens(s.lineNumber), l;
    try {
      l = ui.onElectricCharacter(o, a, s.column);
    } catch (u) {
      return Pi(u), null;
    }
    if (!l)
      return null;
    if (l.matchOpenBracket) {
      let u = (a.getLineContent() + o).lastIndexOf(l.matchOpenBracket) + 1, c = i.findMatchingBracketUp(l.matchOpenBracket, {
        lineNumber: s.lineNumber,
        column: u
      });
      if (c) {
        if (c.startLineNumber === s.lineNumber)
          return null;
        let h = i.getLineContent(c.startLineNumber), d = Fr(h), f = t.normalizeIndentation(d), p = i.getLineContent(s.lineNumber), g = i.getLineFirstNonWhitespaceColumn(s.lineNumber) || s.column, _ = p.substring(g - 1, s.column - 1), m = f + _ + o, v = new G(s.lineNumber, 1, s.lineNumber, s.column);
        const C = new _o(v, m);
        return new vo(zD(m, e), [C], {
          shouldPushStackElementBefore: !1,
          shouldPushStackElementAfter: !0
        });
      }
    }
    return null;
  }
  /**
   * This is very similar with typing, but the character is already in the text buffer!
   */
  static compositionEndWithInterceptors(e, t, i, r, o, s) {
    if (!r || Ut.selectionsArrEqual(r, o))
      return null;
    let a = null;
    for (const u of o) {
      if (!u.isEmpty())
        return null;
      const c = u.getPosition(), h = i.getValueInRange(new G(c.lineNumber, c.column - 1, c.lineNumber, c.column));
      if (a === null)
        a = h;
      else if (a !== h)
        return null;
    }
    if (!a)
      return null;
    if (this._isAutoClosingOvertype(t, i, o, s, a)) {
      const u = o.map((c) => new _o(new G(c.positionLineNumber, c.positionColumn, c.positionLineNumber, c.positionColumn + 1), "", !1));
      return new vo(4, u, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    const l = this._getAutoClosingPairClose(t, i, o, a, !1);
    return l !== null ? this._runAutoClosingOpenCharType(e, t, i, o, a, !1, l) : null;
  }
  static typeWithInterceptors(e, t, i, r, o, s, a) {
    if (!e && a === `
`) {
      let c = [];
      for (let h = 0, d = o.length; h < d; h++)
        c[h] = Vi._enter(i, r, !1, o[h]);
      return new vo(4, c, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    if (!e && this._isAutoIndentType(i, r, o)) {
      let c = [], h = !1;
      for (let d = 0, f = o.length; d < f; d++)
        if (c[d] = this._runAutoIndentType(i, r, o[d], a), !c[d]) {
          h = !0;
          break;
        }
      if (!h)
        return new vo(4, c, {
          shouldPushStackElementBefore: !0,
          shouldPushStackElementAfter: !1
        });
    }
    if (!e && this._isAutoClosingOvertype(i, r, o, s, a))
      return this._runAutoClosingOvertype(t, i, r, o, a);
    if (!e) {
      const c = this._getAutoClosingPairClose(i, r, o, a, !0);
      if (c)
        return this._runAutoClosingOpenCharType(t, i, r, o, a, !0, c);
    }
    if (this._isSurroundSelectionType(i, r, o, a))
      return this._runSurroundSelectionType(t, i, r, o, a);
    if (!e && this._isTypeInterceptorElectricChar(i, r, o)) {
      const c = this._typeInterceptorElectricChar(t, i, r, o[0], a);
      if (c)
        return c;
    }
    let l = [];
    for (let c = 0, h = o.length; c < h; c++)
      l[c] = new _o(o[c], a);
    const u = zD(a, t);
    return new vo(u, l, {
      shouldPushStackElementBefore: Oy(t, u),
      shouldPushStackElementAfter: !1
    });
  }
  static typeWithoutInterceptors(e, t, i, r, o) {
    let s = [];
    for (let l = 0, u = r.length; l < u; l++)
      s[l] = new _o(r[l], o);
    const a = zD(o, e);
    return new vo(a, s, {
      shouldPushStackElementBefore: Oy(e, a),
      shouldPushStackElementAfter: !1
    });
  }
  static lineInsertBefore(e, t, i) {
    if (t === null || i === null)
      return [];
    let r = [];
    for (let o = 0, s = i.length; o < s; o++) {
      let a = i[o].positionLineNumber;
      if (a === 1)
        r[o] = new Dy(new G(1, 1, 1, 1), `
`);
      else {
        a--;
        let l = t.getLineMaxColumn(a);
        r[o] = this._enter(e, t, !1, new G(a, l, a, l));
      }
    }
    return r;
  }
  static lineInsertAfter(e, t, i) {
    if (t === null || i === null)
      return [];
    let r = [];
    for (let o = 0, s = i.length; o < s; o++) {
      const a = i[o].positionLineNumber;
      let l = t.getLineMaxColumn(a);
      r[o] = this._enter(e, t, !1, new G(a, l, a, l));
    }
    return r;
  }
  static lineBreakInsert(e, t, i) {
    let r = [];
    for (let o = 0, s = i.length; o < s; o++)
      r[o] = this._enter(e, t, !0, i[o]);
    return r;
  }
}
class t7 extends vw {
  constructor(e, t, i, r) {
    super(e, (i ? t : "") + r, 0, -r.length), this._openCharacter = t, this._closeCharacter = r, this.closeCharacterRange = null, this.enclosingRange = null;
  }
  computeCursorState(e, t) {
    let r = t.getInverseEditOperations()[0].range;
    return this.closeCharacterRange = new G(r.startLineNumber, r.endColumn - this._closeCharacter.length, r.endLineNumber, r.endColumn), this.enclosingRange = new G(r.startLineNumber, r.endColumn - this._openCharacter.length - this._closeCharacter.length, r.endLineNumber, r.endColumn), super.computeCursorState(e, t);
  }
}
function zD(n, e) {
  return n === " " ? e === 5 || e === 6 ? 6 : 5 : 4;
}
function Oy(n, e) {
  return Y2(n) && !Y2(e) ? !0 : n === 5 ? !1 : q2(n) !== q2(e);
}
function q2(n) {
  return n === 6 || n === 5 ? "space" : n;
}
function Y2(n) {
  return n === 4 || n === 5 || n === 6;
}
var Re;
(function(n) {
  n.editorSimpleInput = new nt("editorSimpleInput", !1, !0), n.editorTextFocus = new nt("editorTextFocus", !1, b("editorTextFocus", "Whether the editor text has focus (cursor is blinking)")), n.focus = new nt("editorFocus", !1, b("editorFocus", "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)")), n.textInputFocus = new nt("textInputFocus", !1, b("textInputFocus", "Whether an editor or a rich text input has focus (cursor is blinking)")), n.readOnly = new nt("editorReadonly", !1, b("editorReadonly", "Whether the editor is read only")), n.inDiffEditor = new nt("inDiffEditor", !1, b("inDiffEditor", "Whether the context is a diff editor")), n.columnSelection = new nt("editorColumnSelection", !1, b("editorColumnSelection", "Whether `editor.columnSelection` is enabled")), n.writable = n.readOnly.toNegated(), n.hasNonEmptySelection = new nt("editorHasSelection", !1, b("editorHasSelection", "Whether the editor has text selected")), n.hasOnlyEmptySelection = n.hasNonEmptySelection.toNegated(), n.hasMultipleSelections = new nt("editorHasMultipleSelections", !1, b("editorHasMultipleSelections", "Whether the editor has multiple selections")), n.hasSingleSelection = n.hasMultipleSelections.toNegated(), n.tabMovesFocus = new nt("editorTabMovesFocus", !1, b("editorTabMovesFocus", "Whether `Tab` will move focus out of the editor")), n.tabDoesNotMoveFocus = n.tabMovesFocus.toNegated(), n.isInWalkThroughSnippet = new nt("isInEmbeddedEditor", !1, !0), n.canUndo = new nt("canUndo", !1, !0), n.canRedo = new nt("canRedo", !1, !0), n.hoverVisible = new nt("editorHoverVisible", !1, b("editorHoverVisible", "Whether the editor hover is visible")), n.inCompositeEditor = new nt("inCompositeEditor", void 0, b("inCompositeEditor", "Whether the editor is part of a larger editor (e.g. notebooks)")), n.notInCompositeEditor = n.inCompositeEditor.toNegated(), n.languageId = new nt("editorLangId", "", b("editorLangId", "The language identifier of the editor")), n.hasCompletionItemProvider = new nt("editorHasCompletionItemProvider", !1, b("editorHasCompletionItemProvider", "Whether the editor has a completion item provider")), n.hasCodeActionsProvider = new nt("editorHasCodeActionsProvider", !1, b("editorHasCodeActionsProvider", "Whether the editor has a code actions provider")), n.hasCodeLensProvider = new nt("editorHasCodeLensProvider", !1, b("editorHasCodeLensProvider", "Whether the editor has a code lens provider")), n.hasDefinitionProvider = new nt("editorHasDefinitionProvider", !1, b("editorHasDefinitionProvider", "Whether the editor has a definition provider")), n.hasDeclarationProvider = new nt("editorHasDeclarationProvider", !1, b("editorHasDeclarationProvider", "Whether the editor has a declaration provider")), n.hasImplementationProvider = new nt("editorHasImplementationProvider", !1, b("editorHasImplementationProvider", "Whether the editor has an implementation provider")), n.hasTypeDefinitionProvider = new nt("editorHasTypeDefinitionProvider", !1, b("editorHasTypeDefinitionProvider", "Whether the editor has a type definition provider")), n.hasHoverProvider = new nt("editorHasHoverProvider", !1, b("editorHasHoverProvider", "Whether the editor has a hover provider")), n.hasDocumentHighlightProvider = new nt("editorHasDocumentHighlightProvider", !1, b("editorHasDocumentHighlightProvider", "Whether the editor has a document highlight provider")), n.hasDocumentSymbolProvider = new nt("editorHasDocumentSymbolProvider", !1, b("editorHasDocumentSymbolProvider", "Whether the editor has a document symbol provider")), n.hasReferenceProvider = new nt("editorHasReferenceProvider", !1, b("editorHasReferenceProvider", "Whether the editor has a reference provider")), n.hasRenameProvider = new nt("editorHasRenameProvider", !1, b("editorHasRenameProvider", "Whether the editor has a rename provider")), n.hasSignatureHelpProvider = new nt("editorHasSignatureHelpProvider", !1, b("editorHasSignatureHelpProvider", "Whether the editor has a signature help provider")), n.hasInlayHintsProvider = new nt("editorHasInlayHintsProvider", !1, b("editorHasInlayHintsProvider", "Whether the editor has an inline hints provider")), n.hasDocumentFormattingProvider = new nt("editorHasDocumentFormattingProvider", !1, b("editorHasDocumentFormattingProvider", "Whether the editor has a document formatting provider")), n.hasDocumentSelectionFormattingProvider = new nt("editorHasDocumentSelectionFormattingProvider", !1, b("editorHasDocumentSelectionFormattingProvider", "Whether the editor has a document selection formatting provider")), n.hasMultipleDocumentFormattingProvider = new nt("editorHasMultipleDocumentFormattingProvider", !1, b("editorHasMultipleDocumentFormattingProvider", "Whether the editor has multiple document formatting providers")), n.hasMultipleDocumentSelectionFormattingProvider = new nt("editorHasMultipleDocumentSelectionFormattingProvider", !1, b("editorHasMultipleDocumentSelectionFormattingProvider", "Whether the editor has multiple document selection formatting providers"));
})(Re || (Re = {}));
const yt = 0;
class ji extends Mg {
  runEditorCommand(e, t, i) {
    const r = t._getViewModel();
    r && this.runCoreEditorCommand(r, i || {});
  }
}
var $b;
(function(n) {
  const e = function(i) {
    if (!Uo(i))
      return !1;
    const r = i;
    return !(!il(r.to) || !xs(r.by) && !il(r.by) || !xs(r.value) && !j_(r.value) || !xs(r.revealCursor) && !S5(r.revealCursor));
  };
  n.description = {
    description: "Scroll editor in the given direction",
    args: [
      {
        name: "Editor scroll argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'to': A mandatory direction value.\n						```\n						'up', 'down'\n						```\n					* 'by': Unit to move. Default is computed based on 'to' value.\n						```\n						'line', 'wrappedLine', 'page', 'halfPage'\n						```\n					* 'value': Number of units to move. Default is '1'.\n					* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["up", "down"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "page", "halfPage"]
            },
            value: {
              type: "number",
              default: 1
            },
            revealCursor: {
              type: "boolean"
            }
          }
        }
      }
    ]
  }, n.RawDirection = {
    Up: "up",
    Down: "down"
  }, n.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Page: "page",
    HalfPage: "halfPage"
  };
  function t(i) {
    let r;
    switch (i.to) {
      case n.RawDirection.Up:
        r = 1;
        break;
      case n.RawDirection.Down:
        r = 2;
        break;
      default:
        return null;
    }
    let o;
    switch (i.by) {
      case n.RawUnit.Line:
        o = 1;
        break;
      case n.RawUnit.WrappedLine:
        o = 2;
        break;
      case n.RawUnit.Page:
        o = 3;
        break;
      case n.RawUnit.HalfPage:
        o = 4;
        break;
      default:
        o = 2;
    }
    const s = Math.floor(i.value || 1), a = !!i.revealCursor;
    return {
      direction: r,
      unit: o,
      value: s,
      revealCursor: a,
      select: !!i.select
    };
  }
  n.parse = t;
})($b || ($b = {}));
var up;
(function(n) {
  const e = function(t) {
    if (!Uo(t))
      return !1;
    const i = t;
    return !(!j_(i.lineNumber) && !il(i.lineNumber) || !xs(i.at) && !il(i.at));
  };
  n.description = {
    description: "Reveal the given line at the given logical position",
    args: [
      {
        name: "Reveal line argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'lineNumber': A mandatory line number value.\n					* 'at': Logical position at which line has to be revealed.\n						```\n						'top', 'center', 'bottom'\n						```\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["lineNumber"],
          properties: {
            lineNumber: {
              type: ["number", "string"]
            },
            at: {
              type: "string",
              enum: ["top", "center", "bottom"]
            }
          }
        }
      }
    ]
  }, n.RawAtArgument = {
    Top: "top",
    Center: "center",
    Bottom: "bottom"
  };
})(up || (up = {}));
class nO {
  constructor(e) {
    e.addImplementation(1e4, "code-editor", (t, i) => {
      const r = t.get(mr).getFocusedCodeEditor();
      return r && r.hasTextFocus() ? this._runEditorCommand(t, r, i) : !1;
    }), e.addImplementation(1e3, "generic-dom-input-textarea", (t, i) => {
      const r = document.activeElement;
      return r && ["input", "textarea"].indexOf(r.tagName.toLowerCase()) >= 0 ? (this.runDOMCommand(), !0) : !1;
    }), e.addImplementation(0, "generic-dom", (t, i) => {
      const r = t.get(mr).getActiveCodeEditor();
      return r ? (r.focus(), this._runEditorCommand(t, r, i)) : !1;
    });
  }
  _runEditorCommand(e, t, i) {
    const r = this.runEditorCommand(e, t, i);
    return r || !0;
  }
}
var Ln;
(function(n) {
  class e extends ji {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, [
        sr.moveTo(v, v.getPrimaryCursorState(), this._inSelectionMode, C.position, C.viewPosition)
      ]), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.MoveTo = Ze(new e({
    id: "_moveTo",
    inSelectionMode: !1,
    precondition: void 0
  })), n.MoveToSelect = Ze(new e({
    id: "_moveToSelect",
    inSelectionMode: !0,
    precondition: void 0
  }));
  class t extends ji {
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement();
      const y = this._getColumnSelectResult(v, v.getPrimaryCursorState(), v.getCursorColumnSelectData(), C);
      v.setCursorStates(C.source, 3, y.viewStates.map((w) => at.fromViewState(w))), v.setCursorColumnSelectData({
        isReal: !0,
        fromViewLineNumber: y.fromLineNumber,
        fromViewVisualColumn: y.fromVisualColumn,
        toViewLineNumber: y.toLineNumber,
        toViewVisualColumn: y.toVisualColumn
      }), y.reversed ? v.revealTopMostCursor(C.source) : v.revealBottomMostCursor(C.source);
    }
  }
  n.ColumnSelect = Ze(new class extends t {
    constructor() {
      super({
        id: "columnSelect",
        precondition: void 0
      });
    }
    _getColumnSelectResult(m, v, C, y) {
      const w = m.model.validatePosition(y.position), L = m.coordinatesConverter.validateViewPosition(new ie(y.viewPosition.lineNumber, y.viewPosition.column), w);
      let S = y.doColumnSelect ? C.fromViewLineNumber : L.lineNumber, E = y.doColumnSelect ? C.fromViewVisualColumn : y.mouseColumn - 1;
      return id.columnSelect(m.cursorConfig, m, S, E, L.lineNumber, y.mouseColumn - 1);
    }
  }()), n.CursorColumnSelectLeft = Ze(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectLeft",
        precondition: void 0,
        kbOpts: {
          weight: yt,
          kbExpr: Re.textInputFocus,
          primary: 3599,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(m, v, C, y) {
      return id.columnSelectLeft(m.cursorConfig, m, C);
    }
  }()), n.CursorColumnSelectRight = Ze(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectRight",
        precondition: void 0,
        kbOpts: {
          weight: yt,
          kbExpr: Re.textInputFocus,
          primary: 3601,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(m, v, C, y) {
      return id.columnSelectRight(m.cursorConfig, m, C);
    }
  }());
  class i extends t {
    constructor(v) {
      super(v), this._isPaged = v.isPaged;
    }
    _getColumnSelectResult(v, C, y, w) {
      return id.columnSelectUp(v.cursorConfig, v, y, this._isPaged);
    }
  }
  n.CursorColumnSelectUp = Ze(new i({
    isPaged: !1,
    id: "cursorColumnSelectUp",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 3600,
      linux: { primary: 0 }
    }
  })), n.CursorColumnSelectPageUp = Ze(new i({
    isPaged: !0,
    id: "cursorColumnSelectPageUp",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 3595,
      linux: { primary: 0 }
    }
  }));
  class r extends t {
    constructor(v) {
      super(v), this._isPaged = v.isPaged;
    }
    _getColumnSelectResult(v, C, y, w) {
      return id.columnSelectDown(v.cursorConfig, v, y, this._isPaged);
    }
  }
  n.CursorColumnSelectDown = Ze(new r({
    isPaged: !1,
    id: "cursorColumnSelectDown",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 3602,
      linux: { primary: 0 }
    }
  })), n.CursorColumnSelectPageDown = Ze(new r({
    isPaged: !0,
    id: "cursorColumnSelectPageDown",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 3596,
      linux: { primary: 0 }
    }
  }));
  class o extends ji {
    constructor() {
      super({
        id: "cursorMove",
        precondition: void 0,
        description: jb.description
      });
    }
    runCoreEditorCommand(v, C) {
      const y = jb.parse(C);
      y && this._runCursorMove(v, C.source, y);
    }
    _runCursorMove(v, C, y) {
      v.model.pushStackElement(), v.setCursorStates(C, 3, o._move(v, v.getCursorStates(), y)), v.revealPrimaryCursor(C, !0);
    }
    static _move(v, C, y) {
      const w = y.select, L = y.value;
      switch (y.direction) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
          return sr.simpleMove(v, C, y.direction, w, L, y.unit);
        case 11:
        case 13:
        case 12:
        case 14:
          return sr.viewportMove(v, C, y.direction, w, L);
        default:
          return null;
      }
    }
  }
  n.CursorMoveImpl = o, n.CursorMove = Ze(new o());
  class s extends ji {
    constructor(v) {
      super(v), this._staticArgs = v.args;
    }
    runCoreEditorCommand(v, C) {
      let y = this._staticArgs;
      this._staticArgs.value === -1 && (y = {
        direction: this._staticArgs.direction,
        unit: this._staticArgs.unit,
        select: this._staticArgs.select,
        value: v.cursorConfig.pageSize
      }), v.model.pushStackElement(), v.setCursorStates(C.source, 3, sr.simpleMove(v, v.getCursorStates(), y.direction, y.select, y.value, y.unit)), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.CursorLeft = Ze(new s({
    args: {
      direction: 0,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorLeft",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 15,
      mac: { primary: 15, secondary: [
        288
        /* KEY_B */
      ] }
    }
  })), n.CursorLeftSelect = Ze(new s({
    args: {
      direction: 0,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorLeftSelect",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 1039
      /* LeftArrow */
    }
  })), n.CursorRight = Ze(new s({
    args: {
      direction: 1,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorRight",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 17,
      mac: { primary: 17, secondary: [
        292
        /* KEY_F */
      ] }
    }
  })), n.CursorRightSelect = Ze(new s({
    args: {
      direction: 1,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorRightSelect",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 1041
      /* RightArrow */
    }
  })), n.CursorUp = Ze(new s({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorUp",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 16,
      mac: { primary: 16, secondary: [
        302
        /* KEY_P */
      ] }
    }
  })), n.CursorUpSelect = Ze(new s({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 1040,
      secondary: [
        3088
        /* UpArrow */
      ],
      mac: {
        primary: 1040
        /* UpArrow */
      },
      linux: {
        primary: 1040
        /* UpArrow */
      }
    }
  })), n.CursorPageUp = Ze(new s({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: -1
      /* PAGE_SIZE_MARKER */
    },
    id: "cursorPageUp",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 11
      /* PageUp */
    }
  })), n.CursorPageUpSelect = Ze(new s({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: -1
      /* PAGE_SIZE_MARKER */
    },
    id: "cursorPageUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 1035
      /* PageUp */
    }
  })), n.CursorDown = Ze(new s({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorDown",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 18,
      mac: { primary: 18, secondary: [
        300
        /* KEY_N */
      ] }
    }
  })), n.CursorDownSelect = Ze(new s({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 1042,
      secondary: [
        3090
        /* DownArrow */
      ],
      mac: {
        primary: 1042
        /* DownArrow */
      },
      linux: {
        primary: 1042
        /* DownArrow */
      }
    }
  })), n.CursorPageDown = Ze(new s({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: -1
      /* PAGE_SIZE_MARKER */
    },
    id: "cursorPageDown",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 12
      /* PageDown */
    }
  })), n.CursorPageDownSelect = Ze(new s({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: -1
      /* PAGE_SIZE_MARKER */
    },
    id: "cursorPageDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 1036
      /* PageDown */
    }
  })), n.CreateCursor = Ze(new class extends ji {
    constructor() {
      super({
        id: "createCursor",
        precondition: void 0
      });
    }
    runCoreEditorCommand(m, v) {
      let C;
      v.wholeLine ? C = sr.line(m, m.getPrimaryCursorState(), !1, v.position, v.viewPosition) : C = sr.moveTo(m, m.getPrimaryCursorState(), !1, v.position, v.viewPosition);
      const y = m.getCursorStates();
      if (y.length > 1) {
        const w = C.modelState ? C.modelState.position : null, L = C.viewState ? C.viewState.position : null;
        for (let S = 0, E = y.length; S < E; S++) {
          const D = y[S];
          if (!(w && !D.modelState.selection.containsPosition(w)) && !(L && !D.viewState.selection.containsPosition(L))) {
            y.splice(S, 1), m.model.pushStackElement(), m.setCursorStates(v.source, 3, y);
            return;
          }
        }
      }
      y.push(C), m.model.pushStackElement(), m.setCursorStates(v.source, 3, y);
    }
  }()), n.LastCursorMoveToSelect = Ze(new class extends ji {
    constructor() {
      super({
        id: "_lastCursorMoveToSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(m, v) {
      const C = m.getLastAddedCursorIndex(), y = m.getCursorStates(), w = y.slice(0);
      w[C] = sr.moveTo(m, y[C], !0, v.position, v.viewPosition), m.model.pushStackElement(), m.setCursorStates(v.source, 3, w);
    }
  }());
  class a extends ji {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, sr.moveToBeginningOfLine(v, v.getCursorStates(), this._inSelectionMode)), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.CursorHome = Ze(new a({
    inSelectionMode: !1,
    id: "cursorHome",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 14,
      mac: { primary: 14, secondary: [
        2063
        /* LeftArrow */
      ] }
    }
  })), n.CursorHomeSelect = Ze(new a({
    inSelectionMode: !0,
    id: "cursorHomeSelect",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 1038,
      mac: { primary: 1038, secondary: [
        3087
        /* LeftArrow */
      ] }
    }
  }));
  class l extends ji {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, this._exec(v.getCursorStates())), v.revealPrimaryCursor(C.source, !0);
    }
    _exec(v) {
      const C = [];
      for (let y = 0, w = v.length; y < w; y++) {
        const L = v[y], S = L.modelState.position.lineNumber;
        C[y] = at.fromModelState(L.modelState.move(this._inSelectionMode, S, 1, 0));
      }
      return C;
    }
  }
  n.CursorLineStart = Ze(new l({
    inSelectionMode: !1,
    id: "cursorLineStart",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 0,
      mac: {
        primary: 287
        /* KEY_A */
      }
    }
  })), n.CursorLineStartSelect = Ze(new l({
    inSelectionMode: !0,
    id: "cursorLineStartSelect",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 0,
      mac: {
        primary: 1311
        /* KEY_A */
      }
    }
  }));
  class u extends ji {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, sr.moveToEndOfLine(v, v.getCursorStates(), this._inSelectionMode, C.sticky || !1)), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.CursorEnd = Ze(new u({
    inSelectionMode: !1,
    id: "cursorEnd",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 13,
      mac: { primary: 13, secondary: [
        2065
        /* RightArrow */
      ] }
    },
    description: {
      description: "Go to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: b("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  })), n.CursorEndSelect = Ze(new u({
    inSelectionMode: !0,
    id: "cursorEndSelect",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 1037,
      mac: { primary: 1037, secondary: [
        3089
        /* RightArrow */
      ] }
    },
    description: {
      description: "Select to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: b("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  }));
  class c extends ji {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, this._exec(v, v.getCursorStates())), v.revealPrimaryCursor(C.source, !0);
    }
    _exec(v, C) {
      const y = [];
      for (let w = 0, L = C.length; w < L; w++) {
        const S = C[w], E = S.modelState.position.lineNumber, D = v.model.getLineMaxColumn(E);
        y[w] = at.fromModelState(S.modelState.move(this._inSelectionMode, E, D, 0));
      }
      return y;
    }
  }
  n.CursorLineEnd = Ze(new c({
    inSelectionMode: !1,
    id: "cursorLineEnd",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 0,
      mac: {
        primary: 291
        /* KEY_E */
      }
    }
  })), n.CursorLineEndSelect = Ze(new c({
    inSelectionMode: !0,
    id: "cursorLineEndSelect",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 0,
      mac: {
        primary: 1315
        /* KEY_E */
      }
    }
  }));
  class h extends ji {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, sr.moveToBeginningOfBuffer(v, v.getCursorStates(), this._inSelectionMode)), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.CursorTop = Ze(new h({
    inSelectionMode: !1,
    id: "cursorTop",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 2062,
      mac: {
        primary: 2064
        /* UpArrow */
      }
    }
  })), n.CursorTopSelect = Ze(new h({
    inSelectionMode: !0,
    id: "cursorTopSelect",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 3086,
      mac: {
        primary: 3088
        /* UpArrow */
      }
    }
  }));
  class d extends ji {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, sr.moveToEndOfBuffer(v, v.getCursorStates(), this._inSelectionMode)), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.CursorBottom = Ze(new d({
    inSelectionMode: !1,
    id: "cursorBottom",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 2061,
      mac: {
        primary: 2066
        /* DownArrow */
      }
    }
  })), n.CursorBottomSelect = Ze(new d({
    inSelectionMode: !0,
    id: "cursorBottomSelect",
    precondition: void 0,
    kbOpts: {
      weight: yt,
      kbExpr: Re.textInputFocus,
      primary: 3085,
      mac: {
        primary: 3090
        /* DownArrow */
      }
    }
  }));
  class f extends ji {
    constructor() {
      super({
        id: "editorScroll",
        precondition: void 0,
        description: $b.description
      });
    }
    runCoreEditorCommand(v, C) {
      const y = $b.parse(C);
      y && this._runEditorScroll(v, C.source, y);
    }
    _runEditorScroll(v, C, y) {
      const w = this._computeDesiredScrollTop(v, y);
      if (y.revealCursor) {
        const L = v.getCompletelyVisibleViewRangeAtScrollTop(w);
        v.setCursorStates(C, 3, [
          sr.findPositionInViewportIfOutside(v, v.getPrimaryCursorState(), L, y.select)
        ]);
      }
      v.setScrollTop(
        w,
        0
        /* Smooth */
      );
    }
    _computeDesiredScrollTop(v, C) {
      if (C.unit === 1) {
        const L = v.getCompletelyVisibleViewRange(), S = v.coordinatesConverter.convertViewRangeToModelRange(L);
        let E;
        C.direction === 1 ? E = Math.max(1, S.startLineNumber - C.value) : E = Math.min(v.model.getLineCount(), S.startLineNumber + C.value);
        const D = v.coordinatesConverter.convertModelPositionToViewPosition(new ie(E, 1));
        return v.getVerticalOffsetForLineNumber(D.lineNumber);
      }
      let y;
      C.unit === 3 ? y = v.cursorConfig.pageSize * C.value : C.unit === 4 ? y = Math.round(v.cursorConfig.pageSize / 2) * C.value : y = C.value;
      const w = (C.direction === 1 ? -1 : 1) * y;
      return v.getScrollTop() + w * v.cursorConfig.lineHeight;
    }
  }
  n.EditorScrollImpl = f, n.EditorScroll = Ze(new f()), n.ScrollLineUp = Ze(new class extends ji {
    constructor() {
      super({
        id: "scrollLineUp",
        precondition: void 0,
        kbOpts: {
          weight: yt,
          kbExpr: Re.textInputFocus,
          primary: 2064,
          mac: {
            primary: 267
            /* PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(m, v) {
      n.EditorScroll._runEditorScroll(m, v.source, {
        direction: 1,
        unit: 2,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }()), n.ScrollPageUp = Ze(new class extends ji {
    constructor() {
      super({
        id: "scrollPageUp",
        precondition: void 0,
        kbOpts: {
          weight: yt,
          kbExpr: Re.textInputFocus,
          primary: 2059,
          win: {
            primary: 523
            /* PageUp */
          },
          linux: {
            primary: 523
            /* PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(m, v) {
      n.EditorScroll._runEditorScroll(m, v.source, {
        direction: 1,
        unit: 3,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }()), n.ScrollLineDown = Ze(new class extends ji {
    constructor() {
      super({
        id: "scrollLineDown",
        precondition: void 0,
        kbOpts: {
          weight: yt,
          kbExpr: Re.textInputFocus,
          primary: 2066,
          mac: {
            primary: 268
            /* PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(m, v) {
      n.EditorScroll._runEditorScroll(m, v.source, {
        direction: 2,
        unit: 2,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }()), n.ScrollPageDown = Ze(new class extends ji {
    constructor() {
      super({
        id: "scrollPageDown",
        precondition: void 0,
        kbOpts: {
          weight: yt,
          kbExpr: Re.textInputFocus,
          primary: 2060,
          win: {
            primary: 524
            /* PageDown */
          },
          linux: {
            primary: 524
            /* PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(m, v) {
      n.EditorScroll._runEditorScroll(m, v.source, {
        direction: 2,
        unit: 3,
        value: 1,
        revealCursor: !1,
        select: !1
      });
    }
  }());
  class p extends ji {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, [
        sr.word(v, v.getPrimaryCursorState(), this._inSelectionMode, C.position)
      ]), v.revealPrimaryCursor(C.source, !0);
    }
  }
  n.WordSelect = Ze(new p({
    inSelectionMode: !1,
    id: "_wordSelect",
    precondition: void 0
  })), n.WordSelectDrag = Ze(new p({
    inSelectionMode: !0,
    id: "_wordSelectDrag",
    precondition: void 0
  })), n.LastCursorWordSelect = Ze(new class extends ji {
    constructor() {
      super({
        id: "lastCursorWordSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(m, v) {
      const C = m.getLastAddedCursorIndex(), y = m.getCursorStates(), w = y.slice(0), L = y[C];
      w[C] = sr.word(m, L, L.modelState.hasSelection(), v.position), m.model.pushStackElement(), m.setCursorStates(v.source, 3, w);
    }
  }());
  class g extends ji {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      v.model.pushStackElement(), v.setCursorStates(C.source, 3, [
        sr.line(v, v.getPrimaryCursorState(), this._inSelectionMode, C.position, C.viewPosition)
      ]), v.revealPrimaryCursor(C.source, !1);
    }
  }
  n.LineSelect = Ze(new g({
    inSelectionMode: !1,
    id: "_lineSelect",
    precondition: void 0
  })), n.LineSelectDrag = Ze(new g({
    inSelectionMode: !0,
    id: "_lineSelectDrag",
    precondition: void 0
  }));
  class _ extends ji {
    constructor(v) {
      super(v), this._inSelectionMode = v.inSelectionMode;
    }
    runCoreEditorCommand(v, C) {
      const y = v.getLastAddedCursorIndex(), w = v.getCursorStates(), L = w.slice(0);
      L[y] = sr.line(v, w[y], this._inSelectionMode, C.position, C.viewPosition), v.model.pushStackElement(), v.setCursorStates(C.source, 3, L);
    }
  }
  n.LastCursorLineSelect = Ze(new _({
    inSelectionMode: !1,
    id: "lastCursorLineSelect",
    precondition: void 0
  })), n.LastCursorLineSelectDrag = Ze(new _({
    inSelectionMode: !0,
    id: "lastCursorLineSelectDrag",
    precondition: void 0
  })), n.ExpandLineSelection = Ze(new class extends ji {
    constructor() {
      super({
        id: "expandLineSelection",
        precondition: void 0,
        kbOpts: {
          weight: yt,
          kbExpr: Re.textInputFocus,
          primary: 2090
          /* KEY_L */
        }
      });
    }
    runCoreEditorCommand(m, v) {
      m.model.pushStackElement(), m.setCursorStates(v.source, 3, sr.expandLineSelection(m, m.getCursorStates())), m.revealPrimaryCursor(v.source, !0);
    }
  }()), n.CancelSelection = Ze(new class extends ji {
    constructor() {
      super({
        id: "cancelSelection",
        precondition: Re.hasNonEmptySelection,
        kbOpts: {
          weight: yt,
          kbExpr: Re.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(m, v) {
      m.model.pushStackElement(), m.setCursorStates(v.source, 3, [
        sr.cancelSelection(m, m.getPrimaryCursorState())
      ]), m.revealPrimaryCursor(v.source, !0);
    }
  }()), n.RemoveSecondaryCursors = Ze(new class extends ji {
    constructor() {
      super({
        id: "removeSecondaryCursors",
        precondition: Re.hasMultipleSelections,
        kbOpts: {
          weight: yt + 1,
          kbExpr: Re.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(m, v) {
      m.model.pushStackElement(), m.setCursorStates(v.source, 3, [
        m.getPrimaryCursorState()
      ]), m.revealPrimaryCursor(v.source, !0), YT(b("removedCursor", "Removed secondary cursors"));
    }
  }()), n.RevealLine = Ze(new class extends ji {
    constructor() {
      super({
        id: "revealLine",
        precondition: void 0,
        description: up.description
      });
    }
    runCoreEditorCommand(m, v) {
      const C = v, y = C.lineNumber || 0;
      let w = typeof y == "number" ? y + 1 : parseInt(y) + 1;
      w < 1 && (w = 1);
      const L = m.model.getLineCount();
      w > L && (w = L);
      const S = new G(w, 1, w, m.model.getLineMaxColumn(w));
      let E = 0;
      if (C.at)
        switch (C.at) {
          case up.RawAtArgument.Top:
            E = 3;
            break;
          case up.RawAtArgument.Center:
            E = 1;
            break;
          case up.RawAtArgument.Bottom:
            E = 4;
            break;
        }
      const D = m.coordinatesConverter.convertModelRangeToViewRange(S);
      m.revealRange(
        v.source,
        !1,
        D,
        E,
        0
        /* Smooth */
      );
    }
  }()), n.SelectAll = new class extends nO {
    constructor() {
      super(Ble);
    }
    runDOMCommand() {
      to && (document.activeElement.focus(), document.activeElement.select()), document.execCommand("selectAll");
    }
    runEditorCommand(m, v, C) {
      const y = v._getViewModel();
      y && this.runCoreEditorCommand(y, C);
    }
    runCoreEditorCommand(m, v) {
      m.model.pushStackElement(), m.setCursorStates("keyboard", 3, [
        sr.selectAll(m, m.getPrimaryCursorState())
      ]);
    }
  }(), n.SetSelection = Ze(new class extends ji {
    constructor() {
      super({
        id: "setSelection",
        precondition: void 0
      });
    }
    runCoreEditorCommand(m, v) {
      m.model.pushStackElement(), m.setCursorStates(v.source, 3, [
        at.fromModelSelection(v.selection)
      ]);
    }
  }());
})(Ln || (Ln = {}));
const Xhe = fr.and(Re.textInputFocus, Re.columnSelection);
function kg(n, e) {
  fE.registerKeybindingRule({
    id: n,
    primary: e,
    when: Xhe,
    weight: yt + 1
  });
}
kg(
  Ln.CursorColumnSelectLeft.id,
  1039
  /* LeftArrow */
);
kg(
  Ln.CursorColumnSelectRight.id,
  1041
  /* RightArrow */
);
kg(
  Ln.CursorColumnSelectUp.id,
  1040
  /* UpArrow */
);
kg(
  Ln.CursorColumnSelectPageUp.id,
  1035
  /* PageUp */
);
kg(
  Ln.CursorColumnSelectDown.id,
  1042
  /* DownArrow */
);
kg(
  Ln.CursorColumnSelectPageDown.id,
  1036
  /* PageDown */
);
function X2(n) {
  return n.register(), n;
}
var Z2;
(function(n) {
  class e extends Mg {
    runEditorCommand(i, r, o) {
      const s = r._getViewModel();
      s && this.runCoreEditingCommand(r, s, o || {});
    }
  }
  n.CoreEditingCommand = e, n.LineBreakInsert = Ze(new class extends e {
    constructor() {
      super({
        id: "lineBreakInsert",
        precondition: Re.writable,
        kbOpts: {
          weight: yt,
          kbExpr: Re.textInputFocus,
          primary: 0,
          mac: {
            primary: 301
            /* KEY_O */
          }
        }
      });
    }
    runCoreEditingCommand(t, i, r) {
      t.pushUndoStop(), t.executeCommands(this.id, Vi.lineBreakInsert(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection)));
    }
  }()), n.Outdent = Ze(new class extends e {
    constructor() {
      super({
        id: "outdent",
        precondition: Re.writable,
        kbOpts: {
          weight: yt,
          kbExpr: fr.and(Re.editorTextFocus, Re.tabDoesNotMoveFocus),
          primary: 1026
          /* Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, r) {
      t.pushUndoStop(), t.executeCommands(this.id, Vi.outdent(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
    }
  }()), n.Tab = Ze(new class extends e {
    constructor() {
      super({
        id: "tab",
        precondition: Re.writable,
        kbOpts: {
          weight: yt,
          kbExpr: fr.and(Re.editorTextFocus, Re.tabDoesNotMoveFocus),
          primary: 2
          /* Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, r) {
      t.pushUndoStop(), t.executeCommands(this.id, Vi.tab(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
    }
  }()), n.DeleteLeft = Ze(new class extends e {
    constructor() {
      super({
        id: "deleteLeft",
        precondition: void 0,
        kbOpts: {
          weight: yt,
          kbExpr: Re.textInputFocus,
          primary: 1,
          secondary: [
            1025
            /* Backspace */
          ],
          mac: { primary: 1, secondary: [
            1025,
            294,
            257
            /* Backspace */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, r) {
      const [o, s] = qd.deleteLeft(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection), i.getCursorAutoClosedCharacters());
      o && t.pushUndoStop(), t.executeCommands(this.id, s), i.setPrevEditOperationType(
        2
        /* DeletingLeft */
      );
    }
  }()), n.DeleteRight = Ze(new class extends e {
    constructor() {
      super({
        id: "deleteRight",
        precondition: void 0,
        kbOpts: {
          weight: yt,
          kbExpr: Re.textInputFocus,
          primary: 20,
          mac: { primary: 20, secondary: [
            290,
            276
            /* Delete */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, r) {
      const [o, s] = qd.deleteRight(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection));
      o && t.pushUndoStop(), t.executeCommands(this.id, s), i.setPrevEditOperationType(
        3
        /* DeletingRight */
      );
    }
  }()), n.Undo = new class extends nO {
    constructor() {
      super(L3);
    }
    runDOMCommand() {
      document.execCommand("undo");
    }
    runEditorCommand(t, i, r) {
      if (!(!i.hasModel() || i.getOption(
        78
        /* readOnly */
      ) === !0))
        return i.getModel().undo();
    }
  }(), n.Redo = new class extends nO {
    constructor() {
      super(D3);
    }
    runDOMCommand() {
      document.execCommand("redo");
    }
    runEditorCommand(t, i, r) {
      if (!(!i.hasModel() || i.getOption(
        78
        /* readOnly */
      ) === !0))
        return i.getModel().redo();
    }
  }();
})(Z2 || (Z2 = {}));
class Q2 extends LE {
  constructor(e, t, i) {
    super({
      id: e,
      precondition: void 0,
      description: i
    }), this._handlerId = t;
  }
  runCommand(e, t) {
    const i = e.get(mr).getFocusedCodeEditor();
    i && i.trigger("keyboard", this._handlerId, t);
  }
}
function cf(n, e) {
  X2(new Q2("default:" + n, n)), X2(new Q2(n, n, e));
}
cf("type", {
  description: "Type",
  args: [{
    name: "args",
    schema: {
      type: "object",
      required: ["text"],
      properties: {
        text: {
          type: "string"
        }
      }
    }
  }]
});
cf(
  "replacePreviousChar"
  /* ReplacePreviousChar */
);
cf(
  "compositionType"
  /* CompositionType */
);
cf(
  "compositionStart"
  /* CompositionStart */
);
cf(
  "compositionEnd"
  /* CompositionEnd */
);
cf(
  "paste"
  /* Paste */
);
cf(
  "cut"
  /* Cut */
);
class Zhe {
  constructor(e, t, i, r) {
    this.configuration = e, this.viewModel = t, this.userInputEvents = i, this.commandDelegate = r;
  }
  paste(e, t, i, r) {
    this.commandDelegate.paste(e, t, i, r);
  }
  type(e) {
    this.commandDelegate.type(e);
  }
  compositionType(e, t, i, r) {
    this.commandDelegate.compositionType(e, t, i, r);
  }
  compositionStart() {
    this.commandDelegate.startComposition();
  }
  compositionEnd() {
    this.commandDelegate.endComposition();
  }
  cut() {
    this.commandDelegate.cut();
  }
  setSelection(e) {
    Ln.SetSelection.runCoreEditorCommand(this.viewModel, {
      source: "keyboard",
      selection: e
    });
  }
  _validateViewColumn(e) {
    const t = this.viewModel.getLineMinColumn(e.lineNumber);
    return e.column < t ? new ie(e.lineNumber, t) : e;
  }
  _hasMulticursorModifier(e) {
    switch (this.configuration.options.get(
      67
      /* multiCursorModifier */
    )) {
      case "altKey":
        return e.altKey;
      case "ctrlKey":
        return e.ctrlKey;
      case "metaKey":
        return e.metaKey;
      default:
        return !1;
    }
  }
  _hasNonMulticursorModifier(e) {
    switch (this.configuration.options.get(
      67
      /* multiCursorModifier */
    )) {
      case "altKey":
        return e.ctrlKey || e.metaKey;
      case "ctrlKey":
        return e.altKey || e.metaKey;
      case "metaKey":
        return e.ctrlKey || e.altKey;
      default:
        return !1;
    }
  }
  dispatchMouse(e) {
    const t = this.configuration.options, i = Is && t.get(
      94
      /* selectionClipboard */
    ), r = t.get(
      16
      /* columnSelection */
    );
    e.middleButton && !i ? this._columnSelect(e.position, e.mouseColumn, e.inSelectionMode) : e.startedOnLineNumbers ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelect(e.position) : this._createCursor(e.position, !0) : e.inSelectionMode ? this._lineSelectDrag(e.position) : this._lineSelect(e.position) : e.mouseDownCount >= 4 ? this._selectAll() : e.mouseDownCount === 3 ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelectDrag(e.position) : this._lastCursorLineSelect(e.position) : e.inSelectionMode ? this._lineSelectDrag(e.position) : this._lineSelect(e.position) : e.mouseDownCount === 2 ? this._hasMulticursorModifier(e) ? this._lastCursorWordSelect(e.position) : e.inSelectionMode ? this._wordSelectDrag(e.position) : this._wordSelect(e.position) : this._hasMulticursorModifier(e) ? this._hasNonMulticursorModifier(e) || (e.shiftKey ? this._columnSelect(e.position, e.mouseColumn, !0) : e.inSelectionMode ? this._lastCursorMoveToSelect(e.position) : this._createCursor(e.position, !1)) : e.inSelectionMode ? e.altKey ? this._columnSelect(e.position, e.mouseColumn, !0) : r ? this._columnSelect(e.position, e.mouseColumn, !0) : this._moveToSelect(e.position) : this.moveTo(e.position);
  }
  _usualArgs(e) {
    return e = this._validateViewColumn(e), {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e
    };
  }
  moveTo(e) {
    Ln.MoveTo.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _moveToSelect(e) {
    Ln.MoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _columnSelect(e, t, i) {
    e = this._validateViewColumn(e), Ln.ColumnSelect.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      mouseColumn: t,
      doColumnSelect: i
    });
  }
  _createCursor(e, t) {
    e = this._validateViewColumn(e), Ln.CreateCursor.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      wholeLine: t
    });
  }
  _lastCursorMoveToSelect(e) {
    Ln.LastCursorMoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _wordSelect(e) {
    Ln.WordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _wordSelectDrag(e) {
    Ln.WordSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lastCursorWordSelect(e) {
    Ln.LastCursorWordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lineSelect(e) {
    Ln.LineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lineSelectDrag(e) {
    Ln.LineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lastCursorLineSelect(e) {
    Ln.LastCursorLineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _lastCursorLineSelectDrag(e) {
    Ln.LastCursorLineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e));
  }
  _selectAll() {
    Ln.SelectAll.runCoreEditorCommand(this.viewModel, { source: "mouse" });
  }
  // ----------------------
  _convertViewToModelPosition(e) {
    return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(e);
  }
  emitKeyDown(e) {
    this.userInputEvents.emitKeyDown(e);
  }
  emitKeyUp(e) {
    this.userInputEvents.emitKeyUp(e);
  }
  emitContextMenu(e) {
    this.userInputEvents.emitContextMenu(e);
  }
  emitMouseMove(e) {
    this.userInputEvents.emitMouseMove(e);
  }
  emitMouseLeave(e) {
    this.userInputEvents.emitMouseLeave(e);
  }
  emitMouseUp(e) {
    this.userInputEvents.emitMouseUp(e);
  }
  emitMouseDown(e) {
    this.userInputEvents.emitMouseDown(e);
  }
  emitMouseDrag(e) {
    this.userInputEvents.emitMouseDrag(e);
  }
  emitMouseDrop(e) {
    this.userInputEvents.emitMouseDrop(e);
  }
  emitMouseDropCanceled() {
    this.userInputEvents.emitMouseDropCanceled();
  }
  emitMouseWheel(e) {
    this.userInputEvents.emitMouseWheel(e);
  }
}
class IE {
  constructor(e) {
    this.onKeyDown = null, this.onKeyUp = null, this.onContextMenu = null, this.onMouseMove = null, this.onMouseLeave = null, this.onMouseDown = null, this.onMouseUp = null, this.onMouseDrag = null, this.onMouseDrop = null, this.onMouseDropCanceled = null, this.onMouseWheel = null, this._coordinatesConverter = e;
  }
  emitKeyDown(e) {
    this.onKeyDown && this.onKeyDown(e);
  }
  emitKeyUp(e) {
    this.onKeyUp && this.onKeyUp(e);
  }
  emitContextMenu(e) {
    this.onContextMenu && this.onContextMenu(this._convertViewToModelMouseEvent(e));
  }
  emitMouseMove(e) {
    this.onMouseMove && this.onMouseMove(this._convertViewToModelMouseEvent(e));
  }
  emitMouseLeave(e) {
    this.onMouseLeave && this.onMouseLeave(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDown(e) {
    this.onMouseDown && this.onMouseDown(this._convertViewToModelMouseEvent(e));
  }
  emitMouseUp(e) {
    this.onMouseUp && this.onMouseUp(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrag(e) {
    this.onMouseDrag && this.onMouseDrag(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrop(e) {
    this.onMouseDrop && this.onMouseDrop(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDropCanceled() {
    this.onMouseDropCanceled && this.onMouseDropCanceled();
  }
  emitMouseWheel(e) {
    this.onMouseWheel && this.onMouseWheel(e);
  }
  _convertViewToModelMouseEvent(e) {
    return e.target ? {
      event: e.event,
      target: this._convertViewToModelMouseTarget(e.target)
    } : e;
  }
  _convertViewToModelMouseTarget(e) {
    return IE.convertViewToModelMouseTarget(e, this._coordinatesConverter);
  }
  static convertViewToModelMouseTarget(e, t) {
    return new Qhe(e.element, e.type, e.mouseColumn, e.position ? t.convertViewPositionToModelPosition(e.position) : null, e.range ? t.convertViewRangeToModelRange(e.range) : null, e.detail);
  }
}
class Qhe {
  constructor(e, t, i, r, o, s) {
    this.element = e, this.type = t, this.mouseColumn = i, this.position = r, this.range = o, this.detail = s;
  }
  toString() {
    return Wa.toString(this);
  }
}
var jD;
class i7 {
  constructor(e) {
    this._createLine = e, this._set(1, []);
  }
  flush() {
    this._set(1, []);
  }
  _set(e, t) {
    this._lines = t, this._rendLineNumberStart = e;
  }
  _get() {
    return {
      rendLineNumberStart: this._rendLineNumberStart,
      lines: this._lines
    };
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getStartLineNumber() {
    return this._rendLineNumberStart;
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getEndLineNumber() {
    return this._rendLineNumberStart + this._lines.length - 1;
  }
  getCount() {
    return this._lines.length;
  }
  getLine(e) {
    const t = e - this._rendLineNumberStart;
    if (t < 0 || t >= this._lines.length)
      throw new Error("Illegal value for lineNumber");
    return this._lines[t];
  }
  /**
   * @returns Lines that were removed from this collection
   */
  onLinesDeleted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = this.getStartLineNumber(), r = this.getEndLineNumber();
    if (t < i) {
      const l = t - e + 1;
      return this._rendLineNumberStart -= l, null;
    }
    if (e > r)
      return null;
    let o = 0, s = 0;
    for (let l = i; l <= r; l++) {
      const u = l - this._rendLineNumberStart;
      e <= l && l <= t && (s === 0 ? (o = u, s = 1) : s++);
    }
    if (e < i) {
      let l = 0;
      t < i ? l = t - e + 1 : l = i - e, this._rendLineNumberStart -= l;
    }
    return this._lines.splice(o, s);
  }
  onLinesChanged(e, t) {
    if (this.getCount() === 0)
      return !1;
    const i = this.getStartLineNumber(), r = this.getEndLineNumber();
    let o = !1;
    for (let s = e; s <= t; s++)
      s >= i && s <= r && (this._lines[s - this._rendLineNumberStart].onContentChanged(), o = !0);
    return o;
  }
  onLinesInserted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = t - e + 1, r = this.getStartLineNumber(), o = this.getEndLineNumber();
    if (e <= r)
      return this._rendLineNumberStart += i, null;
    if (e > o)
      return null;
    if (i + e > o)
      return this._lines.splice(e - this._rendLineNumberStart, o - e + 1);
    const s = [];
    for (let h = 0; h < i; h++)
      s[h] = this._createLine();
    const a = e - this._rendLineNumberStart, l = this._lines.slice(0, a), u = this._lines.slice(a, this._lines.length - i), c = this._lines.slice(this._lines.length - i, this._lines.length);
    return this._lines = l.concat(s).concat(u), c;
  }
  onTokensChanged(e) {
    if (this.getCount() === 0)
      return !1;
    const t = this.getStartLineNumber(), i = this.getEndLineNumber();
    let r = !1;
    for (let o = 0, s = e.length; o < s; o++) {
      const a = e[o];
      if (a.toLineNumber < t || a.fromLineNumber > i)
        continue;
      const l = Math.max(t, a.fromLineNumber), u = Math.min(i, a.toLineNumber);
      for (let c = l; c <= u; c++) {
        const h = c - this._rendLineNumberStart;
        this._lines[h].onTokensChanged(), r = !0;
      }
    }
    return r;
  }
}
class n7 {
  constructor(e) {
    this._host = e, this.domNode = this._createDomNode(), this._linesCollection = new i7(() => this._host.createVisibleLine());
  }
  _createDomNode() {
    const e = St(document.createElement("div"));
    return e.setClassName("view-layer"), e.setPosition("absolute"), e.domNode.setAttribute("role", "presentation"), e.domNode.setAttribute("aria-hidden", "true"), e;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return !!e.hasChanged(
      128
      /* layoutInfo */
    );
  }
  onFlushed(e) {
    return this._linesCollection.flush(), !0;
  }
  onLinesChanged(e) {
    return this._linesCollection.onLinesChanged(e.fromLineNumber, e.toLineNumber);
  }
  onLinesDeleted(e) {
    const t = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, r = t.length; i < r; i++) {
        const o = t[i].getDomNode();
        o && this.domNode.domNode.removeChild(o);
      }
    return !0;
  }
  onLinesInserted(e) {
    const t = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, r = t.length; i < r; i++) {
        const o = t[i].getDomNode();
        o && this.domNode.domNode.removeChild(o);
      }
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onTokensChanged(e) {
    return this._linesCollection.onTokensChanged(e.ranges);
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  getStartLineNumber() {
    return this._linesCollection.getStartLineNumber();
  }
  getEndLineNumber() {
    return this._linesCollection.getEndLineNumber();
  }
  getVisibleLine(e) {
    return this._linesCollection.getLine(e);
  }
  renderLines(e) {
    const t = this._linesCollection._get(), i = new Uu(this.domNode.domNode, this._host, e), r = {
      rendLineNumberStart: t.rendLineNumberStart,
      lines: t.lines,
      linesLength: t.lines.length
    }, o = i.render(r, e.startLineNumber, e.endLineNumber, e.relativeVerticalOffset);
    this._linesCollection._set(o.rendLineNumberStart, o.lines);
  }
}
class Uu {
  constructor(e, t, i) {
    this.domNode = e, this.host = t, this.viewportData = i;
  }
  render(e, t, i, r) {
    const o = {
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines.slice(0),
      linesLength: e.linesLength
    };
    if (o.rendLineNumberStart + o.linesLength - 1 < t || i < o.rendLineNumberStart) {
      o.rendLineNumberStart = t, o.linesLength = i - t + 1, o.lines = [];
      for (let s = t; s <= i; s++)
        o.lines[s - t] = this.host.createVisibleLine();
      return this._finishRendering(o, !0, r), o;
    }
    if (this._renderUntouchedLines(o, Math.max(t - o.rendLineNumberStart, 0), Math.min(i - o.rendLineNumberStart, o.linesLength - 1), r, t), o.rendLineNumberStart > t) {
      const s = t, a = Math.min(i, o.rendLineNumberStart - 1);
      s <= a && (this._insertLinesBefore(o, s, a, r, t), o.linesLength += a - s + 1);
    } else if (o.rendLineNumberStart < t) {
      const s = Math.min(o.linesLength, t - o.rendLineNumberStart);
      s > 0 && (this._removeLinesBefore(o, s), o.linesLength -= s);
    }
    if (o.rendLineNumberStart = t, o.rendLineNumberStart + o.linesLength - 1 < i) {
      const s = o.rendLineNumberStart + o.linesLength, a = i;
      s <= a && (this._insertLinesAfter(o, s, a, r, t), o.linesLength += a - s + 1);
    } else if (o.rendLineNumberStart + o.linesLength - 1 > i) {
      const s = Math.max(0, i - o.rendLineNumberStart + 1), l = o.linesLength - 1 - s + 1;
      l > 0 && (this._removeLinesAfter(o, l), o.linesLength -= l);
    }
    return this._finishRendering(o, !1, r), o;
  }
  _renderUntouchedLines(e, t, i, r, o) {
    const s = e.rendLineNumberStart, a = e.lines;
    for (let l = t; l <= i; l++) {
      const u = s + l;
      a[l].layoutLine(u, r[u - o]);
    }
  }
  _insertLinesBefore(e, t, i, r, o) {
    const s = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      s[a++] = this.host.createVisibleLine();
    e.lines = s.concat(e.lines);
  }
  _removeLinesBefore(e, t) {
    for (let i = 0; i < t; i++) {
      const r = e.lines[i].getDomNode();
      r && this.domNode.removeChild(r);
    }
    e.lines.splice(0, t);
  }
  _insertLinesAfter(e, t, i, r, o) {
    const s = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      s[a++] = this.host.createVisibleLine();
    e.lines = e.lines.concat(s);
  }
  _removeLinesAfter(e, t) {
    const i = e.linesLength - t;
    for (let r = 0; r < t; r++) {
      const o = e.lines[i + r].getDomNode();
      o && this.domNode.removeChild(o);
    }
    e.lines.splice(i, t);
  }
  _finishRenderingNewLines(e, t, i, r) {
    Uu._ttPolicy && (i = Uu._ttPolicy.createHTML(i));
    const o = this.domNode.lastChild;
    t || !o ? this.domNode.innerHTML = i : o.insertAdjacentHTML("afterend", i);
    let s = this.domNode.lastChild;
    for (let a = e.linesLength - 1; a >= 0; a--) {
      const l = e.lines[a];
      r[a] && (l.setDomNode(s), s = s.previousSibling);
    }
  }
  _finishRenderingInvalidLines(e, t, i) {
    const r = document.createElement("div");
    Uu._ttPolicy && (t = Uu._ttPolicy.createHTML(t)), r.innerHTML = t;
    for (let o = 0; o < e.linesLength; o++) {
      const s = e.lines[o];
      if (i[o]) {
        const a = r.firstChild, l = s.getDomNode();
        l.parentNode.replaceChild(a, l), s.setDomNode(a);
      }
    }
  }
  _finishRendering(e, t, i) {
    const r = Uu._sb, o = e.linesLength, s = e.lines, a = e.rendLineNumberStart, l = [];
    {
      r.reset();
      let u = !1;
      for (let c = 0; c < o; c++) {
        const h = s[c];
        l[c] = !1, !(h.getDomNode() || !h.renderLine(c + a, i[c], this.viewportData, r)) && (l[c] = !0, u = !0);
      }
      u && this._finishRenderingNewLines(e, t, r.build(), l);
    }
    {
      r.reset();
      let u = !1;
      const c = [];
      for (let h = 0; h < o; h++) {
        const d = s[h];
        c[h] = !1, !(l[h] || !d.renderLine(h + a, i[h], this.viewportData, r)) && (c[h] = !0, u = !0);
      }
      u && this._finishRenderingInvalidLines(e, r.build(), c);
    }
  }
}
Uu._ttPolicy = (jD = window.trustedTypes) === null || jD === void 0 ? void 0 : jD.createPolicy("editorViewLayer", { createHTML: (n) => n });
Uu._sb = eg(1e5);
class r7 extends Fs {
  constructor(e) {
    super(e), this._visibleLines = new n7(this), this.domNode = this._visibleLines.domNode, this._dynamicOverlays = [], this._isFocused = !1, this.domNode.setClassName("view-overlays");
  }
  shouldRender() {
    if (super.shouldRender())
      return !0;
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      if (this._dynamicOverlays[e].shouldRender())
        return !0;
    return !1;
  }
  dispose() {
    super.dispose();
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      this._dynamicOverlays[e].dispose();
    this._dynamicOverlays = [];
  }
  getDomNode() {
    return this.domNode;
  }
  // ---- begin IVisibleLinesHost
  createVisibleLine() {
    return new Jhe(this._context.configuration, this._dynamicOverlays);
  }
  // ---- end IVisibleLinesHost
  addDynamicOverlay(e) {
    this._dynamicOverlays.push(e);
  }
  // ----- event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e);
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    for (let r = t; r <= i; r++)
      this._visibleLines.getVisibleLine(r).onConfigurationChanged(e);
    return !0;
  }
  onFlushed(e) {
    return this._visibleLines.onFlushed(e);
  }
  onFocusChanged(e) {
    return this._isFocused = e.isFocused, !0;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onScrollChanged(e) {
    return this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._visibleLines.onZonesChanged(e);
  }
  // ----- end event handlers
  prepareRender(e) {
    const t = this._dynamicOverlays.filter((i) => i.shouldRender());
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      o.prepareRender(e), o.onDidRender();
    }
  }
  render(e) {
    this._viewOverlaysRender(e), this.domNode.toggleClassName("focused", this._isFocused);
  }
  _viewOverlaysRender(e) {
    this._visibleLines.renderLines(e.viewportData);
  }
}
class Jhe {
  constructor(e, t) {
    this._configuration = e, this._lineHeight = this._configuration.options.get(
      56
      /* lineHeight */
    ), this._dynamicOverlays = t, this._domNode = null, this._renderedContent = null;
  }
  getDomNode() {
    return this._domNode ? this._domNode.domNode : null;
  }
  setDomNode(e) {
    this._domNode = St(e);
  }
  onContentChanged() {
  }
  onTokensChanged() {
  }
  onConfigurationChanged(e) {
    this._lineHeight = this._configuration.options.get(
      56
      /* lineHeight */
    );
  }
  renderLine(e, t, i, r) {
    let o = "";
    for (let s = 0, a = this._dynamicOverlays.length; s < a; s++) {
      const l = this._dynamicOverlays[s];
      o += l.render(i.startLineNumber, e);
    }
    return this._renderedContent === o ? !1 : (this._renderedContent = o, r.appendASCIIString('<div style="position:absolute;top:'), r.appendASCIIString(String(t)), r.appendASCIIString("px;width:100%;height:"), r.appendASCIIString(String(this._lineHeight)), r.appendASCIIString('px;">'), r.appendASCIIString(o), r.appendASCIIString("</div>"), !0);
  }
  layoutLine(e, t) {
    this._domNode && (this._domNode.setTop(t), this._domNode.setHeight(this._lineHeight));
  }
}
class ede extends r7 {
  constructor(e) {
    super(e);
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    this._contentWidth = i.contentWidth, this.domNode.setHeight(0);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    return this._contentWidth = i.contentWidth, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollWidthChanged;
  }
  // --- end event handlers
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e), this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth));
  }
}
class tde extends r7 {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    this._contentLeft = i.contentLeft, this.domNode.setClassName("margin-view-overlays"), this.domNode.setWidth(1), oo.applyFontInfo(this.domNode, t.get(
      40
      /* fontInfo */
    ));
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    oo.applyFontInfo(this.domNode, t.get(
      40
      /* fontInfo */
    ));
    const i = t.get(
      128
      /* layoutInfo */
    );
    return this._contentLeft = i.contentLeft, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollHeightChanged;
  }
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e);
    const t = Math.min(e.scrollHeight, 1e6);
    this.domNode.setHeight(t), this.domNode.setWidth(this._contentLeft);
  }
}
class Hm {
  constructor(e, t) {
    this.top = e, this.left = t;
  }
}
class ide extends Fs {
  constructor(e, t) {
    super(e), this._viewDomNode = t, this._widgets = {}, this.domNode = St(document.createElement("div")), Ql.write(
      this.domNode,
      1
      /* ContentWidgets */
    ), this.domNode.setClassName("contentWidgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this.overflowingContentWidgetsDomNode = St(document.createElement("div")), Ql.write(
      this.overflowingContentWidgetsDomNode,
      2
      /* OverflowingContentWidgets */
    ), this.overflowingContentWidgetsDomNode.setClassName("overflowingContentWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onConfigurationChanged(e);
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLineMappingChanged(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onLineMappingChanged(e);
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  addWidget(e) {
    const t = new nde(this._context, this._viewDomNode, e);
    this._widgets[t.id] = t, t.allowEditorOverflow ? this.overflowingContentWidgetsDomNode.appendChild(t.domNode) : this.domNode.appendChild(t.domNode), this.setShouldRender();
  }
  setWidgetPosition(e, t, i) {
    this._widgets[e.getId()].setPosition(t, i), this.setShouldRender();
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const i = this._widgets[t];
      delete this._widgets[t];
      const r = i.domNode.domNode;
      r.parentNode.removeChild(r), r.removeAttribute("monaco-visible-content-widget"), this.setShouldRender();
    }
  }
  shouldSuppressMouseDownOnWidget(e) {
    return this._widgets.hasOwnProperty(e) ? this._widgets[e].suppressMouseDown : !1;
  }
  onBeforeRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onBeforeRender(e);
  }
  prepareRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].prepareRender(e);
  }
  render(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].render(e);
  }
}
let nde = class {
  constructor(e, t, i) {
    this._context = e, this._viewDomNode = t, this._actual = i, this.domNode = St(this._actual.getDomNode()), this.id = this._actual.getId(), this.allowEditorOverflow = this._actual.allowEditorOverflow || !1, this.suppressMouseDown = this._actual.suppressMouseDown || !1;
    const r = this._context.configuration.options, o = r.get(
      128
      /* layoutInfo */
    );
    this._fixedOverflowWidgets = r.get(
      34
      /* fixedOverflowWidgets */
    ), this._contentWidth = o.contentWidth, this._contentLeft = o.contentLeft, this._lineHeight = r.get(
      56
      /* lineHeight */
    ), this._range = null, this._viewRange = null, this._preference = [], this._cachedDomNodeClientWidth = -1, this._cachedDomNodeClientHeight = -1, this._maxWidth = this._getMaxWidth(), this._isVisible = !1, this._renderData = null, this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute"), this.domNode.setVisibility("hidden"), this.domNode.setAttribute("widgetId", this.id), this.domNode.setMaxWidth(this._maxWidth);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    if (this._lineHeight = t.get(
      56
      /* lineHeight */
    ), e.hasChanged(
      128
      /* layoutInfo */
    )) {
      const i = t.get(
        128
        /* layoutInfo */
      );
      this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._maxWidth = this._getMaxWidth();
    }
  }
  onLineMappingChanged(e) {
    this._setPosition(this._range);
  }
  _setPosition(e) {
    if (this._range = e, this._viewRange = null, this._range) {
      const t = this._context.model.validateModelRange(this._range);
      (this._context.model.coordinatesConverter.modelPositionIsVisible(t.getStartPosition()) || this._context.model.coordinatesConverter.modelPositionIsVisible(t.getEndPosition())) && (this._viewRange = this._context.model.coordinatesConverter.convertModelRangeToViewRange(t));
    }
  }
  _getMaxWidth() {
    return this.allowEditorOverflow ? window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth : this._contentWidth;
  }
  setPosition(e, t) {
    this._setPosition(e), this._preference = t, this._cachedDomNodeClientWidth = -1, this._cachedDomNodeClientHeight = -1;
  }
  _layoutBoxInViewport(e, t, i, r, o) {
    const s = e.top, a = s, l = t.top + this._lineHeight, u = o.viewportHeight - l, c = s - r, h = a >= r, d = l, f = u >= r;
    let p = e.left, g = t.left;
    return p + i > o.scrollLeft + o.viewportWidth && (p = o.scrollLeft + o.viewportWidth - i), g + i > o.scrollLeft + o.viewportWidth && (g = o.scrollLeft + o.viewportWidth - i), p < o.scrollLeft && (p = o.scrollLeft), g < o.scrollLeft && (g = o.scrollLeft), {
      fitsAbove: h,
      aboveTop: c,
      aboveLeft: p,
      fitsBelow: f,
      belowTop: d,
      belowLeft: g
    };
  }
  _layoutHorizontalSegmentInPage(e, t, i, r) {
    const o = Math.max(0, t.left - r), s = Math.min(t.left + t.width + r, e.width);
    let a = t.left + i - Ku.scrollX;
    if (a + r > s) {
      const l = a - (s - r);
      a -= l, i -= l;
    }
    if (a < o) {
      const l = a - o;
      a -= l, i -= l;
    }
    return [i, a];
  }
  _layoutBoxInPage(e, t, i, r, o) {
    const s = e.top - r, a = t.top + this._lineHeight, l = qa(this._viewDomNode.domNode), u = l.top + s - Ku.scrollY, c = l.top + a - Ku.scrollY, h = o5(document.body), [d, f] = this._layoutHorizontalSegmentInPage(h, l, e.left - o.scrollLeft + this._contentLeft, i), [p, g] = this._layoutHorizontalSegmentInPage(h, l, t.left - o.scrollLeft + this._contentLeft, i), _ = 22, m = 22, v = u >= _, C = c + r <= h.height - m;
    return this._fixedOverflowWidgets ? {
      fitsAbove: v,
      aboveTop: Math.max(u, _),
      aboveLeft: f,
      fitsBelow: C,
      belowTop: c,
      belowLeft: g
    } : {
      fitsAbove: v,
      aboveTop: s,
      aboveLeft: d,
      fitsBelow: C,
      belowTop: a,
      belowLeft: p
    };
  }
  _prepareRenderWidgetAtExactPositionOverflowing(e) {
    return new Hm(e.top, e.left + this._contentLeft);
  }
  /**
   * Compute `this._topLeft`
   */
  _getTopAndBottomLeft(e) {
    if (!this._viewRange)
      return [null, null];
    const t = e.linesVisibleRangesForRange(this._viewRange, !1);
    if (!t || t.length === 0)
      return [null, null];
    let i = t[0], r = t[0];
    for (const h of t)
      h.lineNumber < i.lineNumber && (i = h), h.lineNumber > r.lineNumber && (r = h);
    let o = 1073741824;
    for (const h of i.ranges)
      h.left < o && (o = h.left);
    let s = 1073741824;
    for (const h of r.ranges)
      h.left < s && (s = h.left);
    const a = e.getVerticalOffsetForLineNumber(i.lineNumber) - e.scrollTop, l = new Hm(a, o), u = e.getVerticalOffsetForLineNumber(r.lineNumber) - e.scrollTop, c = new Hm(u, s);
    return [l, c];
  }
  _prepareRenderWidget(e) {
    const [t, i] = this._getTopAndBottomLeft(e);
    if (!t || !i)
      return null;
    if (this._cachedDomNodeClientWidth === -1 || this._cachedDomNodeClientHeight === -1) {
      let o = null;
      if (typeof this._actual.beforeRender == "function" && (o = $D(this._actual.beforeRender, this._actual)), o)
        this._cachedDomNodeClientWidth = o.width, this._cachedDomNodeClientHeight = o.height;
      else {
        const s = this.domNode.domNode;
        this._cachedDomNodeClientWidth = s.clientWidth, this._cachedDomNodeClientHeight = s.clientHeight;
      }
    }
    let r;
    if (this.allowEditorOverflow ? r = this._layoutBoxInPage(t, i, this._cachedDomNodeClientWidth, this._cachedDomNodeClientHeight, e) : r = this._layoutBoxInViewport(t, i, this._cachedDomNodeClientWidth, this._cachedDomNodeClientHeight, e), this._preference)
      for (let o = 1; o <= 2; o++)
        for (const s of this._preference)
          if (s === 1) {
            if (!r)
              return null;
            if (o === 2 || r.fitsAbove)
              return {
                coordinate: new Hm(r.aboveTop, r.aboveLeft),
                position: 1
                /* ABOVE */
              };
          } else if (s === 2) {
            if (!r)
              return null;
            if (o === 2 || r.fitsBelow)
              return {
                coordinate: new Hm(r.belowTop, r.belowLeft),
                position: 2
                /* BELOW */
              };
          } else
            return this.allowEditorOverflow ? {
              coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(t),
              position: 0
              /* EXACT */
            } : {
              coordinate: t,
              position: 0
              /* EXACT */
            };
    return null;
  }
  /**
   * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.
   */
  onBeforeRender(e) {
    !this._viewRange || !this._preference || this._viewRange.endLineNumber < e.startLineNumber || this._viewRange.startLineNumber > e.endLineNumber || this.domNode.setMaxWidth(this._maxWidth);
  }
  prepareRender(e) {
    this._renderData = this._prepareRenderWidget(e);
  }
  render(e) {
    if (!this._renderData) {
      this._isVisible && (this.domNode.removeAttribute("monaco-visible-content-widget"), this._isVisible = !1, this.domNode.setVisibility("hidden")), typeof this._actual.afterRender == "function" && $D(this._actual.afterRender, this._actual, null);
      return;
    }
    this.allowEditorOverflow ? (this.domNode.setTop(this._renderData.coordinate.top), this.domNode.setLeft(this._renderData.coordinate.left)) : (this.domNode.setTop(this._renderData.coordinate.top + e.scrollTop - e.bigNumbersDelta), this.domNode.setLeft(this._renderData.coordinate.left)), this._isVisible || (this.domNode.setVisibility("inherit"), this.domNode.setAttribute("monaco-visible-content-widget", "true"), this._isVisible = !0), typeof this._actual.afterRender == "function" && $D(this._actual.afterRender, this._actual, this._renderData.position);
  }
};
function $D(n, e, ...t) {
  try {
    return n.call(e, ...t);
  } catch {
    return null;
  }
}
let rO = !0;
class o7 extends Fg {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._renderLineHighlight = t.get(
      83
      /* renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      84
      /* renderLineHighlightOnlyWhenFocus */
    ), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._selectionIsEmpty = !0, this._focused = !1, this._cursorLineNumbers = [1], this._selections = [new Ut(1, 1, 1, 1)], this._renderData = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  _readFromSelections() {
    let e = !1;
    const t = rO ? this._selections.slice(0, 1) : this._selections, i = t.map((o) => o.positionLineNumber);
    i.sort((o, s) => o - s), Yu(this._cursorLineNumbers, i) || (this._cursorLineNumbers = i, e = !0);
    const r = t.every((o) => o.isEmpty());
    return this._selectionIsEmpty !== r && (this._selectionIsEmpty = r, e = !0), e;
  }
  // --- begin event handlers
  onThemeChanged(e) {
    return this._readFromSelections();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._renderLineHighlight = t.get(
      83
      /* renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      84
      /* renderLineHighlightOnlyWhenFocus */
    ), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._readFromSelections();
  }
  onFlushed(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollWidthChanged || e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._renderLineHighlightOnlyWhenFocus ? (this._focused = e.isFocused, !0) : !1;
  }
  // --- end event handlers
  prepareRender(e) {
    if (!this._shouldRenderThis()) {
      this._renderData = null;
      return;
    }
    const t = this._renderOne(e), i = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber, o = this._cursorLineNumbers.length;
    let s = 0;
    const a = [];
    for (let l = i; l <= r; l++) {
      const u = l - i;
      for (; s < o && this._cursorLineNumbers[s] < l; )
        s++;
      s < o && this._cursorLineNumbers[s] === l ? a[u] = t : a[u] = "";
    }
    this._renderData = a;
  }
  render(e, t) {
    if (!this._renderData)
      return "";
    const i = t - e;
    return i >= this._renderData.length ? "" : this._renderData[i];
  }
}
class rde extends o7 {
  _renderOne(e) {
    return `<div class="${"current-line" + (this._shouldRenderOther() ? " current-line-both" : "")}" style="width:${Math.max(e.scrollWidth, this._contentWidth)}px; height:${this._lineHeight}px;"></div>`;
  }
  _shouldRenderThis() {
    return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
  _shouldRenderOther() {
    return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
}
class ode extends o7 {
  _renderOne(e) {
    return `<div class="${"current-line" + (this._shouldRenderMargin() ? " current-line-margin" : "") + (this._shouldRenderOther() ? " current-line-margin-both" : "")}" style="width:${this._contentLeft}px; height:${this._lineHeight}px;"></div>`;
  }
  _shouldRenderMargin() {
    return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
  _shouldRenderThis() {
    return !0;
  }
  _shouldRenderOther() {
    return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
}
wa((n, e) => {
  rO = !1;
  const t = n.getColor(The);
  if (t && (e.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${t}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${t}; border: none; }`)), !t || t.isTransparent() || n.defines(K2)) {
    const i = n.getColor(K2);
    i && (rO = !0, e.addRule(`.monaco-editor .view-overlays .current-line { border: 2px solid ${i}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { border: 2px solid ${i}; }`), n.type === "hc" && (e.addRule(".monaco-editor .view-overlays .current-line { border-width: 1px; }"), e.addRule(".monaco-editor .margin-view-overlays .current-line-margin { border-width: 1px; }")));
  }
});
class sde extends Fg {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options;
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    const t = e.getDecorationsInViewport();
    let i = [], r = 0;
    for (let l = 0, u = t.length; l < u; l++) {
      const c = t[l];
      c.options.className && (i[r++] = c);
    }
    i = i.sort((l, u) => {
      if (l.options.zIndex < u.options.zIndex)
        return -1;
      if (l.options.zIndex > u.options.zIndex)
        return 1;
      const c = l.options.className, h = u.options.className;
      return c < h ? -1 : c > h ? 1 : G.compareRangesUsingStarts(l.range, u.range);
    });
    const o = e.visibleRange.startLineNumber, s = e.visibleRange.endLineNumber, a = [];
    for (let l = o; l <= s; l++) {
      const u = l - o;
      a[u] = "";
    }
    this._renderWholeLineDecorations(e, i, a), this._renderNormalDecorations(e, i, a), this._renderResult = a;
  }
  _renderWholeLineDecorations(e, t, i) {
    const r = String(this._lineHeight), o = e.visibleRange.startLineNumber, s = e.visibleRange.endLineNumber;
    for (let a = 0, l = t.length; a < l; a++) {
      const u = t[a];
      if (!u.options.isWholeLine)
        continue;
      const c = '<div class="cdr ' + u.options.className + '" style="left:0;width:100%;height:' + r + 'px;"></div>', h = Math.max(u.range.startLineNumber, o), d = Math.min(u.range.endLineNumber, s);
      for (let f = h; f <= d; f++) {
        const p = f - o;
        i[p] += c;
      }
    }
  }
  _renderNormalDecorations(e, t, i) {
    const r = String(this._lineHeight), o = e.visibleRange.startLineNumber;
    let s = null, a = !1, l = null;
    for (let u = 0, c = t.length; u < c; u++) {
      const h = t[u];
      if (h.options.isWholeLine)
        continue;
      const d = h.options.className, f = !!h.options.showIfCollapsed;
      let p = h.range;
      if (f && p.endColumn === 1 && p.endLineNumber !== p.startLineNumber && (p = new G(p.startLineNumber, p.startColumn, p.endLineNumber - 1, this._context.model.getLineMaxColumn(p.endLineNumber - 1))), s === d && a === f && G.areIntersectingOrTouching(l, p)) {
        l = G.plusRange(l, p);
        continue;
      }
      s !== null && this._renderNormalDecoration(e, l, s, a, r, o, i), s = d, a = f, l = p;
    }
    s !== null && this._renderNormalDecoration(e, l, s, a, r, o, i);
  }
  _renderNormalDecoration(e, t, i, r, o, s, a) {
    const l = e.linesVisibleRangesForRange(
      t,
      /*TODO@Alex*/
      i === "findMatch"
    );
    if (l)
      for (let u = 0, c = l.length; u < c; u++) {
        const h = l[u];
        if (h.outsideRenderedLine)
          continue;
        const d = h.lineNumber - s;
        if (r && h.ranges.length === 1) {
          const f = h.ranges[0];
          f.width === 0 && (h.ranges[0] = new th(f.left, this._typicalHalfwidthCharacterWidth));
        }
        for (let f = 0, p = h.ranges.length; f < p; f++) {
          const g = h.ranges[f], _ = '<div class="cdr ' + i + '" style="left:' + String(g.left) + "px;width:" + String(g.width) + "px;height:" + o + 'px;"></div>';
          a[d] += _;
        }
      }
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class PE extends Ce {
  onclick(e, t) {
    this._register(be(e, Ge.CLICK, (i) => t(new pa(i))));
  }
  onmousedown(e, t) {
    this._register(be(e, Ge.MOUSE_DOWN, (i) => t(new pa(i))));
  }
  onmouseover(e, t) {
    this._register(be(e, Ge.MOUSE_OVER, (i) => t(new pa(i))));
  }
  onnonbubblingmouseout(e, t) {
    this._register(i5(e, (i) => t(new pa(i))));
  }
  onkeydown(e, t) {
    this._register(be(e, Ge.KEY_DOWN, (i) => t(new Yi(i))));
  }
  onkeyup(e, t) {
    this._register(be(e, Ge.KEY_UP, (i) => t(new Yi(i))));
  }
  oninput(e, t) {
    this._register(be(e, Ge.INPUT, t));
  }
  onblur(e, t) {
    this._register(be(e, Ge.BLUR, t));
  }
  onfocus(e, t) {
    this._register(be(e, Ge.FOCUS, t));
  }
  ignoreGesture(e) {
    ri.ignoreTarget(e);
  }
}
const og = 11;
class ade extends PE {
  constructor(e) {
    super(), this._onActivate = e.onActivate, this.bgDomNode = document.createElement("div"), this.bgDomNode.className = "arrow-background", this.bgDomNode.style.position = "absolute", this.bgDomNode.style.width = e.bgWidth + "px", this.bgDomNode.style.height = e.bgHeight + "px", typeof e.top < "u" && (this.bgDomNode.style.top = "0px"), typeof e.left < "u" && (this.bgDomNode.style.left = "0px"), typeof e.bottom < "u" && (this.bgDomNode.style.bottom = "0px"), typeof e.right < "u" && (this.bgDomNode.style.right = "0px"), this.domNode = document.createElement("div"), this.domNode.className = e.className, this.domNode.classList.add(...e.icon.classNamesArray), this.domNode.style.position = "absolute", this.domNode.style.width = og + "px", this.domNode.style.height = og + "px", typeof e.top < "u" && (this.domNode.style.top = e.top + "px"), typeof e.left < "u" && (this.domNode.style.left = e.left + "px"), typeof e.bottom < "u" && (this.domNode.style.bottom = e.bottom + "px"), typeof e.right < "u" && (this.domNode.style.right = e.right + "px"), this._mouseMoveMonitor = this._register(new DE()), this.onmousedown(this.bgDomNode, (t) => this._arrowMouseDown(t)), this.onmousedown(this.domNode, (t) => this._arrowMouseDown(t)), this._mousedownRepeatTimer = this._register(new G_()), this._mousedownScheduleRepeatTimer = this._register(new oc());
  }
  _arrowMouseDown(e) {
    const t = () => {
      this._mousedownRepeatTimer.cancelAndSet(() => this._onActivate(), 41.666666666666664);
    };
    this._onActivate(), this._mousedownRepeatTimer.cancel(), this._mousedownScheduleRepeatTimer.cancelAndSet(t, 200), this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, pI, (i) => {
    }, () => {
      this._mousedownRepeatTimer.cancel(), this._mousedownScheduleRepeatTimer.cancel();
    }), e.preventDefault();
  }
}
class lde extends Ce {
  constructor(e, t, i) {
    super(), this._visibility = e, this._visibleClassName = t, this._invisibleClassName = i, this._domNode = null, this._isVisible = !1, this._isNeeded = !1, this._shouldBeVisible = !1, this._revealTimer = this._register(new oc());
  }
  // ----------------- Hide / Reveal
  applyVisibilitySetting(e) {
    return this._visibility === 2 ? !1 : this._visibility === 3 ? !0 : e;
  }
  setShouldBeVisible(e) {
    const t = this.applyVisibilitySetting(e);
    this._shouldBeVisible !== t && (this._shouldBeVisible = t, this.ensureVisibility());
  }
  setIsNeeded(e) {
    this._isNeeded !== e && (this._isNeeded = e, this.ensureVisibility());
  }
  setDomNode(e) {
    this._domNode = e, this._domNode.setClassName(this._invisibleClassName), this.setShouldBeVisible(!1);
  }
  ensureVisibility() {
    if (!this._isNeeded) {
      this._hide(!1);
      return;
    }
    this._shouldBeVisible ? this._reveal() : this._hide(!0);
  }
  _reveal() {
    this._isVisible || (this._isVisible = !0, this._revealTimer.setIfNotSet(() => {
      this._domNode && this._domNode.setClassName(this._visibleClassName);
    }, 0));
  }
  _hide(e) {
    this._revealTimer.cancel(), this._isVisible && (this._isVisible = !1, this._domNode && this._domNode.setClassName(this._invisibleClassName + (e ? " fade" : "")));
  }
}
const ude = 140;
class s7 extends PE {
  constructor(e) {
    super(), this._lazyRender = e.lazyRender, this._host = e.host, this._scrollable = e.scrollable, this._scrollByPage = e.scrollByPage, this._scrollbarState = e.scrollbarState, this._visibilityController = this._register(new lde(e.visibility, "visible scrollbar " + e.extraScrollbarClassName, "invisible scrollbar " + e.extraScrollbarClassName)), this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._mouseMoveMonitor = this._register(new DE()), this._shouldRender = !0, this.domNode = St(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this._visibilityController.setDomNode(this.domNode), this.domNode.setPosition("absolute"), this.onmousedown(this.domNode.domNode, (t) => this._domNodeMouseDown(t));
  }
  // ----------------- creation
  /**
   * Creates the dom node for an arrow & adds it to the container
   */
  _createArrow(e) {
    const t = this._register(new ade(e));
    this.domNode.domNode.appendChild(t.bgDomNode), this.domNode.domNode.appendChild(t.domNode);
  }
  /**
   * Creates the slider dom node, adds it to the container & hooks up the events
   */
  _createSlider(e, t, i, r) {
    this.slider = St(document.createElement("div")), this.slider.setClassName("slider"), this.slider.setPosition("absolute"), this.slider.setTop(e), this.slider.setLeft(t), typeof i == "number" && this.slider.setWidth(i), typeof r == "number" && this.slider.setHeight(r), this.slider.setLayerHinting(!0), this.slider.setContain("strict"), this.domNode.domNode.appendChild(this.slider.domNode), this.onmousedown(this.slider.domNode, (o) => {
      o.leftButton && (o.preventDefault(), this._sliderMouseDown(o, () => {
      }));
    }), this.onclick(this.slider.domNode, (o) => {
      o.leftButton && o.stopPropagation();
    });
  }
  // ----------------- Update state
  _onElementSize(e) {
    return this._scrollbarState.setVisibleSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollSize(e) {
    return this._scrollbarState.setScrollSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollPosition(e) {
    return this._scrollbarState.setScrollPosition(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  // ----------------- rendering
  beginReveal() {
    this._visibilityController.setShouldBeVisible(!0);
  }
  beginHide() {
    this._visibilityController.setShouldBeVisible(!1);
  }
  render() {
    this._shouldRender && (this._shouldRender = !1, this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize()), this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition()));
  }
  // ----------------- DOM events
  _domNodeMouseDown(e) {
    e.target === this.domNode.domNode && this._onMouseDown(e);
  }
  delegateMouseDown(e) {
    const t = this.domNode.domNode.getClientRects()[0].top, i = t + this._scrollbarState.getSliderPosition(), r = t + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize(), o = this._sliderMousePosition(e);
    i <= o && o <= r ? e.leftButton && (e.preventDefault(), this._sliderMouseDown(e, () => {
    })) : this._onMouseDown(e);
  }
  _onMouseDown(e) {
    let t, i;
    if (e.target === this.domNode.domNode && typeof e.browserEvent.offsetX == "number" && typeof e.browserEvent.offsetY == "number")
      t = e.browserEvent.offsetX, i = e.browserEvent.offsetY;
    else {
      const o = qa(this.domNode.domNode);
      t = e.posx - o.left, i = e.posy - o.top;
    }
    const r = this._mouseDownRelativePosition(t, i);
    this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(r) : this._scrollbarState.getDesiredScrollPositionFromOffset(r)), e.leftButton && (e.preventDefault(), this._sliderMouseDown(e, () => {
    }));
  }
  _sliderMouseDown(e, t) {
    const i = this._sliderMousePosition(e), r = this._sliderOrthogonalMousePosition(e), o = this._scrollbarState.clone();
    this.slider.toggleClassName("active", !0), this._mouseMoveMonitor.startMonitoring(e.target, e.buttons, pI, (s) => {
      const a = this._sliderOrthogonalMousePosition(s), l = Math.abs(a - r);
      if (Ro && l > ude) {
        this._setDesiredScrollPositionNow(o.getScrollPosition());
        return;
      }
      const c = this._sliderMousePosition(s) - i;
      this._setDesiredScrollPositionNow(o.getDesiredScrollPositionFromDelta(c));
    }, () => {
      this.slider.toggleClassName("active", !1), this._host.onDragEnd(), t();
    }), this._host.onDragStart();
  }
  _setDesiredScrollPositionNow(e) {
    const t = {};
    this.writeScrollPosition(t, e), this._scrollable.setScrollPositionNow(t);
  }
  updateScrollbarSize(e) {
    this._updateScrollbarSize(e), this._scrollbarState.setScrollbarSize(e), this._shouldRender = !0, this._lazyRender || this.render();
  }
  isNeeded() {
    return this._scrollbarState.isNeeded();
  }
}
const cde = 20;
class s_ {
  constructor(e, t, i, r, o, s) {
    this._scrollbarSize = Math.round(t), this._oppositeScrollbarSize = Math.round(i), this._arrowSize = Math.round(e), this._visibleSize = r, this._scrollSize = o, this._scrollPosition = s, this._computedAvailableSize = 0, this._computedIsNeeded = !1, this._computedSliderSize = 0, this._computedSliderRatio = 0, this._computedSliderPosition = 0, this._refreshComputedValues();
  }
  clone() {
    return new s_(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
  }
  setVisibleSize(e) {
    const t = Math.round(e);
    return this._visibleSize !== t ? (this._visibleSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollSize(e) {
    const t = Math.round(e);
    return this._scrollSize !== t ? (this._scrollSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollPosition(e) {
    const t = Math.round(e);
    return this._scrollPosition !== t ? (this._scrollPosition = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollbarSize(e) {
    this._scrollbarSize = e;
  }
  static _computeValues(e, t, i, r, o) {
    const s = Math.max(0, i - e), a = Math.max(0, s - 2 * t), l = r > 0 && r > i;
    if (!l)
      return {
        computedAvailableSize: Math.round(s),
        computedIsNeeded: l,
        computedSliderSize: Math.round(a),
        computedSliderRatio: 0,
        computedSliderPosition: 0
      };
    const u = Math.round(Math.max(cde, Math.floor(i * a / r))), c = (a - u) / (r - i), h = o * c;
    return {
      computedAvailableSize: Math.round(s),
      computedIsNeeded: l,
      computedSliderSize: Math.round(u),
      computedSliderRatio: c,
      computedSliderPosition: Math.round(h)
    };
  }
  _refreshComputedValues() {
    const e = s_._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    this._computedAvailableSize = e.computedAvailableSize, this._computedIsNeeded = e.computedIsNeeded, this._computedSliderSize = e.computedSliderSize, this._computedSliderRatio = e.computedSliderRatio, this._computedSliderPosition = e.computedSliderPosition;
  }
  getArrowSize() {
    return this._arrowSize;
  }
  getScrollPosition() {
    return this._scrollPosition;
  }
  getRectangleLargeSize() {
    return this._computedAvailableSize;
  }
  getRectangleSmallSize() {
    return this._scrollbarSize;
  }
  isNeeded() {
    return this._computedIsNeeded;
  }
  getSliderSize() {
    return this._computedSliderSize;
  }
  getSliderPosition() {
    return this._computedSliderPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.
   * `offset` is based on the same coordinate system as the `sliderPosition`.
   */
  getDesiredScrollPositionFromOffset(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize - this._computedSliderSize / 2;
    return Math.round(t / this._computedSliderRatio);
  }
  /**
   * Compute a desired `scrollPosition` from if offset is before or after the slider position.
   * If offset is before slider, treat as a page up (or left).  If after, page down (or right).
   * `offset` and `_computedSliderPosition` are based on the same coordinate system.
   * `_visibleSize` corresponds to a "page" of lines in the returned coordinate system.
   */
  getDesiredScrollPositionFromOffsetPaged(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize;
    let i = this._scrollPosition;
    return t < this._computedSliderPosition ? i -= this._visibleSize : i += this._visibleSize, i;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollPositionFromDelta(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = this._computedSliderPosition + e;
    return Math.round(t / this._computedSliderRatio);
  }
}
const hde = ya("scrollbar-button-left", Hi.triangleLeft), dde = ya("scrollbar-button-right", Hi.triangleRight);
class fde extends s7 {
  constructor(e, t, i) {
    const r = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new s_(t.horizontalHasArrows ? t.arrowSize : 0, t.horizontal === 2 ? 0 : t.horizontalScrollbarSize, t.vertical === 2 ? 0 : t.verticalScrollbarSize, r.width, r.scrollWidth, o.scrollLeft),
      visibility: t.horizontal,
      extraScrollbarClassName: "horizontal",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.horizontalHasArrows) {
      const s = (t.arrowSize - og) / 2, a = (t.horizontalScrollbarSize - og) / 2;
      this._createArrow({
        className: "scra",
        icon: hde,
        top: a,
        left: s,
        bottom: void 0,
        right: void 0,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new Yp(null, 1, 0))
      }), this._createArrow({
        className: "scra",
        icon: dde,
        top: a,
        left: void 0,
        bottom: void 0,
        right: s,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new Yp(null, -1, 0))
      });
    }
    this._createSlider(Math.floor((t.horizontalScrollbarSize - t.horizontalSliderSize) / 2), 0, void 0, t.horizontalSliderSize);
  }
  _updateSlider(e, t) {
    this.slider.setWidth(e), this.slider.setLeft(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(e), this.domNode.setHeight(t), this.domNode.setLeft(0), this.domNode.setBottom(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender, this._shouldRender = this._onElementSize(e.width) || this._shouldRender, this._shouldRender;
  }
  _mouseDownRelativePosition(e, t) {
    return e;
  }
  _sliderMousePosition(e) {
    return e.posx;
  }
  _sliderOrthogonalMousePosition(e) {
    return e.posy;
  }
  _updateScrollbarSize(e) {
    this.slider.setHeight(e);
  }
  writeScrollPosition(e, t) {
    e.scrollLeft = t;
  }
}
const pde = ya("scrollbar-button-up", Hi.triangleUp), gde = ya("scrollbar-button-down", Hi.triangleDown);
class mde extends s7 {
  constructor(e, t, i) {
    const r = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new s_(
        t.verticalHasArrows ? t.arrowSize : 0,
        t.vertical === 2 ? 0 : t.verticalScrollbarSize,
        // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
        0,
        r.height,
        r.scrollHeight,
        o.scrollTop
      ),
      visibility: t.vertical,
      extraScrollbarClassName: "vertical",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.verticalHasArrows) {
      const s = (t.arrowSize - og) / 2, a = (t.verticalScrollbarSize - og) / 2;
      this._createArrow({
        className: "scra",
        icon: pde,
        top: s,
        left: a,
        bottom: void 0,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new Yp(null, 0, 1))
      }), this._createArrow({
        className: "scra",
        icon: gde,
        top: void 0,
        left: a,
        bottom: s,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new Yp(null, 0, -1))
      });
    }
    this._createSlider(0, Math.floor((t.verticalScrollbarSize - t.verticalSliderSize) / 2), t.verticalSliderSize, void 0);
  }
  _updateSlider(e, t) {
    this.slider.setHeight(e), this.slider.setTop(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(t), this.domNode.setHeight(e), this.domNode.setRight(0), this.domNode.setTop(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender, this._shouldRender = this._onElementSize(e.height) || this._shouldRender, this._shouldRender;
  }
  _mouseDownRelativePosition(e, t) {
    return t;
  }
  _sliderMousePosition(e) {
    return e.posy;
  }
  _sliderOrthogonalMousePosition(e) {
    return e.posx;
  }
  _updateScrollbarSize(e) {
    this.slider.setWidth(e);
  }
  writeScrollPosition(e, t) {
    e.scrollTop = t;
  }
}
class Kb {
  constructor(e, t, i, r, o, s) {
    e = e | 0, t = t | 0, i = i | 0, r = r | 0, o = o | 0, s = s | 0, this.rawScrollLeft = i, this.rawScrollTop = s, e < 0 && (e = 0), i + e > t && (i = t - e), i < 0 && (i = 0), r < 0 && (r = 0), s + r > o && (s = o - r), s < 0 && (s = 0), this.width = e, this.scrollWidth = t, this.scrollLeft = i, this.height = r, this.scrollHeight = o, this.scrollTop = s;
  }
  equals(e) {
    return this.rawScrollLeft === e.rawScrollLeft && this.rawScrollTop === e.rawScrollTop && this.width === e.width && this.scrollWidth === e.scrollWidth && this.scrollLeft === e.scrollLeft && this.height === e.height && this.scrollHeight === e.scrollHeight && this.scrollTop === e.scrollTop;
  }
  withScrollDimensions(e, t) {
    return new Kb(typeof e.width < "u" ? e.width : this.width, typeof e.scrollWidth < "u" ? e.scrollWidth : this.scrollWidth, t ? this.rawScrollLeft : this.scrollLeft, typeof e.height < "u" ? e.height : this.height, typeof e.scrollHeight < "u" ? e.scrollHeight : this.scrollHeight, t ? this.rawScrollTop : this.scrollTop);
  }
  withScrollPosition(e) {
    return new Kb(this.width, this.scrollWidth, typeof e.scrollLeft < "u" ? e.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof e.scrollTop < "u" ? e.scrollTop : this.rawScrollTop);
  }
  createScrollEvent(e, t) {
    const i = this.width !== e.width, r = this.scrollWidth !== e.scrollWidth, o = this.scrollLeft !== e.scrollLeft, s = this.height !== e.height, a = this.scrollHeight !== e.scrollHeight, l = this.scrollTop !== e.scrollTop;
    return {
      inSmoothScrolling: t,
      oldWidth: e.width,
      oldScrollWidth: e.scrollWidth,
      oldScrollLeft: e.scrollLeft,
      width: this.width,
      scrollWidth: this.scrollWidth,
      scrollLeft: this.scrollLeft,
      oldHeight: e.height,
      oldScrollHeight: e.scrollHeight,
      oldScrollTop: e.scrollTop,
      height: this.height,
      scrollHeight: this.scrollHeight,
      scrollTop: this.scrollTop,
      widthChanged: i,
      scrollWidthChanged: r,
      scrollLeftChanged: o,
      heightChanged: s,
      scrollHeightChanged: a,
      scrollTopChanged: l
    };
  }
}
class AE extends Ce {
  constructor(e, t) {
    super(), this._onScroll = this._register(new q()), this.onScroll = this._onScroll.event, this._smoothScrollDuration = e, this._scheduleAtNextAnimationFrame = t, this._state = new Kb(0, 0, 0, 0, 0, 0), this._smoothScrolling = null;
  }
  dispose() {
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), super.dispose();
  }
  setSmoothScrollDuration(e) {
    this._smoothScrollDuration = e;
  }
  validateScrollPosition(e) {
    return this._state.withScrollPosition(e);
  }
  getScrollDimensions() {
    return this._state;
  }
  setScrollDimensions(e, t) {
    const i = this._state.withScrollDimensions(e, t);
    this._setState(i, !!this._smoothScrolling), this._smoothScrolling && this._smoothScrolling.acceptScrollDimensions(this._state);
  }
  /**
   * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
   * If no scroll animation is occurring, it will return the current scroll position instead.
   */
  getFutureScrollPosition() {
    return this._smoothScrolling ? this._smoothScrolling.to : this._state;
  }
  /**
   * Returns the current scroll position.
   * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
   */
  getCurrentScrollPosition() {
    return this._state;
  }
  setScrollPositionNow(e) {
    const t = this._state.withScrollPosition(e);
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), this._setState(t, !1);
  }
  setScrollPositionSmooth(e, t) {
    if (this._smoothScrollDuration === 0)
      return this.setScrollPositionNow(e);
    if (this._smoothScrolling) {
      e = {
        scrollLeft: typeof e.scrollLeft > "u" ? this._smoothScrolling.to.scrollLeft : e.scrollLeft,
        scrollTop: typeof e.scrollTop > "u" ? this._smoothScrolling.to.scrollTop : e.scrollTop
      };
      const i = this._state.withScrollPosition(e);
      if (this._smoothScrolling.to.scrollLeft === i.scrollLeft && this._smoothScrolling.to.scrollTop === i.scrollTop)
        return;
      let r;
      t ? r = new a_(this._smoothScrolling.from, i, this._smoothScrolling.startTime, this._smoothScrolling.duration) : r = this._smoothScrolling.combine(this._state, i, this._smoothScrollDuration), this._smoothScrolling.dispose(), this._smoothScrolling = r;
    } else {
      const i = this._state.withScrollPosition(e);
      this._smoothScrolling = a_.start(this._state, i, this._smoothScrollDuration);
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
    });
  }
  _performSmoothScrolling() {
    if (!this._smoothScrolling)
      return;
    const e = this._smoothScrolling.tick(), t = this._state.withScrollPosition(e);
    if (this._setState(t, !0), !!this._smoothScrolling) {
      if (e.isDone) {
        this._smoothScrolling.dispose(), this._smoothScrolling = null;
        return;
      }
      this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
        this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
      });
    }
  }
  _setState(e, t) {
    const i = this._state;
    i.equals(e) || (this._state = e, this._onScroll.fire(this._state.createScrollEvent(i, t)));
  }
}
class J2 {
  constructor(e, t, i) {
    this.scrollLeft = e, this.scrollTop = t, this.isDone = i;
  }
}
function KD(n, e) {
  const t = e - n;
  return function(i) {
    return n + t * Cde(i);
  };
}
function vde(n, e, t) {
  return function(i) {
    return i < t ? n(i / t) : e((i - t) / (1 - t));
  };
}
class a_ {
  constructor(e, t, i, r) {
    this.from = e, this.to = t, this.duration = r, this.startTime = i, this.animationFrameDisposable = null, this._initAnimations();
  }
  _initAnimations() {
    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width), this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
  }
  _initAnimation(e, t, i) {
    if (Math.abs(e - t) > 2.5 * i) {
      let o, s;
      return e < t ? (o = e + 0.75 * i, s = t - 0.75 * i) : (o = e - 0.75 * i, s = t + 0.75 * i), vde(KD(e, o), KD(s, t), 0.33);
    }
    return KD(e, t);
  }
  dispose() {
    this.animationFrameDisposable !== null && (this.animationFrameDisposable.dispose(), this.animationFrameDisposable = null);
  }
  acceptScrollDimensions(e) {
    this.to = e.withScrollPosition(this.to), this._initAnimations();
  }
  tick() {
    return this._tick(Date.now());
  }
  _tick(e) {
    const t = (e - this.startTime) / this.duration;
    if (t < 1) {
      const i = this.scrollLeft(t), r = this.scrollTop(t);
      return new J2(i, r, !1);
    }
    return new J2(this.to.scrollLeft, this.to.scrollTop, !0);
  }
  combine(e, t, i) {
    return a_.start(e, t, i);
  }
  static start(e, t, i) {
    i = i + 10;
    const r = Date.now() - 10;
    return new a_(e, t, r, i);
  }
}
function _de(n) {
  return Math.pow(n, 3);
}
function Cde(n) {
  return 1 - _de(1 - n);
}
const yde = 500, eW = 50;
class wde {
  constructor(e, t, i) {
    this.timestamp = e, this.deltaX = t, this.deltaY = i, this.score = 0;
  }
}
class oO {
  constructor() {
    this._capacity = 5, this._memory = [], this._front = -1, this._rear = -1;
  }
  isPhysicalMouseWheel() {
    if (this._front === -1 && this._rear === -1)
      return !1;
    let e = 1, t = 0, i = 1, r = this._rear;
    do {
      const o = r === this._front ? e : Math.pow(2, -i);
      if (e -= o, t += this._memory[r].score * o, r === this._front)
        break;
      r = (this._capacity + r - 1) % this._capacity, i++;
    } while (!0);
    return t <= 0.5;
  }
  accept(e, t, i) {
    const r = new wde(e, t, i);
    r.score = this._computeScore(r), this._front === -1 && this._rear === -1 ? (this._memory[0] = r, this._front = 0, this._rear = 0) : (this._rear = (this._rear + 1) % this._capacity, this._rear === this._front && (this._front = (this._front + 1) % this._capacity), this._memory[this._rear] = r);
  }
  /**
   * A score between 0 and 1 for `item`.
   *  - a score towards 0 indicates that the source appears to be a physical mouse wheel
   *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.
   */
  _computeScore(e) {
    if (Math.abs(e.deltaX) > 0 && Math.abs(e.deltaY) > 0)
      return 1;
    let t = 0.5;
    return this._front === -1 && this._rear === -1 || this._memory[this._rear], (!this._isAlmostInt(e.deltaX) || !this._isAlmostInt(e.deltaY)) && (t += 0.25), Math.min(Math.max(t, 0), 1);
  }
  _isAlmostInt(e) {
    return Math.abs(Math.round(e) - e) < 0.01;
  }
}
oO.INSTANCE = new oO();
class a7 extends PE {
  constructor(e, t, i) {
    super(), this._onScroll = this._register(new q()), this.onScroll = this._onScroll.event, this._onWillScroll = this._register(new q()), e.style.overflow = "hidden", this._options = bde(t), this._scrollable = i, this._register(this._scrollable.onScroll((o) => {
      this._onWillScroll.fire(o), this._onDidScroll(o), this._onScroll.fire(o);
    }));
    const r = {
      onMouseWheel: (o) => this._onMouseWheel(o),
      onDragStart: () => this._onDragStart(),
      onDragEnd: () => this._onDragEnd()
    };
    this._verticalScrollbar = this._register(new mde(this._scrollable, this._options, r)), this._horizontalScrollbar = this._register(new fde(this._scrollable, this._options, r)), this._domNode = document.createElement("div"), this._domNode.className = "monaco-scrollable-element " + this._options.className, this._domNode.setAttribute("role", "presentation"), this._domNode.style.position = "relative", this._domNode.style.overflow = "hidden", this._domNode.appendChild(e), this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode), this._domNode.appendChild(this._verticalScrollbar.domNode.domNode), this._options.useShadows ? (this._leftShadowDomNode = St(document.createElement("div")), this._leftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._leftShadowDomNode.domNode), this._topShadowDomNode = St(document.createElement("div")), this._topShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topShadowDomNode.domNode), this._topLeftShadowDomNode = St(document.createElement("div")), this._topLeftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topLeftShadowDomNode.domNode)) : (this._leftShadowDomNode = null, this._topShadowDomNode = null, this._topLeftShadowDomNode = null), this._listenOnDomNode = this._options.listenOnDomNode || this._domNode, this._mouseWheelToDispose = [], this._setListeningToMouseWheel(this._options.handleMouseWheel), this.onmouseover(this._listenOnDomNode, (o) => this._onMouseOver(o)), this.onnonbubblingmouseout(this._listenOnDomNode, (o) => this._onMouseOut(o)), this._hideTimeout = this._register(new oc()), this._isDragging = !1, this._mouseIsOver = !1, this._shouldRender = !0, this._revealOnScroll = !0;
  }
  dispose() {
    this._mouseWheelToDispose = bi(this._mouseWheelToDispose), super.dispose();
  }
  /**
   * Get the generated 'scrollable' dom node
   */
  getDomNode() {
    return this._domNode;
  }
  getOverviewRulerLayoutInfo() {
    return {
      parent: this._domNode,
      insertBefore: this._verticalScrollbar.domNode.domNode
    };
  }
  /**
   * Delegate a mouse down event to the vertical scrollbar.
   * This is to help with clicking somewhere else and having the scrollbar react.
   */
  delegateVerticalScrollbarMouseDown(e) {
    this._verticalScrollbar.delegateMouseDown(e);
  }
  getScrollDimensions() {
    return this._scrollable.getScrollDimensions();
  }
  setScrollDimensions(e) {
    this._scrollable.setScrollDimensions(e, !1);
  }
  /**
   * Update the class name of the scrollable element.
   */
  updateClassName(e) {
    this._options.className = e, kt && (this._options.className += " mac"), this._domNode.className = "monaco-scrollable-element " + this._options.className;
  }
  /**
   * Update configuration options for the scrollbar.
   * Really this is Editor.IEditorScrollbarOptions, but base shouldn't
   * depend on Editor.
   */
  updateOptions(e) {
    typeof e.handleMouseWheel < "u" && (this._options.handleMouseWheel = e.handleMouseWheel, this._setListeningToMouseWheel(this._options.handleMouseWheel)), typeof e.mouseWheelScrollSensitivity < "u" && (this._options.mouseWheelScrollSensitivity = e.mouseWheelScrollSensitivity), typeof e.fastScrollSensitivity < "u" && (this._options.fastScrollSensitivity = e.fastScrollSensitivity), typeof e.scrollPredominantAxis < "u" && (this._options.scrollPredominantAxis = e.scrollPredominantAxis), typeof e.horizontalScrollbarSize < "u" && this._horizontalScrollbar.updateScrollbarSize(e.horizontalScrollbarSize), this._options.lazyRender || this._render();
  }
  // -------------------- mouse wheel scrolling --------------------
  _setListeningToMouseWheel(e) {
    if (this._mouseWheelToDispose.length > 0 !== e && (this._mouseWheelToDispose = bi(this._mouseWheelToDispose), e)) {
      const i = (r) => {
        this._onMouseWheel(new Yp(r));
      };
      this._mouseWheelToDispose.push(be(this._listenOnDomNode, Ge.MOUSE_WHEEL, i, { passive: !1 }));
    }
  }
  _onMouseWheel(e) {
    const t = oO.INSTANCE;
    {
      const o = window.devicePixelRatio / bre();
      Ro || Is ? t.accept(Date.now(), e.deltaX / o, e.deltaY / o) : t.accept(Date.now(), e.deltaX, e.deltaY);
    }
    let i = !1;
    if (e.deltaY || e.deltaX) {
      let o = e.deltaY * this._options.mouseWheelScrollSensitivity, s = e.deltaX * this._options.mouseWheelScrollSensitivity;
      this._options.scrollPredominantAxis && (Math.abs(o) >= Math.abs(s) ? s = 0 : o = 0), this._options.flipAxes && ([o, s] = [s, o]);
      const a = !kt && e.browserEvent && e.browserEvent.shiftKey;
      (this._options.scrollYToX || a) && !s && (s = o, o = 0), e.browserEvent && e.browserEvent.altKey && (s = s * this._options.fastScrollSensitivity, o = o * this._options.fastScrollSensitivity);
      const l = this._scrollable.getFutureScrollPosition();
      let u = {};
      if (o) {
        const c = l.scrollTop - eW * o;
        this._verticalScrollbar.writeScrollPosition(u, c);
      }
      if (s) {
        const c = l.scrollLeft - eW * s;
        this._horizontalScrollbar.writeScrollPosition(u, c);
      }
      u = this._scrollable.validateScrollPosition(u), (l.scrollLeft !== u.scrollLeft || l.scrollTop !== u.scrollTop) && (this._options.mouseWheelSmoothScroll && t.isPhysicalMouseWheel() ? this._scrollable.setScrollPositionSmooth(u) : this._scrollable.setScrollPositionNow(u), i = !0);
    }
    let r = i;
    !r && this._options.alwaysConsumeMouseWheel && (r = !0), !r && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded()) && (r = !0), r && (e.preventDefault(), e.stopPropagation());
  }
  _onDidScroll(e) {
    this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender, this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender, this._options.useShadows && (this._shouldRender = !0), this._revealOnScroll && this._reveal(), this._options.lazyRender || this._render();
  }
  /**
   * Render / mutate the DOM now.
   * Should be used together with the ctor option `lazyRender`.
   */
  renderNow() {
    if (!this._options.lazyRender)
      throw new Error("Please use `lazyRender` together with `renderNow`!");
    this._render();
  }
  _render() {
    if (this._shouldRender && (this._shouldRender = !1, this._horizontalScrollbar.render(), this._verticalScrollbar.render(), this._options.useShadows)) {
      const e = this._scrollable.getCurrentScrollPosition(), t = e.scrollTop > 0, i = e.scrollLeft > 0, r = i ? " left" : "", o = t ? " top" : "", s = i || t ? " top-left-corner" : "";
      this._leftShadowDomNode.setClassName(`shadow${r}`), this._topShadowDomNode.setClassName(`shadow${o}`), this._topLeftShadowDomNode.setClassName(`shadow${s}${o}${r}`);
    }
  }
  // -------------------- fade in / fade out --------------------
  _onDragStart() {
    this._isDragging = !0, this._reveal();
  }
  _onDragEnd() {
    this._isDragging = !1, this._hide();
  }
  _onMouseOut(e) {
    this._mouseIsOver = !1, this._hide();
  }
  _onMouseOver(e) {
    this._mouseIsOver = !0, this._reveal();
  }
  _reveal() {
    this._verticalScrollbar.beginReveal(), this._horizontalScrollbar.beginReveal(), this._scheduleHide();
  }
  _hide() {
    !this._mouseIsOver && !this._isDragging && (this._verticalScrollbar.beginHide(), this._horizontalScrollbar.beginHide());
  }
  _scheduleHide() {
    !this._mouseIsOver && !this._isDragging && this._hideTimeout.cancelAndSet(() => this._hide(), yde);
  }
}
class l7 extends a7 {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new AE(0, (r) => Zl(r));
    super(e, t, i), this._register(i);
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
}
class DI extends a7 {
  constructor(e, t, i) {
    super(e, t, i);
  }
  setScrollPosition(e) {
    e.reuseAnimation ? this._scrollable.setScrollPositionSmooth(e, e.reuseAnimation) : this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
}
class u7 extends l7 {
  constructor(e, t) {
    super(e, t), this._element = e, this.onScroll((i) => {
      i.scrollTopChanged && (this._element.scrollTop = i.scrollTop), i.scrollLeftChanged && (this._element.scrollLeft = i.scrollLeft);
    }), this.scanDomNode();
  }
  scanDomNode() {
    this.setScrollDimensions({
      width: this._element.clientWidth,
      scrollWidth: this._element.scrollWidth,
      height: this._element.clientHeight,
      scrollHeight: this._element.scrollHeight
    }), this.setScrollPosition({
      scrollLeft: this._element.scrollLeft,
      scrollTop: this._element.scrollTop
    });
  }
}
function bde(n) {
  const e = {
    lazyRender: typeof n.lazyRender < "u" ? n.lazyRender : !1,
    className: typeof n.className < "u" ? n.className : "",
    useShadows: typeof n.useShadows < "u" ? n.useShadows : !0,
    handleMouseWheel: typeof n.handleMouseWheel < "u" ? n.handleMouseWheel : !0,
    flipAxes: typeof n.flipAxes < "u" ? n.flipAxes : !1,
    consumeMouseWheelIfScrollbarIsNeeded: typeof n.consumeMouseWheelIfScrollbarIsNeeded < "u" ? n.consumeMouseWheelIfScrollbarIsNeeded : !1,
    alwaysConsumeMouseWheel: typeof n.alwaysConsumeMouseWheel < "u" ? n.alwaysConsumeMouseWheel : !1,
    scrollYToX: typeof n.scrollYToX < "u" ? n.scrollYToX : !1,
    mouseWheelScrollSensitivity: typeof n.mouseWheelScrollSensitivity < "u" ? n.mouseWheelScrollSensitivity : 1,
    fastScrollSensitivity: typeof n.fastScrollSensitivity < "u" ? n.fastScrollSensitivity : 5,
    scrollPredominantAxis: typeof n.scrollPredominantAxis < "u" ? n.scrollPredominantAxis : !0,
    mouseWheelSmoothScroll: typeof n.mouseWheelSmoothScroll < "u" ? n.mouseWheelSmoothScroll : !0,
    arrowSize: typeof n.arrowSize < "u" ? n.arrowSize : 11,
    listenOnDomNode: typeof n.listenOnDomNode < "u" ? n.listenOnDomNode : null,
    horizontal: typeof n.horizontal < "u" ? n.horizontal : 1,
    horizontalScrollbarSize: typeof n.horizontalScrollbarSize < "u" ? n.horizontalScrollbarSize : 10,
    horizontalSliderSize: typeof n.horizontalSliderSize < "u" ? n.horizontalSliderSize : 0,
    horizontalHasArrows: typeof n.horizontalHasArrows < "u" ? n.horizontalHasArrows : !1,
    vertical: typeof n.vertical < "u" ? n.vertical : 1,
    verticalScrollbarSize: typeof n.verticalScrollbarSize < "u" ? n.verticalScrollbarSize : 10,
    verticalHasArrows: typeof n.verticalHasArrows < "u" ? n.verticalHasArrows : !1,
    verticalSliderSize: typeof n.verticalSliderSize < "u" ? n.verticalSliderSize : 0,
    scrollByPage: typeof n.scrollByPage < "u" ? n.scrollByPage : !1
  };
  return e.horizontalSliderSize = typeof n.horizontalSliderSize < "u" ? n.horizontalSliderSize : e.horizontalScrollbarSize, e.verticalSliderSize = typeof n.verticalSliderSize < "u" ? n.verticalSliderSize : e.verticalScrollbarSize, kt && (e.className += " mac"), e;
}
class Sde extends Fs {
  constructor(e, t, i, r) {
    super(e);
    const o = this._context.configuration.options, s = o.get(
      90
      /* scrollbar */
    ), a = o.get(
      64
      /* mouseWheelScrollSensitivity */
    ), l = o.get(
      32
      /* fastScrollSensitivity */
    ), u = o.get(
      93
      /* scrollPredominantAxis */
    ), c = {
      listenOnDomNode: i.domNode,
      className: "editor-scrollable " + kb(e.theme.type),
      useShadows: !1,
      lazyRender: !0,
      vertical: s.vertical,
      horizontal: s.horizontal,
      verticalHasArrows: s.verticalHasArrows,
      horizontalHasArrows: s.horizontalHasArrows,
      verticalScrollbarSize: s.verticalScrollbarSize,
      verticalSliderSize: s.verticalSliderSize,
      horizontalScrollbarSize: s.horizontalScrollbarSize,
      horizontalSliderSize: s.horizontalSliderSize,
      handleMouseWheel: s.handleMouseWheel,
      alwaysConsumeMouseWheel: s.alwaysConsumeMouseWheel,
      arrowSize: s.arrowSize,
      mouseWheelScrollSensitivity: a,
      fastScrollSensitivity: l,
      scrollPredominantAxis: u,
      scrollByPage: s.scrollByPage
    };
    this.scrollbar = this._register(new DI(t.domNode, c, this._context.viewLayout.getScrollable())), Ql.write(
      this.scrollbar.getDomNode(),
      5
      /* ScrollableElement */
    ), this.scrollbarDomNode = St(this.scrollbar.getDomNode()), this.scrollbarDomNode.setPosition("absolute"), this._setLayout();
    const h = (d, f, p) => {
      const g = {};
      if (f) {
        const _ = d.scrollTop;
        _ && (g.scrollTop = this._context.viewLayout.getCurrentScrollTop() + _, d.scrollTop = 0);
      }
      if (p) {
        const _ = d.scrollLeft;
        _ && (g.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + _, d.scrollLeft = 0);
      }
      this._context.model.setScrollPosition(
        g,
        1
        /* Immediate */
      );
    };
    this._register(be(i.domNode, "scroll", (d) => h(i.domNode, !0, !0))), this._register(be(t.domNode, "scroll", (d) => h(t.domNode, !0, !1))), this._register(be(r.domNode, "scroll", (d) => h(r.domNode, !0, !1))), this._register(be(this.scrollbarDomNode.domNode, "scroll", (d) => h(this.scrollbarDomNode.domNode, !0, !1)));
  }
  dispose() {
    super.dispose();
  }
  _setLayout() {
    const e = this._context.configuration.options, t = e.get(
      128
      /* layoutInfo */
    );
    this.scrollbarDomNode.setLeft(t.contentLeft), e.get(
      62
      /* minimap */
    ).side === "right" ? this.scrollbarDomNode.setWidth(t.contentWidth + t.minimap.minimapWidth) : this.scrollbarDomNode.setWidth(t.contentWidth), this.scrollbarDomNode.setHeight(t.height);
  }
  getOverviewRulerLayoutInfo() {
    return this.scrollbar.getOverviewRulerLayoutInfo();
  }
  getDomNode() {
    return this.scrollbarDomNode;
  }
  delegateVerticalScrollbarMouseDown(e) {
    this.scrollbar.delegateVerticalScrollbarMouseDown(e);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      90
      /* scrollbar */
    ) || e.hasChanged(
      64
      /* mouseWheelScrollSensitivity */
    ) || e.hasChanged(
      32
      /* fastScrollSensitivity */
    )) {
      const t = this._context.configuration.options, i = t.get(
        90
        /* scrollbar */
      ), r = t.get(
        64
        /* mouseWheelScrollSensitivity */
      ), o = t.get(
        32
        /* fastScrollSensitivity */
      ), s = t.get(
        93
        /* scrollPredominantAxis */
      ), a = {
        handleMouseWheel: i.handleMouseWheel,
        mouseWheelScrollSensitivity: r,
        fastScrollSensitivity: o,
        scrollPredominantAxis: s
      };
      this.scrollbar.updateOptions(a);
    }
    return e.hasChanged(
      128
      /* layoutInfo */
    ) && this._setLayout(), !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onThemeChanged(e) {
    return this.scrollbar.updateClassName("editor-scrollable " + kb(this._context.theme.type)), !0;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this.scrollbar.renderNow();
  }
}
class qb {
  constructor(e, t, i) {
    this.startLineNumber = +e, this.endLineNumber = +t, this.className = String(i);
  }
}
class RI extends Fg {
  _render(e, t, i) {
    const r = [];
    for (let a = e; a <= t; a++) {
      const l = a - e;
      r[l] = [];
    }
    if (i.length === 0)
      return r;
    i.sort((a, l) => a.className === l.className ? a.startLineNumber === l.startLineNumber ? a.endLineNumber - l.endLineNumber : a.startLineNumber - l.startLineNumber : a.className < l.className ? -1 : 1);
    let o = null, s = 0;
    for (let a = 0, l = i.length; a < l; a++) {
      const u = i[a], c = u.className;
      let h = Math.max(u.startLineNumber, e) - e;
      const d = Math.min(u.endLineNumber, t) - e;
      o === c ? (h = Math.max(s + 1, h), s = Math.max(s, d)) : (o = c, s = d);
      for (let f = h; f <= s; f++)
        r[f].push(o);
    }
    return r;
  }
}
class Ede extends RI {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._glyphMargin = t.get(
      46
      /* glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._glyphMargin = t.get(
      46
      /* glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport();
    let i = [], r = 0;
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.options.glyphMarginClassName;
      l && (i[r++] = new qb(a.range.startLineNumber, a.range.endLineNumber, l));
    }
    return i;
  }
  prepareRender(e) {
    if (!this._glyphMargin) {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, r = this._render(t, i, this._getDecorations(e)), o = this._lineHeight.toString(), s = this._glyphMarginLeft.toString(), a = this._glyphMarginWidth.toString(), l = '" style="left:' + s + "px;width:" + a + "px;height:" + o + 'px;"></div>', u = [];
    for (let c = t; c <= i; c++) {
      const h = c - t, d = r[h];
      d.length === 0 ? u[h] = "" : u[h] = '<div class="cgmr codicon ' + d.join(" ") + l;
    }
    this._renderResult = u;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class Lde extends Fg {
  constructor(e) {
    super(), this._context = e, this._primaryLineNumber = 0;
    const t = this._context.configuration.options, i = t.get(
      129
      /* wrappingInfo */
    ), r = t.get(
      40
      /* fontInfo */
    );
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._spaceWidth = r.spaceWidth, this._enabled = t.get(
      81
      /* renderIndentGuides */
    ), this._activeIndentEnabled = t.get(
      49
      /* highlightActiveIndentGuide */
    ), this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * r.typicalHalfwidthCharacterWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      129
      /* wrappingInfo */
    ), r = t.get(
      40
      /* fontInfo */
    );
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._spaceWidth = r.spaceWidth, this._enabled = t.get(
      81
      /* renderIndentGuides */
    ), this._activeIndentEnabled = t.get(
      49
      /* highlightActiveIndentGuide */
    ), this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * r.typicalHalfwidthCharacterWidth, !0;
  }
  onCursorStateChanged(e) {
    const t = e.selections[0], i = t.isEmpty() ? t.positionLineNumber : 0;
    return this._primaryLineNumber !== i ? (this._primaryLineNumber = i, !0) : !1;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLanguageConfigurationChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    if (!this._enabled) {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, { indentSize: r } = this._context.model.getTextModelOptions(), o = r * this._spaceWidth, s = e.scrollWidth, a = this._lineHeight, l = this._context.model.getLinesIndentGuides(t, i);
    let u = 0, c = 0, h = 0;
    if (this._activeIndentEnabled && this._primaryLineNumber) {
      const f = this._context.model.getActiveIndentGuide(this._primaryLineNumber, t, i);
      u = f.startLineNumber, c = f.endLineNumber, h = f.indent;
    }
    const d = [];
    for (let f = t; f <= i; f++) {
      const p = u <= f && f <= c, g = f - t, _ = l[g];
      let m = "";
      if (_ >= 1) {
        const v = e.visibleRangeForPosition(new ie(f, 1));
        let C = v ? v.left : 0;
        for (let y = 1; y <= _ && (m += `<div class="${p && y === h ? "cigra" : "cigr"}" style="left:${C}px;height:${a}px;width:${o}px"></div>`, C += o, !(C > s || this._maxIndentLeft > 0 && C > this._maxIndentLeft)); y++)
          ;
      }
      d[g] = m;
    }
    this._renderResult = d;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
wa((n, e) => {
  const t = n.getColor(xE);
  t && e.addRule(`.monaco-editor .lines-content .cigr { box-shadow: 1px 0 0 0 ${t} inset; }`);
  const i = n.getColor(NE) || t;
  i && e.addRule(`.monaco-editor .lines-content .cigra { box-shadow: 1px 0 0 0 ${i} inset; }`);
});
class Dde {
  constructor() {
    this._currentVisibleRange = new G(1, 1, 1, 1);
  }
  getCurrentVisibleRange() {
    return this._currentVisibleRange;
  }
  setCurrentVisibleRange(e) {
    this._currentVisibleRange = e;
  }
}
class Rde {
  constructor(e, t, i, r, o, s) {
    this.lineNumber = e, this.startColumn = t, this.endColumn = i, this.startScrollTop = r, this.stopScrollTop = o, this.scrollType = s, this.type = "range", this.minLineNumber = e, this.maxLineNumber = e;
  }
}
class Tde {
  constructor(e, t, i, r) {
    this.selections = e, this.startScrollTop = t, this.stopScrollTop = i, this.scrollType = r, this.type = "selections";
    let o = e[0].startLineNumber, s = e[0].endLineNumber;
    for (let a = 1, l = e.length; a < l; a++) {
      const u = e[a];
      o = Math.min(o, u.startLineNumber), s = Math.max(s, u.endLineNumber);
    }
    this.minLineNumber = o, this.maxLineNumber = s;
  }
}
class ME extends Fs {
  constructor(e, t) {
    super(e), this._linesContent = t, this._textRangeRestingSpot = document.createElement("div"), this._visibleLines = new n7(this), this.domNode = this._visibleLines.domNode;
    const i = this._context.configuration, r = this._context.configuration.options, o = r.get(
      40
      /* fontInfo */
    ), s = r.get(
      129
      /* wrappingInfo */
    );
    this._lineHeight = r.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = o.typicalHalfwidthCharacterWidth, this._isViewportWrapping = s.isViewportWrapping, this._revealHorizontalRightPadding = r.get(
      87
      /* revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = r.get(
      23
      /* cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = r.get(
      24
      /* cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !r.get(
      26
      /* disableLayerHinting */
    ), this._viewLineOptions = new _2(i, this._context.theme.type), Ql.write(
      this.domNode,
      7
      /* ViewLines */
    ), this.domNode.setClassName(`view-lines ${Dd}`), oo.applyFontInfo(this.domNode, o), this._maxLineWidth = 0, this._asyncUpdateLineWidths = new ro(() => {
      this._updateLineWidthsSlow();
    }, 200), this._asyncCheckMonospaceFontAssumptions = new ro(() => {
      this._checkMonospaceFontAssumptions();
    }, 2e3), this._lastRenderedData = new Dde(), this._horizontalRevealRequest = null;
  }
  dispose() {
    this._asyncUpdateLineWidths.dispose(), this._asyncCheckMonospaceFontAssumptions.dispose(), super.dispose();
  }
  getDomNode() {
    return this.domNode;
  }
  // ---- begin IVisibleLinesHost
  createVisibleLine() {
    return new Wl(this._viewLineOptions);
  }
  // ---- end IVisibleLinesHost
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e), e.hasChanged(
      129
      /* wrappingInfo */
    ) && (this._maxLineWidth = 0);
    const t = this._context.configuration.options, i = t.get(
      40
      /* fontInfo */
    ), r = t.get(
      129
      /* wrappingInfo */
    );
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._isViewportWrapping = r.isViewportWrapping, this._revealHorizontalRightPadding = t.get(
      87
      /* revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = t.get(
      23
      /* cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = t.get(
      24
      /* cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !t.get(
      26
      /* disableLayerHinting */
    ), oo.applyFontInfo(this.domNode, i), this._onOptionsMaybeChanged(), e.hasChanged(
      128
      /* layoutInfo */
    ) && (this._maxLineWidth = 0), !0;
  }
  _onOptionsMaybeChanged() {
    const e = this._context.configuration, t = new _2(e, this._context.theme.type);
    if (!this._viewLineOptions.equals(t)) {
      this._viewLineOptions = t;
      const i = this._visibleLines.getStartLineNumber(), r = this._visibleLines.getEndLineNumber();
      for (let o = i; o <= r; o++)
        this._visibleLines.getVisibleLine(o).onOptionsChanged(this._viewLineOptions);
      return !0;
    }
    return !1;
  }
  onCursorStateChanged(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let r = !1;
    for (let o = t; o <= i; o++)
      r = this._visibleLines.getVisibleLine(o).onSelectionChanged() || r;
    return r;
  }
  onDecorationsChanged(e) {
    {
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      for (let r = t; r <= i; r++)
        this._visibleLines.getVisibleLine(r).onDecorationsChanged();
    }
    return !0;
  }
  onFlushed(e) {
    const t = this._visibleLines.onFlushed(e);
    return this._maxLineWidth = 0, t;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onRevealRangeRequest(e) {
    const t = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.selections, e.verticalType);
    if (t === -1)
      return !1;
    let i = this._context.viewLayout.validateScrollPosition({ scrollTop: t });
    e.revealHorizontal ? e.range && e.range.startLineNumber !== e.range.endLineNumber ? i = {
      scrollTop: i.scrollTop,
      scrollLeft: 0
    } : e.range ? this._horizontalRevealRequest = new Rde(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType) : e.selections && e.selections.length > 0 && (this._horizontalRevealRequest = new Tde(e.selections, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType)) : this._horizontalRevealRequest = null;
    const o = Math.abs(this._context.viewLayout.getCurrentScrollTop() - i.scrollTop) <= this._lineHeight ? 1 : e.scrollType;
    return this._context.model.setScrollPosition(i, o), !0;
  }
  onScrollChanged(e) {
    if (this._horizontalRevealRequest && e.scrollLeftChanged && (this._horizontalRevealRequest = null), this._horizontalRevealRequest && e.scrollTopChanged) {
      const t = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop), i = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
      (e.scrollTop < t || e.scrollTop > i) && (this._horizontalRevealRequest = null);
    }
    return this.domNode.setWidth(e.scrollWidth), this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._context.model.setMaxLineWidth(this._maxLineWidth), this._visibleLines.onZonesChanged(e);
  }
  onThemeChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  // ---- end view event handlers
  // ----------- HELPERS FOR OTHERS
  getPositionFromDOMInfo(e, t) {
    const i = this._getViewLineDomNode(e);
    if (i === null)
      return null;
    const r = this._getLineNumberFor(i);
    if (r === -1 || r < 1 || r > this._context.model.getLineCount())
      return null;
    if (this._context.model.getLineMaxColumn(r) === 1)
      return new ie(r, 1);
    const o = this._visibleLines.getStartLineNumber(), s = this._visibleLines.getEndLineNumber();
    if (r < o || r > s)
      return null;
    let a = this._visibleLines.getVisibleLine(r).getColumnOfNodeOffset(r, e, t);
    const l = this._context.model.getLineMinColumn(r);
    return a < l && (a = l), new ie(r, a);
  }
  _getViewLineDomNode(e) {
    for (; e && e.nodeType === 1; ) {
      if (e.className === Wl.CLASS_NAME)
        return e;
      e = e.parentElement;
    }
    return null;
  }
  /**
   * @returns the line number of this view line dom node.
   */
  _getLineNumberFor(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    for (let r = t; r <= i; r++) {
      const o = this._visibleLines.getVisibleLine(r);
      if (e === o.getDomNode())
        return r;
    }
    return -1;
  }
  getLineWidth(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    return e < t || e > i ? -1 : this._visibleLines.getVisibleLine(e).getWidth();
  }
  linesVisibleRangesForRange(e, t) {
    if (this.shouldRender())
      return null;
    const i = e.endLineNumber, r = G.intersectRanges(e, this._lastRenderedData.getCurrentVisibleRange());
    if (!r)
      return null;
    let o = [], s = 0;
    const a = new v2(this.domNode.domNode, this._textRangeRestingSpot);
    let l = 0;
    t && (l = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new ie(r.startLineNumber, 1)).lineNumber);
    const u = this._visibleLines.getStartLineNumber(), c = this._visibleLines.getEndLineNumber();
    for (let h = r.startLineNumber; h <= r.endLineNumber; h++) {
      if (h < u || h > c)
        continue;
      const d = h === r.startLineNumber ? r.startColumn : 1, f = h === r.endLineNumber ? r.endColumn : this._context.model.getLineMaxColumn(h), p = this._visibleLines.getVisibleLine(h).getVisibleRangesForRange(d, f, a);
      if (p) {
        if (t && h < i) {
          const g = l;
          l = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new ie(h + 1, 1)).lineNumber, g !== l && (p.ranges[p.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth);
        }
        o[s++] = new Jle(p.outsideRenderedLine, h, p.ranges);
      }
    }
    return s === 0 ? null : o;
  }
  _visibleRangesForLineRange(e, t, i) {
    return this.shouldRender() || e < this._visibleLines.getStartLineNumber() || e > this._visibleLines.getEndLineNumber() ? null : this._visibleLines.getVisibleLine(e).getVisibleRangesForRange(t, i, new v2(this.domNode.domNode, this._textRangeRestingSpot));
  }
  visibleRangeForPosition(e) {
    const t = this._visibleRangesForLineRange(e.lineNumber, e.column, e.column);
    return t ? new eue(t.outsideRenderedLine, t.ranges[0].left) : null;
  }
  // --- implementation
  updateLineWidths() {
    this._updateLineWidths(!1);
  }
  /**
   * Updates the max line width if it is fast to compute.
   * Returns true if all lines were taken into account.
   * Returns false if some lines need to be reevaluated (in a slow fashion).
   */
  _updateLineWidthsFast() {
    return this._updateLineWidths(!0);
  }
  _updateLineWidthsSlow() {
    this._updateLineWidths(!1);
  }
  _updateLineWidths(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let r = 1, o = !0;
    for (let s = t; s <= i; s++) {
      const a = this._visibleLines.getVisibleLine(s);
      if (e && !a.getWidthIsFast()) {
        o = !1;
        continue;
      }
      r = Math.max(r, a.getWidth());
    }
    return o && t === 1 && i === this._context.model.getLineCount() && (this._maxLineWidth = 0), this._ensureMaxLineWidth(r), o;
  }
  _checkMonospaceFontAssumptions() {
    let e = -1, t = -1;
    const i = this._visibleLines.getStartLineNumber(), r = this._visibleLines.getEndLineNumber();
    for (let o = i; o <= r; o++) {
      const s = this._visibleLines.getVisibleLine(o);
      if (s.needsMonospaceFontCheck()) {
        const a = s.getWidth();
        a > t && (t = a, e = o);
      }
    }
    if (e !== -1 && !this._visibleLines.getVisibleLine(e).monospaceAssumptionsAreValid())
      for (let o = i; o <= r; o++)
        this._visibleLines.getVisibleLine(o).onMonospaceAssumptionsInvalidated();
  }
  prepareRender() {
    throw new Error("Not supported");
  }
  render() {
    throw new Error("Not supported");
  }
  renderText(e) {
    if (this._visibleLines.renderLines(e), this._lastRenderedData.setCurrentVisibleRange(e.visibleRange), this.domNode.setWidth(this._context.viewLayout.getScrollWidth()), this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1e6)), this._horizontalRevealRequest) {
      const i = this._horizontalRevealRequest;
      if (e.startLineNumber <= i.minLineNumber && i.maxLineNumber <= e.endLineNumber) {
        this._horizontalRevealRequest = null, this.onDidRender();
        const r = this._computeScrollLeftToReveal(i);
        r && (this._isViewportWrapping || this._ensureMaxLineWidth(r.maxHorizontalOffset), this._context.model.setScrollPosition({
          scrollLeft: r.scrollLeft
        }, i.scrollType));
      }
    }
    if (this._updateLineWidthsFast() || this._asyncUpdateLineWidths.schedule(), Is && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {
      const i = this._visibleLines.getStartLineNumber(), r = this._visibleLines.getEndLineNumber();
      for (let o = i; o <= r; o++)
        if (this._visibleLines.getVisibleLine(o).needsMonospaceFontCheck()) {
          this._asyncCheckMonospaceFontAssumptions.schedule();
          break;
        }
    }
    this._linesContent.setLayerHinting(this._canUseLayerHinting), this._linesContent.setContain("strict");
    const t = this._context.viewLayout.getCurrentScrollTop() - e.bigNumbersDelta;
    this._linesContent.setTop(-t), this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
  }
  // --- width
  _ensureMaxLineWidth(e) {
    const t = Math.ceil(e);
    this._maxLineWidth < t && (this._maxLineWidth = t, this._context.model.setMaxLineWidth(this._maxLineWidth));
  }
  _computeScrollTopToRevealRange(e, t, i, r, o) {
    const s = e.top, a = e.height, l = s + a;
    let u, c, h;
    if (r && r.length > 0) {
      let p = r[0].startLineNumber, g = r[0].endLineNumber;
      for (let _ = 1, m = r.length; _ < m; _++) {
        const v = r[_];
        p = Math.min(p, v.startLineNumber), g = Math.max(g, v.endLineNumber);
      }
      u = !1, c = this._context.viewLayout.getVerticalOffsetForLineNumber(p), h = this._context.viewLayout.getVerticalOffsetForLineNumber(g) + this._lineHeight;
    } else if (i)
      u = !0, c = this._context.viewLayout.getVerticalOffsetForLineNumber(i.startLineNumber), h = this._context.viewLayout.getVerticalOffsetForLineNumber(i.endLineNumber) + this._lineHeight;
    else
      return -1;
    if (!(t === "mouse" && this._cursorSurroundingLinesStyle === "default")) {
      const p = Math.min(a / this._lineHeight / 2, this._cursorSurroundingLines);
      c -= p * this._lineHeight, h += Math.max(0, p - 1) * this._lineHeight;
    }
    (o === 0 || o === 4) && (h += this._lineHeight);
    let f;
    if (h - c > a) {
      if (!u)
        return -1;
      f = c;
    } else if (o === 5 || o === 6)
      if (o === 6 && s <= c && h <= l)
        f = s;
      else {
        const p = Math.max(5 * this._lineHeight, a * 0.2), g = c - p, _ = h - a;
        f = Math.max(_, g);
      }
    else if (o === 1 || o === 2)
      if (o === 2 && s <= c && h <= l)
        f = s;
      else {
        const p = (c + h) / 2;
        f = Math.max(0, p - a / 2);
      }
    else
      f = this._computeMinimumScrolling(
        s,
        l,
        c,
        h,
        o === 3,
        o === 4
        /* Bottom */
      );
    return f;
  }
  _computeScrollLeftToReveal(e) {
    const t = this._context.viewLayout.getCurrentViewport(), i = t.left, r = i + t.width;
    let o = 1073741824, s = 0;
    if (e.type === "range") {
      const l = this._visibleRangesForLineRange(e.lineNumber, e.startColumn, e.endColumn);
      if (!l)
        return null;
      for (const u of l.ranges)
        o = Math.min(o, u.left), s = Math.max(s, u.left + u.width);
    } else
      for (const l of e.selections) {
        if (l.startLineNumber !== l.endLineNumber)
          return null;
        const u = this._visibleRangesForLineRange(l.startLineNumber, l.startColumn, l.endColumn);
        if (!u)
          return null;
        for (const c of u.ranges)
          o = Math.min(o, c.left), s = Math.max(s, c.left + c.width);
      }
    return o = Math.max(0, o - ME.HORIZONTAL_EXTRA_PX), s += this._revealHorizontalRightPadding, e.type === "selections" && s - o > t.width ? null : {
      scrollLeft: this._computeMinimumScrolling(i, r, o, s),
      maxHorizontalOffset: s
    };
  }
  _computeMinimumScrolling(e, t, i, r, o, s) {
    e = e | 0, t = t | 0, i = i | 0, r = r | 0, o = !!o, s = !!s;
    const a = t - e;
    if (r - i < a) {
      if (o)
        return i;
      if (s)
        return Math.max(0, r - a);
      if (i < e)
        return i;
      if (r > t)
        return Math.max(0, r - a);
    } else
      return i;
    return e;
  }
}
ME.HORIZONTAL_EXTRA_PX = 30;
class Ode extends RI {
  constructor(e) {
    super(), this._context = e;
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    return this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport();
    let i = [], r = 0;
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.options.linesDecorationsClassName;
      l && (i[r++] = new qb(a.range.startLineNumber, a.range.endLineNumber, l));
      const u = a.options.firstLineDecorationClassName;
      u && (i[r++] = new qb(a.range.startLineNumber, a.range.startLineNumber, u));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, r = this._render(t, i, this._getDecorations(e)), o = this._decorationsLeft.toString(), s = this._decorationsWidth.toString(), a = '" style="left:' + o + "px;width:" + s + 'px;"></div>', l = [];
    for (let u = t; u <= i; u++) {
      const c = u - t, h = r[c];
      let d = "";
      for (let f = 0, p = h.length; f < p; f++)
        d += '<div class="cldr ' + h[f] + a;
      l[c] = d;
    }
    this._renderResult = l;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
class xde extends RI {
  constructor(e) {
    super(), this._context = e, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport();
    let i = [], r = 0;
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o], l = a.options.marginClassName;
      l && (i[r++] = new qb(a.range.startLineNumber, a.range.endLineNumber, l));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, r = this._render(t, i, this._getDecorations(e)), o = [];
    for (let s = t; s <= i; s++) {
      const a = s - t, l = r[a];
      let u = "";
      for (let c = 0, h = l.length; c < h; c++)
        u += '<div class="cmdr ' + l[c] + '" style=""></div>';
      o[a] = u;
    }
    this._renderResult = o;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
class Xa {
  constructor(e, t, i, r) {
    this.r = Xa._clamp(e), this.g = Xa._clamp(t), this.b = Xa._clamp(i), this.a = Xa._clamp(r);
  }
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  static _clamp(e) {
    return e < 0 ? 0 : e > 255 ? 255 : e | 0;
  }
}
Xa.Empty = new Xa(0, 0, 0, 0);
class Q_ {
  constructor() {
    this._onDidChange = new q(), this.onDidChange = this._onDidChange.event, this._updateColorMap(), cn.onDidChange((e) => {
      e.changedColorMap && this._updateColorMap();
    });
  }
  static getInstance() {
    return this._INSTANCE || (this._INSTANCE = new Q_()), this._INSTANCE;
  }
  _updateColorMap() {
    const e = cn.getColorMap();
    if (!e) {
      this._colors = [Xa.Empty], this._backgroundIsLight = !0;
      return;
    }
    this._colors = [Xa.Empty];
    for (let i = 1; i < e.length; i++) {
      const r = e[i].rgba;
      this._colors[i] = new Xa(r.r, r.g, r.b, Math.round(r.a * 255));
    }
    let t = e[
      2
      /* DefaultBackground */
    ].getRelativeLuminance();
    this._backgroundIsLight = t >= 0.5, this._onDidChange.fire(void 0);
  }
  getColor(e) {
    return (e < 1 || e >= this._colors.length) && (e = 2), this._colors[e];
  }
  backgroundIsLight() {
    return this._backgroundIsLight;
  }
}
Q_._INSTANCE = null;
const Nde = (() => {
  const n = [];
  for (let e = 32; e <= 126; e++)
    n.push(e);
  return n.push(
    65533
    /* UNKNOWN_CODE */
  ), n;
})(), Ide = (n, e) => (n -= 32, n < 0 || n > 96 ? e <= 2 ? (n + 96) % 96 : 96 - 1 : n);
class l_ {
  constructor(e, t) {
    this.scale = t, this.charDataNormal = l_.soften(e, 12 / 15), this.charDataLight = l_.soften(e, 50 / 60);
  }
  static soften(e, t) {
    let i = new Uint8ClampedArray(e.length);
    for (let r = 0, o = e.length; r < o; r++)
      i[r] = Eb(e[r] * t);
    return i;
  }
  renderChar(e, t, i, r, o, s, a, l, u) {
    const c = 1 * this.scale, h = 2 * this.scale, d = u ? 1 : h;
    if (t + c > e.width || i + d > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const f = l ? this.charDataLight : this.charDataNormal, p = Ide(r, a), g = e.width * 4, _ = s.r, m = s.g, v = s.b, C = o.r - _, y = o.g - m, w = o.b - v, L = e.data;
    let S = p * c * h, E = i * g + t * 4;
    for (let D = 0; D < d; D++) {
      let x = E;
      for (let R = 0; R < c; R++) {
        const A = f[S++] / 255;
        L[x++] = _ + C * A, L[x++] = m + y * A, L[x++] = v + w * A, x++;
      }
      E += g;
    }
  }
  blockRenderChar(e, t, i, r, o, s, a) {
    const l = 1 * this.scale, u = 2 * this.scale, c = a ? 1 : u;
    if (t + l > e.width || i + c > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const h = e.width * 4, d = 0.5, f = o.r, p = o.g, g = o.b, _ = r.r - f, m = r.g - p, v = r.b - g, C = f + _ * d, y = p + m * d, w = g + v * d, L = e.data;
    let S = i * h + t * 4;
    for (let E = 0; E < c; E++) {
      let D = S;
      for (let x = 0; x < l; x++)
        L[D++] = C, L[D++] = y, L[D++] = w, D++;
      S += h;
    }
  }
}
function sg(n) {
  const e = this;
  let t = !1, i;
  return function() {
    return t || (t = !0, i = n.apply(e, arguments)), i;
  };
}
const tW = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}, iW = (n) => {
  const e = new Uint8ClampedArray(n.length / 2);
  for (let t = 0; t < n.length; t += 2)
    e[t >> 1] = tW[n[t]] << 4 | tW[n[t + 1]] & 15;
  return e;
}, nW = {
  1: sg(() => iW("0000511D6300CF609C709645A78432005642574171487021003C451900274D35D762755E8B629C5BA856AF57BA649530C167D1512A272A3F6038604460398526BCA2A968DB6F8957C768BE5FBE2FB467CF5D8D5B795DC7625B5DFF50DE64C466DB2FC47CD860A65E9A2EB96CB54CE06DA763AB2EA26860524D3763536601005116008177A8705E53AB738E6A982F88BAA35B5F5B626D9C636B449B737E5B7B678598869A662F6B5B8542706C704C80736A607578685B70594A49715A4522E792")),
  2: sg(() => iW("000000000000000055394F383D2800008B8B1F210002000081B1CBCBCC820000847AAF6B9AAF2119BE08B8881AD60000A44FD07DCCF107015338130C00000000385972265F390B406E2437634B4B48031B12B8A0847000001E15B29A402F0000000000004B33460B00007A752C2A0000000000004D3900000084394B82013400ABA5CFC7AD9C0302A45A3E5A98AB000089A43382D97900008BA54AA087A70A0248A6A7AE6DBE0000BF6F94987EA40A01A06DCFA7A7A9030496C32F77891D0000A99FB1A0AFA80603B29AB9CA75930D010C0948354D3900000C0948354F37460D0028BE673D8400000000AF9D7B6E00002B007AA8933400007AA642675C2700007984CFB9C3985B768772A8A6B7B20000CAAECAAFC4B700009F94A6009F840009D09F9BA4CA9C0000CC8FC76DC87F0000C991C472A2000000A894A48CA7B501079BA2C9C69BA20000B19A5D3FA89000005CA6009DA2960901B0A7F0669FB200009D009E00B7890000DAD0F5D092820000D294D4C48BD10000B5A7A4A3B1A50402CAB6CBA6A2000000B5A7A4A3B1A8044FCDADD19D9CB00000B7778F7B8AAE0803C9AB5D3F5D3F00009EA09EA0BAB006039EA0989A8C7900009B9EF4D6B7C00000A9A7816CACA80000ABAC84705D3F000096DA635CDC8C00006F486F266F263D4784006124097B00374F6D2D6D2D6D4A3A95872322000000030000000000008D8939130000000000002E22A5C9CBC70600AB25C0B5C9B400061A2DB04CA67001082AA6BEBEBFC606002321DACBC19E03087AA08B6768380000282FBAC0B8CA7A88AD25BBA5A29900004C396C5894A6000040485A6E356E9442A32CD17EADA70000B4237923628600003E2DE9C1D7B500002F25BBA5A2990000231DB6AFB4A804023025C0B5CAB588062B2CBDBEC0C706882435A75CA20000002326BD6A82A908048B4B9A5A668000002423A09CB4BB060025259C9D8A7900001C1FCAB2C7C700002A2A9387ABA200002626A4A47D6E9D14333163A0C87500004B6F9C2D643A257049364936493647358A34438355497F1A0000A24C1D590000D38DFFBDD4CD3126"))
};
class Lv {
  /**
   * Creates a new character renderer factory with the given scale.
   */
  static create(e, t) {
    if (this.lastCreated && e === this.lastCreated.scale && t === this.lastFontFamily)
      return this.lastCreated;
    let i;
    return nW[e] ? i = new l_(nW[e](), e) : i = Lv.createFromSampleData(Lv.createSampleData(t).data, e), this.lastFontFamily = t, this.lastCreated = i, i;
  }
  /**
   * Creates the font sample data, writing to a canvas.
   */
  static createSampleData(e) {
    const t = document.createElement("canvas"), i = t.getContext("2d");
    t.style.height = "16px", t.height = 16, t.width = 96 * 10, t.style.width = 96 * 10 + "px", i.fillStyle = "#ffffff", i.font = `bold 16px ${e}`, i.textBaseline = "middle";
    let r = 0;
    for (const o of Nde)
      i.fillText(String.fromCharCode(o), r, 16 / 2), r += 10;
    return i.getImageData(
      0,
      0,
      96 * 10,
      16
      /* SAMPLED_CHAR_HEIGHT */
    );
  }
  /**
   * Creates a character renderer from the canvas sample data.
   */
  static createFromSampleData(e, t) {
    if (e.length !== 61440)
      throw new Error("Unexpected source in MinimapCharRenderer");
    let r = Lv._downsample(e, t);
    return new l_(r, t);
  }
  static _downsampleChar(e, t, i, r, o) {
    const s = 1 * o, a = 2 * o;
    let l = r, u = 0;
    for (let c = 0; c < a; c++) {
      const h = c / a * 16, d = (c + 1) / a * 16;
      for (let f = 0; f < s; f++) {
        const p = f / s * 10, g = (f + 1) / s * 10;
        let _ = 0, m = 0;
        for (let C = h; C < d; C++) {
          const y = t + Math.floor(C) * 3840, w = 1 - (C - Math.floor(C));
          for (let L = p; L < g; L++) {
            const S = 1 - (L - Math.floor(L)), E = y + Math.floor(L) * 4, D = S * w;
            m += D, _ += e[E] * e[E + 3] / 255 * D;
          }
        }
        const v = _ / m;
        u = Math.max(u, v), i[l++] = Eb(v);
      }
    }
    return u;
  }
  static _downsample(e, t) {
    const i = 2 * t * 1 * t, r = i * 96, o = new Uint8ClampedArray(r);
    let s = 0, a = 0, l = 0;
    for (let u = 0; u < 96; u++)
      l = Math.max(l, this._downsampleChar(e, a, o, s, t)), s += i, a += 10 * 4;
    if (l > 0) {
      const u = 255 / l;
      for (let c = 0; c < r; c++)
        o[c] *= u;
    }
    return o;
  }
}
const Pde = 140, Ade = 2;
class Yb {
  constructor(e, t, i) {
    const r = e.options, o = r.get(
      126
      /* pixelRatio */
    ), s = r.get(
      128
      /* layoutInfo */
    ), a = s.minimap, l = r.get(
      40
      /* fontInfo */
    ), u = r.get(
      62
      /* minimap */
    );
    this.renderMinimap = a.renderMinimap, this.size = u.size, this.minimapHeightIsEditorHeight = a.minimapHeightIsEditorHeight, this.scrollBeyondLastLine = r.get(
      92
      /* scrollBeyondLastLine */
    ), this.showSlider = u.showSlider, this.pixelRatio = o, this.typicalHalfwidthCharacterWidth = l.typicalHalfwidthCharacterWidth, this.lineHeight = r.get(
      56
      /* lineHeight */
    ), this.minimapLeft = a.minimapLeft, this.minimapWidth = a.minimapWidth, this.minimapHeight = s.height, this.canvasInnerWidth = a.minimapCanvasInnerWidth, this.canvasInnerHeight = a.minimapCanvasInnerHeight, this.canvasOuterWidth = a.minimapCanvasOuterWidth, this.canvasOuterHeight = a.minimapCanvasOuterHeight, this.isSampling = a.minimapIsSampling, this.editorHeight = s.height, this.fontScale = a.minimapScale, this.minimapLineHeight = a.minimapLineHeight, this.minimapCharWidth = 1 * this.fontScale, this.charRenderer = sg(() => Lv.create(this.fontScale, l.fontFamily)), this.backgroundColor = Yb._getMinimapBackground(t, i);
  }
  static _getMinimapBackground(e, t) {
    const i = e.getColor(q3);
    return i ? new Xa(i.rgba.r, i.rgba.g, i.rgba.b, i.rgba.a) : t.getColor(
      2
      /* DefaultBackground */
    );
  }
  equals(e) {
    return this.renderMinimap === e.renderMinimap && this.size === e.size && this.minimapHeightIsEditorHeight === e.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === e.scrollBeyondLastLine && this.showSlider === e.showSlider && this.pixelRatio === e.pixelRatio && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.lineHeight === e.lineHeight && this.minimapLeft === e.minimapLeft && this.minimapWidth === e.minimapWidth && this.minimapHeight === e.minimapHeight && this.canvasInnerWidth === e.canvasInnerWidth && this.canvasInnerHeight === e.canvasInnerHeight && this.canvasOuterWidth === e.canvasOuterWidth && this.canvasOuterHeight === e.canvasOuterHeight && this.isSampling === e.isSampling && this.editorHeight === e.editorHeight && this.fontScale === e.fontScale && this.minimapLineHeight === e.minimapLineHeight && this.minimapCharWidth === e.minimapCharWidth && this.backgroundColor && this.backgroundColor.equals(e.backgroundColor);
  }
}
class Dv {
  constructor(e, t, i, r, o, s, a, l) {
    this.scrollTop = e, this.scrollHeight = t, this.sliderNeeded = i, this._computedSliderRatio = r, this.sliderTop = o, this.sliderHeight = s, this.startLineNumber = a, this.endLineNumber = l;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollTopFromDelta(e) {
    return Math.round(this.scrollTop + e / this._computedSliderRatio);
  }
  getDesiredScrollTopFromTouchLocation(e) {
    return Math.round((e - this.sliderHeight / 2) / this._computedSliderRatio);
  }
  static create(e, t, i, r, o, s, a, l, u, c, h) {
    const d = e.pixelRatio, f = e.minimapLineHeight, p = Math.floor(e.canvasInnerHeight / f), g = e.lineHeight;
    if (e.minimapHeightIsEditorHeight) {
      const w = l * e.lineHeight + (e.scrollBeyondLastLine ? o - e.lineHeight : 0), L = Math.max(1, Math.floor(o * o / w)), S = Math.max(0, e.minimapHeight - L), E = S / (c - o), D = u * E, x = S > 0, R = Math.floor(e.canvasInnerHeight / e.minimapLineHeight);
      return new Dv(u, c, x, E, D, L, 1, Math.min(a, R));
    }
    let _;
    if (s && i !== a) {
      const w = i - t + 1;
      _ = Math.floor(w * f / d);
    } else {
      const w = o / g;
      _ = Math.floor(w * f / d);
    }
    let m;
    e.scrollBeyondLastLine ? m = (a - 1) * f / d : m = Math.max(0, a * f / d - _), m = Math.min(e.minimapHeight - _, m);
    const v = m / (c - o), C = u * v;
    let y = 0;
    if (e.scrollBeyondLastLine && (y = o / g - 1), p >= a + y) {
      const L = a, S = m > 0;
      return new Dv(u, c, S, v, C, _, 1, L);
    } else {
      let w = Math.max(1, Math.floor(t - C * d / f));
      h && h.scrollHeight === c && (h.scrollTop > u && (w = Math.min(w, h.startLineNumber)), h.scrollTop < u && (w = Math.max(w, h.startLineNumber)));
      const L = Math.min(a, w + p - 1), S = (u - r) / g, E = (t - w + S) * f / d;
      return new Dv(u, c, !0, v, E, _, w, L);
    }
  }
}
class Xb {
  constructor(e) {
    this.dy = e;
  }
  onContentChanged() {
    this.dy = -1;
  }
  onTokensChanged() {
    this.dy = -1;
  }
}
Xb.INVALID = new Xb(-1);
class rW {
  constructor(e, t, i) {
    this.renderedLayout = e, this._imageData = t, this._renderedLines = new i7(() => Xb.INVALID), this._renderedLines._set(e.startLineNumber, i);
  }
  /**
   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.
   */
  linesEquals(e) {
    if (!this.scrollEquals(e))
      return !1;
    const i = this._renderedLines._get().lines;
    for (let r = 0, o = i.length; r < o; r++)
      if (i[r].dy === -1)
        return !1;
    return !0;
  }
  /**
   * Check if the current RenderData matches the new layout's scroll position
   */
  scrollEquals(e) {
    return this.renderedLayout.startLineNumber === e.startLineNumber && this.renderedLayout.endLineNumber === e.endLineNumber;
  }
  _get() {
    const e = this._renderedLines._get();
    return {
      imageData: this._imageData,
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines
    };
  }
  onLinesChanged(e, t) {
    return this._renderedLines.onLinesChanged(e, t);
  }
  onLinesDeleted(e, t) {
    this._renderedLines.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._renderedLines.onLinesInserted(e, t);
  }
  onTokensChanged(e) {
    return this._renderedLines.onTokensChanged(e);
  }
}
class TI {
  constructor(e, t, i, r) {
    this._backgroundFillData = TI._createBackgroundFillData(t, i, r), this._buffers = [
      e.createImageData(t, i),
      e.createImageData(t, i)
    ], this._lastUsedBuffer = 0;
  }
  getBuffer() {
    this._lastUsedBuffer = 1 - this._lastUsedBuffer;
    const e = this._buffers[this._lastUsedBuffer];
    return e.data.set(this._backgroundFillData), e;
  }
  static _createBackgroundFillData(e, t, i) {
    const r = i.r, o = i.g, s = i.b, a = new Uint8ClampedArray(e * t * 4);
    let l = 0;
    for (let u = 0; u < t; u++)
      for (let c = 0; c < e; c++)
        a[l] = r, a[l + 1] = o, a[l + 2] = s, a[l + 3] = 255, l += 4;
    return a;
  }
}
class u_ {
  constructor(e, t) {
    this.samplingRatio = e, this.minimapLines = t;
  }
  static compute(e, t, i) {
    if (e.renderMinimap === 0 || !e.isSampling)
      return [null, []];
    const r = e.pixelRatio, o = e.lineHeight, s = e.scrollBeyondLastLine, { minimapLineCount: a } = wp.computeContainedMinimapLineCount({
      viewLineCount: t,
      scrollBeyondLastLine: s,
      height: e.editorHeight,
      lineHeight: o,
      pixelRatio: r
    }), l = t / a, u = l / 2;
    if (!i || i.minimapLines.length === 0) {
      let C = [];
      if (C[0] = 1, a > 1) {
        for (let y = 0, w = a - 1; y < w; y++)
          C[y] = Math.round(y * l + u);
        C[a - 1] = t;
      }
      return [new u_(l, C), []];
    }
    const c = i.minimapLines, h = c.length;
    let d = [], f = 0, p = 0, g = 1;
    const _ = 10;
    let m = [], v = null;
    for (let C = 0; C < a; C++) {
      const y = Math.max(g, Math.round(C * l)), w = Math.max(y, Math.round((C + 1) * l));
      for (; f < h && c[f] < y; ) {
        if (m.length < _) {
          const S = f + 1 + p;
          v && v.type === "deleted" && v._oldIndex === f - 1 ? v.deleteToLineNumber++ : (v = { type: "deleted", _oldIndex: f, deleteFromLineNumber: S, deleteToLineNumber: S }, m.push(v)), p--;
        }
        f++;
      }
      let L;
      if (f < h && c[f] <= w)
        L = c[f], f++;
      else if (C === 0 ? L = 1 : C + 1 === a ? L = t : L = Math.round(C * l + u), m.length < _) {
        const S = f + 1 + p;
        v && v.type === "inserted" && v._i === C - 1 ? v.insertToLineNumber++ : (v = { type: "inserted", _i: C, insertFromLineNumber: S, insertToLineNumber: S }, m.push(v)), p++;
      }
      d[C] = L, g = L;
    }
    if (m.length < _)
      for (; f < h; ) {
        const C = f + 1 + p;
        v && v.type === "deleted" && v._oldIndex === f - 1 ? v.deleteToLineNumber++ : (v = { type: "deleted", _oldIndex: f, deleteFromLineNumber: C, deleteToLineNumber: C }, m.push(v)), p--, f++;
      }
    else
      m = [{ type: "flush" }];
    return [new u_(l, d), m];
  }
  modelLineToMinimapLine(e) {
    return Math.min(this.minimapLines.length, Math.max(1, Math.round(e / this.samplingRatio)));
  }
  /**
   * Will return null if the model line ranges are not intersecting with a sampled model line.
   */
  modelLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e) - 1;
    for (; i > 0 && this.minimapLines[i - 1] >= e; )
      i--;
    let r = this.modelLineToMinimapLine(t) - 1;
    for (; r + 1 < this.minimapLines.length && this.minimapLines[r + 1] <= t; )
      r++;
    if (i === r) {
      const o = this.minimapLines[i];
      if (o < e || o > t)
        return null;
    }
    return [i + 1, r + 1];
  }
  /**
   * Will always return a range, even if it is not intersecting with a sampled model line.
   */
  decorationLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e), r = this.modelLineToMinimapLine(t);
    return e !== t && r === i && (r === this.minimapLines.length ? i > 1 && i-- : r++), [i, r];
  }
  onLinesDeleted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    let i = this.minimapLines.length, r = 0;
    for (let o = this.minimapLines.length - 1; o >= 0 && !(this.minimapLines[o] < e.fromLineNumber); o--)
      this.minimapLines[o] <= e.toLineNumber ? (this.minimapLines[o] = Math.max(1, e.fromLineNumber - 1), i = Math.min(i, o), r = Math.max(r, o)) : this.minimapLines[o] -= t;
    return [i, r];
  }
  onLinesInserted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    for (let i = this.minimapLines.length - 1; i >= 0 && !(this.minimapLines[i] < e.fromLineNumber); i--)
      this.minimapLines[i] += t;
  }
}
class Mde extends Fs {
  constructor(e) {
    super(e), this.tokensColorTracker = Q_.getInstance(), this._selections = [], this._minimapSelections = null, this.options = new Yb(this._context.configuration, this._context.theme, this.tokensColorTracker);
    const [t] = u_.compute(this.options, this._context.model.getLineCount(), null);
    this._samplingState = t, this._shouldCheckSampling = !1, this._actual = new Zb(e.theme, this);
  }
  dispose() {
    this._actual.dispose(), super.dispose();
  }
  getDomNode() {
    return this._actual.getDomNode();
  }
  _onOptionsMaybeChanged() {
    const e = new Yb(this._context.configuration, this._context.theme, this.tokensColorTracker);
    return this.options.equals(e) ? !1 : (this.options = e, this._recreateLineSampling(), this._actual.onDidChangeOptions(), !0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._minimapSelections = null, this._actual.onSelectionChanged();
  }
  onDecorationsChanged(e) {
    return e.affectsMinimap ? this._actual.onDecorationsChanged() : !1;
  }
  onFlushed(e) {
    return this._samplingState && (this._shouldCheckSampling = !0), this._actual.onFlushed();
  }
  onLinesChanged(e) {
    if (this._samplingState) {
      const t = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.toLineNumber);
      return t ? this._actual.onLinesChanged(t[0], t[1]) : !1;
    } else
      return this._actual.onLinesChanged(e.fromLineNumber, e.toLineNumber);
  }
  onLinesDeleted(e) {
    if (this._samplingState) {
      const [t, i] = this._samplingState.onLinesDeleted(e);
      return t <= i && this._actual.onLinesChanged(t + 1, i + 1), this._shouldCheckSampling = !0, !0;
    } else
      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
  }
  onLinesInserted(e) {
    return this._samplingState ? (this._samplingState.onLinesInserted(e), this._shouldCheckSampling = !0, !0) : this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);
  }
  onScrollChanged(e) {
    return this._actual.onScrollChanged();
  }
  onThemeChanged(e) {
    return this._context.model.invalidateMinimapColorCache(), this._actual.onThemeChanged(), this._onOptionsMaybeChanged(), !0;
  }
  onTokensChanged(e) {
    if (this._samplingState) {
      let t = [];
      for (const i of e.ranges) {
        const r = this._samplingState.modelLineRangeToMinimapLineRange(i.fromLineNumber, i.toLineNumber);
        r && t.push({ fromLineNumber: r[0], toLineNumber: r[1] });
      }
      return t.length ? this._actual.onTokensChanged(t) : !1;
    } else
      return this._actual.onTokensChanged(e.ranges);
  }
  onTokensColorsChanged(e) {
    return this._onOptionsMaybeChanged(), this._actual.onTokensColorsChanged();
  }
  onZonesChanged(e) {
    return this._actual.onZonesChanged();
  }
  // --- end event handlers
  prepareRender(e) {
    this._shouldCheckSampling && (this._shouldCheckSampling = !1, this._recreateLineSampling());
  }
  render(e) {
    let t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber;
    this._samplingState && (t = this._samplingState.modelLineToMinimapLine(t), i = this._samplingState.modelLineToMinimapLine(i));
    const r = {
      viewportContainsWhitespaceGaps: e.viewportData.whitespaceViewportData.length > 0,
      scrollWidth: e.scrollWidth,
      scrollHeight: e.scrollHeight,
      viewportStartLineNumber: t,
      viewportEndLineNumber: i,
      viewportStartLineNumberVerticalOffset: e.getVerticalOffsetForLineNumber(t),
      scrollTop: e.scrollTop,
      scrollLeft: e.scrollLeft,
      viewportWidth: e.viewportWidth,
      viewportHeight: e.viewportHeight
    };
    this._actual.render(r);
  }
  //#region IMinimapModel
  _recreateLineSampling() {
    this._minimapSelections = null;
    const e = !!this._samplingState, [t, i] = u_.compute(this.options, this._context.model.getLineCount(), this._samplingState);
    if (this._samplingState = t, e && this._samplingState)
      for (const r of i)
        switch (r.type) {
          case "deleted":
            this._actual.onLinesDeleted(r.deleteFromLineNumber, r.deleteToLineNumber);
            break;
          case "inserted":
            this._actual.onLinesInserted(r.insertFromLineNumber, r.insertToLineNumber);
            break;
          case "flush":
            this._actual.onFlushed();
            break;
        }
  }
  getLineCount() {
    return this._samplingState ? this._samplingState.minimapLines.length : this._context.model.getLineCount();
  }
  getRealLineCount() {
    return this._context.model.getLineCount();
  }
  getLineContent(e) {
    return this._samplingState ? this._context.model.getLineContent(this._samplingState.minimapLines[e - 1]) : this._context.model.getLineContent(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    if (this._samplingState) {
      let r = [];
      for (let o = 0, s = t - e + 1; o < s; o++)
        i[o] ? r[o] = this._context.model.getViewLineData(this._samplingState.minimapLines[e + o - 1]) : r[o] = null;
      return r;
    }
    return this._context.model.getMinimapLinesRenderingData(e, t, i).data;
  }
  getSelections() {
    if (this._minimapSelections === null)
      if (this._samplingState) {
        this._minimapSelections = [];
        for (const e of this._selections) {
          const [t, i] = this._samplingState.decorationLineRangeToMinimapLineRange(e.startLineNumber, e.endLineNumber);
          this._minimapSelections.push(new Ut(t, e.startColumn, i, e.endColumn));
        }
      } else
        this._minimapSelections = this._selections;
    return this._minimapSelections;
  }
  getMinimapDecorationsInViewport(e, t) {
    let i;
    if (this._samplingState) {
      const o = this._samplingState.minimapLines[e - 1], s = this._samplingState.minimapLines[t - 1];
      i = new G(o, 1, s, this._context.model.getLineMaxColumn(s));
    } else
      i = new G(e, 1, t, this._context.model.getLineMaxColumn(t));
    const r = this._context.model.getDecorationsInViewport(i);
    if (this._samplingState) {
      let o = [];
      for (const s of r) {
        if (!s.options.minimap)
          continue;
        const a = s.range, l = this._samplingState.modelLineToMinimapLine(a.startLineNumber), u = this._samplingState.modelLineToMinimapLine(a.endLineNumber);
        o.push(new X5(new G(l, a.startColumn, u, a.endColumn), s.options));
      }
      return o;
    }
    return r;
  }
  getOptions() {
    return this._context.model.getTextModelOptions();
  }
  revealLineNumber(e) {
    this._samplingState && (e = this._samplingState.minimapLines[e - 1]), this._context.model.revealRange(
      "mouse",
      !1,
      new G(e, 1, e, 1),
      1,
      0
      /* Smooth */
    );
  }
  setScrollTop(e) {
    this._context.model.setScrollPosition(
      {
        scrollTop: e
      },
      1
      /* Immediate */
    );
  }
}
class Zb extends Ce {
  constructor(e, t) {
    super(), this._renderDecorations = !1, this._gestureInProgress = !1, this._theme = e, this._model = t, this._lastRenderData = null, this._buffers = null, this._selectionColor = this._theme.getColor(U2), this._domNode = St(document.createElement("div")), Ql.write(
      this._domNode,
      8
      /* Minimap */
    ), this._domNode.setClassName(this._getMinimapDomNodeClassName()), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._shadow = St(document.createElement("div")), this._shadow.setClassName("minimap-shadow-hidden"), this._domNode.appendChild(this._shadow), this._canvas = St(document.createElement("canvas")), this._canvas.setPosition("absolute"), this._canvas.setLeft(0), this._domNode.appendChild(this._canvas), this._decorationsCanvas = St(document.createElement("canvas")), this._decorationsCanvas.setPosition("absolute"), this._decorationsCanvas.setClassName("minimap-decorations-layer"), this._decorationsCanvas.setLeft(0), this._domNode.appendChild(this._decorationsCanvas), this._slider = St(document.createElement("div")), this._slider.setPosition("absolute"), this._slider.setClassName("minimap-slider"), this._slider.setLayerHinting(!0), this._slider.setContain("strict"), this._domNode.appendChild(this._slider), this._sliderHorizontal = St(document.createElement("div")), this._sliderHorizontal.setPosition("absolute"), this._sliderHorizontal.setClassName("minimap-slider-horizontal"), this._slider.appendChild(this._sliderHorizontal), this._applyLayout(), this._mouseDownListener = io(this._domNode.domNode, "mousedown", (i) => {
      if (i.preventDefault(), this._model.options.renderMinimap === 0 || !this._lastRenderData)
        return;
      if (this._model.options.size !== "proportional") {
        if (i.leftButton && this._lastRenderData) {
          const u = qa(this._slider.domNode), c = u.top + u.height / 2;
          this._startSliderDragging(i.buttons, i.posx, c, i.posy, this._lastRenderData.renderedLayout);
        }
        return;
      }
      const o = this._model.options.minimapLineHeight, s = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * i.browserEvent.offsetY;
      let l = Math.floor(s / o) + this._lastRenderData.renderedLayout.startLineNumber;
      l = Math.min(l, this._model.getLineCount()), this._model.revealLineNumber(l);
    }), this._sliderMouseMoveMonitor = new DE(), this._sliderMouseDownListener = io(this._slider.domNode, "mousedown", (i) => {
      i.preventDefault(), i.stopPropagation(), i.leftButton && this._lastRenderData && this._startSliderDragging(i.buttons, i.posx, i.posy, i.posy, this._lastRenderData.renderedLayout);
    }), this._gestureDisposable = ri.addTarget(this._domNode.domNode), this._sliderTouchStartListener = be(this._domNode.domNode, Ri.Start, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && (this._slider.toggleClassName("active", !0), this._gestureInProgress = !0, this.scrollDueToTouchEvent(i));
    }, { passive: !1 }), this._sliderTouchMoveListener = be(this._domNode.domNode, Ri.Change, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && this._gestureInProgress && this.scrollDueToTouchEvent(i);
    }, { passive: !1 }), this._sliderTouchEndListener = io(this._domNode.domNode, Ri.End, (i) => {
      i.preventDefault(), i.stopPropagation(), this._gestureInProgress = !1, this._slider.toggleClassName("active", !1);
    });
  }
  _startSliderDragging(e, t, i, r, o) {
    this._slider.toggleClassName("active", !0);
    const s = (a, l) => {
      const u = Math.abs(l - t);
      if (Ro && u > Pde) {
        this._model.setScrollTop(o.scrollTop);
        return;
      }
      const c = a - i;
      this._model.setScrollTop(o.getDesiredScrollTopFromDelta(c));
    };
    r !== i && s(r, t), this._sliderMouseMoveMonitor.startMonitoring(this._slider.domNode, e, pI, (a) => s(a.posy, a.posx), () => {
      this._slider.toggleClassName("active", !1);
    });
  }
  scrollDueToTouchEvent(e) {
    const t = this._domNode.domNode.getBoundingClientRect().top, i = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(e.pageY - t);
    this._model.setScrollTop(i);
  }
  dispose() {
    this._mouseDownListener.dispose(), this._sliderMouseMoveMonitor.dispose(), this._sliderMouseDownListener.dispose(), this._gestureDisposable.dispose(), this._sliderTouchStartListener.dispose(), this._sliderTouchMoveListener.dispose(), this._sliderTouchEndListener.dispose(), super.dispose();
  }
  _getMinimapDomNodeClassName() {
    return this._model.options.showSlider === "always" ? "minimap slider-always" : "minimap slider-mouseover";
  }
  getDomNode() {
    return this._domNode;
  }
  _applyLayout() {
    this._domNode.setLeft(this._model.options.minimapLeft), this._domNode.setWidth(this._model.options.minimapWidth), this._domNode.setHeight(this._model.options.minimapHeight), this._shadow.setHeight(this._model.options.minimapHeight), this._canvas.setWidth(this._model.options.canvasOuterWidth), this._canvas.setHeight(this._model.options.canvasOuterHeight), this._canvas.domNode.width = this._model.options.canvasInnerWidth, this._canvas.domNode.height = this._model.options.canvasInnerHeight, this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth), this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight), this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth, this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight, this._slider.setWidth(this._model.options.minimapWidth);
  }
  _getBuffer() {
    return this._buffers || this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0 && (this._buffers = new TI(this._canvas.domNode.getContext("2d"), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor)), this._buffers ? this._buffers.getBuffer() : null;
  }
  // ---- begin view event handlers
  onDidChangeOptions() {
    this._lastRenderData = null, this._buffers = null, this._applyLayout(), this._domNode.setClassName(this._getMinimapDomNodeClassName());
  }
  onSelectionChanged() {
    return this._renderDecorations = !0, !0;
  }
  onDecorationsChanged() {
    return this._renderDecorations = !0, !0;
  }
  onFlushed() {
    return this._lastRenderData = null, !0;
  }
  onLinesChanged(e, t) {
    return this._lastRenderData ? this._lastRenderData.onLinesChanged(e, t) : !1;
  }
  onLinesDeleted(e, t) {
    return this._lastRenderData && this._lastRenderData.onLinesDeleted(e, t), !0;
  }
  onLinesInserted(e, t) {
    return this._lastRenderData && this._lastRenderData.onLinesInserted(e, t), !0;
  }
  onScrollChanged() {
    return this._renderDecorations = !0, !0;
  }
  onThemeChanged() {
    return this._selectionColor = this._theme.getColor(U2), this._renderDecorations = !0, !0;
  }
  onTokensChanged(e) {
    return this._lastRenderData ? this._lastRenderData.onTokensChanged(e) : !1;
  }
  onTokensColorsChanged() {
    return this._lastRenderData = null, this._buffers = null, !0;
  }
  onZonesChanged() {
    return this._lastRenderData = null, !0;
  }
  // --- end event handlers
  render(e) {
    if (this._model.options.renderMinimap === 0) {
      this._shadow.setClassName("minimap-shadow-hidden"), this._sliderHorizontal.setWidth(0), this._sliderHorizontal.setHeight(0);
      return;
    }
    e.scrollLeft + e.viewportWidth >= e.scrollWidth ? this._shadow.setClassName("minimap-shadow-hidden") : this._shadow.setClassName("minimap-shadow-visible");
    const i = Dv.create(this._model.options, e.viewportStartLineNumber, e.viewportEndLineNumber, e.viewportStartLineNumberVerticalOffset, e.viewportHeight, e.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), e.scrollTop, e.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);
    this._slider.setDisplay(i.sliderNeeded ? "block" : "none"), this._slider.setTop(i.sliderTop), this._slider.setHeight(i.sliderHeight);
    const r = e.scrollLeft / this._model.options.typicalHalfwidthCharacterWidth, o = Math.min(this._model.options.minimapWidth, Math.round(r * this._model.options.minimapCharWidth / this._model.options.pixelRatio));
    this._sliderHorizontal.setLeft(o), this._sliderHorizontal.setWidth(this._model.options.minimapWidth - o), this._sliderHorizontal.setTop(0), this._sliderHorizontal.setHeight(i.sliderHeight), this.renderDecorations(i), this._lastRenderData = this.renderLines(i);
  }
  renderDecorations(e) {
    if (this._renderDecorations) {
      this._renderDecorations = !1;
      const t = this._model.getSelections(), i = this._model.getMinimapDecorationsInViewport(e.startLineNumber, e.endLineNumber), { canvasInnerWidth: r, canvasInnerHeight: o } = this._model.options, s = this._model.options.minimapLineHeight, a = this._model.options.minimapCharWidth, l = this._model.getOptions().tabSize, u = this._decorationsCanvas.domNode.getContext("2d");
      u.clearRect(0, 0, r, o);
      const c = /* @__PURE__ */ new Map();
      for (let h = 0; h < t.length; h++) {
        const d = t[h];
        for (let f = d.startLineNumber; f <= d.endLineNumber; f++)
          this.renderDecorationOnLine(u, c, d, this._selectionColor, e, f, s, s, l, a);
      }
      for (let h = 0; h < i.length; h++) {
        const d = i[h];
        if (!d.options.minimap)
          continue;
        const f = d.options.minimap.getColor(this._theme);
        for (let p = d.range.startLineNumber; p <= d.range.endLineNumber; p++)
          switch (d.options.minimap.position) {
            case Qp.Inline:
              this.renderDecorationOnLine(u, c, d.range, f, e, p, s, s, l, a);
              continue;
            case Qp.Gutter:
              const g = (p - e.startLineNumber) * s, _ = 2;
              this.renderDecoration(u, f, _, g, Ade, s);
              continue;
          }
      }
    }
  }
  renderDecorationOnLine(e, t, i, r, o, s, a, l, u, c) {
    const h = (s - o.startLineNumber) * l;
    if (h + a < 0 || h > this._model.options.canvasInnerHeight)
      return;
    let d = t.get(s);
    const f = !d;
    if (!d) {
      const y = this._model.getLineContent(s);
      d = [Ym];
      for (let w = 1; w < y.length + 1; w++) {
        const L = y.charCodeAt(w - 1), S = L === 9 ? u * c : el(L) ? 2 * c : c;
        d[w] = d[w - 1] + S;
      }
      t.set(s, d);
    }
    const { startColumn: p, endColumn: g, startLineNumber: _, endLineNumber: m } = i, v = _ === s ? d[p - 1] : Ym, C = m > s ? d.length - 1 : g - 1;
    if (C > 0) {
      const y = d[C] - v || 2;
      this.renderDecoration(e, r, v, h, y, a);
    }
    f && this.renderLineHighlight(e, r, h, a);
  }
  renderLineHighlight(e, t, i, r) {
    e.fillStyle = t && t.transparent(0.5).toString() || "", e.fillRect(Ym, i, e.canvas.width, r);
  }
  renderDecoration(e, t, i, r, o, s) {
    e.fillStyle = t && t.toString() || "", e.fillRect(i, r, o, s);
  }
  renderLines(e) {
    const t = e.startLineNumber, i = e.endLineNumber, r = this._model.options.minimapLineHeight;
    if (this._lastRenderData && this._lastRenderData.linesEquals(e)) {
      const R = this._lastRenderData._get();
      return new rW(e, R.imageData, R.lines);
    }
    const o = this._getBuffer();
    if (!o)
      return null;
    let [s, a, l] = Zb._renderUntouchedLines(o, t, i, r, this._lastRenderData);
    const u = this._model.getMinimapLinesRenderingData(t, i, l), c = this._model.getOptions().tabSize, h = this._model.options.backgroundColor, d = this._model.tokensColorTracker, f = d.backgroundIsLight(), p = this._model.options.renderMinimap, g = this._model.options.charRenderer(), _ = this._model.options.fontScale, m = this._model.options.minimapCharWidth, C = (p === 1 ? 2 : 2 + 1) * _, y = r > C ? Math.floor((r - C) / 2) : 0;
    let w = 0;
    const L = [];
    for (let R = 0, A = i - t + 1; R < A; R++)
      l[R] && Zb._renderLine(o, h, f, p, m, d, g, w, y, c, u[R], _, r), L[R] = new Xb(w), w += r;
    const S = s === -1 ? 0 : s, D = (a === -1 ? o.height : a) - S;
    return this._canvas.domNode.getContext("2d").putImageData(o, 0, 0, 0, S, o.width, D), new rW(e, o, L);
  }
  static _renderUntouchedLines(e, t, i, r, o) {
    const s = [];
    if (!o) {
      for (let E = 0, D = i - t + 1; E < D; E++)
        s[E] = !0;
      return [-1, -1, s];
    }
    const a = o._get(), l = a.imageData.data, u = a.rendLineNumberStart, c = a.lines, h = c.length, d = e.width, f = e.data, p = (i - t + 1) * r * d * 4;
    let g = -1, _ = -1, m = -1, v = -1, C = -1, y = -1, w = 0;
    for (let E = t; E <= i; E++) {
      const D = E - t, x = E - u, R = x >= 0 && x < h ? c[x].dy : -1;
      if (R === -1) {
        s[D] = !0, w += r;
        continue;
      }
      const A = R * d * 4, M = (R + r) * d * 4, z = w * d * 4, j = (w + r) * d * 4;
      v === A && y === z ? (v = M, y = j) : (m !== -1 && (f.set(l.subarray(m, v), C), g === -1 && m === 0 && m === C && (g = v), _ === -1 && v === p && m === C && (_ = m)), m = A, v = M, C = z, y = j), s[D] = !1, w += r;
    }
    m !== -1 && (f.set(l.subarray(m, v), C), g === -1 && m === 0 && m === C && (g = v), _ === -1 && v === p && m === C && (_ = m));
    const L = g === -1 ? -1 : g / (d * 4), S = _ === -1 ? -1 : _ / (d * 4);
    return [L, S, s];
  }
  static _renderLine(e, t, i, r, o, s, a, l, u, c, h, d, f) {
    const p = h.content, g = h.tokens, _ = e.width - o, m = f === 1;
    let v = Ym, C = 0, y = 0;
    for (let w = 0, L = g.getCount(); w < L; w++) {
      const S = g.getEndOffset(w), E = g.getForeground(w), D = s.getColor(E);
      for (; C < S; C++) {
        if (v > _)
          return;
        const x = p.charCodeAt(C);
        if (x === 9) {
          const R = c - (C + y) % c;
          y += R - 1, v += R * o;
        } else if (x === 32)
          v += o;
        else {
          const R = el(x) ? 2 : 1;
          for (let A = 0; A < R; A++)
            if (r === 2 ? a.blockRenderChar(e, v, l + u, D, t, i, m) : a.renderChar(e, v, l + u, x, D, t, d, i, m), v += o, v > _)
              return;
        }
      }
    }
  }
}
wa((n, e) => {
  const t = n.getColor(q3);
  t && e.addRule(`.monaco-editor .minimap > canvas { opacity: ${t.rgba.a}; will-change: opacity; }`);
  const i = n.getColor(Ehe);
  i && e.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${i}; }`);
  const r = n.getColor(Lhe);
  r && e.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${r}; }`);
  const o = n.getColor(Dhe);
  o && e.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${o}; }`);
  const s = n.getColor(OE);
  s && e.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${s} -6px 0 6px -6px inset; }`);
});
class Fde extends Fs {
  constructor(e) {
    super(e);
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    this._widgets = {}, this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, this._domNode = St(document.createElement("div")), Ql.write(
      this._domNode,
      4
      /* OverlayWidgets */
    ), this._domNode.setClassName("overlayWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  getDomNode() {
    return this._domNode;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    return this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, !0;
  }
  // ---- end view event handlers
  addWidget(e) {
    const t = St(e.getDomNode());
    this._widgets[e.getId()] = {
      widget: e,
      preference: null,
      domNode: t
    }, t.setPosition("absolute"), t.setAttribute("widgetId", e.getId()), this._domNode.appendChild(t), this.setShouldRender();
  }
  setWidgetPosition(e, t) {
    const i = this._widgets[e.getId()];
    return i.preference === t ? !1 : (i.preference = t, this.setShouldRender(), !0);
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const r = this._widgets[t].domNode.domNode;
      delete this._widgets[t], r.parentNode.removeChild(r), this.setShouldRender();
    }
  }
  _renderWidget(e) {
    const t = e.domNode;
    if (e.preference === null) {
      t.unsetTop();
      return;
    }
    if (e.preference === 0)
      t.setTop(0), t.setRight(2 * this._verticalScrollbarWidth + this._minimapWidth);
    else if (e.preference === 1) {
      const i = t.domNode.clientHeight;
      t.setTop(this._editorHeight - i - 2 * this._horizontalScrollbarHeight), t.setRight(2 * this._verticalScrollbarWidth + this._minimapWidth);
    } else
      e.preference === 2 && (t.setTop(0), t.domNode.style.right = "50%");
  }
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setWidth(this._editorWidth);
    const t = Object.keys(this._widgets);
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      this._renderWidget(this._widgets[o]);
    }
  }
}
class kde {
  constructor(e, t) {
    const i = e.options;
    this.lineHeight = i.get(
      56
      /* lineHeight */
    ), this.pixelRatio = i.get(
      126
      /* pixelRatio */
    ), this.overviewRulerLanes = i.get(
      71
      /* overviewRulerLanes */
    ), this.renderBorder = i.get(
      70
      /* overviewRulerBorder */
    );
    const r = t.getColor(Fhe);
    this.borderColor = r ? r.toString() : null, this.hideCursor = i.get(
      48
      /* hideCursorInOverviewRuler */
    );
    const o = t.getColor(J3);
    this.cursorColor = o ? o.transparent(0.7).toString() : null, this.themeType = t.type;
    const s = i.get(
      62
      /* minimap */
    ), a = s.enabled, l = s.side, u = a ? t.getColor(khe) || cn.getDefaultBackground() : null;
    u === null || l === "left" ? this.backgroundColor = null : this.backgroundColor = ne.Format.CSS.formatHex(u);
    const h = i.get(
      128
      /* layoutInfo */
    ).overviewRuler;
    this.top = h.top, this.right = h.right, this.domWidth = h.width, this.domHeight = h.height, this.overviewRulerLanes === 0 ? (this.canvasWidth = 0, this.canvasHeight = 0) : (this.canvasWidth = this.domWidth * this.pixelRatio | 0, this.canvasHeight = this.domHeight * this.pixelRatio | 0);
    const [d, f] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);
    this.x = d, this.w = f;
  }
  _initLanes(e, t, i) {
    const r = t - e;
    if (i >= 3) {
      const o = Math.floor(r / 3), s = Math.floor(r / 3), a = r - o - s, l = e, u = l + o, c = l + o + a;
      return [
        [
          0,
          l,
          u,
          l,
          c,
          l,
          u,
          l
          // Left | Center | Right
        ],
        [
          0,
          o,
          a,
          o + a,
          s,
          o + a + s,
          a + s,
          o + a + s
          // Left | Center | Right
        ]
      ];
    } else if (i === 2) {
      const o = Math.floor(r / 2), s = r - o, a = e, l = a + o;
      return [
        [
          0,
          a,
          a,
          a,
          l,
          a,
          a,
          a
          // Left | Center | Right
        ],
        [
          0,
          o,
          o,
          o,
          s,
          o + s,
          o + s,
          o + s
          // Left | Center | Right
        ]
      ];
    } else {
      const o = e, s = r;
      return [
        [
          0,
          o,
          o,
          o,
          o,
          o,
          o,
          o
          // Left | Center | Right
        ],
        [
          0,
          s,
          s,
          s,
          s,
          s,
          s,
          s
          // Left | Center | Right
        ]
      ];
    }
  }
  equals(e) {
    return this.lineHeight === e.lineHeight && this.pixelRatio === e.pixelRatio && this.overviewRulerLanes === e.overviewRulerLanes && this.renderBorder === e.renderBorder && this.borderColor === e.borderColor && this.hideCursor === e.hideCursor && this.cursorColor === e.cursorColor && this.themeType === e.themeType && this.backgroundColor === e.backgroundColor && this.top === e.top && this.right === e.right && this.domWidth === e.domWidth && this.domHeight === e.domHeight && this.canvasWidth === e.canvasWidth && this.canvasHeight === e.canvasHeight;
  }
}
class Wde extends Fs {
  constructor(e) {
    super(e), this._domNode = St(document.createElement("canvas")), this._domNode.setClassName("decorationsOverviewRuler"), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._domNode.setAttribute("aria-hidden", "true"), this._updateSettings(!1), this._tokensColorTrackerListener = cn.onDidChange((t) => {
      t.changedColorMap && this._updateSettings(!0);
    }), this._cursorPositions = [];
  }
  dispose() {
    super.dispose(), this._tokensColorTrackerListener.dispose();
  }
  _updateSettings(e) {
    const t = new kde(this._context.configuration, this._context.theme);
    return this._settings && this._settings.equals(t) ? !1 : (this._settings = t, this._domNode.setTop(this._settings.top), this._domNode.setRight(this._settings.right), this._domNode.setWidth(this._settings.domWidth), this._domNode.setHeight(this._settings.domHeight), this._domNode.domNode.width = this._settings.canvasWidth, this._domNode.domNode.height = this._settings.canvasHeight, e && this._render(), !0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return this._updateSettings(!1);
  }
  onCursorStateChanged(e) {
    this._cursorPositions = [];
    for (let t = 0, i = e.selections.length; t < i; t++)
      this._cursorPositions[t] = e.selections[t].getPosition();
    return this._cursorPositions.sort(ie.compare), !0;
  }
  onDecorationsChanged(e) {
    return !!e.affectsOverviewRuler;
  }
  onFlushed(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onThemeChanged(e) {
    return this._context.model.invalidateOverviewRulerColorCache(), this._updateSettings(!1);
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  prepareRender(e) {
  }
  render(e) {
    this._render();
  }
  _render() {
    if (this._settings.overviewRulerLanes === 0) {
      this._domNode.setBackgroundColor(this._settings.backgroundColor ? this._settings.backgroundColor : "");
      return;
    }
    const e = this._settings.canvasWidth, t = this._settings.canvasHeight, i = this._settings.lineHeight, r = this._context.viewLayout, o = this._context.viewLayout.getScrollHeight(), s = t / o, a = this._context.model.getAllOverviewRulerDecorations(this._context.theme), l = 6 * this._settings.pixelRatio | 0, u = l / 2 | 0, c = this._domNode.domNode.getContext("2d");
    this._settings.backgroundColor === null ? c.clearRect(0, 0, e, t) : (c.fillStyle = this._settings.backgroundColor, c.fillRect(0, 0, e, t));
    const h = this._settings.x, d = this._settings.w, f = Object.keys(a);
    f.sort();
    for (let p = 0, g = f.length; p < g; p++) {
      const _ = f[p], m = a[_];
      c.fillStyle = _;
      let v = 0, C = 0, y = 0;
      for (let w = 0, L = m.length; w < L; w++) {
        const S = m[3 * w], E = m[3 * w + 1], D = m[3 * w + 2];
        let x = r.getVerticalOffsetForLineNumber(E) * s | 0, R = (r.getVerticalOffsetForLineNumber(D) + i) * s | 0;
        if (R - x < l) {
          let M = (x + R) / 2 | 0;
          M < u ? M = u : M + u > t && (M = t - u), x = M - u, R = M + u;
        }
        x > y + 1 || S !== v ? (w !== 0 && c.fillRect(h[v], C, d[v], y - C), v = S, C = x, y = R) : R > y && (y = R);
      }
      c.fillRect(h[v], C, d[v], y - C);
    }
    if (!this._settings.hideCursor && this._settings.cursorColor) {
      const p = 2 * this._settings.pixelRatio | 0, g = p / 2 | 0, _ = this._settings.x[
        7
        /* Full */
      ], m = this._settings.w[
        7
        /* Full */
      ];
      c.fillStyle = this._settings.cursorColor;
      let v = -100, C = -100;
      for (let y = 0, w = this._cursorPositions.length; y < w; y++) {
        const L = this._cursorPositions[y];
        let S = r.getVerticalOffsetForLineNumber(L.lineNumber) * s | 0;
        S < g ? S = g : S + g > t && (S = t - g);
        const E = S - g, D = E + p;
        E > C + 1 ? (y !== 0 && c.fillRect(_, v, m, C - v), v = E, C = D) : D > C && (C = D);
      }
      c.fillRect(_, v, m, C - v);
    }
    this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0 && (c.beginPath(), c.lineWidth = 1, c.strokeStyle = this._settings.borderColor, c.moveTo(0, 0), c.lineTo(0, t), c.stroke(), c.moveTo(0, 0), c.lineTo(e, 0), c.stroke());
  }
}
class oW {
  constructor(e, t, i) {
    this.from = e | 0, this.to = t | 0, this.colorId = i | 0;
  }
  static compare(e, t) {
    return e.colorId === t.colorId ? e.from === t.from ? e.to - t.to : e.from - t.from : e.colorId - t.colorId;
  }
}
class c_ {
  constructor(e, t, i) {
    this.startLineNumber = e, this.endLineNumber = t, this.color = i, this._colorZone = null;
  }
  static compare(e, t) {
    return e.color === t.color ? e.startLineNumber === t.startLineNumber ? e.endLineNumber - t.endLineNumber : e.startLineNumber - t.startLineNumber : e.color < t.color ? -1 : 1;
  }
  setColorZone(e) {
    this._colorZone = e;
  }
  getColorZones() {
    return this._colorZone;
  }
}
class Vde {
  constructor(e) {
    this._getVerticalOffsetForLine = e, this._zones = [], this._colorZonesInvalid = !1, this._lineHeight = 0, this._domWidth = 0, this._domHeight = 0, this._outerHeight = 0, this._pixelRatio = 1, this._lastAssignedId = 0, this._color2Id = /* @__PURE__ */ Object.create(null), this._id2Color = [];
  }
  getId2Color() {
    return this._id2Color;
  }
  setZones(e) {
    this._zones = e, this._zones.sort(c_.compare);
  }
  setLineHeight(e) {
    return this._lineHeight === e ? !1 : (this._lineHeight = e, this._colorZonesInvalid = !0, !0);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this._colorZonesInvalid = !0;
  }
  getDOMWidth() {
    return this._domWidth;
  }
  getCanvasWidth() {
    return this._domWidth * this._pixelRatio;
  }
  setDOMWidth(e) {
    return this._domWidth === e ? !1 : (this._domWidth = e, this._colorZonesInvalid = !0, !0);
  }
  getDOMHeight() {
    return this._domHeight;
  }
  getCanvasHeight() {
    return this._domHeight * this._pixelRatio;
  }
  setDOMHeight(e) {
    return this._domHeight === e ? !1 : (this._domHeight = e, this._colorZonesInvalid = !0, !0);
  }
  getOuterHeight() {
    return this._outerHeight;
  }
  setOuterHeight(e) {
    return this._outerHeight === e ? !1 : (this._outerHeight = e, this._colorZonesInvalid = !0, !0);
  }
  resolveColorZones() {
    const e = this._colorZonesInvalid, t = Math.floor(this._lineHeight), i = Math.floor(this.getCanvasHeight()), r = Math.floor(this._outerHeight), o = i / r, s = Math.floor(4 * this._pixelRatio / 2);
    let a = [];
    for (let l = 0, u = this._zones.length; l < u; l++) {
      const c = this._zones[l];
      if (!e) {
        const v = c.getColorZones();
        if (v) {
          a.push(v);
          continue;
        }
      }
      const h = Math.floor(o * this._getVerticalOffsetForLine(c.startLineNumber)), d = Math.floor(o * (this._getVerticalOffsetForLine(c.endLineNumber) + t));
      let f = Math.floor((h + d) / 2), p = d - f;
      p < s && (p = s), f - p < 0 && (f = p), f + p > i && (f = i - p);
      const g = c.color;
      let _ = this._color2Id[g];
      _ || (_ = ++this._lastAssignedId, this._color2Id[g] = _, this._id2Color[_] = g);
      const m = new oW(f - p, f + p, _);
      c.setColorZone(m), a.push(m);
    }
    return this._colorZonesInvalid = !1, a.sort(oW.compare), a;
  }
}
class Bde extends X_ {
  constructor(e, t) {
    super(), this._context = e;
    const i = this._context.configuration.options;
    this._domNode = St(document.createElement("canvas")), this._domNode.setClassName(t), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._zoneManager = new Vde((r) => this._context.viewLayout.getVerticalOffsetForLineNumber(r)), this._zoneManager.setDOMWidth(0), this._zoneManager.setDOMHeight(0), this._zoneManager.setOuterHeight(this._context.viewLayout.getScrollHeight()), this._zoneManager.setLineHeight(i.get(
      56
      /* lineHeight */
    )), this._zoneManager.setPixelRatio(i.get(
      126
      /* pixelRatio */
    )), this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return e.hasChanged(
      56
      /* lineHeight */
    ) && (this._zoneManager.setLineHeight(t.get(
      56
      /* lineHeight */
    )), this._render()), e.hasChanged(
      126
      /* pixelRatio */
    ) && (this._zoneManager.setPixelRatio(t.get(
      126
      /* pixelRatio */
    )), this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render()), !0;
  }
  onFlushed(e) {
    return this._render(), !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged && (this._zoneManager.setOuterHeight(e.scrollHeight), this._render()), !0;
  }
  onZonesChanged(e) {
    return this._render(), !0;
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  setLayout(e) {
    this._domNode.setTop(e.top), this._domNode.setRight(e.right);
    let t = !1;
    t = this._zoneManager.setDOMWidth(e.width) || t, t = this._zoneManager.setDOMHeight(e.height) || t, t && (this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render());
  }
  setZones(e) {
    this._zoneManager.setZones(e), this._render();
  }
  _render() {
    if (this._zoneManager.getOuterHeight() === 0)
      return !1;
    const e = this._zoneManager.getCanvasWidth(), t = this._zoneManager.getCanvasHeight(), i = this._zoneManager.resolveColorZones(), r = this._zoneManager.getId2Color(), o = this._domNode.domNode.getContext("2d");
    return o.clearRect(0, 0, e, t), i.length > 0 && this._renderOneLane(o, i, r, e), !0;
  }
  _renderOneLane(e, t, i, r) {
    let o = 0, s = 0, a = 0;
    for (const l of t) {
      const u = l.colorId, c = l.from, h = l.to;
      u !== o ? (e.fillRect(0, s, r, a - s), o = u, e.fillStyle = i[o], s = c, a = h) : a >= c ? a = Math.max(a, h) : (e.fillRect(0, s, r, a - s), s = c, a = h);
    }
    e.fillRect(0, s, r, a - s);
  }
}
class Hde extends Fs {
  constructor(e) {
    super(e), this.domNode = St(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("view-rulers"), this._renderedRulers = [];
    const t = this._context.configuration.options;
    this._rulers = t.get(
      89
      /* rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth;
  }
  dispose() {
    super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._rulers = t.get(
      89
      /* rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  _ensureRulersCount() {
    const e = this._renderedRulers.length, t = this._rulers.length;
    if (e === t)
      return;
    if (e < t) {
      const { tabSize: r } = this._context.model.getTextModelOptions(), o = r;
      let s = t - e;
      for (; s > 0; ) {
        const a = St(document.createElement("div"));
        a.setClassName("view-ruler"), a.setWidth(o), this.domNode.appendChild(a), this._renderedRulers.push(a), s--;
      }
      return;
    }
    let i = e - t;
    for (; i > 0; ) {
      const r = this._renderedRulers.pop();
      this.domNode.removeChild(r), i--;
    }
  }
  render(e) {
    this._ensureRulersCount();
    for (let t = 0, i = this._rulers.length; t < i; t++) {
      const r = this._renderedRulers[t], o = this._rulers[t];
      r.setBoxShadow(o.color ? `1px 0 0 0 ${o.color} inset` : ""), r.setHeight(Math.min(e.scrollHeight, 1e6)), r.setLeft(o.column * this._typicalHalfwidthCharacterWidth);
    }
  }
}
wa((n, e) => {
  const t = n.getColor(Mhe);
  t && e.addRule(`.monaco-editor .view-ruler { box-shadow: 1px 0 0 0 ${t} inset; }`);
});
class Gde extends Fs {
  constructor(e) {
    super(e), this._scrollTop = 0, this._width = 0, this._updateWidth(), this._shouldShow = !1;
    const i = this._context.configuration.options.get(
      90
      /* scrollbar */
    );
    this._useShadows = i.useShadows, this._domNode = St(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
  }
  dispose() {
    super.dispose();
  }
  _updateShouldShow() {
    const e = this._useShadows && this._scrollTop > 0;
    return this._shouldShow !== e ? (this._shouldShow = e, !0) : !1;
  }
  getDomNode() {
    return this._domNode;
  }
  _updateWidth() {
    const t = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    t.minimap.renderMinimap === 0 || t.minimap.minimapWidth > 0 && t.minimap.minimapLeft === 0 ? this._width = t.width : this._width = t.width - t.minimap.minimapWidth - t.verticalScrollbarWidth;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      90
      /* scrollbar */
    );
    return this._useShadows = i.useShadows, this._updateWidth(), this._updateShouldShow(), !0;
  }
  onScrollChanged(e) {
    return this._scrollTop = e.scrollTop, this._updateShouldShow();
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setWidth(this._width), this._domNode.setClassName(this._shouldShow ? "scroll-decoration" : "");
  }
}
wa((n, e) => {
  const t = n.getColor(OE);
  t && e.addRule(`.monaco-editor .scroll-decoration { box-shadow: ${t} 0 6px 6px -6px inset; }`);
});
class Ude {
  constructor(e) {
    this.left = e.left, this.width = e.width, this.startStyle = null, this.endStyle = null;
  }
}
class zde {
  constructor(e, t) {
    this.lineNumber = e, this.ranges = t;
  }
}
function jde(n) {
  return new Ude(n);
}
function $de(n) {
  return new zde(n.lineNumber, n.ranges.map(jde));
}
class Ni extends Fg {
  constructor(e) {
    super(), this._previousFrameVisibleRangesWithStyle = [], this._context = e;
    const t = this._context.configuration.options;
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._roundedSelection = t.get(
      88
      /* roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, this._selections = [], this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._roundedSelection = t.get(
      88
      /* roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      40
      /* fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _visibleRangesHaveGaps(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t].ranges.length > 1)
        return !0;
    return !1;
  }
  _enrichVisibleRangesWithStyle(e, t, i) {
    const r = this._typicalHalfwidthCharacterWidth / 4;
    let o = null, s = null;
    if (i && i.length > 0 && t.length > 0) {
      const a = t[0].lineNumber;
      if (a === e.startLineNumber)
        for (let u = 0; !o && u < i.length; u++)
          i[u].lineNumber === a && (o = i[u].ranges[0]);
      const l = t[t.length - 1].lineNumber;
      if (l === e.endLineNumber)
        for (let u = i.length - 1; !s && u >= 0; u--)
          i[u].lineNumber === l && (s = i[u].ranges[0]);
      o && !o.startStyle && (o = null), s && !s.startStyle && (s = null);
    }
    for (let a = 0, l = t.length; a < l; a++) {
      const u = t[a].ranges[0], c = u.left, h = u.left + u.width, d = {
        top: 0,
        bottom: 0
        /* EXTERN */
      }, f = {
        top: 0,
        bottom: 0
        /* EXTERN */
      };
      if (a > 0) {
        const p = t[a - 1].ranges[0].left, g = t[a - 1].ranges[0].left + t[a - 1].ranges[0].width;
        xy(c - p) < r ? d.top = 2 : c > p && (d.top = 1), xy(h - g) < r ? f.top = 2 : p < h && h < g && (f.top = 1);
      } else
        o && (d.top = o.startStyle.top, f.top = o.endStyle.top);
      if (a + 1 < l) {
        const p = t[a + 1].ranges[0].left, g = t[a + 1].ranges[0].left + t[a + 1].ranges[0].width;
        xy(c - p) < r ? d.bottom = 2 : p < c && c < g && (d.bottom = 1), xy(h - g) < r ? f.bottom = 2 : h < g && (f.bottom = 1);
      } else
        s && (d.bottom = s.startStyle.bottom, f.bottom = s.endStyle.bottom);
      u.startStyle = d, u.endStyle = f;
    }
  }
  _getVisibleRangesWithStyle(e, t, i) {
    const o = (t.linesVisibleRangesForRange(e, !0) || []).map($de);
    return !this._visibleRangesHaveGaps(o) && this._roundedSelection && this._enrichVisibleRangesWithStyle(t.visibleRange, o, i), o;
  }
  _createSelectionPiece(e, t, i, r, o) {
    return '<div class="cslr ' + i + '" style="top:' + e.toString() + "px;left:" + r.toString() + "px;width:" + o.toString() + "px;height:" + t + 'px;"></div>';
  }
  _actualRenderOneSelection(e, t, i, r) {
    if (r.length === 0)
      return;
    const o = !!r[0].ranges[0].startStyle, s = this._lineHeight.toString(), a = (this._lineHeight - 1).toString(), l = r[0].lineNumber, u = r[r.length - 1].lineNumber;
    for (let c = 0, h = r.length; c < h; c++) {
      const d = r[c], f = d.lineNumber, p = f - t, g = i && (f === u || f === l) ? a : s, _ = i && f === l ? 1 : 0;
      let m = "", v = "";
      for (let C = 0, y = d.ranges.length; C < y; C++) {
        const w = d.ranges[C];
        if (o) {
          const S = w.startStyle, E = w.endStyle;
          if (S.top === 1 || S.bottom === 1) {
            m += this._createSelectionPiece(_, g, Ni.SELECTION_CLASS_NAME, w.left - Ni.ROUNDED_PIECE_WIDTH, Ni.ROUNDED_PIECE_WIDTH);
            let D = Ni.EDITOR_BACKGROUND_CLASS_NAME;
            S.top === 1 && (D += " " + Ni.SELECTION_TOP_RIGHT), S.bottom === 1 && (D += " " + Ni.SELECTION_BOTTOM_RIGHT), m += this._createSelectionPiece(_, g, D, w.left - Ni.ROUNDED_PIECE_WIDTH, Ni.ROUNDED_PIECE_WIDTH);
          }
          if (E.top === 1 || E.bottom === 1) {
            m += this._createSelectionPiece(_, g, Ni.SELECTION_CLASS_NAME, w.left + w.width, Ni.ROUNDED_PIECE_WIDTH);
            let D = Ni.EDITOR_BACKGROUND_CLASS_NAME;
            E.top === 1 && (D += " " + Ni.SELECTION_TOP_LEFT), E.bottom === 1 && (D += " " + Ni.SELECTION_BOTTOM_LEFT), m += this._createSelectionPiece(_, g, D, w.left + w.width, Ni.ROUNDED_PIECE_WIDTH);
          }
        }
        let L = Ni.SELECTION_CLASS_NAME;
        if (o) {
          const S = w.startStyle, E = w.endStyle;
          S.top === 0 && (L += " " + Ni.SELECTION_TOP_LEFT), S.bottom === 0 && (L += " " + Ni.SELECTION_BOTTOM_LEFT), E.top === 0 && (L += " " + Ni.SELECTION_TOP_RIGHT), E.bottom === 0 && (L += " " + Ni.SELECTION_BOTTOM_RIGHT);
        }
        v += this._createSelectionPiece(_, g, L, w.left, w.width);
      }
      e[p][0] += m, e[p][1] += v;
    }
  }
  prepareRender(e) {
    const t = [], i = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber;
    for (let s = i; s <= r; s++) {
      const a = s - i;
      t[a] = ["", ""];
    }
    const o = [];
    for (let s = 0, a = this._selections.length; s < a; s++) {
      const l = this._selections[s];
      if (l.isEmpty()) {
        o[s] = null;
        continue;
      }
      const u = this._getVisibleRangesWithStyle(l, e, this._previousFrameVisibleRangesWithStyle[s]);
      o[s] = u, this._actualRenderOneSelection(t, i, this._selections.length > 1, u);
    }
    this._previousFrameVisibleRangesWithStyle = o, this._renderResult = t.map(([s, a]) => s + a);
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
Ni.SELECTION_CLASS_NAME = "selected-text";
Ni.SELECTION_TOP_LEFT = "top-left-radius";
Ni.SELECTION_BOTTOM_LEFT = "bottom-left-radius";
Ni.SELECTION_TOP_RIGHT = "top-right-radius";
Ni.SELECTION_BOTTOM_RIGHT = "bottom-right-radius";
Ni.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background";
Ni.ROUNDED_PIECE_WIDTH = 10;
wa((n, e) => {
  const t = n.getColor(Mp);
  t && e.addRule(`.monaco-editor .focused .selected-text { background-color: ${t}; }`);
  const i = n.getColor(EI);
  i && e.addRule(`.monaco-editor .selected-text { background-color: ${i}; }`);
  const r = n.getColor($ce);
  r && !r.isTransparent() && e.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${r}; }`);
});
function xy(n) {
  return n < 0 ? -n : n;
}
class sW {
  constructor(e, t, i, r, o, s) {
    this.top = e, this.left = t, this.width = i, this.height = r, this.textContent = o, this.textContentClassName = s;
  }
}
class aW {
  constructor(e) {
    this._context = e;
    const t = this._context.configuration.options, i = t.get(
      40
      /* fontInfo */
    );
    this._cursorStyle = t.get(
      22
      /* cursorStyle */
    ), this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(
      25
      /* cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), this._isVisible = !0, this._domNode = St(document.createElement("div")), this._domNode.setClassName(`cursor ${Dd}`), this._domNode.setHeight(this._lineHeight), this._domNode.setTop(0), this._domNode.setLeft(0), oo.applyFontInfo(this._domNode, i), this._domNode.setDisplay("none"), this._position = new ie(1, 1), this._lastRenderedContent = "", this._renderData = null;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._position;
  }
  show() {
    this._isVisible || (this._domNode.setVisibility("inherit"), this._isVisible = !0);
  }
  hide() {
    this._isVisible && (this._domNode.setVisibility("hidden"), this._isVisible = !1);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      40
      /* fontInfo */
    );
    return this._cursorStyle = t.get(
      22
      /* cursorStyle */
    ), this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(
      25
      /* cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), oo.applyFontInfo(this._domNode, i), !0;
  }
  onCursorPositionChanged(e) {
    return this._position = e, !0;
  }
  _prepareRender(e) {
    let t = "";
    if (this._cursorStyle === Vn.Line || this._cursorStyle === Vn.LineThin) {
      const d = e.visibleRangeForPosition(this._position);
      if (!d || d.outsideRenderedLine)
        return null;
      let f;
      if (this._cursorStyle === Vn.Line) {
        if (f = ok(this._lineCursorWidth > 0 ? this._lineCursorWidth : 2), f > 2) {
          const _ = this._context.model.getLineContent(this._position.lineNumber), m = fb(_, this._position.column - 1);
          t = _.substr(this._position.column - 1, m);
        }
      } else
        f = ok(1);
      let p = d.left;
      f >= 2 && p >= 1 && (p -= 1);
      const g = e.getVerticalOffsetForLineNumber(this._position.lineNumber) - e.bigNumbersDelta;
      return new sW(g, p, f, this._lineHeight, t, "");
    }
    const i = this._context.model.getLineContent(this._position.lineNumber), r = fb(i, this._position.column - 1), o = e.linesVisibleRangesForRange(new G(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column + r), !1);
    if (!o || o.length === 0)
      return null;
    const s = o[0];
    if (s.outsideRenderedLine || s.ranges.length === 0)
      return null;
    const a = s.ranges[0], l = a.width < 1 ? this._typicalHalfwidthCharacterWidth : a.width;
    let u = "";
    if (this._cursorStyle === Vn.Block) {
      const d = this._context.model.getViewLineData(this._position.lineNumber);
      t = i.substr(this._position.column - 1, r);
      const f = d.tokens.findTokenIndexAtOffset(this._position.column - 1);
      u = d.tokens.getClassName(f);
    }
    let c = e.getVerticalOffsetForLineNumber(this._position.lineNumber) - e.bigNumbersDelta, h = this._lineHeight;
    return (this._cursorStyle === Vn.Underline || this._cursorStyle === Vn.UnderlineThin) && (c += this._lineHeight - 2, h = 2), new sW(c, a.left, l, h, t, u);
  }
  prepareRender(e) {
    this._renderData = this._prepareRender(e);
  }
  render(e) {
    return this._renderData ? (this._lastRenderedContent !== this._renderData.textContent && (this._lastRenderedContent = this._renderData.textContent, this._domNode.domNode.textContent = this._lastRenderedContent), this._domNode.setClassName(`cursor ${Dd} ${this._renderData.textContentClassName}`), this._domNode.setDisplay("block"), this._domNode.setTop(this._renderData.top), this._domNode.setLeft(this._renderData.left), this._domNode.setWidth(this._renderData.width), this._domNode.setLineHeight(this._renderData.height), this._domNode.setHeight(this._renderData.height), {
      domNode: this._domNode.domNode,
      position: this._position,
      contentLeft: this._renderData.left,
      height: this._renderData.height,
      width: 2
    }) : (this._domNode.setDisplay("none"), null);
  }
}
class h_ extends Fs {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      78
      /* readOnly */
    ), this._cursorBlinking = t.get(
      20
      /* cursorBlinking */
    ), this._cursorStyle = t.get(
      22
      /* cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      21
      /* cursorSmoothCaretAnimation */
    ), this._selectionIsEmpty = !0, this._isComposingInput = !1, this._isVisible = !1, this._primaryCursor = new aW(this._context), this._secondaryCursors = [], this._renderData = [], this._domNode = St(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._updateDomClassName(), this._domNode.appendChild(this._primaryCursor.getDomNode()), this._startCursorBlinkAnimation = new oc(), this._cursorFlatBlinkInterval = new G_(), this._blinkingEnabled = !1, this._editorHasFocus = !1, this._updateBlinking();
  }
  dispose() {
    super.dispose(), this._startCursorBlinkAnimation.dispose(), this._cursorFlatBlinkInterval.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return this._isComposingInput = !0, this._updateBlinking(), !0;
  }
  onCompositionEnd(e) {
    return this._isComposingInput = !1, this._updateBlinking(), !0;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      78
      /* readOnly */
    ), this._cursorBlinking = t.get(
      20
      /* cursorBlinking */
    ), this._cursorStyle = t.get(
      22
      /* cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      21
      /* cursorSmoothCaretAnimation */
    ), this._updateBlinking(), this._updateDomClassName(), this._primaryCursor.onConfigurationChanged(e);
    for (let i = 0, r = this._secondaryCursors.length; i < r; i++)
      this._secondaryCursors[i].onConfigurationChanged(e);
    return !0;
  }
  _onCursorPositionChanged(e, t) {
    if (this._primaryCursor.onCursorPositionChanged(e), this._updateBlinking(), this._secondaryCursors.length < t.length) {
      const i = t.length - this._secondaryCursors.length;
      for (let r = 0; r < i; r++) {
        const o = new aW(this._context);
        this._domNode.domNode.insertBefore(o.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling), this._secondaryCursors.push(o);
      }
    } else if (this._secondaryCursors.length > t.length) {
      const i = this._secondaryCursors.length - t.length;
      for (let r = 0; r < i; r++)
        this._domNode.removeChild(this._secondaryCursors[0].getDomNode()), this._secondaryCursors.splice(0, 1);
    }
    for (let i = 0; i < t.length; i++)
      this._secondaryCursors[i].onCursorPositionChanged(t[i]);
  }
  onCursorStateChanged(e) {
    const t = [];
    for (let r = 0, o = e.selections.length; r < o; r++)
      t[r] = e.selections[r].getPosition();
    this._onCursorPositionChanged(t[0], t.slice(1));
    const i = e.selections[0].isEmpty();
    return this._selectionIsEmpty !== i && (this._selectionIsEmpty = i, this._updateDomClassName()), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._editorHasFocus = e.isFocused, this._updateBlinking(), !1;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onTokensChanged(e) {
    const t = (i) => {
      for (let r = 0, o = e.ranges.length; r < o; r++)
        if (e.ranges[r].fromLineNumber <= i.lineNumber && i.lineNumber <= e.ranges[r].toLineNumber)
          return !0;
      return !1;
    };
    if (t(this._primaryCursor.getPosition()))
      return !0;
    for (const i of this._secondaryCursors)
      if (t(i.getPosition()))
        return !0;
    return !1;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // ---- blinking logic
  _getCursorBlinking() {
    return this._isComposingInput || !this._editorHasFocus ? 0 : this._readOnly ? 5 : this._cursorBlinking;
  }
  _updateBlinking() {
    this._startCursorBlinkAnimation.cancel(), this._cursorFlatBlinkInterval.cancel();
    const e = this._getCursorBlinking(), t = e === 0, i = e === 5;
    t ? this._hide() : this._show(), this._blinkingEnabled = !1, this._updateDomClassName(), !t && !i && (e === 1 ? this._cursorFlatBlinkInterval.cancelAndSet(() => {
      this._isVisible ? this._hide() : this._show();
    }, h_.BLINK_INTERVAL) : this._startCursorBlinkAnimation.setIfNotSet(() => {
      this._blinkingEnabled = !0, this._updateDomClassName();
    }, h_.BLINK_INTERVAL));
  }
  // --- end blinking logic
  _updateDomClassName() {
    this._domNode.setClassName(this._getClassName());
  }
  _getClassName() {
    let e = "cursors-layer";
    switch (this._selectionIsEmpty || (e += " has-selection"), this._cursorStyle) {
      case Vn.Line:
        e += " cursor-line-style";
        break;
      case Vn.Block:
        e += " cursor-block-style";
        break;
      case Vn.Underline:
        e += " cursor-underline-style";
        break;
      case Vn.LineThin:
        e += " cursor-line-thin-style";
        break;
      case Vn.BlockOutline:
        e += " cursor-block-outline-style";
        break;
      case Vn.UnderlineThin:
        e += " cursor-underline-thin-style";
        break;
      default:
        e += " cursor-line-style";
    }
    if (this._blinkingEnabled)
      switch (this._getCursorBlinking()) {
        case 1:
          e += " cursor-blink";
          break;
        case 2:
          e += " cursor-smooth";
          break;
        case 3:
          e += " cursor-phase";
          break;
        case 4:
          e += " cursor-expand";
          break;
        case 5:
          e += " cursor-solid";
          break;
        default:
          e += " cursor-solid";
      }
    else
      e += " cursor-solid";
    return this._cursorSmoothCaretAnimation && (e += " cursor-smooth-caret-animation"), e;
  }
  _show() {
    this._primaryCursor.show();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].show();
    this._isVisible = !0;
  }
  _hide() {
    this._primaryCursor.hide();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].hide();
    this._isVisible = !1;
  }
  // ---- IViewPart implementation
  prepareRender(e) {
    this._primaryCursor.prepareRender(e);
    for (let t = 0, i = this._secondaryCursors.length; t < i; t++)
      this._secondaryCursors[t].prepareRender(e);
  }
  render(e) {
    let t = [], i = 0;
    const r = this._primaryCursor.render(e);
    r && (t[i++] = r);
    for (let o = 0, s = this._secondaryCursors.length; o < s; o++) {
      const a = this._secondaryCursors[o].render(e);
      a && (t[i++] = a);
    }
    this._renderData = t;
  }
  getLastRenderData() {
    return this._renderData;
  }
}
h_.BLINK_INTERVAL = 500;
wa((n, e) => {
  const t = n.getColor(J3);
  if (t) {
    let i = n.getColor(Phe);
    i || (i = t.opposite()), e.addRule(`.monaco-editor .cursors-layer .cursor { background-color: ${t}; border-color: ${t}; color: ${i}; }`), n.type === "hc" && e.addRule(`.monaco-editor .cursors-layer.has-selection .cursor { border-left: 1px solid ${i}; border-right: 1px solid ${i}; }`);
  }
});
const qD = () => {
  throw new Error("Invalid change accessor");
};
class Kde extends Fs {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, this.domNode = St(document.createElement("div")), this.domNode.setClassName("view-zones"), this.domNode.setPosition("absolute"), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.marginDomNode = St(document.createElement("div")), this.marginDomNode.setClassName("margin-view-zones"), this.marginDomNode.setPosition("absolute"), this.marginDomNode.setAttribute("role", "presentation"), this.marginDomNode.setAttribute("aria-hidden", "true"), this._zones = {};
  }
  dispose() {
    super.dispose(), this._zones = {};
  }
  // ---- begin view event handlers
  _recomputeWhitespacesProps() {
    const e = this._context.viewLayout.getWhitespaces(), t = /* @__PURE__ */ new Map();
    for (const r of e)
      t.set(r.id, r);
    let i = !1;
    return this._context.model.changeWhitespace((r) => {
      const o = Object.keys(this._zones);
      for (let s = 0, a = o.length; s < a; s++) {
        const l = o[s], u = this._zones[l], c = this._computeWhitespaceProps(u.delegate), h = t.get(l);
        h && (h.afterLineNumber !== c.afterViewLineNumber || h.height !== c.heightInPx) && (r.changeOneWhitespace(l, c.afterViewLineNumber, c.heightInPx), this._safeCallOnComputedHeight(u.delegate, c.heightInPx), i = !0);
      }
    }), i;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      128
      /* layoutInfo */
    );
    return this._lineHeight = t.get(
      56
      /* lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, e.hasChanged(
      56
      /* lineHeight */
    ) && this._recomputeWhitespacesProps(), !0;
  }
  onLineMappingChanged(e) {
    return this._recomputeWhitespacesProps();
  }
  onLinesDeleted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  // ---- end view event handlers
  _getZoneOrdinal(e) {
    return typeof e.afterColumn < "u" ? e.afterColumn : 1e4;
  }
  _computeWhitespaceProps(e) {
    if (e.afterLineNumber === 0)
      return {
        afterViewLineNumber: 0,
        heightInPx: this._heightInPixels(e),
        minWidthInPx: this._minWidthInPixels(e)
      };
    let t;
    if (typeof e.afterColumn < "u")
      t = this._context.model.validateModelPosition({
        lineNumber: e.afterLineNumber,
        column: e.afterColumn
      });
    else {
      const s = this._context.model.validateModelPosition({
        lineNumber: e.afterLineNumber,
        column: 1
      }).lineNumber;
      t = new ie(s, this._context.model.getModelLineMaxColumn(s));
    }
    let i;
    t.column === this._context.model.getModelLineMaxColumn(t.lineNumber) ? i = this._context.model.validateModelPosition({
      lineNumber: t.lineNumber + 1,
      column: 1
    }) : i = this._context.model.validateModelPosition({
      lineNumber: t.lineNumber,
      column: t.column + 1
    });
    const r = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(t), o = this._context.model.coordinatesConverter.modelPositionIsVisible(i);
    return {
      afterViewLineNumber: r.lineNumber,
      heightInPx: o ? this._heightInPixels(e) : 0,
      minWidthInPx: this._minWidthInPixels(e)
    };
  }
  changeViewZones(e) {
    let t = !1;
    return this._context.model.changeWhitespace((i) => {
      const r = {
        addZone: (o) => (t = !0, this._addZone(i, o)),
        removeZone: (o) => {
          o && (t = this._removeZone(i, o) || t);
        },
        layoutZone: (o) => {
          o && (t = this._layoutZone(i, o) || t);
        }
      };
      qde(e, r), r.addZone = qD, r.removeZone = qD, r.layoutZone = qD;
    }), t;
  }
  _addZone(e, t) {
    const i = this._computeWhitespaceProps(t), o = {
      whitespaceId: e.insertWhitespace(i.afterViewLineNumber, this._getZoneOrdinal(t), i.heightInPx, i.minWidthInPx),
      delegate: t,
      isVisible: !1,
      domNode: St(t.domNode),
      marginDomNode: t.marginDomNode ? St(t.marginDomNode) : null
    };
    return this._safeCallOnComputedHeight(o.delegate, i.heightInPx), o.domNode.setPosition("absolute"), o.domNode.domNode.style.width = "100%", o.domNode.setDisplay("none"), o.domNode.setAttribute("monaco-view-zone", o.whitespaceId), this.domNode.appendChild(o.domNode), o.marginDomNode && (o.marginDomNode.setPosition("absolute"), o.marginDomNode.domNode.style.width = "100%", o.marginDomNode.setDisplay("none"), o.marginDomNode.setAttribute("monaco-view-zone", o.whitespaceId), this.marginDomNode.appendChild(o.marginDomNode)), this._zones[o.whitespaceId] = o, this.setShouldRender(), o.whitespaceId;
  }
  _removeZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t];
      return delete this._zones[t], e.removeWhitespace(i.whitespaceId), i.domNode.removeAttribute("monaco-visible-view-zone"), i.domNode.removeAttribute("monaco-view-zone"), i.domNode.domNode.parentNode.removeChild(i.domNode.domNode), i.marginDomNode && (i.marginDomNode.removeAttribute("monaco-visible-view-zone"), i.marginDomNode.removeAttribute("monaco-view-zone"), i.marginDomNode.domNode.parentNode.removeChild(i.marginDomNode.domNode)), this.setShouldRender(), !0;
    }
    return !1;
  }
  _layoutZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t], r = this._computeWhitespaceProps(i.delegate);
      return e.changeOneWhitespace(i.whitespaceId, r.afterViewLineNumber, r.heightInPx), this._safeCallOnComputedHeight(i.delegate, r.heightInPx), this.setShouldRender(), !0;
    }
    return !1;
  }
  shouldSuppressMouseDownOnViewZone(e) {
    return this._zones.hasOwnProperty(e) ? !!this._zones[e].delegate.suppressMouseDown : !1;
  }
  _heightInPixels(e) {
    return typeof e.heightInPx == "number" ? e.heightInPx : typeof e.heightInLines == "number" ? this._lineHeight * e.heightInLines : this._lineHeight;
  }
  _minWidthInPixels(e) {
    return typeof e.minWidthInPx == "number" ? e.minWidthInPx : 0;
  }
  _safeCallOnComputedHeight(e, t) {
    if (typeof e.onComputedHeight == "function")
      try {
        e.onComputedHeight(t);
      } catch (i) {
        Pi(i);
      }
  }
  _safeCallOnDomNodeTop(e, t) {
    if (typeof e.onDomNodeTop == "function")
      try {
        e.onDomNodeTop(t);
      } catch (i) {
        Pi(i);
      }
  }
  prepareRender(e) {
  }
  render(e) {
    const t = e.viewportData.whitespaceViewportData, i = {};
    let r = !1;
    for (let s = 0, a = t.length; s < a; s++)
      i[t[s].id] = t[s], r = !0;
    const o = Object.keys(this._zones);
    for (let s = 0, a = o.length; s < a; s++) {
      const l = o[s], u = this._zones[l];
      let c = 0, h = 0, d = "none";
      i.hasOwnProperty(l) ? (c = i[l].verticalOffset - e.bigNumbersDelta, h = i[l].height, d = "block", u.isVisible || (u.domNode.setAttribute("monaco-visible-view-zone", "true"), u.isVisible = !0), this._safeCallOnDomNodeTop(u.delegate, e.getScrolledTopFromAbsoluteTop(i[l].verticalOffset))) : (u.isVisible && (u.domNode.removeAttribute("monaco-visible-view-zone"), u.isVisible = !1), this._safeCallOnDomNodeTop(u.delegate, e.getScrolledTopFromAbsoluteTop(-1e6))), u.domNode.setTop(c), u.domNode.setHeight(h), u.domNode.setDisplay(d), u.marginDomNode && (u.marginDomNode.setTop(c), u.marginDomNode.setHeight(h), u.marginDomNode.setDisplay(d));
    }
    r && (this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth)), this.marginDomNode.setWidth(this._contentLeft));
  }
}
function qde(n, e) {
  try {
    return n(e);
  } catch (t) {
    Pi(t);
  }
}
class Yde {
  constructor(e) {
    this._theme = e;
  }
  get type() {
    return this._theme.type;
  }
  update(e) {
    this._theme = e;
  }
  getColor(e) {
    return this._theme.getColor(e);
  }
}
class Xde {
  constructor(e, t, i) {
    this.configuration = e, this.theme = new Yde(t), this.model = i, this.viewLayout = i.viewLayout;
  }
  addEventHandler(e) {
    this.model.addViewEventHandler(e);
  }
  removeEventHandler(e) {
    this.model.removeViewEventHandler(e);
  }
}
class Zde {
  constructor(e, t, i, r) {
    this.selections = e, this.startLineNumber = t.startLineNumber | 0, this.endLineNumber = t.endLineNumber | 0, this.relativeVerticalOffset = t.relativeVerticalOffset, this.bigNumbersDelta = t.bigNumbersDelta | 0, this.whitespaceViewportData = i, this._model = r, this.visibleRange = new G(t.startLineNumber, this._model.getLineMinColumn(t.startLineNumber), t.endLineNumber, this._model.getLineMaxColumn(t.endLineNumber));
  }
  getViewLineRenderingData(e) {
    return this._model.getViewLineRenderingData(this.visibleRange, e);
  }
  getDecorationsInViewport() {
    return this._model.getDecorationsInViewport(this.visibleRange);
  }
}
class Qde extends X_ {
  constructor(e, t, i, r, o, s) {
    super(), this._selections = [new Ut(1, 1, 1, 1)], this._renderAnimationFrame = null;
    const a = new Zhe(t, r, o, e);
    this._context = new Xde(t, i.getColorTheme(), r), this._configPixelRatio = this._context.configuration.options.get(
      126
      /* pixelRatio */
    ), this._context.addEventHandler(this), this._register(i.onDidColorThemeChange((g) => {
      this._context.theme.update(g), this._context.model.onDidColorThemeChange(), this.render(!0, !1);
    })), this._viewParts = [], this._textAreaHandler = new zhe(this._context, a, this._createTextAreaHandlerHelper()), this._viewParts.push(this._textAreaHandler), this._linesContent = St(document.createElement("div")), this._linesContent.setClassName("lines-content monaco-editor-background"), this._linesContent.setPosition("absolute"), this.domNode = St(document.createElement("div")), this.domNode.setClassName(this._getEditorClassName()), this.domNode.setAttribute("role", "code"), this._overflowGuardContainer = St(document.createElement("div")), Ql.write(
      this._overflowGuardContainer,
      3
      /* OverflowGuard */
    ), this._overflowGuardContainer.setClassName("overflow-guard"), this._scrollbar = new Sde(this._context, this._linesContent, this.domNode, this._overflowGuardContainer), this._viewParts.push(this._scrollbar), this._viewLines = new ME(this._context, this._linesContent), this._viewZones = new Kde(this._context), this._viewParts.push(this._viewZones);
    const l = new Wde(this._context);
    this._viewParts.push(l);
    const u = new Gde(this._context);
    this._viewParts.push(u);
    const c = new ede(this._context);
    this._viewParts.push(c), c.addDynamicOverlay(new rde(this._context)), c.addDynamicOverlay(new Ni(this._context)), c.addDynamicOverlay(new Lde(this._context)), c.addDynamicOverlay(new sde(this._context));
    const h = new tde(this._context);
    this._viewParts.push(h), h.addDynamicOverlay(new ode(this._context)), h.addDynamicOverlay(new Ede(this._context)), h.addDynamicOverlay(new xde(this._context)), h.addDynamicOverlay(new Ode(this._context)), h.addDynamicOverlay(new rg(this._context));
    const d = new Kd(this._context);
    d.getDomNode().appendChild(this._viewZones.marginDomNode), d.getDomNode().appendChild(h.getDomNode()), this._viewParts.push(d), this._contentWidgets = new ide(this._context, this.domNode), this._viewParts.push(this._contentWidgets), this._viewCursors = new h_(this._context), this._viewParts.push(this._viewCursors), this._overlayWidgets = new Fde(this._context), this._viewParts.push(this._overlayWidgets);
    const f = new Hde(this._context);
    this._viewParts.push(f);
    const p = new Mde(this._context);
    if (this._viewParts.push(p), l) {
      const g = this._scrollbar.getOverviewRulerLayoutInfo();
      g.parent.insertBefore(l.getDomNode(), g.insertBefore);
    }
    this._linesContent.appendChild(c.getDomNode()), this._linesContent.appendChild(f.domNode), this._linesContent.appendChild(this._viewZones.domNode), this._linesContent.appendChild(this._viewLines.getDomNode()), this._linesContent.appendChild(this._contentWidgets.domNode), this._linesContent.appendChild(this._viewCursors.getDomNode()), this._overflowGuardContainer.appendChild(d.getDomNode()), this._overflowGuardContainer.appendChild(this._scrollbar.getDomNode()), this._overflowGuardContainer.appendChild(u.getDomNode()), this._overflowGuardContainer.appendChild(this._textAreaHandler.textArea), this._overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover), this._overflowGuardContainer.appendChild(this._overlayWidgets.getDomNode()), this._overflowGuardContainer.appendChild(p.getDomNode()), this.domNode.appendChild(this._overflowGuardContainer), s ? s.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode.domNode) : this.domNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode), this._applyLayout(), this._pointerHandler = this._register(new gce(this._context, a, this._createPointerHandlerHelper()));
  }
  _flushAccumulatedAndRenderNow() {
    this._renderNow();
  }
  _createPointerHandlerHelper() {
    return {
      viewDomNode: this.domNode.domNode,
      linesContentDomNode: this._linesContent.domNode,
      focusTextArea: () => {
        this.focus();
      },
      dispatchTextAreaEvent: (e) => {
        this._textAreaHandler.textArea.domNode.dispatchEvent(e);
      },
      getLastRenderData: () => {
        const e = this._viewCursors.getLastRenderData() || [], t = this._textAreaHandler.getLastRenderData();
        return new sce(e, t);
      },
      shouldSuppressMouseDownOnViewZone: (e) => this._viewZones.shouldSuppressMouseDownOnViewZone(e),
      shouldSuppressMouseDownOnWidget: (e) => this._contentWidgets.shouldSuppressMouseDownOnWidget(e),
      getPositionFromDOMInfo: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getPositionFromDOMInfo(e, t)),
      visibleRangeForPosition: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(new ie(e, t))),
      getLineWidth: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getLineWidth(e))
    };
  }
  _createTextAreaHandlerHelper() {
    return {
      visibleRangeForPositionRelativeToEditor: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(new ie(e, t)))
    };
  }
  _applyLayout() {
    const t = this._context.configuration.options.get(
      128
      /* layoutInfo */
    );
    this.domNode.setWidth(t.width), this.domNode.setHeight(t.height), this._overflowGuardContainer.setWidth(t.width), this._overflowGuardContainer.setHeight(t.height), this._linesContent.setWidth(1e6), this._linesContent.setHeight(1e6);
  }
  _getEditorClassName() {
    const e = this._textAreaHandler.isFocused() ? " focused" : "";
    return this._context.configuration.options.get(
      125
      /* editorClassName */
    ) + " " + kb(this._context.theme.type) + e;
  }
  // --- begin event handlers
  handleEvents(e) {
    super.handleEvents(e), this._scheduleRender();
  }
  onConfigurationChanged(e) {
    return this._configPixelRatio = this._context.configuration.options.get(
      126
      /* pixelRatio */
    ), this.domNode.setClassName(this._getEditorClassName()), this._applyLayout(), !1;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, !1;
  }
  onFocusChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  onThemeChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  // --- end event handlers
  dispose() {
    this._renderAnimationFrame !== null && (this._renderAnimationFrame.dispose(), this._renderAnimationFrame = null), this._contentWidgets.overflowingContentWidgetsDomNode.domNode.remove(), this._context.removeEventHandler(this), this._viewLines.dispose();
    for (const e of this._viewParts)
      e.dispose();
    super.dispose();
  }
  _scheduleRender() {
    this._renderAnimationFrame === null && (this._renderAnimationFrame = n5(this._onRenderScheduled.bind(this), 100));
  }
  _onRenderScheduled() {
    this._renderAnimationFrame = null, this._flushAccumulatedAndRenderNow();
  }
  _renderNow() {
    Jde(() => this._actualRender());
  }
  _getViewPartsToRender() {
    let e = [], t = 0;
    for (const i of this._viewParts)
      i.shouldRender() && (e[t++] = i);
    return e;
  }
  _actualRender() {
    if (!e5(this.domNode.domNode))
      return;
    let e = this._getViewPartsToRender();
    if (!this._viewLines.shouldRender() && e.length === 0)
      return;
    const t = this._context.viewLayout.getLinesViewportData();
    this._context.model.setViewport(t.startLineNumber, t.endLineNumber, t.centeredLineNumber);
    const i = new Zde(this._selections, t, this._context.viewLayout.getWhitespaceViewportData(), this._context.model);
    this._contentWidgets.shouldRender() && this._contentWidgets.onBeforeRender(i), this._viewLines.shouldRender() && (this._viewLines.renderText(i), this._viewLines.onDidRender(), e = this._getViewPartsToRender());
    const r = new Qle(this._context.viewLayout, i, this._viewLines);
    for (const o of e)
      o.prepareRender(r);
    for (const o of e)
      o.render(r), o.onDidRender();
    Math.abs(hb() - this._configPixelRatio) > 1e-3 && this._context.configuration.updatePixelRatio();
  }
  // --- BEGIN CodeEditor helpers
  delegateVerticalScrollbarMouseDown(e) {
    this._scrollbar.delegateVerticalScrollbarMouseDown(e);
  }
  restoreState(e) {
    this._context.model.setScrollPosition(
      { scrollTop: e.scrollTop },
      1
      /* Immediate */
    ), this._context.model.tokenizeViewport(), this._renderNow(), this._viewLines.updateLineWidths(), this._context.model.setScrollPosition(
      { scrollLeft: e.scrollLeft },
      1
      /* Immediate */
    );
  }
  getOffsetForColumn(e, t) {
    const i = this._context.model.validateModelPosition({
      lineNumber: e,
      column: t
    }), r = this._context.model.coordinatesConverter.convertModelPositionToViewPosition(i);
    this._flushAccumulatedAndRenderNow();
    const o = this._viewLines.visibleRangeForPosition(new ie(r.lineNumber, r.column));
    return o ? o.left : -1;
  }
  getTargetAtClientPoint(e, t) {
    const i = this._pointerHandler.getTargetAtClientPoint(e, t);
    return i ? IE.convertViewToModelMouseTarget(i, this._context.model.coordinatesConverter) : null;
  }
  createOverviewRuler(e) {
    return new Bde(this._context, e);
  }
  change(e) {
    this._viewZones.changeViewZones(e), this._scheduleRender();
  }
  render(e, t) {
    if (t) {
      this._viewLines.forceShouldRender();
      for (const i of this._viewParts)
        i.forceShouldRender();
    }
    e ? this._flushAccumulatedAndRenderNow() : this._scheduleRender();
  }
  focus() {
    this._textAreaHandler.focusTextArea();
  }
  isFocused() {
    return this._textAreaHandler.isFocused();
  }
  setAriaOptions(e) {
    this._textAreaHandler.setAriaOptions(e);
  }
  addContentWidget(e) {
    this._contentWidgets.addWidget(e.widget), this.layoutContentWidget(e), this._scheduleRender();
  }
  layoutContentWidget(e) {
    let t = e.position && e.position.range || null;
    if (t === null) {
      const r = e.position ? e.position.position : null;
      r !== null && (t = new G(r.lineNumber, r.column, r.lineNumber, r.column));
    }
    const i = e.position ? e.position.preference : null;
    this._contentWidgets.setWidgetPosition(e.widget, t, i), this._scheduleRender();
  }
  removeContentWidget(e) {
    this._contentWidgets.removeWidget(e.widget), this._scheduleRender();
  }
  addOverlayWidget(e) {
    this._overlayWidgets.addWidget(e.widget), this.layoutOverlayWidget(e), this._scheduleRender();
  }
  layoutOverlayWidget(e) {
    const t = e.position ? e.position.preference : null;
    this._overlayWidgets.setWidgetPosition(e.widget, t) && this._scheduleRender();
  }
  removeOverlayWidget(e) {
    this._overlayWidgets.removeWidget(e.widget), this._scheduleRender();
  }
}
function Jde(n) {
  try {
    return n();
  } catch (e) {
    Pi(e);
  }
}
class lW {
  constructor(e) {
    this._selTrackedRange = null, this._trackSelection = !0, this._setState(e, new qn(new G(1, 1, 1, 1), 0, new ie(1, 1), 0), new qn(new G(1, 1, 1, 1), 0, new ie(1, 1), 0));
  }
  dispose(e) {
    this._removeTrackedRange(e);
  }
  startTrackingSelection(e) {
    this._trackSelection = !0, this._updateTrackedRange(e);
  }
  stopTrackingSelection(e) {
    this._trackSelection = !1, this._removeTrackedRange(e);
  }
  _updateTrackedRange(e) {
    this._trackSelection && (this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      this.modelState.selection,
      0
      /* AlwaysGrowsWhenTypingAtEdges */
    ));
  }
  _removeTrackedRange(e) {
    this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      null,
      0
      /* AlwaysGrowsWhenTypingAtEdges */
    );
  }
  asCursorState() {
    return new at(this.modelState, this.viewState);
  }
  readSelectionFromMarkers(e) {
    const t = e.model._getTrackedRange(this._selTrackedRange);
    return this.modelState.selection.getDirection() === 0 ? new Ut(t.startLineNumber, t.startColumn, t.endLineNumber, t.endColumn) : new Ut(t.endLineNumber, t.endColumn, t.startLineNumber, t.startColumn);
  }
  ensureValidState(e) {
    this._setState(e, this.modelState, this.viewState);
  }
  setState(e, t, i) {
    this._setState(e, t, i);
  }
  _setState(e, t, i) {
    if (t) {
      const r = e.model.validateRange(t.selectionStart), o = t.selectionStart.equalsRange(r) ? t.selectionStartLeftoverVisibleColumns : 0, s = e.model.validatePosition(t.position), a = t.position.equals(s) ? t.leftoverVisibleColumns : 0;
      t = new qn(r, o, s, a);
    } else {
      if (!i)
        return;
      const r = e.model.validateRange(e.coordinatesConverter.convertViewRangeToModelRange(i.selectionStart)), o = e.model.validatePosition(e.coordinatesConverter.convertViewPositionToModelPosition(i.position));
      t = new qn(r, i.selectionStartLeftoverVisibleColumns, o, i.leftoverVisibleColumns);
    }
    if (i) {
      const r = e.coordinatesConverter.validateViewRange(i.selectionStart, t.selectionStart), o = e.coordinatesConverter.validateViewPosition(i.position, t.position);
      i = new qn(r, t.selectionStartLeftoverVisibleColumns, o, t.leftoverVisibleColumns);
    } else {
      const r = e.coordinatesConverter.convertModelPositionToViewPosition(new ie(t.selectionStart.startLineNumber, t.selectionStart.startColumn)), o = e.coordinatesConverter.convertModelPositionToViewPosition(new ie(t.selectionStart.endLineNumber, t.selectionStart.endColumn)), s = new G(r.lineNumber, r.column, o.lineNumber, o.column), a = e.coordinatesConverter.convertModelPositionToViewPosition(t.position);
      i = new qn(s, t.selectionStartLeftoverVisibleColumns, a, t.leftoverVisibleColumns);
    }
    this.modelState = t, this.viewState = i, this._updateTrackedRange(e);
  }
}
class uW {
  constructor(e) {
    this.context = e, this.primaryCursor = new lW(e), this.secondaryCursors = [], this.lastAddedCursorIndex = 0;
  }
  dispose() {
    this.primaryCursor.dispose(this.context), this.killSecondaryCursors();
  }
  startTrackingSelections() {
    this.primaryCursor.startTrackingSelection(this.context);
    for (let e = 0, t = this.secondaryCursors.length; e < t; e++)
      this.secondaryCursors[e].startTrackingSelection(this.context);
  }
  stopTrackingSelections() {
    this.primaryCursor.stopTrackingSelection(this.context);
    for (let e = 0, t = this.secondaryCursors.length; e < t; e++)
      this.secondaryCursors[e].stopTrackingSelection(this.context);
  }
  updateContext(e) {
    this.context = e;
  }
  ensureValidState() {
    this.primaryCursor.ensureValidState(this.context);
    for (let e = 0, t = this.secondaryCursors.length; e < t; e++)
      this.secondaryCursors[e].ensureValidState(this.context);
  }
  readSelectionFromMarkers() {
    let e = [];
    e[0] = this.primaryCursor.readSelectionFromMarkers(this.context);
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t].readSelectionFromMarkers(this.context);
    return e;
  }
  getAll() {
    let e = [];
    e[0] = this.primaryCursor.asCursorState();
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t].asCursorState();
    return e;
  }
  getViewPositions() {
    let e = [];
    e[0] = this.primaryCursor.viewState.position;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t].viewState.position;
    return e;
  }
  getTopMostViewPosition() {
    let e = this.primaryCursor.viewState.position;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++) {
      const r = this.secondaryCursors[t].viewState.position;
      r.isBefore(e) && (e = r);
    }
    return e;
  }
  getBottomMostViewPosition() {
    let e = this.primaryCursor.viewState.position;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++) {
      const r = this.secondaryCursors[t].viewState.position;
      e.isBeforeOrEqual(r) && (e = r);
    }
    return e;
  }
  getSelections() {
    let e = [];
    e[0] = this.primaryCursor.modelState.selection;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t].modelState.selection;
    return e;
  }
  getViewSelections() {
    let e = [];
    e[0] = this.primaryCursor.viewState.selection;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t].viewState.selection;
    return e;
  }
  setSelections(e) {
    this.setStates(at.fromModelSelections(e));
  }
  getPrimaryCursor() {
    return this.primaryCursor.asCursorState();
  }
  setStates(e) {
    e !== null && (this.primaryCursor.setState(this.context, e[0].modelState, e[0].viewState), this._setSecondaryStates(e.slice(1)));
  }
  /**
   * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.
   */
  _setSecondaryStates(e) {
    const t = this.secondaryCursors.length, i = e.length;
    if (t < i) {
      let r = i - t;
      for (let o = 0; o < r; o++)
        this._addSecondaryCursor();
    } else if (t > i) {
      let r = t - i;
      for (let o = 0; o < r; o++)
        this._removeSecondaryCursor(this.secondaryCursors.length - 1);
    }
    for (let r = 0; r < i; r++)
      this.secondaryCursors[r].setState(this.context, e[r].modelState, e[r].viewState);
  }
  killSecondaryCursors() {
    this._setSecondaryStates([]);
  }
  _addSecondaryCursor() {
    this.secondaryCursors.push(new lW(this.context)), this.lastAddedCursorIndex = this.secondaryCursors.length;
  }
  getLastAddedCursorIndex() {
    return this.secondaryCursors.length === 0 || this.lastAddedCursorIndex === 0 ? 0 : this.lastAddedCursorIndex;
  }
  _removeSecondaryCursor(e) {
    this.lastAddedCursorIndex >= e + 1 && this.lastAddedCursorIndex--, this.secondaryCursors[e].dispose(this.context), this.secondaryCursors.splice(e, 1);
  }
  _getAll() {
    let e = [];
    e[0] = this.primaryCursor;
    for (let t = 0, i = this.secondaryCursors.length; t < i; t++)
      e[t + 1] = this.secondaryCursors[t];
    return e;
  }
  normalize() {
    if (this.secondaryCursors.length === 0)
      return;
    let e = this._getAll(), t = [];
    for (let i = 0, r = e.length; i < r; i++)
      t.push({
        index: i,
        selection: e[i].modelState.selection
      });
    t.sort((i, r) => i.selection.startLineNumber === r.selection.startLineNumber ? i.selection.startColumn - r.selection.startColumn : i.selection.startLineNumber - r.selection.startLineNumber);
    for (let i = 0; i < t.length - 1; i++) {
      const r = t[i], o = t[i + 1], s = r.selection, a = o.selection;
      if (!this.context.cursorConfig.multiCursorMergeOverlapping)
        continue;
      let l;
      if (a.isEmpty() || s.isEmpty() ? l = a.getStartPosition().isBeforeOrEqual(s.getEndPosition()) : l = a.getStartPosition().isBefore(s.getEndPosition()), l) {
        const u = r.index < o.index ? i : i + 1, c = r.index < o.index ? i + 1 : i, h = t[c].index, d = t[u].index, f = t[c].selection, p = t[u].selection;
        if (!f.equalsSelection(p)) {
          const g = f.plusRange(p), _ = f.selectionStartLineNumber === f.startLineNumber && f.selectionStartColumn === f.startColumn, m = p.selectionStartLineNumber === p.startLineNumber && p.selectionStartColumn === p.startColumn;
          let v;
          h === this.lastAddedCursorIndex ? (v = _, this.lastAddedCursorIndex = d) : v = m;
          let C;
          v ? C = new Ut(g.startLineNumber, g.startColumn, g.endLineNumber, g.endColumn) : C = new Ut(g.endLineNumber, g.endColumn, g.startLineNumber, g.startColumn), t[u].selection = C;
          const y = at.fromModelSelection(C);
          e[d].setState(this.context, y.modelState, y.viewState);
        }
        for (const g of t)
          g.index > h && g.index--;
        e.splice(h, 1), t.splice(c, 1), this._removeSecondaryCursor(h - 1), i--;
      }
    }
  }
}
class efe {
  constructor() {
    this.type = 0;
  }
}
class tfe {
  constructor() {
    this.type = 1;
  }
}
class ife {
  constructor(e) {
    this.type = 2, this._source = e;
  }
  hasChanged(e) {
    return this._source.hasChanged(e);
  }
}
class nfe {
  constructor(e, t) {
    this.type = 3, this.selections = e, this.modelSelections = t;
  }
}
class Uf {
  constructor(e) {
    this.type = 4, e ? (this.affectsMinimap = e.affectsMinimap, this.affectsOverviewRuler = e.affectsOverviewRuler) : (this.affectsMinimap = !0, this.affectsOverviewRuler = !0);
  }
}
class Ny {
  constructor() {
    this.type = 5;
  }
}
class rfe {
  constructor(e) {
    this.type = 6, this.isFocused = e;
  }
}
class ofe {
  constructor() {
    this.type = 7;
  }
}
class Iy {
  constructor() {
    this.type = 8;
  }
}
class c7 {
  constructor(e, t) {
    this.type = 9, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class sO {
  constructor(e, t) {
    this.type = 10, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class aO {
  constructor(e, t) {
    this.type = 11, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class _w {
  constructor(e, t, i, r, o, s) {
    this.type = 12, this.source = e, this.range = t, this.selections = i, this.verticalType = r, this.revealHorizontal = o, this.scrollType = s;
  }
}
class sfe {
  constructor(e) {
    this.type = 13, this.scrollWidth = e.scrollWidth, this.scrollLeft = e.scrollLeft, this.scrollHeight = e.scrollHeight, this.scrollTop = e.scrollTop, this.scrollWidthChanged = e.scrollWidthChanged, this.scrollLeftChanged = e.scrollLeftChanged, this.scrollHeightChanged = e.scrollHeightChanged, this.scrollTopChanged = e.scrollTopChanged;
  }
}
class afe {
  constructor() {
    this.type = 14;
  }
}
class lfe {
  constructor(e) {
    this.type = 15, this.ranges = e;
  }
}
class ufe {
  constructor() {
    this.type = 16;
  }
}
let cfe = class {
  constructor() {
    this.type = 17;
  }
};
class hfe extends Ce {
  constructor() {
    super(), this._onEvent = this._register(new q()), this.onEvent = this._onEvent.event, this._eventHandlers = [], this._viewEventQueue = null, this._isConsumingViewEventQueue = !1, this._collector = null, this._collectorCnt = 0, this._outgoingEvents = [];
  }
  emitOutgoingEvent(e) {
    this._addOutgoingEvent(e), this._emitOugoingEvents();
  }
  _addOutgoingEvent(e) {
    for (let t = 0, i = this._outgoingEvents.length; t < i; t++)
      if (this._outgoingEvents[t].kind === e.kind) {
        this._outgoingEvents[t] = this._outgoingEvents[t].merge(e);
        return;
      }
    this._outgoingEvents.push(e);
  }
  _emitOugoingEvents() {
    for (; this._outgoingEvents.length > 0; ) {
      if (this._collector || this._isConsumingViewEventQueue)
        return;
      const e = this._outgoingEvents.shift();
      e.isNoOp() || this._onEvent.fire(e);
    }
  }
  addViewEventHandler(e) {
    for (let t = 0, i = this._eventHandlers.length; t < i; t++)
      this._eventHandlers[t] === e && console.warn("Detected duplicate listener in ViewEventDispatcher", e);
    this._eventHandlers.push(e);
  }
  removeViewEventHandler(e) {
    for (let t = 0; t < this._eventHandlers.length; t++)
      if (this._eventHandlers[t] === e) {
        this._eventHandlers.splice(t, 1);
        break;
      }
  }
  beginEmitViewEvents() {
    return this._collectorCnt++, this._collectorCnt === 1 && (this._collector = new dfe()), this._collector;
  }
  endEmitViewEvents() {
    if (this._collectorCnt--, this._collectorCnt === 0) {
      const e = this._collector.outgoingEvents, t = this._collector.viewEvents;
      this._collector = null;
      for (const i of e)
        this._addOutgoingEvent(i);
      t.length > 0 && this._emitMany(t);
    }
    this._emitOugoingEvents();
  }
  emitSingleViewEvent(e) {
    try {
      this.beginEmitViewEvents().emitViewEvent(e);
    } finally {
      this.endEmitViewEvents();
    }
  }
  _emitMany(e) {
    this._viewEventQueue ? this._viewEventQueue = this._viewEventQueue.concat(e) : this._viewEventQueue = e, this._isConsumingViewEventQueue || this._consumeViewEventQueue();
  }
  _consumeViewEventQueue() {
    try {
      this._isConsumingViewEventQueue = !0, this._doConsumeQueue();
    } finally {
      this._isConsumingViewEventQueue = !1;
    }
  }
  _doConsumeQueue() {
    for (; this._viewEventQueue; ) {
      const e = this._viewEventQueue;
      this._viewEventQueue = null;
      const t = this._eventHandlers.slice(0);
      for (const i of t)
        i.handleEvents(e);
    }
  }
}
class dfe {
  constructor() {
    this.viewEvents = [], this.outgoingEvents = [];
  }
  emitViewEvent(e) {
    this.viewEvents.push(e);
  }
  emitOutgoingEvent(e) {
    this.outgoingEvents.push(e);
  }
}
class OI {
  constructor(e, t, i, r) {
    this.kind = 0, this._oldContentWidth = e, this._oldContentHeight = t, this.contentWidth = i, this.contentHeight = r, this.contentWidthChanged = this._oldContentWidth !== this.contentWidth, this.contentHeightChanged = this._oldContentHeight !== this.contentHeight;
  }
  isNoOp() {
    return !this.contentWidthChanged && !this.contentHeightChanged;
  }
  merge(e) {
    return e.kind !== 0 ? this : new OI(this._oldContentWidth, this._oldContentHeight, e.contentWidth, e.contentHeight);
  }
}
class xI {
  constructor(e, t) {
    this.kind = 1, this.oldHasFocus = e, this.hasFocus = t;
  }
  isNoOp() {
    return this.oldHasFocus === this.hasFocus;
  }
  merge(e) {
    return e.kind !== 1 ? this : new xI(this.oldHasFocus, e.hasFocus);
  }
}
class NI {
  constructor(e, t, i, r, o, s, a, l) {
    this.kind = 2, this._oldScrollWidth = e, this._oldScrollLeft = t, this._oldScrollHeight = i, this._oldScrollTop = r, this.scrollWidth = o, this.scrollLeft = s, this.scrollHeight = a, this.scrollTop = l, this.scrollWidthChanged = this._oldScrollWidth !== this.scrollWidth, this.scrollLeftChanged = this._oldScrollLeft !== this.scrollLeft, this.scrollHeightChanged = this._oldScrollHeight !== this.scrollHeight, this.scrollTopChanged = this._oldScrollTop !== this.scrollTop;
  }
  isNoOp() {
    return !this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged;
  }
  merge(e) {
    return e.kind !== 2 ? this : new NI(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop);
  }
}
class ffe {
  constructor() {
    this.kind = 3;
  }
  isNoOp() {
    return !1;
  }
  merge(e) {
    return this;
  }
}
class Qb {
  constructor(e, t, i, r, o, s, a) {
    this.kind = 5, this.oldSelections = e, this.selections = t, this.oldModelVersionId = i, this.modelVersionId = r, this.source = o, this.reason = s, this.reachedMaxCursorCount = a;
  }
  static _selectionsAreEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e || !t)
      return !1;
    const i = e.length, r = t.length;
    if (i !== r)
      return !1;
    for (let o = 0; o < i; o++)
      if (!e[o].equalsSelection(t[o]))
        return !1;
    return !0;
  }
  isNoOp() {
    return Qb._selectionsAreEqual(this.oldSelections, this.selections) && this.oldModelVersionId === this.modelVersionId;
  }
  merge(e) {
    return e.kind !== 5 ? this : new Qb(this.oldSelections, e.selections, this.oldModelVersionId, e.modelVersionId, e.source, e.reason, this.reachedMaxCursorCount || e.reachedMaxCursorCount);
  }
}
class pfe {
  constructor() {
    this.kind = 4;
  }
  isNoOp() {
    return !1;
  }
  merge(e) {
    return this;
  }
}
class YD {
  constructor(e, t) {
    this.modelVersionId = e.getVersionId(), this.cursorState = t.getCursorStates();
  }
  equals(e) {
    if (!e || this.modelVersionId !== e.modelVersionId || this.cursorState.length !== e.cursorState.length)
      return !1;
    for (let t = 0, i = this.cursorState.length; t < i; t++)
      if (!this.cursorState[t].equals(e.cursorState[t]))
        return !1;
    return !0;
  }
}
class cW {
  constructor(e, t, i) {
    this._model = e, this._autoClosedCharactersDecorations = t, this._autoClosedEnclosingDecorations = i;
  }
  static getAllAutoClosedCharacters(e) {
    let t = [];
    for (const i of e)
      t = t.concat(i.getAutoClosedCharactersRanges());
    return t;
  }
  dispose() {
    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []), this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);
  }
  getAutoClosedCharactersRanges() {
    let e = [];
    for (let t = 0; t < this._autoClosedCharactersDecorations.length; t++) {
      const i = this._model.getDecorationRange(this._autoClosedCharactersDecorations[t]);
      i && e.push(i);
    }
    return e;
  }
  isValid(e) {
    let t = [];
    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {
      const r = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);
      if (r && (t.push(r), r.startLineNumber !== r.endLineNumber))
        return !1;
    }
    t.sort(G.compareRangesUsingStarts), e.sort(G.compareRangesUsingStarts);
    for (let i = 0; i < e.length; i++)
      if (i >= t.length || !t[i].strictContainsRange(e[i]))
        return !1;
    return !0;
  }
}
class ag extends Ce {
  constructor(e, t, i, r) {
    super(), this._model = e, this._knownModelVersionId = this._model.getVersionId(), this._viewModel = t, this._coordinatesConverter = i, this.context = new F2(this._model, this._coordinatesConverter, r), this._cursors = new uW(this.context), this._hasFocus = !1, this._isHandling = !1, this._isDoingComposition = !1, this._selectionsWhenCompositionStarted = null, this._columnSelectData = null, this._autoClosedActions = [], this._prevEditOperationType = 0;
  }
  dispose() {
    this._cursors.dispose(), this._autoClosedActions = bi(this._autoClosedActions), super.dispose();
  }
  updateConfiguration(e) {
    this.context = new F2(this._model, this._coordinatesConverter, e), this._cursors.updateContext(this.context);
  }
  onLineMappingChanged(e) {
    this._knownModelVersionId === this._model.getVersionId() && this.setStates(e, "viewModel", 0, this.getCursorStates());
  }
  setHasFocus(e) {
    this._hasFocus = e;
  }
  _validateAutoClosedActions() {
    if (this._autoClosedActions.length > 0) {
      let e = this._cursors.getSelections();
      for (let t = 0; t < this._autoClosedActions.length; t++) {
        const i = this._autoClosedActions[t];
        i.isValid(e) || (i.dispose(), this._autoClosedActions.splice(t, 1), t--);
      }
    }
  }
  // ------ some getters/setters
  getPrimaryCursorState() {
    return this._cursors.getPrimaryCursor();
  }
  getLastAddedCursorIndex() {
    return this._cursors.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursors.getAll();
  }
  setStates(e, t, i, r) {
    let o = !1;
    r !== null && r.length > ag.MAX_CURSOR_COUNT && (r = r.slice(0, ag.MAX_CURSOR_COUNT), o = !0);
    const s = new YD(this._model, this);
    return this._cursors.setStates(r), this._cursors.normalize(), this._columnSelectData = null, this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, t, i, s, o);
  }
  setCursorColumnSelectData(e) {
    this._columnSelectData = e;
  }
  revealPrimary(e, t, i, r) {
    const o = this._cursors.getViewPositions();
    if (o.length > 1) {
      this._emitCursorRevealRange(e, t, null, this._cursors.getViewSelections(), 0, i, r);
      return;
    } else {
      const s = o[0], a = new G(s.lineNumber, s.column, s.lineNumber, s.column);
      this._emitCursorRevealRange(e, t, a, null, 0, i, r);
    }
  }
  _revealPrimaryCursor(e, t, i, r, o) {
    const s = this._cursors.getViewPositions();
    if (s.length > 1)
      this._emitCursorRevealRange(e, t, null, this._cursors.getViewSelections(), i, r, o);
    else {
      const a = s[0], l = new G(a.lineNumber, a.column, a.lineNumber, a.column);
      this._emitCursorRevealRange(e, t, l, null, i, r, o);
    }
  }
  _emitCursorRevealRange(e, t, i, r, o, s, a) {
    e.emitViewEvent(new _w(t, i, r, o, s, a));
  }
  saveState() {
    let e = [];
    const t = this._cursors.getSelections();
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      e.push({
        inSelectionMode: !o.isEmpty(),
        selectionStart: {
          lineNumber: o.selectionStartLineNumber,
          column: o.selectionStartColumn
        },
        position: {
          lineNumber: o.positionLineNumber,
          column: o.positionColumn
        }
      });
    }
    return e;
  }
  restoreState(e, t) {
    let i = [];
    for (let r = 0, o = t.length; r < o; r++) {
      const s = t[r];
      let a = 1, l = 1;
      s.position && s.position.lineNumber && (a = s.position.lineNumber), s.position && s.position.column && (l = s.position.column);
      let u = a, c = l;
      s.selectionStart && s.selectionStart.lineNumber && (u = s.selectionStart.lineNumber), s.selectionStart && s.selectionStart.column && (c = s.selectionStart.column), i.push({
        selectionStartLineNumber: u,
        selectionStartColumn: c,
        positionLineNumber: a,
        positionColumn: l
      });
    }
    this.setStates(e, "restoreState", 0, at.fromModelSelections(i)), this.revealPrimary(
      e,
      "restoreState",
      !0,
      1
      /* Immediate */
    );
  }
  onModelContentChanged(e, t) {
    if (this._knownModelVersionId = t.versionId, this._isHandling)
      return;
    const i = t.containsEvent(
      1
      /* Flush */
    );
    if (this._prevEditOperationType = 0, i)
      this._cursors.dispose(), this._cursors = new uW(this.context), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, "model", 1, null, !1);
    else if (this._hasFocus && t.resultingSelection && t.resultingSelection.length > 0) {
      const r = at.fromModelSelections(t.resultingSelection);
      this.setStates(e, "modelChange", t.isUndoing ? 5 : t.isRedoing ? 6 : 2, r) && this._revealPrimaryCursor(
        e,
        "modelChange",
        0,
        !0,
        0
        /* Smooth */
      );
    } else {
      const r = this._cursors.readSelectionFromMarkers();
      this.setStates(e, "modelChange", 2, at.fromModelSelections(r));
    }
  }
  getSelection() {
    return this._cursors.getPrimaryCursor().modelState.selection;
  }
  getTopMostViewPosition() {
    return this._cursors.getTopMostViewPosition();
  }
  getBottomMostViewPosition() {
    return this._cursors.getBottomMostViewPosition();
  }
  getCursorColumnSelectData() {
    if (this._columnSelectData)
      return this._columnSelectData;
    const e = this._cursors.getPrimaryCursor(), t = e.viewState.selectionStart.getStartPosition(), i = e.viewState.position;
    return {
      isReal: !1,
      fromViewLineNumber: t.lineNumber,
      fromViewVisualColumn: Kt.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, t),
      toViewLineNumber: i.lineNumber,
      toViewVisualColumn: Kt.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, i)
    };
  }
  getSelections() {
    return this._cursors.getSelections();
  }
  setSelections(e, t, i, r) {
    this.setStates(e, t, r, at.fromModelSelections(i));
  }
  getPrevEditOperationType() {
    return this._prevEditOperationType;
  }
  setPrevEditOperationType(e) {
    this._prevEditOperationType = e;
  }
  // ------ auxiliary handling logic
  _pushAutoClosedAction(e, t) {
    let i = [], r = [];
    for (let a = 0, l = e.length; a < l; a++)
      i.push({
        range: e[a],
        options: {
          description: "auto-closed-character",
          inlineClassName: "auto-closed-character",
          stickiness: 1
          /* NeverGrowsWhenTypingAtEdges */
        }
      }), r.push({
        range: t[a],
        options: {
          description: "auto-closed-enclosing",
          stickiness: 1
          /* NeverGrowsWhenTypingAtEdges */
        }
      });
    const o = this._model.deltaDecorations([], i), s = this._model.deltaDecorations([], r);
    this._autoClosedActions.push(new cW(this._model, o, s));
  }
  _executeEditOperation(e) {
    if (!e)
      return;
    e.shouldPushStackElementBefore && this._model.pushStackElement();
    const t = gfe.executeCommands(this._model, this._cursors.getSelections(), e.commands);
    if (t) {
      this._interpretCommandResult(t);
      let i = [], r = [];
      for (let o = 0; o < e.commands.length; o++) {
        const s = e.commands[o];
        s instanceof t7 && s.enclosingRange && s.closeCharacterRange && (i.push(s.closeCharacterRange), r.push(s.enclosingRange));
      }
      i.length > 0 && this._pushAutoClosedAction(i, r), this._prevEditOperationType = e.type;
    }
    e.shouldPushStackElementAfter && this._model.pushStackElement();
  }
  _interpretCommandResult(e) {
    (!e || e.length === 0) && (e = this._cursors.readSelectionFromMarkers()), this._columnSelectData = null, this._cursors.setSelections(e), this._cursors.normalize();
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- emitting events
  _emitStateChangedIfNecessary(e, t, i, r, o) {
    const s = new YD(this._model, this);
    if (s.equals(r))
      return !1;
    const a = this._cursors.getSelections(), l = this._cursors.getViewSelections();
    if (e.emitViewEvent(new nfe(l, a)), !r || r.cursorState.length !== s.cursorState.length || s.cursorState.some((u, c) => !u.modelState.equals(r.cursorState[c].modelState))) {
      const u = r ? r.cursorState.map((h) => h.modelState.selection) : null, c = r ? r.modelVersionId : 0;
      e.emitOutgoingEvent(new Qb(u, a, c, s.modelVersionId, t || "keyboard", i, o));
    }
    return !0;
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- handlers beyond this point
  _findAutoClosingPairs(e) {
    if (!e.length)
      return null;
    let t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i];
      if (!o.text || o.text.indexOf(`
`) >= 0)
        return null;
      const s = o.text.match(/([)\]}>'"`])([^)\]}>'"`]*)$/);
      if (!s)
        return null;
      const a = s[1], l = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(a);
      if (!l || l.length !== 1)
        return null;
      const u = l[0].open, c = o.text.length - s[2].length - 1, h = o.text.lastIndexOf(u, c - 1);
      if (h === -1)
        return null;
      t.push([h, c]);
    }
    return t;
  }
  executeEdits(e, t, i, r) {
    let o = null;
    t === "snippet" && (o = this._findAutoClosingPairs(i)), o && (i[0]._isTracked = !0);
    let s = [], a = [];
    const l = this._model.pushEditOperations(this.getSelections(), i, (u) => {
      if (o)
        for (let h = 0, d = o.length; h < d; h++) {
          const [f, p] = o[h], g = u[h], _ = g.range.startLineNumber, m = g.range.startColumn - 1 + f, v = g.range.startColumn - 1 + p;
          s.push(new G(_, v + 1, _, v + 2)), a.push(new G(_, m + 1, _, v + 2));
        }
      const c = r(u);
      return c && (this._isHandling = !0), c;
    });
    l && (this._isHandling = !1, this.setSelections(
      e,
      t,
      l,
      0
      /* NotSet */
    )), s.length > 0 && this._pushAutoClosedAction(s, a);
  }
  _executeEdit(e, t, i, r = 0) {
    if (this.context.cursorConfig.readOnly)
      return;
    const o = new YD(this._model, this);
    this._cursors.stopTrackingSelections(), this._isHandling = !0;
    try {
      this._cursors.ensureValidState(), e();
    } catch (s) {
      Pi(s);
    }
    this._isHandling = !1, this._cursors.startTrackingSelections(), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(t, i, r, o, !1) && this._revealPrimaryCursor(
      t,
      i,
      0,
      !0,
      0
      /* Smooth */
    );
  }
  setIsDoingComposition(e) {
    this._isDoingComposition = e;
  }
  getAutoClosedCharacters() {
    return cW.getAllAutoClosedCharacters(this._autoClosedActions);
  }
  startComposition(e) {
    this._selectionsWhenCompositionStarted = this.getSelections().slice(0);
  }
  endComposition(e, t) {
    this._executeEdit(() => {
      t === "keyboard" && (this._executeEditOperation(Vi.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), this.getAutoClosedCharacters())), this._selectionsWhenCompositionStarted = null);
    }, e, t);
  }
  type(e, t, i) {
    this._executeEdit(() => {
      if (i === "keyboard") {
        const r = t.length;
        let o = 0;
        for (; o < r; ) {
          const s = fb(t, o), a = t.substr(o, s);
          this._executeEditOperation(Vi.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), a)), o += s;
        }
      } else
        this._executeEditOperation(Vi.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t));
    }, e, i);
  }
  compositionType(e, t, i, r, o, s) {
    if (t.length === 0 && i === 0 && r === 0) {
      if (o !== 0) {
        const a = this.getSelections().map((l) => {
          const u = l.getPosition();
          return new Ut(u.lineNumber, u.column + o, u.lineNumber, u.column + o);
        });
        this.setSelections(
          e,
          s,
          a,
          0
          /* NotSet */
        );
      }
      return;
    }
    this._executeEdit(() => {
      this._executeEditOperation(Vi.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t, i, r, o));
    }, e, s);
  }
  paste(e, t, i, r, o) {
    this._executeEdit(
      () => {
        this._executeEditOperation(Vi.paste(this.context.cursorConfig, this._model, this.getSelections(), t, i, r || []));
      },
      e,
      o,
      4
      /* Paste */
    );
  }
  cut(e, t) {
    this._executeEdit(() => {
      this._executeEditOperation(qd.cut(this.context.cursorConfig, this._model, this.getSelections()));
    }, e, t);
  }
  executeCommand(e, t, i) {
    this._executeEdit(() => {
      this._cursors.killSecondaryCursors(), this._executeEditOperation(new vo(0, [t], {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
  executeCommands(e, t, i) {
    this._executeEdit(() => {
      this._executeEditOperation(new vo(0, t, {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
}
ag.MAX_CURSOR_COUNT = 1e4;
class gfe {
  static executeCommands(e, t, i) {
    const r = {
      model: e,
      selectionsBefore: t,
      trackedRanges: [],
      trackedRangesDirection: []
    }, o = this._innerExecuteCommands(r, i);
    for (let s = 0, a = r.trackedRanges.length; s < a; s++)
      r.model._setTrackedRange(
        r.trackedRanges[s],
        null,
        0
        /* AlwaysGrowsWhenTypingAtEdges */
      );
    return o;
  }
  static _innerExecuteCommands(e, t) {
    if (this._arrayIsEmpty(t))
      return null;
    const i = this._getEditOperations(e, t);
    if (i.operations.length === 0)
      return null;
    const r = i.operations, o = this._getLoserCursorMap(r);
    if (o.hasOwnProperty("0"))
      return console.warn("Ignoring commands"), null;
    let s = [];
    for (let u = 0, c = r.length; u < c; u++)
      o.hasOwnProperty(r[u].identifier.major.toString()) || s.push(r[u]);
    i.hadTrackedEditOperation && s.length > 0 && (s[0]._isTracked = !0);
    let a = e.model.pushEditOperations(e.selectionsBefore, s, (u) => {
      let c = [];
      for (let f = 0; f < e.selectionsBefore.length; f++)
        c[f] = [];
      for (const f of u)
        f.identifier && c[f.identifier.major].push(f);
      const h = (f, p) => f.identifier.minor - p.identifier.minor;
      let d = [];
      for (let f = 0; f < e.selectionsBefore.length; f++)
        c[f].length > 0 ? (c[f].sort(h), d[f] = t[f].computeCursorState(e.model, {
          getInverseEditOperations: () => c[f],
          getTrackedSelection: (p) => {
            const g = parseInt(p, 10), _ = e.model._getTrackedRange(e.trackedRanges[g]);
            return e.trackedRangesDirection[g] === 0 ? new Ut(_.startLineNumber, _.startColumn, _.endLineNumber, _.endColumn) : new Ut(_.endLineNumber, _.endColumn, _.startLineNumber, _.startColumn);
          }
        })) : d[f] = e.selectionsBefore[f];
      return d;
    });
    a || (a = e.selectionsBefore);
    let l = [];
    for (let u in o)
      o.hasOwnProperty(u) && l.push(parseInt(u, 10));
    l.sort((u, c) => c - u);
    for (const u of l)
      a.splice(u, 1);
    return a;
  }
  static _arrayIsEmpty(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t])
        return !1;
    return !0;
  }
  static _getEditOperations(e, t) {
    let i = [], r = !1;
    for (let o = 0, s = t.length; o < s; o++) {
      const a = t[o];
      if (a) {
        const l = this._getEditOperationsFromCommand(e, o, a);
        i = i.concat(l.operations), r = r || l.hadTrackedEditOperation;
      }
    }
    return {
      operations: i,
      hadTrackedEditOperation: r
    };
  }
  static _getEditOperationsFromCommand(e, t, i) {
    let r = [], o = 0;
    const s = (h, d, f = !1) => {
      G.isEmpty(h) && d === "" || r.push({
        identifier: {
          major: t,
          minor: o++
        },
        range: h,
        text: d,
        forceMoveMarkers: f,
        isAutoWhitespaceEdit: i.insertsAutoWhitespace
      });
    };
    let a = !1;
    const c = {
      addEditOperation: s,
      addTrackedEditOperation: (h, d, f) => {
        a = !0, s(h, d, f);
      },
      trackSelection: (h, d) => {
        const f = Ut.liftSelection(h);
        let p;
        if (f.isEmpty())
          if (typeof d == "boolean")
            d ? p = 2 : p = 3;
          else {
            const m = e.model.getLineMaxColumn(f.startLineNumber);
            f.startColumn === m ? p = 2 : p = 3;
          }
        else
          p = 1;
        const g = e.trackedRanges.length, _ = e.model._setTrackedRange(null, f, p);
        return e.trackedRanges[g] = _, e.trackedRangesDirection[g] = f.getDirection(), g.toString();
      }
    };
    try {
      i.getEditOperations(e.model, c);
    } catch (h) {
      return Pi(h), {
        operations: [],
        hadTrackedEditOperation: !1
      };
    }
    return {
      operations: r,
      hadTrackedEditOperation: a
    };
  }
  static _getLoserCursorMap(e) {
    e = e.slice(0), e.sort((i, r) => -G.compareRangesUsingEnds(i.range, r.range));
    let t = {};
    for (let i = 1; i < e.length; i++) {
      const r = e[i - 1], o = e[i];
      if (G.getStartPosition(r.range).isBefore(G.getEndPosition(o.range))) {
        let s;
        r.identifier.major > o.identifier.major ? s = r.identifier.major : s = o.identifier.major, t[s.toString()] = !0;
        for (let a = 0; a < e.length; a++)
          e[a].identifier.major === s && (e.splice(a, 1), a < i && i--, a--);
        i > 0 && i--;
      }
    }
    return t;
  }
}
class h7 {
  constructor(e, t, i, r, o, s) {
    this.id = e, this.label = t, this.alias = i, this._precondition = r, this._run = o, this._contextKeyService = s;
  }
  isSupported() {
    return this._contextKeyService.contextMatchesRules(this._precondition);
  }
  run() {
    return this.isSupported() ? this._run() : Promise.resolve(void 0);
  }
}
const hW = {
  getInitialState: () => sE,
  tokenize2: (n, e, t, i) => M5(0, n, t, i)
};
function Fwe(n, e = hW) {
  return vfe(n, e || hW);
}
function mfe(n, e, t, i, r, o, s) {
  let a = "<div>", l = i, u = 0;
  for (let c = 0, h = e.getCount(); c < h; c++) {
    const d = e.getEndOffset(c);
    if (d <= i)
      continue;
    let f = "";
    for (; l < d && l < r; l++) {
      const p = n.charCodeAt(l);
      switch (p) {
        case 9:
          let g = o - (l + u) % o;
          for (u += g - 1; g > 0; )
            f += s ? "&#160;" : " ", g--;
          break;
        case 60:
          f += "&lt;";
          break;
        case 62:
          f += "&gt;";
          break;
        case 38:
          f += "&amp;";
          break;
        case 0:
          f += "&#00;";
          break;
        case 65279:
        case 8232:
        case 8233:
        case 133:
          f += "";
          break;
        case 13:
          f += "&#8203";
          break;
        case 32:
          f += s ? "&#160;" : " ";
          break;
        default:
          f += String.fromCharCode(p);
      }
    }
    if (a += `<span style="${e.getInlineStyle(c, t)}">${f}</span>`, d > r || l >= r)
      break;
  }
  return a += "</div>", a;
}
function vfe(n, e) {
  let t = '<div class="monaco-tokenized-source">', i = z_(n), r = e.getInitialState();
  for (let o = 0, s = i.length; o < s; o++) {
    let a = i[o];
    o > 0 && (t += "<br/>");
    let l = e.tokenize2(a, !0, r, 0);
    eo.convertToEndOffset(l.tokens, a.length);
    let c = new eo(l.tokens, a).inflate(), h = 0;
    for (let d = 0, f = c.getCount(); d < f; d++) {
      const p = c.getClassName(d), g = c.getEndOffset(d);
      t += `<span class="${p}">${p5(a.substring(h, g))}</span>`, h = g;
    }
    r = l.endState;
  }
  return t += "</div>", t;
}
class _fe {
  constructor() {
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [];
  }
  insert(e) {
    this._hasPending = !0, this._inserts.push(e);
  }
  change(e) {
    this._hasPending = !0, this._changes.push(e);
  }
  remove(e) {
    this._hasPending = !0, this._removes.push(e);
  }
  mustCommit() {
    return this._hasPending;
  }
  commit(e) {
    if (!this._hasPending)
      return;
    const t = this._inserts, i = this._changes, r = this._removes;
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [], e._commitPendingChanges(t, i, r);
  }
}
class Cfe {
  constructor(e, t, i, r, o) {
    this.id = e, this.afterLineNumber = t, this.ordinal = i, this.height = r, this.minWidth = o, this.prefixSum = 0;
  }
}
class d_ {
  constructor(e, t, i, r) {
    this._instanceId = w5(++d_.INSTANCE_COUNT), this._pendingChanges = new _fe(), this._lastWhitespaceId = 0, this._arr = [], this._prefixSumValidIndex = -1, this._minWidth = -1, this._lineCount = e, this._lineHeight = t, this._paddingTop = i, this._paddingBottom = r;
  }
  /**
   * Find the insertion index for a new value inside a sorted array of values.
   * If the value is already present in the sorted array, the insertion index will be after the already existing value.
   */
  static findInsertionIndex(e, t, i) {
    let r = 0, o = e.length;
    for (; r < o; ) {
      const s = r + o >>> 1;
      t === e[s].afterLineNumber ? i < e[s].ordinal ? o = s : r = s + 1 : t < e[s].afterLineNumber ? o = s : r = s + 1;
    }
    return r;
  }
  /**
   * Change the height of a line in pixels.
   */
  setLineHeight(e) {
    this._checkPendingChanges(), this._lineHeight = e;
  }
  /**
   * Changes the padding used to calculate vertical offsets.
   */
  setPadding(e, t) {
    this._paddingTop = e, this._paddingBottom = t;
  }
  /**
   * Set the number of lines.
   *
   * @param lineCount New number of lines.
   */
  onFlushed(e) {
    this._checkPendingChanges(), this._lineCount = e;
  }
  changeWhitespace(e) {
    let t = !1;
    try {
      e({
        insertWhitespace: (r, o, s, a) => {
          t = !0, r = r | 0, o = o | 0, s = s | 0, a = a | 0;
          const l = this._instanceId + ++this._lastWhitespaceId;
          return this._pendingChanges.insert(new Cfe(l, r, o, s, a)), l;
        },
        changeOneWhitespace: (r, o, s) => {
          t = !0, o = o | 0, s = s | 0, this._pendingChanges.change({ id: r, newAfterLineNumber: o, newHeight: s });
        },
        removeWhitespace: (r) => {
          t = !0, this._pendingChanges.remove({ id: r });
        }
      });
    } finally {
      this._pendingChanges.commit(this);
    }
    return t;
  }
  _commitPendingChanges(e, t, i) {
    if ((e.length > 0 || i.length > 0) && (this._minWidth = -1), e.length + t.length + i.length <= 1) {
      for (const l of e)
        this._insertWhitespace(l);
      for (const l of t)
        this._changeOneWhitespace(l.id, l.newAfterLineNumber, l.newHeight);
      for (const l of i) {
        const u = this._findWhitespaceIndex(l.id);
        u !== -1 && this._removeWhitespace(u);
      }
      return;
    }
    const r = /* @__PURE__ */ new Set();
    for (const l of i)
      r.add(l.id);
    const o = /* @__PURE__ */ new Map();
    for (const l of t)
      o.set(l.id, l);
    const s = (l) => {
      let u = [];
      for (const c of l)
        if (!r.has(c.id)) {
          if (o.has(c.id)) {
            const h = o.get(c.id);
            c.afterLineNumber = h.newAfterLineNumber, c.height = h.newHeight;
          }
          u.push(c);
        }
      return u;
    }, a = s(this._arr).concat(s(e));
    a.sort((l, u) => l.afterLineNumber === u.afterLineNumber ? l.ordinal - u.ordinal : l.afterLineNumber - u.afterLineNumber), this._arr = a, this._prefixSumValidIndex = -1;
  }
  _checkPendingChanges() {
    this._pendingChanges.mustCommit() && this._pendingChanges.commit(this);
  }
  _insertWhitespace(e) {
    const t = d_.findInsertionIndex(this._arr, e.afterLineNumber, e.ordinal);
    this._arr.splice(t, 0, e), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, t - 1);
  }
  _findWhitespaceIndex(e) {
    const t = this._arr;
    for (let i = 0, r = t.length; i < r; i++)
      if (t[i].id === e)
        return i;
    return -1;
  }
  _changeOneWhitespace(e, t, i) {
    const r = this._findWhitespaceIndex(e);
    if (r !== -1 && (this._arr[r].height !== i && (this._arr[r].height = i, this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, r - 1)), this._arr[r].afterLineNumber !== t)) {
      const o = this._arr[r];
      this._removeWhitespace(r), o.afterLineNumber = t, this._insertWhitespace(o);
    }
  }
  _removeWhitespace(e) {
    this._arr.splice(e, 1), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, e - 1);
  }
  /**
   * Notify the layouter that lines have been deleted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the deletion started, inclusive
   * @param toLineNumber The line number at which the deletion ended, inclusive
   */
  onLinesDeleted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount -= t - e + 1;
    for (let i = 0, r = this._arr.length; i < r; i++) {
      const o = this._arr[i].afterLineNumber;
      e <= o && o <= t ? this._arr[i].afterLineNumber = e - 1 : o > t && (this._arr[i].afterLineNumber -= t - e + 1);
    }
  }
  /**
   * Notify the layouter that lines have been inserted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the insertion started, inclusive
   * @param toLineNumber The line number at which the insertion ended, inclusive.
   */
  onLinesInserted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount += t - e + 1;
    for (let i = 0, r = this._arr.length; i < r; i++) {
      const o = this._arr[i].afterLineNumber;
      e <= o && (this._arr[i].afterLineNumber += t - e + 1);
    }
  }
  /**
   * Get the sum of all the whitespaces.
   */
  getWhitespacesTotalHeight() {
    return this._checkPendingChanges(), this._arr.length === 0 ? 0 : this.getWhitespacesAccumulatedHeight(this._arr.length - 1);
  }
  /**
   * Return the sum of the heights of the whitespaces at [0..index].
   * This includes the whitespace at `index`.
   *
   * @param index The index of the whitespace.
   * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.
   */
  getWhitespacesAccumulatedHeight(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = Math.max(0, this._prefixSumValidIndex + 1);
    t === 0 && (this._arr[0].prefixSum = this._arr[0].height, t++);
    for (let i = t; i <= e; i++)
      this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;
    return this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, e), this._arr[e].prefixSum;
  }
  /**
   * Get the sum of heights for all objects.
   *
   * @return The sum of heights for all objects.
   */
  getLinesTotalHeight() {
    this._checkPendingChanges();
    const e = this._lineHeight * this._lineCount, t = this.getWhitespacesTotalHeight();
    return e + t + this._paddingTop + this._paddingBottom;
  }
  /**
   * Returns the accumulated height of whitespaces before the given line number.
   *
   * @param lineNumber The line number
   */
  getWhitespaceAccumulatedHeightBeforeLineNumber(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this._findLastWhitespaceBeforeLineNumber(e);
    return t === -1 ? 0 : this.getWhitespacesAccumulatedHeight(t);
  }
  _findLastWhitespaceBeforeLineNumber(e) {
    e = e | 0;
    const t = this._arr;
    let i = 0, r = t.length - 1;
    for (; i <= r; ) {
      const s = (r - i | 0) / 2 | 0, a = i + s | 0;
      if (t[a].afterLineNumber < e) {
        if (a + 1 >= t.length || t[a + 1].afterLineNumber >= e)
          return a;
        i = a + 1 | 0;
      } else
        r = a - 1 | 0;
    }
    return -1;
  }
  _findFirstWhitespaceAfterLineNumber(e) {
    e = e | 0;
    const i = this._findLastWhitespaceBeforeLineNumber(e) + 1;
    return i < this._arr.length ? i : -1;
  }
  /**
   * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.
   * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.
   */
  getFirstWhitespaceIndexAfterLineNumber(e) {
    return this._checkPendingChanges(), e = e | 0, this._findFirstWhitespaceAfterLineNumber(e);
  }
  /**
   * Get the vertical offset (the sum of heights for all objects above) a certain line number.
   *
   * @param lineNumber The line number
   * @return The sum of heights for all objects above `lineNumber`.
   */
  getVerticalOffsetForLineNumber(e) {
    this._checkPendingChanges(), e = e | 0;
    let t;
    e > 1 ? t = this._lineHeight * (e - 1) : t = 0;
    const i = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e);
    return t + i + this._paddingTop;
  }
  /**
   * The maximum min width for all whitespaces.
   */
  getWhitespaceMinWidth() {
    if (this._checkPendingChanges(), this._minWidth === -1) {
      let e = 0;
      for (let t = 0, i = this._arr.length; t < i; t++)
        e = Math.max(e, this._arr[t].minWidth);
      this._minWidth = e;
    }
    return this._minWidth;
  }
  /**
   * Check if `verticalOffset` is below all lines.
   */
  isAfterLines(e) {
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e > t;
  }
  isInTopPadding(e) {
    return this._paddingTop === 0 ? !1 : (this._checkPendingChanges(), e < this._paddingTop);
  }
  isInBottomPadding(e) {
    if (this._paddingBottom === 0)
      return !1;
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e >= t - this._paddingBottom;
  }
  /**
   * Find the first line number that is at or after vertical offset `verticalOffset`.
   * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then
   * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.
   *
   * @param verticalOffset The vertical offset to search at.
   * @return The line number at or after vertical offset `verticalOffset`.
   */
  getLineNumberAtOrAfterVerticalOffset(e) {
    if (this._checkPendingChanges(), e = e | 0, e < 0)
      return 1;
    const t = this._lineCount | 0, i = this._lineHeight;
    let r = 1, o = t;
    for (; r < o; ) {
      const s = (r + o) / 2 | 0, a = this.getVerticalOffsetForLineNumber(s) | 0;
      if (e >= a + i)
        r = s + 1;
      else {
        if (e >= a)
          return s;
        o = s;
      }
    }
    return r > t ? t : r;
  }
  /**
   * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.
   */
  getLinesViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this._lineHeight, r = this.getLineNumberAtOrAfterVerticalOffset(e) | 0, o = this.getVerticalOffsetForLineNumber(r) | 0;
    let s = this._lineCount | 0, a = this.getFirstWhitespaceIndexAfterLineNumber(r) | 0;
    const l = this.getWhitespacesCount() | 0;
    let u, c;
    a === -1 ? (a = l, c = s + 1, u = 0) : (c = this.getAfterLineNumberForWhitespaceIndex(a) | 0, u = this.getHeightForWhitespaceIndex(a) | 0);
    let h = o, d = h;
    const f = 5e5;
    let p = 0;
    o >= f && (p = Math.floor(o / f) * f, p = Math.floor(p / i) * i, d -= p);
    const g = [], _ = e + (t - e) / 2;
    let m = -1;
    for (let w = r; w <= s; w++) {
      if (m === -1) {
        const L = h, S = h + i;
        (L <= _ && _ < S || L > _) && (m = w);
      }
      for (h += i, g[w - r] = d, d += i; c === w; )
        d += u, h += u, a++, a >= l ? c = s + 1 : (c = this.getAfterLineNumberForWhitespaceIndex(a) | 0, u = this.getHeightForWhitespaceIndex(a) | 0);
      if (h >= t) {
        s = w;
        break;
      }
    }
    m === -1 && (m = s);
    const v = this.getVerticalOffsetForLineNumber(s) | 0;
    let C = r, y = s;
    return C < y && o < e && C++, C < y && v + i > t && y--, {
      bigNumbersDelta: p,
      startLineNumber: r,
      endLineNumber: s,
      relativeVerticalOffset: g,
      centeredLineNumber: m,
      completelyVisibleStartLineNumber: C,
      completelyVisibleEndLineNumber: y
    };
  }
  getVerticalOffsetForWhitespaceIndex(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getAfterLineNumberForWhitespaceIndex(e);
    let i;
    t >= 1 ? i = this._lineHeight * t : i = 0;
    let r;
    return e > 0 ? r = this.getWhitespacesAccumulatedHeight(e - 1) : r = 0, i + r + this._paddingTop;
  }
  getWhitespaceIndexAtOrAfterVerticallOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = 0, i = this.getWhitespacesCount() - 1;
    if (i < 0)
      return -1;
    const r = this.getVerticalOffsetForWhitespaceIndex(i), o = this.getHeightForWhitespaceIndex(i);
    if (e >= r + o)
      return -1;
    for (; t < i; ) {
      const s = Math.floor((t + i) / 2), a = this.getVerticalOffsetForWhitespaceIndex(s), l = this.getHeightForWhitespaceIndex(s);
      if (e >= a + l)
        t = s + 1;
      else {
        if (e >= a)
          return s;
        i = s;
      }
    }
    return t;
  }
  /**
   * Get exactly the whitespace that is layouted at `verticalOffset`.
   *
   * @param verticalOffset The vertical offset.
   * @return Precisely the whitespace that is layouted at `verticaloffset` or null.
   */
  getWhitespaceAtVerticalOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getWhitespaceIndexAtOrAfterVerticallOffset(e);
    if (t < 0 || t >= this.getWhitespacesCount())
      return null;
    const i = this.getVerticalOffsetForWhitespaceIndex(t);
    if (i > e)
      return null;
    const r = this.getHeightForWhitespaceIndex(t), o = this.getIdForWhitespaceIndex(t), s = this.getAfterLineNumberForWhitespaceIndex(t);
    return {
      id: o,
      afterLineNumber: s,
      verticalOffset: i,
      height: r
    };
  }
  /**
   * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.
   */
  getWhitespaceViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this.getWhitespaceIndexAtOrAfterVerticallOffset(e), r = this.getWhitespacesCount() - 1;
    if (i < 0)
      return [];
    let o = [];
    for (let s = i; s <= r; s++) {
      const a = this.getVerticalOffsetForWhitespaceIndex(s), l = this.getHeightForWhitespaceIndex(s);
      if (a >= t)
        break;
      o.push({
        id: this.getIdForWhitespaceIndex(s),
        afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(s),
        verticalOffset: a,
        height: l
      });
    }
    return o;
  }
  /**
   * Get all whitespaces.
   */
  getWhitespaces() {
    return this._checkPendingChanges(), this._arr.slice(0);
  }
  /**
   * The number of whitespaces.
   */
  getWhitespacesCount() {
    return this._checkPendingChanges(), this._arr.length;
  }
  /**
   * Get the `id` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `id` of whitespace at `index`.
   */
  getIdForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].id;
  }
  /**
   * Get the `afterLineNumber` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `afterLineNumber` of whitespace at `index`.
   */
  getAfterLineNumberForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].afterLineNumber;
  }
  /**
   * Get the `height` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `height` of whitespace at `index`.
   */
  getHeightForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].height;
  }
}
d_.INSTANCE_COUNT = 0;
const yfe = 125;
class tv {
  constructor(e, t, i, r) {
    e = e | 0, t = t | 0, i = i | 0, r = r | 0, e < 0 && (e = 0), t < 0 && (t = 0), i < 0 && (i = 0), r < 0 && (r = 0), this.width = e, this.contentWidth = t, this.scrollWidth = Math.max(e, t), this.height = i, this.contentHeight = r, this.scrollHeight = Math.max(i, r);
  }
  equals(e) {
    return this.width === e.width && this.contentWidth === e.contentWidth && this.height === e.height && this.contentHeight === e.contentHeight;
  }
}
class wfe extends Ce {
  constructor(e, t) {
    super(), this._onDidContentSizeChange = this._register(new q()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._dimensions = new tv(0, 0, 0, 0), this._scrollable = this._register(new AE(e, t)), this.onDidScroll = this._scrollable.onScroll;
  }
  getScrollable() {
    return this._scrollable;
  }
  setSmoothScrollDuration(e) {
    this._scrollable.setSmoothScrollDuration(e);
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  getScrollDimensions() {
    return this._dimensions;
  }
  setScrollDimensions(e) {
    if (this._dimensions.equals(e))
      return;
    const t = this._dimensions;
    this._dimensions = e, this._scrollable.setScrollDimensions({
      width: e.width,
      scrollWidth: e.scrollWidth,
      height: e.height,
      scrollHeight: e.scrollHeight
    }, !0);
    const i = t.contentWidth !== e.contentWidth, r = t.contentHeight !== e.contentHeight;
    (i || r) && this._onDidContentSizeChange.fire(new OI(t.contentWidth, t.contentHeight, e.contentWidth, e.contentHeight));
  }
  getFutureScrollPosition() {
    return this._scrollable.getFutureScrollPosition();
  }
  getCurrentScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  setScrollPositionNow(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  setScrollPositionSmooth(e) {
    this._scrollable.setScrollPositionSmooth(e);
  }
}
class bfe extends Ce {
  constructor(e, t, i) {
    super(), this._configuration = e;
    const r = this._configuration.options, o = r.get(
      128
      /* layoutInfo */
    ), s = r.get(
      72
      /* padding */
    );
    this._linesLayout = new d_(t, r.get(
      56
      /* lineHeight */
    ), s.top, s.bottom), this._scrollable = this._register(new wfe(0, i)), this._configureSmoothScrollDuration(), this._scrollable.setScrollDimensions(new tv(o.contentWidth, 0, o.height, 0)), this.onDidScroll = this._scrollable.onDidScroll, this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange, this._updateHeight();
  }
  dispose() {
    super.dispose();
  }
  getScrollable() {
    return this._scrollable.getScrollable();
  }
  onHeightMaybeChanged() {
    this._updateHeight();
  }
  _configureSmoothScrollDuration() {
    this._scrollable.setSmoothScrollDuration(this._configuration.options.get(
      101
      /* smoothScrolling */
    ) ? yfe : 0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._configuration.options;
    if (e.hasChanged(
      56
      /* lineHeight */
    ) && this._linesLayout.setLineHeight(t.get(
      56
      /* lineHeight */
    )), e.hasChanged(
      72
      /* padding */
    )) {
      const i = t.get(
        72
        /* padding */
      );
      this._linesLayout.setPadding(i.top, i.bottom);
    }
    if (e.hasChanged(
      128
      /* layoutInfo */
    )) {
      const i = t.get(
        128
        /* layoutInfo */
      ), r = i.contentWidth, o = i.height, s = this._scrollable.getScrollDimensions(), a = s.contentWidth;
      this._scrollable.setScrollDimensions(new tv(r, s.contentWidth, o, this._getContentHeight(r, o, a)));
    } else
      this._updateHeight();
    e.hasChanged(
      101
      /* smoothScrolling */
    ) && this._configureSmoothScrollDuration();
  }
  onFlushed(e) {
    this._linesLayout.onFlushed(e);
  }
  onLinesDeleted(e, t) {
    this._linesLayout.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._linesLayout.onLinesInserted(e, t);
  }
  // ---- end view event handlers
  _getHorizontalScrollbarHeight(e, t) {
    const r = this._configuration.options.get(
      90
      /* scrollbar */
    );
    return r.horizontal === 2 || e >= t ? 0 : r.horizontalScrollbarSize;
  }
  _getContentHeight(e, t, i) {
    const r = this._configuration.options;
    let o = this._linesLayout.getLinesTotalHeight();
    return r.get(
      92
      /* scrollBeyondLastLine */
    ) ? o += Math.max(0, t - r.get(
      56
      /* lineHeight */
    ) - r.get(
      72
      /* padding */
    ).bottom) : o += this._getHorizontalScrollbarHeight(e, i), o;
  }
  _updateHeight() {
    const e = this._scrollable.getScrollDimensions(), t = e.width, i = e.height, r = e.contentWidth;
    this._scrollable.setScrollDimensions(new tv(t, e.contentWidth, i, this._getContentHeight(t, i, r)));
  }
  // ---- Layouting logic
  getCurrentViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getCurrentScrollPosition();
    return new qk(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  getFutureViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getFutureScrollPosition();
    return new qk(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  _computeContentWidth(e) {
    const t = this._configuration.options, i = t.get(
      129
      /* wrappingInfo */
    ), r = t.get(
      40
      /* fontInfo */
    );
    if (i.isViewportWrapping) {
      const o = t.get(
        128
        /* layoutInfo */
      ), s = t.get(
        62
        /* minimap */
      );
      return e > o.contentWidth + r.typicalHalfwidthCharacterWidth && s.enabled && s.side === "right" ? e + o.verticalScrollbarWidth : e;
    } else {
      const o = t.get(
        91
        /* scrollBeyondLastColumn */
      ) * r.typicalHalfwidthCharacterWidth, s = this._linesLayout.getWhitespaceMinWidth();
      return Math.max(e + o, s);
    }
  }
  setMaxLineWidth(e) {
    const t = this._scrollable.getScrollDimensions();
    this._scrollable.setScrollDimensions(new tv(t.width, this._computeContentWidth(e), t.height, t.contentHeight)), this._updateHeight();
  }
  // ---- view state
  saveState() {
    const e = this._scrollable.getFutureScrollPosition();
    let t = e.scrollTop, i = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(t), r = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(i);
    return {
      scrollTop: t,
      scrollTopWithoutViewZones: t - r,
      scrollLeft: e.scrollLeft
    };
  }
  // ---- IVerticalLayoutProvider
  changeWhitespace(e) {
    const t = this._linesLayout.changeWhitespace(e);
    return t && this.onHeightMaybeChanged(), t;
  }
  getVerticalOffsetForLineNumber(e) {
    return this._linesLayout.getVerticalOffsetForLineNumber(e);
  }
  isAfterLines(e) {
    return this._linesLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._linesLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._linesLayout.isInBottomPadding(e);
  }
  getLineNumberAtVerticalOffset(e) {
    return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(e);
  }
  getWhitespaceAtVerticalOffset(e) {
    return this._linesLayout.getWhitespaceAtVerticalOffset(e);
  }
  getLinesViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getLinesViewportData(e.top, e.top + e.height);
  }
  getLinesViewportDataAtScrollTop(e) {
    const t = this._scrollable.getScrollDimensions();
    return e + t.height > t.scrollHeight && (e = t.scrollHeight - t.height), e < 0 && (e = 0), this._linesLayout.getLinesViewportData(e, e + t.height);
  }
  getWhitespaceViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getWhitespaceViewportData(e.top, e.top + e.height);
  }
  getWhitespaces() {
    return this._linesLayout.getWhitespaces();
  }
  // ---- IScrollingProvider
  getContentWidth() {
    return this._scrollable.getScrollDimensions().contentWidth;
  }
  getScrollWidth() {
    return this._scrollable.getScrollDimensions().scrollWidth;
  }
  getContentHeight() {
    return this._scrollable.getScrollDimensions().contentHeight;
  }
  getScrollHeight() {
    return this._scrollable.getScrollDimensions().scrollHeight;
  }
  getCurrentScrollLeft() {
    return this._scrollable.getCurrentScrollPosition().scrollLeft;
  }
  getCurrentScrollTop() {
    return this._scrollable.getCurrentScrollPosition().scrollTop;
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  setScrollPosition(e, t) {
    t === 1 ? this._scrollable.setScrollPositionNow(e) : this._scrollable.setScrollPositionSmooth(e);
  }
  deltaScrollNow(e, t) {
    const i = this._scrollable.getCurrentScrollPosition();
    this._scrollable.setScrollPositionNow({
      scrollLeft: i.scrollLeft + e,
      scrollTop: i.scrollTop + t
    });
  }
}
class Sfe {
  constructor(e) {
    this._lines = e;
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._lines.convertViewPositionToModelPosition(e.lineNumber, e.column);
  }
  convertViewRangeToModelRange(e) {
    return this._lines.convertViewRangeToModelRange(e);
  }
  validateViewPosition(e, t) {
    return this._lines.validateViewPosition(e.lineNumber, e.column, t);
  }
  validateViewRange(e, t) {
    return this._lines.validateViewRange(e, t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e) {
    return this._lines.convertModelPositionToViewPosition(e.lineNumber, e.column);
  }
  convertModelRangeToViewRange(e) {
    return this._lines.convertModelRangeToViewRange(e);
  }
  modelPositionIsVisible(e) {
    return this._lines.modelPositionIsVisible(e.lineNumber, e.column);
  }
  getModelLineViewLineCount(e) {
    return this._lines.getModelLineViewLineCount(e);
  }
}
class Efe {
  constructor(e) {
    this._counts = e, this._isValid = !1, this._validEndIndex = -1, this._modelToView = [], this._viewToModel = [];
  }
  _invalidate(e) {
    this._isValid = !1, this._validEndIndex = Math.min(this._validEndIndex, e - 1);
  }
  _ensureValid() {
    if (!this._isValid) {
      for (let e = this._validEndIndex + 1, t = this._counts.length; e < t; e++) {
        const i = this._counts[e], r = e > 0 ? this._modelToView[e - 1] : 0;
        this._modelToView[e] = r + i;
        for (let o = 0; o < i; o++)
          this._viewToModel[r + o] = e;
      }
      this._modelToView.length = this._counts.length, this._viewToModel.length = this._modelToView[this._modelToView.length - 1], this._isValid = !0, this._validEndIndex = this._counts.length - 1;
    }
  }
  changeValue(e, t) {
    this._counts[e] !== t && (this._counts[e] = t, this._invalidate(e));
  }
  removeValues(e, t) {
    this._counts.splice(e, t), this._invalidate(e);
  }
  insertValues(e, t) {
    this._counts = Jv(this._counts, e, t), this._invalidate(e);
  }
  getTotalValue() {
    return this._ensureValid(), this._viewToModel.length;
  }
  getAccumulatedValue(e) {
    return this._ensureValid(), this._modelToView[e];
  }
  getIndexOf(e) {
    this._ensureValid();
    const t = this._viewToModel[e], i = t > 0 ? this._modelToView[t - 1] : 0;
    return new U5(t, e - i);
  }
}
class Lfe {
  constructor(e, t, i, r, o, s, a, l) {
    this.model = e, this._validModelVersionId = -1, this._domLineBreaksComputerFactory = t, this._monospaceLineBreaksComputerFactory = i, this.fontInfo = r, this.tabSize = o, this.wrappingStrategy = s, this.wrappingColumn = a, this.wrappingIndent = l, this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  dispose() {
    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);
  }
  createCoordinatesConverter() {
    return new Sfe(this);
  }
  _constructLines(e, t) {
    this.lines = [], e && (this.hiddenAreasIds = []);
    let i = this.model.getLinesContent();
    const r = i.length, o = this.createLineBreaksComputer();
    for (let f = 0; f < r; f++)
      o.addRequest(i[f], t ? t[f] : null);
    const s = o.finalize();
    let a = [], l = this.hiddenAreasIds.map((f) => this.model.getDecorationRange(f)).sort(G.compareRangesUsingStarts), u = 1, c = 0, h = -1, d = h + 1 < l.length ? c + 1 : r + 2;
    for (let f = 0; f < r; f++) {
      let p = f + 1;
      p === d && (h++, u = l[h].startLineNumber, c = l[h].endLineNumber, d = h + 1 < l.length ? c + 1 : r + 2);
      let g = p >= u && p <= c, _ = ZD(s[f], !g);
      a[f] = _.getViewLineCount(), this.lines[f] = _;
    }
    this._validModelVersionId = this.model.getVersionId(), this.prefixSumComputer = new Efe(a);
  }
  getHiddenAreas() {
    return this.hiddenAreasIds.map((e) => this.model.getDecorationRange(e));
  }
  _reduceRanges(e) {
    if (e.length === 0)
      return [];
    let t = e.map((s) => this.model.validateRange(s)).sort(G.compareRangesUsingStarts), i = [], r = t[0].startLineNumber, o = t[0].endLineNumber;
    for (let s = 1, a = t.length; s < a; s++) {
      let l = t[s];
      l.startLineNumber > o + 1 ? (i.push(new G(r, 1, o, 1)), r = l.startLineNumber, o = l.endLineNumber) : l.endLineNumber > o && (o = l.endLineNumber);
    }
    return i.push(new G(r, 1, o, 1)), i;
  }
  setHiddenAreas(e) {
    let t = this._reduceRanges(e), i = this.hiddenAreasIds.map((h) => this.model.getDecorationRange(h)).sort(G.compareRangesUsingStarts);
    if (t.length === i.length) {
      let h = !1;
      for (let d = 0; d < t.length; d++)
        if (!t[d].equalsRange(i[d])) {
          h = !0;
          break;
        }
      if (!h)
        return !1;
    }
    let r = [];
    for (const h of t)
      r.push({
        range: h,
        options: kn.EMPTY
      });
    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, r);
    let o = t, s = 1, a = 0, l = -1, u = l + 1 < o.length ? a + 1 : this.lines.length + 2, c = !1;
    for (let h = 0; h < this.lines.length; h++) {
      let d = h + 1;
      d === u && (l++, s = o[l].startLineNumber, a = o[l].endLineNumber, u = l + 1 < o.length ? a + 1 : this.lines.length + 2);
      let f = !1;
      if (d >= s && d <= a ? this.lines[h].isVisible() && (this.lines[h] = this.lines[h].setVisible(!1), f = !0) : (c = !0, this.lines[h].isVisible() || (this.lines[h] = this.lines[h].setVisible(!0), f = !0)), f) {
        let p = this.lines[h].getViewLineCount();
        this.prefixSumComputer.changeValue(h, p);
      }
    }
    return c || this.setHiddenAreas([]), !0;
  }
  modelPositionIsVisible(e, t) {
    return e < 1 || e > this.lines.length ? !1 : this.lines[e - 1].isVisible();
  }
  getModelLineViewLineCount(e) {
    return e < 1 || e > this.lines.length ? 1 : this.lines[e - 1].getViewLineCount();
  }
  setTabSize(e) {
    return this.tabSize === e ? !1 : (this.tabSize = e, this._constructLines(
      /*resetHiddenAreas*/
      !1,
      null
    ), !0);
  }
  setWrappingSettings(e, t, i, r) {
    const o = this.fontInfo.equals(e), s = this.wrappingStrategy === t, a = this.wrappingColumn === i, l = this.wrappingIndent === r;
    if (o && s && a && l)
      return !1;
    const u = o && s && !a && l;
    this.fontInfo = e, this.wrappingStrategy = t, this.wrappingColumn = i, this.wrappingIndent = r;
    let c = null;
    if (u) {
      c = [];
      for (let h = 0, d = this.lines.length; h < d; h++)
        c[h] = this.lines[h].getLineBreakData();
    }
    return this._constructLines(
      /*resetHiddenAreas*/
      !1,
      c
    ), !0;
  }
  createLineBreaksComputer() {
    return (this.wrappingStrategy === "advanced" ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory).createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);
  }
  onModelFlushed() {
    this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  onModelLinesDeleted(e, t, i) {
    if (e <= this._validModelVersionId)
      return null;
    let r = t === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(t - 2) + 1, o = this.prefixSumComputer.getAccumulatedValue(i - 1);
    return this.lines.splice(t - 1, i - t + 1), this.prefixSumComputer.removeValues(t - 1, i - t + 1), new sO(r, o);
  }
  onModelLinesInserted(e, t, i, r) {
    if (e <= this._validModelVersionId)
      return null;
    const o = t > 2 && !this.lines[t - 2].isVisible();
    let s = t === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(t - 2) + 1, a = 0, l = [], u = [];
    for (let c = 0, h = r.length; c < h; c++) {
      let d = ZD(r[c], !o);
      l.push(d);
      let f = d.getViewLineCount();
      a += f, u[c] = f;
    }
    return this.lines = this.lines.slice(0, t - 1).concat(l).concat(this.lines.slice(t - 1)), this.prefixSumComputer.insertValues(t - 1, u), new aO(s, s + a - 1);
  }
  onModelLineChanged(e, t, i) {
    if (e <= this._validModelVersionId)
      return [!1, null, null, null];
    let r = t - 1, o = this.lines[r].getViewLineCount(), s = this.lines[r].isVisible(), a = ZD(i, s);
    this.lines[r] = a;
    let l = this.lines[r].getViewLineCount(), u = !1, c = 0, h = -1, d = 0, f = -1, p = 0, g = -1;
    o > l ? (c = t === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(t - 2) + 1, h = c + l - 1, p = h + 1, g = p + (o - l) - 1, u = !0) : o < l ? (c = t === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(t - 2) + 1, h = c + o - 1, d = h + 1, f = d + (l - o) - 1, u = !0) : (c = t === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(t - 2) + 1, h = c + l - 1), this.prefixSumComputer.changeValue(r, l);
    const _ = c <= h ? new c7(c, h) : null, m = d <= f ? new aO(d, f) : null, v = p <= g ? new sO(p, g) : null;
    return [u, _, m, v];
  }
  acceptVersionId(e) {
    this._validModelVersionId = e, this.lines.length === 1 && !this.lines[0].isVisible() && this.setHiddenAreas([]);
  }
  getViewLineCount() {
    return this.prefixSumComputer.getTotalValue();
  }
  _toValidViewLineNumber(e) {
    if (e < 1)
      return 1;
    const t = this.getViewLineCount();
    return e > t ? t : e | 0;
  }
  getActiveIndentGuide(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t), i = this._toValidViewLineNumber(i);
    const r = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), o = this.convertViewPositionToModelPosition(t, this.getViewLineMinColumn(t)), s = this.convertViewPositionToModelPosition(i, this.getViewLineMinColumn(i)), a = this.model.getActiveIndentGuide(r.lineNumber, o.lineNumber, s.lineNumber), l = this.convertModelPositionToViewPosition(a.startLineNumber, 1), u = this.convertModelPositionToViewPosition(a.endLineNumber, this.model.getLineMaxColumn(a.endLineNumber));
    return {
      startLineNumber: l.lineNumber,
      endLineNumber: u.lineNumber,
      indent: a.indent
    };
  }
  getViewLinesIndentGuides(e, t) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const i = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), r = this.convertViewPositionToModelPosition(t, this.getViewLineMaxColumn(t));
    let o = [], s = [], a = [];
    const l = i.lineNumber - 1, u = r.lineNumber - 1;
    let c = null;
    for (let p = l; p <= u; p++) {
      const g = this.lines[p];
      if (g.isVisible()) {
        let _ = g.getViewLineNumberOfModelPosition(0, p === l ? i.column : 1), m = g.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(p + 1)), v = m - _ + 1, C = 0;
        v > 1 && g.getViewLineMinColumn(this.model, p + 1, m) === 1 && (C = _ === 0 ? 1 : 2), s.push(v), a.push(C), c === null && (c = new ie(p + 1, 0));
      } else
        c !== null && (o = o.concat(this.model.getLinesIndentGuides(c.lineNumber, p)), c = null);
    }
    c !== null && (o = o.concat(this.model.getLinesIndentGuides(c.lineNumber, r.lineNumber)), c = null);
    const h = t - e + 1;
    let d = new Array(h), f = 0;
    for (let p = 0, g = o.length; p < g; p++) {
      let _ = o[p], m = Math.min(h - f, s[p]), v = a[p], C;
      v === 2 ? C = 0 : v === 1 ? C = 1 : C = m;
      for (let y = 0; y < m; y++)
        y === C && (_ = 0), d[f++] = _;
    }
    return d;
  }
  getViewLineContent(e) {
    e = this._toValidViewLineNumber(e);
    let t = this.prefixSumComputer.getIndexOf(e - 1), i = t.index, r = t.remainder;
    return this.lines[i].getViewLineContent(this.model, i + 1, r);
  }
  getViewLineLength(e) {
    e = this._toValidViewLineNumber(e);
    let t = this.prefixSumComputer.getIndexOf(e - 1), i = t.index, r = t.remainder;
    return this.lines[i].getViewLineLength(this.model, i + 1, r);
  }
  getViewLineMinColumn(e) {
    e = this._toValidViewLineNumber(e);
    let t = this.prefixSumComputer.getIndexOf(e - 1), i = t.index, r = t.remainder;
    return this.lines[i].getViewLineMinColumn(this.model, i + 1, r);
  }
  getViewLineMaxColumn(e) {
    e = this._toValidViewLineNumber(e);
    let t = this.prefixSumComputer.getIndexOf(e - 1), i = t.index, r = t.remainder;
    return this.lines[i].getViewLineMaxColumn(this.model, i + 1, r);
  }
  getViewLineData(e) {
    e = this._toValidViewLineNumber(e);
    let t = this.prefixSumComputer.getIndexOf(e - 1), i = t.index, r = t.remainder;
    return this.lines[i].getViewLineData(this.model, i + 1, r);
  }
  getViewLinesData(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    let r = this.prefixSumComputer.getIndexOf(e - 1), o = e, s = r.index, a = r.remainder, l = [];
    for (let u = s, c = this.model.getLineCount(); u < c; u++) {
      let h = this.lines[u];
      if (!h.isVisible())
        continue;
      let d = u === s ? a : 0, f = h.getViewLineCount() - d, p = !1;
      o + f > t && (p = !0, f = t - o + 1);
      let g = d + f;
      if (h.getViewLinesData(this.model, u + 1, d, g, o - e, i, l), o += f, p)
        break;
    }
    return l;
  }
  validateViewPosition(e, t, i) {
    e = this._toValidViewLineNumber(e);
    let r = this.prefixSumComputer.getIndexOf(e - 1), o = r.index, s = r.remainder, a = this.lines[o], l = a.getViewLineMinColumn(this.model, o + 1, s), u = a.getViewLineMaxColumn(this.model, o + 1, s);
    t < l && (t = l), t > u && (t = u);
    let c = a.getModelColumnOfViewPosition(s, t);
    return this.model.validatePosition(new ie(o + 1, c)).equals(i) ? new ie(e, t) : this.convertModelPositionToViewPosition(i.lineNumber, i.column);
  }
  validateViewRange(e, t) {
    const i = this.validateViewPosition(e.startLineNumber, e.startColumn, t.getStartPosition()), r = this.validateViewPosition(e.endLineNumber, e.endColumn, t.getEndPosition());
    return new G(i.lineNumber, i.column, r.lineNumber, r.column);
  }
  convertViewPositionToModelPosition(e, t) {
    e = this._toValidViewLineNumber(e);
    let i = this.prefixSumComputer.getIndexOf(e - 1), r = i.index, o = i.remainder, s = this.lines[r].getModelColumnOfViewPosition(o, t);
    return this.model.validatePosition(new ie(r + 1, s));
  }
  convertViewRangeToModelRange(e) {
    const t = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), i = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    return new G(t.lineNumber, t.column, i.lineNumber, i.column);
  }
  convertModelPositionToViewPosition(e, t) {
    const i = this.model.validatePosition(new ie(e, t)), r = i.lineNumber, o = i.column;
    let s = r - 1, a = !1;
    for (; s > 0 && !this.lines[s].isVisible(); )
      s--, a = !0;
    if (s === 0 && !this.lines[s].isVisible())
      return new ie(1, 1);
    const l = 1 + (s === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(s - 1));
    let u;
    return a ? u = this.lines[s].getViewPositionOfModelPosition(l, this.model.getLineMaxColumn(s + 1)) : u = this.lines[r - 1].getViewPositionOfModelPosition(l, o), u;
  }
  convertModelRangeToViewRange(e) {
    let t = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn), i = this.convertModelPositionToViewPosition(e.endLineNumber, e.endColumn);
    return e.startLineNumber === e.endLineNumber && t.lineNumber !== i.lineNumber && i.column === this.getViewLineMinColumn(i.lineNumber) ? new G(t.lineNumber, t.column, i.lineNumber - 1, this.getViewLineMaxColumn(i.lineNumber - 1)) : new G(t.lineNumber, t.column, i.lineNumber, i.column);
  }
  _getViewLineNumberForModelPosition(e, t) {
    let i = e - 1;
    if (this.lines[i].isVisible()) {
      const o = 1 + (i === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(i - 1));
      return this.lines[i].getViewLineNumberOfModelPosition(o, t);
    }
    for (; i > 0 && !this.lines[i].isVisible(); )
      i--;
    if (i === 0 && !this.lines[i].isVisible())
      return 1;
    const r = 1 + (i === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(i - 1));
    return this.lines[i].getViewLineNumberOfModelPosition(r, this.model.getLineMaxColumn(i + 1));
  }
  getAllOverviewRulerDecorations(e, t, i) {
    const r = this.model.getOverviewRulerDecorations(e, t), o = new d7();
    for (const s of r) {
      const a = s.options.overviewRuler, l = a ? a.position : 0;
      if (l === 0)
        continue;
      const u = a.getColor(i), c = this._getViewLineNumberForModelPosition(s.range.startLineNumber, s.range.startColumn), h = this._getViewLineNumberForModelPosition(s.range.endLineNumber, s.range.endColumn);
      o.accept(u, c, h, l);
    }
    return o.result;
  }
  getDecorationsInRange(e, t, i) {
    const r = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), o = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    if (o.lineNumber - r.lineNumber <= e.endLineNumber - e.startLineNumber)
      return this.model.getDecorationsInRange(new G(r.lineNumber, 1, o.lineNumber, o.column), t, i);
    let s = [];
    const a = r.lineNumber - 1, l = o.lineNumber - 1;
    let u = null;
    for (let f = a; f <= l; f++)
      if (this.lines[f].isVisible())
        u === null && (u = new ie(f + 1, f === a ? r.column : 1));
      else if (u !== null) {
        const g = this.model.getLineMaxColumn(f);
        s = s.concat(this.model.getDecorationsInRange(new G(u.lineNumber, u.column, f, g), t, i)), u = null;
      }
    u !== null && (s = s.concat(this.model.getDecorationsInRange(new G(u.lineNumber, u.column, o.lineNumber, o.column), t, i)), u = null), s.sort((f, p) => {
      const g = G.compareRangesUsingStarts(f.range, p.range);
      return g === 0 ? f.id < p.id ? -1 : f.id > p.id ? 1 : 0 : g;
    });
    let c = [], h = 0, d = null;
    for (const f of s) {
      const p = f.id;
      d !== p && (d = p, c[h++] = f);
    }
    return c;
  }
  normalizePosition(e, t) {
    const i = this._toValidViewLineNumber(e.lineNumber), r = this.prefixSumComputer.getIndexOf(i - 1), o = r.index, s = r.remainder;
    return this.lines[o].normalizePosition(this.model, o + 1, s, e, t);
  }
  getLineIndentColumn(e) {
    const t = this._toValidViewLineNumber(e), i = this.prefixSumComputer.getIndexOf(t - 1), r = i.index;
    return i.remainder === 0 ? this.model.getLineIndentColumn(r + 1) : 0;
  }
}
class Jb {
  constructor() {
  }
  isVisible() {
    return !0;
  }
  setVisible(e) {
    return e ? this : eS.INSTANCE;
  }
  getLineBreakData() {
    return null;
  }
  getViewLineCount() {
    return 1;
  }
  getViewLineContent(e, t, i) {
    return e.getLineContent(t);
  }
  getViewLineLength(e, t, i) {
    return e.getLineLength(t);
  }
  getViewLineMinColumn(e, t, i) {
    return e.getLineMinColumn(t);
  }
  getViewLineMaxColumn(e, t, i) {
    return e.getLineMaxColumn(t);
  }
  getViewLineData(e, t, i) {
    let r = e.getLineTokens(t), o = r.getLineContent();
    return new rI(o, !1, 1, o.length + 1, 0, r.inflate());
  }
  getViewLinesData(e, t, i, r, o, s, a) {
    if (!s[o]) {
      a[o] = null;
      return;
    }
    a[o] = this.getViewLineData(e, t, 0);
  }
  getModelColumnOfViewPosition(e, t) {
    return t;
  }
  getViewPositionOfModelPosition(e, t) {
    return new ie(e, t);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
  normalizePosition(e, t, i, r, o) {
    return r;
  }
}
Jb.INSTANCE = new Jb();
class eS {
  constructor() {
  }
  isVisible() {
    return !1;
  }
  setVisible(e) {
    return e ? Jb.INSTANCE : this;
  }
  getLineBreakData() {
    return null;
  }
  getViewLineCount() {
    return 0;
  }
  getViewLineContent(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineLength(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMinColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMaxColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineData(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLinesData(e, t, i, r, o, s, a) {
    throw new Error("Not supported");
  }
  getModelColumnOfViewPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewPositionOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewLineNumberOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  normalizePosition(e, t, i, r, o) {
    throw new Error("Not supported");
  }
}
eS.INSTANCE = new eS();
class Dfe {
  constructor(e, t) {
    this._lineBreakData = e, this._isVisible = t;
  }
  isVisible() {
    return this._isVisible;
  }
  setVisible(e) {
    return this._isVisible = e, this;
  }
  getLineBreakData() {
    return this._lineBreakData;
  }
  getViewLineCount() {
    return this._isVisible ? this._lineBreakData.breakOffsets.length : 0;
  }
  getInputStartOffsetOfOutputLineIndex(e) {
    return Zh.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, e, 0);
  }
  getInputEndOffsetOfOutputLineIndex(e, t, i) {
    return i + 1 === this._lineBreakData.breakOffsets.length ? e.getLineMaxColumn(t) - 1 : Zh.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, i + 1, 0);
  }
  getViewLineContent(e, t, i) {
    if (!this._isVisible)
      throw new Error("Not supported");
    let r = this.getInputStartOffsetOfOutputLineIndex(i), o = this.getInputEndOffsetOfOutputLineIndex(e, t, i), s = e.getValueInRange({
      startLineNumber: t,
      startColumn: r + 1,
      endLineNumber: t,
      endColumn: o + 1
    });
    return i > 0 && (s = dW(this._lineBreakData.wrappedTextIndentLength) + s), s;
  }
  getViewLineLength(e, t, i) {
    if (!this._isVisible)
      throw new Error("Not supported");
    let r = this.getInputStartOffsetOfOutputLineIndex(i), s = this.getInputEndOffsetOfOutputLineIndex(e, t, i) - r;
    return i > 0 && (s = this._lineBreakData.wrappedTextIndentLength + s), s;
  }
  getViewLineMinColumn(e, t, i) {
    if (!this._isVisible)
      throw new Error("Not supported");
    return this._getViewLineMinColumn(i);
  }
  _getViewLineMinColumn(e) {
    return e > 0 ? this._lineBreakData.wrappedTextIndentLength + 1 : 1;
  }
  getViewLineMaxColumn(e, t, i) {
    if (!this._isVisible)
      throw new Error("Not supported");
    return this.getViewLineLength(e, t, i) + 1;
  }
  getViewLineData(e, t, i) {
    if (!this._isVisible)
      throw new Error("Not supported");
    let r = this.getInputStartOffsetOfOutputLineIndex(i), o = this.getInputEndOffsetOfOutputLineIndex(e, t, i), s = e.getValueInRange({
      startLineNumber: t,
      startColumn: r + 1,
      endLineNumber: t,
      endColumn: o + 1
    });
    i > 0 && (s = dW(this._lineBreakData.wrappedTextIndentLength) + s);
    let a = i > 0 ? this._lineBreakData.wrappedTextIndentLength + 1 : 1, l = s.length + 1, u = i + 1 < this.getViewLineCount(), c = 0;
    i > 0 && (c = this._lineBreakData.wrappedTextIndentLength);
    let h = e.getLineTokens(t);
    const d = i === 0 ? 0 : this._lineBreakData.breakOffsetsVisibleColumn[i - 1];
    return new rI(s, u, a, l, d, h.sliceAndInflate(r, o, c));
  }
  getViewLinesData(e, t, i, r, o, s, a) {
    if (!this._isVisible)
      throw new Error("Not supported");
    for (let l = i; l < r; l++) {
      let u = o + l - i;
      if (!s[u]) {
        a[u] = null;
        continue;
      }
      a[u] = this.getViewLineData(e, t, l);
    }
  }
  getModelColumnOfViewPosition(e, t) {
    if (!this._isVisible)
      throw new Error("Not supported");
    let i = t - 1;
    return e > 0 && (i < this._lineBreakData.wrappedTextIndentLength ? i = 0 : i -= this._lineBreakData.wrappedTextIndentLength), Zh.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, e, i) + 1;
  }
  getViewPositionOfModelPosition(e, t) {
    if (!this._isVisible)
      throw new Error("Not supported");
    let i = Zh.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, t - 1), r = i.outputLineIndex, o = i.outputOffset + 1;
    return r > 0 && (o += this._lineBreakData.wrappedTextIndentLength), new ie(e + r, o);
  }
  getViewLineNumberOfModelPosition(e, t) {
    if (!this._isVisible)
      throw new Error("Not supported");
    const i = Zh.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, t - 1);
    return e + i.outputLineIndex;
  }
  normalizePosition(e, t, i, r, o) {
    if (o === 0) {
      if (i > 0 && r.column === this._getViewLineMinColumn(i))
        return new ie(r.lineNumber - 1, this.getViewLineMaxColumn(e, t, i - 1));
    } else if (o === 1) {
      const s = this.getViewLineCount() - 1;
      if (i < s && r.column === this.getViewLineMaxColumn(e, t, i))
        return new ie(r.lineNumber + 1, this._getViewLineMinColumn(i + 1));
    }
    return r;
  }
}
let XD = [""];
function dW(n) {
  if (n >= XD.length)
    for (let e = 1; e <= n; e++)
      XD[e] = Rfe(e);
  return XD[n];
}
function Rfe(n) {
  return new Array(n + 1).join(" ");
}
function ZD(n, e) {
  return n === null ? e ? Jb.INSTANCE : eS.INSTANCE : new Dfe(n, e);
}
class Tfe {
  constructor(e) {
    this._lines = e;
  }
  _validPosition(e) {
    return this._lines.model.validatePosition(e);
  }
  _validRange(e) {
    return this._lines.model.validateRange(e);
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._validPosition(e);
  }
  convertViewRangeToModelRange(e) {
    return this._validRange(e);
  }
  validateViewPosition(e, t) {
    return this._validPosition(t);
  }
  validateViewRange(e, t) {
    return this._validRange(t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e) {
    return this._validPosition(e);
  }
  convertModelRangeToViewRange(e) {
    return this._validRange(e);
  }
  modelPositionIsVisible(e) {
    const t = this._lines.model.getLineCount();
    return !(e.lineNumber < 1 || e.lineNumber > t);
  }
  getModelLineViewLineCount(e) {
    return 1;
  }
}
class Ofe {
  constructor(e) {
    this.model = e;
  }
  dispose() {
  }
  createCoordinatesConverter() {
    return new Tfe(this);
  }
  getHiddenAreas() {
    return [];
  }
  setHiddenAreas(e) {
    return !1;
  }
  setTabSize(e) {
    return !1;
  }
  setWrappingSettings(e, t, i, r) {
    return !1;
  }
  createLineBreaksComputer() {
    let e = [];
    return {
      addRequest: (t, i) => {
        e.push(null);
      },
      finalize: () => e
    };
  }
  onModelFlushed() {
  }
  onModelLinesDeleted(e, t, i) {
    return new sO(t, i);
  }
  onModelLinesInserted(e, t, i, r) {
    return new aO(t, i);
  }
  onModelLineChanged(e, t, i) {
    return [!1, new c7(t, t), null, null];
  }
  acceptVersionId(e) {
  }
  getViewLineCount() {
    return this.model.getLineCount();
  }
  getActiveIndentGuide(e, t, i) {
    return {
      startLineNumber: e,
      endLineNumber: e,
      indent: 0
    };
  }
  getViewLinesIndentGuides(e, t) {
    const i = t - e + 1;
    let r = new Array(i);
    for (let o = 0; o < i; o++)
      r[o] = 0;
    return r;
  }
  getViewLineContent(e) {
    return this.model.getLineContent(e);
  }
  getViewLineLength(e) {
    return this.model.getLineLength(e);
  }
  getViewLineMinColumn(e) {
    return this.model.getLineMinColumn(e);
  }
  getViewLineMaxColumn(e) {
    return this.model.getLineMaxColumn(e);
  }
  getViewLineData(e) {
    let t = this.model.getLineTokens(e), i = t.getLineContent();
    return new rI(i, !1, 1, i.length + 1, 0, t.inflate());
  }
  getViewLinesData(e, t, i) {
    const r = this.model.getLineCount();
    e = Math.min(Math.max(1, e), r), t = Math.min(Math.max(1, t), r);
    let o = [];
    for (let s = e; s <= t; s++) {
      let a = s - e;
      i[a] || (o[a] = null), o[a] = this.getViewLineData(s);
    }
    return o;
  }
  getAllOverviewRulerDecorations(e, t, i) {
    const r = this.model.getOverviewRulerDecorations(e, t), o = new d7();
    for (const s of r) {
      const a = s.options.overviewRuler, l = a ? a.position : 0;
      if (l === 0)
        continue;
      const u = a.getColor(i), c = s.range.startLineNumber, h = s.range.endLineNumber;
      o.accept(u, c, h, l);
    }
    return o.result;
  }
  getDecorationsInRange(e, t, i) {
    return this.model.getDecorationsInRange(e, t, i);
  }
  normalizePosition(e, t) {
    return this.model.normalizePosition(e, t);
  }
  getLineIndentColumn(e) {
    return this.model.getLineIndentColumn(e);
  }
}
class d7 {
  constructor() {
    this.result = /* @__PURE__ */ Object.create(null);
  }
  accept(e, t, i, r) {
    let o = this.result[e];
    if (o) {
      const s = o[o.length - 3], a = o[o.length - 1];
      if (s === r && a + 1 >= t) {
        i > a && (o[o.length - 1] = i);
        return;
      }
      o.push(r, t, i);
    } else
      this.result[e] = [r, t, i];
  }
}
class xfe {
  constructor(e, t, i, r, o) {
    this.editorId = e, this.model = t, this.configuration = i, this._linesCollection = r, this._coordinatesConverter = o, this._decorationsCache = /* @__PURE__ */ Object.create(null), this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  _clearCachedModelDecorationsResolver() {
    this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  dispose() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  reset() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onModelDecorationsChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onLineMappingChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  _getOrCreateViewModelDecoration(e) {
    const t = e.id;
    let i = this._decorationsCache[t];
    if (!i) {
      const r = e.range, o = e.options;
      let s;
      if (o.isWholeLine) {
        const a = this._coordinatesConverter.convertModelPositionToViewPosition(new ie(r.startLineNumber, 1)), l = this._coordinatesConverter.convertModelPositionToViewPosition(new ie(r.endLineNumber, this.model.getLineMaxColumn(r.endLineNumber)));
        s = new G(a.lineNumber, a.column, l.lineNumber, l.column);
      } else
        s = this._coordinatesConverter.convertModelRangeToViewRange(r);
      i = new X5(s, o), this._decorationsCache[t] = i;
    }
    return i;
  }
  getDecorationsViewportData(e) {
    let t = this._cachedModelDecorationsResolver !== null;
    return t = t && e.equalsRange(this._cachedModelDecorationsResolverViewRange), t || (this._cachedModelDecorationsResolver = this._getDecorationsViewportData(e), this._cachedModelDecorationsResolverViewRange = e), this._cachedModelDecorationsResolver;
  }
  _getDecorationsViewportData(e) {
    const t = this._linesCollection.getDecorationsInRange(e, this.editorId, TN(this.configuration.options)), i = e.startLineNumber, r = e.endLineNumber;
    let o = [], s = 0, a = [];
    for (let l = i; l <= r; l++)
      a[l - i] = [];
    for (let l = 0, u = t.length; l < u; l++) {
      let c = t[l], h = c.options, d = this._getOrCreateViewModelDecoration(c), f = d.range;
      if (o[s++] = d, h.inlineClassName) {
        let p = new cw(
          f,
          h.inlineClassName,
          h.inlineClassNameAffectsLetterSpacing ? 3 : 0
          /* Regular */
        ), g = Math.max(i, f.startLineNumber), _ = Math.min(r, f.endLineNumber);
        for (let m = g; m <= _; m++)
          a[m - i].push(p);
      }
      if (h.beforeContentClassName && i <= f.startLineNumber && f.startLineNumber <= r) {
        let p = new cw(
          new G(f.startLineNumber, f.startColumn, f.startLineNumber, f.startColumn),
          h.beforeContentClassName,
          1
          /* Before */
        );
        a[f.startLineNumber - i].push(p);
      }
      if (h.afterContentClassName && i <= f.endLineNumber && f.endLineNumber <= r) {
        let p = new cw(
          new G(f.endLineNumber, f.endColumn, f.endLineNumber, f.endColumn),
          h.afterContentClassName,
          2
          /* After */
        );
        a[f.endLineNumber - i].push(p);
      }
    }
    return {
      decorations: o,
      inlineDecorations: a
    };
  }
}
class Nfe extends Ce {
  constructor(e, t, i, r, o, s) {
    if (super(), this._editorId = e, this._configuration = t, this.model = i, this._eventDispatcher = new hfe(), this.onEvent = this._eventDispatcher.onEvent, this.cursorConfig = new aa(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration), this._tokenizeViewportSoon = this._register(new ro(() => this.tokenizeViewport(), 50)), this._updateConfigurationViewLineCount = this._register(new ro(() => this._updateConfigurationViewLineCountNow(), 0)), this._hasFocus = !1, this._viewportStartLine = -1, this._viewportStartLineTrackedRange = null, this._viewportStartLineDelta = 0, this.model.isTooLargeForTokenization())
      this._lines = new Ofe(this.model);
    else {
      const a = this._configuration.options, l = a.get(
        40
        /* fontInfo */
      ), u = a.get(
        122
        /* wrappingStrategy */
      ), c = a.get(
        129
        /* wrappingInfo */
      ), h = a.get(
        121
        /* wrappingIndent */
      );
      this._lines = new Lfe(this.model, r, o, l, this.model.getOptions().tabSize, u, c.wrappingColumn, h);
    }
    this.coordinatesConverter = this._lines.createCoordinatesConverter(), this._cursor = this._register(new ag(i, this, this.coordinatesConverter, this.cursorConfig)), this.viewLayout = this._register(new bfe(this._configuration, this.getLineCount(), s)), this._register(this.viewLayout.onDidScroll((a) => {
      a.scrollTopChanged && this._tokenizeViewportSoon.schedule(), this._eventDispatcher.emitSingleViewEvent(new sfe(a)), this._eventDispatcher.emitOutgoingEvent(new NI(a.oldScrollWidth, a.oldScrollLeft, a.oldScrollHeight, a.oldScrollTop, a.scrollWidth, a.scrollLeft, a.scrollHeight, a.scrollTop));
    })), this._register(this.viewLayout.onDidContentSizeChange((a) => {
      this._eventDispatcher.emitOutgoingEvent(a);
    })), this._decorations = new xfe(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter), this._registerModelEvents(), this._register(this._configuration.onDidChangeFast((a) => {
      try {
        const l = this._eventDispatcher.beginEmitViewEvents();
        this._onConfigurationChanged(l, a);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    })), this._register(Q_.getInstance().onDidChange(() => {
      this._eventDispatcher.emitSingleViewEvent(new ufe());
    })), this._updateConfigurationViewLineCountNow();
  }
  dispose() {
    super.dispose(), this._decorations.dispose(), this._lines.dispose(), this.invalidateMinimapColorCache(), this._viewportStartLineTrackedRange = this.model._setTrackedRange(
      this._viewportStartLineTrackedRange,
      null,
      1
      /* NeverGrowsWhenTypingAtEdges */
    ), this._eventDispatcher.dispose();
  }
  createLineBreaksComputer() {
    return this._lines.createLineBreaksComputer();
  }
  addViewEventHandler(e) {
    this._eventDispatcher.addViewEventHandler(e);
  }
  removeViewEventHandler(e) {
    this._eventDispatcher.removeViewEventHandler(e);
  }
  _updateConfigurationViewLineCountNow() {
    this._configuration.setViewLineCount(this._lines.getViewLineCount());
  }
  tokenizeViewport() {
    const e = this.viewLayout.getLinesViewportData(), t = this.coordinatesConverter.convertViewPositionToModelPosition(new ie(e.startLineNumber, 1)), i = this.coordinatesConverter.convertViewPositionToModelPosition(new ie(e.endLineNumber, 1));
    this.model.tokenizeViewport(t.lineNumber, i.lineNumber);
  }
  setHasFocus(e) {
    this._hasFocus = e, this._cursor.setHasFocus(e), this._eventDispatcher.emitSingleViewEvent(new rfe(e)), this._eventDispatcher.emitOutgoingEvent(new xI(!e, e));
  }
  onCompositionStart() {
    this._eventDispatcher.emitSingleViewEvent(new efe());
  }
  onCompositionEnd() {
    this._eventDispatcher.emitSingleViewEvent(new tfe());
  }
  onDidColorThemeChange() {
    this._eventDispatcher.emitSingleViewEvent(new afe());
  }
  _onConfigurationChanged(e, t) {
    let i = null;
    if (this._viewportStartLine !== -1) {
      let c = new ie(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));
      i = this.coordinatesConverter.convertViewPositionToModelPosition(c);
    }
    let r = !1;
    const o = this._configuration.options, s = o.get(
      40
      /* fontInfo */
    ), a = o.get(
      122
      /* wrappingStrategy */
    ), l = o.get(
      129
      /* wrappingInfo */
    ), u = o.get(
      121
      /* wrappingIndent */
    );
    if (this._lines.setWrappingSettings(s, a, l.wrappingColumn, u) && (e.emitViewEvent(new Ny()), e.emitViewEvent(new Iy()), e.emitViewEvent(new Uf(null)), this._cursor.onLineMappingChanged(e), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.getCurrentScrollTop() !== 0 && (r = !0), this._updateConfigurationViewLineCount.schedule()), t.hasChanged(
      78
      /* readOnly */
    ) && (this._decorations.reset(), e.emitViewEvent(new Uf(null))), e.emitViewEvent(new ife(t)), this.viewLayout.onConfigurationChanged(t), r && i) {
      const c = this.coordinatesConverter.convertModelPositionToViewPosition(i), h = this.viewLayout.getVerticalOffsetForLineNumber(c.lineNumber);
      this.viewLayout.setScrollPosition(
        { scrollTop: h + this._viewportStartLineDelta },
        1
        /* Immediate */
      );
    }
    aa.shouldRecreate(t) && (this.cursorConfig = new aa(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration), this._cursor.updateConfiguration(this.cursorConfig));
  }
  _registerModelEvents() {
    this._register(this.model.onDidChangeRawContentFast((e) => {
      try {
        const t = this._eventDispatcher.beginEmitViewEvents();
        let i = !1, r = !1;
        const o = e.changes, s = e.versionId, a = this._lines.createLineBreaksComputer();
        for (const c of o)
          switch (c.changeType) {
            case 4: {
              for (const h of c.detail)
                a.addRequest(h, null);
              break;
            }
            case 2: {
              a.addRequest(c.detail, null);
              break;
            }
          }
        const l = a.finalize();
        let u = 0;
        for (const c of o)
          switch (c.changeType) {
            case 1: {
              this._lines.onModelFlushed(), t.emitViewEvent(new Ny()), this._decorations.reset(), this.viewLayout.onFlushed(this.getLineCount()), i = !0;
              break;
            }
            case 3: {
              const h = this._lines.onModelLinesDeleted(s, c.fromLineNumber, c.toLineNumber);
              h !== null && (t.emitViewEvent(h), this.viewLayout.onLinesDeleted(h.fromLineNumber, h.toLineNumber)), i = !0;
              break;
            }
            case 4: {
              const h = l.slice(u, u + c.detail.length);
              u += c.detail.length;
              const d = this._lines.onModelLinesInserted(s, c.fromLineNumber, c.toLineNumber, h);
              d !== null && (t.emitViewEvent(d), this.viewLayout.onLinesInserted(d.fromLineNumber, d.toLineNumber)), i = !0;
              break;
            }
            case 2: {
              const h = l[u];
              u++;
              const [d, f, p, g] = this._lines.onModelLineChanged(s, c.lineNumber, h);
              r = d, f && t.emitViewEvent(f), p && (t.emitViewEvent(p), this.viewLayout.onLinesInserted(p.fromLineNumber, p.toLineNumber)), g && (t.emitViewEvent(g), this.viewLayout.onLinesDeleted(g.fromLineNumber, g.toLineNumber));
              break;
            }
            case 5:
              break;
          }
        this._lines.acceptVersionId(s), this.viewLayout.onHeightMaybeChanged(), !i && r && (t.emitViewEvent(new Iy()), t.emitViewEvent(new Uf(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged());
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      if (this._viewportStartLine = -1, this._configuration.setMaxLineNumber(this.model.getLineCount()), this._updateConfigurationViewLineCountNow(), !this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {
        const t = this.model._getTrackedRange(this._viewportStartLineTrackedRange);
        if (t) {
          const i = this.coordinatesConverter.convertModelPositionToViewPosition(t.getStartPosition()), r = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber);
          this.viewLayout.setScrollPosition(
            { scrollTop: r + this._viewportStartLineDelta },
            1
            /* Immediate */
          );
        }
      }
      try {
        const t = this._eventDispatcher.beginEmitViewEvents();
        this._cursor.onModelContentChanged(t, e);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    })), this._register(this.model.onDidChangeTokens((e) => {
      let t = [];
      for (let i = 0, r = e.ranges.length; i < r; i++) {
        const o = e.ranges[i], s = this.coordinatesConverter.convertModelPositionToViewPosition(new ie(o.fromLineNumber, 1)).lineNumber, a = this.coordinatesConverter.convertModelPositionToViewPosition(new ie(o.toLineNumber, this.model.getLineMaxColumn(o.toLineNumber))).lineNumber;
        t[i] = {
          fromLineNumber: s,
          toLineNumber: a
        };
      }
      this._eventDispatcher.emitSingleViewEvent(new lfe(t)), e.tokenizationSupportChanged && this._tokenizeViewportSoon.schedule();
    })), this._register(this.model.onDidChangeLanguageConfiguration((e) => {
      this._eventDispatcher.emitSingleViewEvent(new ofe()), this.cursorConfig = new aa(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration), this._cursor.updateConfiguration(this.cursorConfig);
    })), this._register(this.model.onDidChangeLanguage((e) => {
      this.cursorConfig = new aa(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration), this._cursor.updateConfiguration(this.cursorConfig);
    })), this._register(this.model.onDidChangeOptions((e) => {
      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {
        try {
          const t = this._eventDispatcher.beginEmitViewEvents();
          t.emitViewEvent(new Ny()), t.emitViewEvent(new Iy()), t.emitViewEvent(new Uf(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount());
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        this._updateConfigurationViewLineCount.schedule();
      }
      this.cursorConfig = new aa(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration), this._cursor.updateConfiguration(this.cursorConfig);
    })), this._register(this.model.onDidChangeDecorations((e) => {
      this._decorations.onModelDecorationsChanged(), this._eventDispatcher.emitSingleViewEvent(new Uf(e));
    }));
  }
  setHiddenAreas(e) {
    try {
      const t = this._eventDispatcher.beginEmitViewEvents();
      this._lines.setHiddenAreas(e) && (t.emitViewEvent(new Ny()), t.emitViewEvent(new Iy()), t.emitViewEvent(new Uf(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.onHeightMaybeChanged());
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
    this._updateConfigurationViewLineCount.schedule();
  }
  getVisibleRangesPlusViewportAboveBelow() {
    const e = this._configuration.options.get(
      128
      /* layoutInfo */
    ), t = this._configuration.options.get(
      56
      /* lineHeight */
    ), i = Math.max(20, Math.round(e.height / t)), r = this.viewLayout.getLinesViewportData(), o = Math.max(1, r.completelyVisibleStartLineNumber - i), s = Math.min(this.getLineCount(), r.completelyVisibleEndLineNumber + i);
    return this._toModelVisibleRanges(new G(o, this.getLineMinColumn(o), s, this.getLineMaxColumn(s)));
  }
  getVisibleRanges() {
    const e = this.getCompletelyVisibleViewRange();
    return this._toModelVisibleRanges(e);
  }
  _toModelVisibleRanges(e) {
    const t = this.coordinatesConverter.convertViewRangeToModelRange(e), i = this._lines.getHiddenAreas();
    if (i.length === 0)
      return [t];
    let r = [], o = 0, s = t.startLineNumber, a = t.startColumn, l = t.endLineNumber, u = t.endColumn;
    for (let c = 0, h = i.length; c < h; c++) {
      const d = i[c].startLineNumber, f = i[c].endLineNumber;
      f < s || d > l || (s < d && (r[o++] = new G(s, a, d - 1, this.model.getLineMaxColumn(d - 1))), s = f + 1, a = 1);
    }
    return (s < l || s === l && a < u) && (r[o++] = new G(s, a, l, u)), r;
  }
  getCompletelyVisibleViewRange() {
    const e = this.viewLayout.getLinesViewportData(), t = e.completelyVisibleStartLineNumber, i = e.completelyVisibleEndLineNumber;
    return new G(t, this.getLineMinColumn(t), i, this.getLineMaxColumn(i));
  }
  getCompletelyVisibleViewRangeAtScrollTop(e) {
    const t = this.viewLayout.getLinesViewportDataAtScrollTop(e), i = t.completelyVisibleStartLineNumber, r = t.completelyVisibleEndLineNumber;
    return new G(i, this.getLineMinColumn(i), r, this.getLineMaxColumn(r));
  }
  saveState() {
    const e = this.viewLayout.saveState(), t = e.scrollTop, i = this.viewLayout.getLineNumberAtVerticalOffset(t), r = this.coordinatesConverter.convertViewPositionToModelPosition(new ie(i, this.getLineMinColumn(i))), o = this.viewLayout.getVerticalOffsetForLineNumber(i) - t;
    return {
      scrollLeft: e.scrollLeft,
      firstPosition: r,
      firstPositionDeltaTop: o
    };
  }
  reduceRestoreState(e) {
    if (typeof e.firstPosition > "u")
      return this._reduceRestoreStateCompatibility(e);
    const t = this.model.validatePosition(e.firstPosition), i = this.coordinatesConverter.convertModelPositionToViewPosition(t), r = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber) - e.firstPositionDeltaTop;
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: r
    };
  }
  _reduceRestoreStateCompatibility(e) {
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTopWithoutViewZones
    };
  }
  getTabSize() {
    return this.model.getOptions().tabSize;
  }
  getTextModelOptions() {
    return this.model.getOptions();
  }
  getLineCount() {
    return this._lines.getViewLineCount();
  }
  /**
   * Gives a hint that a lot of requests are about to come in for these line numbers.
   */
  setViewport(e, t, i) {
    this._viewportStartLine = e;
    let r = this.coordinatesConverter.convertViewPositionToModelPosition(new ie(e, this.getLineMinColumn(e)));
    this._viewportStartLineTrackedRange = this.model._setTrackedRange(
      this._viewportStartLineTrackedRange,
      new G(r.lineNumber, r.column, r.lineNumber, r.column),
      1
      /* NeverGrowsWhenTypingAtEdges */
    );
    const o = this.viewLayout.getVerticalOffsetForLineNumber(e), s = this.viewLayout.getCurrentScrollTop();
    this._viewportStartLineDelta = s - o;
  }
  getActiveIndentGuide(e, t, i) {
    return this._lines.getActiveIndentGuide(e, t, i);
  }
  getLinesIndentGuides(e, t) {
    return this._lines.getViewLinesIndentGuides(e, t);
  }
  getLineContent(e) {
    return this._lines.getViewLineContent(e);
  }
  getLineLength(e) {
    return this._lines.getViewLineLength(e);
  }
  getLineMinColumn(e) {
    return this._lines.getViewLineMinColumn(e);
  }
  getLineMaxColumn(e) {
    return this._lines.getViewLineMaxColumn(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = Os(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = Ng(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  getDecorationsInViewport(e) {
    return this._decorations.getDecorationsViewportData(e).decorations;
  }
  getViewLineRenderingData(e, t) {
    let i = this.model.mightContainRTL(), r = this.model.mightContainNonBasicASCII(), o = this.getTabSize(), s = this._lines.getViewLineData(t), l = this._decorations.getDecorationsViewportData(e).inlineDecorations[t - e.startLineNumber];
    return new Yo(s.minColumn, s.maxColumn, s.content, s.continuesWithWrappedLine, i, r, s.tokens, l, o, s.startVisibleColumn);
  }
  getViewLineData(e) {
    return this._lines.getViewLineData(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    let r = this._lines.getViewLinesData(e, t, i);
    return new Tae(this.getTabSize(), r);
  }
  getAllOverviewRulerDecorations(e) {
    return this._lines.getAllOverviewRulerDecorations(this._editorId, TN(this._configuration.options), e);
  }
  invalidateOverviewRulerColorCache() {
    const e = this.model.getOverviewRulerDecorations();
    for (const t of e) {
      const i = t.options.overviewRuler;
      i && i.invalidateCachedColor();
    }
  }
  invalidateMinimapColorCache() {
    const e = this.model.getAllDecorations();
    for (const t of e) {
      const i = t.options.minimap;
      i && i.invalidateCachedColor();
    }
  }
  getValueInRange(e, t) {
    const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
    return this.model.getValueInRange(i, t);
  }
  getModelLineMaxColumn(e) {
    return this.model.getLineMaxColumn(e);
  }
  validateModelPosition(e) {
    return this.model.validatePosition(e);
  }
  validateModelRange(e) {
    return this.model.validateRange(e);
  }
  deduceModelPositionRelativeToViewPosition(e, t, i) {
    const r = this.coordinatesConverter.convertViewPositionToModelPosition(e);
    this.model.getEOL().length === 2 && (t < 0 ? t -= i : t += i);
    const s = this.model.getOffsetAt(r) + t;
    return this.model.getPositionAt(s);
  }
  getEOL() {
    return this.model.getEOL();
  }
  getPlainTextToCopy(e, t, i) {
    const r = i ? `\r
` : this.model.getEOL();
    e = e.slice(0), e.sort(G.compareRangesUsingStarts);
    let o = !1, s = !1;
    for (const l of e)
      l.isEmpty() ? o = !0 : s = !0;
    if (!s) {
      if (!t)
        return "";
      const l = e.map((c) => c.startLineNumber);
      let u = "";
      for (let c = 0; c < l.length; c++)
        c > 0 && l[c - 1] === l[c] || (u += this.model.getLineContent(l[c]) + r);
      return u;
    }
    if (o && t) {
      let l = [], u = 0;
      for (const c of e) {
        const h = c.startLineNumber;
        c.isEmpty() ? h !== u && l.push(this.model.getLineContent(h)) : l.push(this.model.getValueInRange(
          c,
          i ? 2 : 0
          /* TextDefined */
        )), u = h;
      }
      return l.length === 1 ? l[0] : l;
    }
    let a = [];
    for (const l of e)
      l.isEmpty() || a.push(this.model.getValueInRange(
        l,
        i ? 2 : 0
        /* TextDefined */
      ));
    return a.length === 1 ? a[0] : a;
  }
  getRichTextToCopy(e, t) {
    const i = this.model.getLanguageIdentifier();
    if (i.id === 1 || e.length !== 1)
      return null;
    let r = e[0];
    if (r.isEmpty()) {
      if (!t)
        return null;
      const c = r.startLineNumber;
      r = new G(c, this.model.getLineMinColumn(c), c, this.model.getLineMaxColumn(c));
    }
    const o = this._configuration.options.get(
      40
      /* fontInfo */
    ), s = this._getColorMap(), l = /[:;\\\/<>]/.test(o.fontFamily) || o.fontFamily === Ts.fontFamily;
    let u;
    return l ? u = Ts.fontFamily : (u = o.fontFamily, u = u.replace(/"/g, "'"), /[,']/.test(u) || /[+ ]/.test(u) && (u = `'${u}'`), u = `${u}, ${Ts.fontFamily}`), {
      mode: i.language,
      html: `<div style="color: ${s[
        1
        /* DefaultForeground */
      ]};background-color: ${s[
        2
        /* DefaultBackground */
      ]};font-family: ${u};font-weight: ${o.fontWeight};font-size: ${o.fontSize}px;line-height: ${o.lineHeight}px;white-space: pre;">` + this._getHTMLToCopy(r, s) + "</div>"
    };
  }
  _getHTMLToCopy(e, t) {
    const i = e.startLineNumber, r = e.startColumn, o = e.endLineNumber, s = e.endColumn, a = this.getTabSize();
    let l = "";
    for (let u = i; u <= o; u++) {
      const c = this.model.getLineTokens(u), h = c.getLineContent(), d = u === i ? r - 1 : 0, f = u === o ? s - 1 : h.length;
      h === "" ? l += "<br>" : l += mfe(h, c.inflate(), t, d, f, a, Ro);
    }
    return l;
  }
  _getColorMap() {
    let e = cn.getColorMap(), t = ["#000000"];
    if (e)
      for (let i = 1, r = e.length; i < r; i++)
        t[i] = ne.Format.CSS.formatHex(e[i]);
    return t;
  }
  //#region model
  pushStackElement() {
    this.model.pushStackElement();
  }
  //#endregion
  //#region cursor operations
  getPrimaryCursorState() {
    return this._cursor.getPrimaryCursorState();
  }
  getLastAddedCursorIndex() {
    return this._cursor.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursor.getCursorStates();
  }
  setCursorStates(e, t, i) {
    this._withViewEventsCollector((r) => this._cursor.setStates(r, e, t, i));
  }
  getCursorColumnSelectData() {
    return this._cursor.getCursorColumnSelectData();
  }
  getCursorAutoClosedCharacters() {
    return this._cursor.getAutoClosedCharacters();
  }
  setCursorColumnSelectData(e) {
    this._cursor.setCursorColumnSelectData(e);
  }
  getPrevEditOperationType() {
    return this._cursor.getPrevEditOperationType();
  }
  setPrevEditOperationType(e) {
    this._cursor.setPrevEditOperationType(e);
  }
  getSelection() {
    return this._cursor.getSelection();
  }
  getSelections() {
    return this._cursor.getSelections();
  }
  getPosition() {
    return this._cursor.getPrimaryCursorState().modelState.position;
  }
  setSelections(e, t, i = 0) {
    this._withViewEventsCollector((r) => this._cursor.setSelections(r, e, t, i));
  }
  saveCursorState() {
    return this._cursor.saveState();
  }
  restoreCursorState(e) {
    this._withViewEventsCollector((t) => this._cursor.restoreState(t, e));
  }
  _executeCursorEdit(e) {
    if (this._cursor.context.cursorConfig.readOnly) {
      this._eventDispatcher.emitOutgoingEvent(new pfe());
      return;
    }
    this._withViewEventsCollector(e);
  }
  executeEdits(e, t, i) {
    this._executeCursorEdit((r) => this._cursor.executeEdits(r, e, t, i));
  }
  startComposition() {
    this._cursor.setIsDoingComposition(!0), this._executeCursorEdit((e) => this._cursor.startComposition(e));
  }
  endComposition(e) {
    this._cursor.setIsDoingComposition(!1), this._executeCursorEdit((t) => this._cursor.endComposition(t, e));
  }
  type(e, t) {
    this._executeCursorEdit((i) => this._cursor.type(i, e, t));
  }
  compositionType(e, t, i, r, o) {
    this._executeCursorEdit((s) => this._cursor.compositionType(s, e, t, i, r, o));
  }
  paste(e, t, i, r) {
    this._executeCursorEdit((o) => this._cursor.paste(o, e, t, i, r));
  }
  cut(e) {
    this._executeCursorEdit((t) => this._cursor.cut(t, e));
  }
  executeCommand(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommand(i, e, t));
  }
  executeCommands(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommands(i, e, t));
  }
  revealPrimaryCursor(e, t) {
    this._withViewEventsCollector((i) => this._cursor.revealPrimary(
      i,
      e,
      t,
      0
      /* Smooth */
    ));
  }
  revealTopMostCursor(e) {
    const t = this._cursor.getTopMostViewPosition(), i = new G(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((r) => r.emitViewEvent(new _w(
      e,
      i,
      null,
      0,
      !0,
      0
      /* Smooth */
    )));
  }
  revealBottomMostCursor(e) {
    const t = this._cursor.getBottomMostViewPosition(), i = new G(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((r) => r.emitViewEvent(new _w(
      e,
      i,
      null,
      0,
      !0,
      0
      /* Smooth */
    )));
  }
  revealRange(e, t, i, r, o) {
    this._withViewEventsCollector((s) => s.emitViewEvent(new _w(e, i, null, r, t, o)));
  }
  //#endregion
  //#region viewLayout
  getVerticalOffsetForLineNumber(e) {
    return this.viewLayout.getVerticalOffsetForLineNumber(e);
  }
  getScrollTop() {
    return this.viewLayout.getCurrentScrollTop();
  }
  setScrollTop(e, t) {
    this.viewLayout.setScrollPosition({ scrollTop: e }, t);
  }
  setScrollPosition(e, t) {
    this.viewLayout.setScrollPosition(e, t);
  }
  deltaScrollNow(e, t) {
    this.viewLayout.deltaScrollNow(e, t);
  }
  changeWhitespace(e) {
    this.viewLayout.changeWhitespace(e) && (this._eventDispatcher.emitSingleViewEvent(new cfe()), this._eventDispatcher.emitOutgoingEvent(new ffe()));
  }
  setMaxLineWidth(e) {
    this.viewLayout.setMaxLineWidth(e);
  }
  //#endregion
  _withViewEventsCollector(e) {
    try {
      const t = this._eventDispatcher.beginEmitViewEvents();
      e(t);
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
  }
  normalizePosition(e, t) {
    return this._lines.normalizePosition(e, t);
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return this._lines.getLineIndentColumn(e);
  }
}
class f_ {
  constructor(...e) {
    this._entries = /* @__PURE__ */ new Map();
    for (let [t, i] of e)
      this.set(t, i);
  }
  set(e, t) {
    const i = this._entries.get(e);
    return this._entries.set(e, t), i;
  }
  has(e) {
    return this._entries.has(e);
  }
  get(e) {
    return this._entries.get(e);
  }
}
const ks = Vt("accessibilityService"), Ife = new nt("accessibilityModeEnabled", !1);
class Pfe extends Ig {
  constructor(e, t) {
    super(
      0
      /* NONE */
    );
    for (let i = 0; i < e.length; i++)
      this.set(
        e.charCodeAt(i),
        1
        /* BREAK_BEFORE */
      );
    for (let i = 0; i < t.length; i++)
      this.set(
        t.charCodeAt(i),
        2
        /* BREAK_AFTER */
      );
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : e >= 12352 && e <= 12543 || e >= 13312 && e <= 19903 || e >= 19968 && e <= 40959 ? 3 : this._map.get(e) || this._defaultValue;
  }
}
let lO = [], uO = [];
class II {
  constructor(e, t) {
    this.classifier = new Pfe(e, t);
  }
  static create(e) {
    return new II(e.get(
      117
      /* wordWrapBreakBeforeCharacters */
    ), e.get(
      116
      /* wordWrapBreakAfterCharacters */
    ));
  }
  createLineBreaksComputer(e, t, i, r) {
    t = t | 0, i = +i;
    let o = [], s = [];
    return {
      addRequest: (a, l) => {
        o.push(a), s.push(l);
      },
      finalize: () => {
        const a = e.typicalFullwidthCharacterWidth / e.typicalHalfwidthCharacterWidth;
        let l = [];
        for (let u = 0, c = o.length; u < c; u++) {
          const h = s[u];
          h ? l[u] = Afe(this.classifier, h, o[u], t, i, a, r) : l[u] = Mfe(this.classifier, o[u], t, i, a, r);
        }
        return lO.length = 0, uO.length = 0, l;
      }
    };
  }
}
function Afe(n, e, t, i, r, o, s) {
  if (r === -1)
    return null;
  const a = t.length;
  if (a <= 1)
    return null;
  const l = e.breakOffsets, u = e.breakOffsetsVisibleColumn, c = f7(t, i, r, o, s), h = r - c;
  let d = lO, f = uO, p = 0, g = 0, _ = 0, m = r;
  const v = l.length;
  let C = 0;
  if (C >= 0) {
    let y = Math.abs(u[C] - m);
    for (; C + 1 < v; ) {
      const w = Math.abs(u[C + 1] - m);
      if (w >= y)
        break;
      y = w, C++;
    }
  }
  for (; C < v; ) {
    let y = C < 0 ? 0 : l[C], w = C < 0 ? 0 : u[C];
    g > y && (y = g, w = _);
    let L = 0, S = 0, E = 0, D = 0;
    if (w <= m) {
      let R = w, A = y === 0 ? 0 : t.charCodeAt(y - 1), M = y === 0 ? 0 : n.get(A), z = !0;
      for (let j = y; j < a; j++) {
        const $ = j, k = t.charCodeAt(j);
        let ae, re;
        if (Kn(k) ? (j++, ae = 0, re = 2) : (ae = n.get(k), re = Rv(k, R, i, o)), $ > g && cO(A, M, k, ae) && (L = $, S = R), R += re, R > m) {
          $ > g ? (E = $, D = R - re) : (E = j + 1, D = R), R - S > h && (L = 0), z = !1;
          break;
        }
        A = k, M = ae;
      }
      if (z) {
        p > 0 && (d[p] = l[l.length - 1], f[p] = u[l.length - 1], p++);
        break;
      }
    }
    if (L === 0) {
      let R = w, A = t.charCodeAt(y), M = n.get(A), z = !1;
      for (let j = y - 1; j >= g; j--) {
        const $ = j + 1, k = t.charCodeAt(j);
        if (k === 9) {
          z = !0;
          break;
        }
        let ae, re;
        if (Yv(k) ? (j--, ae = 0, re = 2) : (ae = n.get(k), re = el(k) ? o : 1), R <= m) {
          if (E === 0 && (E = $, D = R), R <= m - h)
            break;
          if (cO(k, ae, A, M)) {
            L = $, S = R;
            break;
          }
        }
        R -= re, A = k, M = ae;
      }
      if (L !== 0) {
        const j = h - (D - S);
        if (j <= i) {
          const $ = t.charCodeAt(E);
          let k;
          Kn($) ? k = 2 : k = Rv($, D, i, o), j - k < 0 && (L = 0);
        }
      }
      if (z) {
        C--;
        continue;
      }
    }
    if (L === 0 && (L = E, S = D), L <= g) {
      const R = t.charCodeAt(g);
      Kn(R) ? (L = g + 2, S = _ + 2) : (L = g + 1, S = _ + Rv(R, _, i, o));
    }
    for (g = L, d[p] = L, _ = S, f[p] = S, p++, m = S + h; C < 0 || C < v && u[C] < S; )
      C++;
    let x = Math.abs(u[C] - m);
    for (; C + 1 < v; ) {
      const R = Math.abs(u[C + 1] - m);
      if (R >= x)
        break;
      x = R, C++;
    }
  }
  return p === 0 ? null : (d.length = p, f.length = p, lO = e.breakOffsets, uO = e.breakOffsetsVisibleColumn, e.breakOffsets = d, e.breakOffsetsVisibleColumn = f, e.wrappedTextIndentLength = c, e);
}
function Mfe(n, e, t, i, r, o) {
  if (i === -1)
    return null;
  const s = e.length;
  if (s <= 1)
    return null;
  const a = f7(e, t, i, r, o), l = i - a;
  let u = [], c = [], h = 0, d = 0, f = 0, p = i, g = e.charCodeAt(0), _ = n.get(g), m = Rv(g, 0, t, r), v = 1;
  Kn(g) && (m += 1, g = e.charCodeAt(1), _ = n.get(g), v++);
  for (let C = v; C < s; C++) {
    const y = C, w = e.charCodeAt(C);
    let L, S;
    Kn(w) ? (C++, L = 0, S = 2) : (L = n.get(w), S = Rv(w, m, t, r)), cO(g, _, w, L) && (d = y, f = m), m += S, m > p && ((d === 0 || m - f > l) && (d = y, f = m - S), u[h] = d, c[h] = f, h++, p = f + l, d = 0), g = w, _ = L;
  }
  return h === 0 ? null : (u[h] = s, c[h] = m, new Zh(u, c, a));
}
function Rv(n, e, t, i) {
  return n === 9 ? t - e % t : el(n) || n < 32 ? i : 1;
}
function fW(n, e) {
  return e - n % e;
}
function cO(n, e, t, i) {
  return t !== 32 && (e === 2 || e === 3 && i !== 2 || i === 1 || i === 3 && e !== 1);
}
function f7(n, e, t, i, r) {
  let o = 0;
  if (r !== 0) {
    const s = Os(n);
    if (s !== -1) {
      for (let l = 0; l < s; l++) {
        const u = n.charCodeAt(l) === 9 ? fW(o, e) : 1;
        o += u;
      }
      const a = r === 3 ? 2 : r === 2 ? 1 : 0;
      for (let l = 0; l < a; l++) {
        const u = fW(o, e);
        o += u;
      }
      o + i > t && (o = 0);
    }
  }
  return o;
}
var QD;
const JD = (QD = window.trustedTypes) === null || QD === void 0 ? void 0 : QD.createPolicy("domLineBreaksComputer", { createHTML: (n) => n });
class PI {
  static create() {
    return new PI();
  }
  constructor() {
  }
  createLineBreaksComputer(e, t, i, r) {
    t = t | 0, i = +i;
    let o = [];
    return {
      addRequest: (s, a) => {
        o.push(s);
      },
      finalize: () => Ffe(o, e, t, i, r)
    };
  }
}
function Ffe(n, e, t, i, r) {
  var o;
  if (i === -1) {
    const C = [];
    for (let y = 0, w = n.length; y < w; y++)
      C[y] = null;
    return C;
  }
  const s = Math.round(i * e.typicalHalfwidthCharacterWidth);
  (r === 2 || r === 3) && (r = 1);
  const a = document.createElement("div");
  oo.applyFontInfoSlow(a, e);
  const l = eg(1e4), u = [], c = [], h = [], d = [], f = [];
  for (let C = 0; C < n.length; C++) {
    const y = n[C];
    let w = 0, L = 0, S = s;
    if (r !== 0)
      if (w = Os(y), w === -1)
        w = 0;
      else {
        for (let R = 0; R < w; R++) {
          const A = y.charCodeAt(R) === 9 ? t - L % t : 1;
          L += A;
        }
        const x = Math.ceil(e.spaceWidth * L);
        x + e.typicalFullwidthCharacterWidth > s ? (w = 0, L = 0) : S = s - x;
      }
    const E = y.substr(w), D = kfe(E, L, t, S, l);
    u[C] = w, c[C] = L, h[C] = E, d[C] = D[0], f[C] = D[1];
  }
  const p = l.build(), g = (o = JD == null ? void 0 : JD.createHTML(p)) !== null && o !== void 0 ? o : p;
  a.innerHTML = g, a.style.position = "absolute", a.style.top = "10000", a.style.wordWrap = "break-word", document.body.appendChild(a);
  let _ = document.createRange();
  const m = Array.prototype.slice.call(a.children, 0);
  let v = [];
  for (let C = 0; C < n.length; C++) {
    const y = m[C], w = Wfe(_, y, h[C], d[C]);
    if (w === null) {
      v[C] = null;
      continue;
    }
    const L = u[C], S = c[C], E = f[C], D = [];
    for (let x = 0, R = w.length; x < R; x++)
      D[x] = E[w[x]];
    if (L !== 0)
      for (let x = 0, R = w.length; x < R; x++)
        w[x] += L;
    v[C] = new Zh(w, D, S);
  }
  return document.body.removeChild(a), v;
}
function kfe(n, e, t, i, r) {
  r.appendASCIIString('<div style="width:'), r.appendASCIIString(String(i)), r.appendASCIIString('px;">');
  const o = n.length;
  let s = e, a = 0, l = [], u = [], c = 0 < o ? n.charCodeAt(0) : 0;
  r.appendASCIIString("<span>");
  for (let h = 0; h < o; h++) {
    h !== 0 && h % 16384 === 0 && r.appendASCIIString("</span><span>"), l[h] = a, u[h] = s;
    const d = c;
    c = h + 1 < o ? n.charCodeAt(h + 1) : 0;
    let f = 1, p = 1;
    switch (d) {
      case 9:
        f = t - s % t, p = f;
        for (let g = 1; g <= f; g++)
          g < f ? r.write1(160) : r.appendASCII(
            32
            /* Space */
          );
        break;
      case 32:
        c === 32 ? r.write1(160) : r.appendASCII(
          32
          /* Space */
        );
        break;
      case 60:
        r.appendASCIIString("&lt;");
        break;
      case 62:
        r.appendASCIIString("&gt;");
        break;
      case 38:
        r.appendASCIIString("&amp;");
        break;
      case 0:
        r.appendASCIIString("&#00;");
        break;
      case 65279:
      case 8232:
      case 8233:
      case 133:
        r.write1(65533);
        break;
      default:
        el(d) && p++, d < 32 ? r.write1(9216 + d) : r.write1(d);
    }
    a += f, s += p;
  }
  return r.appendASCIIString("</span>"), l[n.length] = a, u[n.length] = s, r.appendASCIIString("</div>"), [l, u];
}
function Wfe(n, e, t, i) {
  if (t.length <= 1)
    return null;
  const r = Array.prototype.slice.call(e.children, 0), o = [];
  try {
    hO(n, r, i, 0, null, t.length - 1, null, o);
  } catch (s) {
    return console.log(s), null;
  }
  return o.length === 0 ? null : (o.push(t.length), o);
}
function hO(n, e, t, i, r, o, s, a) {
  if (i === o || (r = r || e1(n, e, t[i], t[i + 1]), s = s || e1(n, e, t[o], t[o + 1]), Math.abs(r[0].top - s[0].top) <= 0.1))
    return;
  if (i + 1 === o) {
    a.push(o);
    return;
  }
  const l = i + (o - i) / 2 | 0, u = e1(n, e, t[l], t[l + 1]);
  hO(n, e, t, i, r, l, u, a), hO(n, e, t, l, u, o, s, a);
}
function e1(n, e, t, i) {
  return n.setStart(
    e[t / 16384 | 0].firstChild,
    t % 16384
    /* SPAN_MODULO_LIMIT */
  ), n.setEnd(
    e[i / 16384 | 0].firstChild,
    i % 16384
    /* SPAN_MODULO_LIMIT */
  ), n.getClientRects();
}
var Vfe = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Gh = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let Bfe = 0, Hfe = class {
  constructor(e, t, i, r, o) {
    this.model = e, this.viewModel = t, this.view = i, this.hasRealView = r, this.listenersToRemove = o;
  }
  dispose() {
    bi(this.listenersToRemove), this.model.onBeforeDetached(), this.hasRealView && this.view.dispose(), this.viewModel.dispose();
  }
}, tS = class Cw extends Ce {
  constructor(e, t, i, r, o, s, a, l, u, c) {
    super(), this._onDidDispose = this._register(new q()), this.onDidDispose = this._onDidDispose.event, this._onDidChangeModelContent = this._register(new q()), this.onDidChangeModelContent = this._onDidChangeModelContent.event, this._onDidChangeModelLanguage = this._register(new q()), this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event, this._onDidChangeModelLanguageConfiguration = this._register(new q()), this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event, this._onDidChangeModelOptions = this._register(new q()), this.onDidChangeModelOptions = this._onDidChangeModelOptions.event, this._onDidChangeModelDecorations = this._register(new q()), this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event, this._onDidChangeConfiguration = this._register(new q()), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._onDidChangeModel = this._register(new q()), this.onDidChangeModel = this._onDidChangeModel.event, this._onDidChangeCursorPosition = this._register(new q()), this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event, this._onDidChangeCursorSelection = this._register(new q()), this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event, this._onDidAttemptReadOnlyEdit = this._register(new q()), this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event, this._onDidLayoutChange = this._register(new q()), this.onDidLayoutChange = this._onDidLayoutChange.event, this._editorTextFocus = this._register(new pW()), this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue, this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse, this._editorWidgetFocus = this._register(new pW()), this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue, this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse, this._onWillType = this._register(new q()), this.onWillType = this._onWillType.event, this._onDidType = this._register(new q()), this.onDidType = this._onDidType.event, this._onDidCompositionStart = this._register(new q()), this.onDidCompositionStart = this._onDidCompositionStart.event, this._onDidCompositionEnd = this._register(new q()), this.onDidCompositionEnd = this._onDidCompositionEnd.event, this._onDidPaste = this._register(new q()), this.onDidPaste = this._onDidPaste.event, this._onMouseUp = this._register(new q()), this.onMouseUp = this._onMouseUp.event, this._onMouseDown = this._register(new q()), this.onMouseDown = this._onMouseDown.event, this._onMouseDrag = this._register(new q()), this.onMouseDrag = this._onMouseDrag.event, this._onMouseDrop = this._register(new q()), this.onMouseDrop = this._onMouseDrop.event, this._onMouseDropCanceled = this._register(new q()), this.onMouseDropCanceled = this._onMouseDropCanceled.event, this._onContextMenu = this._register(new q()), this.onContextMenu = this._onContextMenu.event, this._onMouseMove = this._register(new q()), this.onMouseMove = this._onMouseMove.event, this._onMouseLeave = this._register(new q()), this.onMouseLeave = this._onMouseLeave.event, this._onMouseWheel = this._register(new q()), this.onMouseWheel = this._onMouseWheel.event, this._onKeyUp = this._register(new q()), this.onKeyUp = this._onKeyUp.event, this._onKeyDown = this._register(new q()), this.onKeyDown = this._onKeyDown.event, this._onDidContentSizeChange = this._register(new q()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._onDidScrollChange = this._register(new q()), this.onDidScrollChange = this._onDidScrollChange.event, this._onDidChangeViewZones = this._register(new q()), this.onDidChangeViewZones = this._onDidChangeViewZones.event;
    const h = Object.assign({}, t);
    this._domElement = e, this._overflowWidgetsDomNode = h.overflowWidgetsDomNode, delete h.overflowWidgetsDomNode, this._id = ++Bfe, this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes = {}, this.isSimpleWidget = i.isSimpleWidget || !1, this._telemetryData = i.telemetryData, this._configuration = this._register(this._createConfiguration(h, c)), this._register(this._configuration.onDidChange((f) => {
      this._onDidChangeConfiguration.fire(f);
      const p = this._configuration.options;
      if (f.hasChanged(
        128
        /* layoutInfo */
      )) {
        const g = p.get(
          128
          /* layoutInfo */
        );
        this._onDidLayoutChange.fire(g);
      }
    })), this._contextKeyService = this._register(a.createScoped(this._domElement)), this._notificationService = u, this._codeEditorService = o, this._commandService = s, this._themeService = l, this._register(new Gfe(this, this._contextKeyService)), this._register(new Ufe(this, this._contextKeyService)), this._instantiationService = r.createChild(new f_([xi, this._contextKeyService])), this._modelData = null, this._contributions = {}, this._actions = {}, this._focusTracker = new zfe(e), this._focusTracker.onChange(() => {
      this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());
    }), this._contentWidgets = {}, this._overlayWidgets = {};
    let d;
    Array.isArray(i.contributions) ? d = i.contributions : d = xp.getEditorContributions();
    for (const f of d) {
      if (this._contributions[f.id]) {
        Pi(new Error(`Cannot have two contributions with the same id ${f.id}`));
        continue;
      }
      try {
        const p = this._instantiationService.createInstance(f.ctor, this);
        this._contributions[f.id] = p;
      } catch (p) {
        Pi(p);
      }
    }
    xp.getEditorActions().forEach((f) => {
      if (this._actions[f.id]) {
        Pi(new Error(`Cannot have two actions with the same id ${f.id}`));
        return;
      }
      const p = new h7(f.id, f.label, f.alias, op(f.precondition), () => this._instantiationService.invokeFunction((g) => Promise.resolve(f.runEditorCommand(g, this, null))), this._contextKeyService);
      this._actions[p.id] = p;
    }), this._codeEditorService.addCodeEditor(this);
  }
  _createConfiguration(e, t) {
    return new oo(this.isSimpleWidget, e, this._domElement, t);
  }
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return $_.ICodeEditor;
  }
  dispose() {
    this._codeEditorService.removeCodeEditor(this), this._focusTracker.dispose();
    const e = Object.keys(this._contributions);
    for (let t = 0, i = e.length; t < i; t++) {
      const r = e[t];
      this._contributions[r].dispose();
    }
    this._contributions = {}, this._actions = {}, this._contentWidgets = {}, this._overlayWidgets = {}, this._removeDecorationTypes(), this._postDetachModelCleanup(this._detachModel()), this._onDidDispose.fire(), super.dispose();
  }
  invokeWithinContext(e) {
    return this._instantiationService.invokeFunction(e);
  }
  updateOptions(e) {
    this._configuration.updateOptions(e);
  }
  getOptions() {
    return this._configuration.options;
  }
  getOption(e) {
    return this._configuration.options.get(e);
  }
  getRawOptions() {
    return this._configuration.getRawOptions();
  }
  getOverflowWidgetsDomNode() {
    return this._overflowWidgetsDomNode;
  }
  getConfiguredWordAtPosition(e) {
    return this._modelData ? xt.getWordAtPosition(this._modelData.model, this._configuration.options.get(
      114
      /* wordSeparators */
    ), e) : null;
  }
  getValue(e = null) {
    if (!this._modelData)
      return "";
    const t = !!(e && e.preserveBOM);
    let i = 0;
    return e && e.lineEnding && e.lineEnding === `
` ? i = 1 : e && e.lineEnding && e.lineEnding === `\r
` && (i = 2), this._modelData.model.getValue(i, t);
  }
  setValue(e) {
    this._modelData && this._modelData.model.setValue(e);
  }
  getModel() {
    return this._modelData ? this._modelData.model : null;
  }
  setModel(e = null) {
    const t = e;
    if (this._modelData === null && t === null || this._modelData && this._modelData.model === t)
      return;
    const i = this.hasTextFocus(), r = this._detachModel();
    this._attachModel(t), i && this.hasModel() && this.focus();
    const o = {
      oldModelUrl: r ? r.uri : null,
      newModelUrl: t ? t.uri : null
    };
    this._removeDecorationTypes(), this._onDidChangeModel.fire(o), this._postDetachModelCleanup(r);
  }
  _removeDecorationTypes() {
    if (this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes) {
      for (let e in this._decorationTypeSubtypes) {
        const t = this._decorationTypeSubtypes[e];
        for (let i in t)
          this._removeDecorationType(e + "-" + i);
      }
      this._decorationTypeSubtypes = {};
    }
  }
  getVisibleRanges() {
    return this._modelData ? this._modelData.viewModel.getVisibleRanges() : [];
  }
  getVisibleRangesPlusViewportAboveBelow() {
    return this._modelData ? this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow() : [];
  }
  getWhitespaces() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getWhitespaces() : [];
  }
  static _getVerticalOffsetForPosition(e, t, i) {
    const r = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), o = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(r);
    return e.viewModel.viewLayout.getVerticalOffsetForLineNumber(o.lineNumber);
  }
  getTopForLineNumber(e) {
    return this._modelData ? Cw._getVerticalOffsetForPosition(this._modelData, e, 1) : -1;
  }
  getTopForPosition(e, t) {
    return this._modelData ? Cw._getVerticalOffsetForPosition(this._modelData, e, t) : -1;
  }
  setHiddenAreas(e) {
    this._modelData && this._modelData.viewModel.setHiddenAreas(e.map((t) => G.lift(t)));
  }
  getVisibleColumnFromPosition(e) {
    if (!this._modelData)
      return e.column;
    const t = this._modelData.model.validatePosition(e), i = this._modelData.model.getOptions().tabSize;
    return Kt.visibleColumnFromColumn(this._modelData.model.getLineContent(t.lineNumber), t.column, i) + 1;
  }
  getPosition() {
    return this._modelData ? this._modelData.viewModel.getPosition() : null;
  }
  setPosition(e) {
    if (this._modelData) {
      if (!ie.isIPosition(e))
        throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections("api", [{
        selectionStartLineNumber: e.lineNumber,
        selectionStartColumn: e.column,
        positionLineNumber: e.lineNumber,
        positionColumn: e.column
      }]);
    }
  }
  _sendRevealRange(e, t, i, r) {
    if (!this._modelData)
      return;
    if (!G.isIRange(e))
      throw new Error("Invalid arguments");
    const o = this._modelData.model.validateRange(e), s = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(o);
    this._modelData.viewModel.revealRange("api", i, s, t, r);
  }
  revealLine(e, t = 0) {
    this._revealLine(e, 0, t);
  }
  revealLineInCenter(e, t = 0) {
    this._revealLine(e, 1, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._revealLine(e, 2, t);
  }
  revealLineNearTop(e, t = 0) {
    this._revealLine(e, 5, t);
  }
  _revealLine(e, t, i) {
    if (typeof e != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new G(e, 1, e, 1), t, !1, i);
  }
  revealPosition(e, t = 0) {
    this._revealPosition(e, 0, !0, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._revealPosition(e, 1, !0, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._revealPosition(e, 2, !0, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._revealPosition(e, 5, !0, t);
  }
  _revealPosition(e, t, i, r) {
    if (!ie.isIPosition(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(new G(e.lineNumber, e.column, e.lineNumber, e.column), t, i, r);
  }
  getSelection() {
    return this._modelData ? this._modelData.viewModel.getSelection() : null;
  }
  getSelections() {
    return this._modelData ? this._modelData.viewModel.getSelections() : null;
  }
  setSelection(e) {
    const t = Ut.isISelection(e), i = G.isIRange(e);
    if (!t && !i)
      throw new Error("Invalid arguments");
    if (t)
      this._setSelectionImpl(e);
    else if (i) {
      const r = {
        selectionStartLineNumber: e.startLineNumber,
        selectionStartColumn: e.startColumn,
        positionLineNumber: e.endLineNumber,
        positionColumn: e.endColumn
      };
      this._setSelectionImpl(r);
    }
  }
  _setSelectionImpl(e) {
    if (!this._modelData)
      return;
    const t = new Ut(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
    this._modelData.viewModel.setSelections("api", [t]);
  }
  revealLines(e, t, i = 0) {
    this._revealLines(e, t, 0, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._revealLines(e, t, 1, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._revealLines(e, t, 2, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._revealLines(e, t, 5, i);
  }
  _revealLines(e, t, i, r) {
    if (typeof e != "number" || typeof t != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new G(e, 1, t, 1), i, !1, r);
  }
  revealRange(e, t = 0, i = !1, r = !0) {
    this._revealRange(e, i ? 1 : 0, r, t);
  }
  revealRangeInCenter(e, t = 0) {
    this._revealRange(e, 1, !0, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 2, !0, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._revealRange(e, 5, !0, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 6, !0, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._revealRange(e, 3, !0, t);
  }
  _revealRange(e, t, i, r) {
    if (!G.isIRange(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(G.lift(e), t, i, r);
  }
  setSelections(e, t = "api", i = 0) {
    if (this._modelData) {
      if (!e || e.length === 0)
        throw new Error("Invalid arguments");
      for (let r = 0, o = e.length; r < o; r++)
        if (!Ut.isISelection(e[r]))
          throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, e, i);
    }
  }
  getContentWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentWidth() : -1;
  }
  getScrollWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollWidth() : -1;
  }
  getScrollLeft() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollLeft() : -1;
  }
  getContentHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentHeight() : -1;
  }
  getScrollHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollHeight() : -1;
  }
  getScrollTop() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollTop() : -1;
  }
  setScrollLeft(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.setScrollPosition({
        scrollLeft: e
      }, t);
    }
  }
  setScrollTop(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.setScrollPosition({
        scrollTop: e
      }, t);
    }
  }
  setScrollPosition(e, t = 1) {
    this._modelData && this._modelData.viewModel.setScrollPosition(e, t);
  }
  saveViewState() {
    if (!this._modelData)
      return null;
    const e = {}, t = Object.keys(this._contributions);
    for (const o of t) {
      const s = this._contributions[o];
      typeof s.saveViewState == "function" && (e[o] = s.saveViewState());
    }
    const i = this._modelData.viewModel.saveCursorState(), r = this._modelData.viewModel.saveState();
    return {
      cursorState: i,
      viewState: r,
      contributionsState: e
    };
  }
  restoreViewState(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return;
    const t = e;
    if (t && t.cursorState && t.viewState) {
      const i = t.cursorState;
      Array.isArray(i) ? this._modelData.viewModel.restoreCursorState(i) : this._modelData.viewModel.restoreCursorState([i]);
      const r = t.contributionsState || {}, o = Object.keys(this._contributions);
      for (let a = 0, l = o.length; a < l; a++) {
        const u = o[a], c = this._contributions[u];
        typeof c.restoreViewState == "function" && c.restoreViewState(r[u]);
      }
      const s = this._modelData.viewModel.reduceRestoreState(t.viewState);
      this._modelData.view.restoreState(s);
    }
  }
  getContribution(e) {
    return this._contributions[e] || null;
  }
  getActions() {
    const e = [], t = Object.keys(this._actions);
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      e.push(this._actions[o]);
    }
    return e;
  }
  getSupportedActions() {
    let e = this.getActions();
    return e = e.filter((t) => t.isSupported()), e;
  }
  getAction(e) {
    return this._actions[e] || null;
  }
  trigger(e, t, i) {
    switch (i = i || {}, t) {
      case "compositionStart":
        this._startComposition();
        return;
      case "compositionEnd":
        this._endComposition(e);
        return;
      case "type": {
        const o = i;
        this._type(e, o.text || "");
        return;
      }
      case "replacePreviousChar": {
        const o = i;
        this._compositionType(e, o.text || "", o.replaceCharCnt || 0, 0, 0);
        return;
      }
      case "compositionType": {
        const o = i;
        this._compositionType(e, o.text || "", o.replacePrevCharCnt || 0, o.replaceNextCharCnt || 0, o.positionDelta || 0);
        return;
      }
      case "paste": {
        const o = i;
        this._paste(e, o.text || "", o.pasteOnNewLine || !1, o.multicursorText || null, o.mode || null);
        return;
      }
      case "cut":
        this._cut(e);
        return;
    }
    const r = this.getAction(t);
    if (r) {
      Promise.resolve(r.run()).then(void 0, Pi);
      return;
    }
    this._modelData && (this._triggerEditorCommand(e, t, i) || this._triggerCommand(t, i));
  }
  _triggerCommand(e, t) {
    this._commandService.executeCommand(e, t);
  }
  _startComposition() {
    this._modelData && (this._modelData.viewModel.startComposition(), this._onDidCompositionStart.fire());
  }
  _endComposition(e) {
    this._modelData && (this._modelData.viewModel.endComposition(e), this._onDidCompositionEnd.fire());
  }
  _type(e, t) {
    !this._modelData || t.length === 0 || (e === "keyboard" && this._onWillType.fire(t), this._modelData.viewModel.type(t, e), e === "keyboard" && this._onDidType.fire(t));
  }
  _compositionType(e, t, i, r, o) {
    this._modelData && this._modelData.viewModel.compositionType(t, i, r, o, e);
  }
  _paste(e, t, i, r, o) {
    if (!this._modelData || t.length === 0)
      return;
    const s = this._modelData.viewModel.getSelection().getStartPosition();
    this._modelData.viewModel.paste(t, i, r, e);
    const a = this._modelData.viewModel.getSelection().getStartPosition();
    e === "keyboard" && this._onDidPaste.fire({
      range: new G(s.lineNumber, s.column, a.lineNumber, a.column),
      mode: o
    });
  }
  _cut(e) {
    this._modelData && this._modelData.viewModel.cut(e);
  }
  _triggerEditorCommand(e, t, i) {
    const r = xp.getEditorCommand(t);
    return r ? (i = i || {}, i.source = e, this._instantiationService.invokeFunction((o) => {
      Promise.resolve(r.runEditorCommand(o, this, i)).then(void 0, Pi);
    }), !0) : !1;
  }
  _getViewModel() {
    return this._modelData ? this._modelData.viewModel : null;
  }
  pushUndoStop() {
    return !this._modelData || this._configuration.options.get(
      78
      /* readOnly */
    ) ? !1 : (this._modelData.model.pushStackElement(), !0);
  }
  popUndoStop() {
    return !this._modelData || this._configuration.options.get(
      78
      /* readOnly */
    ) ? !1 : (this._modelData.model.popStackElement(), !0);
  }
  executeEdits(e, t, i) {
    if (!this._modelData || this._configuration.options.get(
      78
      /* readOnly */
    ))
      return !1;
    let r;
    return i ? Array.isArray(i) ? r = () => i : r = i : r = () => null, this._modelData.viewModel.executeEdits(e, t, r), !0;
  }
  executeCommand(e, t) {
    this._modelData && this._modelData.viewModel.executeCommand(t, e);
  }
  executeCommands(e, t) {
    this._modelData && this._modelData.viewModel.executeCommands(t, e);
  }
  changeDecorations(e) {
    return this._modelData ? this._modelData.model.changeDecorations(e, this._id) : null;
  }
  getLineDecorations(e) {
    return this._modelData ? this._modelData.model.getLineDecorations(e, this._id, TN(this._configuration.options)) : null;
  }
  deltaDecorations(e, t) {
    return this._modelData ? e.length === 0 && t.length === 0 ? e : this._modelData.model.deltaDecorations(e, t, this._id) : [];
  }
  removeDecorations(e) {
    const t = this._decorationTypeKeysToIds[e];
    t && this.deltaDecorations(t, []), this._decorationTypeKeysToIds.hasOwnProperty(e) && delete this._decorationTypeKeysToIds[e], this._decorationTypeSubtypes.hasOwnProperty(e) && delete this._decorationTypeSubtypes[e];
  }
  getLayoutInfo() {
    return this._configuration.options.get(
      128
      /* layoutInfo */
    );
  }
  createOverviewRuler(e) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.createOverviewRuler(e);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getDomNode() {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.domNode.domNode;
  }
  delegateVerticalScrollbarMouseDown(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateVerticalScrollbarMouseDown(e);
  }
  layout(e) {
    this._configuration.observeReferenceElement(e), this.render();
  }
  focus() {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.focus();
  }
  hasTextFocus() {
    return !this._modelData || !this._modelData.hasRealView ? !1 : this._modelData.view.isFocused();
  }
  hasWidgetFocus() {
    return this._focusTracker && this._focusTracker.hasFocus();
  }
  addContentWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._contentWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a content widget with the same id."), this._contentWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addContentWidget(t);
  }
  layoutContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutContentWidget(i);
    }
  }
  removeContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      delete this._contentWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeContentWidget(i);
    }
  }
  addOverlayWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._overlayWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting an overlay widget with the same id."), this._overlayWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addOverlayWidget(t);
  }
  layoutOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutOverlayWidget(i);
    }
  }
  removeOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      delete this._overlayWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeOverlayWidget(i);
    }
  }
  changeViewZones(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.change(e);
  }
  getTargetAtClientPoint(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.getTargetAtClientPoint(e, t);
  }
  getScrolledVisiblePosition(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return null;
    const t = this._modelData.model.validatePosition(e), i = this._configuration.options, r = i.get(
      128
      /* layoutInfo */
    ), o = Cw._getVerticalOffsetForPosition(this._modelData, t.lineNumber, t.column) - this.getScrollTop(), s = this._modelData.view.getOffsetForColumn(t.lineNumber, t.column) + r.glyphMarginWidth + r.lineNumbersWidth + r.decorationsWidth - this.getScrollLeft();
    return {
      top: o,
      left: s,
      height: i.get(
        56
        /* lineHeight */
      )
    };
  }
  getOffsetForColumn(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? -1 : this._modelData.view.getOffsetForColumn(e, t);
  }
  render(e = !1) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.render(!0, e);
  }
  setAriaOptions(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.setAriaOptions(e);
  }
  applyFontInfo(e) {
    oo.applyFontInfoSlow(e, this._configuration.options.get(
      40
      /* fontInfo */
    ));
  }
  _attachModel(e) {
    if (!e) {
      this._modelData = null;
      return;
    }
    const t = [];
    this._domElement.setAttribute("data-mode-id", e.getLanguageIdentifier().language), this._configuration.setIsDominatedByLongLines(e.isDominatedByLongLines()), this._configuration.setMaxLineNumber(e.getLineCount()), e.onBeforeAttached();
    const i = new Nfe(this._id, this._configuration, e, PI.create(), II.create(this._configuration.options), (s) => Zl(s));
    t.push(e.onDidChangeDecorations((s) => this._onDidChangeModelDecorations.fire(s))), t.push(e.onDidChangeLanguage((s) => {
      this._domElement.setAttribute("data-mode-id", e.getLanguageIdentifier().language), this._onDidChangeModelLanguage.fire(s);
    })), t.push(e.onDidChangeLanguageConfiguration((s) => this._onDidChangeModelLanguageConfiguration.fire(s))), t.push(e.onDidChangeContent((s) => this._onDidChangeModelContent.fire(s))), t.push(e.onDidChangeOptions((s) => this._onDidChangeModelOptions.fire(s))), t.push(e.onWillDispose(() => this.setModel(null))), t.push(i.onEvent((s) => {
      switch (s.kind) {
        case 0:
          this._onDidContentSizeChange.fire(s);
          break;
        case 1:
          this._editorTextFocus.setValue(s.hasFocus);
          break;
        case 2:
          this._onDidScrollChange.fire(s);
          break;
        case 3:
          this._onDidChangeViewZones.fire();
          break;
        case 4:
          this._onDidAttemptReadOnlyEdit.fire();
          break;
        case 5: {
          s.reachedMaxCursorCount && this._notificationService.warn(b("cursors.maximum", "The number of cursors has been limited to {0}.", ag.MAX_CURSOR_COUNT));
          const a = [];
          for (let c = 0, h = s.selections.length; c < h; c++)
            a[c] = s.selections[c].getPosition();
          const l = {
            position: a[0],
            secondaryPositions: a.slice(1),
            reason: s.reason,
            source: s.source
          };
          this._onDidChangeCursorPosition.fire(l);
          const u = {
            selection: s.selections[0],
            secondarySelections: s.selections.slice(1),
            modelVersionId: s.modelVersionId,
            oldSelections: s.oldSelections,
            oldModelVersionId: s.oldModelVersionId,
            source: s.source,
            reason: s.reason
          };
          this._onDidChangeCursorSelection.fire(u);
          break;
        }
      }
    }));
    const [r, o] = this._createView(i);
    if (o) {
      this._domElement.appendChild(r.domNode.domNode);
      let s = Object.keys(this._contentWidgets);
      for (let a = 0, l = s.length; a < l; a++) {
        const u = s[a];
        r.addContentWidget(this._contentWidgets[u]);
      }
      s = Object.keys(this._overlayWidgets);
      for (let a = 0, l = s.length; a < l; a++) {
        const u = s[a];
        r.addOverlayWidget(this._overlayWidgets[u]);
      }
      r.render(!1, !0), r.domNode.domNode.setAttribute("data-uri", e.uri.toString());
    }
    this._modelData = new Hfe(e, i, r, o, t);
  }
  _createView(e) {
    let t;
    this.isSimpleWidget ? t = {
      paste: (o, s, a, l) => {
        this._paste("keyboard", o, s, a, l);
      },
      type: (o) => {
        this._type("keyboard", o);
      },
      compositionType: (o, s, a, l) => {
        this._compositionType("keyboard", o, s, a, l);
      },
      startComposition: () => {
        this._startComposition();
      },
      endComposition: () => {
        this._endComposition("keyboard");
      },
      cut: () => {
        this._cut("keyboard");
      }
    } : t = {
      paste: (o, s, a, l) => {
        const u = { text: o, pasteOnNewLine: s, multicursorText: a, mode: l };
        this._commandService.executeCommand("paste", u);
      },
      type: (o) => {
        const s = { text: o };
        this._commandService.executeCommand("type", s);
      },
      compositionType: (o, s, a, l) => {
        if (a || l) {
          const u = { text: o, replacePrevCharCnt: s, replaceNextCharCnt: a, positionDelta: l };
          this._commandService.executeCommand("compositionType", u);
        } else {
          const u = { text: o, replaceCharCnt: s };
          this._commandService.executeCommand("replacePreviousChar", u);
        }
      },
      startComposition: () => {
        this._commandService.executeCommand("compositionStart", {});
      },
      endComposition: () => {
        this._commandService.executeCommand("compositionEnd", {});
      },
      cut: () => {
        this._commandService.executeCommand("cut", {});
      }
    };
    const i = new IE(e.coordinatesConverter);
    return i.onKeyDown = (o) => this._onKeyDown.fire(o), i.onKeyUp = (o) => this._onKeyUp.fire(o), i.onContextMenu = (o) => this._onContextMenu.fire(o), i.onMouseMove = (o) => this._onMouseMove.fire(o), i.onMouseLeave = (o) => this._onMouseLeave.fire(o), i.onMouseDown = (o) => this._onMouseDown.fire(o), i.onMouseUp = (o) => this._onMouseUp.fire(o), i.onMouseDrag = (o) => this._onMouseDrag.fire(o), i.onMouseDrop = (o) => this._onMouseDrop.fire(o), i.onMouseDropCanceled = (o) => this._onMouseDropCanceled.fire(o), i.onMouseWheel = (o) => this._onMouseWheel.fire(o), [new Qde(t, this._configuration, this._themeService, e, i, this._overflowWidgetsDomNode), !0];
  }
  _postDetachModelCleanup(e) {
    e && e.removeAllDecorationsWithOwnerId(this._id);
  }
  _detachModel() {
    if (!this._modelData)
      return null;
    const e = this._modelData.model, t = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;
    return this._modelData.dispose(), this._modelData = null, this._domElement.removeAttribute("data-mode-id"), t && this._domElement.contains(t) && this._domElement.removeChild(t), e;
  }
  _removeDecorationType(e) {
    this._codeEditorService.removeDecorationType(e);
  }
  hasModel() {
    return this._modelData !== null;
  }
};
tS = Vfe([
  Gh(3, no),
  Gh(4, mr),
  Gh(5, Xo),
  Gh(6, xi),
  Gh(7, er),
  Gh(8, al),
  Gh(9, ks)
], tS);
class pW extends Ce {
  constructor() {
    super(), this._onDidChangeToTrue = this._register(new q()), this.onDidChangeToTrue = this._onDidChangeToTrue.event, this._onDidChangeToFalse = this._register(new q()), this.onDidChangeToFalse = this._onDidChangeToFalse.event, this._value = 0;
  }
  setValue(e) {
    const t = e ? 2 : 1;
    this._value !== t && (this._value = t, this._value === 2 ? this._onDidChangeToTrue.fire() : this._value === 1 && this._onDidChangeToFalse.fire());
  }
}
class Gfe extends Ce {
  constructor(e, t) {
    super(), this._editor = e, t.createKey("editorId", e.getId()), this._editorSimpleInput = Re.editorSimpleInput.bindTo(t), this._editorFocus = Re.focus.bindTo(t), this._textInputFocus = Re.textInputFocus.bindTo(t), this._editorTextFocus = Re.editorTextFocus.bindTo(t), this._editorTabMovesFocus = Re.tabMovesFocus.bindTo(t), this._editorReadonly = Re.readOnly.bindTo(t), this._inDiffEditor = Re.inDiffEditor.bindTo(t), this._editorColumnSelection = Re.columnSelection.bindTo(t), this._hasMultipleSelections = Re.hasMultipleSelections.bindTo(t), this._hasNonEmptySelection = Re.hasNonEmptySelection.bindTo(t), this._canUndo = Re.canUndo.bindTo(t), this._canRedo = Re.canRedo.bindTo(t), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig())), this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection())), this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidChangeModel(() => this._updateFromModel())), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel())), this._updateFromConfig(), this._updateFromSelection(), this._updateFromFocus(), this._updateFromModel(), this._editorSimpleInput.set(this._editor.isSimpleWidget);
  }
  _updateFromConfig() {
    const e = this._editor.getOptions();
    this._editorTabMovesFocus.set(e.get(
      127
      /* tabFocusMode */
    )), this._editorReadonly.set(e.get(
      78
      /* readOnly */
    )), this._inDiffEditor.set(e.get(
      51
      /* inDiffEditor */
    )), this._editorColumnSelection.set(e.get(
      16
      /* columnSelection */
    ));
  }
  _updateFromSelection() {
    const e = this._editor.getSelections();
    e ? (this._hasMultipleSelections.set(e.length > 1), this._hasNonEmptySelection.set(e.some((t) => !t.isEmpty()))) : (this._hasMultipleSelections.reset(), this._hasNonEmptySelection.reset());
  }
  _updateFromFocus() {
    this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget), this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget), this._textInputFocus.set(this._editor.hasTextFocus());
  }
  _updateFromModel() {
    const e = this._editor.getModel();
    this._canUndo.set(!!(e && e.canUndo())), this._canRedo.set(!!(e && e.canRedo()));
  }
}
class Ufe extends Ce {
  constructor(e, t) {
    super(), this._editor = e, this._contextKeyService = t, this._langId = Re.languageId.bindTo(t), this._hasCompletionItemProvider = Re.hasCompletionItemProvider.bindTo(t), this._hasCodeActionsProvider = Re.hasCodeActionsProvider.bindTo(t), this._hasCodeLensProvider = Re.hasCodeLensProvider.bindTo(t), this._hasDefinitionProvider = Re.hasDefinitionProvider.bindTo(t), this._hasDeclarationProvider = Re.hasDeclarationProvider.bindTo(t), this._hasImplementationProvider = Re.hasImplementationProvider.bindTo(t), this._hasTypeDefinitionProvider = Re.hasTypeDefinitionProvider.bindTo(t), this._hasHoverProvider = Re.hasHoverProvider.bindTo(t), this._hasDocumentHighlightProvider = Re.hasDocumentHighlightProvider.bindTo(t), this._hasDocumentSymbolProvider = Re.hasDocumentSymbolProvider.bindTo(t), this._hasReferenceProvider = Re.hasReferenceProvider.bindTo(t), this._hasRenameProvider = Re.hasRenameProvider.bindTo(t), this._hasSignatureHelpProvider = Re.hasSignatureHelpProvider.bindTo(t), this._hasInlayHintsProvider = Re.hasInlayHintsProvider.bindTo(t), this._hasDocumentFormattingProvider = Re.hasDocumentFormattingProvider.bindTo(t), this._hasDocumentSelectionFormattingProvider = Re.hasDocumentSelectionFormattingProvider.bindTo(t), this._hasMultipleDocumentFormattingProvider = Re.hasMultipleDocumentFormattingProvider.bindTo(t), this._hasMultipleDocumentSelectionFormattingProvider = Re.hasMultipleDocumentSelectionFormattingProvider.bindTo(t), this._isInWalkThrough = Re.isInWalkThroughSnippet.bindTo(t);
    const i = () => this._update();
    this._register(e.onDidChangeModel(i)), this._register(e.onDidChangeModelLanguage(i)), this._register(Cb.onDidChange(i)), this._register(AT.onDidChange(i)), this._register(PT.onDidChange(i)), this._register(OT.onDidChange(i)), this._register(xT.onDidChange(i)), this._register(NT.onDidChange(i)), this._register(IT.onDidChange(i)), this._register(DT.onDidChange(i)), this._register(TT.onDidChange(i)), this._register(RT.onDidChange(i)), this._register(ST.onDidChange(i)), this._register(ET.onDidChange(i)), this._register(gv.onDidChange(i)), this._register(Gu.onDidChange(i)), this._register(LT.onDidChange(i)), this._register(Pk.onDidChange(i)), i();
  }
  dispose() {
    super.dispose();
  }
  reset() {
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.reset(), this._hasCompletionItemProvider.reset(), this._hasCodeActionsProvider.reset(), this._hasCodeLensProvider.reset(), this._hasDefinitionProvider.reset(), this._hasDeclarationProvider.reset(), this._hasImplementationProvider.reset(), this._hasTypeDefinitionProvider.reset(), this._hasHoverProvider.reset(), this._hasDocumentHighlightProvider.reset(), this._hasDocumentSymbolProvider.reset(), this._hasReferenceProvider.reset(), this._hasRenameProvider.reset(), this._hasDocumentFormattingProvider.reset(), this._hasDocumentSelectionFormattingProvider.reset(), this._hasSignatureHelpProvider.reset(), this._isInWalkThrough.reset();
    });
  }
  _update() {
    const e = this._editor.getModel();
    if (!e) {
      this.reset();
      return;
    }
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.set(e.getLanguageIdentifier().language), this._hasCompletionItemProvider.set(Cb.has(e)), this._hasCodeActionsProvider.set(AT.has(e)), this._hasCodeLensProvider.set(PT.has(e)), this._hasDefinitionProvider.set(OT.has(e)), this._hasDeclarationProvider.set(xT.has(e)), this._hasImplementationProvider.set(NT.has(e)), this._hasTypeDefinitionProvider.set(IT.has(e)), this._hasHoverProvider.set(DT.has(e)), this._hasDocumentHighlightProvider.set(TT.has(e)), this._hasDocumentSymbolProvider.set(RT.has(e)), this._hasReferenceProvider.set(ST.has(e)), this._hasRenameProvider.set(ET.has(e)), this._hasSignatureHelpProvider.set(LT.has(e)), this._hasInlayHintsProvider.set(Pk.has(e)), this._hasDocumentFormattingProvider.set(gv.has(e) || Gu.has(e)), this._hasDocumentSelectionFormattingProvider.set(Gu.has(e)), this._hasMultipleDocumentFormattingProvider.set(gv.all(e).length + Gu.all(e).length > 1), this._hasMultipleDocumentSelectionFormattingProvider.set(Gu.all(e).length > 1), this._isInWalkThrough.set(e.uri.scheme === vi.walkThroughSnippet);
    });
  }
}
class zfe extends Ce {
  constructor(e) {
    super(), this._onChange = this._register(new q()), this.onChange = this._onChange.event, this._hasFocus = !1, this._domFocusTracker = this._register(iE(e)), this._register(this._domFocusTracker.onDidFocus(() => {
      this._hasFocus = !0, this._onChange.fire(void 0);
    })), this._register(this._domFocusTracker.onDidBlur(() => {
      this._hasFocus = !1, this._onChange.fire(void 0);
    }));
  }
  hasFocus() {
    return this._hasFocus;
  }
}
const jfe = encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='"), $fe = encodeURIComponent("'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>");
function t1(n) {
  return jfe + encodeURIComponent(n.toString()) + $fe;
}
const Kfe = encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" height="3" width="12"><g fill="'), qfe = encodeURIComponent('"><circle cx="1" cy="1" r="1"/><circle cx="5" cy="1" r="1"/><circle cx="9" cy="1" r="1"/></g></svg>');
function Yfe(n) {
  return Kfe + encodeURIComponent(n.toString()) + qfe;
}
wa((n, e) => {
  const t = n.getColor(Pce);
  t && e.addRule(`.monaco-editor .squiggly-error { border-bottom: 4px double ${t}; }`);
  const i = n.getColor(mw);
  i && e.addRule(`.monaco-editor .squiggly-error { background: url("data:image/svg+xml,${t1(i)}") repeat-x bottom left; }`);
  const r = n.getColor(Ice);
  r && e.addRule(`.monaco-editor .squiggly-error::before { display: block; content: ''; width: 100%; height: 100%; background: ${r}; }`);
  const o = n.getColor(SI);
  o && e.addRule(`.monaco-editor .squiggly-warning { border-bottom: 4px double ${o}; }`);
  const s = n.getColor(nh);
  s && e.addRule(`.monaco-editor .squiggly-warning { background: url("data:image/svg+xml,${t1(s)}") repeat-x bottom left; }`);
  const a = n.getColor(Ace);
  a && e.addRule(`.monaco-editor .squiggly-warning::before { display: block; content: ''; width: 100%; height: 100%; background: ${a}; }`);
  const l = n.getColor(z3);
  l && e.addRule(`.monaco-editor .squiggly-info { border-bottom: 4px double ${l}; }`);
  const u = n.getColor(Ap);
  u && e.addRule(`.monaco-editor .squiggly-info { background: url("data:image/svg+xml,${t1(u)}") repeat-x bottom left; }`);
  const c = n.getColor(Mce);
  c && e.addRule(`.monaco-editor .squiggly-info::before { display: block; content: ''; width: 100%; height: 100%; background: ${c}; }`);
  const h = n.getColor(kce);
  h && e.addRule(`.monaco-editor .squiggly-hint { border-bottom: 2px dotted ${h}; }`);
  const d = n.getColor(Fce);
  d && e.addRule(`.monaco-editor .squiggly-hint { background: url("data:image/svg+xml,${Yfe(d)}") no-repeat bottom left; }`);
  const f = n.getColor(Bhe);
  f && e.addRule(`.monaco-editor.showUnused .squiggly-inline-unnecessary { opacity: ${f.rgba.a}; }`);
  const p = n.getColor(Vhe);
  p && e.addRule(`.monaco-editor.showUnused .squiggly-unnecessary { border-bottom: 2px dashed ${p}; }`);
  const g = n.getColor(Z_) || "inherit";
  e.addRule(`.monaco-editor.showDeprecated .squiggly-inline-deprecated { text-decoration: line-through; text-decoration-color: ${g}}`);
});
var Wg = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
};
let Xfe = !1;
var gW;
(function(n) {
  n.North = "north", n.South = "south", n.East = "east", n.West = "west";
})(gW || (gW = {}));
let Zfe = 4;
const Qfe = new q();
let Jfe = 300;
const epe = new q();
class AI {
  constructor() {
    this.disposables = new dt();
  }
  get onPointerMove() {
    return this.disposables.add(new Dr(window, "mousemove")).event;
  }
  get onPointerUp() {
    return this.disposables.add(new Dr(window, "mouseup")).event;
  }
  dispose() {
    this.disposables.dispose();
  }
}
Wg([
  Bn
], AI.prototype, "onPointerMove", null);
Wg([
  Bn
], AI.prototype, "onPointerUp", null);
class MI {
  constructor(e) {
    this.el = e, this.disposables = new dt();
  }
  get onPointerMove() {
    return this.disposables.add(new Dr(this.el, Ri.Change)).event;
  }
  get onPointerUp() {
    return this.disposables.add(new Dr(this.el, Ri.End)).event;
  }
  dispose() {
    this.disposables.dispose();
  }
}
Wg([
  Bn
], MI.prototype, "onPointerMove", null);
Wg([
  Bn
], MI.prototype, "onPointerUp", null);
class iS {
  constructor(e) {
    this.factory = e;
  }
  get onPointerMove() {
    return this.factory.onPointerMove;
  }
  get onPointerUp() {
    return this.factory.onPointerUp;
  }
  dispose() {
  }
}
Wg([
  Bn
], iS.prototype, "onPointerMove", null);
Wg([
  Bn
], iS.prototype, "onPointerUp", null);
class ds extends Ce {
  constructor(e, t, i) {
    super(), this.hoverDelay = Jfe, this.hoverDelayer = this._register(new AN(this.hoverDelay)), this._state = 3, this._onDidEnablementChange = this._register(new q()), this.onDidEnablementChange = this._onDidEnablementChange.event, this._onDidStart = this._register(new q()), this.onDidStart = this._onDidStart.event, this._onDidChange = this._register(new q()), this.onDidChange = this._onDidChange.event, this._onDidReset = this._register(new q()), this.onDidReset = this._onDidReset.event, this._onDidEnd = this._register(new q()), this.onDidEnd = this._onDidEnd.event, this.linkedSash = void 0, this.orthogonalStartSashDisposables = this._register(new dt()), this.orthogonalStartDragHandleDisposables = this._register(new dt()), this.orthogonalEndSashDisposables = this._register(new dt()), this.orthogonalEndDragHandleDisposables = this._register(new dt()), this.el = Me(e, Xe(".monaco-sash")), i.orthogonalEdge && this.el.classList.add(`orthogonal-edge-${i.orthogonalEdge}`), kt && this.el.classList.add("mac");
    const r = this._register(new Dr(this.el, "mousedown")).event;
    this._register(r((h) => this.onPointerStart(h, new AI()), this));
    const o = this._register(new Dr(this.el, "dblclick")).event;
    this._register(o(this.onPointerDoublePress, this));
    const s = this._register(new Dr(this.el, "mouseenter")).event;
    this._register(s(() => ds.onMouseEnter(this)));
    const a = this._register(new Dr(this.el, "mouseleave")).event;
    this._register(a(() => ds.onMouseLeave(this))), this._register(ri.addTarget(this.el));
    const l = We.map(this._register(new Dr(this.el, Ri.Start)).event, (h) => {
      var d;
      return Object.assign(Object.assign({}, h), { target: (d = h.initialTarget) !== null && d !== void 0 ? d : null });
    });
    this._register(l((h) => this.onPointerStart(h, new MI(this.el)), this));
    const u = this._register(new Dr(this.el, Ri.Tap)).event, c = We.map(We.filter(We.debounce(u, (h, d) => {
      var f;
      return { event: d, count: ((f = h == null ? void 0 : h.count) !== null && f !== void 0 ? f : 0) + 1 };
    }, 250), ({ count: h }) => h === 2), ({ event: h }) => {
      var d;
      return Object.assign(Object.assign({}, h), { target: (d = h.initialTarget) !== null && d !== void 0 ? d : null });
    });
    this._register(c(this.onPointerDoublePress, this)), typeof i.size == "number" ? (this.size = i.size, i.orientation === 0 ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = Zfe, this._register(Qfe.event((h) => {
      this.size = h, this.layout();
    }))), this._register(epe.event((h) => this.hoverDelay = h)), this.hidden = !1, this.layoutProvider = t, this.orthogonalStartSash = i.orthogonalStartSash, this.orthogonalEndSash = i.orthogonalEndSash, this.orientation = i.orientation || 0, this.orientation === 1 ? (this.el.classList.add("horizontal"), this.el.classList.remove("vertical")) : (this.el.classList.remove("horizontal"), this.el.classList.add("vertical")), this.el.classList.toggle("debug", Xfe), this.layout();
  }
  get state() {
    return this._state;
  }
  set state(e) {
    this._state !== e && (this.el.classList.toggle(
      "disabled",
      e === 0
      /* Disabled */
    ), this.el.classList.toggle(
      "minimum",
      e === 1
      /* Minimum */
    ), this.el.classList.toggle(
      "maximum",
      e === 2
      /* Maximum */
    ), this._state = e, this._onDidEnablementChange.fire(e));
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  set orthogonalStartSash(e) {
    if (this.orthogonalStartDragHandleDisposables.clear(), this.orthogonalStartSashDisposables.clear(), e) {
      const t = (i) => {
        this.orthogonalStartDragHandleDisposables.clear(), i !== 0 && (this._orthogonalStartDragHandle = Me(this.el, Xe(".orthogonal-drag-handle.start")), this.orthogonalStartDragHandleDisposables.add(Oi(() => this._orthogonalStartDragHandle.remove())), this.orthogonalEndDragHandleDisposables.add(new Dr(this._orthogonalStartDragHandle, "mouseenter")).event(() => ds.onMouseEnter(e), void 0, this.orthogonalStartDragHandleDisposables), this.orthogonalEndDragHandleDisposables.add(new Dr(this._orthogonalStartDragHandle, "mouseleave")).event(() => ds.onMouseLeave(e), void 0, this.orthogonalStartDragHandleDisposables));
      };
      this.orthogonalStartSashDisposables.add(e.onDidEnablementChange(t, this)), t(e.state);
    }
    this._orthogonalStartSash = e;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  set orthogonalEndSash(e) {
    if (this.orthogonalEndDragHandleDisposables.clear(), this.orthogonalEndSashDisposables.clear(), e) {
      const t = (i) => {
        this.orthogonalEndDragHandleDisposables.clear(), i !== 0 && (this._orthogonalEndDragHandle = Me(this.el, Xe(".orthogonal-drag-handle.end")), this.orthogonalEndDragHandleDisposables.add(Oi(() => this._orthogonalEndDragHandle.remove())), this.orthogonalEndDragHandleDisposables.add(new Dr(this._orthogonalEndDragHandle, "mouseenter")).event(() => ds.onMouseEnter(e), void 0, this.orthogonalEndDragHandleDisposables), this.orthogonalEndDragHandleDisposables.add(new Dr(this._orthogonalEndDragHandle, "mouseleave")).event(() => ds.onMouseLeave(e), void 0, this.orthogonalEndDragHandleDisposables));
      };
      this.orthogonalEndSashDisposables.add(e.onDidEnablementChange(t, this)), t(e.state);
    }
    this._orthogonalEndSash = e;
  }
  onPointerStart(e, t) {
    gi.stop(e);
    let i = !1;
    if (!e.__orthogonalSashEvent) {
      const p = this.getOrthogonalSash(e);
      p && (i = !0, e.__orthogonalSashEvent = !0, p.onPointerStart(e, new iS(t)));
    }
    if (this.linkedSash && !e.__linkedSashEvent && (e.__linkedSashEvent = !0, this.linkedSash.onPointerStart(e, new iS(t))), !this.state)
      return;
    const r = [
      ...rk("iframe"),
      ...rk("webview")
    ];
    for (const p of r)
      p.style.pointerEvents = "none";
    const o = e.pageX, s = e.pageY, a = e.altKey, l = { startX: o, currentX: o, startY: s, currentY: s, altKey: a };
    this.el.classList.add("active"), this._onDidStart.fire(l);
    const u = As(this.el), c = () => {
      let p = "";
      i ? p = "all-scroll" : this.orientation === 1 ? this.state === 1 ? p = "s-resize" : this.state === 2 ? p = "n-resize" : p = kt ? "row-resize" : "ns-resize" : this.state === 1 ? p = "e-resize" : this.state === 2 ? p = "w-resize" : p = kt ? "col-resize" : "ew-resize", u.textContent = `* { cursor: ${p} !important; }`;
    }, h = new dt();
    c(), i || this.onDidEnablementChange(c, null, h);
    const d = (p) => {
      gi.stop(p, !1);
      const g = { startX: o, currentX: p.pageX, startY: s, currentY: p.pageY, altKey: a };
      this._onDidChange.fire(g);
    }, f = (p) => {
      gi.stop(p, !1), this.el.removeChild(u), this.el.classList.remove("active"), this._onDidEnd.fire(), h.dispose();
      for (const g of r)
        g.style.pointerEvents = "auto";
    };
    t.onPointerMove(d, null, h), t.onPointerUp(f, null, h), h.add(t);
  }
  onPointerDoublePress(e) {
    const t = this.getOrthogonalSash(e);
    t && t._onDidReset.fire(), this.linkedSash && this.linkedSash._onDidReset.fire(), this._onDidReset.fire();
  }
  static onMouseEnter(e, t = !1) {
    e.el.classList.contains("active") ? (e.hoverDelayer.cancel(), e.el.classList.add("hover")) : e.hoverDelayer.trigger(() => e.el.classList.add("hover"), e.hoverDelay).then(void 0, () => {
    }), !t && e.linkedSash && ds.onMouseEnter(e.linkedSash, !0);
  }
  static onMouseLeave(e, t = !1) {
    e.hoverDelayer.cancel(), e.el.classList.remove("hover"), !t && e.linkedSash && ds.onMouseLeave(e.linkedSash, !0);
  }
  clearSashHoverState() {
    ds.onMouseLeave(this);
  }
  layout() {
    if (this.orientation === 0) {
      const e = this.layoutProvider;
      this.el.style.left = e.getVerticalSashLeft(this) - this.size / 2 + "px", e.getVerticalSashTop && (this.el.style.top = e.getVerticalSashTop(this) + "px"), e.getVerticalSashHeight && (this.el.style.height = e.getVerticalSashHeight(this) + "px");
    } else {
      const e = this.layoutProvider;
      this.el.style.top = e.getHorizontalSashTop(this) - this.size / 2 + "px", e.getHorizontalSashLeft && (this.el.style.left = e.getHorizontalSashLeft(this) + "px"), e.getHorizontalSashWidth && (this.el.style.width = e.getHorizontalSashWidth(this) + "px");
    }
  }
  hide() {
    this.hidden = !0, this.el.style.display = "none", this.el.setAttribute("aria-hidden", "true");
  }
  getOrthogonalSash(e) {
    if (!(!e.target || !(e.target instanceof HTMLElement)) && e.target.classList.contains("orthogonal-drag-handle"))
      return e.target.classList.contains("start") ? this.orthogonalStartSash : this.orthogonalEndSash;
  }
  dispose() {
    super.dispose(), this.el.remove();
  }
}
class Vc {
  constructor(e, t = [], i = !1) {
    this.ctor = e, this.staticArguments = t, this.supportsDelayedInstantiation = i;
  }
}
const p7 = [];
function g7(n, e, t) {
  e instanceof Vc || (e = new Vc(e, [], t)), p7.push([n, e]);
}
function tpe() {
  return p7;
}
const FI = Vt("IEditorCancelService"), m7 = new nt("cancellableOperation", !1, b("cancellableOperation", "Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));
g7(FI, class {
  constructor() {
    this._tokens = /* @__PURE__ */ new WeakMap();
  }
  add(n, e) {
    let t = this._tokens.get(n);
    t || (t = n.invokeWithinContext((r) => {
      const o = m7.bindTo(r.get(xi)), s = new fa();
      return { key: o, tokens: s };
    }), this._tokens.set(n, t));
    let i;
    return t.key.set(!0), i = t.tokens.push(e), () => {
      i && (i(), t.key.set(!t.tokens.isEmpty()), i = void 0);
    };
  }
  cancel(n) {
    const e = this._tokens.get(n);
    if (!e)
      return;
    const t = e.tokens.pop();
    t && (t.cancel(), e.key.set(!e.tokens.isEmpty()));
  }
}, !0);
class ipe extends mh {
  constructor(e, t) {
    super(t), this.editor = e, this._unregister = e.invokeWithinContext((i) => i.get(FI).add(e, this));
  }
  dispose() {
    this._unregister(), super.dispose();
  }
}
Ze(new class extends Mg {
  constructor() {
    super({
      id: "editor.cancelOperation",
      kbOpts: {
        weight: 100,
        primary: 9
        /* Escape */
      },
      precondition: m7
    });
  }
  runEditorCommand(n, e) {
    n.get(FI).cancel(e);
  }
}());
class dO {
  constructor(e, t) {
    if (this.flags = t, this.flags & 1) {
      const i = e.getModel();
      this.modelVersionId = i ? Fl("{0}#{1}", i.uri.toString(), i.getVersionId()) : null;
    } else
      this.modelVersionId = null;
    this.flags & 4 ? this.position = e.getPosition() : this.position = null, this.flags & 2 ? this.selection = e.getSelection() : this.selection = null, this.flags & 8 ? (this.scrollLeft = e.getScrollLeft(), this.scrollTop = e.getScrollTop()) : (this.scrollLeft = -1, this.scrollTop = -1);
  }
  _equals(e) {
    if (!(e instanceof dO))
      return !1;
    const t = e;
    return !(this.modelVersionId !== t.modelVersionId || this.scrollLeft !== t.scrollLeft || this.scrollTop !== t.scrollTop || !this.position && t.position || this.position && !t.position || this.position && t.position && !this.position.equals(t.position) || !this.selection && t.selection || this.selection && !t.selection || this.selection && t.selection && !this.selection.equalsRange(t.selection));
  }
  validate(e) {
    return this._equals(new dO(e, this.flags));
  }
}
class v7 extends ipe {
  constructor(e, t, i, r) {
    super(e, r), this._listener = new dt(), t & 4 && this._listener.add(e.onDidChangeCursorPosition((o) => {
      (!i || !G.containsPosition(i, o.position)) && this.cancel();
    })), t & 2 && this._listener.add(e.onDidChangeCursorSelection((o) => {
      (!i || !G.containsRange(i, o.selection)) && this.cancel();
    })), t & 8 && this._listener.add(e.onDidScrollChange((o) => this.cancel())), t & 1 && (this._listener.add(e.onDidChangeModel((o) => this.cancel())), this._listener.add(e.onDidChangeModelContent((o) => this.cancel())));
  }
  dispose() {
    this._listener.dispose(), super.dispose();
  }
}
class _7 extends mh {
  constructor(e, t) {
    super(t), this._listener = e.onDidChangeContent(() => this.cancel());
  }
  dispose() {
    this._listener.dispose(), super.dispose();
  }
}
class kI {
  constructor(e, t, i) {
    this._visiblePosition = e, this._visiblePositionScrollDelta = t, this._cursorPosition = i;
  }
  static capture(e) {
    let t = null, i = 0;
    if (e.getScrollTop() !== 0) {
      const r = e.getVisibleRanges();
      if (r.length > 0) {
        t = r[0].getStartPosition();
        const o = e.getTopForPosition(t.lineNumber, t.column);
        i = e.getScrollTop() - o;
      }
    }
    return new kI(t, i, e.getPosition());
  }
  restore(e) {
    if (this._visiblePosition) {
      const t = e.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
      e.setScrollTop(t + this._visiblePositionScrollDelta);
    }
  }
  restoreRelativeVerticalPositionOfCursor(e) {
    const t = e.getPosition();
    if (!this._cursorPosition || !t)
      return;
    const i = e.getTopForLineNumber(t.lineNumber) - e.getTopForLineNumber(this._cursorPosition.lineNumber);
    e.setScrollTop(e.getScrollTop() + i);
  }
}
const C7 = {
  /**
   * Application specific resource transfer type
   */
  RESOURCES: "ResourceURLs",
  /**
   * Browser specific transfer type to download
   */
  DOWNLOAD_URL: "DownloadURL",
  /**
   * Browser specific transfer type for files
   */
  FILES: "Files",
  /**
   * Typically transfer type for copy/paste transfers.
   */
  TEXT: "text/plain"
};
class npe {
  constructor(e) {
    this.data = e;
  }
  update() {
  }
  getData() {
    return this.data;
  }
}
const xu = {
  CurrentDragAndDropData: void 0
};
class Tv extends Ce {
  constructor(e, t, i = {}) {
    super(), this.options = i, this._context = e || this, this._action = t, t instanceof zl && this._register(t.onDidChange((r) => {
      this.element && this.handleActionChangeEvent(r);
    }));
  }
  handleActionChangeEvent(e) {
    e.enabled !== void 0 && this.updateEnabled(), e.checked !== void 0 && this.updateChecked(), e.class !== void 0 && this.updateClass(), e.label !== void 0 && (this.updateLabel(), this.updateTooltip()), e.tooltip !== void 0 && this.updateTooltip();
  }
  get actionRunner() {
    return this._actionRunner || (this._actionRunner = this._register(new lI())), this._actionRunner;
  }
  set actionRunner(e) {
    this._actionRunner = e;
  }
  getAction() {
    return this._action;
  }
  isEnabled() {
    return this._action.enabled;
  }
  setActionContext(e) {
    this._context = e;
  }
  render(e) {
    const t = this.element = e;
    this._register(ri.addTarget(e));
    const i = this.options && this.options.draggable;
    i && (e.draggable = !0, to && this._register(be(e, Ge.DRAG_START, (r) => {
      var o;
      return (o = r.dataTransfer) === null || o === void 0 ? void 0 : o.setData(C7.TEXT, this._action.label);
    }))), this._register(be(t, Ri.Tap, (r) => this.onClick(r))), this._register(be(t, Ge.MOUSE_DOWN, (r) => {
      i || gi.stop(r, !0), this._action.enabled && r.button === 0 && t.classList.add("active");
    })), kt && this._register(be(t, Ge.CONTEXT_MENU, (r) => {
      r.button === 0 && r.ctrlKey === !0 && this.onClick(r);
    })), this._register(be(t, Ge.CLICK, (r) => {
      gi.stop(r, !0), this.options && this.options.isMenu || ab(() => this.onClick(r));
    })), this._register(be(t, Ge.DBLCLICK, (r) => {
      gi.stop(r, !0);
    })), [Ge.MOUSE_UP, Ge.MOUSE_OUT].forEach((r) => {
      this._register(be(t, r, (o) => {
        gi.stop(o), t.classList.remove("active");
      }));
    });
  }
  onClick(e) {
    var t;
    gi.stop(e, !0);
    const i = _s(this._context) ? !((t = this.options) === null || t === void 0) && t.useEventAsContext ? e : void 0 : this._context;
    this.actionRunner.run(this._action, i);
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.element && (this.element.tabIndex = 0, this.element.focus(), this.element.classList.add("focused"));
  }
  blur() {
    this.element && (this.element.blur(), this.element.tabIndex = -1, this.element.classList.remove("focused"));
  }
  setFocusable(e) {
    this.element && (this.element.tabIndex = e ? 0 : -1);
  }
  get trapsArrowNavigation() {
    return !1;
  }
  updateEnabled() {
  }
  updateLabel() {
  }
  updateTooltip() {
  }
  updateClass() {
  }
  updateChecked() {
  }
  dispose() {
    this.element && (this.element.remove(), this.element = void 0), super.dispose();
  }
}
class y7 extends Tv {
  constructor(e, t, i = {}) {
    super(e, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "";
  }
  render(e) {
    super.render(e), this.element && (this.label = Me(this.element, Xe("a.action-label"))), this.label && (this._action.id === lf.ID ? this.label.setAttribute("role", "presentation") : this.options.isMenu ? this.label.setAttribute("role", "menuitem") : this.label.setAttribute("role", "button")), this.options.label && this.options.keybinding && this.element && (Me(this.element, Xe("span.keybinding")).textContent = this.options.keybinding), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked();
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.label && (this.label.tabIndex = 0, this.label.focus());
  }
  blur() {
    this.label && (this.label.tabIndex = -1);
  }
  setFocusable(e) {
    this.label && (this.label.tabIndex = e ? 0 : -1);
  }
  updateLabel() {
    this.options.label && this.label && (this.label.textContent = this.getAction().label);
  }
  updateTooltip() {
    let e = null;
    this.getAction().tooltip ? e = this.getAction().tooltip : !this.options.label && this.getAction().label && this.options.icon && (e = this.getAction().label, this.options.keybinding && (e = b({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", e, this.options.keybinding))), e && this.label && (this.label.title = e);
  }
  updateClass() {
    this.cssClass && this.label && this.label.classList.remove(...this.cssClass.split(" ")), this.options.icon ? (this.cssClass = this.getAction().class, this.label && (this.label.classList.add("codicon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" "))), this.updateEnabled()) : this.label && this.label.classList.remove("codicon");
  }
  updateEnabled() {
    this.getAction().enabled ? (this.label && (this.label.removeAttribute("aria-disabled"), this.label.classList.remove("disabled")), this.element && this.element.classList.remove("disabled")) : (this.label && (this.label.setAttribute("aria-disabled", "true"), this.label.classList.add("disabled")), this.element && this.element.classList.add("disabled"));
  }
  updateChecked() {
    this.label && (this.getAction().checked ? this.label.classList.add("checked") : this.label.classList.remove("checked"));
  }
}
var rpe = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class lg extends Ce {
  constructor(e, t = {}) {
    var i, r, o, s, a, l;
    super(), this.triggerKeyDown = !1, this.focusable = !0, this._onDidBlur = this._register(new q()), this.onDidBlur = this._onDidBlur.event, this._onDidCancel = this._register(new q({ onFirstListenerAdd: () => this.cancelHasListener = !0 })), this.onDidCancel = this._onDidCancel.event, this.cancelHasListener = !1, this._onDidRun = this._register(new q()), this.onDidRun = this._onDidRun.event, this._onBeforeRun = this._register(new q()), this.onBeforeRun = this._onBeforeRun.event, this.options = t, this._context = (i = t.context) !== null && i !== void 0 ? i : null, this._orientation = (r = this.options.orientation) !== null && r !== void 0 ? r : 0, this._triggerKeys = {
      keyDown: (s = (o = this.options.triggerKeys) === null || o === void 0 ? void 0 : o.keyDown) !== null && s !== void 0 ? s : !1,
      keys: (l = (a = this.options.triggerKeys) === null || a === void 0 ? void 0 : a.keys) !== null && l !== void 0 ? l : [
        3,
        10
        /* Space */
      ]
    }, this.options.actionRunner ? this._actionRunner = this.options.actionRunner : (this._actionRunner = new lI(), this._register(this._actionRunner)), this._register(this._actionRunner.onDidRun((h) => this._onDidRun.fire(h))), this._register(this._actionRunner.onBeforeRun((h) => this._onBeforeRun.fire(h))), this._actionIds = [], this.viewItems = [], this.focusedItem = void 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-action-bar", t.animated !== !1 && this.domNode.classList.add("animated");
    let u, c;
    switch (this._orientation) {
      case 0:
        u = [
          15
          /* LeftArrow */
        ], c = [
          17
          /* RightArrow */
        ];
        break;
      case 1:
        u = [
          16
          /* UpArrow */
        ], c = [
          18
          /* DownArrow */
        ], this.domNode.className += " vertical";
        break;
    }
    this._register(be(this.domNode, Ge.KEY_DOWN, (h) => {
      const d = new Yi(h);
      let f = !0;
      const p = typeof this.focusedItem == "number" ? this.viewItems[this.focusedItem] : void 0;
      u && (d.equals(u[0]) || d.equals(u[1])) ? f = this.focusPrevious() : c && (d.equals(c[0]) || d.equals(c[1])) ? f = this.focusNext() : d.equals(
        9
        /* Escape */
      ) && this.cancelHasListener ? this._onDidCancel.fire() : d.equals(
        14
        /* Home */
      ) ? f = this.focusFirst() : d.equals(
        13
        /* End */
      ) ? f = this.focusLast() : d.equals(
        2
        /* Tab */
      ) && p instanceof Tv && p.trapsArrowNavigation ? f = this.focusNext() : this.isTriggerKeyEvent(d) ? this._triggerKeys.keyDown ? this.doTrigger(d) : this.triggerKeyDown = !0 : f = !1, f && (d.preventDefault(), d.stopPropagation());
    })), this._register(be(this.domNode, Ge.KEY_UP, (h) => {
      const d = new Yi(h);
      this.isTriggerKeyEvent(d) ? (!this._triggerKeys.keyDown && this.triggerKeyDown && (this.triggerKeyDown = !1, this.doTrigger(d)), d.preventDefault(), d.stopPropagation()) : (d.equals(
        2
        /* Tab */
      ) || d.equals(
        1026
        /* Tab */
      )) && this.updateFocusedItem();
    })), this.focusTracker = this._register(iE(this.domNode)), this._register(this.focusTracker.onDidBlur(() => {
      (Lp() === this.domNode || !Ju(Lp(), this.domNode)) && (this._onDidBlur.fire(), this.focusedItem = void 0, this.triggerKeyDown = !1);
    })), this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem())), this.actionsList = document.createElement("ul"), this.actionsList.className = "actions-container", this.actionsList.setAttribute("role", "toolbar"), this.options.ariaLabel && this.actionsList.setAttribute("aria-label", this.options.ariaLabel), this.domNode.appendChild(this.actionsList), e.appendChild(this.domNode);
  }
  isTriggerKeyEvent(e) {
    let t = !1;
    return this._triggerKeys.keys.forEach((i) => {
      t = t || e.equals(i);
    }), t;
  }
  updateFocusedItem() {
    for (let e = 0; e < this.actionsList.children.length; e++) {
      const t = this.actionsList.children[e];
      if (Ju(Lp(), t)) {
        this.focusedItem = e;
        break;
      }
    }
  }
  get context() {
    return this._context;
  }
  set context(e) {
    this._context = e, this.viewItems.forEach((t) => t.setActionContext(e));
  }
  get actionRunner() {
    return this._actionRunner;
  }
  set actionRunner(e) {
    e && (this._actionRunner = e, this.viewItems.forEach((t) => t.actionRunner = e));
  }
  getContainer() {
    return this.domNode;
  }
  push(e, t = {}) {
    const i = Array.isArray(e) ? e : [e];
    let r = j_(t.index) ? t.index : null;
    i.forEach((o) => {
      const s = document.createElement("li");
      s.className = "action-item", s.setAttribute("role", "presentation"), this.options.allowContextMenu || this._register(be(s, Ge.CONTEXT_MENU, (l) => {
        gi.stop(l, !0);
      }));
      let a;
      this.options.actionViewItemProvider && (a = this.options.actionViewItemProvider(o)), a || (a = new y7(this.context, o, t)), a.actionRunner = this._actionRunner, a.setActionContext(this.context), a.render(s), this.focusable && a instanceof Tv && this.viewItems.length === 0 && a.setFocusable(!0), r === null || r < 0 || r >= this.actionsList.children.length ? (this.actionsList.appendChild(s), this.viewItems.push(a), this._actionIds.push(o.id)) : (this.actionsList.insertBefore(s, this.actionsList.children[r]), this.viewItems.splice(r, 0, a), this._actionIds.splice(r, 0, o.id), r++);
    }), typeof this.focusedItem == "number" && this.focus(this.focusedItem);
  }
  clear() {
    bi(this.viewItems), this.viewItems = [], this._actionIds = [], Ps(this.actionsList);
  }
  length() {
    return this.viewItems.length;
  }
  focus(e) {
    let t = !1, i;
    if (e === void 0 ? t = !0 : typeof e == "number" ? i = e : typeof e == "boolean" && (t = e), t && typeof this.focusedItem > "u") {
      const r = this.viewItems.findIndex((o) => o.isEnabled());
      this.focusedItem = r === -1 ? void 0 : r, this.updateFocus();
    } else
      i !== void 0 && (this.focusedItem = i), this.updateFocus();
  }
  focusFirst() {
    return this.focusedItem = this.length() > 1 ? 1 : 0, this.focusPrevious();
  }
  focusLast() {
    return this.focusedItem = this.length() < 2 ? 0 : this.length() - 2, this.focusNext();
  }
  focusNext() {
    if (typeof this.focusedItem > "u")
      this.focusedItem = this.viewItems.length - 1;
    else if (this.viewItems.length <= 1)
      return !1;
    const e = this.focusedItem;
    let t;
    do {
      if (this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length)
        return this.focusedItem = e, !1;
      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length, t = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== e && this.options.focusOnlyEnabledItems && !t.isEnabled());
    return this.updateFocus(), !0;
  }
  focusPrevious() {
    if (typeof this.focusedItem > "u")
      this.focusedItem = 0;
    else if (this.viewItems.length <= 1)
      return !1;
    const e = this.focusedItem;
    let t;
    do {
      if (this.focusedItem = this.focusedItem - 1, this.focusedItem < 0) {
        if (this.options.preventLoopNavigation)
          return this.focusedItem = e, !1;
        this.focusedItem = this.viewItems.length - 1;
      }
      t = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== e && this.options.focusOnlyEnabledItems && !t.isEnabled());
    return this.updateFocus(!0), !0;
  }
  updateFocus(e, t) {
    typeof this.focusedItem > "u" && this.actionsList.focus({ preventScroll: t });
    for (let i = 0; i < this.viewItems.length; i++) {
      const r = this.viewItems[i], o = r;
      if (i === this.focusedItem) {
        let s = !0;
        pv(o.focus) || (s = !1), this.options.focusOnlyEnabledItems && pv(r.isEnabled) && !r.isEnabled() && (s = !1), s ? o.focus(e) : this.actionsList.focus({ preventScroll: t });
      } else
        pv(o.blur) && o.blur();
    }
  }
  doTrigger(e) {
    if (typeof this.focusedItem > "u")
      return;
    const t = this.viewItems[this.focusedItem];
    if (t instanceof Tv) {
      const i = t._context === null || t._context === void 0 ? e : t._context;
      this.run(t._action, i);
    }
  }
  run(e, t) {
    return rpe(this, void 0, void 0, function* () {
      yield this._actionRunner.run(e, t);
    });
  }
  dispose() {
    bi(this.viewItems), this.viewItems = [], this._actionIds = [], this.getContainer().remove(), super.dispose();
  }
}
const ope = {
  IconContribution: "base.contributions.icons"
};
class spe {
  constructor() {
    this._onDidChange = new q(), this.onDidChange = this._onDidChange.event, this.iconSchema = {
      definitions: {
        icons: {
          type: "object",
          properties: {
            fontId: { type: "string", description: b("iconDefintion.fontId", "The id of the font to use. If not set, the font that is defined first is used.") },
            fontCharacter: { type: "string", description: b("iconDefintion.fontCharacter", "The font character associated with the icon definition.") }
          },
          additionalProperties: !1,
          defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
        }
      },
      type: "object",
      properties: {}
    }, this.iconReferenceSchema = { type: "string", pattern: `^${Go.iconNameExpression}$`, enum: [], enumDescriptions: [] }, this.iconsById = {}, this.iconFontsById = {};
  }
  registerIcon(e, t, i, r) {
    const o = this.iconsById[e];
    if (o) {
      if (i && !o.description) {
        o.description = i, this.iconSchema.properties[e].markdownDescription = `${i} $(${e})`;
        const l = this.iconReferenceSchema.enum.indexOf(e);
        l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = i), this._onDidChange.fire();
      }
      return o;
    }
    let s = { id: e, description: i, defaults: t, deprecationMessage: r };
    this.iconsById[e] = s;
    let a = { $ref: "#/definitions/icons" };
    return r && (a.deprecationMessage = r), i && (a.markdownDescription = `${i}: $(${e})`), this.iconSchema.properties[e] = a, this.iconReferenceSchema.enum.push(e), this.iconReferenceSchema.enumDescriptions.push(i || ""), this._onDidChange.fire(), { id: e };
  }
  getIcons() {
    return Object.keys(this.iconsById).map((e) => this.iconsById[e]);
  }
  getIcon(e) {
    return this.iconsById[e];
  }
  getIconSchema() {
    return this.iconSchema;
  }
  getIconFont(e) {
    return this.iconFontsById[e];
  }
  toString() {
    const e = (o, s) => o.id.localeCompare(s.id), t = (o) => {
      for (; ma.isThemeIcon(o.defaults); )
        o = this.iconsById[o.defaults.id];
      return `codicon codicon-${o ? o.id : ""}`;
    };
    let i = [];
    i.push("| preview     | identifier                        | default codicon ID                | description"), i.push("| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |");
    const r = Object.keys(this.iconsById).map((o) => this.iconsById[o]);
    for (const o of r.filter((s) => !!s.description).sort(e))
      i.push(`|<i class="${t(o)}"></i>|${o.id}|${ma.isThemeIcon(o.defaults) ? o.defaults.id : o.id}|${o.description || ""}|`);
    i.push("| preview     | identifier                        "), i.push("| ----------- | --------------------------------- |");
    for (const o of r.filter((s) => !ma.isThemeIcon(s.defaults)).sort(e))
      i.push(`|<i class="${t(o)}"></i>|${o.id}|`);
    return i.join(`
`);
  }
}
const Yd = new spe();
Jn.add(ope.IconContribution, Yd);
function Vg(n, e, t, i) {
  return Yd.registerIcon(n, e, t, i);
}
function ape() {
  return Yd;
}
function lpe() {
  for (const n of _b.all)
    Yd.registerIcon(n.id, n.definition, n.description);
  _b.onDidRegister((n) => Yd.registerIcon(n.id, n.definition, n.description));
}
lpe();
const w7 = "vscode://schemas/icons";
let b7 = Jn.as(dE.JSONContribution);
b7.registerSchema(w7, Yd.getIconSchema());
const mW = new ro(() => b7.notifySchemaChanged(w7), 200);
Yd.onDidChange(() => {
  mW.isScheduled() || mW.schedule();
});
const Wwe = Vg("widget-close", Hi.close, b("widgetClose", "Icon for the close action in widgets."));
var upe = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
}, i1;
const Py = 3;
class Gm {
  constructor(e, t, i, r) {
    this.originalLineStart = e, this.originalLineEnd = t, this.modifiedLineStart = i, this.modifiedLineEnd = r;
  }
  getType() {
    return this.originalLineStart === 0 ? 1 : this.modifiedLineStart === 0 ? 2 : 0;
  }
}
class n1 {
  constructor(e) {
    this.entries = e;
  }
}
const cpe = Vg("diff-review-insert", Hi.add, b("diffReviewInsertIcon", "Icon for 'Insert' in diff review.")), hpe = Vg("diff-review-remove", Hi.remove, b("diffReviewRemoveIcon", "Icon for 'Remove' in diff review.")), dpe = Vg("diff-review-close", Hi.close, b("diffReviewCloseIcon", "Icon for 'Close' in diff review."));
class ku extends Ce {
  constructor(e) {
    super(), this._width = 0, this._diffEditor = e, this._isVisible = !1, this.shadow = St(document.createElement("div")), this.shadow.setClassName("diff-review-shadow"), this.actionBarContainer = St(document.createElement("div")), this.actionBarContainer.setClassName("diff-review-actions"), this._actionBar = this._register(new lg(this.actionBarContainer.domNode)), this._actionBar.push(new zl("diffreview.close", b("label.close", "Close"), "close-diff-review " + ma.asClassName(dpe), !0, () => upe(this, void 0, void 0, function* () {
      return this.hide();
    })), { label: !1, icon: !0 }), this.domNode = St(document.createElement("div")), this.domNode.setClassName("diff-review monaco-editor-background"), this._content = St(document.createElement("div")), this._content.setClassName("diff-review-content"), this._content.setAttribute("role", "code"), this.scrollbar = this._register(new u7(this._content.domNode, {})), this.domNode.domNode.appendChild(this.scrollbar.getDomNode()), this._register(e.onDidUpdateDiff(() => {
      this._isVisible && (this._diffs = this._compute(), this._render());
    })), this._register(e.getModifiedEditor().onDidChangeCursorPosition(() => {
      this._isVisible && this._render();
    })), this._register(io(this.domNode.domNode, "click", (t) => {
      t.preventDefault();
      let i = s5(t.target, "diff-review-row");
      i && this._goToRow(i);
    })), this._register(io(this.domNode.domNode, "keydown", (t) => {
      (t.equals(
        18
        /* DownArrow */
      ) || t.equals(
        2066
        /* DownArrow */
      ) || t.equals(
        530
        /* DownArrow */
      )) && (t.preventDefault(), this._goToRow(this._getNextRow())), (t.equals(
        16
        /* UpArrow */
      ) || t.equals(
        2064
        /* UpArrow */
      ) || t.equals(
        528
        /* UpArrow */
      )) && (t.preventDefault(), this._goToRow(this._getPrevRow())), (t.equals(
        9
        /* Escape */
      ) || t.equals(
        2057
        /* Escape */
      ) || t.equals(
        521
        /* Escape */
      ) || t.equals(
        1033
        /* Escape */
      )) && (t.preventDefault(), this.hide()), (t.equals(
        10
        /* Space */
      ) || t.equals(
        3
        /* Enter */
      )) && (t.preventDefault(), this.accept());
    })), this._diffs = [], this._currentDiff = null;
  }
  prev() {
    let e = 0;
    if (this._isVisible || (this._diffs = this._compute()), this._isVisible) {
      let i = -1;
      for (let r = 0, o = this._diffs.length; r < o; r++)
        if (this._diffs[r] === this._currentDiff) {
          i = r;
          break;
        }
      e = this._diffs.length + i - 1;
    } else
      e = this._findDiffIndex(this._diffEditor.getPosition());
    if (this._diffs.length === 0)
      return;
    e = e % this._diffs.length;
    const t = this._diffs[e].entries;
    this._diffEditor.setPosition(new ie(t[0].modifiedLineStart, 1)), this._diffEditor.setSelection({ startColumn: 1, startLineNumber: t[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: t[t.length - 1].modifiedLineEnd }), this._isVisible = !0, this._diffEditor.doLayout(), this._render(), this._goToRow(this._getNextRow());
  }
  next() {
    let e = 0;
    if (this._isVisible || (this._diffs = this._compute()), this._isVisible) {
      let i = -1;
      for (let r = 0, o = this._diffs.length; r < o; r++)
        if (this._diffs[r] === this._currentDiff) {
          i = r;
          break;
        }
      e = i + 1;
    } else
      e = this._findDiffIndex(this._diffEditor.getPosition());
    if (this._diffs.length === 0)
      return;
    e = e % this._diffs.length;
    const t = this._diffs[e].entries;
    this._diffEditor.setPosition(new ie(t[0].modifiedLineStart, 1)), this._diffEditor.setSelection({ startColumn: 1, startLineNumber: t[0].modifiedLineStart, endColumn: 1073741824, endLineNumber: t[t.length - 1].modifiedLineEnd }), this._isVisible = !0, this._diffEditor.doLayout(), this._render(), this._goToRow(this._getNextRow());
  }
  accept() {
    let e = -1, t = this._getCurrentFocusedRow();
    if (t) {
      let i = parseInt(t.getAttribute("data-line"), 10);
      isNaN(i) || (e = i);
    }
    this.hide(), e !== -1 && (this._diffEditor.setPosition(new ie(e, 1)), this._diffEditor.revealPosition(
      new ie(e, 1),
      1
      /* Immediate */
    ));
  }
  hide() {
    this._isVisible = !1, this._diffEditor.updateOptions({ readOnly: !1 }), this._diffEditor.focus(), this._diffEditor.doLayout(), this._render();
  }
  _getPrevRow() {
    let e = this._getCurrentFocusedRow();
    return e ? e.previousElementSibling ? e.previousElementSibling : e : this._getFirstRow();
  }
  _getNextRow() {
    let e = this._getCurrentFocusedRow();
    return e ? e.nextElementSibling ? e.nextElementSibling : e : this._getFirstRow();
  }
  _getFirstRow() {
    return this.domNode.domNode.querySelector(".diff-review-row");
  }
  _getCurrentFocusedRow() {
    let e = document.activeElement;
    return e && /diff-review-row/.test(e.className) ? e : null;
  }
  _goToRow(e) {
    let t = this._getCurrentFocusedRow();
    e.tabIndex = 0, e.focus(), t && t !== e && (t.tabIndex = -1), this.scrollbar.scanDomNode();
  }
  isVisible() {
    return this._isVisible;
  }
  layout(e, t, i) {
    this._width = t, this.shadow.setTop(e - 6), this.shadow.setWidth(t), this.shadow.setHeight(this._isVisible ? 6 : 0), this.domNode.setTop(e), this.domNode.setWidth(t), this.domNode.setHeight(i), this._content.setHeight(i), this._content.setWidth(t), this._isVisible ? (this.actionBarContainer.setAttribute("aria-hidden", "false"), this.actionBarContainer.setDisplay("block")) : (this.actionBarContainer.setAttribute("aria-hidden", "true"), this.actionBarContainer.setDisplay("none"));
  }
  _compute() {
    const e = this._diffEditor.getLineChanges();
    if (!e || e.length === 0)
      return [];
    const t = this._diffEditor.getOriginalEditor().getModel(), i = this._diffEditor.getModifiedEditor().getModel();
    return !t || !i ? [] : ku._mergeAdjacent(e, t.getLineCount(), i.getLineCount());
  }
  static _mergeAdjacent(e, t, i) {
    if (!e || e.length === 0)
      return [];
    let r = [], o = 0;
    for (let u = 0, c = e.length; u < c; u++) {
      const h = e[u], d = h.originalStartLineNumber, f = h.originalEndLineNumber, p = h.modifiedStartLineNumber, g = h.modifiedEndLineNumber;
      let _ = [], m = 0;
      {
        const v = f === 0 ? d : d - 1, C = g === 0 ? p : p - 1;
        let y = 1, w = 1;
        if (u > 0) {
          const E = e[u - 1];
          E.originalEndLineNumber === 0 ? y = E.originalStartLineNumber + 1 : y = E.originalEndLineNumber + 1, E.modifiedEndLineNumber === 0 ? w = E.modifiedStartLineNumber + 1 : w = E.modifiedEndLineNumber + 1;
        }
        let L = v - Py + 1, S = C - Py + 1;
        if (L < y) {
          const E = y - L;
          L = L + E, S = S + E;
        }
        if (S < w) {
          const E = w - S;
          L = L + E, S = S + E;
        }
        _[m++] = new Gm(L, v, S, C);
      }
      f !== 0 && (_[m++] = new Gm(d, f, 0, 0)), g !== 0 && (_[m++] = new Gm(0, 0, p, g));
      {
        const v = f === 0 ? d + 1 : f + 1, C = g === 0 ? p + 1 : g + 1;
        let y = t, w = i;
        if (u + 1 < c) {
          const E = e[u + 1];
          E.originalEndLineNumber === 0 ? y = E.originalStartLineNumber : y = E.originalStartLineNumber - 1, E.modifiedEndLineNumber === 0 ? w = E.modifiedStartLineNumber : w = E.modifiedStartLineNumber - 1;
        }
        let L = v + Py - 1, S = C + Py - 1;
        if (L > y) {
          const E = y - L;
          L = L + E, S = S + E;
        }
        if (S > w) {
          const E = w - S;
          L = L + E, S = S + E;
        }
        _[m++] = new Gm(v, L, C, S);
      }
      r[o++] = new n1(_);
    }
    let s = r[0].entries, a = [], l = 0;
    for (let u = 1, c = r.length; u < c; u++) {
      const h = r[u].entries, d = s[s.length - 1], f = h[0];
      if (d.getType() === 0 && f.getType() === 0 && f.originalLineStart <= d.originalLineEnd) {
        s[s.length - 1] = new Gm(d.originalLineStart, f.originalLineEnd, d.modifiedLineStart, f.modifiedLineEnd), s = s.concat(h.slice(1));
        continue;
      }
      a[l++] = new n1(s), s = h;
    }
    return a[l++] = new n1(s), a;
  }
  _findDiffIndex(e) {
    const t = e.lineNumber;
    for (let i = 0, r = this._diffs.length; i < r; i++) {
      const o = this._diffs[i].entries, s = o[o.length - 1].modifiedLineEnd;
      if (t <= s)
        return i;
    }
    return 0;
  }
  _render() {
    const e = this._diffEditor.getOriginalEditor().getOptions(), t = this._diffEditor.getModifiedEditor().getOptions(), i = this._diffEditor.getOriginalEditor().getModel(), r = this._diffEditor.getModifiedEditor().getModel(), o = i.getOptions(), s = r.getOptions();
    if (!this._isVisible || !i || !r) {
      Ps(this._content.domNode), this._currentDiff = null, this.scrollbar.scanDomNode();
      return;
    }
    this._diffEditor.updateOptions({ readOnly: !0 });
    const a = this._findDiffIndex(this._diffEditor.getPosition());
    if (this._diffs[a] === this._currentDiff)
      return;
    this._currentDiff = this._diffs[a];
    const l = this._diffs[a].entries;
    let u = document.createElement("div");
    u.className = "diff-review-table", u.setAttribute("role", "list"), u.setAttribute("aria-label", 'Difference review. Use "Stage | Unstage | Revert Selected Ranges" commands'), oo.applyFontInfoSlow(u, t.get(
      40
      /* fontInfo */
    ));
    let c = 0, h = 0, d = 0, f = 0;
    for (let S = 0, E = l.length; S < E; S++) {
      const D = l[S], x = D.originalLineStart, R = D.originalLineEnd, A = D.modifiedLineStart, M = D.modifiedLineEnd;
      x !== 0 && (c === 0 || x < c) && (c = x), R !== 0 && (h === 0 || R > h) && (h = R), A !== 0 && (d === 0 || A < d) && (d = A), M !== 0 && (f === 0 || M > f) && (f = M);
    }
    let p = document.createElement("div");
    p.className = "diff-review-row";
    let g = document.createElement("div");
    g.className = "diff-review-cell diff-review-summary";
    const _ = h - c + 1, m = f - d + 1;
    g.appendChild(document.createTextNode(`${a + 1}/${this._diffs.length}: @@ -${c},${_} +${d},${m} @@`)), p.setAttribute("data-line", String(d));
    const v = (S) => S === 0 ? b("no_lines_changed", "no lines changed") : S === 1 ? b("one_line_changed", "1 line changed") : b("more_lines_changed", "{0} lines changed", S), C = v(_), y = v(m);
    p.setAttribute("aria-label", b({
      key: "header",
      comment: [
        "This is the ARIA label for a git diff header.",
        "A git diff header looks like this: @@ -154,12 +159,39 @@.",
        "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
        "Variables 0 and 1 refer to the diff index out of total number of diffs.",
        "Variables 2 and 4 will be numbers (a line number).",
        'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
      ]
    }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", a + 1, this._diffs.length, c, C, d, y)), p.appendChild(g), p.setAttribute("role", "listitem"), u.appendChild(p);
    const w = t.get(
      56
      /* lineHeight */
    );
    let L = d;
    for (let S = 0, E = l.length; S < E; S++) {
      const D = l[S];
      ku._renderSection(u, D, L, w, this._width, e, i, o, t, r, s), D.modifiedLineStart !== 0 && (L = D.modifiedLineEnd);
    }
    Ps(this._content.domNode), this._content.domNode.appendChild(u), this.scrollbar.scanDomNode();
  }
  static _renderSection(e, t, i, r, o, s, a, l, u, c, h) {
    const d = t.getType();
    let f = "diff-review-row", p = "";
    const g = "diff-review-spacer";
    let _ = null;
    switch (d) {
      case 1:
        f = "diff-review-row line-insert", p = " char-insert", _ = cpe;
        break;
      case 2:
        f = "diff-review-row line-delete", p = " char-delete", _ = hpe;
        break;
    }
    const m = t.originalLineStart, v = t.originalLineEnd, C = t.modifiedLineStart, y = t.modifiedLineEnd, w = Math.max(y - C, v - m), L = s.get(
      128
      /* layoutInfo */
    ), S = L.glyphMarginWidth + L.lineNumbersWidth, E = u.get(
      128
      /* layoutInfo */
    ), D = 10 + E.glyphMarginWidth + E.lineNumbersWidth;
    for (let x = 0; x <= w; x++) {
      const R = m === 0 ? 0 : m + x, A = C === 0 ? 0 : C + x, M = document.createElement("div");
      M.style.minWidth = o + "px", M.className = f, M.setAttribute("role", "listitem"), A !== 0 && (i = A), M.setAttribute("data-line", String(i));
      let z = document.createElement("div");
      z.className = "diff-review-cell", z.style.height = `${r}px`, M.appendChild(z);
      const j = document.createElement("span");
      j.style.width = S + "px", j.style.minWidth = S + "px", j.className = "diff-review-line-number" + p, R !== 0 ? j.appendChild(document.createTextNode(String(R))) : j.innerText = "", z.appendChild(j);
      const $ = document.createElement("span");
      $.style.width = D + "px", $.style.minWidth = D + "px", $.style.paddingRight = "10px", $.className = "diff-review-line-number" + p, A !== 0 ? $.appendChild(document.createTextNode(String(A))) : $.innerText = "", z.appendChild($);
      const k = document.createElement("span");
      if (k.className = g, _) {
        const Y = document.createElement("span");
        Y.className = ma.asClassName(_), Y.innerText = "", k.appendChild(Y);
      } else
        k.innerText = "";
      z.appendChild(k);
      let ae;
      if (A !== 0) {
        let Y = this._renderLine(c, u, h.tabSize, A);
        ku._ttPolicy && (Y = ku._ttPolicy.createHTML(Y)), z.insertAdjacentHTML("beforeend", Y), ae = c.getLineContent(A);
      } else {
        let Y = this._renderLine(a, s, l.tabSize, R);
        ku._ttPolicy && (Y = ku._ttPolicy.createHTML(Y)), z.insertAdjacentHTML("beforeend", Y), ae = a.getLineContent(R);
      }
      ae.length === 0 && (ae = b("blankLine", "blank"));
      let re = "";
      switch (d) {
        case 0:
          R === A ? re = b({ key: "unchangedLine", comment: ["The placeholders are contents of the line and should not be translated."] }, "{0} unchanged line {1}", ae, R) : re = b("equalLine", "{0} original line {1} modified line {2}", ae, R, A);
          break;
        case 1:
          re = b("insertLine", "+ {0} modified line {1}", ae, A);
          break;
        case 2:
          re = b("deleteLine", "- {0} original line {1}", ae, R);
          break;
      }
      M.setAttribute("aria-label", re), e.appendChild(M);
    }
  }
  static _renderLine(e, t, i, r) {
    const o = e.getLineContent(r), s = t.get(
      40
      /* fontInfo */
    ), a = eo.createEmpty(o), l = Yo.isBasicASCII(o, e.mightContainNonBasicASCII()), u = Yo.containsRTL(o, l, e.mightContainRTL());
    return cE(new Pg(s.isMonospace && !t.get(
      27
      /* disableMonospaceOptimizations */
    ), s.canUseHalfwidthRightwardsArrow, o, !1, l, u, 0, a, [], i, 0, s.spaceWidth, s.middotWidth, s.wsmiddotWidth, t.get(
      103
      /* stopRenderingLineAfter */
    ), t.get(
      86
      /* renderWhitespace */
    ), t.get(
      80
      /* renderControlCharacters */
    ), t.get(
      41
      /* fontLigatures */
    ) !== vs.OFF, null)).html;
  }
}
ku._ttPolicy = (i1 = window.trustedTypes) === null || i1 === void 0 ? void 0 : i1.createPolicy("diffReview", { createHTML: (n) => n });
wa((n, e) => {
  const t = n.getColor(e7);
  t && e.addRule(`.monaco-diff-editor .diff-review-line-number { color: ${t}; }`);
  const i = n.getColor(OE);
  i && e.addRule(`.monaco-diff-editor .diff-review-shadow { box-shadow: ${i} 0 -6px 6px -6px inset; }`);
});
class fpe extends q_ {
  constructor() {
    super({
      id: "editor.action.diffReview.next",
      label: b("editor.action.diffReview.next", "Go to Next Difference"),
      alias: "Go to Next Difference",
      precondition: fr.has("isInDiffEditor"),
      kbOpts: {
        kbExpr: null,
        primary: 65,
        weight: 100
        /* EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = S7(e);
    i && i.diffReviewNext();
  }
}
class ppe extends q_ {
  constructor() {
    super({
      id: "editor.action.diffReview.prev",
      label: b("editor.action.diffReview.prev", "Go to Previous Difference"),
      alias: "Go to Previous Difference",
      precondition: fr.has("isInDiffEditor"),
      kbOpts: {
        kbExpr: null,
        primary: 1089,
        weight: 100
        /* EditorContrib */
      }
    });
  }
  run(e, t) {
    const i = S7(e);
    i && i.diffReviewPrev();
  }
}
function S7(n) {
  const e = n.get(mr), t = e.listDiffEditors(), i = e.getActiveCodeEditor();
  if (!i)
    return null;
  for (let r = 0, o = t.length; r < o; r++) {
    const s = t[r];
    if (s.getModifiedEditor().getId() === i.getId() || s.getOriginalEditor().getId() === i.getId())
      return s;
  }
  return null;
}
S3(fpe);
S3(ppe);
const Bg = Vt("contextViewService"), FE = Vt("contextMenuService");
var r1 = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class gpe extends Ce {
  constructor(e, t, i, r, o, s) {
    super(), this._viewZoneId = e, this._marginDomNode = t, this.editor = i, this.diff = r, this._contextMenuService = o, this._clipboardService = s, this._visibility = !1, this._marginDomNode.style.zIndex = "10", this._diffActions = document.createElement("div"), this._diffActions.className = Hi.lightBulb.classNames + " lightbulb-glyph", this._diffActions.style.position = "absolute";
    const a = i.getOption(
      56
      /* lineHeight */
    ), l = i.getModel().getEOL();
    this._diffActions.style.right = "0px", this._diffActions.style.visibility = "hidden", this._diffActions.style.height = `${a}px`, this._diffActions.style.lineHeight = `${a}px`, this._marginDomNode.appendChild(this._diffActions);
    const u = [];
    u.push(new zl("diff.clipboard.copyDeletedContent", r.originalEndLineNumber > r.modifiedStartLineNumber ? b("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : b("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line"), void 0, !0, () => r1(this, void 0, void 0, function* () {
      const p = new G(r.originalStartLineNumber, 1, r.originalEndLineNumber + 1, 1), g = r.originalModel.getValueInRange(p);
      yield this._clipboardService.writeText(g);
    })));
    let c = 0, h;
    r.originalEndLineNumber > r.modifiedStartLineNumber && (h = new zl("diff.clipboard.copyDeletedLineContent", b("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", r.originalStartLineNumber), void 0, !0, () => r1(this, void 0, void 0, function* () {
      const p = r.originalModel.getLineContent(r.originalStartLineNumber + c);
      yield this._clipboardService.writeText(p);
    })), u.push(h)), i.getOption(
      78
      /* readOnly */
    ) || u.push(new zl("diff.inline.revertChange", b("diff.inline.revertChange.label", "Revert this change"), void 0, !0, () => r1(this, void 0, void 0, function* () {
      const p = new G(r.originalStartLineNumber, 1, r.originalEndLineNumber, r.originalModel.getLineMaxColumn(r.originalEndLineNumber)), g = r.originalModel.getValueInRange(p);
      if (r.modifiedEndLineNumber === 0) {
        const _ = i.getModel().getLineMaxColumn(r.modifiedStartLineNumber);
        i.executeEdits("diffEditor", [
          {
            range: new G(r.modifiedStartLineNumber, _, r.modifiedStartLineNumber, _),
            text: l + g
          }
        ]);
      } else {
        const _ = i.getModel().getLineMaxColumn(r.modifiedEndLineNumber);
        i.executeEdits("diffEditor", [
          {
            range: new G(r.modifiedStartLineNumber, 1, r.modifiedEndLineNumber, _),
            text: g
          }
        ]);
      }
    })));
    const f = (p, g) => {
      this._contextMenuService.showContextMenu({
        getAnchor: () => ({
          x: p,
          y: g
        }),
        getActions: () => (h && (h.label = b("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", r.originalStartLineNumber + c)), u),
        autoSelectFirstItem: !0
      });
    };
    this._register(io(this._diffActions, "mousedown", (p) => {
      const { top: g, height: _ } = qa(this._diffActions);
      let m = Math.floor(a / 3);
      p.preventDefault(), f(p.posx, g + _ + m);
    })), this._register(i.onMouseMove((p) => {
      p.target.type === 8 || p.target.type === 5 ? p.target.detail.viewZoneId === this._viewZoneId ? (this.visibility = !0, c = this._updateLightBulbPosition(this._marginDomNode, p.event.browserEvent.y, a)) : this.visibility = !1 : this.visibility = !1;
    })), this._register(i.onMouseDown((p) => {
      p.event.rightButton && (p.target.type === 8 || p.target.type === 5) && p.target.detail.viewZoneId === this._viewZoneId && (p.event.preventDefault(), c = this._updateLightBulbPosition(this._marginDomNode, p.event.browserEvent.y, a), f(p.event.posx, p.event.posy + a));
    }));
  }
  get visibility() {
    return this._visibility;
  }
  set visibility(e) {
    this._visibility !== e && (this._visibility = e, e ? this._diffActions.style.visibility = "visible" : this._diffActions.style.visibility = "hidden");
  }
  _updateLightBulbPosition(e, t, i) {
    const { top: r } = qa(e), o = t - r, s = Math.floor(o / i), a = s * i;
    if (this._diffActions.style.top = `${a}px`, this.diff.viewLineCounts) {
      let l = 0;
      for (let u = 0; u < this.diff.viewLineCounts.length; u++)
        if (l += this.diff.viewLineCounts[u], s < l)
          return u;
    }
    return s;
  }
}
const kE = Vt("clipboardService");
class mpe {
  constructor(e) {
    this.callback = e;
  }
  report(e) {
    this._value = e, this.callback(this._value);
  }
}
mpe.None = Object.freeze({ report() {
} });
const WE = Vt("editorProgressService");
var vpe = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Lu = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, o1;
class vW {
  constructor(e, t) {
    this._contextMenuService = e, this._clipboardService = t, this._zones = [], this._inlineDiffMargins = [], this._zonesMap = {}, this._decorations = [];
  }
  getForeignViewZones(e) {
    return e.filter((t) => !this._zonesMap[String(t.id)]);
  }
  clean(e) {
    this._zones.length > 0 && e.changeViewZones((t) => {
      for (const i of this._zones)
        t.removeZone(i);
    }), this._zones = [], this._zonesMap = {}, this._decorations = e.deltaDecorations(this._decorations, []);
  }
  apply(e, t, i, r) {
    const o = r ? kI.capture(e) : null;
    e.changeViewZones((s) => {
      for (const a of this._zones)
        s.removeZone(a);
      for (const a of this._inlineDiffMargins)
        a.dispose();
      this._zones = [], this._zonesMap = {}, this._inlineDiffMargins = [];
      for (let a = 0, l = i.zones.length; a < l; a++) {
        const u = i.zones[a];
        u.suppressMouseDown = !0;
        const c = s.addZone(u);
        this._zones.push(c), this._zonesMap[String(c)] = !0, i.zones[a].diff && u.marginDomNode && (u.suppressMouseDown = !1, this._inlineDiffMargins.push(new gpe(c, u.marginDomNode, e, i.zones[a].diff, this._contextMenuService, this._clipboardService)));
      }
    }), o && o.restore(e), this._decorations = e.deltaDecorations(this._decorations, i.decorations), t && t.setZones(i.overviewZones);
  }
}
let _pe = 0;
const Cpe = Vg("diff-insert", Hi.add, b("diffInsertIcon", "Line decoration for inserts in the diff editor.")), E7 = Vg("diff-remove", Hi.remove, b("diffRemoveIcon", "Line decoration for removals in the diff editor.")), _W = (o1 = window.trustedTypes) === null || o1 === void 0 ? void 0 : o1.createPolicy("diffEditorWidget", { createHTML: (n) => n });
let dh = class lr extends Ce {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d) {
    super(), this._editorProgressService = d, this._onDidDispose = this._register(new q()), this.onDidDispose = this._onDidDispose.event, this._onDidUpdateDiff = this._register(new q()), this.onDidUpdateDiff = this._onDidUpdateDiff.event, this._onDidContentSizeChange = this._register(new q()), this._lastOriginalWarning = null, this._lastModifiedWarning = null, this._editorWorkerService = o, this._codeEditorService = l, this._contextKeyService = this._register(s.createScoped(e)), this._instantiationService = a.createChild(new f_([xi, this._contextKeyService])), this._contextKeyService.createKey("isInDiffEditor", !0), this._themeService = u, this._notificationService = c, this._id = ++_pe, this._state = 0, this._updatingDiffProgress = null, this._domElement = e, t = t || {}, this._renderSideBySide = !0, typeof t.renderSideBySide < "u" && (this._renderSideBySide = t.renderSideBySide), this._maxComputationTime = 5e3, typeof t.maxComputationTime < "u" && (this._maxComputationTime = t.maxComputationTime), this._ignoreTrimWhitespace = !0, typeof t.ignoreTrimWhitespace < "u" && (this._ignoreTrimWhitespace = t.ignoreTrimWhitespace), this._renderIndicators = !0, typeof t.renderIndicators < "u" && (this._renderIndicators = t.renderIndicators), this._originalIsEditable = ze(t.originalEditable, !1), this._diffCodeLens = ze(t.diffCodeLens, !1), this._diffWordWrap = wW(t.diffWordWrap, "inherit"), typeof t.isInEmbeddedEditor < "u" ? this._contextKeyService.createKey("isInEmbeddedDiffEditor", t.isInEmbeddedEditor) : this._contextKeyService.createKey("isInEmbeddedDiffEditor", !1), this._renderOverviewRuler = !0, typeof t.renderOverviewRuler < "u" && (this._renderOverviewRuler = !!t.renderOverviewRuler), this._updateDecorationsRunner = this._register(new ro(() => this._updateDecorations(), 0)), this._containerDomElement = document.createElement("div"), this._containerDomElement.className = lr._getClassName(this._themeService.getColorTheme(), this._renderSideBySide), this._containerDomElement.style.position = "relative", this._containerDomElement.style.height = "100%", this._domElement.appendChild(this._containerDomElement), this._overviewViewportDomElement = St(document.createElement("div")), this._overviewViewportDomElement.setClassName("diffViewport"), this._overviewViewportDomElement.setPosition("absolute"), this._overviewDomElement = document.createElement("div"), this._overviewDomElement.className = "diffOverview", this._overviewDomElement.style.position = "absolute", this._overviewDomElement.appendChild(this._overviewViewportDomElement.domNode), this._register(io(this._overviewDomElement, "mousedown", (p) => {
      this._modifiedEditor.delegateVerticalScrollbarMouseDown(p);
    })), this._renderOverviewRuler && this._containerDomElement.appendChild(this._overviewDomElement), this._originalDomNode = document.createElement("div"), this._originalDomNode.className = "editor original", this._originalDomNode.style.position = "absolute", this._originalDomNode.style.height = "100%", this._containerDomElement.appendChild(this._originalDomNode), this._modifiedDomNode = document.createElement("div"), this._modifiedDomNode.className = "editor modified", this._modifiedDomNode.style.position = "absolute", this._modifiedDomNode.style.height = "100%", this._containerDomElement.appendChild(this._modifiedDomNode), this._beginUpdateDecorationsTimeout = -1, this._currentlyChangingViewZones = !1, this._diffComputationToken = 0, this._originalEditorState = new vW(h, r), this._modifiedEditorState = new vW(h, r), this._isVisible = !0, this._isHandlingScrollEvent = !1, this._elementSizeObserver = this._register(new R3(this._containerDomElement, t.dimension, () => this._onDidContainerSizeChanged())), t.automaticLayout && this._elementSizeObserver.startObserving(), this._diffComputationResult = null, this._originalEditor = this._createLeftHandSideEditor(t, i.originalEditor || {}), this._modifiedEditor = this._createRightHandSideEditor(t, i.modifiedEditor || {}), this._originalOverviewRuler = null, this._modifiedOverviewRuler = null, this._reviewPane = new ku(this), this._containerDomElement.appendChild(this._reviewPane.domNode.domNode), this._containerDomElement.appendChild(this._reviewPane.shadow.domNode), this._containerDomElement.appendChild(this._reviewPane.actionBarContainer.domNode), this._enableSplitViewResizing = !0, typeof t.enableSplitViewResizing < "u" && (this._enableSplitViewResizing = t.enableSplitViewResizing), this._renderSideBySide ? this._setStrategy(new zu(this._createDataSource(), this._enableSplitViewResizing)) : this._setStrategy(new yW(this._createDataSource(), this._enableSplitViewResizing)), this._register(u.onDidColorThemeChange((p) => {
      this._strategy && this._strategy.applyColors(p) && this._updateDecorationsRunner.schedule(), this._containerDomElement.className = lr._getClassName(this._themeService.getColorTheme(), this._renderSideBySide);
    }));
    const f = xp.getDiffEditorContributions();
    for (const p of f)
      try {
        this._register(a.createInstance(p.ctor, this));
      } catch (g) {
        Pi(g);
      }
    this._codeEditorService.addDiffEditor(this);
  }
  _setState(e) {
    this._state !== e && (this._state = e, this._updatingDiffProgress && (this._updatingDiffProgress.done(), this._updatingDiffProgress = null), this._state === 1 && (this._updatingDiffProgress = this._editorProgressService.show(!0, 1e3)));
  }
  diffReviewNext() {
    this._reviewPane.next();
  }
  diffReviewPrev() {
    this._reviewPane.prev();
  }
  static _getClassName(e, t) {
    let i = "monaco-diff-editor monaco-editor-background ";
    return t && (i += "side-by-side "), i += kb(e.type), i;
  }
  _recreateOverviewRulers() {
    this._renderOverviewRuler && (this._originalOverviewRuler && (this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode()), this._originalOverviewRuler.dispose()), this._originalEditor.hasModel() && (this._originalOverviewRuler = this._originalEditor.createOverviewRuler("original diffOverviewRuler"), this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode())), this._modifiedOverviewRuler && (this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode()), this._modifiedOverviewRuler.dispose()), this._modifiedEditor.hasModel() && (this._modifiedOverviewRuler = this._modifiedEditor.createOverviewRuler("modified diffOverviewRuler"), this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode())), this._layoutOverviewRulers());
  }
  _createLeftHandSideEditor(e, t) {
    const i = this._createInnerEditor(this._instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(e), t);
    this._register(i.onDidScrollChange((o) => {
      this._isHandlingScrollEvent || !o.scrollTopChanged && !o.scrollLeftChanged && !o.scrollHeightChanged || (this._isHandlingScrollEvent = !0, this._modifiedEditor.setScrollPosition({
        scrollLeft: o.scrollLeft,
        scrollTop: o.scrollTop
      }), this._isHandlingScrollEvent = !1, this._layoutOverviewViewport());
    })), this._register(i.onDidChangeViewZones(() => {
      this._onViewZonesChanged();
    })), this._register(i.onDidChangeConfiguration((o) => {
      i.getModel() && (o.hasChanged(
        40
        /* fontInfo */
      ) && this._updateDecorationsRunner.schedule(), o.hasChanged(
        129
        /* wrappingInfo */
      ) && (this._updateDecorationsRunner.cancel(), this._updateDecorations()));
    })), this._register(i.onDidChangeModelContent(() => {
      this._isVisible && this._beginUpdateDecorationsSoon();
    }));
    const r = this._contextKeyService.createKey("isInDiffLeftEditor", i.hasWidgetFocus());
    return this._register(i.onDidFocusEditorWidget(() => r.set(!0))), this._register(i.onDidBlurEditorWidget(() => r.set(!1))), this._register(i.onDidContentSizeChange((o) => {
      const s = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + lr.ONE_OVERVIEW_WIDTH, a = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: a,
        contentWidth: s,
        contentHeightChanged: o.contentHeightChanged,
        contentWidthChanged: o.contentWidthChanged
      });
    })), i;
  }
  _createRightHandSideEditor(e, t) {
    const i = this._createInnerEditor(this._instantiationService, this._modifiedDomNode, this._adjustOptionsForRightHandSide(e), t);
    this._register(i.onDidScrollChange((o) => {
      this._isHandlingScrollEvent || !o.scrollTopChanged && !o.scrollLeftChanged && !o.scrollHeightChanged || (this._isHandlingScrollEvent = !0, this._originalEditor.setScrollPosition({
        scrollLeft: o.scrollLeft,
        scrollTop: o.scrollTop
      }), this._isHandlingScrollEvent = !1, this._layoutOverviewViewport());
    })), this._register(i.onDidChangeViewZones(() => {
      this._onViewZonesChanged();
    })), this._register(i.onDidChangeConfiguration((o) => {
      i.getModel() && (o.hasChanged(
        40
        /* fontInfo */
      ) && this._updateDecorationsRunner.schedule(), o.hasChanged(
        129
        /* wrappingInfo */
      ) && (this._updateDecorationsRunner.cancel(), this._updateDecorations()));
    })), this._register(i.onDidChangeModelContent(() => {
      this._isVisible && this._beginUpdateDecorationsSoon();
    })), this._register(i.onDidChangeModelOptions((o) => {
      o.tabSize && this._updateDecorationsRunner.schedule();
    }));
    const r = this._contextKeyService.createKey("isInDiffRightEditor", i.hasWidgetFocus());
    return this._register(i.onDidFocusEditorWidget(() => r.set(!0))), this._register(i.onDidBlurEditorWidget(() => r.set(!1))), this._register(i.onDidContentSizeChange((o) => {
      const s = this._originalEditor.getContentWidth() + this._modifiedEditor.getContentWidth() + lr.ONE_OVERVIEW_WIDTH, a = Math.max(this._modifiedEditor.getContentHeight(), this._originalEditor.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: a,
        contentWidth: s,
        contentHeightChanged: o.contentHeightChanged,
        contentWidthChanged: o.contentWidthChanged
      });
    })), i;
  }
  _createInnerEditor(e, t, i, r) {
    return e.createInstance(tS, t, i, r);
  }
  dispose() {
    this._codeEditorService.removeDiffEditor(this), this._beginUpdateDecorationsTimeout !== -1 && (window.clearTimeout(this._beginUpdateDecorationsTimeout), this._beginUpdateDecorationsTimeout = -1), this._cleanViewZonesAndDecorations(), this._originalOverviewRuler && (this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode()), this._originalOverviewRuler.dispose()), this._modifiedOverviewRuler && (this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode()), this._modifiedOverviewRuler.dispose()), this._overviewDomElement.removeChild(this._overviewViewportDomElement.domNode), this._renderOverviewRuler && this._containerDomElement.removeChild(this._overviewDomElement), this._containerDomElement.removeChild(this._originalDomNode), this._originalEditor.dispose(), this._containerDomElement.removeChild(this._modifiedDomNode), this._modifiedEditor.dispose(), this._strategy.dispose(), this._containerDomElement.removeChild(this._reviewPane.domNode.domNode), this._containerDomElement.removeChild(this._reviewPane.shadow.domNode), this._containerDomElement.removeChild(this._reviewPane.actionBarContainer.domNode), this._reviewPane.dispose(), this._domElement.removeChild(this._containerDomElement), this._onDidDispose.fire(), super.dispose();
  }
  //------------ begin IDiffEditor methods
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return $_.IDiffEditor;
  }
  getLineChanges() {
    return this._diffComputationResult ? this._diffComputationResult.changes : null;
  }
  getOriginalEditor() {
    return this._originalEditor;
  }
  getModifiedEditor() {
    return this._modifiedEditor;
  }
  updateOptions(e) {
    let t = !1;
    typeof e.renderSideBySide < "u" && this._renderSideBySide !== e.renderSideBySide && (this._renderSideBySide = e.renderSideBySide, t = !0), typeof e.maxComputationTime < "u" && (this._maxComputationTime = e.maxComputationTime, this._isVisible && this._beginUpdateDecorationsSoon());
    let i = !1;
    typeof e.ignoreTrimWhitespace < "u" && this._ignoreTrimWhitespace !== e.ignoreTrimWhitespace && (this._ignoreTrimWhitespace = e.ignoreTrimWhitespace, i = !0), typeof e.renderIndicators < "u" && this._renderIndicators !== e.renderIndicators && (this._renderIndicators = e.renderIndicators, i = !0), i && this._beginUpdateDecorations(), this._originalIsEditable = ze(e.originalEditable, this._originalIsEditable), this._diffCodeLens = ze(e.diffCodeLens, this._diffCodeLens), this._diffWordWrap = wW(e.diffWordWrap, this._diffWordWrap), this._modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(e)), this._originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(e)), typeof e.enableSplitViewResizing < "u" && (this._enableSplitViewResizing = e.enableSplitViewResizing), this._strategy.setEnableSplitViewResizing(this._enableSplitViewResizing), t && (this._renderSideBySide ? this._setStrategy(new zu(this._createDataSource(), this._enableSplitViewResizing)) : this._setStrategy(new yW(this._createDataSource(), this._enableSplitViewResizing)), this._containerDomElement.className = lr._getClassName(this._themeService.getColorTheme(), this._renderSideBySide)), typeof e.renderOverviewRuler < "u" && this._renderOverviewRuler !== e.renderOverviewRuler && (this._renderOverviewRuler = e.renderOverviewRuler, this._renderOverviewRuler ? this._containerDomElement.appendChild(this._overviewDomElement) : this._containerDomElement.removeChild(this._overviewDomElement));
  }
  getModel() {
    return {
      original: this._originalEditor.getModel(),
      modified: this._modifiedEditor.getModel()
    };
  }
  setModel(e) {
    if (e && (!e.original || !e.modified))
      throw new Error(e.original ? "DiffEditorWidget.setModel: Modified model is null" : "DiffEditorWidget.setModel: Original model is null");
    this._cleanViewZonesAndDecorations(), this._originalEditor.setModel(e ? e.original : null), this._modifiedEditor.setModel(e ? e.modified : null), this._updateDecorationsRunner.cancel(), e && (this._originalEditor.setScrollTop(0), this._modifiedEditor.setScrollTop(0)), this._diffComputationResult = null, this._diffComputationToken++, this._setState(
      0
      /* Idle */
    ), e && (this._recreateOverviewRulers(), this._beginUpdateDecorations()), this._layoutOverviewViewport();
  }
  getDomNode() {
    return this._domElement;
  }
  getVisibleColumnFromPosition(e) {
    return this._modifiedEditor.getVisibleColumnFromPosition(e);
  }
  getPosition() {
    return this._modifiedEditor.getPosition();
  }
  setPosition(e) {
    this._modifiedEditor.setPosition(e);
  }
  revealLine(e, t = 0) {
    this._modifiedEditor.revealLine(e, t);
  }
  revealLineInCenter(e, t = 0) {
    this._modifiedEditor.revealLineInCenter(e, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealLineInCenterIfOutsideViewport(e, t);
  }
  revealLineNearTop(e, t = 0) {
    this._modifiedEditor.revealLineNearTop(e, t);
  }
  revealPosition(e, t = 0) {
    this._modifiedEditor.revealPosition(e, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._modifiedEditor.revealPositionInCenter(e, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealPositionInCenterIfOutsideViewport(e, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._modifiedEditor.revealPositionNearTop(e, t);
  }
  getSelection() {
    return this._modifiedEditor.getSelection();
  }
  getSelections() {
    return this._modifiedEditor.getSelections();
  }
  setSelection(e) {
    this._modifiedEditor.setSelection(e);
  }
  setSelections(e) {
    this._modifiedEditor.setSelections(e);
  }
  revealLines(e, t, i = 0) {
    this._modifiedEditor.revealLines(e, t, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._modifiedEditor.revealLinesInCenter(e, t, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._modifiedEditor.revealLinesInCenterIfOutsideViewport(e, t, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._modifiedEditor.revealLinesNearTop(e, t, i);
  }
  revealRange(e, t = 0, i = !1, r = !0) {
    this._modifiedEditor.revealRange(e, t, i, r);
  }
  revealRangeInCenter(e, t = 0) {
    this._modifiedEditor.revealRangeInCenter(e, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealRangeInCenterIfOutsideViewport(e, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._modifiedEditor.revealRangeNearTop(e, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._modifiedEditor.revealRangeNearTopIfOutsideViewport(e, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._modifiedEditor.revealRangeAtTop(e, t);
  }
  getSupportedActions() {
    return this._modifiedEditor.getSupportedActions();
  }
  saveViewState() {
    const e = this._originalEditor.saveViewState(), t = this._modifiedEditor.saveViewState();
    return {
      original: e,
      modified: t
    };
  }
  restoreViewState(e) {
    if (e && e.original && e.modified) {
      const t = e;
      this._originalEditor.restoreViewState(t.original), this._modifiedEditor.restoreViewState(t.modified);
    }
  }
  layout(e) {
    this._elementSizeObserver.observe(e);
  }
  focus() {
    this._modifiedEditor.focus();
  }
  hasTextFocus() {
    return this._originalEditor.hasTextFocus() || this._modifiedEditor.hasTextFocus();
  }
  trigger(e, t, i) {
    this._modifiedEditor.trigger(e, t, i);
  }
  changeDecorations(e) {
    return this._modifiedEditor.changeDecorations(e);
  }
  //------------ end IDiffEditor methods
  //------------ begin layouting methods
  _onDidContainerSizeChanged() {
    this._doLayout();
  }
  _getReviewHeight() {
    return this._reviewPane.isVisible() ? this._elementSizeObserver.getHeight() : 0;
  }
  _layoutOverviewRulers() {
    if (!this._renderOverviewRuler || !this._originalOverviewRuler || !this._modifiedOverviewRuler)
      return;
    const e = this._elementSizeObserver.getHeight(), t = this._getReviewHeight(), i = lr.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * lr.ONE_OVERVIEW_WIDTH;
    this._modifiedEditor.getLayoutInfo() && (this._originalOverviewRuler.setLayout({
      top: 0,
      width: lr.ONE_OVERVIEW_WIDTH,
      right: i + lr.ONE_OVERVIEW_WIDTH,
      height: e - t
    }), this._modifiedOverviewRuler.setLayout({
      top: 0,
      right: 0,
      width: lr.ONE_OVERVIEW_WIDTH,
      height: e - t
    }));
  }
  //------------ end layouting methods
  _onViewZonesChanged() {
    this._currentlyChangingViewZones || this._updateDecorationsRunner.schedule();
  }
  _beginUpdateDecorationsSoon() {
    this._beginUpdateDecorationsTimeout !== -1 && (window.clearTimeout(this._beginUpdateDecorationsTimeout), this._beginUpdateDecorationsTimeout = -1), this._beginUpdateDecorationsTimeout = window.setTimeout(() => this._beginUpdateDecorations(), lr.UPDATE_DIFF_DECORATIONS_DELAY);
  }
  static _equals(e, t) {
    return !e && !t ? !0 : !e || !t ? !1 : e.toString() === t.toString();
  }
  _beginUpdateDecorations() {
    this._beginUpdateDecorationsTimeout = -1;
    const e = this._originalEditor.getModel(), t = this._modifiedEditor.getModel();
    if (!e || !t)
      return;
    this._diffComputationToken++;
    const i = this._diffComputationToken;
    if (this._setState(
      1
      /* ComputingDiff */
    ), !this._editorWorkerService.canComputeDiff(e.uri, t.uri)) {
      (!lr._equals(e.uri, this._lastOriginalWarning) || !lr._equals(t.uri, this._lastModifiedWarning)) && (this._lastOriginalWarning = e.uri, this._lastModifiedWarning = t.uri, this._notificationService.warn(b("diff.tooLarge", "Cannot compare files because one file is too large.")));
      return;
    }
    this._editorWorkerService.computeDiff(e.uri, t.uri, this._ignoreTrimWhitespace, this._maxComputationTime).then((r) => {
      i === this._diffComputationToken && e === this._originalEditor.getModel() && t === this._modifiedEditor.getModel() && (this._setState(
        2
        /* DiffComputed */
      ), this._diffComputationResult = r, this._updateDecorationsRunner.schedule(), this._onDidUpdateDiff.fire());
    }, (r) => {
      i === this._diffComputationToken && e === this._originalEditor.getModel() && t === this._modifiedEditor.getModel() && (this._setState(
        2
        /* DiffComputed */
      ), this._diffComputationResult = null, this._updateDecorationsRunner.schedule());
    });
  }
  _cleanViewZonesAndDecorations() {
    this._originalEditorState.clean(this._originalEditor), this._modifiedEditorState.clean(this._modifiedEditor);
  }
  _updateDecorations() {
    if (!this._originalEditor.getModel() || !this._modifiedEditor.getModel())
      return;
    const e = this._diffComputationResult ? this._diffComputationResult.changes : [], t = this._originalEditorState.getForeignViewZones(this._originalEditor.getWhitespaces()), i = this._modifiedEditorState.getForeignViewZones(this._modifiedEditor.getWhitespaces()), r = this._strategy.getEditorsDiffDecorations(e, this._ignoreTrimWhitespace, this._renderIndicators, t, i);
    try {
      this._currentlyChangingViewZones = !0, this._originalEditorState.apply(this._originalEditor, this._originalOverviewRuler, r.original, !1), this._modifiedEditorState.apply(this._modifiedEditor, this._modifiedOverviewRuler, r.modified, !0);
    } finally {
      this._currentlyChangingViewZones = !1;
    }
  }
  _adjustOptionsForSubEditor(e) {
    const t = Object.assign({}, e);
    return t.inDiffEditor = !0, t.automaticLayout = !1, t.scrollbar = Object.assign({}, t.scrollbar || {}), t.scrollbar.vertical = "visible", t.folding = !1, t.codeLens = this._diffCodeLens, t.fixedOverflowWidgets = !0, t.minimap = Object.assign({}, t.minimap || {}), t.minimap.enabled = !1, t;
  }
  _adjustOptionsForLeftHandSide(e) {
    const t = this._adjustOptionsForSubEditor(e);
    return this._renderSideBySide ? t.wordWrapOverride1 = this._diffWordWrap : t.wordWrapOverride1 = "off", e.originalAriaLabel && (t.ariaLabel = e.originalAriaLabel), t.readOnly = !this._originalIsEditable, t.extraEditorClassName = "original-in-monaco-diff-editor", Object.assign(Object.assign({}, t), { dimension: {
      height: 0,
      width: 0
    } });
  }
  _adjustOptionsForRightHandSide(e) {
    const t = this._adjustOptionsForSubEditor(e);
    return e.modifiedAriaLabel && (t.ariaLabel = e.modifiedAriaLabel), t.wordWrapOverride1 = this._diffWordWrap, t.revealHorizontalRightPadding = sf.revealHorizontalRightPadding.defaultValue + lr.ENTIRE_DIFF_OVERVIEW_WIDTH, t.scrollbar.verticalHasArrows = !1, t.extraEditorClassName = "modified-in-monaco-diff-editor", Object.assign(Object.assign({}, t), { dimension: {
      height: 0,
      width: 0
    } });
  }
  doLayout() {
    this._elementSizeObserver.observe(), this._doLayout();
  }
  _doLayout() {
    const e = this._elementSizeObserver.getWidth(), t = this._elementSizeObserver.getHeight(), i = this._getReviewHeight(), r = this._strategy.layout();
    this._originalDomNode.style.width = r + "px", this._originalDomNode.style.left = "0px", this._modifiedDomNode.style.width = e - r + "px", this._modifiedDomNode.style.left = r + "px", this._overviewDomElement.style.top = "0px", this._overviewDomElement.style.height = t - i + "px", this._overviewDomElement.style.width = lr.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", this._overviewDomElement.style.left = e - lr.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", this._overviewViewportDomElement.setWidth(lr.ENTIRE_DIFF_OVERVIEW_WIDTH), this._overviewViewportDomElement.setHeight(30), this._originalEditor.layout({ width: r, height: t - i }), this._modifiedEditor.layout({ width: e - r - (this._renderOverviewRuler ? lr.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), height: t - i }), (this._originalOverviewRuler || this._modifiedOverviewRuler) && this._layoutOverviewRulers(), this._reviewPane.layout(t - i, e, i), this._layoutOverviewViewport();
  }
  _layoutOverviewViewport() {
    const e = this._computeOverviewViewport();
    e ? (this._overviewViewportDomElement.setTop(e.top), this._overviewViewportDomElement.setHeight(e.height)) : (this._overviewViewportDomElement.setTop(0), this._overviewViewportDomElement.setHeight(0));
  }
  _computeOverviewViewport() {
    const e = this._modifiedEditor.getLayoutInfo();
    if (!e)
      return null;
    const t = this._modifiedEditor.getScrollTop(), i = this._modifiedEditor.getScrollHeight(), r = Math.max(0, e.height), o = Math.max(0, r - 2 * 0), s = i > 0 ? o / i : 0, a = Math.max(0, Math.floor(e.height * s)), l = Math.floor(t * s);
    return {
      height: a,
      top: l
    };
  }
  _createDataSource() {
    return {
      getWidth: () => this._elementSizeObserver.getWidth(),
      getHeight: () => this._elementSizeObserver.getHeight() - this._getReviewHeight(),
      getOptions: () => ({
        renderOverviewRuler: this._renderOverviewRuler
      }),
      getContainerDomNode: () => this._containerDomElement,
      relayoutEditors: () => {
        this._doLayout();
      },
      getOriginalEditor: () => this._originalEditor,
      getModifiedEditor: () => this._modifiedEditor
    };
  }
  _setStrategy(e) {
    this._strategy && this._strategy.dispose(), this._strategy = e, e.applyColors(this._themeService.getColorTheme()), this._diffComputationResult && this._updateDecorations(), this._doLayout();
  }
  _getLineChangeAtOrBeforeLineNumber(e, t) {
    const i = this._diffComputationResult ? this._diffComputationResult.changes : [];
    if (i.length === 0 || e < t(i[0]))
      return null;
    let r = 0, o = i.length - 1;
    for (; r < o; ) {
      const s = Math.floor((r + o) / 2), a = t(i[s]), l = s + 1 <= o ? t(i[s + 1]) : 1073741824;
      e < a ? o = s - 1 : e >= l ? r = s + 1 : (r = s, o = s);
    }
    return i[r];
  }
  _getEquivalentLineForOriginalLineNumber(e) {
    const t = this._getLineChangeAtOrBeforeLineNumber(e, (l) => l.originalStartLineNumber);
    if (!t)
      return e;
    const i = t.originalStartLineNumber + (t.originalEndLineNumber > 0 ? -1 : 0), r = t.modifiedStartLineNumber + (t.modifiedEndLineNumber > 0 ? -1 : 0), o = t.originalEndLineNumber > 0 ? t.originalEndLineNumber - t.originalStartLineNumber + 1 : 0, s = t.modifiedEndLineNumber > 0 ? t.modifiedEndLineNumber - t.modifiedStartLineNumber + 1 : 0, a = e - i;
    return a <= o ? r + Math.min(a, s) : r + s - o + a;
  }
  _getEquivalentLineForModifiedLineNumber(e) {
    const t = this._getLineChangeAtOrBeforeLineNumber(e, (l) => l.modifiedStartLineNumber);
    if (!t)
      return e;
    const i = t.originalStartLineNumber + (t.originalEndLineNumber > 0 ? -1 : 0), r = t.modifiedStartLineNumber + (t.modifiedEndLineNumber > 0 ? -1 : 0), o = t.originalEndLineNumber > 0 ? t.originalEndLineNumber - t.originalStartLineNumber + 1 : 0, s = t.modifiedEndLineNumber > 0 ? t.modifiedEndLineNumber - t.modifiedStartLineNumber + 1 : 0, a = e - r;
    return a <= s ? i + Math.min(a, o) : i + o - s + a;
  }
  getDiffLineInformationForOriginal(e) {
    return this._diffComputationResult ? {
      equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(e)
    } : null;
  }
  getDiffLineInformationForModified(e) {
    return this._diffComputationResult ? {
      equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(e)
    } : null;
  }
};
dh.ONE_OVERVIEW_WIDTH = 15;
dh.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;
dh.UPDATE_DIFF_DECORATIONS_DELAY = 200;
dh = vpe([
  Lu(3, kE),
  Lu(4, sc),
  Lu(5, xi),
  Lu(6, no),
  Lu(7, mr),
  Lu(8, er),
  Lu(9, al),
  Lu(10, FE),
  Lu(11, WE)
], dh);
class L7 extends Ce {
  constructor(e) {
    super(), this._dataSource = e, this._insertColor = null, this._removeColor = null;
  }
  applyColors(e) {
    const t = (e.getColor($3) || tO).transparent(2), i = (e.getColor(K3) || iO).transparent(2), r = !t.equals(this._insertColor) || !i.equals(this._removeColor);
    return this._insertColor = t, this._removeColor = i, r;
  }
  getEditorsDiffDecorations(e, t, i, r, o) {
    o = o.sort((u, c) => u.afterLineNumber - c.afterLineNumber), r = r.sort((u, c) => u.afterLineNumber - c.afterLineNumber);
    const s = this._getViewZones(e, r, o, i), a = this._getOriginalEditorDecorations(e, t, i), l = this._getModifiedEditorDecorations(e, t, i);
    return {
      original: {
        decorations: a.decorations,
        overviewZones: a.overviewZones,
        zones: s.original
      },
      modified: {
        decorations: l.decorations,
        overviewZones: l.overviewZones,
        zones: s.modified
      }
    };
  }
}
class CW {
  constructor(e) {
    this._source = e, this._index = -1, this.current = null, this.advance();
  }
  advance() {
    this._index++, this._index < this._source.length ? this.current = this._source[this._index] : this.current = null;
  }
}
class cd {
  constructor(e, t, i, r, o) {
    this._lineChanges = e, this._originalForeignVZ = t, this._modifiedForeignVZ = i, this._originalEditor = r, this._modifiedEditor = o;
  }
  static _getViewLineCount(e, t, i) {
    const r = e.getModel(), o = e._getViewModel();
    if (r && o) {
      const s = p_(r, o, t, i);
      return s.endLineNumber - s.startLineNumber + 1;
    }
    return i - t + 1;
  }
  getViewZones() {
    const e = this._originalEditor.getOption(
      56
      /* lineHeight */
    ), t = this._modifiedEditor.getOption(
      56
      /* lineHeight */
    ), i = this._originalEditor.getOption(
      129
      /* wrappingInfo */
    ).wrappingColumn !== -1, r = this._modifiedEditor.getOption(
      129
      /* wrappingInfo */
    ).wrappingColumn !== -1, o = i || r, s = this._originalEditor.getModel(), a = this._originalEditor._getViewModel().coordinatesConverter, l = this._modifiedEditor._getViewModel().coordinatesConverter, u = {
      original: [],
      modified: []
    };
    let c = 0, h = 0, d = 0, f = 0, p = 0, g = 0;
    const _ = (L, S) => L.afterLineNumber - S.afterLineNumber, m = (L, S) => {
      if (S.domNode === null && L.length > 0) {
        const E = L[L.length - 1];
        if (E.afterLineNumber === S.afterLineNumber && E.domNode === null) {
          E.heightInLines += S.heightInLines;
          return;
        }
      }
      L.push(S);
    }, v = new CW(this._modifiedForeignVZ), C = new CW(this._originalForeignVZ);
    let y = 1, w = 1;
    for (let L = 0, S = this._lineChanges.length; L <= S; L++) {
      const E = L < S ? this._lineChanges[L] : null;
      E !== null ? (d = E.originalStartLineNumber + (E.originalEndLineNumber > 0 ? -1 : 0), f = E.modifiedStartLineNumber + (E.modifiedEndLineNumber > 0 ? -1 : 0), h = E.originalEndLineNumber > 0 ? cd._getViewLineCount(this._originalEditor, E.originalStartLineNumber, E.originalEndLineNumber) : 0, c = E.modifiedEndLineNumber > 0 ? cd._getViewLineCount(this._modifiedEditor, E.modifiedStartLineNumber, E.modifiedEndLineNumber) : 0, p = Math.max(E.originalStartLineNumber, E.originalEndLineNumber), g = Math.max(E.modifiedStartLineNumber, E.modifiedEndLineNumber)) : (d += 1e7 + h, f += 1e7 + c, p = d, g = f);
      let D = [], x = [];
      if (o) {
        let M;
        E ? E.originalEndLineNumber > 0 ? M = E.originalStartLineNumber - y : M = E.modifiedStartLineNumber - w : M = s.getLineCount() - y;
        for (let z = 0; z < M; z++) {
          const j = y + z, $ = w + z, k = a.getModelLineViewLineCount(j), ae = l.getModelLineViewLineCount($);
          k < ae ? D.push({
            afterLineNumber: j,
            heightInLines: ae - k,
            domNode: null,
            marginDomNode: null
          }) : k > ae && x.push({
            afterLineNumber: $,
            heightInLines: k - ae,
            domNode: null,
            marginDomNode: null
          });
        }
        E && (y = (E.originalEndLineNumber > 0 ? E.originalEndLineNumber : E.originalStartLineNumber) + 1, w = (E.modifiedEndLineNumber > 0 ? E.modifiedEndLineNumber : E.modifiedStartLineNumber) + 1);
      }
      for (; v.current && v.current.afterLineNumber <= g; ) {
        let M;
        v.current.afterLineNumber <= f ? M = d - f + v.current.afterLineNumber : M = p;
        let z = null;
        E && E.modifiedStartLineNumber <= v.current.afterLineNumber && v.current.afterLineNumber <= E.modifiedEndLineNumber && (z = this._createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion()), D.push({
          afterLineNumber: M,
          heightInLines: v.current.height / t,
          domNode: null,
          marginDomNode: z
        }), v.advance();
      }
      for (; C.current && C.current.afterLineNumber <= p; ) {
        let M;
        C.current.afterLineNumber <= d ? M = f - d + C.current.afterLineNumber : M = g, x.push({
          afterLineNumber: M,
          heightInLines: C.current.height / e,
          domNode: null
        }), C.advance();
      }
      if (E !== null && Fp(E)) {
        const M = this._produceOriginalFromDiff(E, h, c);
        M && D.push(M);
      }
      if (E !== null && kp(E)) {
        const M = this._produceModifiedFromDiff(E, h, c);
        M && x.push(M);
      }
      let R = 0, A = 0;
      for (D = D.sort(_), x = x.sort(_); R < D.length && A < x.length; ) {
        const M = D[R], z = x[A], j = M.afterLineNumber - d, $ = z.afterLineNumber - f;
        j < $ ? (m(u.original, M), R++) : $ < j ? (m(u.modified, z), A++) : M.shouldNotShrink ? (m(u.original, M), R++) : z.shouldNotShrink ? (m(u.modified, z), A++) : M.heightInLines >= z.heightInLines ? (M.heightInLines -= z.heightInLines, A++) : (z.heightInLines -= M.heightInLines, R++);
      }
      for (; R < D.length; )
        m(u.original, D[R]), R++;
      for (; A < x.length; )
        m(u.modified, x[A]), A++;
    }
    return {
      original: cd._ensureDomNodes(u.original),
      modified: cd._ensureDomNodes(u.modified)
    };
  }
  static _ensureDomNodes(e) {
    return e.map((t) => (t.domNode || (t.domNode = D7()), t));
  }
}
function Wu(n, e, t, i, r) {
  return {
    range: new G(n, e, t, i),
    options: r
  };
}
const Yr = {
  charDelete: kn.register({
    description: "diff-editor-char-delete",
    className: "char-delete"
  }),
  charDeleteWholeLine: kn.register({
    description: "diff-editor-char-delete-whole-line",
    className: "char-delete",
    isWholeLine: !0
  }),
  charInsert: kn.register({
    description: "diff-editor-char-insert",
    className: "char-insert"
  }),
  charInsertWholeLine: kn.register({
    description: "diff-editor-char-insert-whole-line",
    className: "char-insert",
    isWholeLine: !0
  }),
  lineInsert: kn.register({
    description: "diff-editor-line-insert",
    className: "line-insert",
    marginClassName: "line-insert",
    isWholeLine: !0
  }),
  lineInsertWithSign: kn.register({
    description: "diff-editor-line-insert-with-sign",
    className: "line-insert",
    linesDecorationsClassName: "insert-sign " + ma.asClassName(Cpe),
    marginClassName: "line-insert",
    isWholeLine: !0
  }),
  lineDelete: kn.register({
    description: "diff-editor-line-delete",
    className: "line-delete",
    marginClassName: "line-delete",
    isWholeLine: !0
  }),
  lineDeleteWithSign: kn.register({
    description: "diff-editor-line-delete-with-sign",
    className: "line-delete",
    linesDecorationsClassName: "delete-sign " + ma.asClassName(E7),
    marginClassName: "line-delete",
    isWholeLine: !0
  }),
  lineDeleteMargin: kn.register({
    description: "diff-editor-line-delete-margin",
    marginClassName: "line-delete"
  })
};
class zu extends L7 {
  constructor(e, t) {
    super(e), this._disableSash = t === !1, this._sashRatio = null, this._sashPosition = null, this._startSashPosition = null, this._sash = this._register(new ds(this._dataSource.getContainerDomNode(), this, {
      orientation: 0
      /* VERTICAL */
    })), this._disableSash && (this._sash.state = 0), this._sash.onDidStart(() => this._onSashDragStart()), this._sash.onDidChange((i) => this._onSashDrag(i)), this._sash.onDidEnd(() => this._onSashDragEnd()), this._sash.onDidReset(() => this._onSashReset());
  }
  setEnableSplitViewResizing(e) {
    const t = e === !1;
    this._disableSash !== t && (this._disableSash = t, this._sash.state = this._disableSash ? 0 : 3);
  }
  layout(e = this._sashRatio) {
    const i = this._dataSource.getWidth() - (this._dataSource.getOptions().renderOverviewRuler ? dh.ENTIRE_DIFF_OVERVIEW_WIDTH : 0);
    let r = Math.floor((e || 0.5) * i);
    const o = Math.floor(0.5 * i);
    return r = this._disableSash ? o : r || o, i > zu.MINIMUM_EDITOR_WIDTH * 2 ? (r < zu.MINIMUM_EDITOR_WIDTH && (r = zu.MINIMUM_EDITOR_WIDTH), r > i - zu.MINIMUM_EDITOR_WIDTH && (r = i - zu.MINIMUM_EDITOR_WIDTH)) : r = o, this._sashPosition !== r && (this._sashPosition = r, this._sash.layout()), this._sashPosition;
  }
  _onSashDragStart() {
    this._startSashPosition = this._sashPosition;
  }
  _onSashDrag(e) {
    const i = this._dataSource.getWidth() - (this._dataSource.getOptions().renderOverviewRuler ? dh.ENTIRE_DIFF_OVERVIEW_WIDTH : 0), r = this.layout((this._startSashPosition + (e.currentX - e.startX)) / i);
    this._sashRatio = r / i, this._dataSource.relayoutEditors();
  }
  _onSashDragEnd() {
    this._sash.layout();
  }
  _onSashReset() {
    this._sashRatio = 0.5, this._dataSource.relayoutEditors(), this._sash.layout();
  }
  getVerticalSashTop(e) {
    return 0;
  }
  getVerticalSashLeft(e) {
    return this._sashPosition;
  }
  getVerticalSashHeight(e) {
    return this._dataSource.getHeight();
  }
  _getViewZones(e, t, i) {
    const r = this._dataSource.getOriginalEditor(), o = this._dataSource.getModifiedEditor();
    return new ype(e, t, i, r, o).getViewZones();
  }
  _getOriginalEditorDecorations(e, t, i) {
    const r = this._dataSource.getOriginalEditor(), o = String(this._removeColor), s = {
      decorations: [],
      overviewZones: []
    }, a = r.getModel(), l = r._getViewModel();
    for (const u of e)
      if (kp(u)) {
        s.decorations.push({
          range: new G(
            u.originalStartLineNumber,
            1,
            u.originalEndLineNumber,
            1073741824
            /* MAX_SAFE_SMALL_INTEGER */
          ),
          options: i ? Yr.lineDeleteWithSign : Yr.lineDelete
        }), (!Fp(u) || !u.charChanges) && s.decorations.push(Wu(u.originalStartLineNumber, 1, u.originalEndLineNumber, 1073741824, Yr.charDeleteWholeLine));
        const c = p_(a, l, u.originalStartLineNumber, u.originalEndLineNumber);
        if (s.overviewZones.push(new c_(c.startLineNumber, c.endLineNumber, o)), u.charChanges) {
          for (const h of u.charChanges)
            if (kp(h))
              if (t)
                for (let d = h.originalStartLineNumber; d <= h.originalEndLineNumber; d++) {
                  let f, p;
                  d === h.originalStartLineNumber ? f = h.originalStartColumn : f = a.getLineFirstNonWhitespaceColumn(d), d === h.originalEndLineNumber ? p = h.originalEndColumn : p = a.getLineLastNonWhitespaceColumn(d), s.decorations.push(Wu(d, f, d, p, Yr.charDelete));
                }
              else
                s.decorations.push(Wu(h.originalStartLineNumber, h.originalStartColumn, h.originalEndLineNumber, h.originalEndColumn, Yr.charDelete));
        }
      }
    return s;
  }
  _getModifiedEditorDecorations(e, t, i) {
    const r = this._dataSource.getModifiedEditor(), o = String(this._insertColor), s = {
      decorations: [],
      overviewZones: []
    }, a = r.getModel(), l = r._getViewModel();
    for (const u of e)
      if (Fp(u)) {
        s.decorations.push({
          range: new G(
            u.modifiedStartLineNumber,
            1,
            u.modifiedEndLineNumber,
            1073741824
            /* MAX_SAFE_SMALL_INTEGER */
          ),
          options: i ? Yr.lineInsertWithSign : Yr.lineInsert
        }), (!kp(u) || !u.charChanges) && s.decorations.push(Wu(u.modifiedStartLineNumber, 1, u.modifiedEndLineNumber, 1073741824, Yr.charInsertWholeLine));
        const c = p_(a, l, u.modifiedStartLineNumber, u.modifiedEndLineNumber);
        if (s.overviewZones.push(new c_(c.startLineNumber, c.endLineNumber, o)), u.charChanges) {
          for (const h of u.charChanges)
            if (Fp(h))
              if (t)
                for (let d = h.modifiedStartLineNumber; d <= h.modifiedEndLineNumber; d++) {
                  let f, p;
                  d === h.modifiedStartLineNumber ? f = h.modifiedStartColumn : f = a.getLineFirstNonWhitespaceColumn(d), d === h.modifiedEndLineNumber ? p = h.modifiedEndColumn : p = a.getLineLastNonWhitespaceColumn(d), s.decorations.push(Wu(d, f, d, p, Yr.charInsert));
                }
              else
                s.decorations.push(Wu(h.modifiedStartLineNumber, h.modifiedStartColumn, h.modifiedEndLineNumber, h.modifiedEndColumn, Yr.charInsert));
        }
      }
    return s;
  }
}
zu.MINIMUM_EDITOR_WIDTH = 100;
class ype extends cd {
  constructor(e, t, i, r, o) {
    super(e, t, i, r, o);
  }
  _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
    return null;
  }
  _produceOriginalFromDiff(e, t, i) {
    return i > t ? {
      afterLineNumber: Math.max(e.originalStartLineNumber, e.originalEndLineNumber),
      heightInLines: i - t,
      domNode: null
    } : null;
  }
  _produceModifiedFromDiff(e, t, i) {
    return t > i ? {
      afterLineNumber: Math.max(e.modifiedStartLineNumber, e.modifiedEndLineNumber),
      heightInLines: t - i,
      domNode: null
    } : null;
  }
}
class yW extends L7 {
  constructor(e, t) {
    super(e), this._decorationsLeft = e.getOriginalEditor().getLayoutInfo().decorationsLeft, this._register(e.getOriginalEditor().onDidLayoutChange((i) => {
      this._decorationsLeft !== i.decorationsLeft && (this._decorationsLeft = i.decorationsLeft, e.relayoutEditors());
    }));
  }
  setEnableSplitViewResizing(e) {
  }
  _getViewZones(e, t, i, r) {
    const o = this._dataSource.getOriginalEditor(), s = this._dataSource.getModifiedEditor();
    return new wpe(e, t, i, o, s, r).getViewZones();
  }
  _getOriginalEditorDecorations(e, t, i) {
    const r = String(this._removeColor), o = {
      decorations: [],
      overviewZones: []
    }, s = this._dataSource.getOriginalEditor(), a = s.getModel(), l = s._getViewModel();
    for (const u of e)
      if (kp(u)) {
        o.decorations.push({
          range: new G(
            u.originalStartLineNumber,
            1,
            u.originalEndLineNumber,
            1073741824
            /* MAX_SAFE_SMALL_INTEGER */
          ),
          options: Yr.lineDeleteMargin
        });
        const c = p_(a, l, u.originalStartLineNumber, u.originalEndLineNumber);
        o.overviewZones.push(new c_(c.startLineNumber, c.endLineNumber, r));
      }
    return o;
  }
  _getModifiedEditorDecorations(e, t, i) {
    const r = this._dataSource.getModifiedEditor(), o = String(this._insertColor), s = {
      decorations: [],
      overviewZones: []
    }, a = r.getModel(), l = r._getViewModel();
    for (const u of e)
      if (Fp(u)) {
        s.decorations.push({
          range: new G(
            u.modifiedStartLineNumber,
            1,
            u.modifiedEndLineNumber,
            1073741824
            /* MAX_SAFE_SMALL_INTEGER */
          ),
          options: i ? Yr.lineInsertWithSign : Yr.lineInsert
        });
        const c = p_(a, l, u.modifiedStartLineNumber, u.modifiedEndLineNumber);
        if (s.overviewZones.push(new c_(c.startLineNumber, c.endLineNumber, o)), u.charChanges) {
          for (const h of u.charChanges)
            if (Fp(h))
              if (t)
                for (let d = h.modifiedStartLineNumber; d <= h.modifiedEndLineNumber; d++) {
                  let f, p;
                  d === h.modifiedStartLineNumber ? f = h.modifiedStartColumn : f = a.getLineFirstNonWhitespaceColumn(d), d === h.modifiedEndLineNumber ? p = h.modifiedEndColumn : p = a.getLineLastNonWhitespaceColumn(d), s.decorations.push(Wu(d, f, d, p, Yr.charInsert));
                }
              else
                s.decorations.push(Wu(h.modifiedStartLineNumber, h.modifiedStartColumn, h.modifiedEndLineNumber, h.modifiedEndColumn, Yr.charInsert));
        } else
          s.decorations.push(Wu(u.modifiedStartLineNumber, 1, u.modifiedEndLineNumber, 1073741824, Yr.charInsertWholeLine));
      }
    return s;
  }
  layout() {
    return Math.max(5, this._decorationsLeft);
  }
}
class wpe extends cd {
  constructor(e, t, i, r, o, s) {
    super(e, t, i, r, o), this._originalModel = r.getModel(), this._renderIndicators = s, this._pendingLineChange = [], this._pendingViewZones = [], this._lineBreaksComputer = this._modifiedEditor._getViewModel().createLineBreaksComputer();
  }
  getViewZones() {
    const e = super.getViewZones();
    return this._finalize(e), e;
  }
  _createOriginalMarginDomNodeForModifiedForeignViewZoneInAddedRegion() {
    const e = document.createElement("div");
    return e.className = "inline-added-margin-view-zone", e;
  }
  _produceOriginalFromDiff(e, t, i) {
    const r = document.createElement("div");
    return r.className = "inline-added-margin-view-zone", {
      afterLineNumber: Math.max(e.originalStartLineNumber, e.originalEndLineNumber),
      heightInLines: i,
      domNode: document.createElement("div"),
      marginDomNode: r
    };
  }
  _produceModifiedFromDiff(e, t, i) {
    const r = document.createElement("div");
    r.className = `view-lines line-delete ${Dd}`;
    const o = document.createElement("div");
    o.className = "inline-deleted-margin-view-zone";
    const s = {
      shouldNotShrink: !0,
      afterLineNumber: e.modifiedEndLineNumber === 0 ? e.modifiedStartLineNumber : e.modifiedStartLineNumber - 1,
      heightInLines: t,
      minWidthInPx: 0,
      domNode: r,
      marginDomNode: o,
      diff: {
        originalStartLineNumber: e.originalStartLineNumber,
        originalEndLineNumber: e.originalEndLineNumber,
        modifiedStartLineNumber: e.modifiedStartLineNumber,
        modifiedEndLineNumber: e.modifiedEndLineNumber,
        originalModel: this._originalModel,
        viewLineCounts: null
      }
    };
    for (let a = e.originalStartLineNumber; a <= e.originalEndLineNumber; a++)
      this._lineBreaksComputer.addRequest(this._originalModel.getLineContent(a), null);
    return this._pendingLineChange.push(e), this._pendingViewZones.push(s), s;
  }
  _finalize(e) {
    const t = this._modifiedEditor.getOptions(), i = this._modifiedEditor.getModel().getOptions().tabSize, r = t.get(
      40
      /* fontInfo */
    ), o = t.get(
      27
      /* disableMonospaceOptimizations */
    ), s = r.typicalHalfwidthCharacterWidth, a = t.get(
      91
      /* scrollBeyondLastColumn */
    ), l = this._originalModel.mightContainNonBasicASCII(), u = this._originalModel.mightContainRTL(), c = t.get(
      56
      /* lineHeight */
    ), d = t.get(
      128
      /* layoutInfo */
    ).decorationsWidth, f = t.get(
      103
      /* stopRenderingLineAfter */
    ), p = t.get(
      86
      /* renderWhitespace */
    ), g = t.get(
      80
      /* renderControlCharacters */
    ), _ = t.get(
      41
      /* fontLigatures */
    ), m = this._lineBreaksComputer.finalize();
    let v = 0;
    for (let C = 0; C < this._pendingLineChange.length; C++) {
      const y = this._pendingLineChange[C], w = this._pendingViewZones[C], L = w.domNode;
      oo.applyFontInfoSlow(L, r);
      const S = w.marginDomNode;
      oo.applyFontInfoSlow(S, r);
      const E = [];
      if (y.charChanges)
        for (const $ of y.charChanges)
          kp($) && E.push(new cw(
            new G($.originalStartLineNumber, $.originalStartColumn, $.originalEndLineNumber, $.originalEndColumn),
            "char-delete",
            0
            /* Regular */
          ));
      const D = E.length > 0, x = eg(1e4);
      let R = 0, A = 0, M = null;
      for (let $ = y.originalStartLineNumber; $ <= y.originalEndLineNumber; $++) {
        const k = $ - y.originalStartLineNumber, ae = this._originalModel.getLineTokens($), re = ae.getLineContent(), Y = m[v++], K = ga.filter(E, $, 1, re.length + 1);
        if (Y) {
          let W = 0;
          for (const U of Y.breakOffsets) {
            const O = ae.sliceAndInflate(W, U, 0), N = re.substring(W, U);
            R = Math.max(R, this._renderOriginalLine(A++, N, O, ga.extractWrapped(K, W, U), D, l, u, r, o, c, d, f, p, g, _, i, x, S)), W = U;
          }
          for (M || (M = []); M.length < k; )
            M[M.length] = 1;
          M[k] = Y.breakOffsets.length, w.heightInLines += Y.breakOffsets.length - 1;
          const B = document.createElement("div");
          B.className = "line-delete", e.original.push({
            afterLineNumber: $,
            afterColumn: 0,
            heightInLines: Y.breakOffsets.length - 1,
            domNode: D7(),
            marginDomNode: B
          });
        } else
          R = Math.max(R, this._renderOriginalLine(A++, re, ae, K, D, l, u, r, o, c, d, f, p, g, _, i, x, S));
      }
      R += a;
      const z = x.build(), j = _W ? _W.createHTML(z) : z;
      if (L.innerHTML = j, w.minWidthInPx = R * s, M) {
        const $ = y.originalEndLineNumber - y.originalStartLineNumber;
        for (; M.length <= $; )
          M[M.length] = 1;
      }
      w.diff.viewLineCounts = M;
    }
    e.original.sort((C, y) => C.afterLineNumber - y.afterLineNumber);
  }
  _renderOriginalLine(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g, _, m, v) {
    m.appendASCIIString('<div class="view-line'), o || m.appendASCIIString(" char-delete"), m.appendASCIIString('" style="top:'), m.appendASCIIString(String(e * c)), m.appendASCIIString('px;width:1000000px;">');
    const C = Yo.isBasicASCII(t, s), y = Yo.containsRTL(t, C, a), w = nI(new Pg(
      l.isMonospace && !u,
      l.canUseHalfwidthRightwardsArrow,
      t,
      !1,
      C,
      y,
      0,
      i,
      r,
      _,
      0,
      l.spaceWidth,
      l.middotWidth,
      l.wsmiddotWidth,
      d,
      f,
      p,
      g !== vs.OFF,
      null
      // Send no selections, original line cannot be selected
    ), m);
    if (m.appendASCIIString("</div>"), this._renderIndicators) {
      const S = document.createElement("div");
      S.className = `delete-sign ${ma.asClassName(E7)}`, S.setAttribute("style", `position:absolute;top:${e * c}px;width:${h}px;height:${c}px;right:0;`), v.appendChild(S);
    }
    const L = w.characterMapping.getAbsoluteOffsets();
    return L.length > 0 ? L[L.length - 1] : 0;
  }
}
function wW(n, e) {
  return gs(n, e, ["off", "on", "inherit"]);
}
function Fp(n) {
  return n.modifiedEndLineNumber > 0;
}
function kp(n) {
  return n.originalEndLineNumber > 0;
}
function D7() {
  const n = document.createElement("div");
  return n.className = "diagonal-fill", n;
}
function p_(n, e, t, i) {
  const r = n.getLineCount();
  return t = Math.min(r, Math.max(1, t)), i = Math.min(r, Math.max(1, i)), e.coordinatesConverter.convertModelRangeToViewRange(new G(t, n.getLineMinColumn(t), i, n.getLineMaxColumn(i)));
}
wa((n, e) => {
  const t = n.getColor($3);
  t && (e.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { background-color: ${t}; }`), e.addRule(`.monaco-diff-editor .line-insert, .monaco-diff-editor .char-insert { background-color: ${t}; }`), e.addRule(`.monaco-editor .inline-added-margin-view-zone { background-color: ${t}; }`));
  const i = n.getColor(K3);
  i && (e.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { background-color: ${i}; }`), e.addRule(`.monaco-diff-editor .line-delete, .monaco-diff-editor .char-delete { background-color: ${i}; }`), e.addRule(`.monaco-editor .inline-deleted-margin-view-zone { background-color: ${i}; }`));
  const r = n.getColor(Kce);
  r && e.addRule(`.monaco-editor .line-insert, .monaco-editor .char-insert { border: 1px ${n.type === "hc" ? "dashed" : "solid"} ${r}; }`);
  const o = n.getColor(qce);
  o && e.addRule(`.monaco-editor .line-delete, .monaco-editor .char-delete { border: 1px ${n.type === "hc" ? "dashed" : "solid"} ${o}; }`);
  const s = n.getColor(OE);
  s && e.addRule(`.monaco-diff-editor.side-by-side .editor.modified { box-shadow: -6px 0 5px -5px ${s}; }`);
  const a = n.getColor(Yce);
  a && e.addRule(`.monaco-diff-editor.side-by-side .editor.modified { border-left: 1px solid ${a}; }`);
  const l = n.getColor(fw);
  l && e.addRule(`
			.monaco-diff-editor .diffViewport {
				background: ${l};
			}
		`);
  const u = n.getColor(pw);
  u && e.addRule(`
			.monaco-diff-editor .diffViewport:hover {
				background: ${u};
			}
		`);
  const c = n.getColor(gw);
  c && e.addRule(`
			.monaco-diff-editor .diffViewport:active {
				background: ${c};
			}
		`);
  const h = n.getColor(Xce);
  e.addRule(`
	.monaco-editor .diagonal-fill {
		background-image: linear-gradient(
			-45deg,
			${h} 12.5%,
			#0000 12.5%, #0000 50%,
			${h} 50%, ${h} 62.5%,
			#0000 62.5%, #0000 100%
		);
		background-size: 8px 8px;
	}
	`);
});
const J_ = Vt("themeService"), xo = Vt("keybindingService");
class bpe extends Ce {
  constructor() {
    super(), this._onCodeEditorAdd = this._register(new q()), this.onCodeEditorAdd = this._onCodeEditorAdd.event, this._onCodeEditorRemove = this._register(new q()), this.onCodeEditorRemove = this._onCodeEditorRemove.event, this._onDiffEditorAdd = this._register(new q()), this._onDiffEditorRemove = this._register(new q()), this._onDecorationTypeRegistered = this._register(new q()), this._modelProperties = /* @__PURE__ */ new Map(), this._codeEditors = /* @__PURE__ */ Object.create(null), this._diffEditors = /* @__PURE__ */ Object.create(null);
  }
  addCodeEditor(e) {
    this._codeEditors[e.getId()] = e, this._onCodeEditorAdd.fire(e);
  }
  removeCodeEditor(e) {
    delete this._codeEditors[e.getId()] && this._onCodeEditorRemove.fire(e);
  }
  listCodeEditors() {
    return Object.keys(this._codeEditors).map((e) => this._codeEditors[e]);
  }
  addDiffEditor(e) {
    this._diffEditors[e.getId()] = e, this._onDiffEditorAdd.fire(e);
  }
  removeDiffEditor(e) {
    delete this._diffEditors[e.getId()] && this._onDiffEditorRemove.fire(e);
  }
  listDiffEditors() {
    return Object.keys(this._diffEditors).map((e) => this._diffEditors[e]);
  }
  getFocusedCodeEditor() {
    let e = null;
    const t = this.listCodeEditors();
    for (const i of t) {
      if (i.hasTextFocus())
        return i;
      i.hasWidgetFocus() && (e = i);
    }
    return e;
  }
  setModelProperty(e, t, i) {
    const r = e.toString();
    let o;
    this._modelProperties.has(r) ? o = this._modelProperties.get(r) : (o = /* @__PURE__ */ new Map(), this._modelProperties.set(r, o)), o.set(t, i);
  }
  getModelProperty(e, t) {
    const i = e.toString();
    if (this._modelProperties.has(i))
      return this._modelProperties.get(i).get(t);
  }
}
var Spe = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Epe = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
class Lpe {
  constructor(e, t, i) {
    this._parent = e, this._editorId = t, this._styleSheet = i, this._refCount = 0;
  }
  ref() {
    this._refCount++;
  }
  unref() {
    var e;
    this._refCount--, this._refCount === 0 && ((e = this._styleSheet.parentNode) === null || e === void 0 || e.removeChild(this._styleSheet), this._parent._removeEditorStyleSheets(this._editorId));
  }
  insertRule(e, t) {
    this._styleSheet.sheet.insertRule(e, t);
  }
  removeRulesContainingSelector(e) {
    u5(e, this._styleSheet);
  }
}
class Dpe {
  constructor(e) {
    this._styleSheet = e;
  }
  ref() {
  }
  unref() {
  }
  insertRule(e, t) {
    this._styleSheet.sheet.insertRule(e, t);
  }
  removeRulesContainingSelector(e) {
    u5(e, this._styleSheet);
  }
}
let fO = class extends bpe {
  constructor(e, t) {
    super(), this._decorationOptionProviders = /* @__PURE__ */ new Map(), this._editorStyleSheets = /* @__PURE__ */ new Map(), this._globalStyleSheet = e || null, this._themeService = t;
  }
  _getOrCreateGlobalStyleSheet() {
    return this._globalStyleSheet || (this._globalStyleSheet = new Dpe(As())), this._globalStyleSheet;
  }
  _getOrCreateStyleSheet(e) {
    if (!e)
      return this._getOrCreateGlobalStyleSheet();
    const t = e.getContainerDomNode();
    if (!FN(t))
      return this._getOrCreateGlobalStyleSheet();
    const i = e.getId();
    if (!this._editorStyleSheets.has(i)) {
      const r = new Lpe(this, i, As(t));
      this._editorStyleSheets.set(i, r);
    }
    return this._editorStyleSheets.get(i);
  }
  _removeEditorStyleSheets(e) {
    this._editorStyleSheets.delete(e);
  }
  registerDecorationType(e, t, i, r, o) {
    let s = this._decorationOptionProviders.get(t);
    if (!s) {
      const a = this._getOrCreateStyleSheet(o), l = {
        styleSheet: a,
        key: t,
        parentTypeKey: r,
        options: i || /* @__PURE__ */ Object.create(null)
      };
      r ? s = new Rpe(this._themeService, a, l) : s = new Tpe(e, this._themeService, a, l), this._decorationOptionProviders.set(t, s), this._onDecorationTypeRegistered.fire(t);
    }
    s.refCount++;
  }
  removeDecorationType(e) {
    const t = this._decorationOptionProviders.get(e);
    t && (t.refCount--, t.refCount <= 0 && (this._decorationOptionProviders.delete(e), t.dispose(), this.listCodeEditors().forEach((i) => i.removeDecorations(e))));
  }
  resolveDecorationOptions(e, t) {
    const i = this._decorationOptionProviders.get(e);
    if (!i)
      throw new Error("Unknown decoration type key: " + e);
    return i.getOptions(this, t);
  }
};
fO = Spe([
  Epe(1, er)
], fO);
class Rpe {
  constructor(e, t, i) {
    this._styleSheet = t, this._styleSheet.ref(), this._parentTypeKey = i.parentTypeKey, this.refCount = 0, this._beforeContentRules = new nS(3, i, e), this._afterContentRules = new nS(4, i, e);
  }
  getOptions(e, t) {
    const i = e.resolveDecorationOptions(this._parentTypeKey, !0);
    return this._beforeContentRules && (i.beforeContentClassName = this._beforeContentRules.className), this._afterContentRules && (i.afterContentClassName = this._afterContentRules.className), i;
  }
  dispose() {
    this._beforeContentRules && (this._beforeContentRules.dispose(), this._beforeContentRules = null), this._afterContentRules && (this._afterContentRules.dispose(), this._afterContentRules = null), this._styleSheet.unref();
  }
}
class Tpe {
  constructor(e, t, i, r) {
    this._disposables = new dt(), this.description = e, this._styleSheet = i, this._styleSheet.ref(), this.refCount = 0;
    const o = (h) => {
      const d = new nS(h, r, t);
      if (this._disposables.add(d), d.hasContent)
        return d.className;
    }, s = (h) => {
      const d = new nS(h, r, t);
      return this._disposables.add(d), d.hasContent ? { className: d.className, hasLetterSpacing: d.hasLetterSpacing } : null;
    };
    this.className = o(
      0
      /* ClassName */
    );
    const a = s(
      1
      /* InlineClassName */
    );
    a && (this.inlineClassName = a.className, this.inlineClassNameAffectsLetterSpacing = a.hasLetterSpacing), this.beforeContentClassName = o(
      3
      /* BeforeContentClassName */
    ), this.afterContentClassName = o(
      4
      /* AfterContentClassName */
    ), this.glyphMarginClassName = o(
      2
      /* GlyphMarginClassName */
    );
    const l = r.options;
    this.isWholeLine = !!l.isWholeLine, this.stickiness = l.rangeBehavior;
    const u = l.light && l.light.overviewRulerColor || l.overviewRulerColor, c = l.dark && l.dark.overviewRulerColor || l.overviewRulerColor;
    (typeof u < "u" || typeof c < "u") && (this.overviewRuler = {
      color: u || c,
      darkColor: c || u,
      position: l.overviewRulerLane || Xv.Center
    });
  }
  getOptions(e, t) {
    return t ? {
      description: this.description,
      inlineClassName: this.inlineClassName,
      beforeContentClassName: this.beforeContentClassName,
      afterContentClassName: this.afterContentClassName,
      className: this.className,
      glyphMarginClassName: this.glyphMarginClassName,
      isWholeLine: this.isWholeLine,
      overviewRuler: this.overviewRuler,
      stickiness: this.stickiness
    } : this;
  }
  dispose() {
    this._disposables.dispose(), this._styleSheet.unref();
  }
}
const Um = {
  color: "color:{0} !important;",
  opacity: "opacity:{0};",
  backgroundColor: "background-color:{0};",
  outline: "outline:{0};",
  outlineColor: "outline-color:{0};",
  outlineStyle: "outline-style:{0};",
  outlineWidth: "outline-width:{0};",
  border: "border:{0};",
  borderColor: "border-color:{0};",
  borderRadius: "border-radius:{0};",
  borderSpacing: "border-spacing:{0};",
  borderStyle: "border-style:{0};",
  borderWidth: "border-width:{0};",
  fontStyle: "font-style:{0};",
  fontWeight: "font-weight:{0};",
  fontSize: "font-size:{0};",
  fontFamily: "font-family:{0};",
  textDecoration: "text-decoration:{0};",
  cursor: "cursor:{0};",
  letterSpacing: "letter-spacing:{0};",
  gutterIconPath: "background:{0} center center no-repeat;",
  gutterIconSize: "background-size:{0};",
  contentText: "content:'{0}';",
  contentIconPath: "content:{0};",
  margin: "margin:{0};",
  padding: "padding:{0};",
  width: "width:{0};",
  height: "height:{0};"
};
class nS {
  constructor(e, t, i) {
    this._theme = i.getColorTheme(), this._ruleType = e, this._providerArgs = t, this._usesThemeColors = !1, this._hasContent = !1, this._hasLetterSpacing = !1;
    let r = s1.getClassName(this._providerArgs.key, e);
    this._providerArgs.parentTypeKey && (r = r + " " + s1.getClassName(this._providerArgs.parentTypeKey, e)), this._className = r, this._unThemedSelector = s1.getSelector(this._providerArgs.key, this._providerArgs.parentTypeKey, e), this._buildCSS(), this._usesThemeColors ? this._themeListener = i.onDidColorThemeChange((o) => {
      this._theme = i.getColorTheme(), this._removeCSS(), this._buildCSS();
    }) : this._themeListener = null;
  }
  dispose() {
    this._hasContent && (this._removeCSS(), this._hasContent = !1), this._themeListener && (this._themeListener.dispose(), this._themeListener = null);
  }
  get hasContent() {
    return this._hasContent;
  }
  get hasLetterSpacing() {
    return this._hasLetterSpacing;
  }
  get className() {
    return this._className;
  }
  _buildCSS() {
    const e = this._providerArgs.options;
    let t, i, r;
    switch (this._ruleType) {
      case 0:
        t = this.getCSSTextForModelDecorationClassName(e), i = this.getCSSTextForModelDecorationClassName(e.light), r = this.getCSSTextForModelDecorationClassName(e.dark);
        break;
      case 1:
        t = this.getCSSTextForModelDecorationInlineClassName(e), i = this.getCSSTextForModelDecorationInlineClassName(e.light), r = this.getCSSTextForModelDecorationInlineClassName(e.dark);
        break;
      case 2:
        t = this.getCSSTextForModelDecorationGlyphMarginClassName(e), i = this.getCSSTextForModelDecorationGlyphMarginClassName(e.light), r = this.getCSSTextForModelDecorationGlyphMarginClassName(e.dark);
        break;
      case 3:
        t = this.getCSSTextForModelDecorationContentClassName(e.before), i = this.getCSSTextForModelDecorationContentClassName(e.light && e.light.before), r = this.getCSSTextForModelDecorationContentClassName(e.dark && e.dark.before);
        break;
      case 4:
        t = this.getCSSTextForModelDecorationContentClassName(e.after), i = this.getCSSTextForModelDecorationContentClassName(e.light && e.light.after), r = this.getCSSTextForModelDecorationContentClassName(e.dark && e.dark.after);
        break;
      default:
        throw new Error("Unknown rule type: " + this._ruleType);
    }
    const o = this._providerArgs.styleSheet;
    let s = !1;
    t.length > 0 && (o.insertRule(`${this._unThemedSelector} {${t}}`, 0), s = !0), i.length > 0 && (o.insertRule(`.vs${this._unThemedSelector} {${i}}`, 0), s = !0), r.length > 0 && (o.insertRule(`.vs-dark${this._unThemedSelector}, .hc-black${this._unThemedSelector} {${r}}`, 0), s = !0), this._hasContent = s;
  }
  _removeCSS() {
    this._providerArgs.styleSheet.removeRulesContainingSelector(this._unThemedSelector);
  }
  /**
   * Build the CSS for decorations styled via `className`.
   */
  getCSSTextForModelDecorationClassName(e) {
    if (!e)
      return "";
    const t = [];
    return this.collectCSSText(e, ["backgroundColor"], t), this.collectCSSText(e, ["outline", "outlineColor", "outlineStyle", "outlineWidth"], t), this.collectBorderSettingsCSSText(e, t), t.join("");
  }
  /**
   * Build the CSS for decorations styled via `inlineClassName`.
   */
  getCSSTextForModelDecorationInlineClassName(e) {
    if (!e)
      return "";
    const t = [];
    return this.collectCSSText(e, ["fontStyle", "fontWeight", "textDecoration", "cursor", "color", "opacity", "letterSpacing"], t), e.letterSpacing && (this._hasLetterSpacing = !0), t.join("");
  }
  /**
   * Build the CSS for decorations styled before or after content.
   */
  getCSSTextForModelDecorationContentClassName(e) {
    if (!e)
      return "";
    const t = [];
    if (typeof e < "u") {
      if (this.collectBorderSettingsCSSText(e, t), typeof e.contentIconPath < "u" && t.push(Fl(Um.contentIconPath, qv(ft.revive(e.contentIconPath)))), typeof e.contentText == "string") {
        const r = e.contentText.match(/^.*$/m)[0].replace(/['\\]/g, "\\$&");
        t.push(Fl(Um.contentText, r));
      }
      this.collectCSSText(e, ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textDecoration", "color", "opacity", "backgroundColor", "margin", "padding"], t), this.collectCSSText(e, ["width", "height"], t) && t.push("display:inline-block;");
    }
    return t.join("");
  }
  /**
   * Build the CSS for decorations styled via `glpyhMarginClassName`.
   */
  getCSSTextForModelDecorationGlyphMarginClassName(e) {
    if (!e)
      return "";
    const t = [];
    return typeof e.gutterIconPath < "u" && (t.push(Fl(Um.gutterIconPath, qv(ft.revive(e.gutterIconPath)))), typeof e.gutterIconSize < "u" && t.push(Fl(Um.gutterIconSize, e.gutterIconSize))), t.join("");
  }
  collectBorderSettingsCSSText(e, t) {
    return this.collectCSSText(e, ["border", "borderColor", "borderRadius", "borderSpacing", "borderStyle", "borderWidth"], t) ? (t.push(Fl("box-sizing: border-box;")), !0) : !1;
  }
  collectCSSText(e, t, i) {
    const r = i.length;
    for (let o of t) {
      const s = this.resolveValue(e[o]);
      typeof s == "string" && i.push(Fl(Um[o], s));
    }
    return i.length !== r;
  }
  resolveValue(e) {
    if (Hoe(e)) {
      this._usesThemeColors = !0;
      const t = this._theme.getColor(e.id);
      return t ? t.toString() : "transparent";
    }
    return e;
  }
}
class s1 {
  static getClassName(e, t) {
    return "ced-" + e + "-" + t;
  }
  static getSelector(e, t, i) {
    let r = ".monaco-editor ." + this.getClassName(e, i);
    return t && (r = r + "." + this.getClassName(t, i)), i === 3 ? r += "::before" : i === 4 && (r += "::after"), r;
  }
}
var Ope = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, bW = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let rS = class extends fO {
  constructor(e, t, i) {
    super(e, i), this.onCodeEditorAdd(() => this._checkContextKey()), this.onCodeEditorRemove(() => this._checkContextKey()), this._editorIsOpen = t.createKey("editorIsOpen", !1), this._activeCodeEditor = null;
  }
  _checkContextKey() {
    let e = !1;
    for (const t of this.listCodeEditors())
      if (!t.isSimpleWidget) {
        e = !0;
        break;
      }
    this._editorIsOpen.set(e);
  }
  setActiveCodeEditor(e) {
    this._activeCodeEditor = e;
  }
  getActiveCodeEditor() {
    return this._activeCodeEditor;
  }
  openCodeEditor(e, t, i) {
    return t ? Promise.resolve(this.doOpenEditor(t, e)) : Promise.resolve(null);
  }
  doOpenEditor(e, t) {
    if (!this.findModel(e, t.resource)) {
      if (t.resource) {
        const o = t.resource.scheme;
        if (o === vi.http || o === vi.https)
          return f5(t.resource.toString()), e;
      }
      return null;
    }
    const r = t.options ? t.options.selection : null;
    if (r)
      if (typeof r.endLineNumber == "number" && typeof r.endColumn == "number")
        e.setSelection(r), e.revealRangeInCenter(
          r,
          1
          /* Immediate */
        );
      else {
        const o = {
          lineNumber: r.startLineNumber,
          column: r.startColumn
        };
        e.setPosition(o), e.revealPositionInCenter(
          o,
          1
          /* Immediate */
        );
      }
    return e;
  }
  findModel(e, t) {
    const i = e.getModel();
    return i && i.uri.toString() !== t.toString() ? null : i;
  }
};
rS = Ope([
  bW(1, xi),
  bW(2, er)
], rS);
var WI = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, ci = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let xpe = 0, SW = !1;
function Npe() {
  SW || (SW = !0, Ile(document.body));
}
let oS = class extends tS {
  constructor(e, t, i, r, o, s, a, l, u, c) {
    const h = Object.assign({}, t);
    h.ariaLabel = h.ariaLabel || Ib.editorViewAccessibleLabel, h.ariaLabel = h.ariaLabel + ";" + Ib.accessibilityHelpMessage, super(e, h, {}, i, r, o, s, l, u, c), a instanceof f3 ? this._standaloneKeybindingService = a : this._standaloneKeybindingService = null, Npe();
  }
  addCommand(e, t, i) {
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService"), null;
    let r = "DYNAMIC_" + ++xpe, o = fr.deserialize(i);
    return this._standaloneKeybindingService.addDynamicKeybinding(r, e, t, o), r;
  }
  createContextKey(e, t) {
    return this._contextKeyService.createKey(e, t);
  }
  addAction(e) {
    if (typeof e.id != "string" || typeof e.label != "string" || typeof e.run != "function")
      throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), Ce.None;
    const t = e.id, i = e.label, r = fr.and(fr.equals("editorId", this.getId()), fr.deserialize(e.precondition)), o = e.keybindings, s = fr.and(r, fr.deserialize(e.keybindingContext)), a = e.contextMenuGroupId || null, l = e.contextMenuOrder || 0, u = (f, ...p) => Promise.resolve(e.run(this, ...p)), c = new dt(), h = this.getId() + ":" + t;
    if (c.add(Qn.registerCommand(h, u)), a) {
      let f = {
        command: {
          id: h,
          title: i
        },
        when: r,
        group: a,
        order: l
      };
      c.add(yv.appendMenuItem(si.EditorContext, f));
    }
    if (Array.isArray(o))
      for (const f of o)
        c.add(this._standaloneKeybindingService.addDynamicKeybinding(h, f, u, s));
    let d = new h7(h, i, i, r, u, this._contextKeyService);
    return this._actions[t] = d, c.add(Oi(() => {
      delete this._actions[t];
    })), c;
  }
  _triggerCommand(e, t) {
    if (this._codeEditorService instanceof rS)
      try {
        this._codeEditorService.setActiveCodeEditor(this), super._triggerCommand(e, t);
      } finally {
        this._codeEditorService.setActiveCodeEditor(null);
      }
    else
      super._triggerCommand(e, t);
  }
};
oS = WI([
  ci(2, no),
  ci(3, mr),
  ci(4, Xo),
  ci(5, xi),
  ci(6, xo),
  ci(7, er),
  ci(8, al),
  ci(9, ks)
], oS);
let pO = class extends oS {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g) {
    const _ = Object.assign({}, t);
    Pb(d, _, !1);
    const m = c.registerEditorContainer(e);
    typeof _.theme == "string" && c.setTheme(_.theme), typeof _.autoDetectHighContrast < "u" && c.setAutoDetectHighContrast(!!_.autoDetectHighContrast);
    let v = _.model;
    delete _.model, super(e, _, r, o, s, a, l, c, h, f), this._contextViewService = u, this._configurationService = d, this._standaloneThemeService = c, this._register(i), this._register(m);
    let C;
    if (typeof v > "u" ? (C = R7(p, g, _.value || "", _.language || "text/plain", void 0), this._ownsModel = !0) : (C = v, this._ownsModel = !1), this._attachModel(C), C) {
      let y = {
        oldModelUrl: null,
        newModelUrl: C.uri
      };
      this._onDidChangeModel.fire(y);
    }
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    Pb(this._configurationService, e, !1), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _attachModel(e) {
    super._attachModel(e), this._modelData && this._contextViewService.setContainer(this._modelData.view.domNode.domNode);
  }
  _postDetachModelCleanup(e) {
    super._postDetachModelCleanup(e), e && this._ownsModel && (e.dispose(), this._ownsModel = !1);
  }
};
pO = WI([
  ci(3, no),
  ci(4, mr),
  ci(5, Xo),
  ci(6, xi),
  ci(7, xo),
  ci(8, Bg),
  ci(9, J_),
  ci(10, al),
  ci(11, _r),
  ci(12, ks),
  ci(13, ao),
  ci(14, QN)
], pO);
let gO = class extends dh {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d, f, p, g) {
    const _ = Object.assign({}, t);
    Pb(d, _, !0);
    const m = c.registerEditorContainer(e);
    typeof _.theme == "string" && c.setTheme(_.theme), typeof _.autoDetectHighContrast < "u" && c.setAutoDetectHighContrast(!!_.autoDetectHighContrast), super(e, _, {}, g, l, o, r, u, c, h, f, p), this._contextViewService = a, this._configurationService = d, this._standaloneThemeService = c, this._register(i), this._register(m), this._contextViewService.setContainer(this._containerDomElement);
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    Pb(this._configurationService, e, !0), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _createInnerEditor(e, t, i) {
    return e.createInstance(oS, t, i);
  }
  getOriginalEditor() {
    return super.getOriginalEditor();
  }
  getModifiedEditor() {
    return super.getModifiedEditor();
  }
  addCommand(e, t, i) {
    return this.getModifiedEditor().addCommand(e, t, i);
  }
  createContextKey(e, t) {
    return this.getModifiedEditor().createContextKey(e, t);
  }
  addAction(e) {
    return this.getModifiedEditor().addAction(e);
  }
};
gO = WI([
  ci(3, no),
  ci(4, xi),
  ci(5, xo),
  ci(6, Bg),
  ci(7, sc),
  ci(8, mr),
  ci(9, J_),
  ci(10, al),
  ci(11, _r),
  ci(12, FE),
  ci(13, WE),
  ci(14, kE)
], gO);
function R7(n, e, t, i, r) {
  if (t = t || "", !i) {
    const o = t.indexOf(`
`);
    let s = t;
    return o !== -1 && (s = t.substring(0, o)), EW(n, t, e.createByFilepathOrFirstLine(r || null, s), r);
  }
  return EW(n, t, e.create(i), r);
}
function EW(n, e, t, i) {
  return n.createModel(e, t, i);
}
class Ipe {
  constructor(e) {
    this._languageIdentifier = e;
  }
  getId() {
    return this._languageIdentifier.language;
  }
}
const a1 = "text/plain", LW = "application/unknown";
let sS = [], T7 = [], O7 = [];
function Ay(n, e = !1) {
  const t = Ppe(n);
  sS.push(t), t.userConfigured ? O7.push(t) : T7.push(t), e && !t.userConfigured && sS.forEach((i) => {
    i.mime === t.mime || i.userConfigured || (t.extension && i.extension === t.extension && console.warn(`Overwriting extension <<${t.extension}>> to now point to mime <<${t.mime}>>`), t.filename && i.filename === t.filename && console.warn(`Overwriting filename <<${t.filename}>> to now point to mime <<${t.mime}>>`), t.filepattern && i.filepattern === t.filepattern && console.warn(`Overwriting filepattern <<${t.filepattern}>> to now point to mime <<${t.mime}>>`), t.firstline && i.firstline === t.firstline && console.warn(`Overwriting firstline <<${t.firstline}>> to now point to mime <<${t.mime}>>`));
  });
}
function Ppe(n) {
  return {
    id: n.id,
    mime: n.mime,
    filename: n.filename,
    extension: n.extension,
    filepattern: n.filepattern,
    firstline: n.firstline,
    userConfigured: n.userConfigured,
    filenameLowercase: n.filename ? n.filename.toLowerCase() : void 0,
    extensionLowercase: n.extension ? n.extension.toLowerCase() : void 0,
    filepatternLowercase: n.filepattern ? n.filepattern.toLowerCase() : void 0,
    filepatternOnPath: n.filepattern ? n.filepattern.indexOf(_n.sep) >= 0 : !1
  };
}
function Ape(n, e) {
  let t;
  if (n)
    switch (n.scheme) {
      case vi.file:
        t = n.fsPath;
        break;
      case vi.data:
        t = pb.parseMetaData(n).get(pb.META_DATA_LABEL);
        break;
      default:
        t = n.path;
    }
  if (!t)
    return [LW];
  t = t.toLowerCase();
  const i = zG(t), r = DW(t, i, O7);
  if (r)
    return [r, a1];
  const o = DW(t, i, T7);
  if (o)
    return [o, a1];
  if (e) {
    const s = Mpe(e);
    if (s)
      return [s, a1];
  }
  return [LW];
}
function DW(n, e, t) {
  let i = null, r = null, o = null;
  for (let s = t.length - 1; s >= 0; s--) {
    const a = t[s];
    if (e === a.filenameLowercase) {
      i = a;
      break;
    }
    if (a.filepattern && (!r || a.filepattern.length > r.filepattern.length)) {
      const l = a.filepatternOnPath ? n : e;
      R5(a.filepatternLowercase, l) && (r = a);
    }
    a.extension && (!o || a.extension.length > o.extension.length) && e.endsWith(a.extensionLowercase) && (o = a);
  }
  return i ? i.mime : r ? r.mime : o ? o.mime : null;
}
function Mpe(n) {
  if (UN(n) && (n = n.substr(1)), n.length > 0)
    for (let e = sS.length - 1; e >= 0; e--) {
      const t = sS[e];
      if (!t.firstline)
        continue;
      const i = n.match(t.firstline);
      if (i && i.length > 0)
        return t.mime;
    }
  return null;
}
const Fpe = {
  ModesRegistry: "editor.modesRegistry"
};
class kpe {
  constructor() {
    this._onDidChangeLanguages = new q(), this.onDidChangeLanguages = this._onDidChangeLanguages.event, this._languages = [], this._dynamicLanguages = [];
  }
  // --- languages
  registerLanguage(e) {
    return this._languages.push(e), this._onDidChangeLanguages.fire(void 0), {
      dispose: () => {
        for (let t = 0, i = this._languages.length; t < i; t++)
          if (this._languages[t] === e) {
            this._languages.splice(t, 1);
            return;
          }
      }
    };
  }
  getLanguages() {
    return [].concat(this._languages).concat(this._dynamicLanguages);
  }
}
const Rd = new kpe();
Jn.add(Fpe.ModesRegistry, Rd);
const x7 = "plaintext", Wpe = ".txt", N7 = new XN(
  x7,
  1
  /* PlainText */
);
Rd.registerLanguage({
  id: x7,
  extensions: [Wpe],
  aliases: [b("plainText.alias", "Plain Text"), "text"],
  mimetypes: ["text/plain"]
});
ui.register(N7, {
  brackets: [
    ["(", ")"],
    ["[", "]"],
    ["{", "}"]
  ],
  surroundingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: "<", close: ">" },
    { open: '"', close: '"' },
    { open: "'", close: "'" },
    { open: "`", close: "`" }
  ],
  folding: {
    offSide: !0
  }
}, 0);
const Uh = Object.prototype.hasOwnProperty;
class Vpe extends Ce {
  constructor(e = !0, t = !1) {
    super(), this._onDidChange = this._register(new q()), this.onDidChange = this._onDidChange.event, this._warnOnOverwrite = t, this._nextLanguageId2 = 1, this._languageIdToLanguage = [], this._languageToLanguageId = /* @__PURE__ */ Object.create(null), this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, e && (this._initializeFromRegistry(), this._register(Rd.onDidChangeLanguages((i) => this._initializeFromRegistry())));
  }
  _initializeFromRegistry() {
    this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {};
    const e = Rd.getLanguages();
    this._registerLanguages(e);
  }
  _registerLanguages(e) {
    for (const t of e)
      this._registerLanguage(t);
    this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Object.keys(this._languages).forEach((t) => {
      let i = this._languages[t];
      i.name && (this._nameMap[i.name] = i.identifier), i.aliases.forEach((r) => {
        this._lowercaseNameMap[r.toLowerCase()] = i.identifier;
      }), i.mimetypes.forEach((r) => {
        this._mimeTypesMap[r] = i.identifier;
      });
    }), Jn.as(Ag.Configuration).registerOverrideIdentifiers(Rd.getLanguages().map((t) => t.id)), this._onDidChange.fire();
  }
  _getLanguageId(e) {
    if (this._languageToLanguageId[e])
      return this._languageToLanguageId[e];
    const t = this._nextLanguageId2++;
    return this._languageIdToLanguage[t] = e, this._languageToLanguageId[e] = t, t;
  }
  _registerLanguage(e) {
    const t = e.id;
    let i;
    if (Uh.call(this._languages, t))
      i = this._languages[t];
    else {
      const r = this._getLanguageId(t);
      i = {
        identifier: new XN(t, r),
        name: null,
        mimetypes: [],
        aliases: [],
        extensions: [],
        filenames: [],
        configurationFiles: []
      }, this._languages[t] = i;
    }
    this._mergeLanguage(i, e);
  }
  _mergeLanguage(e, t) {
    const i = t.id;
    let r = null;
    if (Array.isArray(t.mimetypes) && t.mimetypes.length > 0 && (e.mimetypes.push(...t.mimetypes), r = t.mimetypes[0]), r || (r = `text/x-${i}`, e.mimetypes.push(r)), Array.isArray(t.extensions)) {
      t.configuration ? e.extensions = t.extensions.concat(e.extensions) : e.extensions = e.extensions.concat(t.extensions);
      for (let a of t.extensions)
        Ay({ id: i, mime: r, extension: a }, this._warnOnOverwrite);
    }
    if (Array.isArray(t.filenames))
      for (let a of t.filenames)
        Ay({ id: i, mime: r, filename: a }, this._warnOnOverwrite), e.filenames.push(a);
    if (Array.isArray(t.filenamePatterns))
      for (let a of t.filenamePatterns)
        Ay({ id: i, mime: r, filepattern: a }, this._warnOnOverwrite);
    if (typeof t.firstLine == "string" && t.firstLine.length > 0) {
      let a = t.firstLine;
      a.charAt(0) !== "^" && (a = "^" + a);
      try {
        let l = new RegExp(a);
        noe(l) || Ay({ id: i, mime: r, firstline: l }, this._warnOnOverwrite);
      } catch (l) {
        Pi(l);
      }
    }
    e.aliases.push(i);
    let o = null;
    if (typeof t.aliases < "u" && Array.isArray(t.aliases) && (t.aliases.length === 0 ? o = [null] : o = t.aliases), o !== null)
      for (const a of o)
        !a || a.length === 0 || e.aliases.push(a);
    let s = o !== null && o.length > 0;
    if (!(s && o[0] === null)) {
      let a = (s ? o[0] : null) || i;
      (s || !e.name) && (e.name = a);
    }
    t.configuration && e.configurationFiles.push(t.configuration);
  }
  isRegisteredMode(e) {
    return Uh.call(this._mimeTypesMap, e) ? !0 : Uh.call(this._languages, e);
  }
  getModeIdForLanguageNameLowercase(e) {
    return Uh.call(this._lowercaseNameMap, e) ? this._lowercaseNameMap[e].language : null;
  }
  extractModeIds(e) {
    return e ? e.split(",").map((t) => t.trim()).map((t) => Uh.call(this._mimeTypesMap, t) ? this._mimeTypesMap[t].language : t).filter((t) => Uh.call(this._languages, t)) : [];
  }
  getLanguageIdentifier(e) {
    if (e === ZN || e === 0)
      return wb;
    let t;
    if (typeof e == "string")
      t = e;
    else if (t = this._languageIdToLanguage[e], !t)
      return null;
    return Uh.call(this._languages, t) ? this._languages[t].identifier : null;
  }
  getModeIdsFromFilepathOrFirstLine(e, t) {
    if (!e && !t)
      return [];
    let i = Ape(e, t);
    return this.extractModeIds(i.join(","));
  }
}
class RW {
  constructor(e, t) {
    this._selector = t, this.languageIdentifier = this._selector();
    let i;
    this._onDidChange = new q({
      onFirstListenerAdd: () => {
        i = e(() => this._evaluate());
      },
      onLastListenerRemove: () => {
        i.dispose();
      }
    }), this.onDidChange = this._onDidChange.event;
  }
  _evaluate() {
    let e = this._selector();
    e.id !== this.languageIdentifier.id && (this.languageIdentifier = e, this._onDidChange.fire(this.languageIdentifier));
  }
}
class Bpe extends Ce {
  constructor(e = !1) {
    super(), this._onDidCreateMode = this._register(new q()), this.onDidCreateMode = this._onDidCreateMode.event, this._onLanguagesMaybeChanged = this._register(new q({
      leakWarningThreshold: 200
      /* https://github.com/microsoft/vscode/issues/119968 */
    })), this.onLanguagesMaybeChanged = this._onLanguagesMaybeChanged.event, this._instantiatedModes = {}, this._registry = this._register(new Vpe(!0, e)), this._register(this._registry.onDidChange(() => this._onLanguagesMaybeChanged.fire()));
  }
  isRegisteredMode(e) {
    return this._registry.isRegisteredMode(e);
  }
  getModeIdForLanguageName(e) {
    return this._registry.getModeIdForLanguageNameLowercase(e);
  }
  getModeIdByFilepathOrFirstLine(e, t) {
    const i = this._registry.getModeIdsFromFilepathOrFirstLine(e, t);
    return BT(i, null);
  }
  getModeId(e) {
    const t = this._registry.extractModeIds(e);
    return BT(t, null);
  }
  getLanguageIdentifier(e) {
    return this._registry.getLanguageIdentifier(e);
  }
  // --- instantiation
  create(e) {
    return new RW(this.onLanguagesMaybeChanged, () => {
      const t = this.getModeId(e);
      return this._createModeAndGetLanguageIdentifier(t);
    });
  }
  createByFilepathOrFirstLine(e, t) {
    return new RW(this.onLanguagesMaybeChanged, () => {
      const i = this.getModeIdByFilepathOrFirstLine(e, t);
      return this._createModeAndGetLanguageIdentifier(i);
    });
  }
  _createModeAndGetLanguageIdentifier(e) {
    const t = this.getLanguageIdentifier(e || "plaintext") || wb;
    return this._getOrCreateMode(t.language), t;
  }
  triggerMode(e) {
    const t = this.getModeId(e);
    this._getOrCreateMode(t || "plaintext");
  }
  _getOrCreateMode(e) {
    if (!this._instantiatedModes.hasOwnProperty(e)) {
      let t = this.getLanguageIdentifier(e) || wb;
      this._instantiatedModes[e] = new Ipe(t), this._onDidCreateMode.fire(this._instantiatedModes[e]);
    }
    return this._instantiatedModes[e];
  }
}
const VI = Vt("undoRedoService");
class I7 {
  constructor(e, t) {
    this.resource = e, this.elements = t;
  }
}
class ug {
  constructor() {
    this.id = ug._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
}
ug._ID = 0;
ug.None = new ug();
class Vl {
  constructor() {
    this.id = Vl._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
}
Vl._ID = 0;
Vl.None = new Vl();
class Hpe {
  constructor(e, t, i) {
    this._legend = e, this._themeService = t, this._logService = i, this._hashTable = new Vu(), this._hasWarnedOverlappingTokens = !1;
  }
  getMetadata(e, t, i) {
    const r = this._hashTable.get(e, t, i.id);
    let o;
    if (r)
      o = r.metadata, this._logService.getLevel() === Ya.Trace && this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${e} / ${t}: foreground ${la.getForeground(o)}, fontStyle ${la.getFontStyle(o).toString(2)}`);
    else {
      let s = this._legend.tokenTypes[e];
      const a = [];
      if (s) {
        let l = t;
        for (let c = 0; l > 0 && c < this._legend.tokenModifiers.length; c++)
          l & 1 && a.push(this._legend.tokenModifiers[c]), l = l >> 1;
        l > 0 && this._logService.getLevel() === Ya.Trace && (this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${t.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`), a.push("not-in-legend"));
        const u = this._themeService.getColorTheme().getTokenStyleMetadata(s, a, i.language);
        if (typeof u > "u")
          o = 2147483647;
        else {
          if (o = 0, typeof u.italic < "u") {
            const c = (u.italic ? 1 : 0) << 11;
            o |= c | 1;
          }
          if (typeof u.bold < "u") {
            const c = (u.bold ? 2 : 0) << 11;
            o |= c | 2;
          }
          if (typeof u.underline < "u") {
            const c = (u.underline ? 4 : 0) << 11;
            o |= c | 4;
          }
          if (u.foreground) {
            const c = u.foreground << 14;
            o |= c | 8;
          }
          o === 0 && (o = 2147483647);
        }
      } else
        this._logService.getLevel() === Ya.Trace && this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${e} for legend: ${JSON.stringify(this._legend.tokenTypes)}`), o = 2147483647, s = "not-in-legend";
      this._hashTable.add(e, t, i.id, o), this._logService.getLevel() === Ya.Trace && this._logService.trace(`SemanticTokensProviderStyling ${e} (${s}) / ${t} (${a.join(" ")}): foreground ${la.getForeground(o)}, fontStyle ${la.getFontStyle(o).toString(2)}`);
    }
    return o;
  }
  warnOverlappingSemanticTokens(e, t) {
    this._hasWarnedOverlappingTokens || (this._hasWarnedOverlappingTokens = !0, console.warn(`Overlapping semantic tokens detected at lineNumber ${e}, column ${t}`));
  }
}
function Gpe(n, e, t) {
  const i = n.data, r = n.data.length / 5 | 0, o = Math.max(
    Math.ceil(
      r / 1024
      /* DesiredMaxAreas */
    ),
    400
    /* DesiredTokensPerArea */
  ), s = [];
  let a = 0, l = 1, u = 0;
  for (; a < r; ) {
    const c = a;
    let h = Math.min(c + o, r);
    if (h < r) {
      let C = h;
      for (; C - 1 > c && i[5 * C] === 0; )
        C--;
      if (C - 1 === c) {
        let y = h;
        for (; y + 1 < r && i[5 * y] === 0; )
          y++;
        h = y;
      } else
        h = C;
    }
    let d = new Uint32Array((h - c) * 4), f = 0, p = 0, g = 0, _ = 0, m = 0;
    for (; a < h; ) {
      const C = 5 * a, y = i[C], w = i[C + 1], L = l + y, S = y === 0 ? u + w : w, E = i[C + 2], D = i[C + 3], x = i[C + 4], R = e.getMetadata(D, x, t);
      R !== 2147483647 && (p === 0 && (p = L), g === L && m > S && (e.warnOverlappingSemanticTokens(L, S + 1), _ < S ? d[f - 4 + 2] = S : f -= 4), d[f] = L - p, d[f + 1] = S, d[f + 2] = S + E, d[f + 3] = R, f += 4, g = L, _ = S, m = S + E), l = L, u = S, a++;
    }
    f !== d.length && (d = d.subarray(0, f));
    const v = new Vb(p, new Wb(d));
    s.push(v);
  }
  return s;
}
class Upe {
  constructor(e, t, i, r) {
    this.tokenTypeIndex = e, this.tokenModifierSet = t, this.languageId = i, this.metadata = r, this.next = null;
  }
}
class Vu {
  constructor() {
    this._elementsCount = 0, this._currentLengthIndex = 0, this._currentLength = Vu._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < Vu._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], Vu._nullOutEntries(this._elements, this._currentLength);
  }
  static _nullOutEntries(e, t) {
    for (let i = 0; i < t; i++)
      e[i] = null;
  }
  _hash2(e, t) {
    return (e << 5) - e + t | 0;
  }
  _hashFunc(e, t, i) {
    return this._hash2(this._hash2(e, t), i) % this._currentLength;
  }
  get(e, t, i) {
    const r = this._hashFunc(e, t, i);
    let o = this._elements[r];
    for (; o; ) {
      if (o.tokenTypeIndex === e && o.tokenModifierSet === t && o.languageId === i)
        return o;
      o = o.next;
    }
    return null;
  }
  add(e, t, i, r) {
    if (this._elementsCount++, this._growCount !== 0 && this._elementsCount >= this._growCount) {
      const o = this._elements;
      this._currentLengthIndex++, this._currentLength = Vu._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < Vu._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], Vu._nullOutEntries(this._elements, this._currentLength);
      for (const s of o) {
        let a = s;
        for (; a; ) {
          const l = a.next;
          a.next = null, this._add(a), a = l;
        }
      }
    }
    this._add(new Upe(e, t, i, r));
  }
  _add(e) {
    const t = this._hashFunc(e.tokenTypeIndex, e.tokenModifierSet, e.languageId);
    e.next = this._elements[t], this._elements[t] = e;
  }
}
Vu._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];
function zpe(n) {
  for (let e = 0, t = n.length; e < t; e += 4) {
    const i = n[e + 0], r = n[e + 1], o = n[e + 2], s = n[e + 3];
    n[e + 0] = s, n[e + 1] = o, n[e + 2] = r, n[e + 3] = i;
  }
}
function jpe(n) {
  const e = new Uint8Array(n.buffer, n.byteOffset, n.length * 4);
  return AG() || zpe(e), rE.wrap(e);
}
function P7(n) {
  const e = new Uint32Array($pe(n));
  let t = 0;
  if (e[t++] = n.id, n.type === "full")
    e[t++] = 1, e[t++] = n.data.length, e.set(n.data, t), t += n.data.length;
  else {
    e[t++] = 2, e[t++] = n.deltas.length;
    for (const i of n.deltas)
      e[t++] = i.start, e[t++] = i.deleteCount, i.data ? (e[t++] = i.data.length, e.set(i.data, t), t += i.data.length) : e[t++] = 0;
  }
  return jpe(e);
}
function $pe(n) {
  let e = 0;
  if (e += 1 + 1, n.type === "full")
    e += 1 + n.data.length;
  else {
    e += 1, e += (1 + 1 + 1) * n.deltas.length;
    for (const t of n.deltas)
      t.data && (e += t.data.length);
  }
  return e;
}
var VE = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function BI(n) {
  return n && !!n.data;
}
function Kpe(n) {
  return n && Array.isArray(n.edits);
}
function A7(n, e, t) {
  const i = M7(n);
  return i ? {
    provider: i,
    request: Promise.resolve(i.provideDocumentSemanticTokens(n, e, t))
  } : null;
}
function M7(n) {
  const e = yb.ordered(n);
  return e.length > 0 ? e[0] : null;
}
function F7(n) {
  const e = A5.ordered(n);
  return e.length > 0 ? e[0] : null;
}
Qn.registerCommand("_provideDocumentSemanticTokensLegend", (n, ...e) => VE(void 0, void 0, void 0, function* () {
  const [t] = e;
  $o(t instanceof ft);
  const i = n.get(ao).getModel(t);
  if (!i)
    return;
  const r = M7(i);
  return r ? r.getLegend() : n.get(Xo).executeCommand("_provideDocumentRangeSemanticTokensLegend", t);
}));
Qn.registerCommand("_provideDocumentSemanticTokens", (n, ...e) => VE(void 0, void 0, void 0, function* () {
  const [t] = e;
  $o(t instanceof ft);
  const i = n.get(ao).getModel(t);
  if (!i)
    return;
  const r = A7(i, null, Ko.None);
  if (!r)
    return n.get(Xo).executeCommand("_provideDocumentRangeSemanticTokens", t, i.getFullModelRange());
  const { provider: o, request: s } = r;
  let a;
  try {
    a = yield s;
  } catch (u) {
    k_(u);
    return;
  }
  if (!a || !BI(a))
    return;
  const l = P7({
    id: 0,
    type: "full",
    data: a.data
  });
  return a.resultId && o.releaseDocumentSemanticTokens(a.resultId), l;
}));
Qn.registerCommand("_provideDocumentRangeSemanticTokensLegend", (n, ...e) => VE(void 0, void 0, void 0, function* () {
  const [t] = e;
  $o(t instanceof ft);
  const i = n.get(ao).getModel(t);
  if (!i)
    return;
  const r = F7(i);
  if (r)
    return r.getLegend();
}));
Qn.registerCommand("_provideDocumentRangeSemanticTokens", (n, ...e) => VE(void 0, void 0, void 0, function* () {
  const [t, i] = e;
  $o(t instanceof ft), $o(G.isIRange(i));
  const r = n.get(ao).getModel(t);
  if (!r)
    return;
  const o = F7(r);
  if (!o)
    return;
  let s;
  try {
    s = yield o.provideDocumentRangeSemanticTokens(r, G.lift(i), Ko.None);
  } catch (a) {
    k_(a);
    return;
  }
  if (!(!s || !BI(s)))
    return P7({
      id: 0,
      type: "full",
      data: s.data
    });
}));
var qpe = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, zm = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
function xc(n) {
  return n.toString();
}
function TW(n) {
  const e = new oE(), t = n.createSnapshot();
  let i;
  for (; i = t.read(); )
    e.update(i);
  return e.digest();
}
class Ype {
  constructor(e, t, i) {
    this._modelEventListeners = new dt(), this.model = e, this._languageSelection = null, this._languageSelectionListener = null, this._modelEventListeners.add(e.onWillDispose(() => t(e))), this._modelEventListeners.add(e.onDidChangeLanguage((r) => i(e, r)));
  }
  _disposeLanguageSelection() {
    this._languageSelectionListener && (this._languageSelectionListener.dispose(), this._languageSelectionListener = null);
  }
  dispose() {
    this._modelEventListeners.dispose(), this._disposeLanguageSelection();
  }
  setLanguage(e) {
    this._disposeLanguageSelection(), this._languageSelection = e, this._languageSelectionListener = this._languageSelection.onDidChange(() => this.model.setMode(e.languageIdentifier)), this.model.setMode(e.languageIdentifier);
  }
}
const Xpe = Is || kt ? 1 : 2;
class Zpe {
  constructor(e, t, i, r, o, s, a, l) {
    this.uri = e, this.initialUndoRedoSnapshot = t, this.time = i, this.sharesUndoRedoStack = r, this.heapSize = o, this.sha1 = s, this.versionId = a, this.alternativeVersionId = l;
  }
}
function Qpe(n) {
  return n.scheme === vi.file || n.scheme === vi.vscodeRemote || n.scheme === vi.userData || n.scheme === "fake-fs";
}
let aS = class iv extends Ce {
  constructor(e, t, i, r, o) {
    super(), this._configurationService = e, this._resourcePropertiesService = t, this._themeService = i, this._logService = r, this._undoRedoService = o, this._onModelAdded = this._register(new q()), this.onModelAdded = this._onModelAdded.event, this._onModelRemoved = this._register(new q()), this.onModelRemoved = this._onModelRemoved.event, this._onModelModeChanged = this._register(new q()), this.onModelModeChanged = this._onModelModeChanged.event, this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null), this._models = {}, this._disposedModels = /* @__PURE__ */ new Map(), this._disposedModelsHeapSize = 0, this._semanticStyling = this._register(new ege(this._themeService, this._logService)), this._register(this._configurationService.onDidChangeConfiguration(() => this._updateModelOptions())), this._updateModelOptions(), this._register(new Jpe(this, this._themeService, this._configurationService, this._semanticStyling));
  }
  static _readModelOptions(e, t) {
    let i = bo.tabSize;
    if (e.editor && typeof e.editor.tabSize < "u") {
      const h = parseInt(e.editor.tabSize, 10);
      isNaN(h) || (i = h), i < 1 && (i = 1);
    }
    let r = i;
    if (e.editor && typeof e.editor.indentSize < "u" && e.editor.indentSize !== "tabSize") {
      const h = parseInt(e.editor.indentSize, 10);
      isNaN(h) || (r = h), r < 1 && (r = 1);
    }
    let o = bo.insertSpaces;
    e.editor && typeof e.editor.insertSpaces < "u" && (o = e.editor.insertSpaces === "false" ? !1 : !!e.editor.insertSpaces);
    let s = Xpe;
    const a = e.eol;
    a === `\r
` ? s = 2 : a === `
` && (s = 1);
    let l = bo.trimAutoWhitespace;
    e.editor && typeof e.editor.trimAutoWhitespace < "u" && (l = e.editor.trimAutoWhitespace === "false" ? !1 : !!e.editor.trimAutoWhitespace);
    let u = bo.detectIndentation;
    e.editor && typeof e.editor.detectIndentation < "u" && (u = e.editor.detectIndentation === "false" ? !1 : !!e.editor.detectIndentation);
    let c = bo.largeFileOptimizations;
    return e.editor && typeof e.editor.largeFileOptimizations < "u" && (c = e.editor.largeFileOptimizations === "false" ? !1 : !!e.editor.largeFileOptimizations), {
      isForSimpleWidget: t,
      tabSize: i,
      indentSize: r,
      insertSpaces: o,
      detectIndentation: u,
      defaultEOL: s,
      trimAutoWhitespace: l,
      largeFileOptimizations: c
    };
  }
  _getEOL(e, t) {
    if (e)
      return this._resourcePropertiesService.getEOL(e, t);
    const i = this._configurationService.getValue("files.eol", { overrideIdentifier: t });
    return i && i !== "auto" ? i : ja === 3 || ja === 2 ? `
` : `\r
`;
  }
  _shouldRestoreUndoStack() {
    const e = this._configurationService.getValue("files.restoreUndoStack");
    return typeof e == "boolean" ? e : !0;
  }
  getCreationOptions(e, t, i) {
    let r = this._modelCreationOptionsByLanguageAndResource[e + t];
    if (!r) {
      const o = this._configurationService.getValue("editor", { overrideIdentifier: e, resource: t }), s = this._getEOL(t, e);
      r = iv._readModelOptions({ editor: o, eol: s }, i), this._modelCreationOptionsByLanguageAndResource[e + t] = r;
    }
    return r;
  }
  _updateModelOptions() {
    const e = this._modelCreationOptionsByLanguageAndResource;
    this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
    const t = Object.keys(this._models);
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i], s = this._models[o], a = s.model.getLanguageIdentifier().language, l = s.model.uri, u = e[a + l], c = this.getCreationOptions(a, l, s.model.isForSimpleWidget);
      iv._setModelOptionsForModel(s.model, c, u);
    }
  }
  static _setModelOptionsForModel(e, t, i) {
    i && i.defaultEOL !== t.defaultEOL && e.getLineCount() === 1 && e.setEOL(
      t.defaultEOL === 1 ? 0 : 1
      /* CRLF */
    ), !(i && i.detectIndentation === t.detectIndentation && i.insertSpaces === t.insertSpaces && i.tabSize === t.tabSize && i.indentSize === t.indentSize && i.trimAutoWhitespace === t.trimAutoWhitespace) && (t.detectIndentation ? (e.detectIndentation(t.insertSpaces, t.tabSize), e.updateOptions({
      trimAutoWhitespace: t.trimAutoWhitespace
    })) : e.updateOptions({
      insertSpaces: t.insertSpaces,
      tabSize: t.tabSize,
      indentSize: t.indentSize,
      trimAutoWhitespace: t.trimAutoWhitespace
    }));
  }
  // --- begin IModelService
  _insertDisposedModel(e) {
    this._disposedModels.set(xc(e.uri), e), this._disposedModelsHeapSize += e.heapSize;
  }
  _removeDisposedModel(e) {
    const t = this._disposedModels.get(xc(e));
    return t && (this._disposedModelsHeapSize -= t.heapSize), this._disposedModels.delete(xc(e)), t;
  }
  _ensureDisposedModelsHeapSize(e) {
    if (this._disposedModelsHeapSize > e) {
      const t = [];
      for (this._disposedModels.forEach((i) => {
        i.sharesUndoRedoStack || t.push(i);
      }), t.sort((i, r) => i.time - r.time); t.length > 0 && this._disposedModelsHeapSize > e; ) {
        const i = t.shift();
        this._removeDisposedModel(i.uri), i.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(i.initialUndoRedoSnapshot);
      }
    }
  }
  _createModelData(e, t, i, r) {
    const o = this.getCreationOptions(t.language, i, r), s = new Xr(e, o, t, i, this._undoRedoService);
    if (i && this._disposedModels.has(xc(i))) {
      const u = this._removeDisposedModel(i), c = this._undoRedoService.getElements(i), h = TW(s) === u.sha1;
      if (h || u.sharesUndoRedoStack) {
        for (const d of c.past)
          Mu(d) && d.matchesResource(i) && d.setModel(s);
        for (const d of c.future)
          Mu(d) && d.matchesResource(i) && d.setModel(s);
        this._undoRedoService.setElementsValidFlag(i, !0, (d) => Mu(d) && d.matchesResource(i)), h && (s._overwriteVersionId(u.versionId), s._overwriteAlternativeVersionId(u.alternativeVersionId), s._overwriteInitialUndoRedoSnapshot(u.initialUndoRedoSnapshot));
      } else
        u.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(u.initialUndoRedoSnapshot);
    }
    const a = xc(s.uri);
    if (this._models[a])
      throw new Error("ModelService: Cannot add model because it already exists!");
    const l = new Ype(s, (u) => this._onWillDispose(u), (u, c) => this._onDidChangeLanguage(u, c));
    return this._models[a] = l, l;
  }
  createModel(e, t, i, r = !1) {
    let o;
    return t ? (o = this._createModelData(e, t.languageIdentifier, i, r), this.setMode(o.model, t)) : o = this._createModelData(e, N7, i, r), this._onModelAdded.fire(o.model), o.model;
  }
  setMode(e, t) {
    if (!t)
      return;
    const i = this._models[xc(e.uri)];
    i && i.setLanguage(t);
  }
  getModels() {
    const e = [], t = Object.keys(this._models);
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      e.push(this._models[o].model);
    }
    return e;
  }
  getModel(e) {
    const t = xc(e), i = this._models[t];
    return i ? i.model : null;
  }
  getSemanticTokensProviderStyling(e) {
    return this._semanticStyling.get(e);
  }
  // --- end IModelService
  _onWillDispose(e) {
    const t = xc(e.uri), i = this._models[t], r = this._undoRedoService.getUriComparisonKey(e.uri) !== e.uri.toString();
    let o = !1, s = 0;
    if (r || this._shouldRestoreUndoStack() && Qpe(e.uri)) {
      const l = this._undoRedoService.getElements(e.uri);
      if (l.past.length > 0 || l.future.length > 0) {
        for (const u of l.past)
          Mu(u) && u.matchesResource(e.uri) && (o = !0, s += u.heapSize(e.uri), u.setModel(e.uri));
        for (const u of l.future)
          Mu(u) && u.matchesResource(e.uri) && (o = !0, s += u.heapSize(e.uri), u.setModel(e.uri));
      }
    }
    const a = iv.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;
    if (o)
      if (!r && s > a) {
        const l = i.model.getInitialUndoRedoSnapshot();
        l !== null && this._undoRedoService.restoreSnapshot(l);
      } else
        this._ensureDisposedModelsHeapSize(a - s), this._undoRedoService.setElementsValidFlag(e.uri, !1, (l) => Mu(l) && l.matchesResource(e.uri)), this._insertDisposedModel(new Zpe(e.uri, i.model.getInitialUndoRedoSnapshot(), Date.now(), r, s, TW(e), e.getVersionId(), e.getAlternativeVersionId()));
    else if (!r) {
      const l = i.model.getInitialUndoRedoSnapshot();
      l !== null && this._undoRedoService.restoreSnapshot(l);
    }
    delete this._models[t], i.dispose(), delete this._modelCreationOptionsByLanguageAndResource[e.getLanguageIdentifier().language + e.uri], this._onModelRemoved.fire(e);
  }
  _onDidChangeLanguage(e, t) {
    const i = t.oldLanguage, r = e.getLanguageIdentifier().language, o = this.getCreationOptions(i, e.uri, e.isForSimpleWidget), s = this.getCreationOptions(r, e.uri, e.isForSimpleWidget);
    iv._setModelOptionsForModel(e, s, o), this._onModelModeChanged.fire({ model: e, oldModeId: i });
  }
};
aS.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024;
aS = qpe([
  zm(0, _r),
  zm(1, j5),
  zm(2, er),
  zm(3, K_),
  zm(4, VI)
], aS);
const k7 = "editor.semanticHighlighting";
function OW(n, e, t) {
  var i;
  const r = (i = t.getValue(k7, { overrideIdentifier: n.getLanguageIdentifier().language, resource: n.uri })) === null || i === void 0 ? void 0 : i.enabled;
  return typeof r == "boolean" ? r : e.getColorTheme().semanticHighlighting;
}
class Jpe extends Ce {
  constructor(e, t, i, r) {
    super(), this._watchers = /* @__PURE__ */ Object.create(null), this._semanticStyling = r;
    const o = (l) => {
      this._watchers[l.uri.toString()] = new hd(l, t, this._semanticStyling);
    }, s = (l, u) => {
      u.dispose(), delete this._watchers[l.uri.toString()];
    }, a = () => {
      for (let l of e.getModels()) {
        const u = this._watchers[l.uri.toString()];
        OW(l, t, i) ? u || o(l) : u && s(l, u);
      }
    };
    this._register(e.onModelAdded((l) => {
      OW(l, t, i) && o(l);
    })), this._register(e.onModelRemoved((l) => {
      const u = this._watchers[l.uri.toString()];
      u && s(l, u);
    })), this._register(i.onDidChangeConfiguration((l) => {
      l.affectsConfiguration(k7) && a();
    })), this._register(t.onDidColorThemeChange(a));
  }
}
class ege extends Ce {
  constructor(e, t) {
    super(), this._themeService = e, this._logService = t, this._caches = /* @__PURE__ */ new WeakMap(), this._register(this._themeService.onDidColorThemeChange(() => {
      this._caches = /* @__PURE__ */ new WeakMap();
    }));
  }
  get(e) {
    return this._caches.has(e) || this._caches.set(e, new Hpe(e.getLegend(), this._themeService, this._logService)), this._caches.get(e);
  }
}
class tge {
  constructor(e, t, i) {
    this._provider = e, this.resultId = t, this.data = i;
  }
  dispose() {
    this._provider.releaseDocumentSemanticTokens(this.resultId);
  }
}
class hd extends Ce {
  constructor(e, t, i) {
    super(), this._isDisposed = !1, this._model = e, this._semanticStyling = i, this._fetchDocumentSemanticTokens = this._register(new ro(() => this._fetchDocumentSemanticTokensNow(), hd.FETCH_DOCUMENT_SEMANTIC_TOKENS_DELAY)), this._currentDocumentResponse = null, this._currentDocumentRequestCancellationTokenSource = null, this._documentProvidersChangeListeners = [], this._register(this._model.onDidChangeContent(() => {
      this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule();
    })), this._register(this._model.onDidChangeLanguage(() => {
      this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule(0);
    }));
    const r = () => {
      bi(this._documentProvidersChangeListeners), this._documentProvidersChangeListeners = [];
      for (const o of yb.all(e))
        typeof o.onDidChange == "function" && this._documentProvidersChangeListeners.push(o.onDidChange(() => this._fetchDocumentSemanticTokens.schedule(0)));
    };
    r(), this._register(yb.onDidChange(() => {
      r(), this._fetchDocumentSemanticTokens.schedule();
    })), this._register(t.onDidColorThemeChange((o) => {
      this._setDocumentSemanticTokens(null, null, null, []), this._fetchDocumentSemanticTokens.schedule();
    })), this._fetchDocumentSemanticTokens.schedule(0);
  }
  dispose() {
    this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._currentDocumentRequestCancellationTokenSource && (this._currentDocumentRequestCancellationTokenSource.cancel(), this._currentDocumentRequestCancellationTokenSource = null), this._setDocumentSemanticTokens(null, null, null, []), this._isDisposed = !0, super.dispose();
  }
  _fetchDocumentSemanticTokensNow() {
    if (this._currentDocumentRequestCancellationTokenSource)
      return;
    const e = new mh(), t = this._currentDocumentResponse && this._currentDocumentResponse.resultId || null, i = A7(this._model, t, e.token);
    if (!i) {
      this._currentDocumentResponse && this._model.setSemanticTokens(null, !1);
      return;
    }
    const { provider: r, request: o } = i;
    this._currentDocumentRequestCancellationTokenSource = e;
    const s = [], a = this._model.onDidChangeContent((u) => {
      s.push(u);
    }), l = this._semanticStyling.get(r);
    o.then((u) => {
      this._currentDocumentRequestCancellationTokenSource = null, a.dispose(), this._setDocumentSemanticTokens(r, u || null, l, s);
    }, (u) => {
      u && (W_(u) || typeof u.message == "string" && u.message.indexOf("busy") !== -1) || Pi(u), this._currentDocumentRequestCancellationTokenSource = null, a.dispose(), s.length > 0 && (this._fetchDocumentSemanticTokens.isScheduled() || this._fetchDocumentSemanticTokens.schedule());
    });
  }
  static _copy(e, t, i, r, o) {
    for (let s = 0; s < o; s++)
      i[r + s] = e[t + s];
  }
  _setDocumentSemanticTokens(e, t, i, r) {
    const o = this._currentDocumentResponse, s = () => {
      r.length > 0 && !this._fetchDocumentSemanticTokens.isScheduled() && this._fetchDocumentSemanticTokens.schedule();
    };
    if (this._currentDocumentResponse && (this._currentDocumentResponse.dispose(), this._currentDocumentResponse = null), this._isDisposed) {
      e && t && e.releaseDocumentSemanticTokens(t.resultId);
      return;
    }
    if (!e || !i) {
      this._model.setSemanticTokens(null, !1);
      return;
    }
    if (!t) {
      this._model.setSemanticTokens(null, !0), s();
      return;
    }
    if (Kpe(t)) {
      if (!o) {
        this._model.setSemanticTokens(null, !0);
        return;
      }
      if (t.edits.length === 0)
        t = {
          resultId: t.resultId,
          data: o.data
        };
      else {
        let a = 0;
        for (const d of t.edits)
          a += (d.data ? d.data.length : 0) - d.deleteCount;
        const l = o.data, u = new Uint32Array(l.length + a);
        let c = l.length, h = u.length;
        for (let d = t.edits.length - 1; d >= 0; d--) {
          const f = t.edits[d], p = c - (f.start + f.deleteCount);
          p > 0 && (hd._copy(l, c - p, u, h - p, p), h -= p), f.data && (hd._copy(f.data, 0, u, h - f.data.length, f.data.length), h -= f.data.length), c = f.start;
        }
        c > 0 && hd._copy(l, 0, u, 0, c), t = {
          resultId: t.resultId,
          data: u
        };
      }
    }
    if (BI(t)) {
      this._currentDocumentResponse = new tge(e, t.resultId, t.data);
      const a = Gpe(t, i, this._model.getLanguageIdentifier());
      if (r.length > 0)
        for (const l of r)
          for (const u of a)
            for (const c of l.changes)
              u.applyEdit(c.range, c.text);
      this._model.setSemanticTokens(a, !0);
    } else
      this._model.setSemanticTokens(null, !0);
    s();
  }
}
hd.FETCH_DOCUMENT_SEMANTIC_TOKENS_DELAY = 300;
class ige {
  constructor(e, t, i, r, o) {
    this.token = e, this.index = t, this.fontStyle = i, this.foreground = r, this.background = o;
  }
}
function nge(n) {
  if (!n || !Array.isArray(n))
    return [];
  let e = [], t = 0;
  for (let i = 0, r = n.length; i < r; i++) {
    let o = n[i], s = -1;
    if (typeof o.fontStyle == "string") {
      s = 0;
      let u = o.fontStyle.split(" ");
      for (let c = 0, h = u.length; c < h; c++)
        switch (u[c]) {
          case "italic":
            s = s | 1;
            break;
          case "bold":
            s = s | 2;
            break;
          case "underline":
            s = s | 4;
            break;
        }
    }
    let a = null;
    typeof o.foreground == "string" && (a = o.foreground);
    let l = null;
    typeof o.background == "string" && (l = o.background), e[t++] = new ige(o.token || "", i, s, a, l);
  }
  return e;
}
function rge(n, e) {
  n.sort((c, h) => {
    let d = uge(c.token, h.token);
    return d !== 0 ? d : c.index - h.index;
  });
  let t = 0, i = "000000", r = "ffffff";
  for (; n.length >= 1 && n[0].token === ""; ) {
    let c = n.shift();
    c.fontStyle !== -1 && (t = c.fontStyle), c.foreground !== null && (i = c.foreground), c.background !== null && (r = c.background);
  }
  let o = new sge();
  for (let c of e)
    o.getId(c);
  let s = o.getId(i), a = o.getId(r), l = new HI(t, s, a), u = new GI(l);
  for (let c = 0, h = n.length; c < h; c++) {
    let d = n[c];
    u.insert(d.token, d.fontStyle, o.getId(d.foreground), o.getId(d.background));
  }
  return new W7(o, u);
}
const oge = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
class sge {
  constructor() {
    this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ new Map();
  }
  getId(e) {
    if (e === null)
      return 0;
    const t = e.match(oge);
    if (!t)
      throw new Error("Illegal value for token color: " + e);
    e = t[1].toUpperCase();
    let i = this._color2id.get(e);
    return i || (i = ++this._lastColorId, this._color2id.set(e, i), this._id2color[i] = ne.fromHex("#" + e), i);
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}
class W7 {
  constructor(e, t) {
    this._colorMap = e, this._root = t, this._cache = /* @__PURE__ */ new Map();
  }
  static createFromRawTokenTheme(e, t) {
    return this.createFromParsedTokenTheme(nge(e), t);
  }
  static createFromParsedTokenTheme(e, t) {
    return rge(e, t);
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  _match(e) {
    return this._root.match(e);
  }
  match(e, t) {
    let i = this._cache.get(t);
    if (typeof i > "u") {
      let r = this._match(t), o = lge(t);
      i = (r.metadata | o << 8) >>> 0, this._cache.set(t, i);
    }
    return (i | e << 0) >>> 0;
  }
}
const age = /\b(comment|string|regex|regexp)\b/;
function lge(n) {
  let e = n.match(age);
  if (!e)
    return 0;
  switch (e[1]) {
    case "comment":
      return 1;
    case "string":
      return 2;
    case "regex":
      return 4;
    case "regexp":
      return 4;
  }
  throw new Error("Unexpected match for standard token type!");
}
function uge(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
class HI {
  constructor(e, t, i) {
    this._fontStyle = e, this._foreground = t, this._background = i, this.metadata = (this._fontStyle << 11 | this._foreground << 14 | this._background << 23) >>> 0;
  }
  clone() {
    return new HI(this._fontStyle, this._foreground, this._background);
  }
  acceptOverwrite(e, t, i) {
    e !== -1 && (this._fontStyle = e), t !== 0 && (this._foreground = t), i !== 0 && (this._background = i), this.metadata = (this._fontStyle << 11 | this._foreground << 14 | this._background << 23) >>> 0;
  }
}
class GI {
  constructor(e) {
    this._mainRule = e, this._children = /* @__PURE__ */ new Map();
  }
  match(e) {
    if (e === "")
      return this._mainRule;
    let t = e.indexOf("."), i, r;
    t === -1 ? (i = e, r = "") : (i = e.substring(0, t), r = e.substring(t + 1));
    let o = this._children.get(i);
    return typeof o < "u" ? o.match(r) : this._mainRule;
  }
  insert(e, t, i, r) {
    if (e === "") {
      this._mainRule.acceptOverwrite(t, i, r);
      return;
    }
    let o = e.indexOf("."), s, a;
    o === -1 ? (s = e, a = "") : (s = e.substring(0, o), a = e.substring(o + 1));
    let l = this._children.get(s);
    typeof l > "u" && (l = new GI(this._mainRule.clone()), this._children.set(s, l)), l.insert(a, t, i, r);
  }
}
function cge(n) {
  let e = [];
  for (let t = 1, i = n.length; t < i; t++) {
    let r = n[t];
    e[t] = `.mtk${t} { color: ${r}; }`;
  }
  return e.push(".mtki { font-style: italic; }"), e.push(".mtkb { font-weight: bold; }"), e.push(".mtku { text-decoration: underline; text-underline-position: under; }"), e.join(`
`);
}
const hge = {
  base: "vs",
  inherit: !1,
  rules: [
    { token: "", foreground: "000000", background: "fffffe" },
    { token: "invalid", foreground: "cd3131" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "001188" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "delimiter.xml", foreground: "0000FF" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "FF0000" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "FF0000" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "attribute.value.number", foreground: "098658" },
    { token: "attribute.value.unit", foreground: "098658" },
    { token: "attribute.value.html", foreground: "0000FF" },
    { token: "attribute.value.xml", foreground: "0000FF" },
    { token: "string", foreground: "A31515" },
    { token: "string.html", foreground: "0000FF" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "string.yaml", foreground: "0451A5" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.json", foreground: "0451A5" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "keyword.flow.scss", foreground: "0000FF" },
    { token: "operator.scss", foreground: "666666" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [Xu]: "#FFFFFE",
    [Z_]: "#000000",
    [EI]: "#E5EBF1",
    [xE]: "#D3D3D3",
    [NE]: "#939393",
    [j3]: "#ADD6FF4D",
    [ahe]: "#9DDDFF"
  }
}, dge = {
  base: "vs-dark",
  inherit: !1,
  rules: [
    { token: "", foreground: "D4D4D4", background: "1E1E1E" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "74B0DF" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "B5CEA8" },
    { token: "number.hex", foreground: "5BB498" },
    { token: "regexp", foreground: "B46695" },
    { token: "annotation", foreground: "cc6666" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "DCDCDC" },
    { token: "delimiter.html", foreground: "808080" },
    { token: "delimiter.xml", foreground: "808080" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "A79873" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "DD6A6F" },
    { token: "metatag.content.html", foreground: "9CDCFE" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key.json", foreground: "9CDCFE" },
    { token: "string.value.json", foreground: "CE9178" },
    { token: "attribute.name", foreground: "9CDCFE" },
    { token: "attribute.value", foreground: "CE9178" },
    { token: "attribute.value.number.css", foreground: "B5CEA8" },
    { token: "attribute.value.unit.css", foreground: "B5CEA8" },
    { token: "attribute.value.hex.css", foreground: "D4D4D4" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "keyword.json", foreground: "CE9178" },
    { token: "keyword.flow.scss", foreground: "569CD6" },
    { token: "operator.scss", foreground: "909090" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [Xu]: "#1E1E1E",
    [Z_]: "#D4D4D4",
    [EI]: "#3A3D41",
    [xE]: "#404040",
    [NE]: "#707070",
    [j3]: "#ADD6FF26"
  }
}, fge = {
  base: "hc-black",
  inherit: !1,
  rules: [
    { token: "", foreground: "FFFFFF", background: "000000" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "1AEBFF" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "FFFFFF" },
    { token: "regexp", foreground: "C0C0C0" },
    { token: "annotation", foreground: "569CD6" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "FFFF00" },
    { token: "delimiter.html", foreground: "FFFF00" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta", foreground: "D4D4D4" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "569CD6" },
    { token: "metatag.content.html", foreground: "1AEBFF" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key", foreground: "9CDCFE" },
    { token: "string.value", foreground: "CE9178" },
    { token: "attribute.name", foreground: "569CD6" },
    { token: "attribute.value", foreground: "3FF23F" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [Xu]: "#000000",
    [Z_]: "#FFFFFF",
    [xE]: "#FFFFFF",
    [NE]: "#FFFFFF"
  }
};
function pge() {
  const n = new q(), e = ape();
  return e.onDidChange(() => n.fire()), {
    onDidChange: n.event,
    getCSS() {
      const t = {}, i = (o) => {
        let s = o.defaults;
        for (; ma.isThemeIcon(s); ) {
          const l = e.getIcon(s.id);
          if (!l)
            return;
          s = l.defaults;
        }
        const a = s.fontId;
        if (a) {
          const l = e.getIconFont(a);
          if (l)
            return t[a] = l, `.codicon-${o.id}:before { content: '${s.fontCharacter}'; font-family: ${sk(a)}; }`;
        }
        return `.codicon-${o.id}:before { content: '${s.fontCharacter}'; }`;
      }, r = [];
      for (let o of e.getIcons()) {
        const s = i(o);
        s && r.push(s);
      }
      for (let o in t) {
        const a = t[o].definition.src.map((l) => `${qv(l.location)} format('${l.format}')`).join(", ");
        r.push(`@font-face { src: ${a}; font-family: ${sk(o)}; }`);
      }
      return r.join(`
`);
    }
  };
}
const dd = "vs", lS = "vs-dark", Wp = "hc-black", gge = Jn.as(H3.ColorContribution), mge = Jn.as(_3.ThemingContribution);
class V7 {
  constructor(e, t) {
    this.semanticHighlighting = !1, this.themeData = t;
    let i = t.base;
    e.length > 0 ? (yw(e) ? this.id = e : this.id = i + " " + e, this.themeName = e) : (this.id = i, this.themeName = i), this.colors = null, this.defaultColors = /* @__PURE__ */ Object.create(null), this._tokenTheme = null;
  }
  get base() {
    return this.themeData.base;
  }
  notifyBaseUpdated() {
    this.themeData.inherit && (this.colors = null, this._tokenTheme = null);
  }
  getColors() {
    if (!this.colors) {
      const e = /* @__PURE__ */ new Map();
      for (let t in this.themeData.colors)
        e.set(t, ne.fromHex(this.themeData.colors[t]));
      if (this.themeData.inherit) {
        let t = mO(this.themeData.base);
        for (let i in t.colors)
          e.has(i) || e.set(i, ne.fromHex(t.colors[i]));
      }
      this.colors = e;
    }
    return this.colors;
  }
  getColor(e, t) {
    const i = this.getColors().get(e);
    if (i)
      return i;
    if (t !== !1)
      return this.getDefault(e);
  }
  getDefault(e) {
    let t = this.defaultColors[e];
    return t || (t = gge.resolveDefaultColor(e, this), this.defaultColors[e] = t, t);
  }
  defines(e) {
    return Object.prototype.hasOwnProperty.call(this.getColors(), e);
  }
  get type() {
    switch (this.base) {
      case dd:
        return jl.LIGHT;
      case Wp:
        return jl.HIGH_CONTRAST;
      default:
        return jl.DARK;
    }
  }
  get tokenTheme() {
    if (!this._tokenTheme) {
      let e = [], t = [];
      if (this.themeData.inherit) {
        let i = mO(this.themeData.base);
        e = i.rules, i.encodedTokensColors && (t = i.encodedTokensColors);
      }
      e = e.concat(this.themeData.rules), this.themeData.encodedTokensColors && (t = this.themeData.encodedTokensColors), this._tokenTheme = W7.createFromRawTokenTheme(e, t);
    }
    return this._tokenTheme;
  }
  getTokenStyleMetadata(e, t, i) {
    const o = this.tokenTheme._match([e].concat(t).join(".")).metadata, s = la.getForeground(o), a = la.getFontStyle(o);
    return {
      foreground: s,
      italic: !!(a & 1),
      bold: !!(a & 2),
      underline: !!(a & 4)
    };
  }
}
function yw(n) {
  return n === dd || n === lS || n === Wp;
}
function mO(n) {
  switch (n) {
    case dd:
      return hge;
    case lS:
      return dge;
    case Wp:
      return fge;
  }
}
function l1(n) {
  let e = mO(n);
  return new V7(n, e);
}
class vge extends Ce {
  constructor() {
    super(), this._onColorThemeChange = this._register(new q()), this.onDidColorThemeChange = this._onColorThemeChange.event, this._environment = /* @__PURE__ */ Object.create(null), this._autoDetectHighContrast = !0, this._knownThemes = /* @__PURE__ */ new Map(), this._knownThemes.set(dd, l1(dd)), this._knownThemes.set(lS, l1(lS)), this._knownThemes.set(Wp, l1(Wp));
    const e = pge();
    this._codiconCSS = e.getCSS(), this._themeCSS = "", this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._globalStyleElement = null, this._styleElements = [], this._colorMapOverride = null, this.setTheme(dd), e.onDidChange(() => {
      this._codiconCSS = e.getCSS(), this._updateCSS();
    }), Jre("(forced-colors: active)", () => {
      this._updateActualTheme();
    });
  }
  registerEditorContainer(e) {
    return FN(e) ? this._registerShadowDomContainer(e) : this._registerRegularEditorContainer();
  }
  _registerRegularEditorContainer() {
    return this._globalStyleElement || (this._globalStyleElement = As(), this._globalStyleElement.className = "monaco-colors", this._globalStyleElement.textContent = this._allCSS, this._styleElements.push(this._globalStyleElement)), Ce.None;
  }
  _registerShadowDomContainer(e) {
    const t = As(e);
    return t.className = "monaco-colors", t.textContent = this._allCSS, this._styleElements.push(t), {
      dispose: () => {
        for (let i = 0; i < this._styleElements.length; i++)
          if (this._styleElements[i] === t) {
            this._styleElements.splice(i, 1);
            return;
          }
      }
    };
  }
  defineTheme(e, t) {
    if (!/^[a-z0-9\-]+$/i.test(e))
      throw new Error("Illegal theme name!");
    if (!yw(t.base) && !yw(e))
      throw new Error("Illegal theme base!");
    this._knownThemes.set(e, new V7(e, t)), yw(e) && this._knownThemes.forEach((i) => {
      i.base === e && i.notifyBaseUpdated();
    }), this._theme.themeName === e && this.setTheme(e);
  }
  getColorTheme() {
    return this._theme;
  }
  setColorMapOverride(e) {
    this._colorMapOverride = e, this._updateThemeOrColorMap();
  }
  setTheme(e) {
    let t;
    this._knownThemes.has(e) ? t = this._knownThemes.get(e) : t = this._knownThemes.get(dd), this._desiredTheme = t, this._updateActualTheme();
  }
  _updateActualTheme() {
    const e = this._autoDetectHighContrast && window.matchMedia("(forced-colors: active)").matches ? this._knownThemes.get(Wp) : this._desiredTheme;
    this._theme !== e && (this._theme = e, this._updateThemeOrColorMap());
  }
  setAutoDetectHighContrast(e) {
    this._autoDetectHighContrast = e, this._updateActualTheme();
  }
  _updateThemeOrColorMap() {
    let e = [], t = {}, i = {
      addRule: (o) => {
        t[o] || (e.push(o), t[o] = !0);
      }
    };
    mge.getThemingParticipants().forEach((o) => o(this._theme, i, this._environment));
    const r = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
    i.addRule(cge(r)), this._themeCSS = e.join(`
`), this._updateCSS(), cn.setColorMap(r), this._onColorThemeChange.fire(this._theme);
  }
  _updateCSS() {
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._styleElements.forEach((e) => e.textContent = this._allCSS);
  }
  getFileIconTheme() {
    return {
      hasFileIcons: !1,
      hasFolderIcons: !1,
      hidesExplorerArrows: !1
    };
  }
}
var _ge = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Cge = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
const Ov = "data-keybinding-context";
class UI {
  constructor(e, t) {
    this._id = e, this._parent = t, this._value = /* @__PURE__ */ Object.create(null), this._value._contextId = e;
  }
  setValue(e, t) {
    return this._value[e] !== t ? (this._value[e] = t, !0) : !1;
  }
  removeValue(e) {
    return e in this._value ? (delete this._value[e], !0) : !1;
  }
  getValue(e) {
    const t = this._value[e];
    return typeof t > "u" && this._parent ? this._parent.getValue(e) : t;
  }
}
class cg extends UI {
  constructor() {
    super(-1, null);
  }
  setValue(e, t) {
    return !1;
  }
  removeValue(e) {
    return !1;
  }
  getValue(e) {
  }
}
cg.INSTANCE = new cg();
class g_ extends UI {
  constructor(e, t, i) {
    super(e, null), this._configurationService = t, this._values = fv.forConfigKeys(), this._listener = this._configurationService.onDidChangeConfiguration((r) => {
      if (r.source === 6) {
        const o = Array.from(Ct.map(this._values, ([s]) => s));
        this._values.clear(), i.fire(new NW(o));
      } else {
        const o = [];
        for (const s of r.affectedKeys) {
          const a = `config.${s}`, l = this._values.findSuperstr(a);
          l !== void 0 && (o.push(...Ct.map(l, ([u]) => u)), this._values.deleteSuperstr(a)), this._values.has(a) && (o.push(a), this._values.delete(a));
        }
        i.fire(new NW(o));
      }
    });
  }
  dispose() {
    this._listener.dispose();
  }
  getValue(e) {
    if (e.indexOf(g_._keyPrefix) !== 0)
      return super.getValue(e);
    if (this._values.has(e))
      return this._values.get(e);
    const t = e.substr(g_._keyPrefix.length), i = this._configurationService.getValue(t);
    let r;
    switch (typeof i) {
      case "number":
      case "boolean":
      case "string":
        r = i;
        break;
      default:
        Array.isArray(i) ? r = JSON.stringify(i) : r = i;
    }
    return this._values.set(e, r), r;
  }
  setValue(e, t) {
    return super.setValue(e, t);
  }
  removeValue(e) {
    return super.removeValue(e);
  }
}
g_._keyPrefix = "config.";
class yge {
  constructor(e, t, i) {
    this._service = e, this._key = t, this._defaultValue = i, this.reset();
  }
  set(e) {
    this._service.setContext(this._key, e);
  }
  reset() {
    typeof this._defaultValue > "u" ? this._service.removeContext(this._key) : this._service.setContext(this._key, this._defaultValue);
  }
  get() {
    return this._service.getContextKeyValue(this._key);
  }
}
class xW {
  constructor(e) {
    this.key = e;
  }
  affectsSome(e) {
    return e.has(this.key);
  }
}
class NW {
  constructor(e) {
    this.keys = e;
  }
  affectsSome(e) {
    for (const t of this.keys)
      if (e.has(t))
        return !0;
    return !1;
  }
}
class wge {
  constructor(e) {
    this.events = e;
  }
  affectsSome(e) {
    for (const t of this.events)
      if (t.affectsSome(e))
        return !0;
    return !1;
  }
}
class B7 {
  constructor(e) {
    this._onDidChangeContext = new vR({ merge: (t) => new wge(t) }), this.onDidChangeContext = this._onDidChangeContext.event, this._isDisposed = !1, this._myContextId = e;
  }
  createKey(e, t) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new yge(this, e, t);
  }
  bufferChangeEvents(e) {
    this._onDidChangeContext.pause();
    try {
      e();
    } finally {
      this._onDidChangeContext.resume();
    }
  }
  createScoped(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new bge(this, e);
  }
  contextMatchesRules(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    const t = this.getContextValuesContainer(this._myContextId);
    return Tp.contextMatchesRules(t, e);
  }
  getContextKeyValue(e) {
    if (!this._isDisposed)
      return this.getContextValuesContainer(this._myContextId).getValue(e);
  }
  setContext(e, t) {
    if (this._isDisposed)
      return;
    const i = this.getContextValuesContainer(this._myContextId);
    i && i.setValue(e, t) && this._onDidChangeContext.fire(new xW(e));
  }
  removeContext(e) {
    this._isDisposed || this.getContextValuesContainer(this._myContextId).removeValue(e) && this._onDidChangeContext.fire(new xW(e));
  }
  getContext(e) {
    return this._isDisposed ? cg.INSTANCE : this.getContextValuesContainer(Sge(e));
  }
}
let vO = class extends B7 {
  constructor(e) {
    super(0), this._contexts = /* @__PURE__ */ new Map(), this._toDispose = new dt(), this._lastContextId = 0;
    const t = new g_(this._myContextId, e, this._onDidChangeContext);
    this._contexts.set(this._myContextId, t), this._toDispose.add(t);
  }
  dispose() {
    this._onDidChangeContext.dispose(), this._isDisposed = !0, this._toDispose.dispose();
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? cg.INSTANCE : this._contexts.get(e) || cg.INSTANCE;
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ContextKeyService has been disposed");
    let t = ++this._lastContextId;
    return this._contexts.set(t, new UI(t, this.getContextValuesContainer(e))), t;
  }
  disposeContext(e) {
    this._isDisposed || this._contexts.delete(e);
  }
};
vO = _ge([
  Cge(0, _r)
], vO);
class bge extends B7 {
  constructor(e, t) {
    if (super(e.createChildContext()), this._parentChangeListener = new Xne(), this._parent = e, this._updateParentChangeListener(), this._domNode = t, this._domNode.hasAttribute(Ov)) {
      let i = "";
      this._domNode.classList && (i = Array.from(this._domNode.classList.values()).join(", ")), console.error(`Element already has context attribute${i ? ": " + i : ""}`);
    }
    this._domNode.setAttribute(Ov, String(this._myContextId));
  }
  _updateParentChangeListener() {
    this._parentChangeListener.value = this._parent.onDidChangeContext(this._onDidChangeContext.fire, this._onDidChangeContext);
  }
  dispose() {
    this._isDisposed || (this._onDidChangeContext.dispose(), this._parent.disposeContext(this._myContextId), this._parentChangeListener.dispose(), this._domNode.removeAttribute(Ov), this._isDisposed = !0);
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? cg.INSTANCE : this._parent.getContextValuesContainer(e);
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ScopedContextKeyService has been disposed");
    return this._parent.createChildContext(e);
  }
  disposeContext(e) {
    this._isDisposed || this._parent.disposeContext(e);
  }
}
function Sge(n) {
  for (; n; ) {
    if (n.hasAttribute(Ov)) {
      const e = n.getAttribute(Ov);
      return e ? parseInt(e, 10) : NaN;
    }
    n = n.parentElement;
  }
  return 0;
}
Qn.registerCommand(Ale, function(n, e, t) {
  n.get(xi).createKey(String(e), t);
});
Qn.registerCommand({
  id: "getContextKeyInfo",
  handler() {
    return [...nt.all()].sort((n, e) => n.key.localeCompare(e.key));
  },
  description: {
    description: b("getContextKeyInfo", "A command that returns information about context keys"),
    args: []
  }
});
Qn.registerCommand("_generateContextKeyInfo", function() {
  const n = [], e = /* @__PURE__ */ new Set();
  for (let t of nt.all())
    e.has(t.key) || (e.add(t.key), n.push(t));
  n.sort((t, i) => t.key.localeCompare(i.key)), console.log(JSON.stringify(n, void 0, 2));
});
var cr;
(function(n) {
  function e(o, s) {
    if (o.start >= s.end || s.start >= o.end)
      return { start: 0, end: 0 };
    const a = Math.max(o.start, s.start), l = Math.min(o.end, s.end);
    return l - a <= 0 ? { start: 0, end: 0 } : { start: a, end: l };
  }
  n.intersect = e;
  function t(o) {
    return o.end - o.start <= 0;
  }
  n.isEmpty = t;
  function i(o, s) {
    return !t(e(o, s));
  }
  n.intersects = i;
  function r(o, s) {
    const a = [], l = { start: o.start, end: Math.min(s.start, o.end) }, u = { start: Math.max(s.end, o.start), end: o.end };
    return t(l) || a.push(l), t(u) || a.push(u), a;
  }
  n.relativeComplement = r;
})(cr || (cr = {}));
var qc;
(function(n) {
  n[n.AVOID = 0] = "AVOID", n[n.ALIGN = 1] = "ALIGN";
})(qc || (qc = {}));
function cp(n, e, t) {
  const i = t.mode === qc.ALIGN ? t.offset : t.offset + t.size, r = t.mode === qc.ALIGN ? t.offset + t.size : t.offset;
  return t.position === 0 ? e <= n - i ? i : e <= r ? r - e : Math.max(n - e, 0) : e <= r ? r - e : e <= n - i ? i : 0;
}
class hg extends Ce {
  constructor(e, t) {
    super(), this.container = null, this.delegate = null, this.toDisposeOnClean = Ce.None, this.toDisposeOnSetContainer = Ce.None, this.shadowRoot = null, this.shadowRootHostElement = null, this.view = Xe(".context-view"), this.useFixedPosition = !1, this.useShadowDOM = !1, nk(this.view), this.setContainer(e, t), this._register(Oi(() => this.setContainer(
      null,
      1
      /* ABSOLUTE */
    )));
  }
  setContainer(e, t) {
    var i;
    if (this.container && (this.toDisposeOnSetContainer.dispose(), this.shadowRoot ? (this.shadowRoot.removeChild(this.view), this.shadowRoot = null, (i = this.shadowRootHostElement) === null || i === void 0 || i.remove(), this.shadowRootHostElement = null) : this.container.removeChild(this.view), this.container = null), e) {
      if (this.container = e, this.useFixedPosition = t !== 1, this.useShadowDOM = t === 3, this.useShadowDOM) {
        this.shadowRootHostElement = Xe(".shadow-root-host"), this.container.appendChild(this.shadowRootHostElement), this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: "open" });
        const o = document.createElement("style");
        o.textContent = Ege, this.shadowRoot.appendChild(o), this.shadowRoot.appendChild(this.view), this.shadowRoot.appendChild(Xe("slot"));
      } else
        this.container.appendChild(this.view);
      const r = new dt();
      hg.BUBBLE_UP_EVENTS.forEach((o) => {
        r.add(io(this.container, o, (s) => {
          this.onDOMEvent(s, !1);
        }));
      }), hg.BUBBLE_DOWN_EVENTS.forEach((o) => {
        r.add(io(this.container, o, (s) => {
          this.onDOMEvent(s, !0);
        }, !0));
      }), this.toDisposeOnSetContainer = r;
    }
  }
  show(e) {
    this.isVisible() && this.hide(), Ps(this.view), this.view.className = "context-view", this.view.style.top = "0px", this.view.style.left = "0px", this.view.style.zIndex = "2500", this.view.style.position = this.useFixedPosition ? "fixed" : "absolute", d5(this.view), this.toDisposeOnClean = e.render(this.view) || Ce.None, this.delegate = e, this.doLayout(), this.delegate.focus && this.delegate.focus();
  }
  getViewElement() {
    return this.view;
  }
  layout() {
    if (this.isVisible()) {
      if (this.delegate.canRelayout === !1 && !(Tg && tE.pointerEvents)) {
        this.hide();
        return;
      }
      this.delegate.layout && this.delegate.layout(), this.doLayout();
    }
  }
  doLayout() {
    if (!this.isVisible())
      return;
    let e = this.delegate.getAnchor(), t;
    if (c5(e)) {
      let h = qa(e);
      t = {
        top: h.top,
        left: h.left,
        width: h.width,
        height: h.height
      };
    } else
      t = {
        top: e.y,
        left: e.x,
        width: e.width || 1,
        height: e.height || 2
      };
    const i = pT(this.view), r = gT(this.view), o = this.delegate.anchorPosition || 0, s = this.delegate.anchorAlignment || 0, a = this.delegate.anchorAxisAlignment || 0;
    let l, u;
    if (a === 0) {
      const h = {
        offset: t.top - window.pageYOffset,
        size: t.height,
        position: o === 0 ? 0 : 1
        /* After */
      }, d = { offset: t.left, size: t.width, position: s === 0 ? 0 : 1, mode: qc.ALIGN };
      l = cp(window.innerHeight, r, h) + window.pageYOffset, cr.intersects({ start: l, end: l + r }, { start: h.offset, end: h.offset + h.size }) && (d.mode = qc.AVOID), u = cp(window.innerWidth, i, d);
    } else {
      const h = {
        offset: t.left,
        size: t.width,
        position: s === 0 ? 0 : 1
        /* After */
      }, d = { offset: t.top, size: t.height, position: o === 0 ? 0 : 1, mode: qc.ALIGN };
      u = cp(window.innerWidth, i, h), cr.intersects({ start: u, end: u + i }, { start: h.offset, end: h.offset + h.size }) && (d.mode = qc.AVOID), l = cp(window.innerHeight, r, d) + window.pageYOffset;
    }
    this.view.classList.remove("top", "bottom", "left", "right"), this.view.classList.add(o === 0 ? "bottom" : "top"), this.view.classList.add(s === 0 ? "left" : "right"), this.view.classList.toggle("fixed", this.useFixedPosition);
    const c = qa(this.container);
    this.view.style.top = `${l - (this.useFixedPosition ? qa(this.view).top : c.top)}px`, this.view.style.left = `${u - (this.useFixedPosition ? qa(this.view).left : c.left)}px`, this.view.style.width = "initial";
  }
  hide(e) {
    const t = this.delegate;
    this.delegate = null, t != null && t.onHide && t.onHide(e), this.toDisposeOnClean.dispose(), nk(this.view);
  }
  isVisible() {
    return !!this.delegate;
  }
  onDOMEvent(e, t) {
    this.delegate && (this.delegate.onDOMEvent ? this.delegate.onDOMEvent(e, document.activeElement) : t && !Ju(e.target, this.container) && this.hide());
  }
  dispose() {
    this.hide(), super.dispose();
  }
}
hg.BUBBLE_UP_EVENTS = ["click", "keydown", "focus", "blur"];
hg.BUBBLE_DOWN_EVENTS = ["click"];
let Ege = (
  /* css */
  `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	@font-face {
		font-family: "codicon";
		src: url("./codicon.ttf?5d4d76ab2ce5108968ad644d591a16a6") format("truetype");
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`
);
function IW(n) {
  let e = n.definition;
  for (; e instanceof Hi; )
    e = e.definition;
  return `.codicon-${n.id}:before { content: '${e.fontCharacter}'; }`;
}
function H7(...n) {
  return function(e, t) {
    for (let i = 0, r = n.length; i < r; i++) {
      const o = n[i](e, t);
      if (o)
        return o;
    }
    return null;
  };
}
const zI = Lge.bind(void 0, !0);
function Lge(n, e, t) {
  if (!t || t.length < e.length)
    return null;
  let i;
  return n ? i = BN(t, e) : i = t.indexOf(e) === 0, i ? e.length > 0 ? [{ start: 0, end: e.length }] : [] : null;
}
function Dge(n, e) {
  const t = e.toLowerCase().indexOf(n.toLowerCase());
  return t === -1 ? null : [{ start: t, end: t + n.length }];
}
function Rge(n, e) {
  return _O(n.toLowerCase(), e.toLowerCase(), 0, 0);
}
function _O(n, e, t, i) {
  if (t === n.length)
    return [];
  if (i === e.length)
    return null;
  if (n[t] === e[i]) {
    let r = null;
    return (r = _O(n, e, t + 1, i + 1)) ? KI({ start: i, end: i + 1 }, r) : null;
  }
  return _O(n, e, t, i + 1);
}
function jI(n) {
  return 97 <= n && n <= 122;
}
function BE(n) {
  return 65 <= n && n <= 90;
}
function $I(n) {
  return 48 <= n && n <= 57;
}
function G7(n) {
  return n === 32 || n === 9 || n === 10 || n === 13;
}
const U7 = /* @__PURE__ */ new Set();
"`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?".split("").forEach((n) => U7.add(n.charCodeAt(0)));
function uS(n) {
  return G7(n) || U7.has(n);
}
function Tge(n, e) {
  return n === e || uS(n) && uS(e);
}
function z7(n) {
  return jI(n) || BE(n) || $I(n);
}
function KI(n, e) {
  return e.length === 0 ? e = [n] : n.end === e[0].start ? e[0].start = n.start : e.unshift(n), e;
}
function j7(n, e) {
  for (let t = e; t < n.length; t++) {
    const i = n.charCodeAt(t);
    if (BE(i) || $I(i) || t > 0 && !z7(n.charCodeAt(t - 1)))
      return t;
  }
  return n.length;
}
function CO(n, e, t, i) {
  if (t === n.length)
    return [];
  if (i === e.length)
    return null;
  if (n[t] !== e[i].toLowerCase())
    return null;
  {
    let r = null, o = i + 1;
    for (r = CO(n, e, t + 1, i + 1); !r && (o = j7(e, o)) < e.length; )
      r = CO(n, e, t + 1, o), o++;
    return r === null ? null : KI({ start: i, end: i + 1 }, r);
  }
}
function Oge(n) {
  let e = 0, t = 0, i = 0, r = 0, o = 0;
  for (let c = 0; c < n.length; c++)
    o = n.charCodeAt(c), BE(o) && e++, jI(o) && t++, z7(o) && i++, $I(o) && r++;
  const s = e / n.length, a = t / n.length, l = i / n.length, u = r / n.length;
  return { upperPercent: s, lowerPercent: a, alphaPercent: l, numericPercent: u };
}
function xge(n) {
  const { upperPercent: e, lowerPercent: t } = n;
  return t === 0 && e > 0.6;
}
function Nge(n) {
  const { upperPercent: e, lowerPercent: t, alphaPercent: i, numericPercent: r } = n;
  return t > 0.2 && e < 0.8 && i > 0.6 && r < 0.2;
}
function Ige(n) {
  let e = 0, t = 0, i = 0, r = 0;
  for (let o = 0; o < n.length; o++)
    i = n.charCodeAt(o), BE(i) && e++, jI(i) && t++, G7(i) && r++;
  return (e === 0 || t === 0) && r === 0 ? n.length <= 30 : e <= 5;
}
function $7(n, e) {
  if (!e || (e = e.trim(), e.length === 0) || !Ige(n) || e.length > 60)
    return null;
  const t = Oge(e);
  if (!Nge(t)) {
    if (!xge(t))
      return null;
    e = e.toLowerCase();
  }
  let i = null, r = 0;
  for (n = n.toLowerCase(); r < e.length && (i = CO(n, e, 0, r)) === null; )
    r = j7(e, r + 1);
  return i;
}
function jwe(n, e, t = !1) {
  if (!e || e.length === 0)
    return null;
  let i = null, r = 0;
  for (n = n.toLowerCase(), e = e.toLowerCase(); r < e.length && (i = yO(n, e, 0, r, t)) === null; )
    r = K7(e, r + 1);
  return i;
}
function yO(n, e, t, i, r) {
  if (t === n.length)
    return [];
  if (i === e.length)
    return null;
  if (Tge(n.charCodeAt(t), e.charCodeAt(i))) {
    let o = null, s = i + 1;
    if (o = yO(n, e, t + 1, i + 1, r), !r)
      for (; !o && (s = K7(e, s)) < e.length; )
        o = yO(n, e, t + 1, s, r), s++;
    return o === null ? null : KI({ start: i, end: i + 1 }, o);
  } else
    return null;
}
function K7(n, e) {
  for (let t = e; t < n.length; t++)
    if (uS(n.charCodeAt(t)) || t > 0 && uS(n.charCodeAt(t - 1)))
      return t;
  return n.length;
}
const Pge = H7(zI, $7, Dge), Age = H7(zI, $7, Rge), PW = new zN(1e4);
function AW(n, e, t = !1) {
  if (typeof n != "string" || typeof e != "string")
    return null;
  let i = PW.get(n);
  i || (i = new RegExp(ioe(n), "i"), PW.set(n, i));
  const r = i.exec(e);
  return r ? [{ start: r.index, end: r.index + r[0].length }] : t ? Age(n, e) : Pge(n, e);
}
function $we(n, e, t, i, r, o) {
  const s = Math.min(13, n.length);
  for (; t < s; t++) {
    const a = cS(n, e, t, i, r, o, !1);
    if (a)
      return a;
  }
  return [0, o];
}
function Kwe(n) {
  if (typeof n > "u")
    return [];
  const e = [], t = n[1];
  for (let i = n.length - 1; i > 1; i--) {
    const r = n[i] + t, o = e[e.length - 1];
    o && o.end === r ? o.end = r + 1 : e.push({ start: r, end: r + 1 });
  }
  return e;
}
const Yc = 128;
function qI() {
  const n = [], e = [];
  for (let t = 0; t <= Yc; t++)
    e[t] = 0;
  for (let t = 0; t <= Yc; t++)
    n.push(e.slice(0));
  return n;
}
function q7(n) {
  const e = [];
  for (let t = 0; t <= n; t++)
    e[t] = 0;
  return e;
}
const Y7 = q7(2 * Yc), wO = q7(2 * Yc), Du = qI(), zh = qI(), My = qI();
function Fy(n, e) {
  if (e < 0 || e >= n.length)
    return !1;
  const t = n.codePointAt(e);
  switch (t) {
    case 95:
    case 45:
    case 46:
    case 32:
    case 47:
    case 92:
    case 39:
    case 34:
    case 58:
    case 36:
    case 60:
    case 40:
    case 91:
      return !0;
    case void 0:
      return !1;
    default:
      return !!hv(t);
  }
}
function MW(n, e) {
  if (e < 0 || e >= n.length)
    return !1;
  switch (n.charCodeAt(e)) {
    case 32:
    case 9:
      return !0;
    default:
      return !1;
  }
}
function ww(n, e, t) {
  return e[n] !== t[n];
}
function Mge(n, e, t, i, r, o, s = !1) {
  for (; e < t && r < o; )
    n[e] === i[r] && (s && (Y7[e] = r), e += 1), r += 1;
  return e === t;
}
var Td;
(function(n) {
  n.Default = [-100, 0];
  function e(t) {
    return !t || t.length === 2 && t[0] === -100 && t[1] === 0;
  }
  n.isDefault = e;
})(Td || (Td = {}));
function cS(n, e, t, i, r, o, s) {
  const a = n.length > Yc ? Yc : n.length, l = i.length > Yc ? Yc : i.length;
  if (t >= a || o >= l || a - t > l - o || !Mge(e, t, a, r, o, l, !0))
    return;
  Fge(a, l, t, o, e, r);
  let u = 1, c = 1, h = t, d = o;
  const f = [!1];
  for (u = 1, h = t; h < a; u++, h++) {
    const v = Y7[h], C = wO[h], y = h + 1 < a ? wO[h + 1] : l;
    for (c = v - o + 1, d = v; d < y; c++, d++) {
      let w = Number.MIN_SAFE_INTEGER, L = !1;
      d <= C && (w = kge(n, e, h, t, i, r, d, l, o, Du[u - 1][c - 1] === 0, f));
      let S = 0;
      w !== Number.MAX_SAFE_INTEGER && (L = !0, S = w + zh[u - 1][c - 1]);
      const E = d > v, D = E ? zh[u][c - 1] + (Du[u][c - 1] > 0 ? -5 : 0) : 0, x = d > v + 1 && Du[u][c - 1] > 0, R = x ? zh[u][c - 2] + (Du[u][c - 2] > 0 ? -5 : 0) : 0;
      if (x && (!E || R >= D) && (!L || R >= S))
        zh[u][c] = R, My[u][c] = 3, Du[u][c] = 0;
      else if (E && (!L || D >= S))
        zh[u][c] = D, My[u][c] = 2, Du[u][c] = 0;
      else if (L)
        zh[u][c] = S, My[u][c] = 1, Du[u][c] = Du[u - 1][c - 1] + 1;
      else
        throw new Error("not possible");
    }
  }
  if (!f[0] && !s)
    return;
  u--, c--;
  const p = [zh[u][c], o];
  let g = 0, _ = 0;
  for (; u >= 1; ) {
    let v = c;
    do {
      const C = My[u][v];
      if (C === 3)
        v = v - 2;
      else if (C === 2)
        v = v - 1;
      else
        break;
    } while (v >= 1);
    g > 1 && e[t + u - 1] === r[o + c - 1] && !ww(v + o - 1, i, r) && g + 1 > Du[u][v] && (v = c), v === c ? g++ : g = 1, _ || (_ = v), u--, c = v - 1, p.push(c);
  }
  l === a && (p[0] += 2);
  const m = _ - a;
  return p[0] -= m, p;
}
function Fge(n, e, t, i, r, o) {
  let s = n - 1, a = e - 1;
  for (; s >= t && a >= i; )
    r[s] === o[a] && (wO[s] = a, s--), a--;
}
function kge(n, e, t, i, r, o, s, a, l, u, c) {
  if (e[t] !== o[s])
    return Number.MIN_SAFE_INTEGER;
  let h = 1, d = !1;
  return s === t - i ? h = n[t] === r[s] ? 7 : 5 : ww(s, r, o) && (s === 0 || !ww(s - 1, r, o)) ? (h = n[t] === r[s] ? 7 : 5, d = !0) : Fy(o, s) && (s === 0 || !Fy(o, s - 1)) ? h = 5 : (Fy(o, s - 1) || MW(o, s - 1)) && (h = 5, d = !0), h > 1 && t === i && (c[0] = !0), d || (d = ww(s, r, o) || Fy(o, s - 1) || MW(o, s - 1)), t === i ? s > l && (h -= d ? 3 : 5) : u ? h += d ? 2 : 0 : h += d ? 0 : 1, s + 1 === a && (h -= d ? 3 : 5), h;
}
function qwe(n, e, t, i, r, o, s) {
  return Wge(n, e, t, i, r, o, !0, s);
}
function Wge(n, e, t, i, r, o, s, a) {
  let l = cS(n, e, t, i, r, o, a);
  if (l && !s)
    return l;
  if (n.length >= 3) {
    const u = Math.min(7, n.length - 1);
    for (let c = t + 1; c < u; c++) {
      const h = Vge(n, c);
      if (h) {
        const d = cS(h, h.toLowerCase(), t, i, r, o, a);
        d && (d[0] -= 3, (!l || d[0] > l[0]) && (l = d));
      }
    }
  }
  return l;
}
function Vge(n, e) {
  if (e + 1 >= n.length)
    return;
  const t = n[e], i = n[e + 1];
  if (t !== i)
    return n.slice(0, e) + i + t + n.slice(e + 2);
}
const xv = "$(", YI = new RegExp(`\\$\\(${Go.iconNameExpression}(?:${Go.iconModifierExpression})?\\)`, "g"), Bge = new RegExp(`(\\\\)?${YI.source}`, "g");
function Ywe(n) {
  return n.replace(Bge, (e, t) => t ? e : `\\${e}`);
}
const Hge = new RegExp(`\\\\${YI.source}`, "g");
function Xwe(n) {
  return n.replace(Hge, (e) => `\\${e}`);
}
const Gge = new RegExp(`(\\s)?(\\\\)?${YI.source}(\\s)?`, "g");
function Uge(n) {
  return n.indexOf(xv) === -1 ? n : n.replace(Gge, (e, t, i, r) => i ? e : t || r || "");
}
function ky(n) {
  const e = n.indexOf(xv);
  return e === -1 ? { text: n } : zge(n, e);
}
function zge(n, e) {
  const t = [];
  let i = "";
  function r(d) {
    if (d) {
      i += d;
      for (const f of d)
        t.push(a);
    }
  }
  let o = -1, s = "", a = 0, l, u, c = e;
  const h = n.length;
  for (r(n.substr(0, e)); c < h; ) {
    if (l = n[c], u = n[c + 1], l === xv[0] && u === xv[1])
      o = c, r(s), s = xv, c++;
    else if (l === ")" && o !== -1) {
      const d = c - o + 1;
      a += d, o = -1, s = "";
    } else
      o !== -1 ? /^[a-z0-9\-]$/i.test(l) ? s += l : (r(s), o = -1, s = "") : r(l);
    c++;
  }
  return r(s), { text: i, iconOffsets: t };
}
function Wy(n, e, t = !1) {
  const { text: i, iconOffsets: r } = e;
  if (!r || r.length === 0)
    return AW(n, i, t);
  const o = kN(i, " "), s = i.length - o.length, a = AW(n, o, t);
  if (a)
    for (const l of a) {
      const u = r[l.start + s] + s;
      l.start += u, l.end += u;
    }
  return a;
}
const bO = /\(&([^\s&])\)|(^|[^&])&([^\s&])/, u1 = /(&amp;)?(&amp;)([^\s&])/g, X7 = ya("menu-selection", Hi.check), Z7 = ya("menu-submenu", Hi.chevronRight);
var hS;
(function(n) {
  n[n.Right = 0] = "Right", n[n.Left = 1] = "Left";
})(hS || (hS = {}));
let Q7 = class nv extends lg {
  constructor(e, t, i = {}) {
    e.classList.add("monaco-menu-container"), e.setAttribute("role", "presentation");
    const r = document.createElement("div");
    r.classList.add("monaco-menu"), r.setAttribute("role", "presentation"), super(r, {
      orientation: 1,
      actionViewItemProvider: (a) => this.doGetActionViewItem(a, i, o),
      context: i.context,
      actionRunner: i.actionRunner,
      ariaLabel: i.ariaLabel,
      focusOnlyEnabledItems: !0,
      triggerKeys: { keys: [3, ...kt || Is ? [
        10
        /* Space */
      ] : []], keyDown: !0 }
    }), this.menuElement = r, this.actionsList.setAttribute("role", "menu"), this.actionsList.tabIndex = 0, this.menuDisposables = this._register(new dt()), this.initializeStyleSheet(e), be(r, Ge.KEY_DOWN, (a) => {
      new Yi(a).equals(
        2
        /* Tab */
      ) && a.preventDefault();
    }), i.enableMnemonics && this.menuDisposables.add(be(r, Ge.KEY_DOWN, (a) => {
      const l = a.key.toLocaleLowerCase();
      if (this.mnemonics.has(l)) {
        gi.stop(a, !0);
        const u = this.mnemonics.get(l);
        if (u.length === 1 && (u[0] instanceof FW && u[0].container && this.focusItemByElement(u[0].container), u[0].onClick(a)), u.length > 1) {
          const c = u.shift();
          c && c.container && (this.focusItemByElement(c.container), u.push(c)), this.mnemonics.set(l, u);
        }
      }
    })), Is && this._register(be(r, Ge.KEY_DOWN, (a) => {
      const l = new Yi(a);
      l.equals(
        14
        /* Home */
      ) || l.equals(
        11
        /* PageUp */
      ) ? (this.focusedItem = this.viewItems.length - 1, this.focusNext(), gi.stop(a, !0)) : (l.equals(
        13
        /* End */
      ) || l.equals(
        12
        /* PageDown */
      )) && (this.focusedItem = 0, this.focusPrevious(), gi.stop(a, !0));
    })), this._register(be(this.domNode, Ge.MOUSE_OUT, (a) => {
      let l = a.relatedTarget;
      Ju(l, this.domNode) || (this.focusedItem = void 0, this.updateFocus(), a.stopPropagation());
    })), this._register(be(this.actionsList, Ge.MOUSE_OVER, (a) => {
      let l = a.target;
      if (!(!l || !Ju(l, this.actionsList) || l === this.actionsList)) {
        for (; l.parentElement !== this.actionsList && l.parentElement !== null; )
          l = l.parentElement;
        if (l.classList.contains("action-item")) {
          const u = this.focusedItem;
          this.setFocusedItem(l), u !== this.focusedItem && this.updateFocus();
        }
      }
    }));
    let o = {
      parent: this
    };
    this.mnemonics = /* @__PURE__ */ new Map(), this.scrollableElement = this._register(new u7(r, {
      alwaysConsumeMouseWheel: !0,
      horizontal: 2,
      vertical: 3,
      verticalScrollbarSize: 7,
      handleMouseWheel: !0,
      useShadows: !0
    }));
    const s = this.scrollableElement.getDomNode();
    s.style.position = "", this._register(be(s, Ge.MOUSE_UP, (a) => {
      a.preventDefault();
    })), r.style.maxHeight = `${Math.max(10, window.innerHeight - e.getBoundingClientRect().top - 35)}px`, t = t.filter((a) => {
      var l;
      return !((l = i.submenuIds) === null || l === void 0) && l.has(a.id) ? (console.warn(`Found submenu cycle: ${a.id}`), !1) : !0;
    }), this.push(t, { icon: !0, label: !0, isMenu: !0 }), e.appendChild(this.scrollableElement.getDomNode()), this.scrollableElement.scanDomNode(), this.viewItems.filter((a) => !(a instanceof c1)).forEach((a, l, u) => {
      a.updatePositionInSet(l + 1, u.length);
    });
  }
  initializeStyleSheet(e) {
    FN(e) ? (this.styleSheet = As(e), this.styleSheet.textContent = kW) : (nv.globalStyleSheet || (nv.globalStyleSheet = As(), nv.globalStyleSheet.textContent = kW), this.styleSheet = nv.globalStyleSheet);
  }
  style(e) {
    const t = this.getContainer(), i = e.foregroundColor ? `${e.foregroundColor}` : "", r = e.backgroundColor ? `${e.backgroundColor}` : "", o = e.borderColor ? `1px solid ${e.borderColor}` : "", s = e.shadowColor ? `0 2px 4px ${e.shadowColor}` : "";
    t.style.border = o, this.domNode.style.color = i, this.domNode.style.backgroundColor = r, t.style.boxShadow = s, this.viewItems && this.viewItems.forEach((a) => {
      (a instanceof SO || a instanceof c1) && a.style(e);
    });
  }
  getContainer() {
    return this.scrollableElement.getDomNode();
  }
  get onScroll() {
    return this.scrollableElement.onScroll;
  }
  focusItemByElement(e) {
    const t = this.focusedItem;
    this.setFocusedItem(e), t !== this.focusedItem && this.updateFocus();
  }
  setFocusedItem(e) {
    for (let t = 0; t < this.actionsList.children.length; t++) {
      let i = this.actionsList.children[t];
      if (e === i) {
        this.focusedItem = t;
        break;
      }
    }
  }
  updateFocus(e) {
    super.updateFocus(e, !0), typeof this.focusedItem < "u" && this.scrollableElement.setScrollPosition({
      scrollTop: Math.round(this.menuElement.scrollTop)
    });
  }
  doGetActionViewItem(e, t, i) {
    if (e instanceof lf)
      return new c1(t.context, e, { icon: !0 });
    if (e instanceof m3) {
      const r = new FW(e, e.actions, i, Object.assign(Object.assign({}, t), { submenuIds: /* @__PURE__ */ new Set([...t.submenuIds || [], e.id]) }));
      if (t.enableMnemonics) {
        const o = r.getMnemonic();
        if (o && r.isEnabled()) {
          let s = [];
          this.mnemonics.has(o) && (s = this.mnemonics.get(o)), s.push(r), this.mnemonics.set(o, s);
        }
      }
      return r;
    } else {
      const r = { enableMnemonics: t.enableMnemonics, useEventAsContext: t.useEventAsContext };
      if (t.getKeyBinding) {
        const s = t.getKeyBinding(e);
        if (s) {
          const a = s.getLabel();
          a && (r.keybinding = a);
        }
      }
      const o = new SO(t.context, e, r);
      if (t.enableMnemonics) {
        const s = o.getMnemonic();
        if (s && o.isEnabled()) {
          let a = [];
          this.mnemonics.has(s) && (a = this.mnemonics.get(s)), a.push(o), this.mnemonics.set(s, a);
        }
      }
      return o;
    }
  }
};
class SO extends Tv {
  constructor(e, t, i = {}) {
    if (i.isMenu = !0, super(t, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "", this.options.label && i.enableMnemonics) {
      let r = this.getAction().label;
      if (r) {
        let o = bO.exec(r);
        o && (this.mnemonic = (o[1] ? o[1] : o[3]).toLocaleLowerCase());
      }
    }
    this.runOnceToEnableMouseUp = new ro(() => {
      this.element && (this._register(be(this.element, Ge.MOUSE_UP, (r) => {
        if (gi.stop(r, !0), to) {
          if (new pa(r).rightButton)
            return;
          this.onClick(r);
        } else
          setTimeout(() => {
            this.onClick(r);
          }, 0);
      })), this._register(be(this.element, Ge.CONTEXT_MENU, (r) => {
        gi.stop(r, !0);
      })));
    }, 100), this._register(this.runOnceToEnableMouseUp);
  }
  render(e) {
    super.render(e), this.element && (this.container = e, this.item = Me(this.element, Xe("a.action-menu-item")), this._action.id === lf.ID ? this.item.setAttribute("role", "presentation") : (this.item.setAttribute("role", "menuitem"), this.mnemonic && this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`)), this.check = Me(this.item, Xe("span.menu-item-check" + X7.cssSelector)), this.check.setAttribute("role", "none"), this.label = Me(this.item, Xe("span.action-label")), this.options.label && this.options.keybinding && (Me(this.item, Xe("span.keybinding")).textContent = this.options.keybinding), this.runOnceToEnableMouseUp.schedule(), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked());
  }
  blur() {
    super.blur(), this.applyStyle();
  }
  focus() {
    super.focus(), this.item && this.item.focus(), this.applyStyle();
  }
  updatePositionInSet(e, t) {
    this.item && (this.item.setAttribute("aria-posinset", `${e}`), this.item.setAttribute("aria-setsize", `${t}`));
  }
  updateLabel() {
    if (this.label && this.options.label) {
      Ps(this.label);
      let e = Uge(this.getAction().label);
      if (e) {
        const t = jge(e);
        this.options.enableMnemonics || (e = t), this.label.setAttribute("aria-label", t.replace(/&&/g, "&"));
        const i = bO.exec(e);
        if (i) {
          e = p5(e), u1.lastIndex = 0;
          let r = u1.exec(e);
          for (; r && r[1]; )
            r = u1.exec(e);
          const o = (s) => s.replace(/&amp;&amp;/g, "&amp;");
          r ? this.label.append(kN(o(e.substr(0, r.index)), " "), Xe("u", { "aria-hidden": "true" }, r[3]), g5(o(e.substr(r.index + r[0].length)), " ")) : this.label.innerText = o(e).trim(), this.item && this.item.setAttribute("aria-keyshortcuts", (i[1] ? i[1] : i[3]).toLocaleLowerCase());
        } else
          this.label.innerText = e.replace(/&&/g, "&").trim();
      }
    }
  }
  updateTooltip() {
    let e = null;
    this.getAction().tooltip ? e = this.getAction().tooltip : !this.options.label && this.getAction().label && this.options.icon && (e = this.getAction().label, this.options.keybinding && (e = b({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", e, this.options.keybinding))), e && this.item && (this.item.title = e);
  }
  updateClass() {
    this.cssClass && this.item && this.item.classList.remove(...this.cssClass.split(" ")), this.options.icon && this.label ? (this.cssClass = this.getAction().class || "", this.label.classList.add("icon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" ")), this.updateEnabled()) : this.label && this.label.classList.remove("icon");
  }
  updateEnabled() {
    this.getAction().enabled ? (this.element && (this.element.classList.remove("disabled"), this.element.removeAttribute("aria-disabled")), this.item && (this.item.classList.remove("disabled"), this.item.removeAttribute("aria-disabled"), this.item.tabIndex = 0)) : (this.element && (this.element.classList.add("disabled"), this.element.setAttribute("aria-disabled", "true")), this.item && (this.item.classList.add("disabled"), this.item.setAttribute("aria-disabled", "true")));
  }
  updateChecked() {
    this.item && (this.getAction().checked ? (this.item.classList.add("checked"), this.item.setAttribute("role", "menuitemcheckbox"), this.item.setAttribute("aria-checked", "true")) : (this.item.classList.remove("checked"), this.item.setAttribute("role", "menuitem"), this.item.setAttribute("aria-checked", "false")));
  }
  getMnemonic() {
    return this.mnemonic;
  }
  applyStyle() {
    if (!this.menuStyle)
      return;
    const e = this.element && this.element.classList.contains("focused"), t = e && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor, i = e && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0, r = e && this.menuStyle.selectionBorderColor ? `thin solid ${this.menuStyle.selectionBorderColor}` : "";
    this.item && (this.item.style.color = t ? t.toString() : "", this.item.style.backgroundColor = i ? i.toString() : ""), this.check && (this.check.style.color = t ? t.toString() : ""), this.container && (this.container.style.border = r);
  }
  style(e) {
    this.menuStyle = e, this.applyStyle();
  }
}
class FW extends SO {
  constructor(e, t, i, r) {
    super(e, e, r), this.submenuActions = t, this.parentData = i, this.submenuOptions = r, this.mysubmenu = null, this.submenuDisposables = this._register(new dt()), this.mouseOver = !1, this.expandDirection = r && r.expandDirection !== void 0 ? r.expandDirection : hS.Right, this.showScheduler = new ro(() => {
      this.mouseOver && (this.cleanupExistingSubmenu(!1), this.createSubmenu(!1));
    }, 250), this.hideScheduler = new ro(() => {
      this.element && !Ju(Lp(), this.element) && this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    }, 750);
  }
  render(e) {
    super.render(e), this.element && (this.item && (this.item.classList.add("monaco-submenu-item"), this.item.tabIndex = 0, this.item.setAttribute("aria-haspopup", "true"), this.updateAriaExpanded("false"), this.submenuIndicator = Me(this.item, Xe("span.submenu-indicator" + Z7.cssSelector)), this.submenuIndicator.setAttribute("aria-hidden", "true")), this._register(be(this.element, Ge.KEY_UP, (t) => {
      let i = new Yi(t);
      (i.equals(
        17
        /* RightArrow */
      ) || i.equals(
        3
        /* Enter */
      )) && (gi.stop(t, !0), this.createSubmenu(!0));
    })), this._register(be(this.element, Ge.KEY_DOWN, (t) => {
      let i = new Yi(t);
      Lp() === this.item && (i.equals(
        17
        /* RightArrow */
      ) || i.equals(
        3
        /* Enter */
      )) && gi.stop(t, !0);
    })), this._register(be(this.element, Ge.MOUSE_OVER, (t) => {
      this.mouseOver || (this.mouseOver = !0, this.showScheduler.schedule());
    })), this._register(be(this.element, Ge.MOUSE_LEAVE, (t) => {
      this.mouseOver = !1;
    })), this._register(be(this.element, Ge.FOCUS_OUT, (t) => {
      this.element && !Ju(Lp(), this.element) && this.hideScheduler.schedule();
    })), this._register(this.parentData.parent.onScroll(() => {
      this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!1);
    })));
  }
  updateEnabled() {
  }
  onClick(e) {
    gi.stop(e, !0), this.cleanupExistingSubmenu(!1), this.createSubmenu(!0);
  }
  cleanupExistingSubmenu(e) {
    if (this.parentData.submenu && (e || this.parentData.submenu !== this.mysubmenu)) {
      try {
        this.parentData.submenu.dispose();
      } catch {
      }
      this.parentData.submenu = void 0, this.updateAriaExpanded("false"), this.submenuContainer && (this.submenuDisposables.clear(), this.submenuContainer = void 0);
    }
  }
  calculateSubmenuMenuLayout(e, t, i, r) {
    const o = { top: 0, left: 0 };
    return o.left = cp(e.width, t.width, { position: r === hS.Right ? 0 : 1, offset: i.left, size: i.width }), o.left >= i.left && o.left < i.left + i.width && (i.left + 10 + t.width <= e.width && (o.left = i.left + 10), i.top += 10, i.height = 0), o.top = cp(e.height, t.height, { position: 0, offset: i.top, size: 0 }), o.top + t.height === i.top && o.top + i.height + t.height <= e.height && (o.top += i.height), o;
  }
  createSubmenu(e = !0) {
    if (this.element)
      if (this.parentData.submenu)
        this.parentData.submenu.focus(!1);
      else {
        this.updateAriaExpanded("true"), this.submenuContainer = Me(this.element, Xe("div.monaco-submenu")), this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
        const t = getComputedStyle(this.parentData.parent.domNode), i = parseFloat(t.paddingTop || "0") || 0;
        this.submenuContainer.style.zIndex = "1", this.submenuContainer.style.position = "fixed", this.submenuContainer.style.top = "0", this.submenuContainer.style.left = "0", this.parentData.submenu = new Q7(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new vE()], this.submenuOptions), this.menuStyle && this.parentData.submenu.style(this.menuStyle);
        const r = this.element.getBoundingClientRect(), o = {
          top: r.top - i,
          left: r.left,
          height: r.height + 2 * i,
          width: r.width
        }, s = this.submenuContainer.getBoundingClientRect(), { top: a, left: l } = this.calculateSubmenuMenuLayout(new $a(window.innerWidth, window.innerHeight), $a.lift(s), o, this.expandDirection);
        this.submenuContainer.style.left = `${l}px`, this.submenuContainer.style.top = `${a}px`, this.submenuDisposables.add(be(this.submenuContainer, Ge.KEY_UP, (u) => {
          new Yi(u).equals(
            15
            /* LeftArrow */
          ) && (gi.stop(u, !0), this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0));
        })), this.submenuDisposables.add(be(this.submenuContainer, Ge.KEY_DOWN, (u) => {
          new Yi(u).equals(
            15
            /* LeftArrow */
          ) && gi.stop(u, !0);
        })), this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
          this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0);
        })), this.parentData.submenu.focus(e), this.mysubmenu = this.parentData.submenu;
      }
  }
  updateAriaExpanded(e) {
    var t;
    this.item && ((t = this.item) === null || t === void 0 || t.setAttribute("aria-expanded", e));
  }
  applyStyle() {
    if (super.applyStyle(), !this.menuStyle)
      return;
    const t = this.element && this.element.classList.contains("focused") && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    this.submenuIndicator && (this.submenuIndicator.style.color = t ? `${t}` : ""), this.parentData.submenu && this.parentData.submenu.style(this.menuStyle);
  }
  dispose() {
    super.dispose(), this.hideScheduler.dispose(), this.mysubmenu && (this.mysubmenu.dispose(), this.mysubmenu = null), this.submenuContainer && (this.submenuContainer = void 0);
  }
}
class c1 extends y7 {
  style(e) {
    this.label && (this.label.style.borderBottomColor = e.separatorColor ? `${e.separatorColor}` : "");
  }
}
function jge(n) {
  const e = bO, t = e.exec(n);
  if (!t)
    return n;
  const i = !t[1];
  return n.replace(e, i ? "$2$3" : "").trim();
}
let kW = `
.monaco-menu {
	font-size: 13px;

}

${IW(X7)}
${IW(Z7)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar.animated .action-item.active {
	transform: scale(1.272019649, 1.272019649); /* 1.272019649 =  */
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	opacity: 0.4;
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid #bbb;
	padding-top: 1px;
	margin-left: .8em;
	margin-right: .8em;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	padding: 0.5em 0 0 0;
	margin-bottom: 0.5em;
	width: 100%;
	height: 0px !important;
	margin-left: .8em !important;
	margin-right: .8em !important;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	border: thin solid transparent; /* prevents jumping behaviour on hover or focus */
}


/* High Contrast Theming */
:host-context(.hc-black) .context-view.monaco-menu-container {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: .5em 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 1.8em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	padding: 0.2em 0 0 0;
	margin-bottom: 0.2em;
}

:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}

/* Arrows */
.monaco-scrollable-element > .scrollbar > .scra {
	cursor: pointer;
	font-size: 11px !important;
}

.monaco-scrollable-element > .visible {
	opacity: 1;

	/* Background rule added for IE9 - to allow clicks on dom node */
	background:rgba(0,0,0,0);

	transition: opacity 100ms linear;
}
.monaco-scrollable-element > .invisible {
	opacity: 0;
	pointer-events: none;
}
.monaco-scrollable-element > .invisible.fade {
	transition: opacity 800ms linear;
}

/* Scrollable Content Inset Shadow */
.monaco-scrollable-element > .shadow {
	position: absolute;
	display: none;
}
.monaco-scrollable-element > .shadow.top {
	display: block;
	top: 0;
	left: 3px;
	height: 3px;
	width: 100%;
	box-shadow: #DDD 0 6px 6px -6px inset;
}
.monaco-scrollable-element > .shadow.left {
	display: block;
	top: 3px;
	left: 0;
	height: 100%;
	width: 3px;
	box-shadow: #DDD 6px 0 6px -6px inset;
}
.monaco-scrollable-element > .shadow.top-left-corner {
	display: block;
	top: 0;
	left: 0;
	height: 3px;
	width: 3px;
}
.monaco-scrollable-element > .shadow.top.left {
	box-shadow: #DDD 6px 6px 6px -6px inset;
}

/* ---------- Default Style ---------- */

:host-context(.vs) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(100, 100, 100, .4);
}
:host-context(.vs-dark) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(121, 121, 121, .4);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider {
	background: rgba(111, 195, 223, .6);
}

.monaco-scrollable-element > .scrollbar > .slider:hover {
	background: rgba(100, 100, 100, .7);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider:hover {
	background: rgba(111, 195, 223, .8);
}

.monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(0, 0, 0, .6);
}
:host-context(.vs-dark) .monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(191, 191, 191, .4);
}
:host-context(.hc-black) .monaco-scrollable-element > .scrollbar > .slider.active {
	background: rgba(111, 195, 223, 1);
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.top {
	box-shadow: none;
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.left {
	box-shadow: #000 6px 0 6px -6px inset;
}

:host-context(.vs-dark) .monaco-scrollable-element .shadow.top.left {
	box-shadow: #000 6px 6px 6px -6px inset;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.top {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.left {
	box-shadow: none;
}

:host-context(.hc-black) .monaco-scrollable-element .shadow.top.left {
	box-shadow: none;
}
`;
function Va(n, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (let i in e) {
    const r = e[i];
    r && (t[i] = Wc(r, n));
  }
  return t;
}
function XI(n, e, t) {
  function i() {
    const r = Va(n.getColorTheme(), e);
    typeof t == "function" ? t(r) : t.style(r);
  }
  return i(), n.onDidColorThemeChange(i);
}
function Zwe(n, e, t) {
  return XI(e, {
    badgeBackground: (t == null ? void 0 : t.badgeBackground) || G3,
    badgeForeground: (t == null ? void 0 : t.badgeForeground) || U3,
    badgeBorder: pr
  }, n);
}
function dg(n, e, t) {
  return XI(e, Object.assign(Object.assign({}, HE), t || {}), n);
}
const HE = {
  listFocusBackground: Zce,
  listFocusForeground: Qce,
  listFocusOutline: Jce,
  listActiveSelectionBackground: Ed,
  listActiveSelectionForeground: rh,
  listFocusAndSelectionBackground: Ed,
  listFocusAndSelectionForeground: rh,
  listInactiveSelectionBackground: ehe,
  listInactiveSelectionForeground: the,
  listInactiveFocusBackground: ihe,
  listInactiveFocusOutline: nhe,
  listHoverBackground: rhe,
  listHoverForeground: ohe,
  listDropBackground: she,
  listSelectionOutline: Ms,
  listHoverOutline: Ms,
  listFilterWidgetBackground: lhe,
  listFilterWidgetOutline: uhe,
  listFilterWidgetNoMatchesOutline: che,
  listMatchesShadow: zb,
  treeIndentGuidesStroke: hhe,
  tableColumnsBorder: dhe
}, $ge = {
  shadowColor: zb,
  borderColor: ghe,
  foregroundColor: mhe,
  backgroundColor: vhe,
  selectionForegroundColor: _he,
  selectionBackgroundColor: Che,
  selectionBorderColor: yhe,
  separatorColor: whe
};
function Kge(n, e, t) {
  return XI(e, Object.assign(Object.assign({}, $ge), t), n);
}
class qge {
  constructor(e, t, i, r, o) {
    this.contextViewService = e, this.telemetryService = t, this.notificationService = i, this.keybindingService = r, this.themeService = o, this.focusToReturn = null, this.block = null, this.options = { blockMouse: !0 };
  }
  configure(e) {
    this.options = e;
  }
  showContextMenu(e) {
    const t = e.getActions();
    if (!t.length)
      return;
    this.focusToReturn = document.activeElement;
    let i, r = c5(e.domForShadowRoot) ? e.domForShadowRoot : void 0;
    this.contextViewService.showContextView({
      getAnchor: () => e.getAnchor(),
      canRelayout: !1,
      anchorAlignment: e.anchorAlignment,
      anchorAxisAlignment: e.anchorAxisAlignment,
      render: (o) => {
        let s = e.getMenuClassName ? e.getMenuClassName() : "";
        s && (o.className += " " + s), this.options.blockMouse && (this.block = o.appendChild(Xe(".context-view-block")), this.block.style.position = "fixed", this.block.style.cursor = "initial", this.block.style.left = "0", this.block.style.top = "0", this.block.style.width = "100%", this.block.style.height = "100%", this.block.style.zIndex = "-1", wt(this.block, Ge.MOUSE_DOWN)((u) => u.stopPropagation()));
        const a = new dt(), l = e.actionRunner || new lI();
        return l.onBeforeRun(this.onActionRun, this, a), l.onDidRun(this.onDidActionRun, this, a), i = new Q7(o, t, {
          actionViewItemProvider: e.getActionViewItem,
          context: e.getActionsContext ? e.getActionsContext() : null,
          actionRunner: l,
          getKeyBinding: e.getKeyBinding ? e.getKeyBinding : (u) => this.keybindingService.lookupKeybinding(u.id)
        }), a.add(Kge(i, this.themeService)), i.onDidCancel(() => this.contextViewService.hideContextView(!0), null, a), i.onDidBlur(() => this.contextViewService.hideContextView(!0), null, a), wt(window, Ge.BLUR)(() => {
          this.contextViewService.hideContextView(!0);
        }, null, a), wt(window, Ge.MOUSE_DOWN)((u) => {
          if (u.defaultPrevented)
            return;
          let c = new pa(u), h = c.target;
          if (!c.rightButton) {
            for (; h; ) {
              if (h === o)
                return;
              h = h.parentElement;
            }
            this.contextViewService.hideContextView(!0);
          }
        }, null, a), bp(a, i);
      },
      focus: () => {
        i && i.focus(!!e.autoSelectFirstItem);
      },
      onHide: (o) => {
        e.onHide && e.onHide(!!o), this.block && (this.block.remove(), this.block = null), this.focusToReturn && this.focusToReturn.focus();
      }
    }, r, !!r);
  }
  onActionRun(e) {
    this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "contextMenu" }), this.contextViewService.hideContextView(!1), this.focusToReturn && this.focusToReturn.focus();
  }
  onDidActionRun(e) {
    e.error && !W_(e.error) && this.notificationService.error(e.error);
  }
}
var Yge = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, jm = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let EO = class extends Ce {
  constructor(e, t, i, r, o) {
    super(), this.contextMenuHandler = new qge(i, e, t, r, o);
  }
  configure(e) {
    this.contextMenuHandler.configure(e);
  }
  // ContextMenu
  showContextMenu(e) {
    this.contextMenuHandler.showContextMenu(e), rp.getInstance().resetKeyStatus();
  }
};
EO = Yge([
  jm(0, EE),
  jm(1, al),
  jm(2, Bg),
  jm(3, xo),
  jm(4, er)
], EO);
const GE = Vt("layoutService");
var Xge = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Zge = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let LO = class extends Ce {
  constructor(e) {
    super(), this.layoutService = e, this.currentViewDisposable = Ce.None, this.container = e.container, this.contextView = this._register(new hg(
      this.container,
      1
      /* ABSOLUTE */
    )), this.layout(), this._register(e.onDidLayout(() => this.layout()));
  }
  // ContextView
  setContainer(e, t) {
    this.contextView.setContainer(
      e,
      t || 1
      /* ABSOLUTE */
    );
  }
  showContextView(e, t, i) {
    t ? t !== this.container && (this.container = t, this.setContainer(
      t,
      i ? 3 : 2
      /* FIXED */
    )) : this.container !== this.layoutService.container && (this.container = this.layoutService.container, this.setContainer(
      this.container,
      1
      /* ABSOLUTE */
    )), this.contextView.show(e);
    const r = Oi(() => {
      this.currentViewDisposable === r && this.hideContextView();
    });
    return this.currentViewDisposable = r, r;
  }
  getContextViewElement() {
    return this.contextView.getViewElement();
  }
  layout() {
    this.contextView.layout();
  }
  hideContextView(e) {
    this.contextView.hide(e);
  }
};
LO = Xge([
  Zge(0, GE)
], LO);
const J7 = Vt("dialogService");
let Qge = class {
  constructor(e) {
    this.incoming = /* @__PURE__ */ new Map(), this.outgoing = /* @__PURE__ */ new Map(), this.data = e;
  }
};
class Jge {
  constructor(e) {
    this._hashFn = e, this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const e = [];
    for (let t of this._nodes.values())
      t.outgoing.size === 0 && e.push(t);
    return e;
  }
  insertEdge(e, t) {
    const i = this.lookupOrInsertNode(e), r = this.lookupOrInsertNode(t);
    i.outgoing.set(this._hashFn(t), r), r.incoming.set(this._hashFn(e), i);
  }
  removeNode(e) {
    const t = this._hashFn(e);
    this._nodes.delete(t);
    for (let i of this._nodes.values())
      i.outgoing.delete(t), i.incoming.delete(t);
  }
  lookupOrInsertNode(e) {
    const t = this._hashFn(e);
    let i = this._nodes.get(t);
    return i || (i = new Qge(e), this._nodes.set(t, i)), i;
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    let e = [];
    for (let [t, i] of this._nodes)
      e.push(`${t}, (incoming)[${[...i.incoming.keys()].join(", ")}], (outgoing)[${[...i.outgoing.keys()].join(",")}]`);
    return e.join(`
`);
  }
  /**
   * This is brute force and slow and **only** be used
   * to trouble shoot.
   */
  findCycleSlow() {
    for (let [e, t] of this._nodes) {
      const i = /* @__PURE__ */ new Set([e]), r = this._findCycle(t, i);
      if (r)
        return r;
    }
  }
  _findCycle(e, t) {
    for (let [i, r] of e.outgoing) {
      if (t.has(i))
        return [...t, i].join(" -> ");
      t.add(i);
      const o = this._findCycle(r, t);
      if (o)
        return o;
      t.delete(i);
    }
  }
}
class WW extends Error {
  constructor(e) {
    var t;
    super("cyclic dependency between services"), this.message = (t = e.findCycleSlow()) !== null && t !== void 0 ? t : `UNABLE to detect cycle, dumping graph: 
${e.toString()}`;
  }
}
class dS {
  constructor(e = new f_(), t = !1, i) {
    this._activeInstantiations = /* @__PURE__ */ new Set(), this._services = e, this._strict = t, this._parent = i, this._services.set(no, this);
  }
  createChild(e) {
    return new dS(e, this._strict, this);
  }
  invokeFunction(e, ...t) {
    let i = ua.traceInvocation(e), r = !1;
    try {
      return e({
        get: (s, a) => {
          if (r)
            throw $ne("service accessor is only valid during the invocation of its target method");
          const l = this._getOrCreateServiceInstance(s, i);
          if (!l && a !== Cre)
            throw new Error(`[invokeFunction] unknown service '${s}'`);
          return l;
        }
      }, ...t);
    } finally {
      r = !0, i.stop();
    }
  }
  createInstance(e, ...t) {
    let i, r;
    return e instanceof Vc ? (i = ua.traceCreation(e.ctor), r = this._createInstance(e.ctor, e.staticArguments.concat(t), i)) : (i = ua.traceCreation(e), r = this._createInstance(e, t, i)), i.stop(), r;
  }
  _createInstance(e, t = [], i) {
    let r = Ka.getServiceDependencies(e).sort((a, l) => a.index - l.index), o = [];
    for (const a of r) {
      let l = this._getOrCreateServiceInstance(a.id, i);
      if (!l && this._strict && !a.optional)
        throw new Error(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`);
      o.push(l);
    }
    let s = r.length > 0 ? r[0].index : t.length;
    if (t.length !== s) {
      console.warn(`[createInstance] First service dependency of ${e.name} at position ${s + 1} conflicts with ${t.length} static arguments`);
      let a = s - t.length;
      a > 0 ? t = t.concat(new Array(a)) : t = t.slice(0, s);
    }
    return new e(...t, ...o);
  }
  _setServiceInstance(e, t) {
    if (this._services.get(e) instanceof Vc)
      this._services.set(e, t);
    else if (this._parent)
      this._parent._setServiceInstance(e, t);
    else
      throw new Error("illegalState - setting UNKNOWN service instance");
  }
  _getServiceInstanceOrDescriptor(e) {
    let t = this._services.get(e);
    return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t;
  }
  _getOrCreateServiceInstance(e, t) {
    let i = this._getServiceInstanceOrDescriptor(e);
    return i instanceof Vc ? this._safeCreateAndCacheServiceInstance(e, i, t.branch(e, !0)) : (t.branch(e, !1), i);
  }
  _safeCreateAndCacheServiceInstance(e, t, i) {
    if (this._activeInstantiations.has(e))
      throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
    this._activeInstantiations.add(e);
    try {
      return this._createAndCacheServiceInstance(e, t, i);
    } finally {
      this._activeInstantiations.delete(e);
    }
  }
  _createAndCacheServiceInstance(e, t, i) {
    const r = new Jge((a) => a.id.toString());
    let o = 0;
    const s = [{ id: e, desc: t, _trace: i }];
    for (; s.length; ) {
      const a = s.pop();
      if (r.lookupOrInsertNode(a), o++ > 1e3)
        throw new WW(r);
      for (let l of Ka.getServiceDependencies(a.desc.ctor)) {
        let u = this._getServiceInstanceOrDescriptor(l.id);
        if (!u && !l.optional && console.warn(`[createInstance] ${e} depends on ${l.id} which is NOT registered.`), u instanceof Vc) {
          const c = { id: l.id, desc: u, _trace: a._trace.branch(l.id, !0) };
          r.insertEdge(a, c), s.push(c);
        }
      }
    }
    for (; ; ) {
      const a = r.roots();
      if (a.length === 0) {
        if (!r.isEmpty())
          throw new WW(r);
        break;
      }
      for (const { data: l } of a) {
        if (this._getServiceInstanceOrDescriptor(l.id) instanceof Vc) {
          const c = this._createServiceInstanceWithOwner(l.id, l.desc.ctor, l.desc.staticArguments, l.desc.supportsDelayedInstantiation, l._trace);
          this._setServiceInstance(l.id, c);
        }
        r.removeNode(l);
      }
    }
    return this._getServiceInstanceOrDescriptor(e);
  }
  _createServiceInstanceWithOwner(e, t, i = [], r, o) {
    if (this._services.get(e) instanceof Vc)
      return this._createServiceInstance(t, i, r, o);
    if (this._parent)
      return this._parent._createServiceInstanceWithOwner(e, t, i, r, o);
    throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`);
  }
  _createServiceInstance(e, t = [], i, r) {
    if (i) {
      const o = new QG(() => this._createInstance(e, t, r));
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(s, a) {
          if (a in s)
            return s[a];
          let l = o.value, u = l[a];
          return typeof u != "function" || (u = u.bind(l), s[a] = u), u;
        },
        set(s, a, l) {
          return o.value[a] = l, !0;
        }
      });
    } else
      return this._createInstance(e, t, r);
  }
}
class ua {
  constructor(e, t) {
    this.type = e, this.name = t, this._start = Date.now(), this._dep = [];
  }
  static traceInvocation(e) {
    return ua._None;
  }
  static traceCreation(e) {
    return ua._None;
  }
  branch(e, t) {
    let i = new ua(2, e.toString());
    return this._dep.push([e, t, i]), i;
  }
  stop() {
    let e = Date.now() - this._start;
    ua._totals += e;
    let t = !1;
    function i(o, s) {
      let a = [], l = new Array(o + 1).join("	");
      for (const [u, c, h] of s._dep)
        if (c && h) {
          t = !0, a.push(`${l}CREATES -> ${u}`);
          let d = i(o + 1, h);
          d && a.push(d);
        } else
          a.push(`${l}uses -> ${u}`);
      return a.join(`
`);
    }
    let r = [
      `${this.type === 0 ? "CREATE" : "CALL"} ${this.name}`,
      `${i(1, this)}`,
      `DONE, took ${e.toFixed(2)}ms (grand total ${ua._totals.toFixed(2)}ms)`
    ];
    (e > 2 || t) && console.log(r.join(`
`));
  }
}
ua._None = new class extends ua {
  constructor() {
    super(-1, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}();
ua._totals = 0;
const eme = Vt("labelService");
class jh extends Error {
  constructor(e, t) {
    super(`ListError [${e}] ${t}`);
  }
}
function VW(n, e) {
  const t = [];
  for (let i of e) {
    if (n.start >= i.range.end)
      continue;
    if (n.end < i.range.start)
      break;
    const r = cr.intersect(n, i.range);
    cr.isEmpty(r) || t.push({
      range: r,
      size: i.size
    });
  }
  return t;
}
function DO({ start: n, end: e }, t) {
  return { start: n + t, end: e + t };
}
function tme(n) {
  const e = [];
  let t = null;
  for (let i of n) {
    const r = i.range.start, o = i.range.end, s = i.size;
    if (t && s === t.size) {
      t.range.end = o;
      continue;
    }
    t = { range: { start: r, end: o }, size: s }, e.push(t);
  }
  return e;
}
function ime(...n) {
  return tme(n.reduce((e, t) => e.concat(t), []));
}
class BW {
  constructor() {
    this.groups = [], this._size = 0;
  }
  splice(e, t, i = []) {
    const r = i.length - t, o = VW({ start: 0, end: e }, this.groups), s = VW({ start: e + t, end: Number.POSITIVE_INFINITY }, this.groups).map((l) => ({ range: DO(l.range, r), size: l.size })), a = i.map((l, u) => ({
      range: { start: e + u, end: e + u + 1 },
      size: l.size
    }));
    this.groups = ime(o, a, s), this._size = this.groups.reduce((l, u) => l + u.size * (u.range.end - u.range.start), 0);
  }
  /**
   * Returns the number of items in the range map.
   */
  get count() {
    const e = this.groups.length;
    return e ? this.groups[e - 1].range.end : 0;
  }
  /**
   * Returns the sum of the sizes of all items in the range map.
   */
  get size() {
    return this._size;
  }
  /**
   * Returns the index of the item at the given position.
   */
  indexAt(e) {
    if (e < 0)
      return -1;
    let t = 0, i = 0;
    for (let r of this.groups) {
      const o = r.range.end - r.range.start, s = i + o * r.size;
      if (e < s)
        return t + Math.floor((e - i) / r.size);
      t += o, i = s;
    }
    return t;
  }
  /**
   * Returns the index of the item right after the item at the
   * index of the given position.
   */
  indexAfter(e) {
    return Math.min(this.indexAt(e) + 1, this.count);
  }
  /**
   * Returns the start position of the item at the given index.
   */
  positionAt(e) {
    if (e < 0)
      return -1;
    let t = 0, i = 0;
    for (let r of this.groups) {
      const o = r.range.end - r.range.start, s = i + o;
      if (e < s)
        return t + (e - i) * r.size;
      t += o * r.size, i = s;
    }
    return -1;
  }
}
function nme(n) {
  try {
    n.parentElement && n.parentElement.removeChild(n);
  } catch {
  }
}
class rme {
  constructor(e) {
    this.renderers = e, this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Returns a row either by creating a new one or reusing
   * a previously released row which shares the same templateId.
   */
  alloc(e) {
    let t = this.getTemplateCache(e).pop();
    if (!t) {
      const i = Xe(".monaco-list-row"), o = this.getRenderer(e).renderTemplate(i);
      t = { domNode: i, templateId: e, templateData: o };
    }
    return t;
  }
  /**
   * Releases the row for eventual reuse.
   */
  release(e) {
    e && this.releaseRow(e);
  }
  releaseRow(e) {
    const { domNode: t, templateId: i } = e;
    t && (t.classList.remove("scrolling"), nme(t)), this.getTemplateCache(i).push(e);
  }
  getTemplateCache(e) {
    let t = this.cache.get(e);
    return t || (t = [], this.cache.set(e, t)), t;
  }
  dispose() {
    this.cache.forEach((e, t) => {
      for (const i of e)
        this.getRenderer(t).disposeTemplate(i.templateData), i.templateData = null;
    }), this.cache.clear();
  }
  getRenderer(e) {
    const t = this.renderers.get(e);
    if (!t)
      throw new Error(`No renderer found for ${e}`);
    return t;
  }
}
var hf = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
};
const Ol = {
  useShadows: !0,
  verticalScrollMode: 1,
  setRowLineHeight: !0,
  setRowHeight: !0,
  supportDynamicHeights: !1,
  dnd: {
    getDragElements(n) {
      return [n];
    },
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    }
  },
  horizontalScrolling: !1,
  transformOptimization: !0,
  alwaysConsumeMouseWheel: !0
};
class eC {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class ome {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class sme {
  constructor() {
    this.types = [], this.files = [];
  }
  update(e) {
    if (e.types && this.types.splice(0, this.types.length, ...e.types), e.files) {
      this.files.splice(0, this.files.length);
      for (let t = 0; t < e.files.length; t++) {
        const i = e.files.item(t);
        i && (i.size || i.type) && this.files.push(i);
      }
    }
  }
  getData() {
    return {
      types: this.types,
      files: this.files
    };
  }
}
function ame(n, e) {
  return Array.isArray(n) && Array.isArray(e) ? Yu(n, e) : n === e;
}
class lme {
  constructor(e) {
    e != null && e.getSetSize ? this.getSetSize = e.getSetSize.bind(e) : this.getSetSize = (t, i, r) => r, e != null && e.getPosInSet ? this.getPosInSet = e.getPosInSet.bind(e) : this.getPosInSet = (t, i) => i + 1, e != null && e.getRole ? this.getRole = e.getRole.bind(e) : this.getRole = (t) => "listitem", e != null && e.isChecked ? this.isChecked = e.isChecked.bind(e) : this.isChecked = (t) => {
    };
  }
}
class ll {
  constructor(e, t, i, r = Ol) {
    if (this.virtualDelegate = t, this.domId = `list_id_${++ll.InstanceCount}`, this.renderers = /* @__PURE__ */ new Map(), this.renderWidth = 0, this._scrollHeight = 0, this.scrollableElementUpdateDisposable = null, this.scrollableElementWidthDelayer = new AN(50), this.splicing = !1, this.dragOverAnimationStopDisposable = Ce.None, this.dragOverMouseY = 0, this.canDrop = !1, this.currentDragFeedbackDisposable = Ce.None, this.onDragLeaveTimeout = Ce.None, this.disposables = new dt(), this._onDidChangeContentHeight = new q(), this._horizontalScrolling = !1, r.horizontalScrolling && r.supportDynamicHeights)
      throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
    this.items = [], this.itemId = 0, this.rangeMap = new BW();
    for (const s of i)
      this.renderers.set(s.templateId, s);
    this.cache = this.disposables.add(new rme(this.renderers)), this.lastRenderTop = 0, this.lastRenderHeight = 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-list", this.domNode.classList.add(this.domId), this.domNode.tabIndex = 0, this.domNode.classList.toggle("mouse-support", typeof r.mouseSupport == "boolean" ? r.mouseSupport : !0), this._horizontalScrolling = Tl(r, (s) => s.horizontalScrolling, Ol.horizontalScrolling), this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this.additionalScrollHeight = typeof r.additionalScrollHeight > "u" ? 0 : r.additionalScrollHeight, this.accessibilityProvider = new lme(r.accessibilityProvider), this.rowsContainer = document.createElement("div"), this.rowsContainer.className = "monaco-list-rows", Tl(r, (s) => s.transformOptimization, Ol.transformOptimization) && (this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)"), this.disposables.add(ri.addTarget(this.rowsContainer)), this.scrollable = new AE(Tl(r, (s) => s.smoothScrolling, !1) ? 125 : 0, (s) => Zl(s)), this.scrollableElement = this.disposables.add(new DI(this.rowsContainer, {
      alwaysConsumeMouseWheel: Tl(r, (s) => s.alwaysConsumeMouseWheel, Ol.alwaysConsumeMouseWheel),
      horizontal: 1,
      vertical: Tl(r, (s) => s.verticalScrollMode, Ol.verticalScrollMode),
      useShadows: Tl(r, (s) => s.useShadows, Ol.useShadows)
    }, this.scrollable)), this.domNode.appendChild(this.scrollableElement.getDomNode()), e.appendChild(this.domNode), this.scrollableElement.onScroll(this.onScroll, this, this.disposables), wt(this.rowsContainer, Ri.Change)((s) => this.onTouchChange(s), this, this.disposables), wt(this.scrollableElement.getDomNode(), "scroll")((s) => s.target.scrollTop = 0, null, this.disposables), We.map(wt(this.domNode, "dragover"), (s) => this.toDragEvent(s))(this.onDragOver, this, this.disposables), We.map(wt(this.domNode, "drop"), (s) => this.toDragEvent(s))(this.onDrop, this, this.disposables), wt(this.domNode, "dragleave")(this.onDragLeave, this, this.disposables), wt(window, "dragend")(this.onDragEnd, this, this.disposables), this.setRowLineHeight = Tl(r, (s) => s.setRowLineHeight, Ol.setRowLineHeight), this.setRowHeight = Tl(r, (s) => s.setRowHeight, Ol.setRowHeight), this.supportDynamicHeights = Tl(r, (s) => s.supportDynamicHeights, Ol.supportDynamicHeights), this.dnd = Tl(r, (s) => s.dnd, Ol.dnd), this.layout();
  }
  get contentHeight() {
    return this.rangeMap.size;
  }
  get horizontalScrolling() {
    return this._horizontalScrolling;
  }
  set horizontalScrolling(e) {
    if (e !== this._horizontalScrolling) {
      if (e && this.supportDynamicHeights)
        throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
      if (this._horizontalScrolling = e, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this._horizontalScrolling) {
        for (const t of this.items)
          this.measureItemWidth(t);
        this.updateScrollWidth(), this.scrollableElement.setScrollDimensions({ width: uD(this.domNode) }), this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
      } else
        this.scrollableElementWidthDelayer.cancel(), this.scrollableElement.setScrollDimensions({ width: this.renderWidth, scrollWidth: this.renderWidth }), this.rowsContainer.style.width = "";
    }
  }
  updateOptions(e) {
    e.additionalScrollHeight !== void 0 && (this.additionalScrollHeight = e.additionalScrollHeight, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), e.smoothScrolling !== void 0 && this.scrollable.setSmoothScrollDuration(e.smoothScrolling ? 125 : 0), e.horizontalScrolling !== void 0 && (this.horizontalScrolling = e.horizontalScrolling);
  }
  splice(e, t, i = []) {
    if (this.splicing)
      throw new Error("Can't run recursive splices.");
    this.splicing = !0;
    try {
      return this._splice(e, t, i);
    } finally {
      this.splicing = !1, this._onDidChangeContentHeight.fire(this.contentHeight);
    }
  }
  _splice(e, t, i = []) {
    const r = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), o = { start: e, end: e + t }, s = cr.intersect(r, o), a = /* @__PURE__ */ new Map();
    for (let L = s.start; L < s.end; L++) {
      const S = this.items[L];
      if (S.dragStartDisposable.dispose(), S.row) {
        let E = a.get(S.templateId);
        E || (E = [], a.set(S.templateId, E));
        const D = this.renderers.get(S.templateId);
        D && D.disposeElement && D.disposeElement(S.element, L, S.row.templateData, S.size), E.push(S.row);
      }
      S.row = null;
    }
    const l = { start: e + t, end: this.items.length }, u = cr.intersect(l, r), c = cr.relativeComplement(l, r), h = i.map((L) => ({
      id: String(this.itemId++),
      element: L,
      templateId: this.virtualDelegate.getTemplateId(L),
      size: this.virtualDelegate.getHeight(L),
      width: void 0,
      hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(L),
      lastDynamicHeightWidth: void 0,
      row: null,
      uri: void 0,
      dropTarget: !1,
      dragStartDisposable: Ce.None
    }));
    let d;
    e === 0 && t >= this.items.length ? (this.rangeMap = new BW(), this.rangeMap.splice(0, 0, h), d = this.items, this.items = h) : (this.rangeMap.splice(e, t, h), d = this.items.splice(e, t, ...h));
    const f = i.length - t, p = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), g = DO(u, f), _ = cr.intersect(p, g);
    for (let L = _.start; L < _.end; L++)
      this.updateItemInDOM(this.items[L], L);
    const m = cr.relativeComplement(g, p);
    for (const L of m)
      for (let S = L.start; S < L.end; S++)
        this.removeItemFromDOM(S);
    const v = c.map((L) => DO(L, f)), y = [{ start: e, end: e + i.length }, ...v].map((L) => cr.intersect(p, L)), w = this.getNextToLastElement(y);
    for (const L of y)
      for (let S = L.start; S < L.end; S++) {
        const E = this.items[S], D = a.get(E.templateId), x = D == null ? void 0 : D.pop();
        this.insertItemInDOM(S, w, x);
      }
    for (const L of a.values())
      for (const S of L)
        this.cache.release(S);
    return this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight), d.map((L) => L.element);
  }
  eventuallyUpdateScrollDimensions() {
    this._scrollHeight = this.contentHeight, this.rowsContainer.style.height = `${this._scrollHeight}px`, this.scrollableElementUpdateDisposable || (this.scrollableElementUpdateDisposable = Zl(() => {
      this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight }), this.updateScrollWidth(), this.scrollableElementUpdateDisposable = null;
    }));
  }
  eventuallyUpdateScrollWidth() {
    if (!this.horizontalScrolling) {
      this.scrollableElementWidthDelayer.cancel();
      return;
    }
    this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
  }
  updateScrollWidth() {
    if (!this.horizontalScrolling)
      return;
    let e = 0;
    for (const t of this.items)
      typeof t.width < "u" && (e = Math.max(e, t.width));
    this.scrollWidth = e, this.scrollableElement.setScrollDimensions({ scrollWidth: e === 0 ? 0 : e + 10 });
  }
  rerender() {
    if (this.supportDynamicHeights) {
      for (const e of this.items)
        e.lastDynamicHeightWidth = void 0;
      this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }
  get length() {
    return this.items.length;
  }
  get renderHeight() {
    return this.scrollableElement.getScrollDimensions().height;
  }
  element(e) {
    return this.items[e].element;
  }
  domElement(e) {
    const t = this.items[e].row;
    return t && t.domNode;
  }
  elementHeight(e) {
    return this.items[e].size;
  }
  elementTop(e) {
    return this.rangeMap.positionAt(e);
  }
  indexAt(e) {
    return this.rangeMap.indexAt(e);
  }
  indexAfter(e) {
    return this.rangeMap.indexAfter(e);
  }
  layout(e, t) {
    let i = {
      height: typeof e == "number" ? e : $re(this.domNode)
    };
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, i.scrollHeight = this.scrollHeight), this.scrollableElement.setScrollDimensions(i), typeof t < "u" && (this.renderWidth = t, this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight)), this.horizontalScrolling && this.scrollableElement.setScrollDimensions({
      width: typeof t == "number" ? t : uD(this.domNode)
    });
  }
  // Render
  render(e, t, i, r, o, s = !1) {
    const a = this.getRenderRange(t, i), l = cr.relativeComplement(a, e), u = cr.relativeComplement(e, a), c = this.getNextToLastElement(l);
    if (s) {
      const h = cr.intersect(e, a);
      for (let d = h.start; d < h.end; d++)
        this.updateItemInDOM(this.items[d], d);
    }
    for (const h of l)
      for (let d = h.start; d < h.end; d++)
        this.insertItemInDOM(d, c);
    for (const h of u)
      for (let d = h.start; d < h.end; d++)
        this.removeItemFromDOM(d);
    r !== void 0 && (this.rowsContainer.style.left = `-${r}px`), this.rowsContainer.style.top = `-${t}px`, this.horizontalScrolling && o !== void 0 && (this.rowsContainer.style.width = `${Math.max(o, this.renderWidth)}px`), this.lastRenderTop = t, this.lastRenderHeight = i;
  }
  // DOM operations
  insertItemInDOM(e, t, i) {
    const r = this.items[e];
    r.row || (r.row = i ?? this.cache.alloc(r.templateId));
    const o = this.accessibilityProvider.getRole(r.element) || "listitem";
    r.row.domNode.setAttribute("role", o);
    const s = this.accessibilityProvider.isChecked(r.element);
    typeof s < "u" && r.row.domNode.setAttribute("aria-checked", String(!!s)), r.row.domNode.parentElement || (t ? this.rowsContainer.insertBefore(r.row.domNode, t) : this.rowsContainer.appendChild(r.row.domNode)), this.updateItemInDOM(r, e);
    const a = this.renderers.get(r.templateId);
    if (!a)
      throw new Error(`No renderer found for template id ${r.templateId}`);
    a && a.renderElement(r.element, e, r.row.templateData, r.size);
    const l = this.dnd.getDragURI(r.element);
    if (r.dragStartDisposable.dispose(), r.row.domNode.draggable = !!l, l) {
      const u = wt(r.row.domNode, "dragstart");
      r.dragStartDisposable = u((c) => this.onDragStart(r.element, l, c));
    }
    this.horizontalScrolling && (this.measureItemWidth(r), this.eventuallyUpdateScrollWidth());
  }
  measureItemWidth(e) {
    if (!e.row || !e.row.domNode)
      return;
    e.row.domNode.style.width = to ? "-moz-fit-content" : "fit-content", e.width = uD(e.row.domNode);
    const t = window.getComputedStyle(e.row.domNode);
    t.paddingLeft && (e.width += parseFloat(t.paddingLeft)), t.paddingRight && (e.width += parseFloat(t.paddingRight)), e.row.domNode.style.width = "";
  }
  updateItemInDOM(e, t) {
    e.row.domNode.style.top = `${this.elementTop(t)}px`, this.setRowHeight && (e.row.domNode.style.height = `${e.size}px`), this.setRowLineHeight && (e.row.domNode.style.lineHeight = `${e.size}px`), e.row.domNode.setAttribute("data-index", `${t}`), e.row.domNode.setAttribute("data-last-element", t === this.length - 1 ? "true" : "false"), e.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(e.element, t, this.length))), e.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(e.element, t))), e.row.domNode.setAttribute("id", this.getElementDomId(t)), e.row.domNode.classList.toggle("drop-target", e.dropTarget);
  }
  removeItemFromDOM(e) {
    const t = this.items[e];
    if (t.dragStartDisposable.dispose(), t.row) {
      const i = this.renderers.get(t.templateId);
      i && i.disposeElement && i.disposeElement(t.element, e, t.row.templateData, t.size), this.cache.release(t.row), t.row = null;
    }
    this.horizontalScrolling && this.eventuallyUpdateScrollWidth();
  }
  getScrollTop() {
    return this.scrollableElement.getScrollPosition().scrollTop;
  }
  setScrollTop(e, t) {
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), this.scrollableElement.setScrollPosition({ scrollTop: e, reuseAnimation: t });
  }
  get scrollTop() {
    return this.getScrollTop();
  }
  set scrollTop(e) {
    this.setScrollTop(e);
  }
  get scrollHeight() {
    return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.additionalScrollHeight;
  }
  // Events
  get onMouseClick() {
    return We.map(wt(this.domNode, "click"), (e) => this.toMouseEvent(e));
  }
  get onMouseDblClick() {
    return We.map(wt(this.domNode, "dblclick"), (e) => this.toMouseEvent(e));
  }
  get onMouseMiddleClick() {
    return We.filter(We.map(wt(this.domNode, "auxclick"), (e) => this.toMouseEvent(e)), (e) => e.browserEvent.button === 1);
  }
  get onMouseDown() {
    return We.map(wt(this.domNode, "mousedown"), (e) => this.toMouseEvent(e));
  }
  get onContextMenu() {
    return We.any(We.map(wt(this.domNode, "contextmenu"), (e) => this.toMouseEvent(e)), We.map(wt(this.domNode, Ri.Contextmenu), (e) => this.toGestureEvent(e)));
  }
  get onTouchStart() {
    return We.map(wt(this.domNode, "touchstart"), (e) => this.toTouchEvent(e));
  }
  get onTap() {
    return We.map(wt(this.rowsContainer, Ri.Tap), (e) => this.toGestureEvent(e));
  }
  toMouseEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], r = i && i.element;
    return { browserEvent: e, index: t, element: r };
  }
  toTouchEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], r = i && i.element;
    return { browserEvent: e, index: t, element: r };
  }
  toGestureEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.initialTarget || null), i = typeof t > "u" ? void 0 : this.items[t], r = i && i.element;
    return { browserEvent: e, index: t, element: r };
  }
  toDragEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], r = i && i.element;
    return { browserEvent: e, index: t, element: r };
  }
  onScroll(e) {
    try {
      const t = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      this.render(t, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth), this.supportDynamicHeights && this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
    } catch (t) {
      throw console.error("Got bad scroll event:", e), t;
    }
  }
  onTouchChange(e) {
    e.preventDefault(), e.stopPropagation(), this.scrollTop -= e.translationY;
  }
  // DND
  onDragStart(e, t, i) {
    if (!i.dataTransfer)
      return;
    const r = this.dnd.getDragElements(e);
    if (i.dataTransfer.effectAllowed = "copyMove", i.dataTransfer.setData(C7.RESOURCES, JSON.stringify([t])), i.dataTransfer.setDragImage) {
      let o;
      this.dnd.getDragLabel && (o = this.dnd.getDragLabel(r, i)), typeof o > "u" && (o = String(r.length));
      const s = Xe(".monaco-drag-image");
      s.textContent = o, document.body.appendChild(s), i.dataTransfer.setDragImage(s, -10, -10), setTimeout(() => document.body.removeChild(s), 0);
    }
    this.currentDragData = new eC(r), xu.CurrentDragAndDropData = new ome(r), this.dnd.onDragStart && this.dnd.onDragStart(this.currentDragData, i);
  }
  onDragOver(e) {
    if (e.browserEvent.preventDefault(), this.onDragLeaveTimeout.dispose(), xu.CurrentDragAndDropData && xu.CurrentDragAndDropData.getData() === "vscode-ui" || (this.setupDragAndDropScrollTopAnimation(e.browserEvent), !e.browserEvent.dataTransfer))
      return !1;
    if (!this.currentDragData)
      if (xu.CurrentDragAndDropData)
        this.currentDragData = xu.CurrentDragAndDropData;
      else {
        if (!e.browserEvent.dataTransfer.types)
          return !1;
        this.currentDragData = new sme();
      }
    const t = this.dnd.onDragOver(this.currentDragData, e.element, e.index, e.browserEvent);
    if (this.canDrop = typeof t == "boolean" ? t : t.accept, !this.canDrop)
      return this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), !1;
    e.browserEvent.dataTransfer.dropEffect = typeof t != "boolean" && t.effect === 0 ? "copy" : "move";
    let i;
    if (typeof t != "boolean" && t.feedback ? i = t.feedback : typeof e.index > "u" ? i = [-1] : i = [e.index], i = $5(i).filter((r) => r >= -1 && r < this.length).sort((r, o) => r - o), i = i[0] === -1 ? [-1] : i, ame(this.currentDragFeedback, i))
      return !0;
    if (this.currentDragFeedback = i, this.currentDragFeedbackDisposable.dispose(), i[0] === -1)
      this.domNode.classList.add("drop-target"), this.rowsContainer.classList.add("drop-target"), this.currentDragFeedbackDisposable = Oi(() => {
        this.domNode.classList.remove("drop-target"), this.rowsContainer.classList.remove("drop-target");
      });
    else {
      for (const r of i) {
        const o = this.items[r];
        o.dropTarget = !0, o.row && o.row.domNode.classList.add("drop-target");
      }
      this.currentDragFeedbackDisposable = Oi(() => {
        for (const r of i) {
          const o = this.items[r];
          o.dropTarget = !1, o.row && o.row.domNode.classList.remove("drop-target");
        }
      });
    }
    return !0;
  }
  onDragLeave() {
    this.onDragLeaveTimeout.dispose(), this.onDragLeaveTimeout = hT(() => this.clearDragOverFeedback(), 100);
  }
  onDrop(e) {
    if (!this.canDrop)
      return;
    const t = this.currentDragData;
    this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.currentDragData = void 0, xu.CurrentDragAndDropData = void 0, !(!t || !e.browserEvent.dataTransfer) && (e.browserEvent.preventDefault(), t.update(e.browserEvent.dataTransfer), this.dnd.drop(t, e.element, e.index, e.browserEvent));
  }
  onDragEnd(e) {
    this.canDrop = !1, this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.currentDragData = void 0, xu.CurrentDragAndDropData = void 0, this.dnd.onDragEnd && this.dnd.onDragEnd(e);
  }
  clearDragOverFeedback() {
    this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), this.currentDragFeedbackDisposable = Ce.None;
  }
  // DND scroll top animation
  setupDragAndDropScrollTopAnimation(e) {
    if (!this.dragOverAnimationDisposable) {
      const t = jre(this.domNode).top;
      this.dragOverAnimationDisposable = Qre(this.animateDragAndDropScrollTop.bind(this, t));
    }
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationStopDisposable = hT(() => {
      this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
    }, 1e3), this.dragOverMouseY = e.pageY;
  }
  animateDragAndDropScrollTop(e) {
    if (this.dragOverMouseY === void 0)
      return;
    const t = this.dragOverMouseY - e, i = this.renderHeight - 35;
    t < 35 ? this.scrollTop += Math.max(-14, Math.floor(0.3 * (t - 35))) : t > i && (this.scrollTop += Math.min(14, Math.floor(0.3 * (t - i))));
  }
  teardownDragAndDropScrollTopAnimation() {
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
  }
  // Util
  getItemIndexFromEventTarget(e) {
    const t = this.scrollableElement.getDomNode();
    let i = e;
    for (; i instanceof HTMLElement && i !== this.rowsContainer && t.contains(i); ) {
      const r = i.getAttribute("data-index");
      if (r) {
        const o = Number(r);
        if (!isNaN(o))
          return o;
      }
      i = i.parentElement;
    }
  }
  getRenderRange(e, t) {
    return {
      start: this.rangeMap.indexAt(e),
      end: this.rangeMap.indexAfter(e + t - 1)
    };
  }
  /**
   * Given a stable rendered state, checks every rendered element whether it needs
   * to be probed for dynamic height. Adjusts scroll height and top if necessary.
   */
  _rerender(e, t, i) {
    const r = this.getRenderRange(e, t);
    let o, s;
    e === this.elementTop(r.start) ? (o = r.start, s = 0) : r.end - r.start > 1 && (o = r.start + 1, s = this.elementTop(o) - e);
    let a = 0;
    for (; ; ) {
      const l = this.getRenderRange(e, t);
      let u = !1;
      for (let c = l.start; c < l.end; c++) {
        const h = this.probeDynamicHeight(c);
        h !== 0 && this.rangeMap.splice(c, 1, [this.items[c]]), a += h, u = u || h !== 0;
      }
      if (!u) {
        a !== 0 && this.eventuallyUpdateScrollDimensions();
        const c = cr.relativeComplement(r, l);
        for (const d of c)
          for (let f = d.start; f < d.end; f++)
            this.items[f].row && this.removeItemFromDOM(f);
        const h = cr.relativeComplement(l, r);
        for (const d of h)
          for (let f = d.start; f < d.end; f++) {
            const p = f + 1, g = p < this.items.length ? this.items[p].row : null, _ = g ? g.domNode : null;
            this.insertItemInDOM(f, _);
          }
        for (let d = l.start; d < l.end; d++)
          this.items[d].row && this.updateItemInDOM(this.items[d], d);
        if (typeof o == "number") {
          const d = this.scrollable.getFutureScrollPosition().scrollTop - e, f = this.elementTop(o) - s + d;
          this.setScrollTop(f, i);
        }
        this._onDidChangeContentHeight.fire(this.contentHeight);
        return;
      }
    }
  }
  probeDynamicHeight(e) {
    const t = this.items[e];
    if (!t.hasDynamicHeight || t.lastDynamicHeightWidth === this.renderWidth || this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(t.element))
      return 0;
    const i = t.size;
    if (!this.setRowHeight && t.row) {
      let s = t.row.domNode.offsetHeight;
      return t.size = s, t.lastDynamicHeightWidth = this.renderWidth, s - i;
    }
    const r = this.cache.alloc(t.templateId);
    r.domNode.style.height = "", this.rowsContainer.appendChild(r.domNode);
    const o = this.renderers.get(t.templateId);
    return o && (o.renderElement(t.element, e, r.templateData, void 0), o.disposeElement && o.disposeElement(t.element, e, r.templateData, void 0)), t.size = r.domNode.offsetHeight, this.virtualDelegate.setDynamicHeight && this.virtualDelegate.setDynamicHeight(t.element, t.size), t.lastDynamicHeightWidth = this.renderWidth, this.rowsContainer.removeChild(r.domNode), this.cache.release(r), t.size - i;
  }
  getNextToLastElement(e) {
    const t = e[e.length - 1];
    if (!t)
      return null;
    const i = this.items[t.end];
    return !i || !i.row ? null : i.row.domNode;
  }
  getElementDomId(e) {
    return `${this.domId}_${e}`;
  }
  // Dispose
  dispose() {
    if (this.items) {
      for (const e of this.items)
        if (e.row) {
          const t = this.renderers.get(e.row.templateId);
          t && (t.disposeElement && t.disposeElement(e.element, -1, e.row.templateData, void 0), t.disposeTemplate(e.row.templateData));
        }
      this.items = [];
    }
    this.domNode && this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), bi(this.disposables);
  }
}
ll.InstanceCount = 0;
hf([
  Bn
], ll.prototype, "onMouseClick", null);
hf([
  Bn
], ll.prototype, "onMouseDblClick", null);
hf([
  Bn
], ll.prototype, "onMouseMiddleClick", null);
hf([
  Bn
], ll.prototype, "onMouseDown", null);
hf([
  Bn
], ll.prototype, "onContextMenu", null);
hf([
  Bn
], ll.prototype, "onTouchStart", null);
hf([
  Bn
], ll.prototype, "onTap", null);
class ume {
  constructor(e) {
    this.spliceables = e;
  }
  splice(e, t, i) {
    this.spliceables.forEach((r) => r.splice(e, t, i));
  }
}
var UE = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, HW = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class cme {
  constructor(e) {
    this.trait = e, this.renderedElements = [];
  }
  get templateId() {
    return `template:${this.trait.trait}`;
  }
  renderTemplate(e) {
    return e;
  }
  renderElement(e, t, i) {
    const r = this.renderedElements.findIndex((o) => o.templateData === i);
    if (r >= 0) {
      const o = this.renderedElements[r];
      this.trait.unrender(i), o.index = t;
    } else {
      const o = { index: t, templateData: i };
      this.renderedElements.push(o);
    }
    this.trait.renderIndex(t, i);
  }
  splice(e, t, i) {
    const r = [];
    for (const o of this.renderedElements)
      o.index < e ? r.push(o) : o.index >= e + t && r.push({
        index: o.index + i - t,
        templateData: o.templateData
      });
    this.renderedElements = r;
  }
  renderIndexes(e) {
    for (const { index: t, templateData: i } of this.renderedElements)
      e.indexOf(t) > -1 && this.trait.renderIndex(t, i);
  }
  disposeTemplate(e) {
    const t = this.renderedElements.findIndex((i) => i.templateData === e);
    t < 0 || this.renderedElements.splice(t, 1);
  }
}
let fS = class {
  constructor(e) {
    this._trait = e, this.indexes = [], this.sortedIndexes = [], this._onChange = new q(), this.onChange = this._onChange.event;
  }
  get trait() {
    return this._trait;
  }
  get renderer() {
    return new cme(this);
  }
  splice(e, t, i) {
    const r = i.length - t, o = e + t, s = [
      ...this.sortedIndexes.filter((a) => a < e),
      ...i.map((a, l) => a ? l + e : -1).filter((a) => a !== -1),
      ...this.sortedIndexes.filter((a) => a >= o).map((a) => a + r)
    ];
    this.renderer.splice(e, t, i.length), this._set(s, s);
  }
  renderIndex(e, t) {
    t.classList.toggle(this._trait, this.contains(e));
  }
  unrender(e) {
    e.classList.remove(this._trait);
  }
  /**
   * Sets the indexes which should have this trait.
   *
   * @param indexes Indexes which should have this trait.
   * @return The old indexes which had this trait.
   */
  set(e, t) {
    return this._set(e, [...e].sort(GW), t);
  }
  _set(e, t, i) {
    const r = this.indexes, o = this.sortedIndexes;
    this.indexes = e, this.sortedIndexes = t;
    const s = RO(o, e);
    return this.renderer.renderIndexes(s), this._onChange.fire({ indexes: e, browserEvent: i }), r;
  }
  get() {
    return this.indexes;
  }
  contains(e) {
    return rae(this.sortedIndexes, e, GW) >= 0;
  }
  dispose() {
    bi(this._onChange);
  }
};
UE([
  Bn
], fS.prototype, "renderer", null);
class hme extends fS {
  constructor(e) {
    super("selected"), this.setAriaSelected = e;
  }
  renderIndex(e, t) {
    super.renderIndex(e, t), this.setAriaSelected && (this.contains(e) ? t.setAttribute("aria-selected", "true") : t.setAttribute("aria-selected", "false"));
  }
}
class h1 {
  constructor(e, t, i) {
    this.trait = e, this.view = t, this.identityProvider = i;
  }
  splice(e, t, i) {
    if (!this.identityProvider)
      return this.trait.splice(e, t, i.map(() => !1));
    const r = this.trait.get().map((s) => this.identityProvider.getId(this.view.element(s)).toString()), o = i.map((s) => r.indexOf(this.identityProvider.getId(s).toString()) > -1);
    this.trait.splice(e, t, o);
  }
}
function fh(n) {
  return n.tagName === "INPUT" || n.tagName === "TEXTAREA";
}
function hp(n) {
  return n.classList.contains("monaco-editor") ? !0 : n.classList.contains("monaco-list") || !n.parentElement ? !1 : hp(n.parentElement);
}
class dme {
  constructor(e, t, i) {
    this.list = e, this.view = t, this.disposables = new dt();
    const r = i.multipleSelectionSupport !== !1, o = We.chain(wt(t.domNode, "keydown")).filter((s) => !fh(s.target)).map((s) => new Yi(s));
    o.filter(
      (s) => s.keyCode === 3
      /* Enter */
    ).on(this.onEnter, this, this.disposables), o.filter(
      (s) => s.keyCode === 16
      /* UpArrow */
    ).on(this.onUpArrow, this, this.disposables), o.filter(
      (s) => s.keyCode === 18
      /* DownArrow */
    ).on(this.onDownArrow, this, this.disposables), o.filter(
      (s) => s.keyCode === 11
      /* PageUp */
    ).on(this.onPageUpArrow, this, this.disposables), o.filter(
      (s) => s.keyCode === 12
      /* PageDown */
    ).on(this.onPageDownArrow, this, this.disposables), o.filter(
      (s) => s.keyCode === 9
      /* Escape */
    ).on(this.onEscape, this, this.disposables), r && o.filter(
      (s) => (kt ? s.metaKey : s.ctrlKey) && s.keyCode === 31
      /* KEY_A */
    ).on(this.onCtrlA, this, this.disposables);
  }
  onEnter(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(this.list.getFocus(), e.browserEvent);
  }
  onUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPrevious(1, !1, e.browserEvent), this.list.reveal(this.list.getFocus()[0]), this.view.domNode.focus();
  }
  onDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNext(1, !1, e.browserEvent), this.list.reveal(this.list.getFocus()[0]), this.view.domNode.focus();
  }
  onPageUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPreviousPage(e.browserEvent), this.list.reveal(this.list.getFocus()[0]), this.view.domNode.focus();
  }
  onPageDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNextPage(e.browserEvent), this.list.reveal(this.list.getFocus()[0]), this.view.domNode.focus();
  }
  onCtrlA(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(kr(this.list.length), e.browserEvent), this.view.domNode.focus();
  }
  onEscape(e) {
    this.list.getSelection().length && (e.preventDefault(), e.stopPropagation(), this.list.setSelection([], e.browserEvent), this.view.domNode.focus());
  }
  dispose() {
    this.disposables.dispose();
  }
}
var dp;
(function(n) {
  n[n.Idle = 0] = "Idle", n[n.Typing = 1] = "Typing";
})(dp || (dp = {}));
const eU = new class {
  mightProducePrintableCharacter(n) {
    return n.ctrlKey || n.metaKey || n.altKey ? !1 : n.keyCode >= 31 && n.keyCode <= 56 || n.keyCode >= 21 && n.keyCode <= 30 || n.keyCode >= 93 && n.keyCode <= 102 || n.keyCode >= 80 && n.keyCode <= 90;
  }
}();
class fme {
  constructor(e, t, i, r) {
    this.list = e, this.view = t, this.keyboardNavigationLabelProvider = i, this.delegate = r, this.enabled = !1, this.state = dp.Idle, this.automaticKeyboardNavigation = !0, this.triggered = !1, this.previouslyFocused = -1, this.enabledDisposables = new dt(), this.disposables = new dt(), this.updateOptions(e.options);
  }
  updateOptions(e) {
    (typeof e.enableKeyboardNavigation > "u" ? !0 : !!e.enableKeyboardNavigation) ? this.enable() : this.disable(), typeof e.automaticKeyboardNavigation < "u" && (this.automaticKeyboardNavigation = e.automaticKeyboardNavigation);
  }
  enable() {
    if (this.enabled)
      return;
    const e = We.chain(wt(this.view.domNode, "keydown")).filter((r) => !fh(r.target)).filter(() => this.automaticKeyboardNavigation || this.triggered).map((r) => new Yi(r)).filter((r) => this.delegate.mightProducePrintableCharacter(r)).forEach((r) => {
      r.stopPropagation(), r.preventDefault();
    }).map((r) => r.browserEvent.key).event, t = We.debounce(e, () => null, 800);
    We.reduce(We.any(e, t), (r, o) => o === null ? null : (r || "") + o)(this.onInput, this, this.enabledDisposables), t(this.onClear, this, this.enabledDisposables), this.enabled = !0, this.triggered = !1;
  }
  disable() {
    this.enabled && (this.enabledDisposables.clear(), this.enabled = !1, this.triggered = !1);
  }
  onClear() {
    var e;
    const t = this.list.getFocus();
    if (t.length > 0 && t[0] === this.previouslyFocused) {
      const i = (e = this.list.options.accessibilityProvider) === null || e === void 0 ? void 0 : e.getAriaLabel(this.list.element(t[0]));
      i && ld(i);
    }
    this.previouslyFocused = -1;
  }
  onInput(e) {
    if (!e) {
      this.state = dp.Idle, this.triggered = !1;
      return;
    }
    const t = this.list.getFocus(), i = t.length > 0 ? t[0] : 0, r = this.state === dp.Idle ? 1 : 0;
    this.state = dp.Typing;
    for (let o = 0; o < this.list.length; o++) {
      const s = (i + o + r) % this.list.length, a = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(s)), l = a && a.toString();
      if (typeof l > "u" || zI(e, l)) {
        this.previouslyFocused = i, this.list.setFocus([s]), this.list.reveal(s);
        return;
      }
    }
  }
  dispose() {
    this.disable(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
}
class pme {
  constructor(e, t) {
    this.list = e, this.view = t, this.disposables = new dt(), We.chain(wt(t.domNode, "keydown")).filter((r) => !fh(r.target)).map((r) => new Yi(r)).filter((r) => r.keyCode === 2 && !r.ctrlKey && !r.metaKey && !r.shiftKey && !r.altKey).on(this.onTab, this, this.disposables);
  }
  onTab(e) {
    if (e.target !== this.view.domNode)
      return;
    const t = this.list.getFocus();
    if (t.length === 0)
      return;
    const i = this.view.domElement(t[0]);
    if (!i)
      return;
    const r = i.querySelector("[tabIndex]");
    if (!r || !(r instanceof HTMLElement) || r.tabIndex === -1)
      return;
    const o = window.getComputedStyle(r);
    o.visibility === "hidden" || o.display === "none" || (e.preventDefault(), e.stopPropagation(), r.focus());
  }
  dispose() {
    this.disposables.dispose();
  }
}
function tU(n) {
  return kt ? n.browserEvent.metaKey : n.browserEvent.ctrlKey;
}
function iU(n) {
  return n.browserEvent.shiftKey;
}
function gme(n) {
  return n instanceof MouseEvent && n.button === 2;
}
const mme = {
  isSelectionSingleChangeEvent: tU,
  isSelectionRangeChangeEvent: iU
};
class nU {
  constructor(e) {
    this.list = e, this.disposables = new dt(), this._onPointer = new q(), this.onPointer = this._onPointer.event, this.multipleSelectionSupport = e.options.multipleSelectionSupport !== !1, this.multipleSelectionSupport && (this.multipleSelectionController = e.options.multipleSelectionController || mme), this.mouseSupport = typeof e.options.mouseSupport > "u" || !!e.options.mouseSupport, this.mouseSupport && (e.onMouseDown(this.onMouseDown, this, this.disposables), e.onContextMenu(this.onContextMenu, this, this.disposables), e.onMouseDblClick(this.onDoubleClick, this, this.disposables), e.onTouchStart(this.onMouseDown, this, this.disposables), this.disposables.add(ri.addTarget(e.getHTMLElement()))), We.any(e.onMouseClick, e.onMouseMiddleClick, e.onTap)(this.onViewPointer, this, this.disposables);
  }
  isSelectionSingleChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionSingleChangeEvent(e) : kt ? e.browserEvent.metaKey : e.browserEvent.ctrlKey;
  }
  isSelectionRangeChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionRangeChangeEvent(e) : e.browserEvent.shiftKey;
  }
  isSelectionChangeEvent(e) {
    return this.isSelectionSingleChangeEvent(e) || this.isSelectionRangeChangeEvent(e);
  }
  onMouseDown(e) {
    hp(e.browserEvent.target) || document.activeElement !== e.browserEvent.target && this.list.domFocus();
  }
  onContextMenu(e) {
    if (hp(e.browserEvent.target))
      return;
    const t = typeof e.index > "u" ? [] : [e.index];
    this.list.setFocus(t, e.browserEvent);
  }
  onViewPointer(e) {
    if (!this.mouseSupport || fh(e.browserEvent.target) || hp(e.browserEvent.target))
      return;
    const t = e.index;
    if (typeof t > "u") {
      this.list.setFocus([], e.browserEvent), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0);
      return;
    }
    if (this.multipleSelectionSupport && this.isSelectionRangeChangeEvent(e))
      return this.changeSelection(e);
    if (this.multipleSelectionSupport && this.isSelectionChangeEvent(e))
      return this.changeSelection(e);
    this.list.setFocus([t], e.browserEvent), this.list.setAnchor(t), gme(e.browserEvent) || this.list.setSelection([t], e.browserEvent), this._onPointer.fire(e);
  }
  onDoubleClick(e) {
    if (fh(e.browserEvent.target) || hp(e.browserEvent.target) || this.multipleSelectionSupport && this.isSelectionChangeEvent(e))
      return;
    const t = this.list.getFocus();
    this.list.setSelection(t, e.browserEvent);
  }
  changeSelection(e) {
    const t = e.index;
    let i = this.list.getAnchor();
    if (this.isSelectionRangeChangeEvent(e)) {
      if (typeof i > "u") {
        const c = this.list.getFocus()[0];
        i = c ?? t, this.list.setAnchor(i);
      }
      const r = Math.min(i, t), o = Math.max(i, t), s = kr(r, o + 1), a = this.list.getSelection(), l = Cme(RO(a, [i]), i);
      if (l.length === 0)
        return;
      const u = RO(s, yme(a, l));
      this.list.setSelection(u, e.browserEvent), this.list.setFocus([t], e.browserEvent);
    } else if (this.isSelectionSingleChangeEvent(e)) {
      const r = this.list.getSelection(), o = r.filter((s) => s !== t);
      this.list.setFocus([t]), this.list.setAnchor(t), r.length === o.length ? this.list.setSelection([...o, t], e.browserEvent) : this.list.setSelection(o, e.browserEvent);
    }
  }
  dispose() {
    this.disposables.dispose();
  }
}
class rU {
  constructor(e, t) {
    this.styleElement = e, this.selectorSuffix = t;
  }
  style(e) {
    const t = this.selectorSuffix && `.${this.selectorSuffix}`, i = [];
    e.listBackground && (e.listBackground.isOpaque() ? i.push(`.monaco-list${t} .monaco-list-rows { background: ${e.listBackground}; }`) : kt || console.warn(`List with id '${this.selectorSuffix}' was styled with a non-opaque background color. This will break sub-pixel antialiasing.`)), e.listFocusBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.focused { background-color: ${e.listFocusBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.focused:hover { background-color: ${e.listFocusBackground}; }`)), e.listFocusForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), e.listActiveSelectionBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.selected { background-color: ${e.listActiveSelectionBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.selected:hover { background-color: ${e.listActiveSelectionBackground}; }`)), e.listActiveSelectionForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected { color: ${e.listActiveSelectionForeground}; }`), e.listFocusAndSelectionBackground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { background-color: ${e.listFocusAndSelectionBackground}; }
			`), e.listFocusAndSelectionForeground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { color: ${e.listFocusAndSelectionForeground}; }
			`), e.listInactiveFocusForeground && (i.push(`.monaco-list${t} .monaco-list-row.focused { color:  ${e.listInactiveFocusForeground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { color:  ${e.listInactiveFocusForeground}; }`)), e.listInactiveFocusBackground && (i.push(`.monaco-list${t} .monaco-list-row.focused { background-color:  ${e.listInactiveFocusBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { background-color:  ${e.listInactiveFocusBackground}; }`)), e.listInactiveSelectionBackground && (i.push(`.monaco-list${t} .monaco-list-row.selected { background-color:  ${e.listInactiveSelectionBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.selected:hover { background-color:  ${e.listInactiveSelectionBackground}; }`)), e.listInactiveSelectionForeground && i.push(`.monaco-list${t} .monaco-list-row.selected { color: ${e.listInactiveSelectionForeground}; }`), e.listHoverBackground && i.push(`.monaco-list${t}:not(.drop-target) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${e.listHoverBackground}; }`), e.listHoverForeground && i.push(`.monaco-list${t} .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${e.listHoverForeground}; }`), e.listSelectionOutline && i.push(`.monaco-list${t} .monaco-list-row.selected { outline: 1px dotted ${e.listSelectionOutline}; outline-offset: -1px; }`), e.listFocusOutline && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
			`), e.listInactiveFocusOutline && i.push(`.monaco-list${t} .monaco-list-row.focused { outline: 1px dotted ${e.listInactiveFocusOutline}; outline-offset: -1px; }`), e.listHoverOutline && i.push(`.monaco-list${t} .monaco-list-row:hover { outline: 1px dashed ${e.listHoverOutline}; outline-offset: -1px; }`), e.listDropBackground && i.push(`
				.monaco-list${t}.drop-target,
				.monaco-list${t} .monaco-list-rows.drop-target,
				.monaco-list${t} .monaco-list-row.drop-target { background-color: ${e.listDropBackground} !important; color: inherit !important; }
			`), e.listFilterWidgetBackground && i.push(`.monaco-list-type-filter { background-color: ${e.listFilterWidgetBackground} }`), e.listFilterWidgetOutline && i.push(`.monaco-list-type-filter { border: 1px solid ${e.listFilterWidgetOutline}; }`), e.listFilterWidgetNoMatchesOutline && i.push(`.monaco-list-type-filter.no-matches { border: 1px solid ${e.listFilterWidgetNoMatchesOutline}; }`), e.listMatchesShadow && i.push(`.monaco-list-type-filter { box-shadow: 1px 1px 1px ${e.listMatchesShadow}; }`), e.tableColumnsBorder && i.push(`
				.monaco-table:hover > .monaco-split-view2,
				.monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${e.tableColumnsBorder};
			}`), this.styleElement.textContent = i.join(`
`);
  }
}
const vme = {
  listFocusBackground: ne.fromHex("#7FB0D0"),
  listActiveSelectionBackground: ne.fromHex("#0E639C"),
  listActiveSelectionForeground: ne.fromHex("#FFFFFF"),
  listFocusAndSelectionBackground: ne.fromHex("#094771"),
  listFocusAndSelectionForeground: ne.fromHex("#FFFFFF"),
  listInactiveSelectionBackground: ne.fromHex("#3F3F46"),
  listHoverBackground: ne.fromHex("#2A2D2E"),
  listDropBackground: ne.fromHex("#383B3D"),
  treeIndentGuidesStroke: ne.fromHex("#a9a9a9"),
  tableColumnsBorder: ne.fromHex("#cccccc").transparent(0.2)
}, _me = {
  keyboardSupport: !0,
  mouseSupport: !0,
  multipleSelectionSupport: !0,
  dnd: {
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    }
  }
};
function Cme(n, e) {
  const t = n.indexOf(e);
  if (t === -1)
    return [];
  const i = [];
  let r = t - 1;
  for (; r >= 0 && n[r] === e - (t - r); )
    i.push(n[r--]);
  for (i.reverse(), r = t; r < n.length && n[r] === e + (r - t); )
    i.push(n[r++]);
  return i;
}
function RO(n, e) {
  const t = [];
  let i = 0, r = 0;
  for (; i < n.length || r < e.length; )
    if (i >= n.length)
      t.push(e[r++]);
    else if (r >= e.length)
      t.push(n[i++]);
    else if (n[i] === e[r]) {
      t.push(n[i]), i++, r++;
      continue;
    } else
      n[i] < e[r] ? t.push(n[i++]) : t.push(e[r++]);
  return t;
}
function yme(n, e) {
  const t = [];
  let i = 0, r = 0;
  for (; i < n.length || r < e.length; )
    if (i >= n.length)
      t.push(e[r++]);
    else if (r >= e.length)
      t.push(n[i++]);
    else if (n[i] === e[r]) {
      i++, r++;
      continue;
    } else
      n[i] < e[r] ? t.push(n[i++]) : r++;
  return t;
}
const GW = (n, e) => n - e;
class wme {
  constructor(e, t) {
    this._templateId = e, this.renderers = t;
  }
  get templateId() {
    return this._templateId;
  }
  renderTemplate(e) {
    return this.renderers.map((t) => t.renderTemplate(e));
  }
  renderElement(e, t, i, r) {
    let o = 0;
    for (const s of this.renderers)
      s.renderElement(e, t, i[o++], r);
  }
  disposeElement(e, t, i, r) {
    let o = 0;
    for (const s of this.renderers)
      s.disposeElement && s.disposeElement(e, t, i[o], r), o += 1;
  }
  disposeTemplate(e) {
    let t = 0;
    for (const i of this.renderers)
      i.disposeTemplate(e[t++]);
  }
}
class bme {
  constructor(e) {
    this.accessibilityProvider = e, this.templateId = "a18n";
  }
  renderTemplate(e) {
    return e;
  }
  renderElement(e, t, i) {
    const r = this.accessibilityProvider.getAriaLabel(e);
    r ? i.setAttribute("aria-label", r) : i.removeAttribute("aria-label");
    const o = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(e);
    typeof o == "number" ? i.setAttribute("aria-level", `${o}`) : i.removeAttribute("aria-level");
  }
  disposeTemplate(e) {
  }
}
class Sme {
  constructor(e, t) {
    this.list = e, this.dnd = t;
  }
  getDragElements(e) {
    const t = this.list.getSelectedElements();
    return t.indexOf(e) > -1 ? t : [e];
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e, t);
  }
  onDragStart(e, t) {
    this.dnd.onDragStart && this.dnd.onDragStart(e, t);
  }
  onDragOver(e, t, i, r) {
    return this.dnd.onDragOver(e, t, i, r);
  }
  onDragEnd(e) {
    this.dnd.onDragEnd && this.dnd.onDragEnd(e);
  }
  drop(e, t, i, r) {
    this.dnd.drop(e, t, i, r);
  }
}
class df {
  constructor(e, t, i, r, o = _me) {
    var s;
    this.user = e, this._options = o, this.focus = new fS("focused"), this.anchor = new fS("anchor"), this.eventBufferer = new ON(), this._ariaLabel = "", this.disposables = new dt(), this._onDidDispose = new q(), this.onDidDispose = this._onDidDispose.event;
    const a = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? (s = this._options.accessibilityProvider) === null || s === void 0 ? void 0 : s.getWidgetRole() : "list";
    this.selection = new hme(a !== "listbox"), vh(o, vme, !1);
    const l = [this.focus.renderer, this.selection.renderer];
    this.accessibilityProvider = o.accessibilityProvider, this.accessibilityProvider && (l.push(new bme(this.accessibilityProvider)), this.accessibilityProvider.onDidChangeActiveDescendant && this.accessibilityProvider.onDidChangeActiveDescendant(this.onDidChangeActiveDescendant, this, this.disposables)), r = r.map((c) => new wme(c.templateId, [...l, c]));
    const u = Object.assign(Object.assign({}, o), { dnd: o.dnd && new Sme(this, o.dnd) });
    if (this.view = new ll(t, i, r, u), this.view.domNode.setAttribute("role", a), o.styleController)
      this.styleController = o.styleController(this.view.domId);
    else {
      const c = As(this.view.domNode);
      this.styleController = new rU(c, this.view.domId);
    }
    if (this.spliceable = new ume([
      new h1(this.focus, this.view, o.identityProvider),
      new h1(this.selection, this.view, o.identityProvider),
      new h1(this.anchor, this.view, o.identityProvider),
      this.view
    ]), this.disposables.add(this.focus), this.disposables.add(this.selection), this.disposables.add(this.anchor), this.disposables.add(this.view), this.disposables.add(this._onDidDispose), this.onDidFocus = We.map(wt(this.view.domNode, "focus", !0), () => null), this.onDidBlur = We.map(wt(this.view.domNode, "blur", !0), () => null), this.disposables.add(new pme(this, this.view)), typeof o.keyboardSupport != "boolean" || o.keyboardSupport) {
      const c = new dme(this, this.view, o);
      this.disposables.add(c);
    }
    if (o.keyboardNavigationLabelProvider) {
      const c = o.keyboardNavigationDelegate || eU;
      this.typeLabelController = new fme(this, this.view, o.keyboardNavigationLabelProvider, c), this.disposables.add(this.typeLabelController);
    }
    this.mouseController = this.createMouseController(o), this.disposables.add(this.mouseController), this.onDidChangeFocus(this._onFocusChange, this, this.disposables), this.onDidChangeSelection(this._onSelectionChange, this, this.disposables), this.accessibilityProvider && (this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel()), o.multipleSelectionSupport && this.view.domNode.setAttribute("aria-multiselectable", "true");
  }
  get onDidChangeFocus() {
    return We.map(this.eventBufferer.wrapEvent(this.focus.onChange), (e) => this.toListEvent(e));
  }
  get onDidChangeSelection() {
    return We.map(this.eventBufferer.wrapEvent(this.selection.onChange), (e) => this.toListEvent(e));
  }
  get domId() {
    return this.view.domId;
  }
  get onMouseClick() {
    return this.view.onMouseClick;
  }
  get onMouseDblClick() {
    return this.view.onMouseDblClick;
  }
  get onMouseMiddleClick() {
    return this.view.onMouseMiddleClick;
  }
  get onPointer() {
    return this.mouseController.onPointer;
  }
  get onMouseDown() {
    return this.view.onMouseDown;
  }
  get onTouchStart() {
    return this.view.onTouchStart;
  }
  get onTap() {
    return this.view.onTap;
  }
  /**
   * Possible context menu trigger events:
   * - ContextMenu key
   * - Shift F10
   * - Ctrl Option Shift M (macOS with VoiceOver)
   * - Mouse right click
   */
  get onContextMenu() {
    let e = !1;
    const t = We.chain(wt(this.view.domNode, "keydown")).map((o) => new Yi(o)).filter((o) => e = o.keyCode === 58 || o.shiftKey && o.keyCode === 68).map(lT).filter(() => !1).event, i = We.chain(wt(this.view.domNode, "keyup")).forEach(() => e = !1).map((o) => new Yi(o)).filter((o) => o.keyCode === 58 || o.shiftKey && o.keyCode === 68).map(lT).map(({ browserEvent: o }) => {
      const s = this.getFocus(), a = s.length ? s[0] : void 0, l = typeof a < "u" ? this.view.element(a) : void 0, u = typeof a < "u" ? this.view.domElement(a) : this.view.domNode;
      return { index: a, element: l, anchor: u, browserEvent: o };
    }).event, r = We.chain(this.view.onContextMenu).filter((o) => !e).map(({ element: o, index: s, browserEvent: a }) => ({ element: o, index: s, anchor: { x: a.pageX + 1, y: a.pageY }, browserEvent: a })).event;
    return We.any(t, i, r);
  }
  get onKeyDown() {
    return wt(this.view.domNode, "keydown");
  }
  createMouseController(e) {
    return new nU(this);
  }
  updateOptions(e = {}) {
    this._options = Object.assign(Object.assign({}, this._options), e), this.typeLabelController && this.typeLabelController.updateOptions(this._options), this.view.updateOptions(e);
  }
  get options() {
    return this._options;
  }
  splice(e, t, i = []) {
    if (e < 0 || e > this.view.length)
      throw new jh(this.user, `Invalid start index: ${e}`);
    if (t < 0)
      throw new jh(this.user, `Invalid delete count: ${t}`);
    t === 0 && i.length === 0 || this.eventBufferer.bufferEvents(() => this.spliceable.splice(e, t, i));
  }
  rerender() {
    this.view.rerender();
  }
  element(e) {
    return this.view.element(e);
  }
  get length() {
    return this.view.length;
  }
  get contentHeight() {
    return this.view.contentHeight;
  }
  get scrollTop() {
    return this.view.getScrollTop();
  }
  set scrollTop(e) {
    this.view.setScrollTop(e);
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.view.domNode.setAttribute("aria-label", e);
  }
  domFocus() {
    this.view.domNode.focus({ preventScroll: !0 });
  }
  layout(e, t) {
    this.view.layout(e, t);
  }
  setSelection(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new jh(this.user, `Invalid index ${i}`);
    this.selection.set(e, t);
  }
  getSelection() {
    return this.selection.get();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.view.element(e));
  }
  setAnchor(e) {
    if (typeof e > "u") {
      this.anchor.set([]);
      return;
    }
    if (e < 0 || e >= this.length)
      throw new jh(this.user, `Invalid index ${e}`);
    this.anchor.set([e]);
  }
  getAnchor() {
    return BT(this.anchor.get(), void 0);
  }
  setFocus(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new jh(this.user, `Invalid index ${i}`);
    this.focus.set(e, t);
  }
  focusNext(e = 1, t = !1, i, r) {
    if (this.length === 0)
      return;
    const o = this.focus.get(), s = this.findNextIndex(o.length > 0 ? o[0] + e : 0, t, r);
    s > -1 && this.setFocus([s], i);
  }
  focusPrevious(e = 1, t = !1, i, r) {
    if (this.length === 0)
      return;
    const o = this.focus.get(), s = this.findPreviousIndex(o.length > 0 ? o[0] - e : 0, t, r);
    s > -1 && this.setFocus([s], i);
  }
  focusNextPage(e, t) {
    return HW(this, void 0, void 0, function* () {
      let i = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
      i = i === 0 ? 0 : i - 1;
      const r = this.view.element(i), o = this.getFocusedElements()[0];
      if (o !== r) {
        const s = this.findPreviousIndex(i, !1, t);
        s > -1 && o !== this.view.element(s) ? this.setFocus([s], e) : this.setFocus([i], e);
      } else {
        const s = this.view.getScrollTop();
        this.view.setScrollTop(s + this.view.renderHeight - this.view.elementHeight(i)), this.view.getScrollTop() !== s && (this.setFocus([]), yield $v(0), yield this.focusNextPage(e, t));
      }
    });
  }
  focusPreviousPage(e, t) {
    return HW(this, void 0, void 0, function* () {
      let i;
      const r = this.view.getScrollTop();
      r === 0 ? i = this.view.indexAt(r) : i = this.view.indexAfter(r - 1);
      const o = this.view.element(i), s = this.getFocusedElements()[0];
      if (s !== o) {
        const a = this.findNextIndex(i, !1, t);
        a > -1 && s !== this.view.element(a) ? this.setFocus([a], e) : this.setFocus([i], e);
      } else {
        const a = r;
        this.view.setScrollTop(r - this.view.renderHeight), this.view.getScrollTop() !== a && (this.setFocus([]), yield $v(0), yield this.focusPreviousPage(e, t));
      }
    });
  }
  focusLast(e, t) {
    if (this.length === 0)
      return;
    const i = this.findPreviousIndex(this.length - 1, !1, t);
    i > -1 && this.setFocus([i], e);
  }
  focusFirst(e, t) {
    this.focusNth(0, e, t);
  }
  focusNth(e, t, i) {
    if (this.length === 0)
      return;
    const r = this.findNextIndex(e, !1, i);
    r > -1 && this.setFocus([r], t);
  }
  findNextIndex(e, t = !1, i) {
    for (let r = 0; r < this.length; r++) {
      if (e >= this.length && !t)
        return -1;
      if (e = e % this.length, !i || i(this.element(e)))
        return e;
      e++;
    }
    return -1;
  }
  findPreviousIndex(e, t = !1, i) {
    for (let r = 0; r < this.length; r++) {
      if (e < 0 && !t)
        return -1;
      if (e = (this.length + e % this.length) % this.length, !i || i(this.element(e)))
        return e;
      e--;
    }
    return -1;
  }
  getFocus() {
    return this.focus.get();
  }
  getFocusedElements() {
    return this.getFocus().map((e) => this.view.element(e));
  }
  reveal(e, t) {
    if (e < 0 || e >= this.length)
      throw new jh(this.user, `Invalid index ${e}`);
    const i = this.view.getScrollTop(), r = this.view.elementTop(e), o = this.view.elementHeight(e);
    if (j_(t)) {
      const s = o - this.view.renderHeight;
      this.view.setScrollTop(s * Fa(t, 0, 1) + r);
    } else {
      const s = r + o, a = i + this.view.renderHeight;
      r < i && s >= a || (r < i || s >= a && o >= this.view.renderHeight ? this.view.setScrollTop(r) : s >= a && this.view.setScrollTop(s - this.view.renderHeight));
    }
  }
  /**
   * Returns the relative position of an element rendered in the list.
   * Returns `null` if the element isn't *entirely* in the visible viewport.
   */
  getRelativeTop(e) {
    if (e < 0 || e >= this.length)
      throw new jh(this.user, `Invalid index ${e}`);
    const t = this.view.getScrollTop(), i = this.view.elementTop(e), r = this.view.elementHeight(e);
    if (i < t || i + r > t + this.view.renderHeight)
      return null;
    const o = r - this.view.renderHeight;
    return Math.abs((t - i) / o);
  }
  getHTMLElement() {
    return this.view.domNode;
  }
  style(e) {
    this.styleController.style(e);
  }
  toListEvent({ indexes: e, browserEvent: t }) {
    return { indexes: e, elements: e.map((i) => this.view.element(i)), browserEvent: t };
  }
  _onFocusChange() {
    const e = this.focus.get();
    this.view.domNode.classList.toggle("element-focused", e.length > 0), this.onDidChangeActiveDescendant();
  }
  onDidChangeActiveDescendant() {
    var e;
    const t = this.focus.get();
    if (t.length > 0) {
      let i;
      !((e = this.accessibilityProvider) === null || e === void 0) && e.getActiveDescendantId && (i = this.accessibilityProvider.getActiveDescendantId(this.view.element(t[0]))), this.view.domNode.setAttribute("aria-activedescendant", i || this.view.getElementDomId(t[0]));
    } else
      this.view.domNode.removeAttribute("aria-activedescendant");
  }
  _onSelectionChange() {
    const e = this.selection.get();
    this.view.domNode.classList.toggle("selection-none", e.length === 0), this.view.domNode.classList.toggle("selection-single", e.length === 1), this.view.domNode.classList.toggle("selection-multiple", e.length > 1);
  }
  dispose() {
    this._onDidDispose.fire(), this.disposables.dispose(), this._onDidDispose.dispose();
  }
}
UE([
  Bn
], df.prototype, "onDidChangeFocus", null);
UE([
  Bn
], df.prototype, "onDidChangeSelection", null);
UE([
  Bn
], df.prototype, "onContextMenu", null);
class Eme {
  constructor(e, t) {
    this.renderer = e, this.modelProvider = t;
  }
  get templateId() {
    return this.renderer.templateId;
  }
  renderTemplate(e) {
    return { data: this.renderer.renderTemplate(e), disposable: Ce.None };
  }
  renderElement(e, t, i, r) {
    if (i.disposable && i.disposable.dispose(), !i.data)
      return;
    const o = this.modelProvider();
    if (o.isResolved(e))
      return this.renderer.renderElement(o.get(e), e, i.data, r);
    const s = new mh(), a = o.resolve(e, s.token);
    i.disposable = { dispose: () => s.cancel() }, this.renderer.renderPlaceholder(e, i.data), a.then((l) => this.renderer.renderElement(l, e, i.data, r));
  }
  disposeTemplate(e) {
    e.disposable && (e.disposable.dispose(), e.disposable = void 0), e.data && (this.renderer.disposeTemplate(e.data), e.data = void 0);
  }
}
class Lme {
  constructor(e, t) {
    this.modelProvider = e, this.accessibilityProvider = t;
  }
  getWidgetAriaLabel() {
    return this.accessibilityProvider.getWidgetAriaLabel();
  }
  getAriaLabel(e) {
    const t = this.modelProvider();
    return t.isResolved(e) ? this.accessibilityProvider.getAriaLabel(t.get(e)) : null;
  }
}
function Dme(n, e) {
  return Object.assign(Object.assign({}, e), { accessibilityProvider: e.accessibilityProvider && new Lme(n, e.accessibilityProvider) });
}
class Rme {
  constructor(e, t, i, r, o = {}) {
    const s = () => this.model, a = r.map((l) => new Eme(l, s));
    this.list = new df(e, t, i, a, Dme(s, o));
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  getHTMLElement() {
    return this.list.getHTMLElement();
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  get onMouseDblClick() {
    return We.map(this.list.onMouseDblClick, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onPointer() {
    return We.map(this.list.onPointer, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onDidChangeSelection() {
    return We.map(this.list.onDidChangeSelection, ({ elements: e, indexes: t, browserEvent: i }) => ({ elements: e.map((r) => this._model.get(r)), indexes: t, browserEvent: i }));
  }
  get model() {
    return this._model;
  }
  set model(e) {
    this._model = e, this.list.splice(0, this.list.length, kr(e.length));
  }
  getFocus() {
    return this.list.getFocus();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.model.get(e));
  }
  style(e) {
    this.list.style(e);
  }
  dispose() {
    this.list.dispose();
  }
}
const ibe = new nt("isWindows", Ro, b("isWindows", "Whether the operating system is Windows")), Tme = "inputFocus";
var Nv;
(function(n) {
  n[n.Unknown = 0] = "Unknown", n[n.Twistie = 1] = "Twistie", n[n.Element = 2] = "Element";
})(Nv || (Nv = {}));
class ys extends Error {
  constructor(e, t) {
    super(`TreeError [${e}] ${t}`);
  }
}
class ZI {
  constructor(e) {
    this.fn = e, this._map = /* @__PURE__ */ new WeakMap();
  }
  map(e) {
    let t = this._map.get(e);
    return t || (t = this.fn(e), this._map.set(e, t)), t;
  }
}
function QI(n) {
  return typeof n == "object" && "visibility" in n && "data" in n;
}
function m_(n) {
  switch (n) {
    case !0:
      return 1;
    case !1:
      return 0;
    default:
      return n;
  }
}
function d1(n) {
  return typeof n.collapsible == "boolean";
}
class Ome {
  constructor(e, t, i, r = {}) {
    this.user = e, this.list = t, this.rootRef = [], this.eventBufferer = new ON(), this._onDidChangeCollapseState = new q(), this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event), this._onDidChangeRenderNodeCount = new q(), this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event), this._onDidSplice = new q(), this.onDidSplice = this._onDidSplice.event, this.collapseByDefault = typeof r.collapseByDefault > "u" ? !1 : r.collapseByDefault, this.filter = r.filter, this.autoExpandSingleChildren = typeof r.autoExpandSingleChildren > "u" ? !1 : r.autoExpandSingleChildren, this.root = {
      parent: void 0,
      element: i,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: !1,
      collapsed: !1,
      renderNodeCount: 0,
      visibility: 1,
      visible: !0,
      filterData: void 0
    };
  }
  splice(e, t, i = Ct.empty(), r = {}) {
    if (e.length === 0)
      throw new ys(this.user, "Invalid tree location");
    r.diffIdentityProvider ? this.spliceSmart(r.diffIdentityProvider, e, t, i, r) : this.spliceSimple(e, t, i, r);
  }
  spliceSmart(e, t, i, r, o, s) {
    var a;
    r === void 0 && (r = Ct.empty()), s === void 0 && (s = (a = o.diffDepth) !== null && a !== void 0 ? a : 0);
    const { parentNode: l } = this.getParentNodeWithListIndex(t), u = [...r], c = t[t.length - 1], h = new bd({ getElements: () => l.children.map((_) => e.getId(_.element).toString()) }, {
      getElements: () => [
        ...l.children.slice(0, c),
        ...u,
        ...l.children.slice(c + i)
      ].map((_) => e.getId(_.element).toString())
    }).ComputeDiff(!1);
    if (h.quitEarly)
      return this.spliceSimple(t, i, u, o);
    const d = t.slice(0, -1), f = (_, m, v) => {
      if (s > 0)
        for (let C = 0; C < v; C++)
          _--, m--, this.spliceSmart(e, [...d, _, 0], Number.MAX_SAFE_INTEGER, u[m].children, o, s - 1);
    };
    let p = Math.min(l.children.length, c + i), g = u.length;
    for (const _ of h.changes.sort((m, v) => v.originalStart - m.originalStart))
      f(p, g, p - (_.originalStart + _.originalLength)), p = _.originalStart, g = _.modifiedStart - c, this.spliceSimple([...d, p], _.originalLength, Ct.slice(u, g, g + _.modifiedLength), o);
    f(p, g, p);
  }
  spliceSimple(e, t, i = Ct.empty(), { onDidCreateNode: r, onDidDeleteNode: o }) {
    const { parentNode: s, listIndex: a, revealed: l, visible: u } = this.getParentNodeWithListIndex(e), c = [], h = Ct.map(i, (L) => this.createTreeNode(L, s, s.visible ? 1 : 0, l, c, r)), d = e[e.length - 1], f = s.children.length > 0;
    let p = 0;
    for (let L = d; L >= 0 && L < s.children.length; L--) {
      const S = s.children[L];
      if (S.visible) {
        p = S.visibleChildIndex;
        break;
      }
    }
    const g = [];
    let _ = 0, m = 0;
    for (const L of h)
      g.push(L), m += L.renderNodeCount, L.visible && (L.visibleChildIndex = p + _++);
    const v = s.children.splice(d, t, ...g);
    let C = 0;
    for (const L of v)
      L.visible && C++;
    if (C !== 0)
      for (let L = d + g.length; L < s.children.length; L++) {
        const S = s.children[L];
        S.visible && (S.visibleChildIndex -= C);
      }
    if (s.visibleChildrenCount += _ - C, l && u) {
      const L = v.reduce((S, E) => S + (E.visible ? E.renderNodeCount : 0), 0);
      this._updateAncestorsRenderNodeCount(s, m - L), this.list.splice(a, L, c);
    }
    if (v.length > 0 && o) {
      const L = (S) => {
        o(S), S.children.forEach(L);
      };
      v.forEach(L);
    }
    const y = s.children.length > 0;
    f !== y && this.setCollapsible(e.slice(0, -1), y), this._onDidSplice.fire({ insertedNodes: g, deletedNodes: v });
    let w = s;
    for (; w; ) {
      if (w.visibility === 2) {
        this.refilter();
        break;
      }
      w = w.parent;
    }
  }
  rerender(e) {
    if (e.length === 0)
      throw new ys(this.user, "Invalid tree location");
    const { node: t, listIndex: i, revealed: r } = this.getTreeNodeWithListIndex(e);
    t.visible && r && this.list.splice(i, 1, [t]);
  }
  has(e) {
    return this.hasTreeNode(e);
  }
  getListIndex(e) {
    const { listIndex: t, visible: i, revealed: r } = this.getTreeNodeWithListIndex(e);
    return i && r ? t : -1;
  }
  getListRenderCount(e) {
    return this.getTreeNode(e).renderNodeCount;
  }
  isCollapsible(e) {
    return this.getTreeNode(e).collapsible;
  }
  setCollapsible(e, t) {
    const i = this.getTreeNode(e);
    typeof t > "u" && (t = !i.collapsible);
    const r = { collapsible: t };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, r));
  }
  isCollapsed(e) {
    return this.getTreeNode(e).collapsed;
  }
  setCollapsed(e, t, i) {
    const r = this.getTreeNode(e);
    typeof t > "u" && (t = !r.collapsed);
    const o = { collapsed: t, recursive: i || !1 };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, o));
  }
  _setCollapseState(e, t) {
    const { node: i, listIndex: r, revealed: o } = this.getTreeNodeWithListIndex(e), s = this._setListNodeCollapseState(i, r, o, t);
    if (i !== this.root && this.autoExpandSingleChildren && s && !d1(t) && i.collapsible && !i.collapsed && !t.recursive) {
      let a = -1;
      for (let l = 0; l < i.children.length; l++)
        if (i.children[l].visible)
          if (a > -1) {
            a = -1;
            break;
          } else
            a = l;
      a > -1 && this._setCollapseState([...e, a], t);
    }
    return s;
  }
  _setListNodeCollapseState(e, t, i, r) {
    const o = this._setNodeCollapseState(e, r, !1);
    if (!i || !e.visible || !o)
      return o;
    const s = e.renderNodeCount, a = this.updateNodeAfterCollapseChange(e), l = s - (t === -1 ? 0 : 1);
    return this.list.splice(t + 1, l, a.slice(1)), o;
  }
  _setNodeCollapseState(e, t, i) {
    let r;
    if (e === this.root ? r = !1 : (d1(t) ? (r = e.collapsible !== t.collapsible, e.collapsible = t.collapsible) : e.collapsible ? (r = e.collapsed !== t.collapsed, e.collapsed = t.collapsed) : r = !1, r && this._onDidChangeCollapseState.fire({ node: e, deep: i })), !d1(t) && t.recursive)
      for (const o of e.children)
        r = this._setNodeCollapseState(o, t, !0) || r;
    return r;
  }
  expandTo(e) {
    this.eventBufferer.bufferEvents(() => {
      let t = this.getTreeNode(e);
      for (; t.parent; )
        t = t.parent, e = e.slice(0, e.length - 1), t.collapsed && this._setCollapseState(e, { collapsed: !1, recursive: !1 });
    });
  }
  refilter() {
    const e = this.root.renderNodeCount, t = this.updateNodeAfterFilterChange(this.root);
    this.list.splice(0, e, t);
  }
  createTreeNode(e, t, i, r, o, s) {
    const a = {
      parent: t,
      element: e.element,
      children: [],
      depth: t.depth + 1,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: typeof e.collapsible == "boolean" ? e.collapsible : typeof e.collapsed < "u",
      collapsed: typeof e.collapsed > "u" ? this.collapseByDefault : e.collapsed,
      renderNodeCount: 1,
      visibility: 1,
      visible: !0,
      filterData: void 0
    }, l = this._filterNode(a, i);
    a.visibility = l, r && o.push(a);
    const u = e.children || Ct.empty(), c = r && l !== 0 && !a.collapsed, h = Ct.map(u, (p) => this.createTreeNode(p, a, l, c, o, s));
    let d = 0, f = 1;
    for (const p of h)
      a.children.push(p), f += p.renderNodeCount, p.visible && (p.visibleChildIndex = d++);
    return a.collapsible = a.collapsible || a.children.length > 0, a.visibleChildrenCount = d, a.visible = l === 2 ? d > 0 : l === 1, a.visible ? a.collapsed || (a.renderNodeCount = f) : (a.renderNodeCount = 0, r && o.pop()), s && s(a), a;
  }
  updateNodeAfterCollapseChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterCollapseChange(e, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterCollapseChange(e, t) {
    if (e.visible === !1)
      return 0;
    if (t.push(e), e.renderNodeCount = 1, !e.collapsed)
      for (const i of e.children)
        e.renderNodeCount += this._updateNodeAfterCollapseChange(i, t);
    return this._onDidChangeRenderNodeCount.fire(e), e.renderNodeCount;
  }
  updateNodeAfterFilterChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterFilterChange(e, e.visible ? 1 : 0, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterFilterChange(e, t, i, r = !0) {
    let o;
    if (e !== this.root) {
      if (o = this._filterNode(e, t), o === 0)
        return e.visible = !1, e.renderNodeCount = 0, !1;
      r && i.push(e);
    }
    const s = i.length;
    e.renderNodeCount = e === this.root ? 0 : 1;
    let a = !1;
    if (!e.collapsed || o !== 0) {
      let l = 0;
      for (const u of e.children)
        a = this._updateNodeAfterFilterChange(u, o, i, r && !e.collapsed) || a, u.visible && (u.visibleChildIndex = l++);
      e.visibleChildrenCount = l;
    } else
      e.visibleChildrenCount = 0;
    return e !== this.root && (e.visible = o === 2 ? a : o === 1), e.visible ? e.collapsed || (e.renderNodeCount += i.length - s) : (e.renderNodeCount = 0, r && i.pop()), this._onDidChangeRenderNodeCount.fire(e), e.visible;
  }
  _updateAncestorsRenderNodeCount(e, t) {
    if (t !== 0)
      for (; e; )
        e.renderNodeCount += t, this._onDidChangeRenderNodeCount.fire(e), e = e.parent;
  }
  _filterNode(e, t) {
    const i = this.filter ? this.filter.filter(e.element, t) : 1;
    return typeof i == "boolean" ? (e.filterData = void 0, i ? 1 : 0) : QI(i) ? (e.filterData = i.data, m_(i.visibility)) : (e.filterData = void 0, m_(i));
  }
  // cheap
  hasTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return !0;
    const [i, ...r] = e;
    return i < 0 || i > t.children.length ? !1 : this.hasTreeNode(r, t.children[i]);
  }
  // cheap
  getTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return t;
    const [i, ...r] = e;
    if (i < 0 || i > t.children.length)
      throw new ys(this.user, "Invalid tree location");
    return this.getTreeNode(r, t.children[i]);
  }
  // expensive
  getTreeNodeWithListIndex(e) {
    if (e.length === 0)
      return { node: this.root, listIndex: -1, revealed: !0, visible: !1 };
    const { parentNode: t, listIndex: i, revealed: r, visible: o } = this.getParentNodeWithListIndex(e), s = e[e.length - 1];
    if (s < 0 || s > t.children.length)
      throw new ys(this.user, "Invalid tree location");
    const a = t.children[s];
    return { node: a, listIndex: i, revealed: r, visible: o && a.visible };
  }
  getParentNodeWithListIndex(e, t = this.root, i = 0, r = !0, o = !0) {
    const [s, ...a] = e;
    if (s < 0 || s > t.children.length)
      throw new ys(this.user, "Invalid tree location");
    for (let l = 0; l < s; l++)
      i += t.children[l].renderNodeCount;
    return r = r && !t.collapsed, o = o && t.visible, a.length === 0 ? { parentNode: t, listIndex: i, revealed: r, visible: o } : this.getParentNodeWithListIndex(a, t.children[s], i + 1, r, o);
  }
  getNode(e = []) {
    return this.getTreeNode(e);
  }
  // TODO@joao perf!
  getNodeLocation(e) {
    const t = [];
    let i = e;
    for (; i.parent; )
      t.push(i.parent.children.indexOf(i)), i = i.parent;
    return t.reverse();
  }
  getParentNodeLocation(e) {
    if (e.length !== 0)
      return e.length === 1 ? [] : nae(e)[0];
  }
}
const UW = ya("tree-item-expanded", Hi.chevronDown), zW = ya("tree-filter-on-type-on", Hi.listFilter), jW = ya("tree-filter-on-type-off", Hi.listSelection), xme = ya("tree-filter-clear", Hi.close), pS = ya("tree-item-loading", Hi.loading);
class Nme extends eC {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function f1(n) {
  return n instanceof eC ? new Nme(n) : n;
}
class Ime {
  constructor(e, t) {
    this.modelProvider = e, this.dnd = t, this.autoExpandDisposable = Ce.None;
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    this.dnd.onDragStart && this.dnd.onDragStart(f1(e), t);
  }
  onDragOver(e, t, i, r, o = !0) {
    const s = this.dnd.onDragOver(f1(e), t && t.element, i, r), a = this.autoExpandNode !== t;
    if (a && (this.autoExpandDisposable.dispose(), this.autoExpandNode = t), typeof t > "u")
      return s;
    if (a && typeof s != "boolean" && s.autoExpand && (this.autoExpandDisposable = hT(() => {
      const d = this.modelProvider(), f = d.getNodeLocation(t);
      d.isCollapsed(f) && d.setCollapsed(f, !1), this.autoExpandNode = void 0;
    }, 500)), typeof s == "boolean" || !s.accept || typeof s.bubble > "u" || s.feedback) {
      if (!o) {
        const d = typeof s == "boolean" ? s : s.accept, f = typeof s == "boolean" ? void 0 : s.effect;
        return { accept: d, effect: f, feedback: [i] };
      }
      return s;
    }
    if (s.bubble === 1) {
      const d = this.modelProvider(), f = d.getNodeLocation(t), p = d.getParentNodeLocation(f), g = d.getNode(p), _ = p && d.getListIndex(p);
      return this.onDragOver(e, g, _, r, !1);
    }
    const l = this.modelProvider(), u = l.getNodeLocation(t), c = l.getListIndex(u), h = l.getListRenderCount(u);
    return Object.assign(Object.assign({}, s), { feedback: kr(c, c + h) });
  }
  drop(e, t, i, r) {
    this.autoExpandDisposable.dispose(), this.autoExpandNode = void 0, this.dnd.drop(f1(e), t && t.element, i, r);
  }
  onDragEnd(e) {
    this.dnd.onDragEnd && this.dnd.onDragEnd(e);
  }
}
function Pme(n, e) {
  return e && Object.assign(Object.assign({}, e), { identityProvider: e.identityProvider && {
    getId(t) {
      return e.identityProvider.getId(t.element);
    }
  }, dnd: e.dnd && new Ime(n, e.dnd), multipleSelectionController: e.multipleSelectionController && {
    isSelectionSingleChangeEvent(t) {
      return e.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, t), { element: t.element }));
    },
    isSelectionRangeChangeEvent(t) {
      return e.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, t), { element: t.element }));
    }
  }, accessibilityProvider: e.accessibilityProvider && Object.assign(Object.assign({}, e.accessibilityProvider), {
    getSetSize(t) {
      const i = n(), r = i.getNodeLocation(t), o = i.getParentNodeLocation(r);
      return i.getNode(o).visibleChildrenCount;
    },
    getPosInSet(t) {
      return t.visibleChildIndex + 1;
    },
    isChecked: e.accessibilityProvider && e.accessibilityProvider.isChecked ? (t) => e.accessibilityProvider.isChecked(t.element) : void 0,
    getRole: e.accessibilityProvider && e.accessibilityProvider.getRole ? (t) => e.accessibilityProvider.getRole(t.element) : () => "treeitem",
    getAriaLabel(t) {
      return e.accessibilityProvider.getAriaLabel(t.element);
    },
    getWidgetAriaLabel() {
      return e.accessibilityProvider.getWidgetAriaLabel();
    },
    getWidgetRole: e.accessibilityProvider && e.accessibilityProvider.getWidgetRole ? () => e.accessibilityProvider.getWidgetRole() : () => "tree",
    getAriaLevel: e.accessibilityProvider && e.accessibilityProvider.getAriaLevel ? (t) => e.accessibilityProvider.getAriaLevel(t.element) : (t) => t.depth,
    getActiveDescendantId: e.accessibilityProvider.getActiveDescendantId && ((t) => e.accessibilityProvider.getActiveDescendantId(t.element))
  }), keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, e.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(t) {
    return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t.element);
  } }), enableKeyboardNavigation: e.simpleKeyboardNavigation });
}
class JI {
  constructor(e) {
    this.delegate = e;
  }
  getHeight(e) {
    return this.delegate.getHeight(e.element);
  }
  getTemplateId(e) {
    return this.delegate.getTemplateId(e.element);
  }
  hasDynamicHeight(e) {
    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(e.element);
  }
  setDynamicHeight(e, t) {
    this.delegate.setDynamicHeight && this.delegate.setDynamicHeight(e.element, t);
  }
}
var v_;
(function(n) {
  n.None = "none", n.OnHover = "onHover", n.Always = "always";
})(v_ || (v_ = {}));
class Ame {
  constructor(e, t = []) {
    this._elements = t, this.onDidChange = We.forEach(e, (i) => this._elements = i);
  }
  get elements() {
    return this._elements;
  }
}
class __ {
  constructor(e, t, i, r, o = {}) {
    this.renderer = e, this.modelProvider = t, this.activeNodes = r, this.renderedElements = /* @__PURE__ */ new Map(), this.renderedNodes = /* @__PURE__ */ new Map(), this.indent = __.DefaultIndent, this.hideTwistiesOfChildlessElements = !1, this.shouldRenderIndentGuides = !1, this.renderedIndentGuides = new Jae(), this.activeIndentNodes = /* @__PURE__ */ new Set(), this.indentGuidesDisposable = Ce.None, this.disposables = new dt(), this.templateId = e.templateId, this.updateOptions(o), We.map(i, (s) => s.node)(this.onDidChangeNodeTwistieState, this, this.disposables), e.onDidChangeTwistieState && e.onDidChangeTwistieState(this.onDidChangeTwistieState, this, this.disposables);
  }
  updateOptions(e = {}) {
    if (typeof e.indent < "u" && (this.indent = Fa(e.indent, 0, 40)), typeof e.renderIndentGuides < "u") {
      const t = e.renderIndentGuides !== v_.None;
      if (t !== this.shouldRenderIndentGuides && (this.shouldRenderIndentGuides = t, this.indentGuidesDisposable.dispose(), t)) {
        const i = new dt();
        this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, i), this.indentGuidesDisposable = i, this._onDidChangeActiveNodes(this.activeNodes.elements);
      }
    }
    typeof e.hideTwistiesOfChildlessElements < "u" && (this.hideTwistiesOfChildlessElements = e.hideTwistiesOfChildlessElements);
  }
  renderTemplate(e) {
    const t = Me(e, Xe(".monaco-tl-row")), i = Me(t, Xe(".monaco-tl-indent")), r = Me(t, Xe(".monaco-tl-twistie")), o = Me(t, Xe(".monaco-tl-contents")), s = this.renderer.renderTemplate(o);
    return { container: e, indent: i, twistie: r, indentGuidesDisposable: Ce.None, templateData: s };
  }
  renderElement(e, t, i, r) {
    typeof r == "number" && (this.renderedNodes.set(e, { templateData: i, height: r }), this.renderedElements.set(e.element, e));
    const o = __.DefaultIndent + (e.depth - 1) * this.indent;
    i.twistie.style.paddingLeft = `${o}px`, i.indent.style.width = `${o + this.indent - 16}px`, this.renderTwistie(e, i), typeof r == "number" && this.renderIndentGuides(e, i), this.renderer.renderElement(e, t, i.templateData, r);
  }
  disposeElement(e, t, i, r) {
    i.indentGuidesDisposable.dispose(), this.renderer.disposeElement && this.renderer.disposeElement(e, t, i.templateData, r), typeof r == "number" && (this.renderedNodes.delete(e), this.renderedElements.delete(e.element));
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  onDidChangeTwistieState(e) {
    const t = this.renderedElements.get(e);
    t && this.onDidChangeNodeTwistieState(t);
  }
  onDidChangeNodeTwistieState(e) {
    const t = this.renderedNodes.get(e);
    t && (this.renderTwistie(e, t.templateData), this._onDidChangeActiveNodes(this.activeNodes.elements), this.renderIndentGuides(e, t.templateData));
  }
  renderTwistie(e, t) {
    t.twistie.classList.remove(...UW.classNamesArray);
    let i = !1;
    this.renderer.renderTwistie && (i = this.renderer.renderTwistie(e.element, t.twistie)), e.collapsible && (!this.hideTwistiesOfChildlessElements || e.visibleChildrenCount > 0) ? (i || t.twistie.classList.add(...UW.classNamesArray), t.twistie.classList.add("collapsible"), t.twistie.classList.toggle("collapsed", e.collapsed)) : t.twistie.classList.remove("collapsible", "collapsed"), e.collapsible ? t.container.setAttribute("aria-expanded", String(!e.collapsed)) : t.container.removeAttribute("aria-expanded");
  }
  renderIndentGuides(e, t) {
    if (Ps(t.indent), t.indentGuidesDisposable.dispose(), !this.shouldRenderIndentGuides)
      return;
    const i = new dt(), r = this.modelProvider();
    let o = e;
    for (; ; ) {
      const s = r.getNodeLocation(o), a = r.getParentNodeLocation(s);
      if (!a)
        break;
      const l = r.getNode(a), u = Xe(".indent-guide", { style: `width: ${this.indent}px` });
      this.activeIndentNodes.has(l) && u.classList.add("active"), t.indent.childElementCount === 0 ? t.indent.appendChild(u) : t.indent.insertBefore(u, t.indent.firstElementChild), this.renderedIndentGuides.add(l, u), i.add(Oi(() => this.renderedIndentGuides.delete(l, u))), o = l;
    }
    t.indentGuidesDisposable = i;
  }
  _onDidChangeActiveNodes(e) {
    if (!this.shouldRenderIndentGuides)
      return;
    const t = /* @__PURE__ */ new Set(), i = this.modelProvider();
    e.forEach((r) => {
      const o = i.getNodeLocation(r);
      try {
        const s = i.getParentNodeLocation(o);
        r.collapsible && r.children.length > 0 && !r.collapsed ? t.add(r) : s && t.add(i.getNode(s));
      } catch {
      }
    }), this.activeIndentNodes.forEach((r) => {
      t.has(r) || this.renderedIndentGuides.forEach(r, (o) => o.classList.remove("active"));
    }), t.forEach((r) => {
      this.activeIndentNodes.has(r) || this.renderedIndentGuides.forEach(r, (o) => o.classList.add("active"));
    }), this.activeIndentNodes = t;
  }
  dispose() {
    this.renderedNodes.clear(), this.renderedElements.clear(), this.indentGuidesDisposable.dispose(), bi(this.disposables);
  }
}
__.DefaultIndent = 8;
class Mme {
  constructor(e, t, i) {
    this.tree = e, this.keyboardNavigationLabelProvider = t, this._filter = i, this._totalCount = 0, this._matchCount = 0, this._pattern = "", this._lowercasePattern = "", this.disposables = new dt(), e.onWillRefilter(this.reset, this, this.disposables);
  }
  get totalCount() {
    return this._totalCount;
  }
  get matchCount() {
    return this._matchCount;
  }
  set pattern(e) {
    this._pattern = e, this._lowercasePattern = e.toLowerCase();
  }
  filter(e, t) {
    if (this._filter) {
      const o = this._filter.filter(e, t);
      if (this.tree.options.simpleKeyboardNavigation)
        return o;
      let s;
      if (typeof o == "boolean" ? s = o ? 1 : 0 : QI(o) ? s = m_(o.visibility) : s = o, s === 0)
        return !1;
    }
    if (this._totalCount++, this.tree.options.simpleKeyboardNavigation || !this._pattern)
      return this._matchCount++, { data: Td.Default, visibility: !0 };
    const i = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e), r = Array.isArray(i) ? i : [i];
    for (const o of r) {
      const s = o && o.toString();
      if (typeof s > "u")
        return { data: Td.Default, visibility: !0 };
      const a = cS(this._pattern, this._lowercasePattern, 0, s, s.toLowerCase(), 0, !0);
      if (a)
        return this._matchCount++, r.length === 1 ? { data: a, visibility: !0 } : { data: { label: s, score: a }, visibility: !0 };
    }
    return this.tree.options.filterOnType ? 2 : { data: Td.Default, visibility: !0 };
  }
  reset() {
    this._totalCount = 0, this._matchCount = 0;
  }
  dispose() {
    bi(this.disposables);
  }
}
class Fme {
  constructor(e, t, i, r, o) {
    this.tree = e, this.view = i, this.filter = r, this.keyboardNavigationDelegate = o, this._enabled = !1, this._pattern = "", this._empty = !1, this._onDidChangeEmptyState = new q(), this.positionClassName = "ne", this.automaticKeyboardNavigation = !0, this.triggered = !1, this._onDidChangePattern = new q(), this.enabledDisposables = new dt(), this.disposables = new dt(), this.domNode = Xe(`.monaco-list-type-filter.${this.positionClassName}`), this.domNode.draggable = !0, wt(this.domNode, "dragstart")(this.onDragStart, this, this.disposables), this.messageDomNode = Me(i.getHTMLElement(), Xe(".monaco-list-type-filter-message")), this.labelDomNode = Me(this.domNode, Xe("span.label"));
    const s = Me(this.domNode, Xe(".controls"));
    this._filterOnType = !!e.options.filterOnType, this.filterOnTypeDomNode = Me(s, Xe("input.filter")), this.filterOnTypeDomNode.type = "checkbox", this.filterOnTypeDomNode.checked = this._filterOnType, this.filterOnTypeDomNode.tabIndex = -1, this.updateFilterOnTypeTitleAndIcon(), wt(this.filterOnTypeDomNode, "input")(this.onDidChangeFilterOnType, this, this.disposables), this.clearDomNode = Me(s, Xe("button.clear" + xme.cssSelector)), this.clearDomNode.tabIndex = -1, this.clearDomNode.title = b("clear", "Clear"), this.keyboardNavigationEventFilter = e.options.keyboardNavigationEventFilter, t.onDidSplice(this.onDidSpliceModel, this, this.disposables), this.updateOptions(e.options);
  }
  get enabled() {
    return this._enabled;
  }
  get pattern() {
    return this._pattern;
  }
  get filterOnType() {
    return this._filterOnType;
  }
  updateOptions(e) {
    e.simpleKeyboardNavigation ? this.disable() : this.enable(), typeof e.filterOnType < "u" && (this._filterOnType = !!e.filterOnType, this.filterOnTypeDomNode.checked = this._filterOnType, this.updateFilterOnTypeTitleAndIcon()), typeof e.automaticKeyboardNavigation < "u" && (this.automaticKeyboardNavigation = e.automaticKeyboardNavigation), this.tree.refilter(), this.render(), this.automaticKeyboardNavigation || this.onEventOrInput("");
  }
  enable() {
    if (this._enabled)
      return;
    const e = We.chain(wt(this.view.getHTMLElement(), "keydown")).filter((i) => !fh(i.target) || i.target === this.filterOnTypeDomNode).filter((i) => i.key !== "Dead" && !/^Media/.test(i.key)).map((i) => new Yi(i)).filter(this.keyboardNavigationEventFilter || (() => !0)).filter(() => this.automaticKeyboardNavigation || this.triggered).filter((i) => this.keyboardNavigationDelegate.mightProducePrintableCharacter(i) && !(i.keyCode === 18 || i.keyCode === 16 || i.keyCode === 15 || i.keyCode === 17) || (this.pattern.length > 0 || this.triggered) && (i.keyCode === 9 || i.keyCode === 1) && !i.altKey && !i.ctrlKey && !i.metaKey || i.keyCode === 1 && (kt ? i.altKey && !i.metaKey : i.ctrlKey) && !i.shiftKey).forEach((i) => {
      i.stopPropagation(), i.preventDefault();
    }).event, t = wt(this.clearDomNode, "click");
    We.chain(We.any(e, t)).event(this.onEventOrInput, this, this.enabledDisposables), this.filter.pattern = "", this.tree.refilter(), this.render(), this._enabled = !0, this.triggered = !1;
  }
  disable() {
    this._enabled && (this.domNode.remove(), this.enabledDisposables.clear(), this.tree.refilter(), this.render(), this._enabled = !1, this.triggered = !1);
  }
  onEventOrInput(e) {
    typeof e == "string" ? this.onInput(e) : e instanceof MouseEvent || e.keyCode === 9 || e.keyCode === 1 && (kt ? e.altKey : e.ctrlKey) ? this.onInput("") : e.keyCode === 1 ? this.onInput(this.pattern.length === 0 ? "" : this.pattern.substr(0, this.pattern.length - 1)) : this.onInput(this.pattern + e.browserEvent.key);
  }
  onInput(e) {
    const t = this.view.getHTMLElement();
    e && !this.domNode.parentElement ? t.append(this.domNode) : !e && this.domNode.parentElement && (this.domNode.remove(), this.tree.domFocus()), this._pattern = e, this._onDidChangePattern.fire(e), this.filter.pattern = e, this.tree.refilter(), e && this.tree.focusNext(0, !0, void 0, (r) => !Td.isDefault(r.filterData));
    const i = this.tree.getFocus();
    if (i.length > 0) {
      const r = i[0];
      this.tree.getRelativeTop(r) === null && this.tree.reveal(r, 0.5);
    }
    this.render(), e || (this.triggered = !1);
  }
  onDragStart() {
    const e = this.view.getHTMLElement(), { left: t } = qa(e), i = e.clientWidth, r = i / 2, o = this.domNode.clientWidth, s = new dt();
    let a = this.positionClassName;
    const l = () => {
      switch (a) {
        case "nw":
          this.domNode.style.top = "4px", this.domNode.style.left = "4px";
          break;
        case "ne":
          this.domNode.style.top = "4px", this.domNode.style.left = `${i - o - 6}px`;
          break;
      }
    }, u = (h) => {
      h.preventDefault();
      const d = h.clientX - t;
      h.dataTransfer && (h.dataTransfer.dropEffect = "none"), d < r ? a = "nw" : a = "ne", l();
    }, c = () => {
      this.positionClassName = a, this.domNode.className = `monaco-list-type-filter ${this.positionClassName}`, this.domNode.style.top = "", this.domNode.style.left = "", bi(s);
    };
    l(), this.domNode.classList.remove(a), this.domNode.classList.add("dragging"), s.add(Oi(() => this.domNode.classList.remove("dragging"))), wt(document, "dragover")(u, null, s), wt(this.domNode, "dragend")(c, null, s), xu.CurrentDragAndDropData = new npe("vscode-ui"), s.add(Oi(() => xu.CurrentDragAndDropData = void 0));
  }
  onDidSpliceModel() {
    !this._enabled || this.pattern.length === 0 || (this.tree.refilter(), this.render());
  }
  onDidChangeFilterOnType() {
    this.tree.updateOptions({ filterOnType: this.filterOnTypeDomNode.checked }), this.tree.refilter(), this.tree.domFocus(), this.render(), this.updateFilterOnTypeTitleAndIcon();
  }
  updateFilterOnTypeTitleAndIcon() {
    this.filterOnType ? (this.filterOnTypeDomNode.classList.remove(...jW.classNamesArray), this.filterOnTypeDomNode.classList.add(...zW.classNamesArray), this.filterOnTypeDomNode.title = b("disable filter on type", "Disable Filter on Type")) : (this.filterOnTypeDomNode.classList.remove(...zW.classNamesArray), this.filterOnTypeDomNode.classList.add(...jW.classNamesArray), this.filterOnTypeDomNode.title = b("enable filter on type", "Enable Filter on Type"));
  }
  render() {
    const e = this.filter.totalCount > 0 && this.filter.matchCount === 0;
    this.pattern && this.tree.options.filterOnType && e ? (this.messageDomNode.textContent = b("empty", "No elements found"), this._empty = !0) : (this.messageDomNode.innerText = "", this._empty = !1), this.domNode.classList.toggle("no-matches", e), this.domNode.title = b("found", "Matched {0} out of {1} elements", this.filter.matchCount, this.filter.totalCount), this.labelDomNode.textContent = this.pattern.length > 16 ? "" + this.pattern.substr(this.pattern.length - 16) : this.pattern, this._onDidChangeEmptyState.fire(this._empty);
  }
  shouldAllowFocus(e) {
    return !this.enabled || !this.pattern || this.filterOnType || this.filter.totalCount > 0 && this.filter.matchCount <= 1 ? !0 : !Td.isDefault(e.filterData);
  }
  dispose() {
    this._enabled && (this.domNode.remove(), this.enabledDisposables.dispose(), this._enabled = !1, this.triggered = !1), this._onDidChangePattern.dispose(), bi(this.disposables);
  }
}
function $W(n) {
  let e = Nv.Unknown;
  return tk(n.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row") ? e = Nv.Twistie : tk(n.browserEvent.target, "monaco-tl-contents", "monaco-tl-row") && (e = Nv.Element), {
    browserEvent: n.browserEvent,
    element: n.element ? n.element.element : null,
    target: e
  };
}
function bw(n, e) {
  e(n), n.children.forEach((t) => bw(t, e));
}
class p1 {
  constructor(e) {
    this.identityProvider = e, this.nodes = [], this._onDidChange = new q(), this.onDidChange = this._onDidChange.event;
  }
  get nodeSet() {
    return this._nodeSet || (this._nodeSet = this.createNodeSet()), this._nodeSet;
  }
  set(e, t) {
    var i;
    !(!((i = t) === null || i === void 0) && i.__forceEvent) && Yu(this.nodes, e) || this._set(e, !1, t);
  }
  _set(e, t, i) {
    if (this.nodes = [...e], this.elements = void 0, this._nodeSet = void 0, !t) {
      const r = this;
      this._onDidChange.fire({ get elements() {
        return r.get();
      }, browserEvent: i });
    }
  }
  get() {
    return this.elements || (this.elements = this.nodes.map((e) => e.element)), [...this.elements];
  }
  getNodes() {
    return this.nodes;
  }
  has(e) {
    return this.nodeSet.has(e);
  }
  onDidModelSplice({ insertedNodes: e, deletedNodes: t }) {
    if (!this.identityProvider) {
      const l = this.createNodeSet(), u = (c) => l.delete(c);
      t.forEach((c) => bw(c, u)), this.set([...l.values()]);
      return;
    }
    const i = /* @__PURE__ */ new Set(), r = (l) => i.add(this.identityProvider.getId(l.element).toString());
    t.forEach((l) => bw(l, r));
    const o = /* @__PURE__ */ new Map(), s = (l) => o.set(this.identityProvider.getId(l.element).toString(), l);
    e.forEach((l) => bw(l, s));
    const a = [];
    for (const l of this.nodes) {
      const u = this.identityProvider.getId(l.element).toString();
      if (!i.has(u))
        a.push(l);
      else {
        const h = o.get(u);
        h && a.push(h);
      }
    }
    this._set(a, !0);
  }
  createNodeSet() {
    const e = /* @__PURE__ */ new Set();
    for (const t of this.nodes)
      e.add(t);
    return e;
  }
}
class kme extends nU {
  constructor(e, t) {
    super(e), this.tree = t;
  }
  onViewPointer(e) {
    if (fh(e.browserEvent.target) || hp(e.browserEvent.target))
      return;
    const t = e.element;
    if (!t)
      return super.onViewPointer(e);
    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e))
      return super.onViewPointer(e);
    const i = e.browserEvent.target, r = i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && e.browserEvent.offsetX < 16;
    let o = !1;
    if (typeof this.tree.expandOnlyOnTwistieClick == "function" ? o = this.tree.expandOnlyOnTwistieClick(t.element) : o = !!this.tree.expandOnlyOnTwistieClick, o && !r && e.browserEvent.detail !== 2)
      return super.onViewPointer(e);
    if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2)
      return super.onViewPointer(e);
    if (t.collapsible) {
      const s = this.tree.model, a = s.getNodeLocation(t), l = e.browserEvent.altKey;
      if (this.tree.setFocus([a]), s.setCollapsed(a, void 0, l), o && r)
        return;
    }
    super.onViewPointer(e);
  }
  onDoubleClick(e) {
    e.browserEvent.target.classList.contains("monaco-tl-twistie") || !this.tree.expandOnDoubleClick || super.onDoubleClick(e);
  }
}
class Wme extends df {
  constructor(e, t, i, r, o, s, a, l) {
    super(e, t, i, r, l), this.focusTrait = o, this.selectionTrait = s, this.anchorTrait = a;
  }
  createMouseController(e) {
    return new kme(this, e.tree);
  }
  splice(e, t, i = []) {
    if (super.splice(e, t, i), i.length === 0)
      return;
    const r = [], o = [];
    let s;
    i.forEach((a, l) => {
      this.focusTrait.has(a) && r.push(e + l), this.selectionTrait.has(a) && o.push(e + l), this.anchorTrait.has(a) && (s = e + l);
    }), r.length > 0 && super.setFocus(Uk([...super.getFocus(), ...r])), o.length > 0 && super.setSelection(Uk([...super.getSelection(), ...o])), typeof s == "number" && super.setAnchor(s);
  }
  setFocus(e, t, i = !1) {
    super.setFocus(e, t), i || this.focusTrait.set(e.map((r) => this.element(r)), t);
  }
  setSelection(e, t, i = !1) {
    super.setSelection(e, t), i || this.selectionTrait.set(e.map((r) => this.element(r)), t);
  }
  setAnchor(e, t = !1) {
    super.setAnchor(e), t || (typeof e > "u" ? this.anchorTrait.set([]) : this.anchorTrait.set([this.element(e)]));
  }
}
class oU {
  constructor(e, t, i, r, o = {}) {
    this._options = o, this.eventBufferer = new ON(), this.disposables = new dt(), this._onWillRefilter = new q(), this.onWillRefilter = this._onWillRefilter.event, this._onDidUpdateOptions = new q();
    const s = new JI(i), a = new ZF(), l = new ZF(), u = new Ame(l.event);
    this.renderers = r.map((d) => new __(d, () => this.model, a.event, u, o));
    for (let d of this.renderers)
      this.disposables.add(d);
    let c;
    o.keyboardNavigationLabelProvider && (c = new Mme(this, o.keyboardNavigationLabelProvider, o.filter), o = Object.assign(Object.assign({}, o), { filter: c }), this.disposables.add(c)), this.focus = new p1(o.identityProvider), this.selection = new p1(o.identityProvider), this.anchor = new p1(o.identityProvider), this.view = new Wme(e, t, s, this.renderers, this.focus, this.selection, this.anchor, Object.assign(Object.assign({}, Pme(() => this.model, o)), { tree: this })), this.model = this.createModel(e, this.view, o), a.input = this.model.onDidChangeCollapseState;
    const h = We.forEach(this.model.onDidSplice, (d) => {
      this.eventBufferer.bufferEvents(() => {
        this.focus.onDidModelSplice(d), this.selection.onDidModelSplice(d);
      });
    });
    if (h(() => null, null, this.disposables), l.input = We.chain(We.any(h, this.focus.onDidChange, this.selection.onDidChange)).debounce(() => null, 0).map(() => {
      const d = /* @__PURE__ */ new Set();
      for (const f of this.focus.getNodes())
        d.add(f);
      for (const f of this.selection.getNodes())
        d.add(f);
      return [...d.values()];
    }).event, o.keyboardSupport !== !1) {
      const d = We.chain(this.view.onKeyDown).filter((f) => !fh(f.target)).map((f) => new Yi(f));
      d.filter(
        (f) => f.keyCode === 15
        /* LeftArrow */
      ).on(this.onLeftArrow, this, this.disposables), d.filter(
        (f) => f.keyCode === 17
        /* RightArrow */
      ).on(this.onRightArrow, this, this.disposables), d.filter(
        (f) => f.keyCode === 10
        /* Space */
      ).on(this.onSpace, this, this.disposables);
    }
    if (o.keyboardNavigationLabelProvider) {
      const d = o.keyboardNavigationDelegate || eU;
      this.typeFilterController = new Fme(this, this.model, this.view, c, d), this.focusNavigationFilter = (f) => this.typeFilterController.shouldAllowFocus(f), this.disposables.add(this.typeFilterController);
    }
    this.styleElement = As(this.view.getHTMLElement()), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === v_.Always);
  }
  get onDidChangeFocus() {
    return this.eventBufferer.wrapEvent(this.focus.onDidChange);
  }
  get onDidChangeSelection() {
    return this.eventBufferer.wrapEvent(this.selection.onDidChange);
  }
  get onMouseDblClick() {
    return We.map(this.view.onMouseDblClick, $W);
  }
  get onPointer() {
    return We.map(this.view.onPointer, $W);
  }
  get onDidFocus() {
    return this.view.onDidFocus;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get expandOnDoubleClick() {
    return typeof this._options.expandOnDoubleClick > "u" ? !0 : this._options.expandOnDoubleClick;
  }
  get expandOnlyOnTwistieClick() {
    return typeof this._options.expandOnlyOnTwistieClick > "u" ? !0 : this._options.expandOnlyOnTwistieClick;
  }
  get onDidDispose() {
    return this.view.onDidDispose;
  }
  updateOptions(e = {}) {
    this._options = Object.assign(Object.assign({}, this._options), e);
    for (const t of this.renderers)
      t.updateOptions(e);
    this.view.updateOptions({
      enableKeyboardNavigation: this._options.simpleKeyboardNavigation,
      automaticKeyboardNavigation: this._options.automaticKeyboardNavigation,
      smoothScrolling: this._options.smoothScrolling,
      horizontalScrolling: this._options.horizontalScrolling
    }), this.typeFilterController && this.typeFilterController.updateOptions(this._options), this._onDidUpdateOptions.fire(this._options), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === v_.Always);
  }
  get options() {
    return this._options;
  }
  // Widget
  getHTMLElement() {
    return this.view.getHTMLElement();
  }
  get scrollTop() {
    return this.view.scrollTop;
  }
  set scrollTop(e) {
    this.view.scrollTop = e;
  }
  domFocus() {
    this.view.domFocus();
  }
  layout(e, t) {
    this.view.layout(e, t);
  }
  style(e) {
    const t = `.${this.view.domId}`, i = [];
    e.treeIndentGuidesStroke && (i.push(`.monaco-list${t}:hover .monaco-tl-indent > .indent-guide, .monaco-list${t}.always .monaco-tl-indent > .indent-guide  { border-color: ${e.treeIndentGuidesStroke.transparent(0.4)}; }`), i.push(`.monaco-list${t} .monaco-tl-indent > .indent-guide.active { border-color: ${e.treeIndentGuidesStroke}; }`)), this.styleElement.textContent = i.join(`
`), this.view.style(e);
  }
  collapse(e, t = !1) {
    return this.model.setCollapsed(e, !0, t);
  }
  expand(e, t = !1) {
    return this.model.setCollapsed(e, !1, t);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  refilter() {
    this._onWillRefilter.fire(void 0), this.model.refilter();
  }
  setSelection(e, t) {
    const i = e.map((o) => this.model.getNode(o));
    this.selection.set(i, t);
    const r = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
    this.view.setSelection(r, t, !0);
  }
  getSelection() {
    return this.selection.get();
  }
  setFocus(e, t) {
    const i = e.map((o) => this.model.getNode(o));
    this.focus.set(i, t);
    const r = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
    this.view.setFocus(r, t, !0);
  }
  focusNext(e = 1, t = !1, i, r = this.focusNavigationFilter) {
    this.view.focusNext(e, t, i, r);
  }
  getFocus() {
    return this.focus.get();
  }
  reveal(e, t) {
    this.model.expandTo(e);
    const i = this.model.getListIndex(e);
    i !== -1 && this.view.reveal(i, t);
  }
  /**
   * Returns the relative position of an element rendered in the list.
   * Returns `null` if the element isn't *entirely* in the visible viewport.
   */
  getRelativeTop(e) {
    const t = this.model.getListIndex(e);
    return t === -1 ? null : this.view.getRelativeTop(t);
  }
  // List
  onLeftArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], r = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(r, !0)) {
      const s = this.model.getParentNodeLocation(r);
      if (!s)
        return;
      const a = this.model.getListIndex(s);
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onRightArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], r = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(r, !1)) {
      if (!i.children.some((l) => l.visible))
        return;
      const [s] = this.view.getFocus(), a = s + 1;
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onSpace(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], r = this.model.getNodeLocation(i), o = e.browserEvent.altKey;
    this.model.setCollapsed(r, void 0, o);
  }
  dispose() {
    bi(this.disposables), this.view.dispose();
  }
}
class eP {
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.nodesByIdentity = /* @__PURE__ */ new Map(), this.model = new Ome(e, t, null, i), this.onDidSplice = this.model.onDidSplice, this.onDidChangeCollapseState = this.model.onDidChangeCollapseState, this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount, i.sorter && (this.sorter = {
      compare(r, o) {
        return i.sorter.compare(r.element, o.element);
      }
    }), this.identityProvider = i.identityProvider;
  }
  setChildren(e, t = Ct.empty(), i = {}) {
    const r = this.getElementLocation(e);
    this._setChildren(r, this.preserveCollapseState(t), i);
  }
  _setChildren(e, t = Ct.empty(), i) {
    const r = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), s = (l) => {
      var u;
      if (l.element === null)
        return;
      const c = l;
      if (r.add(c.element), this.nodes.set(c.element, c), this.identityProvider) {
        const h = this.identityProvider.getId(c.element).toString();
        o.add(h), this.nodesByIdentity.set(h, c);
      }
      (u = i.onDidCreateNode) === null || u === void 0 || u.call(i, c);
    }, a = (l) => {
      var u;
      if (l.element === null)
        return;
      const c = l;
      if (r.has(c.element) || this.nodes.delete(c.element), this.identityProvider) {
        const h = this.identityProvider.getId(c.element).toString();
        o.has(h) || this.nodesByIdentity.delete(h);
      }
      (u = i.onDidDeleteNode) === null || u === void 0 || u.call(i, c);
    };
    this.model.splice([...e, 0], Number.MAX_VALUE, t, Object.assign(Object.assign({}, i), { onDidCreateNode: s, onDidDeleteNode: a }));
  }
  preserveCollapseState(e = Ct.empty()) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), Ct.map(e, (t) => {
      let i = this.nodes.get(t.element);
      if (!i && this.identityProvider) {
        const s = this.identityProvider.getId(t.element).toString();
        i = this.nodesByIdentity.get(s);
      }
      if (!i)
        return Object.assign(Object.assign({}, t), { children: this.preserveCollapseState(t.children) });
      const r = typeof t.collapsible == "boolean" ? t.collapsible : i.collapsible, o = typeof t.collapsed < "u" ? t.collapsed : i.collapsed;
      return Object.assign(Object.assign({}, t), {
        collapsible: r,
        collapsed: o,
        children: this.preserveCollapseState(t.children)
      });
    });
  }
  rerender(e) {
    const t = this.getElementLocation(e);
    this.model.rerender(t);
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getElementLocation(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getElementLocation(e);
    return this.model.getListRenderCount(t);
  }
  isCollapsible(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getElementLocation(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const r = this.getElementLocation(e);
    return this.model.setCollapsed(r, t, i);
  }
  expandTo(e) {
    const t = this.getElementLocation(e);
    this.model.expandTo(t);
  }
  refilter() {
    this.model.refilter();
  }
  getNode(e = null) {
    if (e === null)
      return this.model.getNode(this.model.rootRef);
    const t = this.nodes.get(e);
    if (!t)
      throw new ys(this.user, `Tree element not found: ${e}`);
    return t;
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    if (e === null)
      throw new ys(this.user, "Invalid getParentNodeLocation call");
    const t = this.nodes.get(e);
    if (!t)
      throw new ys(this.user, `Tree element not found: ${e}`);
    const i = this.model.getNodeLocation(t), r = this.model.getParentNodeLocation(i);
    return this.model.getNode(r).element;
  }
  getElementLocation(e) {
    if (e === null)
      return [];
    const t = this.nodes.get(e);
    if (!t)
      throw new ys(this.user, `Tree element not found: ${e}`);
    return this.model.getNodeLocation(t);
  }
}
function Sw(n) {
  const e = [n.element], t = n.incompressible || !1;
  return {
    element: { elements: e, incompressible: t },
    children: Ct.map(Ct.from(n.children), Sw),
    collapsible: n.collapsible,
    collapsed: n.collapsed
  };
}
function Ew(n) {
  const e = [n.element], t = n.incompressible || !1;
  let i, r;
  for (; [r, i] = Ct.consume(Ct.from(n.children), 2), !(r.length !== 1 || r[0].incompressible); )
    n = r[0], e.push(n.element);
  return {
    element: { elements: e, incompressible: t },
    children: Ct.map(Ct.concat(r, i), Ew),
    collapsible: n.collapsible,
    collapsed: n.collapsed
  };
}
function TO(n, e = 0) {
  let t;
  return e < n.element.elements.length - 1 ? t = [TO(n, e + 1)] : t = Ct.map(Ct.from(n.children), (i) => TO(i, 0)), e === 0 && n.element.incompressible ? {
    element: n.element.elements[e],
    children: t,
    incompressible: !0,
    collapsible: n.collapsible,
    collapsed: n.collapsed
  } : {
    element: n.element.elements[e],
    children: t,
    collapsible: n.collapsible,
    collapsed: n.collapsed
  };
}
function KW(n) {
  return TO(n, 0);
}
function sU(n, e, t) {
  return n.element === e ? Object.assign(Object.assign({}, n), { children: t }) : Object.assign(Object.assign({}, n), { children: Ct.map(Ct.from(n.children), (i) => sU(i, e, t)) });
}
const Vme = (n) => ({
  getId(e) {
    return e.elements.map((t) => n.getId(t).toString()).join("\0");
  }
});
class Bme {
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.model = new eP(e, t, i), this.enabled = typeof i.compressionEnabled > "u" ? !0 : i.compressionEnabled, this.identityProvider = i.identityProvider;
  }
  get onDidSplice() {
    return this.model.onDidSplice;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get onDidChangeRenderNodeCount() {
    return this.model.onDidChangeRenderNodeCount;
  }
  setChildren(e, t = Ct.empty(), i) {
    const r = i.diffIdentityProvider && Vme(i.diffIdentityProvider);
    if (e === null) {
      const f = Ct.map(t, this.enabled ? Ew : Sw);
      this._setChildren(null, f, { diffIdentityProvider: r, diffDepth: 1 / 0 });
      return;
    }
    const o = this.nodes.get(e);
    if (!o)
      throw new Error("Unknown compressed tree node");
    const s = this.model.getNode(o), a = this.model.getParentNodeLocation(o), l = this.model.getNode(a), u = KW(s), c = sU(u, e, t), h = (this.enabled ? Ew : Sw)(c), d = l.children.map((f) => f === s ? h : f);
    this._setChildren(l.element, d, {
      diffIdentityProvider: r,
      diffDepth: s.depth - l.depth
    });
  }
  setCompressionEnabled(e) {
    if (e === this.enabled)
      return;
    this.enabled = e;
    const i = this.model.getNode().children, r = Ct.map(i, KW), o = Ct.map(r, e ? Ew : Sw);
    this._setChildren(null, o, {
      diffIdentityProvider: this.identityProvider,
      diffDepth: 1 / 0
    });
  }
  _setChildren(e, t, i) {
    const r = /* @__PURE__ */ new Set(), o = (a) => {
      for (const l of a.element.elements)
        r.add(l), this.nodes.set(l, a.element);
    }, s = (a) => {
      for (const l of a.element.elements)
        r.has(l) || this.nodes.delete(l);
    };
    this.model.setChildren(e, t, Object.assign(Object.assign({}, i), { onDidCreateNode: o, onDidDeleteNode: s }));
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListRenderCount(t);
  }
  getNode(e) {
    if (typeof e > "u")
      return this.model.getNode();
    const t = this.getCompressedNode(e);
    return this.model.getNode(t);
  }
  // TODO: review this
  getNodeLocation(e) {
    const t = this.model.getNodeLocation(e);
    return t === null ? null : t.elements[t.elements.length - 1];
  }
  // TODO: review this
  getParentNodeLocation(e) {
    const t = this.getCompressedNode(e), i = this.model.getParentNodeLocation(t);
    return i === null ? null : i.elements[i.elements.length - 1];
  }
  isCollapsible(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getCompressedNode(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const r = this.getCompressedNode(e);
    return this.model.setCollapsed(r, t, i);
  }
  expandTo(e) {
    const t = this.getCompressedNode(e);
    this.model.expandTo(t);
  }
  rerender(e) {
    const t = this.getCompressedNode(e);
    this.model.rerender(t);
  }
  refilter() {
    this.model.refilter();
  }
  getCompressedNode(e) {
    if (e === null)
      return null;
    const t = this.nodes.get(e);
    if (!t)
      throw new ys(this.user, `Tree element not found: ${e}`);
    return t;
  }
}
const Hme = (n) => n[n.length - 1];
class tP {
  constructor(e, t) {
    this.unwrapper = e, this.node = t;
  }
  get element() {
    return this.node.element === null ? null : this.unwrapper(this.node.element);
  }
  get children() {
    return this.node.children.map((e) => new tP(this.unwrapper, e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
}
function Gme(n, e) {
  return {
    splice(t, i, r) {
      e.splice(t, i, r.map((o) => n.map(o)));
    },
    updateElementHeight(t, i) {
      e.updateElementHeight(t, i);
    }
  };
}
function Ume(n, e) {
  return Object.assign(Object.assign({}, e), { identityProvider: e.identityProvider && {
    getId(t) {
      return e.identityProvider.getId(n(t));
    }
  }, sorter: e.sorter && {
    compare(t, i) {
      return e.sorter.compare(t.elements[0], i.elements[0]);
    }
  }, filter: e.filter && {
    filter(t, i) {
      return e.filter.filter(n(t), i);
    }
  } });
}
class zme {
  constructor(e, t, i = {}) {
    this.rootRef = null, this.elementMapper = i.elementMapper || Hme;
    const r = (o) => this.elementMapper(o.elements);
    this.nodeMapper = new ZI((o) => new tP(r, o)), this.model = new Bme(e, Gme(this.nodeMapper, t), Ume(r, i));
  }
  get onDidSplice() {
    return We.map(this.model.onDidSplice, ({ insertedNodes: e, deletedNodes: t }) => ({
      insertedNodes: e.map((i) => this.nodeMapper.map(i)),
      deletedNodes: t.map((i) => this.nodeMapper.map(i))
    }));
  }
  get onDidChangeCollapseState() {
    return We.map(this.model.onDidChangeCollapseState, ({ node: e, deep: t }) => ({
      node: this.nodeMapper.map(e),
      deep: t
    }));
  }
  get onDidChangeRenderNodeCount() {
    return We.map(this.model.onDidChangeRenderNodeCount, (e) => this.nodeMapper.map(e));
  }
  setChildren(e, t = Ct.empty(), i = {}) {
    this.model.setChildren(e, t, i);
  }
  setCompressionEnabled(e) {
    this.model.setCompressionEnabled(e);
  }
  has(e) {
    return this.model.has(e);
  }
  getListIndex(e) {
    return this.model.getListIndex(e);
  }
  getListRenderCount(e) {
    return this.model.getListRenderCount(e);
  }
  getNode(e) {
    return this.nodeMapper.map(this.model.getNode(e));
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    return this.model.getParentNodeLocation(e);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  setCollapsed(e, t, i) {
    return this.model.setCollapsed(e, t, i);
  }
  expandTo(e) {
    return this.model.expandTo(e);
  }
  rerender(e) {
    return this.model.rerender(e);
  }
  refilter() {
    return this.model.refilter();
  }
  getCompressedTreeNode(e = null) {
    return this.model.getNode(e);
  }
}
var jme = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
};
class iP extends oU {
  constructor(e, t, i, r, o = {}) {
    super(e, t, i, r, o);
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  setChildren(e, t = Ct.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  rerender(e) {
    if (e === void 0) {
      this.view.rerender();
      return;
    }
    this.model.rerender(e);
  }
  hasElement(e) {
    return this.model.has(e);
  }
  createModel(e, t, i) {
    return new eP(e, t, i);
  }
}
class aU {
  constructor(e, t) {
    this._compressedTreeNodeProvider = e, this.renderer = t, this.templateId = t.templateId, t.onDidChangeTwistieState && (this.onDidChangeTwistieState = t.onDidChangeTwistieState);
  }
  get compressedTreeNodeProvider() {
    return this._compressedTreeNodeProvider();
  }
  renderTemplate(e) {
    return { compressedTreeNode: void 0, data: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, r) {
    const o = this.compressedTreeNodeProvider.getCompressedTreeNode(e.element);
    o.element.elements.length === 1 ? (i.compressedTreeNode = void 0, this.renderer.renderElement(e, t, i.data, r)) : (i.compressedTreeNode = o, this.renderer.renderCompressedElements(o, t, i.data, r));
  }
  disposeElement(e, t, i, r) {
    i.compressedTreeNode ? this.renderer.disposeCompressedElements && this.renderer.disposeCompressedElements(i.compressedTreeNode, t, i.data, r) : this.renderer.disposeElement && this.renderer.disposeElement(e, t, i.data, r);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.data);
  }
  renderTwistie(e, t) {
    return this.renderer.renderTwistie ? this.renderer.renderTwistie(e, t) : !1;
  }
}
jme([
  Bn
], aU.prototype, "compressedTreeNodeProvider", null);
function $me(n, e) {
  return e && Object.assign(Object.assign({}, e), { keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
    getKeyboardNavigationLabel(t) {
      let i;
      try {
        i = n().getCompressedTreeNode(t);
      } catch {
        return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t);
      }
      return i.element.elements.length === 1 ? e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t) : e.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(i.element.elements);
    }
  } });
}
class lU extends iP {
  constructor(e, t, i, r, o = {}) {
    const s = () => this, a = r.map((l) => new aU(s, l));
    super(e, t, i, a, $me(s, o));
  }
  setChildren(e, t = Ct.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  createModel(e, t, i) {
    return new zme(e, t, i);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), typeof e.compressionEnabled < "u" && this.model.setCompressionEnabled(e.compressionEnabled);
  }
  getCompressedTreeNode(e = null) {
    return this.model.getCompressedTreeNode(e);
  }
}
var Nc = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function g1(n) {
  return Object.assign(Object.assign({}, n), { children: [], refreshPromise: void 0, stale: !0, slow: !1, collapsedByDefault: void 0 });
}
function OO(n, e) {
  return e.parent ? e.parent === n ? !0 : OO(n, e.parent) : !1;
}
function Kme(n, e) {
  return n === e || OO(n, e) || OO(e, n);
}
class nP {
  constructor(e) {
    this.node = e;
  }
  get element() {
    return this.node.element.element;
  }
  get children() {
    return this.node.children.map((e) => new nP(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
}
class qme {
  constructor(e, t, i) {
    this.renderer = e, this.nodeMapper = t, this.onDidChangeTwistieState = i, this.renderedNodes = /* @__PURE__ */ new Map(), this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, r) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, r);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...pS.classNamesArray), !0) : (t.classList.remove(...pS.classNamesArray), !1);
  }
  disposeElement(e, t, i, r) {
    this.renderer.disposeElement && this.renderer.disposeElement(this.nodeMapper.map(e), t, i.templateData, r);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
  }
}
function qW(n) {
  return {
    browserEvent: n.browserEvent,
    elements: n.elements.map((e) => e.element)
  };
}
function YW(n) {
  return {
    browserEvent: n.browserEvent,
    element: n.element && n.element.element,
    target: n.target
  };
}
class Yme extends eC {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function m1(n) {
  return n instanceof eC ? new Yme(n) : n;
}
class Xme {
  constructor(e) {
    this.dnd = e;
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    this.dnd.onDragStart && this.dnd.onDragStart(m1(e), t);
  }
  onDragOver(e, t, i, r, o = !0) {
    return this.dnd.onDragOver(m1(e), t && t.element, i, r);
  }
  drop(e, t, i, r) {
    this.dnd.drop(m1(e), t && t.element, i, r);
  }
  onDragEnd(e) {
    this.dnd.onDragEnd && this.dnd.onDragEnd(e);
  }
}
function uU(n) {
  return n && Object.assign(Object.assign({}, n), { collapseByDefault: !0, identityProvider: n.identityProvider && {
    getId(e) {
      return n.identityProvider.getId(e.element);
    }
  }, dnd: n.dnd && new Xme(n.dnd), multipleSelectionController: n.multipleSelectionController && {
    isSelectionSingleChangeEvent(e) {
      return n.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
    },
    isSelectionRangeChangeEvent(e) {
      return n.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));
    }
  }, accessibilityProvider: n.accessibilityProvider && Object.assign(Object.assign({}, n.accessibilityProvider), {
    getPosInSet: void 0,
    getSetSize: void 0,
    getRole: n.accessibilityProvider.getRole ? (e) => n.accessibilityProvider.getRole(e.element) : () => "treeitem",
    isChecked: n.accessibilityProvider.isChecked ? (e) => {
      var t;
      return !!(!((t = n.accessibilityProvider) === null || t === void 0) && t.isChecked(e.element));
    } : void 0,
    getAriaLabel(e) {
      return n.accessibilityProvider.getAriaLabel(e.element);
    },
    getWidgetAriaLabel() {
      return n.accessibilityProvider.getWidgetAriaLabel();
    },
    getWidgetRole: n.accessibilityProvider.getWidgetRole ? () => n.accessibilityProvider.getWidgetRole() : () => "tree",
    getAriaLevel: n.accessibilityProvider.getAriaLevel && ((e) => n.accessibilityProvider.getAriaLevel(e.element)),
    getActiveDescendantId: n.accessibilityProvider.getActiveDescendantId && ((e) => n.accessibilityProvider.getActiveDescendantId(e.element))
  }), filter: n.filter && {
    filter(e, t) {
      return n.filter.filter(e.element, t);
    }
  }, keyboardNavigationLabelProvider: n.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, n.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(e) {
    return n.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
  } }), sorter: void 0, expandOnlyOnTwistieClick: typeof n.expandOnlyOnTwistieClick > "u" ? void 0 : typeof n.expandOnlyOnTwistieClick != "function" ? n.expandOnlyOnTwistieClick : (e) => n.expandOnlyOnTwistieClick(e.element), additionalScrollHeight: n.additionalScrollHeight });
}
function xO(n, e) {
  e(n), n.children.forEach((t) => xO(t, e));
}
class cU {
  constructor(e, t, i, r, o, s = {}) {
    this.user = e, this.dataSource = o, this.nodes = /* @__PURE__ */ new Map(), this.subTreeRefreshPromises = /* @__PURE__ */ new Map(), this.refreshPromises = /* @__PURE__ */ new Map(), this._onDidRender = new q(), this._onDidChangeNodeSlowState = new q(), this.nodeMapper = new ZI((a) => new nP(a)), this.disposables = new dt(), this.identityProvider = s.identityProvider, this.autoExpandSingleChildren = typeof s.autoExpandSingleChildren > "u" ? !1 : s.autoExpandSingleChildren, this.sorter = s.sorter, this.collapseByDefault = s.collapseByDefault, this.tree = this.createTree(e, t, i, r, s), this.root = g1({
      element: void 0,
      parent: null,
      hasChildren: !0
    }), this.identityProvider && (this.root = Object.assign(Object.assign({}, this.root), { id: null })), this.nodes.set(null, this.root), this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
  }
  get onDidChangeFocus() {
    return We.map(this.tree.onDidChangeFocus, qW);
  }
  get onDidChangeSelection() {
    return We.map(this.tree.onDidChangeSelection, qW);
  }
  get onMouseDblClick() {
    return We.map(this.tree.onMouseDblClick, YW);
  }
  get onPointer() {
    return We.map(this.tree.onPointer, YW);
  }
  get onDidFocus() {
    return this.tree.onDidFocus;
  }
  get onDidDispose() {
    return this.tree.onDidDispose;
  }
  createTree(e, t, i, r, o) {
    const s = new JI(i), a = r.map((u) => new qme(u, this.nodeMapper, this._onDidChangeNodeSlowState.event)), l = uU(o) || {};
    return new iP(e, t, s, a, l);
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  // Widget
  getHTMLElement() {
    return this.tree.getHTMLElement();
  }
  get scrollTop() {
    return this.tree.scrollTop;
  }
  set scrollTop(e) {
    this.tree.scrollTop = e;
  }
  domFocus() {
    this.tree.domFocus();
  }
  layout(e, t) {
    this.tree.layout(e, t);
  }
  style(e) {
    this.tree.style(e);
  }
  // Model
  getInput() {
    return this.root.element;
  }
  setInput(e, t) {
    return Nc(this, void 0, void 0, function* () {
      this.refreshPromises.forEach((r) => r.cancel()), this.refreshPromises.clear(), this.root.element = e;
      const i = t && { viewState: t, focus: [], selection: [] };
      yield this._updateChildren(e, !0, !1, i), i && (this.tree.setFocus(i.focus), this.tree.setSelection(i.selection)), t && typeof t.scrollTop == "number" && (this.scrollTop = t.scrollTop);
    });
  }
  _updateChildren(e = this.root.element, t = !0, i = !1, r, o) {
    return Nc(this, void 0, void 0, function* () {
      if (typeof this.root.element > "u")
        throw new ys(this.user, "Tree input not set");
      this.root.refreshPromise && (yield this.root.refreshPromise, yield We.toPromise(this._onDidRender.event));
      const s = this.getDataNode(e);
      if (yield this.refreshAndRenderNode(s, t, r, o), i)
        try {
          this.tree.rerender(s);
        } catch {
        }
    });
  }
  // View
  rerender(e) {
    if (e === void 0 || e === this.root.element) {
      this.tree.rerender();
      return;
    }
    const t = this.getDataNode(e);
    this.tree.rerender(t);
  }
  collapse(e, t = !1) {
    const i = this.getDataNode(e);
    return this.tree.collapse(i === this.root ? null : i, t);
  }
  expand(e, t = !1) {
    return Nc(this, void 0, void 0, function* () {
      if (typeof this.root.element > "u")
        throw new ys(this.user, "Tree input not set");
      this.root.refreshPromise && (yield this.root.refreshPromise, yield We.toPromise(this._onDidRender.event));
      const i = this.getDataNode(e);
      if (this.tree.hasElement(i) && !this.tree.isCollapsible(i) || (i.refreshPromise && (yield this.root.refreshPromise, yield We.toPromise(this._onDidRender.event)), i !== this.root && !i.refreshPromise && !this.tree.isCollapsed(i)))
        return !1;
      const r = this.tree.expand(i === this.root ? null : i, t);
      return i.refreshPromise && (yield this.root.refreshPromise, yield We.toPromise(this._onDidRender.event)), r;
    });
  }
  setSelection(e, t) {
    const i = e.map((r) => this.getDataNode(r));
    this.tree.setSelection(i, t);
  }
  getSelection() {
    return this.tree.getSelection().map((t) => t.element);
  }
  setFocus(e, t) {
    const i = e.map((r) => this.getDataNode(r));
    this.tree.setFocus(i, t);
  }
  getFocus() {
    return this.tree.getFocus().map((t) => t.element);
  }
  reveal(e, t) {
    this.tree.reveal(this.getDataNode(e), t);
  }
  // Implementation
  getDataNode(e) {
    const t = this.nodes.get(e === this.root.element ? null : e);
    if (!t)
      throw new ys(this.user, `Data tree node not found: ${e}`);
    return t;
  }
  refreshAndRenderNode(e, t, i, r) {
    return Nc(this, void 0, void 0, function* () {
      yield this.refreshNode(e, t, i), this.render(e, i, r);
    });
  }
  refreshNode(e, t, i) {
    return Nc(this, void 0, void 0, function* () {
      let r;
      return this.subTreeRefreshPromises.forEach((o, s) => {
        !r && Kme(s, e) && (r = o.then(() => this.refreshNode(e, t, i)));
      }), r || this.doRefreshSubTree(e, t, i);
    });
  }
  doRefreshSubTree(e, t, i) {
    return Nc(this, void 0, void 0, function* () {
      let r;
      e.refreshPromise = new Promise((o) => r = o), this.subTreeRefreshPromises.set(e, e.refreshPromise), e.refreshPromise.finally(() => {
        e.refreshPromise = void 0, this.subTreeRefreshPromises.delete(e);
      });
      try {
        const o = yield this.doRefreshNode(e, t, i);
        e.stale = !1, yield fT.settled(o.map((s) => this.doRefreshSubTree(s, t, i)));
      } finally {
        r();
      }
    });
  }
  doRefreshNode(e, t, i) {
    return Nc(this, void 0, void 0, function* () {
      e.hasChildren = !!this.dataSource.hasChildren(e.element);
      let r;
      if (!e.hasChildren)
        r = Promise.resolve(Ct.empty());
      else {
        const o = $v(800);
        o.then(() => {
          e.slow = !0, this._onDidChangeNodeSlowState.fire(e);
        }, (s) => null), r = this.doGetChildren(e).finally(() => o.cancel());
      }
      try {
        const o = yield r;
        return this.setChildren(e, o, t, i);
      } catch (o) {
        if (e !== this.root && this.tree.hasElement(e) && this.tree.collapse(e), W_(o))
          return [];
        throw o;
      } finally {
        e.slow && (e.slow = !1, this._onDidChangeNodeSlowState.fire(e));
      }
    });
  }
  doGetChildren(e) {
    let t = this.refreshPromises.get(e);
    return t || (t = ZG(() => Nc(this, void 0, void 0, function* () {
      const i = yield this.dataSource.getChildren(e.element);
      return this.processChildren(i);
    })), this.refreshPromises.set(e, t), t.finally(() => {
      this.refreshPromises.delete(e);
    }));
  }
  _onDidChangeCollapseState({ node: e, deep: t }) {
    e.element !== null && !e.collapsed && e.element.stale && (t ? this.collapse(e.element.element) : this.refreshAndRenderNode(e.element, !1).catch(Pi));
  }
  setChildren(e, t, i, r) {
    const o = [...t];
    if (e.children.length === 0 && o.length === 0)
      return [];
    const s = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    for (const c of e.children)
      if (s.set(c.element, c), this.identityProvider) {
        const h = this.tree.isCollapsed(c);
        a.set(c.id, { node: c, collapsed: h });
      }
    const l = [], u = o.map((c) => {
      const h = !!this.dataSource.hasChildren(c);
      if (!this.identityProvider) {
        const g = g1({ element: c, parent: e, hasChildren: h });
        return h && this.collapseByDefault && !this.collapseByDefault(c) && (g.collapsedByDefault = !1, l.push(g)), g;
      }
      const d = this.identityProvider.getId(c).toString(), f = a.get(d);
      if (f) {
        const g = f.node;
        return s.delete(g.element), this.nodes.delete(g.element), this.nodes.set(c, g), g.element = c, g.hasChildren = h, i ? f.collapsed ? (g.children.forEach((_) => xO(_, (m) => this.nodes.delete(m.element))), g.children.splice(0, g.children.length), g.stale = !0) : l.push(g) : h && this.collapseByDefault && !this.collapseByDefault(c) && (g.collapsedByDefault = !1, l.push(g)), g;
      }
      const p = g1({ element: c, parent: e, id: d, hasChildren: h });
      return r && r.viewState.focus && r.viewState.focus.indexOf(d) > -1 && r.focus.push(p), r && r.viewState.selection && r.viewState.selection.indexOf(d) > -1 && r.selection.push(p), r && r.viewState.expanded && r.viewState.expanded.indexOf(d) > -1 ? l.push(p) : h && this.collapseByDefault && !this.collapseByDefault(c) && (p.collapsedByDefault = !1, l.push(p)), p;
    });
    for (const c of s.values())
      xO(c, (h) => this.nodes.delete(h.element));
    for (const c of u)
      this.nodes.set(c.element, c);
    return e.children.splice(0, e.children.length, ...u), e !== this.root && this.autoExpandSingleChildren && u.length === 1 && l.length === 0 && (u[0].collapsedByDefault = !1, l.push(u[0])), l;
  }
  render(e, t, i) {
    const r = e.children.map((s) => this.asTreeElement(s, t)), o = i && Object.assign(Object.assign({}, i), { diffIdentityProvider: i.diffIdentityProvider && {
      getId(s) {
        return i.diffIdentityProvider.getId(s.element);
      }
    } });
    this.tree.setChildren(e === this.root ? null : e, r, o), e !== this.root && this.tree.setCollapsible(e, e.hasChildren), this._onDidRender.fire();
  }
  asTreeElement(e, t) {
    if (e.stale)
      return {
        element: e,
        collapsible: e.hasChildren,
        collapsed: !0
      };
    let i;
    return t && t.viewState.expanded && e.id && t.viewState.expanded.indexOf(e.id) > -1 ? i = !1 : i = e.collapsedByDefault, e.collapsedByDefault = void 0, {
      element: e,
      children: e.hasChildren ? Ct.map(e.children, (r) => this.asTreeElement(r, t)) : [],
      collapsible: e.hasChildren,
      collapsed: i
    };
  }
  processChildren(e) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), e;
  }
  dispose() {
    this.disposables.dispose();
  }
}
class rP {
  constructor(e) {
    this.node = e;
  }
  get element() {
    return {
      elements: this.node.element.elements.map((e) => e.element),
      incompressible: this.node.element.incompressible
    };
  }
  get children() {
    return this.node.children.map((e) => new rP(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
}
class Zme {
  constructor(e, t, i, r) {
    this.renderer = e, this.nodeMapper = t, this.compressibleNodeMapperProvider = i, this.onDidChangeTwistieState = r, this.renderedNodes = /* @__PURE__ */ new Map(), this.disposables = [], this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, r) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, r);
  }
  renderCompressedElements(e, t, i, r) {
    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, r);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...pS.classNamesArray), !0) : (t.classList.remove(...pS.classNamesArray), !1);
  }
  disposeElement(e, t, i, r) {
    this.renderer.disposeElement && this.renderer.disposeElement(this.nodeMapper.map(e), t, i.templateData, r);
  }
  disposeCompressedElements(e, t, i, r) {
    this.renderer.disposeCompressedElements && this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, r);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear(), this.disposables = bi(this.disposables);
  }
}
function Qme(n) {
  const e = n && uU(n);
  return e && Object.assign(Object.assign({}, e), { keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, e.keyboardNavigationLabelProvider), { getCompressedNodeKeyboardNavigationLabel(t) {
    return n.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(t.map((i) => i.element));
  } }) });
}
class Jme extends cU {
  constructor(e, t, i, r, o, s, a = {}) {
    super(e, t, i, o, s, a), this.compressionDelegate = r, this.compressibleNodeMapper = new ZI((l) => new rP(l)), this.filter = a.filter;
  }
  createTree(e, t, i, r, o) {
    const s = new JI(i), a = r.map((u) => new Zme(u, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event)), l = Qme(o) || {};
    return new lU(e, t, s, a, l);
  }
  asTreeElement(e, t) {
    return Object.assign({ incompressible: this.compressionDelegate.isIncompressible(e.element) }, super.asTreeElement(e, t));
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  render(e, t) {
    if (!this.identityProvider)
      return super.render(e, t);
    const i = (d) => this.identityProvider.getId(d).toString(), r = (d) => {
      const f = /* @__PURE__ */ new Set();
      for (const p of d) {
        const g = this.tree.getCompressedTreeNode(p === this.root ? null : p);
        if (g.element)
          for (const _ of g.element.elements)
            f.add(i(_.element));
      }
      return f;
    }, o = r(this.tree.getSelection()), s = r(this.tree.getFocus());
    super.render(e, t);
    const a = this.getSelection();
    let l = !1;
    const u = this.getFocus();
    let c = !1;
    const h = (d) => {
      const f = d.element;
      if (f)
        for (let p = 0; p < f.elements.length; p++) {
          const g = i(f.elements[p].element), _ = f.elements[f.elements.length - 1].element;
          o.has(g) && a.indexOf(_) === -1 && (a.push(_), l = !0), s.has(g) && u.indexOf(_) === -1 && (u.push(_), c = !0);
        }
      d.children.forEach(h);
    };
    h(this.tree.getCompressedTreeNode(e === this.root ? null : e)), l && this.setSelection(a), c && this.setFocus(u);
  }
  // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work
  // and we have to filter everything beforehand
  // Related to #85193 and #85835
  processChildren(e) {
    return this.filter && (e = Ct.filter(e, (t) => {
      const i = this.filter.filter(
        t,
        1
        /* Visible */
      ), r = eve(i);
      if (r === 2)
        throw new Error("Recursive tree visibility not supported in async data compressed trees");
      return r === 1;
    })), super.processChildren(e);
  }
}
function eve(n) {
  return typeof n == "boolean" ? n ? 1 : 0 : QI(n) ? m_(n.visibility) : m_(n);
}
class tve extends oU {
  constructor(e, t, i, r, o, s = {}) {
    super(e, t, i, r, s), this.user = e, this.dataSource = o, this.identityProvider = s.identityProvider;
  }
  createModel(e, t, i) {
    return new eP(e, t, i);
  }
}
const ive = {
  separatorBorder: ne.transparent
};
class hU {
  constructor(e, t, i, r) {
    this.container = e, this.view = t, this.disposable = r, this._cachedVisibleSize = void 0, typeof i == "number" ? (this._size = i, this._cachedVisibleSize = void 0, e.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = i.cachedVisibleSize);
  }
  set size(e) {
    this._size = e;
  }
  get size() {
    return this._size;
  }
  get visible() {
    return typeof this._cachedVisibleSize > "u";
  }
  setVisible(e, t) {
    e !== this.visible && (e ? (this.size = Fa(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof t == "number" ? t : this.size, this.size = 0), this.container.classList.toggle("visible", e), this.view.setVisible && this.view.setVisible(e));
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  get priority() {
    return this.view.priority;
  }
  get snap() {
    return !!this.view.snap;
  }
  set enabled(e) {
    this.container.style.pointerEvents = e ? "" : "none";
  }
  layout(e, t) {
    this.layoutContainer(e), this.view.layout(this.size, e, t);
  }
  dispose() {
    return this.disposable.dispose(), this.view;
  }
}
class nve extends hU {
  layoutContainer(e) {
    this.container.style.top = `${e}px`, this.container.style.height = `${this.size}px`;
  }
}
class rve extends hU {
  layoutContainer(e) {
    this.container.style.left = `${e}px`, this.container.style.width = `${this.size}px`;
  }
}
var Nu;
(function(n) {
  n[n.Idle = 0] = "Idle", n[n.Busy = 1] = "Busy";
})(Nu || (Nu = {}));
var XW;
(function(n) {
  n.Distribute = { type: "distribute" };
  function e(i) {
    return { type: "split", index: i };
  }
  n.Split = e;
  function t(i) {
    return { type: "invisible", cachedVisibleSize: i };
  }
  n.Invisible = t;
})(XW || (XW = {}));
class ove extends Ce {
  constructor(e, t = {}) {
    var i, r;
    super(), this.size = 0, this.contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.state = Nu.Idle, this._onDidSashChange = this._register(new q()), this.onDidSashChange = this._onDidSashChange.event, this._onDidSashReset = this._register(new q()), this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this.orientation = xs(t.orientation) ? 0 : t.orientation, this.inverseAltBehavior = !!t.inverseAltBehavior, this.proportionalLayout = xs(t.proportionalLayout) ? !0 : !!t.proportionalLayout, this.getSashOrthogonalSize = t.getSashOrthogonalSize, this.el = document.createElement("div"), this.el.classList.add("monaco-split-view2"), this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal"), e.appendChild(this.el), this.sashContainer = Me(this.el, Xe(".sash-container")), this.viewContainer = Xe(".split-view-container"), this.scrollable = new AE(125, Zl), this.scrollableElement = this._register(new DI(this.viewContainer, {
      vertical: this.orientation === 0 ? (i = t.scrollbarVisibility) !== null && i !== void 0 ? i : 1 : 2,
      horizontal: this.orientation === 1 ? (r = t.scrollbarVisibility) !== null && r !== void 0 ? r : 1 : 2
      /* Hidden */
    }, this.scrollable)), this.onDidScroll = this.scrollableElement.onScroll, this._register(this.onDidScroll((o) => {
      this.viewContainer.scrollTop = o.scrollTop, this.viewContainer.scrollLeft = o.scrollLeft;
    })), Me(this.el, this.scrollableElement.getDomNode()), this.style(t.styles || ive), t.descriptor && (this.size = t.descriptor.size, t.descriptor.views.forEach((o, s) => {
      const a = xs(o.visible) || o.visible ? o.size : { type: "invisible", cachedVisibleSize: o.size }, l = o.view;
      this.doAddView(l, a, s, !0);
    }), this.contentSize = this.viewItems.reduce((o, s) => o + s.size, 0), this.saveProportions());
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  set orthogonalStartSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalStartSash = e;
    this._orthogonalStartSash = e;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  set orthogonalEndSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalEndSash = e;
    this._orthogonalEndSash = e;
  }
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  set startSnappingEnabled(e) {
    this._startSnappingEnabled !== e && (this._startSnappingEnabled = e, this.updateSashEnablement());
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  set endSnappingEnabled(e) {
    this._endSnappingEnabled !== e && (this._endSnappingEnabled = e, this.updateSashEnablement());
  }
  style(e) {
    e.separatorBorder.isTransparent() ? (this.el.classList.remove("separator-border"), this.el.style.removeProperty("--separator-border")) : (this.el.classList.add("separator-border"), this.el.style.setProperty("--separator-border", e.separatorBorder.toString()));
  }
  addView(e, t, i = this.viewItems.length, r) {
    this.doAddView(e, t, i, r);
  }
  layout(e, t) {
    const i = Math.max(this.size, this.contentSize);
    if (this.size = e, this.layoutContext = t, this.proportions)
      for (let r = 0; r < this.viewItems.length; r++) {
        const o = this.viewItems[r];
        o.size = Fa(Math.round(this.proportions[r] * e), o.minimumSize, o.maximumSize);
      }
    else {
      const r = kr(this.viewItems.length), o = r.filter(
        (a) => this.viewItems[a].priority === 1
        /* Low */
      ), s = r.filter(
        (a) => this.viewItems[a].priority === 2
        /* High */
      );
      this.resize(this.viewItems.length - 1, e - i, void 0, o, s);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  saveProportions() {
    this.proportionalLayout && this.contentSize > 0 && (this.proportions = this.viewItems.map((e) => e.size / this.contentSize));
  }
  onSashStart({ sash: e, start: t, alt: i }) {
    for (const a of this.viewItems)
      a.enabled = !1;
    const r = this.sashItems.findIndex((a) => a.sash === e), o = bp(wt(document.body, "keydown")((a) => s(this.sashDragState.current, a.altKey)), wt(document.body, "keyup")(() => s(this.sashDragState.current, !1))), s = (a, l) => {
      const u = this.viewItems.map((p) => p.size);
      let c = Number.NEGATIVE_INFINITY, h = Number.POSITIVE_INFINITY;
      if (this.inverseAltBehavior && (l = !l), l)
        if (r === this.sashItems.length - 1) {
          const g = this.viewItems[r];
          c = (g.minimumSize - g.size) / 2, h = (g.maximumSize - g.size) / 2;
        } else {
          const g = this.viewItems[r + 1];
          c = (g.size - g.maximumSize) / 2, h = (g.size - g.minimumSize) / 2;
        }
      let d, f;
      if (!l) {
        const p = kr(r, -1), g = kr(r + 1, this.viewItems.length), _ = p.reduce((E, D) => E + (this.viewItems[D].minimumSize - u[D]), 0), m = p.reduce((E, D) => E + (this.viewItems[D].viewMaximumSize - u[D]), 0), v = g.length === 0 ? Number.POSITIVE_INFINITY : g.reduce((E, D) => E + (u[D] - this.viewItems[D].minimumSize), 0), C = g.length === 0 ? Number.NEGATIVE_INFINITY : g.reduce((E, D) => E + (u[D] - this.viewItems[D].viewMaximumSize), 0), y = Math.max(_, C), w = Math.min(v, m), L = this.findFirstSnapIndex(p), S = this.findFirstSnapIndex(g);
        if (typeof L == "number") {
          const E = this.viewItems[L], D = Math.floor(E.viewMinimumSize / 2);
          d = {
            index: L,
            limitDelta: E.visible ? y - D : y + D,
            size: E.size
          };
        }
        if (typeof S == "number") {
          const E = this.viewItems[S], D = Math.floor(E.viewMinimumSize / 2);
          f = {
            index: S,
            limitDelta: E.visible ? w + D : w - D,
            size: E.size
          };
        }
      }
      this.sashDragState = { start: a, current: a, index: r, sizes: u, minDelta: c, maxDelta: h, alt: l, snapBefore: d, snapAfter: f, disposable: o };
    };
    s(t, i);
  }
  onSashChange({ current: e }) {
    const { index: t, start: i, sizes: r, alt: o, minDelta: s, maxDelta: a, snapBefore: l, snapAfter: u } = this.sashDragState;
    this.sashDragState.current = e;
    const c = e - i, h = this.resize(t, c, r, void 0, void 0, s, a, l, u);
    if (o) {
      const d = t === this.sashItems.length - 1, f = this.viewItems.map((C) => C.size), p = d ? t : t + 1, g = this.viewItems[p], _ = g.size - g.maximumSize, m = g.size - g.minimumSize, v = d ? t - 1 : t + 1;
      this.resize(v, -h, f, void 0, void 0, _, m);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  onSashEnd(e) {
    this._onDidSashChange.fire(e), this.sashDragState.disposable.dispose(), this.saveProportions();
    for (const t of this.viewItems)
      t.enabled = !0;
  }
  onViewChange(e, t) {
    const i = this.viewItems.indexOf(e);
    i < 0 || i >= this.viewItems.length || (t = typeof t == "number" ? t : e.size, t = Fa(t, e.minimumSize, e.maximumSize), this.inverseAltBehavior && i > 0 ? (this.resize(i - 1, Math.floor((e.size - t) / 2)), this.distributeEmptySpace(), this.layoutViews()) : (e.size = t, this.relayout([i], void 0)));
  }
  resizeView(e, t) {
    if (this.state !== Nu.Idle)
      throw new Error("Cant modify splitview");
    if (this.state = Nu.Busy, e < 0 || e >= this.viewItems.length)
      return;
    const i = kr(this.viewItems.length).filter((a) => a !== e), r = [...i.filter(
      (a) => this.viewItems[a].priority === 1
      /* Low */
    ), e], o = i.filter(
      (a) => this.viewItems[a].priority === 2
      /* High */
    ), s = this.viewItems[e];
    t = Math.round(t), t = Fa(t, s.minimumSize, Math.min(s.maximumSize, this.size)), s.size = t, this.relayout(r, o), this.state = Nu.Idle;
  }
  distributeViewSizes() {
    const e = [];
    let t = 0;
    for (const a of this.viewItems)
      a.maximumSize - a.minimumSize > 0 && (e.push(a), t += a.size);
    const i = Math.floor(t / e.length);
    for (const a of e)
      a.size = Fa(i, a.minimumSize, a.maximumSize);
    const r = kr(this.viewItems.length), o = r.filter(
      (a) => this.viewItems[a].priority === 1
      /* Low */
    ), s = r.filter(
      (a) => this.viewItems[a].priority === 2
      /* High */
    );
    this.relayout(o, s);
  }
  getViewSize(e) {
    return e < 0 || e >= this.viewItems.length ? -1 : this.viewItems[e].size;
  }
  doAddView(e, t, i = this.viewItems.length, r) {
    if (this.state !== Nu.Idle)
      throw new Error("Cant modify splitview");
    this.state = Nu.Busy;
    const o = Xe(".split-view-view");
    i === this.viewItems.length ? this.viewContainer.appendChild(o) : this.viewContainer.insertBefore(o, this.viewContainer.children.item(i));
    const s = e.onDidChange((d) => this.onViewChange(c, d)), a = Oi(() => this.viewContainer.removeChild(o)), l = bp(s, a);
    let u;
    typeof t == "number" ? u = t : t.type === "split" ? u = this.getViewSize(t.index) / 2 : t.type === "invisible" ? u = { cachedVisibleSize: t.cachedVisibleSize } : u = e.minimumSize;
    const c = this.orientation === 0 ? new nve(o, e, u, l) : new rve(o, e, u, l);
    if (this.viewItems.splice(i, 0, c), this.viewItems.length > 1) {
      let d = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash };
      const f = this.orientation === 0 ? new ds(this.sashContainer, { getHorizontalSashTop: (E) => this.getSashPosition(E), getHorizontalSashWidth: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, d), {
        orientation: 1
        /* HORIZONTAL */
      })) : new ds(this.sashContainer, { getVerticalSashLeft: (E) => this.getSashPosition(E), getVerticalSashHeight: this.getSashOrthogonalSize }, Object.assign(Object.assign({}, d), {
        orientation: 0
        /* VERTICAL */
      })), p = this.orientation === 0 ? (E) => ({ sash: f, start: E.startY, current: E.currentY, alt: E.altKey }) : (E) => ({ sash: f, start: E.startX, current: E.currentX, alt: E.altKey }), _ = We.map(f.onDidStart, p)(this.onSashStart, this), v = We.map(f.onDidChange, p)(this.onSashChange, this), y = We.map(f.onDidEnd, () => this.sashItems.findIndex((E) => E.sash === f))(this.onSashEnd, this), w = f.onDidReset(() => {
        const E = this.sashItems.findIndex((M) => M.sash === f), D = kr(E, -1), x = kr(E + 1, this.viewItems.length), R = this.findFirstSnapIndex(D), A = this.findFirstSnapIndex(x);
        typeof R == "number" && !this.viewItems[R].visible || typeof A == "number" && !this.viewItems[A].visible || this._onDidSashReset.fire(E);
      }), L = bp(_, v, y, w, f), S = { sash: f, disposable: L };
      this.sashItems.splice(i - 1, 0, S);
    }
    o.appendChild(e.element);
    let h;
    typeof t != "number" && t.type === "split" && (h = [t.index]), r || this.relayout([i], h), this.state = Nu.Idle, !r && typeof t != "number" && t.type === "distribute" && this.distributeViewSizes();
  }
  relayout(e, t) {
    const i = this.viewItems.reduce((r, o) => r + o.size, 0);
    this.resize(this.viewItems.length - 1, this.size - i, void 0, e, t), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
  }
  resize(e, t, i = this.viewItems.map((c) => c.size), r, o, s = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, l, u) {
    if (e < 0 || e >= this.viewItems.length)
      return 0;
    const c = kr(e, -1), h = kr(e + 1, this.viewItems.length);
    if (o)
      for (const S of o)
        ED(c, S), ED(h, S);
    if (r)
      for (const S of r)
        vy(c, S), vy(h, S);
    const d = c.map((S) => this.viewItems[S]), f = c.map((S) => i[S]), p = h.map((S) => this.viewItems[S]), g = h.map((S) => i[S]), _ = c.reduce((S, E) => S + (this.viewItems[E].minimumSize - i[E]), 0), m = c.reduce((S, E) => S + (this.viewItems[E].maximumSize - i[E]), 0), v = h.length === 0 ? Number.POSITIVE_INFINITY : h.reduce((S, E) => S + (i[E] - this.viewItems[E].minimumSize), 0), C = h.length === 0 ? Number.NEGATIVE_INFINITY : h.reduce((S, E) => S + (i[E] - this.viewItems[E].maximumSize), 0), y = Math.max(_, C, s), w = Math.min(v, m, a);
    let L = !1;
    if (l) {
      const S = this.viewItems[l.index], E = t >= l.limitDelta;
      L = E !== S.visible, S.setVisible(E, l.size);
    }
    if (!L && u) {
      const S = this.viewItems[u.index], E = t < u.limitDelta;
      L = E !== S.visible, S.setVisible(E, u.size);
    }
    if (L)
      return this.resize(e, t, i, r, o, s, a);
    t = Fa(t, y, w);
    for (let S = 0, E = t; S < d.length; S++) {
      const D = d[S], x = Fa(f[S] + E, D.minimumSize, D.maximumSize), R = x - f[S];
      E -= R, D.size = x;
    }
    for (let S = 0, E = t; S < p.length; S++) {
      const D = p[S], x = Fa(g[S] - E, D.minimumSize, D.maximumSize), R = x - g[S];
      E += R, D.size = x;
    }
    return t;
  }
  distributeEmptySpace(e) {
    const t = this.viewItems.reduce((a, l) => a + l.size, 0);
    let i = this.size - t;
    const r = kr(this.viewItems.length - 1, -1), o = r.filter(
      (a) => this.viewItems[a].priority === 1
      /* Low */
    ), s = r.filter(
      (a) => this.viewItems[a].priority === 2
      /* High */
    );
    for (const a of s)
      ED(r, a);
    for (const a of o)
      vy(r, a);
    typeof e == "number" && vy(r, e);
    for (let a = 0; i !== 0 && a < r.length; a++) {
      const l = this.viewItems[r[a]], u = Fa(l.size + i, l.minimumSize, l.maximumSize), c = u - l.size;
      i -= c, l.size = u;
    }
  }
  layoutViews() {
    this.contentSize = this.viewItems.reduce((t, i) => t + i.size, 0);
    let e = 0;
    for (const t of this.viewItems)
      t.layout(e, this.layoutContext), e += t.size;
    this.sashItems.forEach((t) => t.sash.layout()), this.updateSashEnablement(), this.updateScrollableElement();
  }
  updateScrollableElement() {
    this.orientation === 0 ? this.scrollableElement.setScrollDimensions({
      height: this.size,
      scrollHeight: this.contentSize
    }) : this.scrollableElement.setScrollDimensions({
      width: this.size,
      scrollWidth: this.contentSize
    });
  }
  updateSashEnablement() {
    let e = !1;
    const t = this.viewItems.map((l) => e = l.size - l.minimumSize > 0 || e);
    e = !1;
    const i = this.viewItems.map((l) => e = l.maximumSize - l.size > 0 || e), r = [...this.viewItems].reverse();
    e = !1;
    const o = r.map((l) => e = l.size - l.minimumSize > 0 || e).reverse();
    e = !1;
    const s = r.map((l) => e = l.maximumSize - l.size > 0 || e).reverse();
    let a = 0;
    for (let l = 0; l < this.sashItems.length; l++) {
      const { sash: u } = this.sashItems[l], c = this.viewItems[l];
      a += c.size;
      const h = !(t[l] && s[l + 1]), d = !(i[l] && o[l + 1]);
      if (h && d) {
        const f = kr(l, -1), p = kr(l + 1, this.viewItems.length), g = this.findFirstSnapIndex(f), _ = this.findFirstSnapIndex(p), m = typeof g == "number" && !this.viewItems[g].visible, v = typeof _ == "number" && !this.viewItems[_].visible;
        m && o[l] && (a > 0 || this.startSnappingEnabled) ? u.state = 1 : v && t[l] && (a < this.contentSize || this.endSnappingEnabled) ? u.state = 2 : u.state = 0;
      } else
        h && !d ? u.state = 1 : !h && d ? u.state = 2 : u.state = 3;
    }
  }
  getSashPosition(e) {
    let t = 0;
    for (let i = 0; i < this.sashItems.length; i++)
      if (t += this.viewItems[i].size, this.sashItems[i].sash === e)
        return t;
    return 0;
  }
  findFirstSnapIndex(e) {
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.snap)
        return t;
    }
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.maximumSize - i.minimumSize > 0)
        return;
      if (!i.visible && i.snap)
        return t;
    }
  }
  dispose() {
    super.dispose(), this.viewItems.forEach((e) => e.dispose()), this.viewItems = [], this.sashItems.forEach((e) => e.disposable.dispose()), this.sashItems = [];
  }
}
class tC {
  constructor(e, t, i) {
    this.columns = e, this.getColumnSize = i, this.templateId = tC.TemplateId, this.renderedTemplates = /* @__PURE__ */ new Set();
    const r = new Map(t.map((o) => [o.templateId, o]));
    this.renderers = [];
    for (const o of e) {
      const s = r.get(o.templateId);
      if (!s)
        throw new Error(`Table cell renderer for template id ${o.templateId} not found.`);
      this.renderers.push(s);
    }
  }
  renderTemplate(e) {
    const t = Me(e, Xe(".monaco-table-tr")), i = [], r = [];
    for (let s = 0; s < this.columns.length; s++) {
      const a = this.renderers[s], l = Me(t, Xe(".monaco-table-td", { "data-col-index": s }));
      l.style.width = `${this.getColumnSize(s)}px`, i.push(l), r.push(a.renderTemplate(l));
    }
    const o = { container: e, cellContainers: i, cellTemplateData: r };
    return this.renderedTemplates.add(o), o;
  }
  renderElement(e, t, i, r) {
    for (let o = 0; o < this.columns.length; o++) {
      const a = this.columns[o].project(e);
      this.renderers[o].renderElement(a, t, i.cellTemplateData[o], r);
    }
  }
  disposeElement(e, t, i, r) {
    for (let o = 0; o < this.columns.length; o++) {
      const s = this.renderers[o];
      if (s.disposeElement) {
        const l = this.columns[o].project(e);
        s.disposeElement(l, t, i.cellTemplateData[o], r);
      }
    }
  }
  disposeTemplate(e) {
    for (let t = 0; t < this.columns.length; t++)
      this.renderers[t].disposeTemplate(e.cellTemplateData[t]);
    Ps(e.container), this.renderedTemplates.delete(e);
  }
  layoutColumn(e, t) {
    for (const { cellContainers: i } of this.renderedTemplates)
      i[e].style.width = `${t}px`;
  }
}
tC.TemplateId = "row";
function sve(n) {
  return {
    getHeight(e) {
      return n.getHeight(e);
    },
    getTemplateId() {
      return tC.TemplateId;
    }
  };
}
class ave {
  constructor(e, t) {
    this.column = e, this.index = t, this._onDidLayout = new q(), this.onDidLayout = this._onDidLayout.event, this.element = Xe(".monaco-table-th", { "data-col-index": t, title: e.tooltip }, e.label);
  }
  get minimumSize() {
    var e;
    return (e = this.column.minimumWidth) !== null && e !== void 0 ? e : 120;
  }
  get maximumSize() {
    var e;
    return (e = this.column.maximumWidth) !== null && e !== void 0 ? e : Number.POSITIVE_INFINITY;
  }
  get onDidChange() {
    var e;
    return (e = this.column.onDidChangeWidthConstraints) !== null && e !== void 0 ? e : We.None;
  }
  layout(e) {
    this._onDidLayout.fire([this.index, e]);
  }
}
class zE {
  constructor(e, t, i, r, o, s) {
    this.virtualDelegate = i, this.domId = `table_id_${++zE.InstanceCount}`, this.cachedHeight = 0, this.domNode = Me(t, Xe(`.monaco-table.${this.domId}`));
    const a = r.map((c, h) => new ave(c, h)), l = {
      size: a.reduce((c, h) => c + h.column.weight, 0),
      views: a.map((c) => ({ size: c.column.weight, view: c }))
    };
    this.splitview = new ove(this.domNode, {
      orientation: 1,
      scrollbarVisibility: 2,
      getSashOrthogonalSize: () => this.cachedHeight,
      descriptor: l
    }), this.splitview.el.style.height = `${i.headerRowHeight}px`, this.splitview.el.style.lineHeight = `${i.headerRowHeight}px`;
    const u = new tC(r, o, (c) => this.splitview.getViewSize(c));
    this.list = new df(e, this.domNode, sve(i), [u], s), this.columnLayoutDisposable = We.any(...a.map((c) => c.onDidLayout))(([c, h]) => u.layoutColumn(c, h)), this.styleElement = As(this.domNode), this.style({});
  }
  get onDidChangeFocus() {
    return this.list.onDidChangeFocus;
  }
  get onDidChangeSelection() {
    return this.list.onDidChangeSelection;
  }
  get onMouseDblClick() {
    return this.list.onMouseDblClick;
  }
  get onPointer() {
    return this.list.onPointer;
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  splice(e, t, i = []) {
    this.list.splice(e, t, i);
  }
  getHTMLElement() {
    return this.domNode;
  }
  style(e) {
    const t = [];
    t.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`), this.styleElement.textContent = t.join(`
`), this.list.style(e);
  }
  getSelectedElements() {
    return this.list.getSelectedElements();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getFocus() {
    return this.list.getFocus();
  }
  dispose() {
    this.splitview.dispose(), this.list.dispose(), this.columnLayoutDisposable.dispose();
  }
}
zE.InstanceCount = 0;
var ru = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, st = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
const ou = Vt("listService");
let NO = class {
  constructor(e) {
    this._themeService = e, this.disposables = new dt(), this.lists = [], this._lastFocusedWidget = void 0, this._hasCreatedStyleController = !1;
  }
  get lastFocusedList() {
    return this._lastFocusedWidget;
  }
  register(e, t) {
    if (!this._hasCreatedStyleController) {
      this._hasCreatedStyleController = !0;
      const r = new rU(As(), "");
      this.disposables.add(dg(r, this._themeService));
    }
    if (this.lists.some((r) => r.widget === e))
      throw new Error("Cannot register the same widget multiple times");
    const i = { widget: e, extraContextKeys: t };
    return this.lists.push(i), e.getHTMLElement() === document.activeElement && (this._lastFocusedWidget = e), bp(e.onDidFocus(() => this._lastFocusedWidget = e), Oi(() => this.lists.splice(this.lists.indexOf(i), 1)), e.onDidDispose(() => {
      this.lists = this.lists.filter((r) => r !== i), this._lastFocusedWidget === e && (this._lastFocusedWidget = void 0);
    }));
  }
  dispose() {
    this.disposables.dispose();
  }
};
NO = ru([
  st(0, er)
], NO);
const dU = new nt("listFocus", !0), jE = new nt("listSupportsMultiselect", !0), rbe = fr.and(dU, fr.not(Tme)), oP = new nt("listHasSelectionOrFocus", !1), sP = new nt("listDoubleSelection", !1), aP = new nt("listMultiSelection", !1), $E = new nt("listSelectionNavigation", !1), lve = new nt("listSupportsKeyboardNavigation", !0), lP = "listAutomaticKeyboardNavigation", uve = new nt(lP, !0);
let ZW = !1;
function KE(n, e) {
  const t = n.createScoped(e.getHTMLElement());
  return dU.bindTo(t), t;
}
const ff = "workbench.list.multiSelectModifier", IO = "workbench.list.openMode", Ns = "workbench.list.horizontalScrolling", gS = "workbench.list.keyboardNavigation", uP = "workbench.list.automaticKeyboardNavigation", mS = "workbench.tree.indent", vS = "workbench.tree.renderIndentGuides", nl = "workbench.list.smoothScrolling", _S = "workbench.tree.expandMode";
function Jl(n) {
  return n.getValue(ff) === "alt";
}
class cve extends Ce {
  constructor(e) {
    super(), this.configurationService = e, this.useAltAsMultipleSelectionModifier = Jl(e), this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration(ff) && (this.useAltAsMultipleSelectionModifier = Jl(this.configurationService));
    }));
  }
  isSelectionSingleChangeEvent(e) {
    return this.useAltAsMultipleSelectionModifier ? e.browserEvent.altKey : tU(e);
  }
  isSelectionRangeChangeEvent(e) {
    return iU(e);
  }
}
function qE(n, e, t) {
  const i = new dt(), r = Object.assign({}, n);
  if (n.multipleSelectionSupport !== !1 && !n.multipleSelectionController) {
    const o = new cve(e);
    r.multipleSelectionController = o, i.add(o);
  }
  return r.keyboardNavigationDelegate = {
    mightProducePrintableCharacter(o) {
      return t.mightProducePrintableCharacter(o);
    }
  }, r.smoothScrolling = !!e.getValue(nl), [r, i];
}
let PO = class extends df {
  constructor(e, t, i, r, o, s, a, l, u, c) {
    const h = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!u.getValue(Ns), [d, f] = qE(o, u, c);
    super(e, t, i, r, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, Va(l.getColorTheme(), HE)), d), { horizontalScrolling: h })), this.disposables.add(f), this.contextKeyService = KE(s, this), this.themeService = l, jE.bindTo(this.contextKeyService).set(o.multipleSelectionSupport !== !1), $E.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this.listHasSelectionOrFocus = oP.bindTo(this.contextKeyService), this.listDoubleSelection = sP.bindTo(this.contextKeyService), this.listMultiSelection = aP.bindTo(this.contextKeyService), this.horizontalScrolling = o.horizontalScrolling, this._useAltAsMultipleSelectionModifier = Jl(u), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), o.overrideStyles && this.updateStyles(o.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const _ = this.getSelection(), m = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(_.length > 0 || m.length > 0), this.listMultiSelection.set(_.length > 1), this.listDoubleSelection.set(_.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const _ = this.getSelection(), m = this.getFocus();
      this.listHasSelectionOrFocus.set(_.length > 0 || m.length > 0);
    })), this.disposables.add(u.onDidChangeConfiguration((_) => {
      _.affectsConfiguration(ff) && (this._useAltAsMultipleSelectionModifier = Jl(u));
      let m = {};
      if (_.affectsConfiguration(Ns) && this.horizontalScrolling === void 0) {
        const v = !!u.getValue(Ns);
        m = Object.assign(Object.assign({}, m), { horizontalScrolling: v });
      }
      if (_.affectsConfiguration(nl)) {
        const v = !!u.getValue(nl);
        m = Object.assign(Object.assign({}, m), { smoothScrolling: v });
      }
      Object.keys(m).length > 0 && this.updateOptions(m);
    })), this.navigator = new fU(this, Object.assign({ configurationService: u }, o)), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles);
  }
  updateStyles(e) {
    var t;
    (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = dg(this, this.themeService, e);
  }
  dispose() {
    var e;
    (e = this._styler) === null || e === void 0 || e.dispose(), super.dispose();
  }
};
PO = ru([
  st(5, xi),
  st(6, ou),
  st(7, er),
  st(8, _r),
  st(9, xo)
], PO);
let QW = class extends Rme {
  constructor(e, t, i, r, o, s, a, l, u, c) {
    const h = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!u.getValue(Ns), [d, f] = qE(o, u, c);
    super(e, t, i, r, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, Va(l.getColorTheme(), HE)), d), { horizontalScrolling: h })), this.disposables = new dt(), this.disposables.add(f), this.contextKeyService = KE(s, this), this.themeService = l, this.horizontalScrolling = o.horizontalScrolling, jE.bindTo(this.contextKeyService).set(o.multipleSelectionSupport !== !1), $E.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this._useAltAsMultipleSelectionModifier = Jl(u), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), o.overrideStyles && this.updateStyles(o.overrideStyles), o.overrideStyles && this.disposables.add(dg(this, l, o.overrideStyles)), this.disposables.add(u.onDidChangeConfiguration((_) => {
      _.affectsConfiguration(ff) && (this._useAltAsMultipleSelectionModifier = Jl(u));
      let m = {};
      if (_.affectsConfiguration(Ns) && this.horizontalScrolling === void 0) {
        const v = !!u.getValue(Ns);
        m = Object.assign(Object.assign({}, m), { horizontalScrolling: v });
      }
      if (_.affectsConfiguration(nl)) {
        const v = !!u.getValue(nl);
        m = Object.assign(Object.assign({}, m), { smoothScrolling: v });
      }
      Object.keys(m).length > 0 && this.updateOptions(m);
    })), this.navigator = new fU(this, Object.assign({ configurationService: u }, o)), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles);
  }
  updateStyles(e) {
    var t;
    (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = dg(this, this.themeService, e);
  }
  dispose() {
    var e;
    (e = this._styler) === null || e === void 0 || e.dispose(), this.disposables.dispose(), super.dispose();
  }
};
QW = ru([
  st(5, xi),
  st(6, ou),
  st(7, er),
  st(8, _r),
  st(9, xo)
], QW);
let JW = class extends zE {
  constructor(e, t, i, r, o, s, a, l, u, c, h) {
    const d = typeof s.horizontalScrolling < "u" ? s.horizontalScrolling : !!c.getValue(Ns), [f, p] = qE(s, c, h);
    super(e, t, i, r, o, Object.assign(Object.assign(Object.assign({ keyboardSupport: !1 }, Va(u.getColorTheme(), HE)), f), { horizontalScrolling: d })), this.disposables = new dt(), this.disposables.add(p), this.contextKeyService = KE(a, this), this.themeService = u, jE.bindTo(this.contextKeyService).set(s.multipleSelectionSupport !== !1), $E.bindTo(this.contextKeyService).set(!!s.selectionNavigation), this.listHasSelectionOrFocus = oP.bindTo(this.contextKeyService), this.listDoubleSelection = sP.bindTo(this.contextKeyService), this.listMultiSelection = aP.bindTo(this.contextKeyService), this.horizontalScrolling = s.horizontalScrolling, this._useAltAsMultipleSelectionModifier = Jl(c), this.disposables.add(this.contextKeyService), this.disposables.add(l.register(this)), s.overrideStyles && this.updateStyles(s.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const m = this.getSelection(), v = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(m.length > 0 || v.length > 0), this.listMultiSelection.set(m.length > 1), this.listDoubleSelection.set(m.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const m = this.getSelection(), v = this.getFocus();
      this.listHasSelectionOrFocus.set(m.length > 0 || v.length > 0);
    })), this.disposables.add(c.onDidChangeConfiguration((m) => {
      m.affectsConfiguration(ff) && (this._useAltAsMultipleSelectionModifier = Jl(c));
      let v = {};
      if (m.affectsConfiguration(Ns) && this.horizontalScrolling === void 0) {
        const C = !!c.getValue(Ns);
        v = Object.assign(Object.assign({}, v), { horizontalScrolling: C });
      }
      if (m.affectsConfiguration(nl)) {
        const C = !!c.getValue(nl);
        v = Object.assign(Object.assign({}, v), { smoothScrolling: C });
      }
      Object.keys(v).length > 0 && this.updateOptions(v);
    })), this.navigator = new hve(this, Object.assign({ configurationService: c }, s)), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles && this.updateStyles(e.overrideStyles);
  }
  updateStyles(e) {
    var t;
    (t = this._styler) === null || t === void 0 || t.dispose(), this._styler = dg(this, this.themeService, e);
  }
  dispose() {
    var e;
    (e = this._styler) === null || e === void 0 || e.dispose(), this.disposables.dispose(), super.dispose();
  }
};
JW = ru([
  st(6, xi),
  st(7, ou),
  st(8, er),
  st(9, _r),
  st(10, xo)
], JW);
class cP extends Ce {
  constructor(e, t) {
    var i;
    super(), this.widget = e, this._onDidOpen = this._register(new q()), this.onDidOpen = this._onDidOpen.event, this._register(We.filter(this.widget.onDidChangeSelection, (r) => r.browserEvent instanceof KeyboardEvent)((r) => this.onSelectionFromKeyboard(r))), this._register(this.widget.onPointer((r) => this.onPointer(r.element, r.browserEvent))), this._register(this.widget.onMouseDblClick((r) => this.onMouseDblClick(r.element, r.browserEvent))), typeof (t == null ? void 0 : t.openOnSingleClick) != "boolean" && (t != null && t.configurationService) ? (this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(IO)) !== "doubleClick", this._register(t == null ? void 0 : t.configurationService.onDidChangeConfiguration(() => {
      this.openOnSingleClick = (t == null ? void 0 : t.configurationService.getValue(IO)) !== "doubleClick";
    }))) : this.openOnSingleClick = (i = t == null ? void 0 : t.openOnSingleClick) !== null && i !== void 0 ? i : !0;
  }
  onSelectionFromKeyboard(e) {
    if (e.elements.length !== 1)
      return;
    const t = e.browserEvent, i = typeof t.preserveFocus == "boolean" ? t.preserveFocus : !0, r = typeof t.pinned == "boolean" ? t.pinned : !i, o = !1;
    this._open(this.getSelectedElement(), i, r, o, e.browserEvent);
  }
  onPointer(e, t) {
    if (!this.openOnSingleClick || t.detail === 2)
      return;
    const r = t.button === 1, o = !0, s = r, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, o, s, a, t);
  }
  onMouseDblClick(e, t) {
    if (!t)
      return;
    const i = t.target;
    if (i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && t.offsetX < 16)
      return;
    const o = !1, s = !0, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, o, s, a, t);
  }
  _open(e, t, i, r, o) {
    e && this._onDidOpen.fire({
      editorOptions: {
        preserveFocus: t,
        pinned: i,
        revealIfVisible: !0
      },
      sideBySide: r,
      element: e,
      browserEvent: o
    });
  }
}
class fU extends cP {
  constructor(e, t) {
    super(e, t), this.widget = e;
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class hve extends cP {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class dve extends cP {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    var e;
    return (e = this.widget.getSelection()[0]) !== null && e !== void 0 ? e : void 0;
  }
}
function fve(n, e) {
  let t = !1;
  return (i) => {
    if (t)
      return t = !1, !1;
    const r = e.softDispatch(i, n);
    return r && r.enterChord ? (t = !0, !1) : (t = !1, !0);
  };
}
let eV = class extends iP {
  constructor(e, t, i, r, o, s, a, l, u, c, h) {
    const { options: d, getAutomaticKeyboardNavigation: f, disposable: p } = iC(t, o, s, u, c, h);
    super(e, t, i, r, d), this.disposables.add(p), this.internals = new Xd(this, o, f, o.overrideStyles, s, a, l, u, h), this.disposables.add(this.internals);
  }
};
eV = ru([
  st(5, xi),
  st(6, ou),
  st(7, er),
  st(8, _r),
  st(9, xo),
  st(10, ks)
], eV);
let tV = class extends lU {
  constructor(e, t, i, r, o, s, a, l, u, c, h) {
    const { options: d, getAutomaticKeyboardNavigation: f, disposable: p } = iC(t, o, s, u, c, h);
    super(e, t, i, r, d), this.disposables.add(p), this.internals = new Xd(this, o, f, o.overrideStyles, s, a, l, u, h), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles);
  }
};
tV = ru([
  st(5, xi),
  st(6, ou),
  st(7, er),
  st(8, _r),
  st(9, xo),
  st(10, ks)
], tV);
let iV = class extends tve {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d) {
    const { options: f, getAutomaticKeyboardNavigation: p, disposable: g } = iC(t, s, a, c, h, d);
    super(e, t, i, r, o, f), this.disposables.add(g), this.internals = new Xd(this, s, p, s.overrideStyles, a, l, u, c, d), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles);
  }
};
iV = ru([
  st(6, xi),
  st(7, ou),
  st(8, er),
  st(9, _r),
  st(10, xo),
  st(11, ks)
], iV);
let nV = class extends cU {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d) {
    const { options: f, getAutomaticKeyboardNavigation: p, disposable: g } = iC(t, s, a, c, h, d);
    super(e, t, i, r, o, f), this.disposables.add(g), this.internals = new Xd(this, s, p, s.overrideStyles, a, l, u, c, d), this.disposables.add(this.internals);
  }
  get onDidOpen() {
    return this.internals.onDidOpen;
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles);
  }
};
nV = ru([
  st(6, xi),
  st(7, ou),
  st(8, er),
  st(9, _r),
  st(10, xo),
  st(11, ks)
], nV);
let rV = class extends Jme {
  constructor(e, t, i, r, o, s, a, l, u, c, h, d, f) {
    const { options: p, getAutomaticKeyboardNavigation: g, disposable: _ } = iC(t, a, l, h, d, f);
    super(e, t, i, r, o, s, p), this.disposables.add(_), this.internals = new Xd(this, a, g, a.overrideStyles, l, u, c, h, f), this.disposables.add(this.internals);
  }
};
rV = ru([
  st(7, xi),
  st(8, ou),
  st(9, er),
  st(10, _r),
  st(11, xo),
  st(12, ks)
], rV);
function iC(n, e, t, i, r, o) {
  var s;
  lve.bindTo(t), ZW || (uve.bindTo(t), ZW = !0);
  const a = () => {
    let p = !!t.getContextKeyValue(lP);
    return p && (p = !!i.getValue(uP)), p;
  }, l = o.isScreenReaderOptimized(), u = e.simpleKeyboardNavigation || l ? "simple" : i.getValue(gS), c = e.horizontalScrolling !== void 0 ? e.horizontalScrolling : !!i.getValue(Ns), [h, d] = qE(e, i, r), f = e.additionalScrollHeight;
  return {
    getAutomaticKeyboardNavigation: a,
    disposable: d,
    options: Object.assign(Object.assign({
      // ...options, // TODO@Joao why is this not splatted here?
      keyboardSupport: !1
    }, h), { indent: i.getValue(mS), renderIndentGuides: i.getValue(vS), smoothScrolling: !!i.getValue(nl), automaticKeyboardNavigation: a(), simpleKeyboardNavigation: u === "simple", filterOnType: u === "filter", horizontalScrolling: c, keyboardNavigationEventFilter: fve(n, r), additionalScrollHeight: f, hideTwistiesOfChildlessElements: e.hideTwistiesOfChildlessElements, expandOnlyOnTwistieClick: (s = e.expandOnlyOnTwistieClick) !== null && s !== void 0 ? s : i.getValue(_S) === "doubleClick" })
  };
}
let Xd = class {
  constructor(e, t, i, r, o, s, a, l, u) {
    this.tree = e, this.themeService = a, this.disposables = [], this.contextKeyService = KE(o, e), jE.bindTo(this.contextKeyService).set(t.multipleSelectionSupport !== !1), $E.bindTo(this.contextKeyService).set(!!t.selectionNavigation), this.hasSelectionOrFocus = oP.bindTo(this.contextKeyService), this.hasDoubleSelection = sP.bindTo(this.contextKeyService), this.hasMultiSelection = aP.bindTo(this.contextKeyService), this._useAltAsMultipleSelectionModifier = Jl(l);
    const d = /* @__PURE__ */ new Set();
    d.add(lP);
    const f = () => {
      const g = u.isScreenReaderOptimized() ? "simple" : l.getValue(gS);
      e.updateOptions({
        simpleKeyboardNavigation: g === "simple",
        filterOnType: g === "filter"
      });
    };
    this.updateStyleOverrides(r), this.disposables.push(this.contextKeyService, s.register(e), e.onDidChangeSelection(() => {
      const p = e.getSelection(), g = e.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.hasSelectionOrFocus.set(p.length > 0 || g.length > 0), this.hasMultiSelection.set(p.length > 1), this.hasDoubleSelection.set(p.length === 2);
      });
    }), e.onDidChangeFocus(() => {
      const p = e.getSelection(), g = e.getFocus();
      this.hasSelectionOrFocus.set(p.length > 0 || g.length > 0);
    }), l.onDidChangeConfiguration((p) => {
      let g = {};
      if (p.affectsConfiguration(ff) && (this._useAltAsMultipleSelectionModifier = Jl(l)), p.affectsConfiguration(mS)) {
        const _ = l.getValue(mS);
        g = Object.assign(Object.assign({}, g), { indent: _ });
      }
      if (p.affectsConfiguration(vS)) {
        const _ = l.getValue(vS);
        g = Object.assign(Object.assign({}, g), { renderIndentGuides: _ });
      }
      if (p.affectsConfiguration(nl)) {
        const _ = !!l.getValue(nl);
        g = Object.assign(Object.assign({}, g), { smoothScrolling: _ });
      }
      if (p.affectsConfiguration(gS) && f(), p.affectsConfiguration(uP) && (g = Object.assign(Object.assign({}, g), { automaticKeyboardNavigation: i() })), p.affectsConfiguration(Ns) && t.horizontalScrolling === void 0) {
        const _ = !!l.getValue(Ns);
        g = Object.assign(Object.assign({}, g), { horizontalScrolling: _ });
      }
      p.affectsConfiguration(_S) && t.expandOnlyOnTwistieClick === void 0 && (g = Object.assign(Object.assign({}, g), { expandOnlyOnTwistieClick: l.getValue(_S) === "doubleClick" })), Object.keys(g).length > 0 && e.updateOptions(g);
    }), this.contextKeyService.onDidChangeContext((p) => {
      p.affectsSome(d) && e.updateOptions({ automaticKeyboardNavigation: i() });
    }), u.onDidChangeScreenReaderOptimized(() => f())), this.navigator = new dve(e, Object.assign({ configurationService: l }, t)), this.disposables.push(this.navigator);
  }
  get onDidOpen() {
    return this.navigator.onDidOpen;
  }
  updateStyleOverrides(e) {
    bi(this.styler), this.styler = e ? dg(this.tree, this.themeService, e) : Ce.None;
  }
  dispose() {
    this.disposables = bi(this.disposables), bi(this.styler), this.styler = void 0;
  }
};
Xd = ru([
  st(4, xi),
  st(5, ou),
  st(6, er),
  st(7, _r),
  st(8, ks)
], Xd);
const pve = Jn.as(Ag.Configuration);
pve.registerConfiguration({
  id: "workbench",
  order: 7,
  title: b("workbenchConfigurationTitle", "Workbench"),
  type: "object",
  properties: {
    [ff]: {
      type: "string",
      enum: ["ctrlCmd", "alt"],
      enumDescriptions: [
        b("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
        b("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
      ],
      default: "ctrlCmd",
      description: b({
        key: "multiSelectModifier",
        comment: [
          "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
          "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
        ]
      }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
    },
    [IO]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: b({
        key: "openModeModifier",
        comment: ["`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."]
      }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [Ns]: {
      type: "boolean",
      default: !1,
      description: b("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
    },
    [mS]: {
      type: "number",
      default: 8,
      minimum: 0,
      maximum: 40,
      description: b("tree indent setting", "Controls tree indentation in pixels.")
    },
    [vS]: {
      type: "string",
      enum: ["none", "onHover", "always"],
      default: "onHover",
      description: b("render tree indent guides", "Controls whether the tree should render indent guides.")
    },
    [nl]: {
      type: "boolean",
      default: !1,
      description: b("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
    },
    [gS]: {
      type: "string",
      enum: ["simple", "highlight", "filter"],
      enumDescriptions: [
        b("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
        b("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
        b("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
      ],
      default: "highlight",
      description: b("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter.")
    },
    [uP]: {
      type: "boolean",
      default: !0,
      markdownDescription: b("automatic keyboard navigation setting", "Controls whether keyboard navigation in lists and trees is automatically triggered simply by typing. If set to `false`, keyboard navigation is only triggered when executing the `list.toggleKeyboardNavigation` command, for which you can assign a keyboard shortcut.")
    },
    [_S]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: b("expand mode", "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    }
  }
});
var ws;
(function(n) {
  n[n.Hint = 1] = "Hint", n[n.Info = 2] = "Info", n[n.Warning = 4] = "Warning", n[n.Error = 8] = "Error";
})(ws || (ws = {}));
(function(n) {
  function e(s, a) {
    return a - s;
  }
  n.compare = e;
  const t = /* @__PURE__ */ Object.create(null);
  t[n.Error] = b("sev.error", "Error"), t[n.Warning] = b("sev.warning", "Warning"), t[n.Info] = b("sev.info", "Info");
  function i(s) {
    return t[s] || "";
  }
  n.toString = i;
  function r(s) {
    switch (s) {
      case mn.Error:
        return n.Error;
      case mn.Warning:
        return n.Warning;
      case mn.Info:
        return n.Info;
      case mn.Ignore:
        return n.Hint;
    }
  }
  n.fromSeverity = r;
  function o(s) {
    switch (s) {
      case n.Error:
        return mn.Error;
      case n.Warning:
        return mn.Warning;
      case n.Info:
        return mn.Info;
      case n.Hint:
        return mn.Ignore;
    }
  }
  n.toSeverity = o;
})(ws || (ws = {}));
var oV;
(function(n) {
  const e = "";
  function t(r) {
    return i(r, !0);
  }
  n.makeKey = t;
  function i(r, o) {
    let s = [e];
    return r.source ? s.push(r.source.replace("", "\\")) : s.push(e), r.code ? typeof r.code == "string" ? s.push(r.code.replace("", "\\")) : s.push(r.code.value.replace("", "\\")) : s.push(e), r.severity !== void 0 && r.severity !== null ? s.push(ws.toString(r.severity)) : s.push(e), r.message && o ? s.push(r.message.replace("", "\\")) : s.push(e), r.startLineNumber !== void 0 && r.startLineNumber !== null ? s.push(r.startLineNumber.toString()) : s.push(e), r.startColumn !== void 0 && r.startColumn !== null ? s.push(r.startColumn.toString()) : s.push(e), r.endLineNumber !== void 0 && r.endLineNumber !== null ? s.push(r.endLineNumber.toString()) : s.push(e), r.endColumn !== void 0 && r.endColumn !== null ? s.push(r.endColumn.toString()) : s.push(e), s.push(e), s.join("");
  }
  n.makeKeyOptionalMessage = i;
})(oV || (oV = {}));
const pU = Vt("markerService");
class gve {
  constructor() {
    this._byResource = new So(), this._byOwner = /* @__PURE__ */ new Map();
  }
  set(e, t, i) {
    let r = this._byResource.get(e);
    r || (r = /* @__PURE__ */ new Map(), this._byResource.set(e, r)), r.set(t, i);
    let o = this._byOwner.get(t);
    o || (o = new So(), this._byOwner.set(t, o)), o.set(e, i);
  }
  get(e, t) {
    let i = this._byResource.get(e);
    return i == null ? void 0 : i.get(t);
  }
  delete(e, t) {
    let i = !1, r = !1, o = this._byResource.get(e);
    o && (i = o.delete(t));
    let s = this._byOwner.get(t);
    if (s && (r = s.delete(e)), i !== r)
      throw new Error("illegal state");
    return i && r;
  }
  values(e) {
    var t, i, r, o;
    return typeof e == "string" ? (i = (t = this._byOwner.get(e)) === null || t === void 0 ? void 0 : t.values()) !== null && i !== void 0 ? i : Ct.empty() : ft.isUri(e) ? (o = (r = this._byResource.get(e)) === null || r === void 0 ? void 0 : r.values()) !== null && o !== void 0 ? o : Ct.empty() : Ct.map(Ct.concat(...this._byOwner.values()), (s) => s[1]);
  }
}
class mve {
  constructor(e) {
    this.errors = 0, this.infos = 0, this.warnings = 0, this.unknowns = 0, this._data = new So(), this._service = e, this._subscription = e.onMarkerChanged(this._update, this);
  }
  dispose() {
    this._subscription.dispose();
  }
  _update(e) {
    for (const t of e) {
      const i = this._data.get(t);
      i && this._substract(i);
      const r = this._resourceStats(t);
      this._add(r), this._data.set(t, r);
    }
  }
  _resourceStats(e) {
    const t = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
    if (e.scheme === vi.inMemory || e.scheme === vi.walkThrough || e.scheme === vi.walkThroughSnippet)
      return t;
    for (const { severity: i } of this._service.read({ resource: e }))
      i === ws.Error ? t.errors += 1 : i === ws.Warning ? t.warnings += 1 : i === ws.Info ? t.infos += 1 : t.unknowns += 1;
    return t;
  }
  _substract(e) {
    this.errors -= e.errors, this.warnings -= e.warnings, this.infos -= e.infos, this.unknowns -= e.unknowns;
  }
  _add(e) {
    this.errors += e.errors, this.warnings += e.warnings, this.infos += e.infos, this.unknowns += e.unknowns;
  }
}
class Al {
  constructor() {
    this._onMarkerChanged = new q(), this.onMarkerChanged = We.debounce(this._onMarkerChanged.event, Al._debouncer, 0), this._data = new gve(), this._stats = new mve(this);
  }
  dispose() {
    this._stats.dispose(), this._onMarkerChanged.dispose();
  }
  remove(e, t) {
    for (const i of t || [])
      this.changeOne(e, i, []);
  }
  changeOne(e, t, i) {
    if (sae(i))
      this._data.delete(t, e) && this._onMarkerChanged.fire([t]);
    else {
      const r = [];
      for (const o of i) {
        const s = Al._toMarker(e, t, o);
        s && r.push(s);
      }
      this._data.set(t, e, r), this._onMarkerChanged.fire([t]);
    }
  }
  static _toMarker(e, t, i) {
    let { code: r, severity: o, message: s, source: a, startLineNumber: l, startColumn: u, endLineNumber: c, endColumn: h, relatedInformation: d, tags: f } = i;
    if (s)
      return l = l > 0 ? l : 1, u = u > 0 ? u : 1, c = c >= l ? c : l, h = h > 0 ? h : u, {
        resource: t,
        owner: e,
        code: r,
        severity: o,
        message: s,
        source: a,
        startLineNumber: l,
        startColumn: u,
        endLineNumber: c,
        endColumn: h,
        relatedInformation: d,
        tags: f
      };
  }
  read(e = /* @__PURE__ */ Object.create(null)) {
    let { owner: t, resource: i, severities: r, take: o } = e;
    if ((!o || o < 0) && (o = -1), t && i) {
      const s = this._data.get(i, t);
      if (s) {
        const a = [];
        for (const l of s)
          if (Al._accept(l, r)) {
            const u = a.push(l);
            if (o > 0 && u === o)
              break;
          }
        return a;
      } else
        return [];
    } else if (!t && !i) {
      const s = [];
      for (let a of this._data.values())
        for (let l of a)
          if (Al._accept(l, r)) {
            const u = s.push(l);
            if (o > 0 && u === o)
              return s;
          }
      return s;
    } else {
      const s = this._data.values(i ?? t), a = [];
      for (const l of s)
        for (const u of l)
          if (Al._accept(u, r)) {
            const c = a.push(u);
            if (o > 0 && c === o)
              return a;
          }
      return a;
    }
  }
  static _accept(e, t) {
    return t === void 0 || (t & e.severity) === e.severity;
  }
  static _debouncer(e, t) {
    e || (Al._dedupeMap = new So(), e = []);
    for (const i of t)
      Al._dedupeMap.has(i) || (Al._dedupeMap.set(i, !0), e.push(i));
    return e;
  }
}
var Lw = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
}, fp;
(function(n) {
  n[n.None = 0] = "None", n[n.Initialized = 1] = "Initialized", n[n.Closed = 2] = "Closed";
})(fp || (fp = {}));
class C_ extends Ce {
  constructor(e, t = /* @__PURE__ */ Object.create(null)) {
    super(), this.database = e, this.options = t, this._onDidChangeStorage = this._register(new q()), this.onDidChangeStorage = this._onDidChangeStorage.event, this.state = fp.None, this.cache = /* @__PURE__ */ new Map(), this.flushDelayer = new Pre(C_.DEFAULT_FLUSH_DELAY), this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.whenFlushedCallbacks = [], this.registerListeners();
  }
  registerListeners() {
    this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
  }
  onDidChangeItemsExternal(e) {
    var t, i;
    (t = e.changed) === null || t === void 0 || t.forEach((r, o) => this.accept(o, r)), (i = e.deleted) === null || i === void 0 || i.forEach((r) => this.accept(r, void 0));
  }
  accept(e, t) {
    if (this.state === fp.Closed)
      return;
    let i = !1;
    _s(t) ? i = this.cache.delete(e) : this.cache.get(e) !== t && (this.cache.set(e, t), i = !0), i && this._onDidChangeStorage.fire(e);
  }
  get(e, t) {
    const i = this.cache.get(e);
    return _s(i) ? t : i;
  }
  getBoolean(e, t) {
    const i = this.get(e);
    return _s(i) ? t : i === "true";
  }
  getNumber(e, t) {
    const i = this.get(e);
    return _s(i) ? t : parseInt(i, 10);
  }
  set(e, t) {
    return Lw(this, void 0, void 0, function* () {
      if (this.state === fp.Closed)
        return;
      if (_s(t))
        return this.delete(e);
      const i = String(t);
      if (this.cache.get(e) !== i)
        return this.cache.set(e, i), this.pendingInserts.set(e, i), this.pendingDeletes.delete(e), this._onDidChangeStorage.fire(e), this.flushDelayer.trigger(() => this.flushPending());
    });
  }
  delete(e) {
    return Lw(this, void 0, void 0, function* () {
      if (!(this.state === fp.Closed || !this.cache.delete(e)))
        return this.pendingDeletes.has(e) || this.pendingDeletes.add(e), this.pendingInserts.delete(e), this._onDidChangeStorage.fire(e), this.flushDelayer.trigger(() => this.flushPending());
    });
  }
  get hasPending() {
    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
  }
  flushPending() {
    return Lw(this, void 0, void 0, function* () {
      if (!this.hasPending)
        return;
      const e = { insert: this.pendingInserts, delete: this.pendingDeletes };
      return this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.database.updateItems(e).finally(() => {
        var t;
        if (!this.hasPending)
          for (; this.whenFlushedCallbacks.length; )
            (t = this.whenFlushedCallbacks.pop()) === null || t === void 0 || t();
      });
    });
  }
  dispose() {
    this.flushDelayer.cancel(), this.flushDelayer.dispose(), super.dispose();
  }
}
C_.DEFAULT_FLUSH_DELAY = 100;
class sV {
  constructor() {
    this.onDidChangeItemsExternal = We.None, this.items = /* @__PURE__ */ new Map();
  }
  updateItems(e) {
    return Lw(this, void 0, void 0, function* () {
      e.insert && e.insert.forEach((t, i) => this.items.set(i, t)), e.delete && e.delete.forEach((t) => this.items.delete(t));
    });
  }
}
const Vy = "__$__targetStorageMarker", vve = Vt("storageService");
var aV;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.SHUTDOWN = 1] = "SHUTDOWN";
})(aV || (aV = {}));
class YE extends Ce {
  constructor(e = { flushInterval: YE.DEFAULT_FLUSH_INTERVAL }) {
    super(), this.options = e, this._onDidChangeValue = this._register(new vR()), this._onDidChangeTarget = this._register(new vR()), this._onWillSaveState = this._register(new q()), this.onWillSaveState = this._onWillSaveState.event, this._workspaceKeyTargets = void 0, this._globalKeyTargets = void 0;
  }
  emitDidChangeValue(e, t) {
    t === Vy ? (e === 0 ? this._globalKeyTargets = void 0 : e === 1 && (this._workspaceKeyTargets = void 0), this._onDidChangeTarget.fire({ scope: e })) : this._onDidChangeValue.fire({ scope: e, key: t, target: this.getKeyTargets(e)[t] });
  }
  get(e, t, i) {
    var r;
    return (r = this.getStorage(t)) === null || r === void 0 ? void 0 : r.get(e, i);
  }
  getBoolean(e, t, i) {
    var r;
    return (r = this.getStorage(t)) === null || r === void 0 ? void 0 : r.getBoolean(e, i);
  }
  getNumber(e, t, i) {
    var r;
    return (r = this.getStorage(t)) === null || r === void 0 ? void 0 : r.getNumber(e, i);
  }
  store(e, t, i, r) {
    if (_s(t)) {
      this.remove(e, i);
      return;
    }
    this.withPausedEmitters(() => {
      var o;
      this.updateKeyTarget(e, i, r), (o = this.getStorage(i)) === null || o === void 0 || o.set(e, t);
    });
  }
  remove(e, t) {
    this.withPausedEmitters(() => {
      var i;
      this.updateKeyTarget(e, t, void 0), (i = this.getStorage(t)) === null || i === void 0 || i.delete(e);
    });
  }
  withPausedEmitters(e) {
    this._onDidChangeValue.pause(), this._onDidChangeTarget.pause();
    try {
      e();
    } finally {
      this._onDidChangeValue.resume(), this._onDidChangeTarget.resume();
    }
  }
  updateKeyTarget(e, t, i) {
    var r, o;
    const s = this.getKeyTargets(t);
    typeof i == "number" ? s[e] !== i && (s[e] = i, (r = this.getStorage(t)) === null || r === void 0 || r.set(Vy, JSON.stringify(s))) : typeof s[e] == "number" && (delete s[e], (o = this.getStorage(t)) === null || o === void 0 || o.set(Vy, JSON.stringify(s)));
  }
  get workspaceKeyTargets() {
    return this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(
      1
      /* WORKSPACE */
    )), this._workspaceKeyTargets;
  }
  get globalKeyTargets() {
    return this._globalKeyTargets || (this._globalKeyTargets = this.loadKeyTargets(
      0
      /* GLOBAL */
    )), this._globalKeyTargets;
  }
  getKeyTargets(e) {
    return e === 0 ? this.globalKeyTargets : this.workspaceKeyTargets;
  }
  loadKeyTargets(e) {
    const t = this.get(Vy, e);
    if (t)
      try {
        return JSON.parse(t);
      } catch {
      }
    return /* @__PURE__ */ Object.create(null);
  }
}
YE.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
class _ve extends YE {
  constructor() {
    super(), this.globalStorage = new C_(new sV()), this.workspaceStorage = new C_(new sV()), this._register(this.workspaceStorage.onDidChangeStorage((e) => this.emitDidChangeValue(1, e))), this._register(this.globalStorage.onDidChangeStorage((e) => this.emitDidChangeValue(0, e)));
  }
  getStorage(e) {
    return e === 0 ? this.globalStorage : this.workspaceStorage;
  }
}
var gU = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Dw = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let AO = class {
  constructor(e) {
    this._commandService = e;
  }
  /**
   * Create a new menu for the given menu identifier. A menu sends events when it's entries
   * have changed (placement, enablement, checked-state). By default it does send events for
   * sub menu entries. That is more expensive and must be explicitly enabled with the
   * `emitEventsForSubmenuChanges` flag.
   */
  createMenu(e, t, i = !1) {
    return new MO(e, i, this._commandService, t, this);
  }
};
AO = gU([
  Dw(0, Xo)
], AO);
let MO = class Xf {
  constructor(e, t, i, r, o) {
    this._id = e, this._fireEventsForSubmenuChanges = t, this._commandService = i, this._contextKeyService = r, this._menuService = o, this._dispoables = new dt(), this._onDidChange = new q(), this.onDidChange = this._onDidChange.event, this._menuGroups = [], this._contextKeys = /* @__PURE__ */ new Set(), this._build();
    const s = new ro(() => this._build(), 50);
    this._dispoables.add(s), this._dispoables.add(yv.onDidChangeMenu((l) => {
      l.has(e) && s.schedule();
    }));
    const a = new ro(() => this._onDidChange.fire(this), 50);
    this._dispoables.add(a), this._dispoables.add(r.onDidChangeContext((l) => {
      l.affectsSome(this._contextKeys) && a.schedule();
    }));
  }
  dispose() {
    this._dispoables.dispose(), this._onDidChange.dispose();
  }
  _build() {
    this._menuGroups.length = 0, this._contextKeys.clear();
    const e = yv.getMenuItems(this._id);
    let t;
    e.sort(Xf._compareMenuItems);
    for (let i of e) {
      const r = i.group || "";
      (!t || t[0] !== r) && (t = [r, []], this._menuGroups.push(t)), t[1].push(i), this._collectContextKeys(i);
    }
    this._onDidChange.fire(this);
  }
  _collectContextKeys(e) {
    if (Xf._fillInKbExprKeys(e.when, this._contextKeys), Qm(e)) {
      if (e.command.precondition && Xf._fillInKbExprKeys(e.command.precondition, this._contextKeys), e.command.toggled) {
        const t = e.command.toggled.condition || e.command.toggled;
        Xf._fillInKbExprKeys(t, this._contextKeys);
      }
    } else
      this._fireEventsForSubmenuChanges && yv.getMenuItems(e.submenu).forEach(this._collectContextKeys, this);
  }
  getActions(e) {
    const t = [];
    for (let i of this._menuGroups) {
      const [r, o] = i, s = [];
      for (const a of o)
        if (this._contextKeyService.contextMatchesRules(a.when)) {
          const l = Qm(a) ? new ZT(a.command, a.alt, e, this._contextKeyService, this._commandService) : new Wle(a, this._menuService, this._contextKeyService, e);
          s.push(l);
        }
      s.length > 0 && t.push([r, s]);
    }
    return t;
  }
  static _fillInKbExprKeys(e, t) {
    if (e)
      for (let i of e.keys())
        t.add(i);
  }
  static _compareMenuItems(e, t) {
    let i = e.group, r = t.group;
    if (i !== r) {
      if (i) {
        if (!r)
          return -1;
      } else
        return 1;
      if (i === "navigation")
        return -1;
      if (r === "navigation")
        return 1;
      let a = i.localeCompare(r);
      if (a !== 0)
        return a;
    }
    let o = e.order || 0, s = t.order || 0;
    return o < s ? -1 : o > s ? 1 : Xf._compareTitles(Qm(e) ? e.command.title : e.title, Qm(t) ? t.command.title : t.title);
  }
  static _compareTitles(e, t) {
    const i = typeof e == "string" ? e : e.original, r = typeof t == "string" ? t : t.original;
    return i.localeCompare(r);
  }
};
MO = gU([
  Dw(2, Xo),
  Dw(3, xi),
  Dw(4, y3)
], MO);
var Cve = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, lV = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
function $m(n) {
  return n.toString();
}
class yve extends Ce {
  constructor(e) {
    super(), this.model = e, this._markersData = /* @__PURE__ */ new Map(), this._register(Oi(() => {
      this.model.deltaDecorations([...this._markersData.keys()], []), this._markersData.clear();
    }));
  }
  update(e, t) {
    const i = [...this._markersData.keys()];
    this._markersData.clear();
    const r = this.model.deltaDecorations(i, t);
    for (let o = 0; o < r.length; o++)
      this._markersData.set(r[o], e[o]);
    return i.length !== 0 || r.length !== 0;
  }
  getMarker(e) {
    return this._markersData.get(e.id);
  }
}
let FO = class extends Ce {
  constructor(e, t) {
    super(), this._markerService = t, this._onDidChangeMarker = this._register(new q()), this._markerDecorations = /* @__PURE__ */ new Map(), e.getModels().forEach((i) => this._onModelAdded(i)), this._register(e.onModelAdded(this._onModelAdded, this)), this._register(e.onModelRemoved(this._onModelRemoved, this)), this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
  }
  dispose() {
    super.dispose(), this._markerDecorations.forEach((e) => e.dispose()), this._markerDecorations.clear();
  }
  getMarker(e, t) {
    const i = this._markerDecorations.get($m(e));
    return i && i.getMarker(t) || null;
  }
  _handleMarkerChange(e) {
    e.forEach((t) => {
      const i = this._markerDecorations.get($m(t));
      i && this._updateDecorations(i);
    });
  }
  _onModelAdded(e) {
    const t = new yve(e);
    this._markerDecorations.set($m(e.uri), t), this._updateDecorations(t);
  }
  _onModelRemoved(e) {
    const t = this._markerDecorations.get($m(e.uri));
    t && (t.dispose(), this._markerDecorations.delete($m(e.uri))), (e.uri.scheme === vi.inMemory || e.uri.scheme === vi.internal || e.uri.scheme === vi.vscode) && this._markerService && this._markerService.read({ resource: e.uri }).map((i) => i.owner).forEach((i) => this._markerService.remove(i, [e.uri]));
  }
  _updateDecorations(e) {
    const t = this._markerService.read({ resource: e.model.uri, take: 500 });
    let i = t.map((r) => ({
      range: this._createDecorationRange(e.model, r),
      options: this._createDecorationOption(r)
    }));
    e.update(t, i) && this._onDidChangeMarker.fire(e.model);
  }
  _createDecorationRange(e, t) {
    let i = G.lift(t);
    if (t.severity === ws.Hint && !this._hasMarkerTag(
      t,
      1
      /* Unnecessary */
    ) && !this._hasMarkerTag(
      t,
      2
      /* Deprecated */
    ) && (i = i.setEndPosition(i.startLineNumber, i.startColumn + 2)), i = e.validateRange(i), i.isEmpty()) {
      let r = e.getWordAtPosition(i.getStartPosition());
      if (r)
        i = new G(i.startLineNumber, r.startColumn, i.endLineNumber, r.endColumn);
      else {
        let o = e.getLineLastNonWhitespaceColumn(i.startLineNumber) || e.getLineMaxColumn(i.startLineNumber);
        o === 1 || (i.endColumn >= o ? i = new G(i.startLineNumber, o - 1, i.endLineNumber, o) : i = new G(i.startLineNumber, i.startColumn, i.endLineNumber, i.endColumn + 1));
      }
    } else if (t.endColumn === Number.MAX_VALUE && t.startColumn === 1 && i.startLineNumber === i.endLineNumber) {
      let r = e.getLineFirstNonWhitespaceColumn(t.startLineNumber);
      r < i.endColumn && (i = new G(i.startLineNumber, r, i.endLineNumber, i.endColumn), t.startColumn = r);
    }
    return i;
  }
  _createDecorationOption(e) {
    let t, i, r, o, s;
    switch (e.severity) {
      case ws.Hint:
        this._hasMarkerTag(
          e,
          2
          /* Deprecated */
        ) ? t = void 0 : this._hasMarkerTag(
          e,
          1
          /* Unnecessary */
        ) ? t = "squiggly-unnecessary" : t = "squiggly-hint", r = 0;
        break;
      case ws.Warning:
        t = "squiggly-warning", i = km(Ghe), r = 20, s = {
          color: km(She),
          position: Qp.Inline
        };
        break;
      case ws.Info:
        t = "squiggly-info", i = km(Uhe), r = 10;
        break;
      case ws.Error:
      default:
        t = "squiggly-error", i = km(Hhe), r = 30, s = {
          color: km(bhe),
          position: Qp.Inline
        };
        break;
    }
    return e.tags && (e.tags.indexOf(
      1
      /* Unnecessary */
    ) !== -1 && (o = "squiggly-inline-unnecessary"), e.tags.indexOf(
      2
      /* Deprecated */
    ) !== -1 && (o = "squiggly-inline-deprecated")), {
      description: "marker-decoration",
      stickiness: 1,
      className: t,
      showIfCollapsed: !0,
      overviewRuler: {
        color: i,
        position: Xv.Right
      },
      minimap: s,
      zIndex: r,
      inlineClassName: o
    };
  }
  _hasMarkerTag(e, t) {
    return e.tags ? e.tags.indexOf(t) >= 0 : !1;
  }
};
FO = Cve([
  lV(0, ao),
  lV(1, pU)
], FO);
var wve = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, uV = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let kO = class extends Ce {
  constructor(e, t) {
    super(), this._contextKeyService = e, this._configurationService = t, this._accessibilitySupport = 0, this._onDidChangeScreenReaderOptimized = new q(), this._accessibilityModeEnabledContext = Ife.bindTo(this._contextKeyService);
    const i = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
    this._register(this._configurationService.onDidChangeConfiguration((r) => {
      r.affectsConfiguration("editor.accessibilitySupport") && (i(), this._onDidChangeScreenReaderOptimized.fire());
    })), i(), this.onDidChangeScreenReaderOptimized(() => i());
  }
  get onDidChangeScreenReaderOptimized() {
    return this._onDidChangeScreenReaderOptimized.event;
  }
  isScreenReaderOptimized() {
    const e = this._configurationService.getValue("editor.accessibilitySupport");
    return e === "on" || e === "auto" && this._accessibilitySupport === 2;
  }
  getAccessibilitySupport() {
    return this._accessibilitySupport;
  }
};
kO = wve([
  uV(0, xi),
  uV(1, _r)
], kO);
var By = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
class bve {
  constructor() {
    this.mapTextToType = /* @__PURE__ */ new Map(), this.findText = "";
  }
  writeText(e, t) {
    return By(this, void 0, void 0, function* () {
      if (t) {
        this.mapTextToType.set(t, e);
        return;
      }
      try {
        return yield navigator.clipboard.writeText(e);
      } catch (o) {
        console.error(o);
      }
      const i = document.activeElement, r = document.body.appendChild(Xe("textarea", { "aria-hidden": !0 }));
      r.style.height = "1px", r.style.width = "1px", r.style.position = "absolute", r.value = e, r.focus(), r.select(), document.execCommand("copy"), i instanceof HTMLElement && i.focus(), document.body.removeChild(r);
    });
  }
  readText(e) {
    return By(this, void 0, void 0, function* () {
      if (e)
        return this.mapTextToType.get(e) || "";
      try {
        return yield navigator.clipboard.readText();
      } catch (t) {
        return console.error(t), "";
      }
    });
  }
  readFindText() {
    return By(this, void 0, void 0, function* () {
      return this.findText;
    });
  }
  writeFindText(e) {
    return By(this, void 0, void 0, function* () {
      this.findText = e;
    });
  }
}
var Sve = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, cV = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}, Hy = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function Gy(n) {
  return n.scheme === vi.file ? n.fsPath : n.path;
}
let mU = 0;
class Uy {
  constructor(e, t, i, r, o, s, a) {
    this.id = ++mU, this.type = 0, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabel = t, this.strResource = i, this.resourceLabels = [this.resourceLabel], this.strResources = [this.strResource], this.groupId = r, this.groupOrder = o, this.sourceId = s, this.sourceOrder = a, this.isValid = !0;
  }
  setValid(e) {
    this.isValid = e;
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class hV {
  constructor(e, t) {
    this.resourceLabel = e, this.reason = t;
  }
}
class dV {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  createMessage() {
    const e = [], t = [];
    for (const [, r] of this.elements)
      (r.reason === 0 ? e : t).push(r.resourceLabel);
    let i = [];
    return e.length > 0 && i.push(b({ key: "externalRemoval", comment: ["{0} is a list of filenames"] }, "The following files have been closed and modified on disk: {0}.", e.join(", "))), t.length > 0 && i.push(b({ key: "noParallelUniverses", comment: ["{0} is a list of filenames"] }, "The following files have been modified in an incompatible way: {0}.", t.join(", "))), i.join(`
`);
  }
  get size() {
    return this.elements.size;
  }
  has(e) {
    return this.elements.has(e);
  }
  set(e, t) {
    this.elements.set(e, t);
  }
  delete(e) {
    return this.elements.delete(e);
  }
}
class Eve {
  constructor(e, t, i, r, o, s, a) {
    this.id = ++mU, this.type = 1, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabels = t, this.strResources = i, this.groupId = r, this.groupOrder = o, this.sourceId = s, this.sourceOrder = a, this.removedResources = null, this.invalidatedResources = null;
  }
  canSplit() {
    return typeof this.actual.split == "function";
  }
  removeResource(e, t, i) {
    this.removedResources || (this.removedResources = new dV()), this.removedResources.has(t) || this.removedResources.set(t, new hV(e, i));
  }
  setValid(e, t, i) {
    i ? this.invalidatedResources && (this.invalidatedResources.delete(t), this.invalidatedResources.size === 0 && (this.invalidatedResources = null)) : (this.invalidatedResources || (this.invalidatedResources = new dV()), this.invalidatedResources.has(t) || this.invalidatedResources.set(t, new hV(
      e,
      0
      /* ExternalRemoval */
    )));
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class vU {
  constructor(e, t) {
    this.resourceLabel = e, this.strResource = t, this._past = [], this._future = [], this.locked = !1, this.versionId = 1;
  }
  dispose() {
    for (const e of this._past)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* ExternalRemoval */
      );
    for (const e of this._future)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* ExternalRemoval */
      );
    this.versionId++;
  }
  toString() {
    let e = [];
    e.push(`* ${this.strResource}:`);
    for (let t = 0; t < this._past.length; t++)
      e.push(`   * [UNDO] ${this._past[t]}`);
    for (let t = this._future.length - 1; t >= 0; t--)
      e.push(`   * [REDO] ${this._future[t]}`);
    return e.join(`
`);
  }
  flushAllElements() {
    this._past = [], this._future = [], this.versionId++;
  }
  _setElementValidFlag(e, t) {
    e.type === 1 ? e.setValid(this.resourceLabel, this.strResource, t) : e.setValid(t);
  }
  setElementsValidFlag(e, t) {
    for (const i of this._past)
      t(i.actual) && this._setElementValidFlag(i, e);
    for (const i of this._future)
      t(i.actual) && this._setElementValidFlag(i, e);
  }
  pushElement(e) {
    for (const t of this._future)
      t.type === 1 && t.removeResource(
        this.resourceLabel,
        this.strResource,
        1
        /* NoParallelUniverses */
      );
    this._future = [], this._past.push(e), this.versionId++;
  }
  createSnapshot(e) {
    const t = [];
    for (let i = 0, r = this._past.length; i < r; i++)
      t.push(this._past[i].id);
    for (let i = this._future.length - 1; i >= 0; i--)
      t.push(this._future[i].id);
    return new I7(e, t);
  }
  restoreSnapshot(e) {
    const t = e.elements.length;
    let i = !0, r = 0, o = -1;
    for (let a = 0, l = this._past.length; a < l; a++, r++) {
      const u = this._past[a];
      i && (r >= t || u.id !== e.elements[r]) && (i = !1, o = 0), !i && u.type === 1 && u.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* ExternalRemoval */
      );
    }
    let s = -1;
    for (let a = this._future.length - 1; a >= 0; a--, r++) {
      const l = this._future[a];
      i && (r >= t || l.id !== e.elements[r]) && (i = !1, s = a), !i && l.type === 1 && l.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* ExternalRemoval */
      );
    }
    o !== -1 && (this._past = this._past.slice(0, o)), s !== -1 && (this._future = this._future.slice(s + 1)), this.versionId++;
  }
  getElements() {
    const e = [], t = [];
    for (const i of this._past)
      e.push(i.actual);
    for (const i of this._future)
      t.push(i.actual);
    return { past: e, future: t };
  }
  getClosestPastElement() {
    return this._past.length === 0 ? null : this._past[this._past.length - 1];
  }
  getSecondClosestPastElement() {
    return this._past.length < 2 ? null : this._past[this._past.length - 2];
  }
  getClosestFutureElement() {
    return this._future.length === 0 ? null : this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  splitPastWorkspaceElement(e, t) {
    for (let i = this._past.length - 1; i >= 0; i--)
      if (this._past[i] === e) {
        t.has(this.strResource) ? this._past[i] = t.get(this.strResource) : this._past.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  splitFutureWorkspaceElement(e, t) {
    for (let i = this._future.length - 1; i >= 0; i--)
      if (this._future[i] === e) {
        t.has(this.strResource) ? this._future[i] = t.get(this.strResource) : this._future.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  moveBackward(e) {
    this._past.pop(), this._future.push(e), this.versionId++;
  }
  moveForward(e) {
    this._future.pop(), this._past.push(e), this.versionId++;
  }
}
class v1 {
  constructor(e) {
    this.editStacks = e, this._versionIds = [];
    for (let t = 0, i = this.editStacks.length; t < i; t++)
      this._versionIds[t] = this.editStacks[t].versionId;
  }
  isValid() {
    for (let e = 0, t = this.editStacks.length; e < t; e++)
      if (this._versionIds[e] !== this.editStacks[e].versionId)
        return !1;
    return !0;
  }
}
const _U = new vU("", "");
_U.locked = !0;
let CS = class {
  constructor(e, t) {
    this._dialogService = e, this._notificationService = t, this._editStacks = /* @__PURE__ */ new Map(), this._uriComparisonKeyComputers = [];
  }
  getUriComparisonKey(e) {
    for (const t of this._uriComparisonKeyComputers)
      if (t[0] === e.scheme)
        return t[1].getComparisonKey(e);
    return e.toString();
  }
  _print(e) {
    console.log("------------------------------------"), console.log(`AFTER ${e}: `);
    let t = [];
    for (const i of this._editStacks)
      t.push(i[1].toString());
    console.log(t.join(`
`));
  }
  pushElement(e, t = ug.None, i = Vl.None) {
    if (e.type === 0) {
      const r = Gy(e.resource), o = this.getUriComparisonKey(e.resource);
      this._pushElement(new Uy(e, r, o, t.id, t.nextOrder(), i.id, i.nextOrder()));
    } else {
      const r = /* @__PURE__ */ new Set(), o = [], s = [];
      for (const a of e.resources) {
        const l = Gy(a), u = this.getUriComparisonKey(a);
        r.has(u) || (r.add(u), o.push(l), s.push(u));
      }
      o.length === 1 ? this._pushElement(new Uy(e, o[0], s[0], t.id, t.nextOrder(), i.id, i.nextOrder())) : this._pushElement(new Eve(e, o, s, t.id, t.nextOrder(), i.id, i.nextOrder()));
    }
  }
  _pushElement(e) {
    for (let t = 0, i = e.strResources.length; t < i; t++) {
      const r = e.resourceLabels[t], o = e.strResources[t];
      let s;
      this._editStacks.has(o) ? s = this._editStacks.get(o) : (s = new vU(r, o), this._editStacks.set(o, s)), s.pushElement(e);
    }
  }
  getLastElement(e) {
    const t = this.getUriComparisonKey(e);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      if (i.hasFutureElements())
        return null;
      const r = i.getClosestPastElement();
      return r ? r.actual : null;
    }
    return null;
  }
  _splitPastWorkspaceElement(e, t) {
    const i = e.actual.split(), r = /* @__PURE__ */ new Map();
    for (const o of i) {
      const s = Gy(o.resource), a = this.getUriComparisonKey(o.resource), l = new Uy(o, s, a, 0, 0, 0, 0);
      r.set(l.strResource, l);
    }
    for (const o of e.strResources) {
      if (t && t.has(o))
        continue;
      this._editStacks.get(o).splitPastWorkspaceElement(e, r);
    }
  }
  _splitFutureWorkspaceElement(e, t) {
    const i = e.actual.split(), r = /* @__PURE__ */ new Map();
    for (const o of i) {
      const s = Gy(o.resource), a = this.getUriComparisonKey(o.resource), l = new Uy(o, s, a, 0, 0, 0, 0);
      r.set(l.strResource, l);
    }
    for (const o of e.strResources) {
      if (t && t.has(o))
        continue;
      this._editStacks.get(o).splitFutureWorkspaceElement(e, r);
    }
  }
  removeElements(e) {
    const t = typeof e == "string" ? e : this.getUriComparisonKey(e);
    this._editStacks.has(t) && (this._editStacks.get(t).dispose(), this._editStacks.delete(t));
  }
  setElementsValidFlag(e, t, i) {
    const r = this.getUriComparisonKey(e);
    this._editStacks.has(r) && this._editStacks.get(r).setElementsValidFlag(t, i);
  }
  createSnapshot(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).createSnapshot(e) : new I7(e, []);
  }
  restoreSnapshot(e) {
    const t = this.getUriComparisonKey(e.resource);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      i.restoreSnapshot(e), !i.hasPastElements() && !i.hasFutureElements() && (i.dispose(), this._editStacks.delete(t));
    }
  }
  getElements(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).getElements() : { past: [], future: [] };
  }
  _findClosestUndoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [r, o] of this._editStacks) {
      const s = o.getClosestPastElement();
      s && s.sourceId === e && (!t || s.sourceOrder > t.sourceOrder) && (t = s, i = r);
    }
    return [t, i];
  }
  canUndo(e) {
    if (e instanceof Vl) {
      const [, i] = this._findClosestUndoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasPastElements() : !1;
  }
  _onError(e, t) {
    Pi(e);
    for (const i of t.strResources)
      this.removeElements(i);
    this._notificationService.error(e);
  }
  _acquireLocks(e) {
    for (const t of e.editStacks)
      if (t.locked)
        throw new Error("Cannot acquire edit stack lock");
    for (const t of e.editStacks)
      t.locked = !0;
    return () => {
      for (const t of e.editStacks)
        t.locked = !1;
    };
  }
  _safeInvokeWithLocks(e, t, i, r, o) {
    const s = this._acquireLocks(i);
    let a;
    try {
      a = t();
    } catch (l) {
      return s(), r.dispose(), this._onError(l, e);
    }
    return a ? a.then(() => (s(), r.dispose(), o()), (l) => (s(), r.dispose(), this._onError(l, e))) : (s(), r.dispose(), o());
  }
  _invokeWorkspacePrepare(e) {
    return Hy(this, void 0, void 0, function* () {
      if (typeof e.actual.prepareUndoRedo > "u")
        return Ce.None;
      const t = e.actual.prepareUndoRedo();
      return typeof t > "u" ? Ce.None : t;
    });
  }
  _invokeResourcePrepare(e, t) {
    if (e.actual.type !== 1 || typeof e.actual.prepareUndoRedo > "u")
      return t(Ce.None);
    const i = e.actual.prepareUndoRedo();
    return i ? Yne(i) ? t(i) : i.then((r) => t(r)) : t(Ce.None);
  }
  _getAffectedEditStacks(e) {
    const t = [];
    for (const i of e.strResources)
      t.push(this._editStacks.get(i) || _U);
    return new v1(t);
  }
  _tryToSplitAndUndo(e, t, i, r) {
    if (t.canSplit())
      return this._splitPastWorkspaceElement(t, i), this._notificationService.warn(r), new zy(this._undo(e, 0, !0));
    for (const o of t.strResources)
      this.removeElements(o);
    return this._notificationService.warn(r), new zy();
  }
  _checkWorkspaceUndo(e, t, i, r) {
    if (t.removedResources)
      return this._tryToSplitAndUndo(e, t, t.removedResources, b({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (r && t.invalidatedResources)
      return this._tryToSplitAndUndo(e, t, t.invalidatedResources, b({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const o = [];
    for (const a of i.editStacks)
      a.getClosestPastElement() !== t && o.push(a.resourceLabel);
    if (o.length > 0)
      return this._tryToSplitAndUndo(e, t, null, b({ key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
    const s = [];
    for (const a of i.editStacks)
      a.locked && s.push(a.resourceLabel);
    return s.length > 0 ? this._tryToSplitAndUndo(e, t, null, b({ key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, s.join(", "))) : i.isValid() ? null : this._tryToSplitAndUndo(e, t, null, b({ key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceUndo(e, t, i) {
    const r = this._getAffectedEditStacks(t), o = this._checkWorkspaceUndo(
      e,
      t,
      r,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return o ? o.returnValue : this._confirmAndExecuteWorkspaceUndo(e, t, r, i);
  }
  _isPartOfUndoGroup(e) {
    if (!e.groupId)
      return !1;
    for (const [, t] of this._editStacks) {
      const i = t.getClosestPastElement();
      if (i) {
        if (i === e) {
          const r = t.getSecondClosestPastElement();
          if (r && r.groupId === e.groupId)
            return !0;
        }
        if (i.groupId === e.groupId)
          return !0;
      }
    }
    return !1;
  }
  _confirmAndExecuteWorkspaceUndo(e, t, i, r) {
    return Hy(this, void 0, void 0, function* () {
      if (t.canSplit() && !this._isPartOfUndoGroup(t)) {
        const a = yield this._dialogService.show(mn.Info, b("confirmWorkspace", "Would you like to undo '{0}' across all files?", t.label), [
          b({ key: "ok", comment: ["{0} denotes a number that is > 1"] }, "Undo in {0} Files", i.editStacks.length),
          b("nok", "Undo this File"),
          b("cancel", "Cancel")
        ], {
          cancelId: 2
        });
        if (a.choice === 2)
          return;
        if (a.choice === 1)
          return this._splitPastWorkspaceElement(t, null), this._undo(e, 0, !0);
        const l = this._checkWorkspaceUndo(
          e,
          t,
          i,
          /*invalidated resources will be checked after the prepare call*/
          !1
        );
        if (l)
          return l.returnValue;
        r = !0;
      }
      let o;
      try {
        o = yield this._invokeWorkspacePrepare(t);
      } catch (a) {
        return this._onError(a, t);
      }
      const s = this._checkWorkspaceUndo(
        e,
        t,
        i,
        /*now also check that there are no more invalidated resources*/
        !0
      );
      if (s)
        return o.dispose(), s.returnValue;
      for (const a of i.editStacks)
        a.moveBackward(t);
      return this._safeInvokeWithLocks(t, () => t.actual.undo(), i, o, () => this._continueUndoInGroup(t.groupId, r));
    });
  }
  _resourceUndo(e, t, i) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const r = b({ key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not undo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(r);
      return;
    }
    return this._invokeResourcePrepare(t, (r) => (e.moveBackward(t), this._safeInvokeWithLocks(t, () => t.actual.undo(), new v1([e]), r, () => this._continueUndoInGroup(t.groupId, i))));
  }
  _findClosestUndoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [r, o] of this._editStacks) {
      const s = o.getClosestPastElement();
      s && s.groupId === e && (!t || s.groupOrder > t.groupOrder) && (t = s, i = r);
    }
    return [t, i];
  }
  _continueUndoInGroup(e, t) {
    if (!e)
      return;
    const [, i] = this._findClosestUndoElementInGroup(e);
    if (i)
      return this._undo(i, 0, t);
  }
  undo(e) {
    if (e instanceof Vl) {
      const [, t] = this._findClosestUndoElementWithSource(e.id);
      return t ? this._undo(t, e.id, !1) : void 0;
    }
    return typeof e == "string" ? this._undo(e, 0, !1) : this._undo(this.getUriComparisonKey(e), 0, !1);
  }
  _undo(e, t = 0, i) {
    if (!this._editStacks.has(e))
      return;
    const r = this._editStacks.get(e), o = r.getClosestPastElement();
    if (!o)
      return;
    if (o.groupId) {
      const [a, l] = this._findClosestUndoElementInGroup(o.groupId);
      if (o !== a && l)
        return this._undo(l, t, i);
    }
    if ((o.sourceId !== t || o.confirmBeforeUndo) && !i)
      return this._confirmAndContinueUndo(e, t, o);
    try {
      return o.type === 1 ? this._workspaceUndo(e, o, i) : this._resourceUndo(r, o, i);
    } finally {
    }
  }
  _confirmAndContinueUndo(e, t, i) {
    return Hy(this, void 0, void 0, function* () {
      if ((yield this._dialogService.show(mn.Info, b("confirmDifferentSource", "Would you like to undo '{0}'?", i.label), [
        b("confirmDifferentSource.ok", "Undo"),
        b("cancel", "Cancel")
      ], {
        cancelId: 1
      })).choice !== 1)
        return this._undo(e, t, !0);
    });
  }
  _findClosestRedoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [r, o] of this._editStacks) {
      const s = o.getClosestFutureElement();
      s && s.sourceId === e && (!t || s.sourceOrder < t.sourceOrder) && (t = s, i = r);
    }
    return [t, i];
  }
  canRedo(e) {
    if (e instanceof Vl) {
      const [, i] = this._findClosestRedoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasFutureElements() : !1;
  }
  _tryToSplitAndRedo(e, t, i, r) {
    if (t.canSplit())
      return this._splitFutureWorkspaceElement(t, i), this._notificationService.warn(r), new zy(this._redo(e));
    for (const o of t.strResources)
      this.removeElements(o);
    return this._notificationService.warn(r), new zy();
  }
  _checkWorkspaceRedo(e, t, i, r) {
    if (t.removedResources)
      return this._tryToSplitAndRedo(e, t, t.removedResources, b({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (r && t.invalidatedResources)
      return this._tryToSplitAndRedo(e, t, t.invalidatedResources, b({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const o = [];
    for (const a of i.editStacks)
      a.getClosestFutureElement() !== t && o.push(a.resourceLabel);
    if (o.length > 0)
      return this._tryToSplitAndRedo(e, t, null, b({ key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
    const s = [];
    for (const a of i.editStacks)
      a.locked && s.push(a.resourceLabel);
    return s.length > 0 ? this._tryToSplitAndRedo(e, t, null, b({ key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, s.join(", "))) : i.isValid() ? null : this._tryToSplitAndRedo(e, t, null, b({ key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceRedo(e, t) {
    const i = this._getAffectedEditStacks(t), r = this._checkWorkspaceRedo(
      e,
      t,
      i,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return r ? r.returnValue : this._executeWorkspaceRedo(e, t, i);
  }
  _executeWorkspaceRedo(e, t, i) {
    return Hy(this, void 0, void 0, function* () {
      let r;
      try {
        r = yield this._invokeWorkspacePrepare(t);
      } catch (s) {
        return this._onError(s, t);
      }
      const o = this._checkWorkspaceRedo(
        e,
        t,
        i,
        /*now also check that there are no more invalidated resources*/
        !0
      );
      if (o)
        return r.dispose(), o.returnValue;
      for (const s of i.editStacks)
        s.moveForward(t);
      return this._safeInvokeWithLocks(t, () => t.actual.redo(), i, r, () => this._continueRedoInGroup(t.groupId));
    });
  }
  _resourceRedo(e, t) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const i = b({ key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not redo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(i);
      return;
    }
    return this._invokeResourcePrepare(t, (i) => (e.moveForward(t), this._safeInvokeWithLocks(t, () => t.actual.redo(), new v1([e]), i, () => this._continueRedoInGroup(t.groupId))));
  }
  _findClosestRedoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [r, o] of this._editStacks) {
      const s = o.getClosestFutureElement();
      s && s.groupId === e && (!t || s.groupOrder < t.groupOrder) && (t = s, i = r);
    }
    return [t, i];
  }
  _continueRedoInGroup(e) {
    if (!e)
      return;
    const [, t] = this._findClosestRedoElementInGroup(e);
    if (t)
      return this._redo(t);
  }
  redo(e) {
    if (e instanceof Vl) {
      const [, t] = this._findClosestRedoElementWithSource(e.id);
      return t ? this._redo(t) : void 0;
    }
    return typeof e == "string" ? this._redo(e) : this._redo(this.getUriComparisonKey(e));
  }
  _redo(e) {
    if (!this._editStacks.has(e))
      return;
    const t = this._editStacks.get(e), i = t.getClosestFutureElement();
    if (i) {
      if (i.groupId) {
        const [r, o] = this._findClosestRedoElementInGroup(i.groupId);
        if (i !== r && o)
          return this._redo(o);
      }
      try {
        return i.type === 1 ? this._workspaceRedo(e, i) : this._resourceRedo(t, i);
      } finally {
      }
    }
  }
};
CS = Sve([
  cV(0, J7),
  cV(1, al)
], CS);
class zy {
  constructor(e) {
    this.returnValue = e;
  }
}
g7(VI, CS);
const Lve = { ctrlCmd: !1, alt: !1 };
var y_;
(function(n) {
  n[n.Blur = 1] = "Blur", n[n.Gesture = 2] = "Gesture", n[n.Other = 3] = "Other";
})(y_ || (y_ = {}));
var ka;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.FIRST = 1] = "FIRST", n[n.SECOND = 2] = "SECOND", n[n.LAST = 3] = "LAST";
})(ka || (ka = {}));
const fV = new QG(() => {
  const n = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" });
  return {
    collator: n,
    collatorIsNumeric: n.resolvedOptions().numeric
  };
});
function Dve(n, e, t = !1) {
  const i = n || "", r = e || "", o = fV.value.collator.compare(i, r);
  return fV.value.collatorIsNumeric && o === 0 && i !== r ? i < r ? -1 : 1 : o;
}
function Rve(n, e, t) {
  const i = n.toLowerCase(), r = e.toLowerCase(), o = Tve(n, e, t);
  if (o)
    return o;
  const s = i.endsWith(t), a = r.endsWith(t);
  if (s !== a)
    return s ? -1 : 1;
  const l = Dve(i, r);
  return l !== 0 ? l : i.localeCompare(r);
}
function Tve(n, e, t) {
  const i = n.toLowerCase(), r = e.toLowerCase(), o = i.startsWith(t), s = r.startsWith(t);
  if (o !== s)
    return o ? -1 : 1;
  if (o && s) {
    if (i.length < r.length)
      return -1;
    if (i.length > r.length)
      return 1;
  }
  return 0;
}
const Ove = new RegExp(`(\\\\)?\\$\\((${Go.iconNameExpression}(?:${Go.iconModifierExpression})?)\\)`, "g");
function Iv(n) {
  const e = new Array();
  let t, i = 0, r = 0;
  for (; (t = Ove.exec(n)) !== null; ) {
    r = t.index || 0, e.push(n.substring(i, r)), i = (t.index || 0) + t[0].length;
    const [, o, s] = t;
    e.push(o ? `$(${s})` : xve({ id: s }));
  }
  return i < n.length && e.push(n.substring(i)), e;
}
function xve(n) {
  const e = Xe("span");
  return e.classList.add(...Go.asClassNameArray(n)), e;
}
class Zd {
  constructor(e, t) {
    this.supportIcons = t, this.text = "", this.title = "", this.highlights = [], this.didEverRender = !1, this.domNode = document.createElement("span"), this.domNode.className = "monaco-highlighted-label", e.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(e, t = [], i = "", r) {
    e || (e = ""), r && (e = Zd.escapeNewLines(e, t)), !(this.didEverRender && this.text === e && this.title === i && qu(this.highlights, t)) && (this.text = e, this.title = i, this.highlights = t, this.render());
  }
  render() {
    const e = [];
    let t = 0;
    for (const i of this.highlights) {
      if (i.end === i.start)
        continue;
      if (t < i.start) {
        const s = this.text.substring(t, i.start);
        e.push(Xe("span", void 0, ...this.supportIcons ? Iv(s) : [s])), t = i.end;
      }
      const r = this.text.substring(i.start, i.end), o = Xe("span.highlight", void 0, ...this.supportIcons ? Iv(r) : [r]);
      i.extraClasses && o.classList.add(i.extraClasses), e.push(o), t = i.end;
    }
    if (t < this.text.length) {
      const i = this.text.substring(t);
      e.push(Xe("span", void 0, ...this.supportIcons ? Iv(i) : [i]));
    }
    nE(this.domNode, ...e), this.title ? this.domNode.title = this.title : this.domNode.removeAttribute("title"), this.didEverRender = !0;
  }
  static escapeNewLines(e, t) {
    let i = 0, r = 0;
    return e.replace(/\r\n|\r|\n/g, (o, s) => {
      r = o === `\r
` ? -1 : 0, s += i;
      for (const a of t)
        a.end <= s || (a.start >= s && (a.start += r), a.end >= s && (a.end += r));
      return i += r, "";
    });
  }
}
var WO = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function Nve(n, e) {
  il(e) ? n.title = e : e != null && e.markdownNotSupportedFallback ? n.title = e.markdownNotSupportedFallback : n.removeAttribute("title");
}
function Ive(n, e, t) {
  if (!t)
    return;
  const i = Pve(t);
  let r, o, s = !1, a, l;
  const u = new Dr(e, Ge.MOUSE_OVER, !0);
  return u.event((c) => {
    if (s)
      return;
    a = new mh();
    function h(_) {
      const m = _.type === Ge.MOUSE_DOWN;
      m && (l == null || l.dispose(), l = void 0), (m || _.fromElement === e) && (s = !1, r = void 0, a.dispose(!0), d.dispose(), f.dispose());
    }
    const d = new Dr(e, Ge.MOUSE_LEAVE, !0);
    d.event(h);
    const f = new Dr(e, Ge.MOUSE_DOWN, !0);
    f.event(h), s = !0;
    function p(_) {
      o = _.x;
    }
    const g = new Dr(e, Ge.MOUSE_MOVE, !0);
    g.event(p), setTimeout(() => WO(this, void 0, void 0, function* () {
      var _;
      if (s && i && !r) {
        const m = {
          targetElements: [e],
          dispose: () => {
          }
        };
        r = {
          text: b("iconLabel.loading", "Loading..."),
          target: m,
          hoverPosition: 2
          /* BELOW */
        }, l = pV(r, o, n, s);
        const v = (_ = yield i(a.token)) !== null && _ !== void 0 ? _ : il(t) ? void 0 : t.markdownNotSupportedFallback;
        v ? (r = {
          text: v,
          target: m,
          showPointer: n.placement === "element",
          hoverPosition: 2
          /* BELOW */
        }, l = pV(r, o, n, s)) : l && (l.dispose(), l = void 0);
      }
      g.dispose();
    }), n.delay);
  }), u;
}
function Pve(n) {
  if (il(n))
    return () => WO(this, void 0, void 0, function* () {
      return n;
    });
  if (pv(n.markdown))
    return n.markdown;
  {
    const e = n.markdown;
    return () => WO(this, void 0, void 0, function* () {
      return e;
    });
  }
}
function pV(n, e, t, i) {
  if (n && i)
    return e !== void 0 && (t.placement === void 0 || t.placement === "mouse") && (n.target.x = e + 10), t.showHover(n);
}
class _1 {
  constructor(e) {
    this._element = e;
  }
  get element() {
    return this._element;
  }
  set textContent(e) {
    this.disposed || e === this._textContent || (this._textContent = e, this._element.textContent = e);
  }
  set className(e) {
    this.disposed || e === this._className || (this._className = e, this._element.className = e);
  }
  set empty(e) {
    this.disposed || e === this._empty || (this._empty = e, this._element.style.marginLeft = e ? "0" : "");
  }
  dispose() {
    this.disposed = !0;
  }
}
class Ave extends Ce {
  constructor(e, t) {
    super(), this.customHovers = /* @__PURE__ */ new Map(), this.domNode = this._register(new _1(Me(e, Xe(".monaco-icon-label")))), this.labelContainer = Me(this.domNode.element, Xe(".monaco-icon-label-container"));
    const i = Me(this.labelContainer, Xe("span.monaco-icon-name-container"));
    this.descriptionContainer = this._register(new _1(Me(this.labelContainer, Xe("span.monaco-icon-description-container")))), t != null && t.supportHighlights || t != null && t.supportIcons ? this.nameNode = new kve(i, !!t.supportIcons) : this.nameNode = new Mve(i), t != null && t.supportDescriptionHighlights ? this.descriptionNodeFactory = () => new Zd(Me(this.descriptionContainer.element, Xe("span.label-description")), !!t.supportIcons) : this.descriptionNodeFactory = () => this._register(new _1(Me(this.descriptionContainer.element, Xe("span.label-description")))), this.hoverDelegate = t == null ? void 0 : t.hoverDelegate;
  }
  setLabel(e, t, i) {
    const r = ["monaco-icon-label"];
    i && (i.extraClasses && r.push(...i.extraClasses), i.italic && r.push("italic"), i.strikethrough && r.push("strikethrough")), this.domNode.className = r.join(" "), this.setupHover(this.labelContainer, i == null ? void 0 : i.title), this.nameNode.setLabel(e, i), (t || this.descriptionNode) && (this.descriptionNode || (this.descriptionNode = this.descriptionNodeFactory()), this.descriptionNode instanceof Zd ? (this.descriptionNode.set(t || "", i ? i.descriptionMatches : void 0), this.setupHover(this.descriptionNode.element, i == null ? void 0 : i.descriptionTitle)) : (this.descriptionNode.textContent = t || "", this.setupHover(this.descriptionNode.element, (i == null ? void 0 : i.descriptionTitle) || ""), this.descriptionNode.empty = !t));
  }
  setupHover(e, t) {
    const i = this.customHovers.get(e);
    if (i && (i.dispose(), this.customHovers.delete(e)), !t) {
      e.removeAttribute("title");
      return;
    }
    if (!this.hoverDelegate)
      Nve(e, t);
    else {
      const r = Ive(this.hoverDelegate, e, t);
      r && this.customHovers.set(e, r);
    }
  }
  dispose() {
    super.dispose();
    for (const e of this.customHovers.values())
      e.dispose();
    this.customHovers.clear();
  }
}
class Mve {
  constructor(e) {
    this.container = e, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && qu(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = Me(this.container, Xe("a.label-name", { id: t == null ? void 0 : t.domId }))), this.singleLabel.textContent = e;
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        for (let i = 0; i < e.length; i++) {
          const r = e[i], o = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${i}`;
          Me(this.container, Xe("a.label-name", { id: o, "data-icon-label-count": e.length, "data-icon-label-index": i, role: "treeitem" }, r)), i < e.length - 1 && Me(this.container, Xe("span.label-separator", void 0, (t == null ? void 0 : t.separator) || "/"));
        }
      }
  }
}
function Fve(n, e, t) {
  if (!t)
    return;
  let i = 0;
  return n.map((r) => {
    const o = { start: i, end: i + r.length }, s = t.map((a) => cr.intersect(o, a)).filter((a) => !cr.isEmpty(a)).map(({ start: a, end: l }) => ({ start: a - i, end: l - i }));
    return i = o.end + e.length, s;
  });
}
class kve {
  constructor(e, t) {
    this.container = e, this.supportIcons = t, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && qu(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = new Zd(Me(this.container, Xe("a.label-name", { id: t == null ? void 0 : t.domId })), this.supportIcons)), this.singleLabel.set(e, t == null ? void 0 : t.matches, void 0, t == null ? void 0 : t.labelEscapeNewLines);
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        const i = (t == null ? void 0 : t.separator) || "/", r = Fve(e, i, t == null ? void 0 : t.matches);
        for (let o = 0; o < e.length; o++) {
          const s = e[o], a = r ? r[o] : void 0, l = (t == null ? void 0 : t.domId) && `${t == null ? void 0 : t.domId}_${o}`, u = Xe("a.label-name", { id: l, "data-icon-label-count": e.length, "data-icon-label-index": o, role: "treeitem" });
          new Zd(Me(this.container, u), this.supportIcons).set(s, a, void 0, t == null ? void 0 : t.labelEscapeNewLines), o < e.length - 1 && Me(u, Xe("span.label-separator", void 0, i));
        }
      }
  }
}
class CU {
  constructor(e) {
    this._prefix = e, this._lastId = 0;
  }
  nextId() {
    return this._prefix + ++this._lastId;
  }
}
const _be = new CU("id#"), C1 = {}, Wve = new CU("quick-input-button-icon-");
function VO(n) {
  if (!n)
    return;
  let e;
  const t = n.dark.toString();
  return C1[t] ? e = C1[t] : (e = Wve.nextId(), ik(`.${e}`, `background-image: ${qv(n.light || n.dark)}`), ik(`.vs-dark .${e}, .hc-black .${e}`, `background-image: ${qv(n.dark)}`), C1[t] = e), e;
}
const jy = Xe;
class hP {
  constructor(e, t, i) {
    this.os = t, this.keyElements = /* @__PURE__ */ new Set(), this.options = i || /* @__PURE__ */ Object.create(null), this.labelBackground = this.options.keybindingLabelBackground, this.labelForeground = this.options.keybindingLabelForeground, this.labelBorder = this.options.keybindingLabelBorder, this.labelBottomBorder = this.options.keybindingLabelBottomBorder, this.labelShadow = this.options.keybindingLabelShadow, this.domNode = Me(e, jy(".monaco-keybinding")), this.didEverRender = !1, e.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(e, t) {
    this.didEverRender && this.keybinding === e && hP.areSame(this.matches, t) || (this.keybinding = e, this.matches = t, this.render());
  }
  render() {
    if (this.clear(), this.keybinding) {
      let [e, t] = this.keybinding.getParts();
      e && this.renderPart(this.domNode, e, this.matches ? this.matches.firstPart : null), t && (Me(this.domNode, jy("span.monaco-keybinding-key-chord-separator", void 0, " ")), this.renderPart(this.domNode, t, this.matches ? this.matches.chordPart : null)), this.domNode.title = this.keybinding.getAriaLabel() || "";
    } else
      this.options && this.options.renderUnboundKeybindings && this.renderUnbound(this.domNode);
    this.applyStyles(), this.didEverRender = !0;
  }
  clear() {
    Ps(this.domNode), this.keyElements.clear();
  }
  renderPart(e, t, i) {
    const r = u3.modifierLabels[this.os];
    t.ctrlKey && this.renderKey(e, r.ctrlKey, !!(i != null && i.ctrlKey), r.separator), t.shiftKey && this.renderKey(e, r.shiftKey, !!(i != null && i.shiftKey), r.separator), t.altKey && this.renderKey(e, r.altKey, !!(i != null && i.altKey), r.separator), t.metaKey && this.renderKey(e, r.metaKey, !!(i != null && i.metaKey), r.separator);
    const o = t.keyLabel;
    o && this.renderKey(e, o, !!(i != null && i.keyCode), "");
  }
  renderKey(e, t, i, r) {
    Me(e, this.createKeyElement(t, i ? ".highlight" : "")), r && Me(e, jy("span.monaco-keybinding-key-separator", void 0, r));
  }
  renderUnbound(e) {
    Me(e, this.createKeyElement(b("unbound", "Unbound")));
  }
  createKeyElement(e, t = "") {
    const i = jy("span.monaco-keybinding-key" + t, void 0, e);
    return this.keyElements.add(i), i;
  }
  style(e) {
    this.labelBackground = e.keybindingLabelBackground, this.labelForeground = e.keybindingLabelForeground, this.labelBorder = e.keybindingLabelBorder, this.labelBottomBorder = e.keybindingLabelBottomBorder, this.labelShadow = e.keybindingLabelShadow, this.applyStyles();
  }
  applyStyles() {
    var e;
    if (this.element) {
      for (const t of this.keyElements)
        this.labelBackground && (t.style.backgroundColor = (e = this.labelBackground) === null || e === void 0 ? void 0 : e.toString()), this.labelBorder && (t.style.borderColor = this.labelBorder.toString()), this.labelBottomBorder && (t.style.borderBottomColor = this.labelBottomBorder.toString()), this.labelShadow && (t.style.boxShadow = `inset 0 -1px 0 ${this.labelShadow}`);
      this.labelForeground && (this.element.style.color = this.labelForeground.toString());
    }
  }
  static areSame(e, t) {
    return e === t || !e && !t ? !0 : !!e && !!t && qu(e.firstPart, t.firstPart) && qu(e.chordPart, t.chordPart);
  }
}
var yU = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, Vve = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
const Il = Xe;
class Bve {
  constructor(e) {
    this.hidden = !1, this._onChecked = new q(), this.onChecked = this._onChecked.event, Object.assign(this, e);
  }
  get checked() {
    return !!this._checked;
  }
  set checked(e) {
    e !== this._checked && (this._checked = e, this._onChecked.fire(e));
  }
  dispose() {
    this._onChecked.dispose();
  }
}
class nC {
  get templateId() {
    return nC.ID;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    t.toDisposeElement = [], t.toDisposeTemplate = [], t.entry = Me(e, Il(".quick-input-list-entry"));
    const i = Me(t.entry, Il("label.quick-input-list-label"));
    t.toDisposeTemplate.push(io(i, Ge.CLICK, (u) => {
      t.checkbox.offsetParent || u.preventDefault();
    })), t.checkbox = Me(i, Il("input.quick-input-list-checkbox")), t.checkbox.type = "checkbox", t.toDisposeTemplate.push(io(t.checkbox, Ge.CHANGE, (u) => {
      t.element.checked = t.checkbox.checked;
    }));
    const r = Me(i, Il(".quick-input-list-rows")), o = Me(r, Il(".quick-input-list-row")), s = Me(r, Il(".quick-input-list-row"));
    t.label = new Ave(o, { supportHighlights: !0, supportDescriptionHighlights: !0, supportIcons: !0 });
    const a = Me(o, Il(".quick-input-list-entry-keybinding"));
    t.keybinding = new hP(a, ja);
    const l = Me(s, Il(".quick-input-list-label-meta"));
    return t.detail = new Zd(l, !0), t.separator = Me(t.entry, Il(".quick-input-list-separator")), t.actionBar = new lg(t.entry), t.actionBar.domNode.classList.add("quick-input-list-entry-action-bar"), t.toDisposeTemplate.push(t.actionBar), t;
  }
  renderElement(e, t, i) {
    i.toDisposeElement = bi(i.toDisposeElement), i.element = e, i.checkbox.checked = e.checked, i.toDisposeElement.push(e.onChecked((u) => i.checkbox.checked = u));
    const { labelHighlights: r, descriptionHighlights: o, detailHighlights: s } = e, a = /* @__PURE__ */ Object.create(null);
    a.matches = r || [], a.descriptionTitle = e.saneDescription, a.descriptionMatches = o || [], a.extraClasses = e.item.iconClasses, a.italic = e.item.italic, a.strikethrough = e.item.strikethrough, i.label.setLabel(e.saneLabel, e.saneDescription, a), i.keybinding.set(e.item.keybinding), i.detail.set(e.saneDetail, s), e.separator && e.separator.label ? (i.separator.textContent = e.separator.label, i.separator.style.display = "") : i.separator.style.display = "none", i.entry.classList.toggle("quick-input-list-separator-border", !!e.separator), i.actionBar.clear();
    const l = e.item.buttons;
    l && l.length ? (i.actionBar.push(l.map((u, c) => {
      let h = u.iconClass || (u.iconPath ? VO(u.iconPath) : void 0);
      u.alwaysVisible && (h = h ? `${h} always-visible` : "always-visible");
      const d = new zl(`id-${c}`, "", h, !0, () => Vve(this, void 0, void 0, function* () {
        e.fireButtonTriggered({
          button: u,
          item: e.item
        });
      }));
      return d.tooltip = u.tooltip || "", d;
    }), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions");
  }
  disposeElement(e, t, i) {
    i.toDisposeElement = bi(i.toDisposeElement);
  }
  disposeTemplate(e) {
    e.toDisposeElement = bi(e.toDisposeElement), e.toDisposeTemplate = bi(e.toDisposeTemplate);
  }
}
nC.ID = "listelement";
class Hve {
  getHeight(e) {
    return e.saneDetail ? 44 : 22;
  }
  getTemplateId(e) {
    return nC.ID;
  }
}
var qi;
(function(n) {
  n[n.First = 1] = "First", n[n.Second = 2] = "Second", n[n.Last = 3] = "Last", n[n.Next = 4] = "Next", n[n.Previous = 5] = "Previous", n[n.NextPage = 6] = "NextPage", n[n.PreviousPage = 7] = "PreviousPage";
})(qi || (qi = {}));
class dP {
  constructor(e, t, i) {
    this.parent = e, this.inputElements = [], this.elements = [], this.elementsToIndexes = /* @__PURE__ */ new Map(), this.matchOnDescription = !1, this.matchOnDetail = !1, this.matchOnLabel = !0, this.matchOnMeta = !0, this.sortByLabel = !0, this._onChangedAllVisibleChecked = new q(), this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event, this._onChangedCheckedCount = new q(), this.onChangedCheckedCount = this._onChangedCheckedCount.event, this._onChangedVisibleCount = new q(), this.onChangedVisibleCount = this._onChangedVisibleCount.event, this._onChangedCheckedElements = new q(), this.onChangedCheckedElements = this._onChangedCheckedElements.event, this._onButtonTriggered = new q(), this.onButtonTriggered = this._onButtonTriggered.event, this._onKeyDown = new q(), this.onKeyDown = this._onKeyDown.event, this._onLeave = new q(), this.onLeave = this._onLeave.event, this._fireCheckedEvents = !0, this.elementDisposables = [], this.disposables = [], this.id = t, this.container = Me(this.parent, Il(".quick-input-list"));
    const r = new Hve(), o = new Uve();
    this.list = i.createList("QuickInput", this.container, r, [new nC()], {
      identityProvider: { getId: (s) => s.saneLabel },
      setRowLineHeight: !1,
      multipleSelectionSupport: !1,
      horizontalScrolling: !1,
      accessibilityProvider: o
    }), this.list.getHTMLElement().id = t, this.disposables.push(this.list), this.disposables.push(this.list.onKeyDown((s) => {
      const a = new Yi(s);
      switch (a.keyCode) {
        case 10:
          this.toggleCheckbox();
          break;
        case 31:
          (kt ? s.metaKey : s.ctrlKey) && this.list.setFocus(kr(this.list.length));
          break;
        case 16:
          const l = this.list.getFocus();
          l.length === 1 && l[0] === 0 && this._onLeave.fire();
          break;
        case 18:
          const u = this.list.getFocus();
          u.length === 1 && u[0] === this.list.length - 1 && this._onLeave.fire();
          break;
      }
      this._onKeyDown.fire(a);
    })), this.disposables.push(this.list.onMouseDown((s) => {
      s.browserEvent.button !== 2 && s.browserEvent.preventDefault();
    })), this.disposables.push(be(this.container, Ge.CLICK, (s) => {
      (s.x || s.y) && this._onLeave.fire();
    })), this.disposables.push(this.list.onMouseMiddleClick((s) => {
      this._onLeave.fire();
    })), this.disposables.push(this.list.onContextMenu((s) => {
      typeof s.index == "number" && (s.browserEvent.preventDefault(), this.list.setSelection([s.index]));
    })), this.disposables.push(this._onChangedAllVisibleChecked, this._onChangedCheckedCount, this._onChangedVisibleCount, this._onChangedCheckedElements, this._onButtonTriggered, this._onLeave, this._onKeyDown);
  }
  get onDidChangeFocus() {
    return We.map(this.list.onDidChangeFocus, (e) => e.elements.map((t) => t.item));
  }
  get onDidChangeSelection() {
    return We.map(this.list.onDidChangeSelection, (e) => ({ items: e.elements.map((t) => t.item), event: e.browserEvent }));
  }
  getAllVisibleChecked() {
    return this.allVisibleChecked(this.elements, !1);
  }
  allVisibleChecked(e, t = !0) {
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i];
      if (!o.hidden)
        if (o.checked)
          t = !0;
        else
          return !1;
    }
    return t;
  }
  getCheckedCount() {
    let e = 0;
    const t = this.elements;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].checked && e++;
    return e;
  }
  getVisibleCount() {
    let e = 0;
    const t = this.elements;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].hidden || e++;
    return e;
  }
  setAllVisibleChecked(e) {
    try {
      this._fireCheckedEvents = !1, this.elements.forEach((t) => {
        t.hidden || (t.checked = e);
      });
    } finally {
      this._fireCheckedEvents = !0, this.fireCheckedEvents();
    }
  }
  setElements(e) {
    this.elementDisposables = bi(this.elementDisposables);
    const t = (i) => this.fireButtonTriggered(i);
    this.inputElements = e, this.elements = e.reduce((i, r, o) => {
      var s, a, l;
      if (r.type !== "separator") {
        const u = o && e[o - 1], c = r.label && r.label.replace(/\r?\n/g, " "), h = r.meta && r.meta.replace(/\r?\n/g, " "), d = r.description && r.description.replace(/\r?\n/g, " "), f = r.detail && r.detail.replace(/\r?\n/g, " "), p = r.ariaLabel || [c, d, f].map((g) => dse(g)).filter((g) => !!g).join(", ");
        i.push(new Bve({
          index: o,
          item: r,
          saneLabel: c,
          saneMeta: h,
          saneAriaLabel: p,
          saneDescription: d,
          saneDetail: f,
          labelHighlights: (s = r.highlights) === null || s === void 0 ? void 0 : s.label,
          descriptionHighlights: (a = r.highlights) === null || a === void 0 ? void 0 : a.description,
          detailHighlights: (l = r.highlights) === null || l === void 0 ? void 0 : l.detail,
          checked: !1,
          separator: u && u.type === "separator" ? u : void 0,
          fireButtonTriggered: t
        }));
      }
      return i;
    }, []), this.elementDisposables.push(...this.elements), this.elementDisposables.push(...this.elements.map((i) => i.onChecked(() => this.fireCheckedEvents()))), this.elementsToIndexes = this.elements.reduce((i, r, o) => (i.set(r.item, o), i), /* @__PURE__ */ new Map()), this.list.splice(0, this.list.length), this.list.splice(0, this.list.length, this.elements), this._onChangedVisibleCount.fire(this.elements.length);
  }
  getFocusedElements() {
    return this.list.getFocusedElements().map((e) => e.item);
  }
  setFocusedElements(e) {
    if (this.list.setFocus(e.filter((t) => this.elementsToIndexes.has(t)).map((t) => this.elementsToIndexes.get(t))), e.length > 0) {
      const t = this.list.getFocus()[0];
      typeof t == "number" && this.list.reveal(t);
    }
  }
  getActiveDescendant() {
    return this.list.getHTMLElement().getAttribute("aria-activedescendant");
  }
  setSelectedElements(e) {
    this.list.setSelection(e.filter((t) => this.elementsToIndexes.has(t)).map((t) => this.elementsToIndexes.get(t)));
  }
  getCheckedElements() {
    return this.elements.filter((e) => e.checked).map((e) => e.item);
  }
  setCheckedElements(e) {
    try {
      this._fireCheckedEvents = !1;
      const t = /* @__PURE__ */ new Set();
      for (const i of e)
        t.add(i);
      for (const i of this.elements)
        i.checked = t.has(i.item);
    } finally {
      this._fireCheckedEvents = !0, this.fireCheckedEvents();
    }
  }
  set enabled(e) {
    this.list.getHTMLElement().style.pointerEvents = e ? "" : "none";
  }
  focus(e) {
    if (!this.list.length)
      return;
    switch (e === qi.Next && this.list.getFocus()[0] === this.list.length - 1 && (e = qi.First), e === qi.Previous && this.list.getFocus()[0] === 0 && (e = qi.Last), e === qi.Second && this.list.length < 2 && (e = qi.First), e) {
      case qi.First:
        this.list.focusFirst();
        break;
      case qi.Second:
        this.list.focusNth(1);
        break;
      case qi.Last:
        this.list.focusLast();
        break;
      case qi.Next:
        this.list.focusNext();
        break;
      case qi.Previous:
        this.list.focusPrevious();
        break;
      case qi.NextPage:
        this.list.focusNextPage();
        break;
      case qi.PreviousPage:
        this.list.focusPreviousPage();
        break;
    }
    const t = this.list.getFocus()[0];
    typeof t == "number" && this.list.reveal(t);
  }
  clearFocus() {
    this.list.setFocus([]);
  }
  domFocus() {
    this.list.domFocus();
  }
  layout(e) {
    this.list.getHTMLElement().style.maxHeight = e ? `calc(${Math.floor(e / 44) * 44}px)` : "", this.list.layout();
  }
  filter(e) {
    if (!(this.sortByLabel || this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
      return this.list.layout(), !1;
    if (e = e.trim(), !e || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
      this.elements.forEach((i) => {
        i.labelHighlights = void 0, i.descriptionHighlights = void 0, i.detailHighlights = void 0, i.hidden = !1;
        const r = i.index && this.inputElements[i.index - 1];
        i.separator = r && r.type === "separator" ? r : void 0;
      });
    else {
      let i;
      this.elements.forEach((r) => {
        const o = this.matchOnLabel ? op(Wy(e, ky(r.saneLabel))) : void 0, s = this.matchOnDescription ? op(Wy(e, ky(r.saneDescription || ""))) : void 0, a = this.matchOnDetail ? op(Wy(e, ky(r.saneDetail || ""))) : void 0, l = this.matchOnMeta ? op(Wy(e, ky(r.saneMeta || ""))) : void 0;
        if (o || s || a || l ? (r.labelHighlights = o, r.descriptionHighlights = s, r.detailHighlights = a, r.hidden = !1) : (r.labelHighlights = void 0, r.descriptionHighlights = void 0, r.detailHighlights = void 0, r.hidden = !r.item.alwaysShow), r.separator = void 0, !this.sortByLabel) {
          const u = r.index && this.inputElements[r.index - 1];
          i = u && u.type === "separator" ? u : i, i && !r.hidden && (r.separator = i, i = void 0);
        }
      });
    }
    const t = this.elements.filter((i) => !i.hidden);
    if (this.sortByLabel && e) {
      const i = e.toLowerCase();
      t.sort((r, o) => Gve(r, o, i));
    }
    return this.elementsToIndexes = t.reduce((i, r, o) => (i.set(r.item, o), i), /* @__PURE__ */ new Map()), this.list.splice(0, this.list.length, t), this.list.setFocus([]), this.list.layout(), this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked()), this._onChangedVisibleCount.fire(t.length), !0;
  }
  toggleCheckbox() {
    try {
      this._fireCheckedEvents = !1;
      const e = this.list.getFocusedElements(), t = this.allVisibleChecked(e);
      for (const i of e)
        i.checked = !t;
    } finally {
      this._fireCheckedEvents = !0, this.fireCheckedEvents();
    }
  }
  display(e) {
    this.container.style.display = e ? "" : "none";
  }
  isDisplayed() {
    return this.container.style.display !== "none";
  }
  dispose() {
    this.elementDisposables = bi(this.elementDisposables), this.disposables = bi(this.disposables);
  }
  fireCheckedEvents() {
    this._fireCheckedEvents && (this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked()), this._onChangedCheckedCount.fire(this.getCheckedCount()), this._onChangedCheckedElements.fire(this.getCheckedElements()));
  }
  fireButtonTriggered(e) {
    this._onButtonTriggered.fire(e);
  }
  style(e) {
    this.list.style(e);
  }
}
yU([
  Bn
], dP.prototype, "onDidChangeFocus", null);
yU([
  Bn
], dP.prototype, "onDidChangeSelection", null);
function Gve(n, e, t) {
  const i = n.labelHighlights || [], r = e.labelHighlights || [];
  return i.length && !r.length ? -1 : !i.length && r.length ? 1 : i.length === 0 && r.length === 0 ? 0 : Rve(n.saneLabel, e.saneLabel, t);
}
class Uve {
  getWidgetAriaLabel() {
    return b("quickInput", "Quick Input");
  }
  getAriaLabel(e) {
    return e.saneAriaLabel;
  }
  getWidgetRole() {
    return "listbox";
  }
  getRole() {
    return "option";
  }
}
function zve(n, e = {}) {
  const t = wU(e);
  return t.textContent = n, t;
}
function jve(n, e = {}) {
  const t = wU(e);
  return bU(t, Kve(n, !!e.renderCodeSegements), e.actionHandler, e.renderCodeSegements), t;
}
function wU(n) {
  const e = n.inline ? "span" : "div", t = document.createElement(e);
  return n.className && (t.className = n.className), t;
}
class $ve {
  constructor(e) {
    this.source = e, this.index = 0;
  }
  eos() {
    return this.index >= this.source.length;
  }
  next() {
    const e = this.peek();
    return this.advance(), e;
  }
  peek() {
    return this.source[this.index];
  }
  advance() {
    this.index++;
  }
}
function bU(n, e, t, i) {
  let r;
  if (e.type === 2)
    r = document.createTextNode(e.content || "");
  else if (e.type === 3)
    r = document.createElement("b");
  else if (e.type === 4)
    r = document.createElement("i");
  else if (e.type === 7 && i)
    r = document.createElement("code");
  else if (e.type === 5 && t) {
    const o = document.createElement("a");
    o.href = "#", t.disposeables.add(io(o, "click", (s) => {
      t.callback(String(e.index), s);
    })), r = o;
  } else
    e.type === 8 ? r = document.createElement("br") : e.type === 1 && (r = n);
  r && n !== r && n.appendChild(r), r && Array.isArray(e.children) && e.children.forEach((o) => {
    bU(r, o, t, i);
  });
}
function Kve(n, e) {
  const t = {
    type: 1,
    children: []
  };
  let i = 0, r = t;
  const o = [], s = new $ve(n);
  for (; !s.eos(); ) {
    let a = s.next();
    const l = a === "\\" && BO(s.peek(), e) !== 0;
    if (l && (a = s.next()), !l && qve(a, e) && a === s.peek()) {
      s.advance(), r.type === 2 && (r = o.pop());
      const u = BO(a, e);
      if (r.type === u || r.type === 5 && u === 6)
        r = o.pop();
      else {
        const c = {
          type: u,
          children: []
        };
        u === 5 && (c.index = i, i++), r.children.push(c), o.push(r), r = c;
      }
    } else if (a === `
`)
      r.type === 2 && (r = o.pop()), r.children.push({
        type: 8
        /* NewLine */
      });
    else if (r.type !== 2) {
      const u = {
        type: 2,
        content: a
      };
      r.children.push(u), o.push(r), r = u;
    } else
      r.content += a;
  }
  return r.type === 2 && (r = o.pop()), t;
}
function qve(n, e) {
  return BO(n, e) !== 0;
}
function BO(n, e) {
  switch (n) {
    case "*":
      return 3;
    case "_":
      return 4;
    case "[":
      return 5;
    case "]":
      return 6;
    case "`":
      return e ? 7 : 0;
    default:
      return 0;
  }
}
class Yve {
  constructor(e, t = 0, i = e.length, r = t - 1) {
    this.items = e, this.start = t, this.end = i, this.index = r;
  }
  current() {
    return this.index === this.start - 1 || this.index === this.end ? null : this.items[this.index];
  }
  next() {
    return this.index = Math.min(this.index + 1, this.end), this.current();
  }
  previous() {
    return this.index = Math.max(this.index - 1, this.start - 1), this.current();
  }
  first() {
    return this.index = this.start, this.current();
  }
  last() {
    return this.index = this.end - 1, this.current();
  }
}
class Xve {
  constructor(e = [], t = 10) {
    this._initialize(e), this._limit = t, this._onChange();
  }
  add(e) {
    this._history.delete(e), this._history.add(e), this._onChange();
  }
  next() {
    return this._currentPosition() !== this._elements.length - 1 ? this._navigator.next() : null;
  }
  previous() {
    return this._currentPosition() !== 0 ? this._navigator.previous() : null;
  }
  current() {
    return this._navigator.current();
  }
  first() {
    return this._navigator.first();
  }
  last() {
    return this._navigator.last();
  }
  has(e) {
    return this._history.has(e);
  }
  _onChange() {
    this._reduceToLimit();
    const e = this._elements;
    this._navigator = new Yve(e, 0, e.length, e.length);
  }
  _reduceToLimit() {
    const e = this._elements;
    e.length > this._limit && this._initialize(e.slice(e.length - this._limit));
  }
  _currentPosition() {
    const e = this._navigator.current();
    return e ? this._elements.indexOf(e) : -1;
  }
  _initialize(e) {
    this._history = /* @__PURE__ */ new Set();
    for (const t of e)
      this._history.add(t);
  }
  get _elements() {
    const e = [];
    return this._history.forEach((t) => e.push(t)), e;
  }
}
const Km = Xe, Zve = {
  inputBackground: ne.fromHex("#3C3C3C"),
  inputForeground: ne.fromHex("#CCCCCC"),
  inputValidationInfoBorder: ne.fromHex("#55AAFF"),
  inputValidationInfoBackground: ne.fromHex("#063B49"),
  inputValidationWarningBorder: ne.fromHex("#B89500"),
  inputValidationWarningBackground: ne.fromHex("#352A05"),
  inputValidationErrorBorder: ne.fromHex("#BE1100"),
  inputValidationErrorBackground: ne.fromHex("#5A1D1D")
};
class SU extends PE {
  constructor(e, t, i) {
    var r;
    super(), this.state = "idle", this.maxHeight = Number.POSITIVE_INFINITY, this._onDidChange = this._register(new q()), this.onDidChange = this._onDidChange.event, this._onDidHeightChange = this._register(new q()), this.onDidHeightChange = this._onDidHeightChange.event, this.contextViewProvider = t, this.options = i || /* @__PURE__ */ Object.create(null), vh(this.options, Zve, !1), this.message = null, this.placeholder = this.options.placeholder || "", this.tooltip = (r = this.options.tooltip) !== null && r !== void 0 ? r : this.placeholder || "", this.ariaLabel = this.options.ariaLabel || "", this.inputBackground = this.options.inputBackground, this.inputForeground = this.options.inputForeground, this.inputBorder = this.options.inputBorder, this.inputValidationInfoBorder = this.options.inputValidationInfoBorder, this.inputValidationInfoBackground = this.options.inputValidationInfoBackground, this.inputValidationInfoForeground = this.options.inputValidationInfoForeground, this.inputValidationWarningBorder = this.options.inputValidationWarningBorder, this.inputValidationWarningBackground = this.options.inputValidationWarningBackground, this.inputValidationWarningForeground = this.options.inputValidationWarningForeground, this.inputValidationErrorBorder = this.options.inputValidationErrorBorder, this.inputValidationErrorBackground = this.options.inputValidationErrorBackground, this.inputValidationErrorForeground = this.options.inputValidationErrorForeground, this.options.validationOptions && (this.validation = this.options.validationOptions.validation), this.element = Me(e, Km(".monaco-inputbox.idle"));
    let o = this.options.flexibleHeight ? "textarea" : "input", s = Me(this.element, Km(".ibwrapper"));
    if (this.input = Me(s, Km(o + ".input.empty")), this.input.setAttribute("autocorrect", "off"), this.input.setAttribute("autocapitalize", "off"), this.input.setAttribute("spellcheck", "false"), this.onfocus(this.input, () => this.element.classList.add("synthetic-focus")), this.onblur(this.input, () => this.element.classList.remove("synthetic-focus")), this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight == "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY, this.mirror = Me(s, Km("div.mirror")), this.mirror.innerText = "", this.scrollableElement = new l7(this.element, {
        vertical: 1
        /* Auto */
      }), this.options.flexibleWidth && (this.input.setAttribute("wrap", "off"), this.mirror.style.whiteSpace = "pre", this.mirror.style.wordWrap = "initial"), Me(e, this.scrollableElement.getDomNode()), this._register(this.scrollableElement), this._register(this.scrollableElement.onScroll((l) => this.input.scrollTop = l.scrollTop));
      const a = We.filter(wt(document, "selectionchange"), () => {
        const l = document.getSelection();
        return (l == null ? void 0 : l.anchorNode) === s;
      });
      this._register(a(this.updateScrollDimensions, this)), this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else
      this.input.type = this.options.type || "text", this.input.setAttribute("wrap", "off");
    this.ariaLabel && this.input.setAttribute("aria-label", this.ariaLabel), this.placeholder && this.setPlaceHolder(this.placeholder), this.tooltip && this.setTooltip(this.tooltip), this.oninput(this.input, () => this.onValueChange()), this.onblur(this.input, () => this.onBlur()), this.onfocus(this.input, () => this.onFocus()), this.ignoreGesture(this.input), setTimeout(() => this.updateMirror(), 0), this.options.actions && (this.actionbar = this._register(new lg(this.element)), this.actionbar.push(this.options.actions, { icon: !0, label: !1 })), this.applyStyles();
  }
  onBlur() {
    this._hideMessage();
  }
  onFocus() {
    this._showMessage();
  }
  setPlaceHolder(e) {
    this.placeholder = e, this.input.setAttribute("placeholder", e);
  }
  setTooltip(e) {
    this.tooltip = e, this.input.title = e;
  }
  setAriaLabel(e) {
    this.ariaLabel = e, e ? this.input.setAttribute("aria-label", this.ariaLabel) : this.input.removeAttribute("aria-label");
  }
  getAriaLabel() {
    return this.ariaLabel;
  }
  get inputElement() {
    return this.input;
  }
  get value() {
    return this.input.value;
  }
  set value(e) {
    this.input.value !== e && (this.input.value = e, this.onValueChange());
  }
  get height() {
    return typeof this.cachedHeight == "number" ? this.cachedHeight : gT(this.element);
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  hasFocus() {
    return document.activeElement === this.input;
  }
  select(e = null) {
    this.input.select(), e && (this.input.setSelectionRange(e.start, e.end), e.end === this.input.value.length && (this.input.scrollLeft = this.input.scrollWidth));
  }
  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }
  enable() {
    this.input.removeAttribute("disabled");
  }
  disable() {
    this.blur(), this.input.disabled = !0, this._hideMessage();
  }
  get width() {
    return pT(this.input);
  }
  set width(e) {
    if (this.options.flexibleHeight && this.options.flexibleWidth) {
      let t = 0;
      if (this.mirror) {
        const i = parseFloat(this.mirror.style.paddingLeft || "") || 0, r = parseFloat(this.mirror.style.paddingRight || "") || 0;
        t = i + r;
      }
      this.input.style.width = e - t + "px";
    } else
      this.input.style.width = e + "px";
    this.mirror && (this.mirror.style.width = e + "px");
  }
  set paddingRight(e) {
    this.options.flexibleHeight && this.options.flexibleWidth ? this.input.style.width = `calc(100% - ${e}px)` : this.input.style.paddingRight = e + "px", this.mirror && (this.mirror.style.paddingRight = e + "px");
  }
  updateScrollDimensions() {
    if (typeof this.cachedContentHeight != "number" || typeof this.cachedHeight != "number" || !this.scrollableElement)
      return;
    const e = this.cachedContentHeight, t = this.cachedHeight, i = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({ scrollHeight: e, height: t }), this.scrollableElement.setScrollPosition({ scrollTop: i });
  }
  showMessage(e, t) {
    this.message = e, this.element.classList.remove("idle"), this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add(this.classForType(e.type));
    const i = this.stylesForType(this.message.type);
    this.element.style.border = i.border ? `1px solid ${i.border}` : "", (this.hasFocus() || t) && this._showMessage();
  }
  hideMessage() {
    this.message = null, this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add("idle"), this._hideMessage(), this.applyStyles();
  }
  validate() {
    let e = null;
    return this.validation && (e = this.validation(this.value), e ? (this.inputElement.setAttribute("aria-invalid", "true"), this.showMessage(e)) : this.inputElement.hasAttribute("aria-invalid") && (this.inputElement.removeAttribute("aria-invalid"), this.hideMessage())), e == null ? void 0 : e.type;
  }
  stylesForType(e) {
    switch (e) {
      case 1:
        return { border: this.inputValidationInfoBorder, background: this.inputValidationInfoBackground, foreground: this.inputValidationInfoForeground };
      case 2:
        return { border: this.inputValidationWarningBorder, background: this.inputValidationWarningBackground, foreground: this.inputValidationWarningForeground };
      default:
        return { border: this.inputValidationErrorBorder, background: this.inputValidationErrorBackground, foreground: this.inputValidationErrorForeground };
    }
  }
  classForType(e) {
    switch (e) {
      case 1:
        return "info";
      case 2:
        return "warning";
      default:
        return "error";
    }
  }
  _showMessage() {
    if (!this.contextViewProvider || !this.message)
      return;
    let e, t = () => e.style.width = pT(this.element) + "px";
    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: 1,
      render: (r) => {
        if (!this.message)
          return null;
        e = Me(r, Km(".monaco-inputbox-container")), t();
        const o = {
          inline: !0,
          className: "monaco-inputbox-message"
        }, s = this.message.formatContent ? jve(this.message.content, o) : zve(this.message.content, o);
        s.classList.add(this.classForType(this.message.type));
        const a = this.stylesForType(this.message.type);
        return s.style.backgroundColor = a.background ? a.background.toString() : "", s.style.color = a.foreground ? a.foreground.toString() : "", s.style.border = a.border ? `1px solid ${a.border}` : "", Me(e, s), null;
      },
      onHide: () => {
        this.state = "closed";
      },
      layout: t
    });
    let i;
    this.message.type === 3 ? i = b("alertErrorMessage", "Error: {0}", this.message.content) : this.message.type === 2 ? i = b("alertWarningMessage", "Warning: {0}", this.message.content) : i = b("alertInfoMessage", "Info: {0}", this.message.content), ld(i), this.state = "open";
  }
  _hideMessage() {
    this.contextViewProvider && (this.state === "open" && this.contextViewProvider.hideContextView(), this.state = "idle");
  }
  onValueChange() {
    this._onDidChange.fire(this.value), this.validate(), this.updateMirror(), this.input.classList.toggle("empty", !this.value), this.state === "open" && this.contextViewProvider && this.contextViewProvider.layout();
  }
  updateMirror() {
    if (!this.mirror)
      return;
    const e = this.value, i = e.charCodeAt(e.length - 1) === 10 ? " " : "";
    e + i ? this.mirror.textContent = e + i : this.mirror.innerText = "", this.layout();
  }
  style(e) {
    this.inputBackground = e.inputBackground, this.inputForeground = e.inputForeground, this.inputBorder = e.inputBorder, this.inputValidationInfoBackground = e.inputValidationInfoBackground, this.inputValidationInfoForeground = e.inputValidationInfoForeground, this.inputValidationInfoBorder = e.inputValidationInfoBorder, this.inputValidationWarningBackground = e.inputValidationWarningBackground, this.inputValidationWarningForeground = e.inputValidationWarningForeground, this.inputValidationWarningBorder = e.inputValidationWarningBorder, this.inputValidationErrorBackground = e.inputValidationErrorBackground, this.inputValidationErrorForeground = e.inputValidationErrorForeground, this.inputValidationErrorBorder = e.inputValidationErrorBorder, this.applyStyles();
  }
  applyStyles() {
    const e = this.inputBackground ? this.inputBackground.toString() : "", t = this.inputForeground ? this.inputForeground.toString() : "", i = this.inputBorder ? this.inputBorder.toString() : "";
    this.element.style.backgroundColor = e, this.element.style.color = t, this.input.style.backgroundColor = "inherit", this.input.style.color = t, this.element.style.borderWidth = i ? "1px" : "", this.element.style.borderStyle = i ? "solid" : "", this.element.style.borderColor = i;
  }
  layout() {
    if (!this.mirror)
      return;
    const e = this.cachedContentHeight;
    this.cachedContentHeight = gT(this.mirror), e !== this.cachedContentHeight && (this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight), this.input.style.height = this.cachedHeight + "px", this._onDidHeightChange.fire(this.cachedContentHeight));
  }
  insertAtCursor(e) {
    const t = this.inputElement, i = t.selectionStart, r = t.selectionEnd, o = t.value;
    i !== null && r !== null && (this.value = o.substr(0, i) + e + o.substr(r), t.setSelectionRange(i + 1, i + 1), this.layout());
  }
  dispose() {
    this._hideMessage(), this.message = null, this.actionbar && this.actionbar.dispose(), super.dispose();
  }
}
class Cbe extends SU {
  constructor(e, t, i) {
    super(e, t, i), this.history = new Xve(i.history, 100);
  }
  addToHistory() {
    this.value && this.value !== this.getCurrentValue() && this.history.add(this.value);
  }
  showNextValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getNextValue();
    e && (e = e === this.value ? this.getNextValue() : e), e && (this.value = e, YT(this.value));
  }
  showPreviousValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getPreviousValue();
    e && (e = e === this.value ? this.getPreviousValue() : e), e && (this.value = e, YT(this.value));
  }
  getCurrentValue() {
    let e = this.history.current();
    return e || (e = this.history.last(), this.history.next()), e;
  }
  getPreviousValue() {
    return this.history.previous() || this.history.first();
  }
  getNextValue() {
    return this.history.next() || this.history.last();
  }
}
const Qve = Xe;
class Jve extends Ce {
  constructor(e) {
    super(), this.parent = e, this.onKeyDown = (t) => be(this.inputBox.inputElement, Ge.KEY_DOWN, (i) => {
      t(new Yi(i));
    }), this.onMouseDown = (t) => be(this.inputBox.inputElement, Ge.MOUSE_DOWN, (i) => {
      t(new pa(i));
    }), this.onDidChange = (t) => this.inputBox.onDidChange(t), this.container = Me(this.parent, Qve(".quick-input-box")), this.inputBox = this._register(new SU(this.container, void 0));
  }
  get value() {
    return this.inputBox.value;
  }
  set value(e) {
    this.inputBox.value = e;
  }
  select(e = null) {
    this.inputBox.select(e);
  }
  isSelectionAtEnd() {
    return this.inputBox.isSelectionAtEnd();
  }
  get placeholder() {
    return this.inputBox.inputElement.getAttribute("placeholder") || "";
  }
  set placeholder(e) {
    this.inputBox.setPlaceHolder(e);
  }
  get ariaLabel() {
    return this.inputBox.getAriaLabel();
  }
  set ariaLabel(e) {
    this.inputBox.setAriaLabel(e);
  }
  get password() {
    return this.inputBox.inputElement.type === "password";
  }
  set password(e) {
    this.inputBox.inputElement.type = e ? "password" : "text";
  }
  setAttribute(e, t) {
    this.inputBox.inputElement.setAttribute(e, t);
  }
  removeAttribute(e) {
    this.inputBox.inputElement.removeAttribute(e);
  }
  showDecoration(e) {
    e === mn.Ignore ? this.inputBox.hideMessage() : this.inputBox.showMessage({ type: e === mn.Info ? 1 : e === mn.Warning ? 2 : 3, content: "" });
  }
  stylesForType(e) {
    return this.inputBox.stylesForType(
      e === mn.Info ? 1 : e === mn.Warning ? 2 : 3
      /* ERROR */
    );
  }
  setFocus() {
    this.inputBox.focus();
  }
  layout() {
    this.inputBox.layout();
  }
  style(e) {
    this.inputBox.style(e);
  }
}
const e_e = {
  badgeBackground: ne.fromHex("#4D4D4D"),
  badgeForeground: ne.fromHex("#FFFFFF")
};
class gV {
  constructor(e, t) {
    this.count = 0, this.options = t || /* @__PURE__ */ Object.create(null), vh(this.options, e_e, !1), this.badgeBackground = this.options.badgeBackground, this.badgeForeground = this.options.badgeForeground, this.badgeBorder = this.options.badgeBorder, this.element = Me(e, Xe(".monaco-count-badge")), this.countFormat = this.options.countFormat || "{0}", this.titleFormat = this.options.titleFormat || "", this.setCount(this.options.count || 0);
  }
  setCount(e) {
    this.count = e, this.render();
  }
  setTitleFormat(e) {
    this.titleFormat = e, this.render();
  }
  render() {
    this.element.textContent = Fl(this.countFormat, this.count), this.element.title = Fl(this.titleFormat, this.count), this.applyStyles();
  }
  style(e) {
    this.badgeBackground = e.badgeBackground, this.badgeForeground = e.badgeForeground, this.badgeBorder = e.badgeBorder, this.applyStyles();
  }
  applyStyles() {
    if (this.element) {
      const e = this.badgeBackground ? this.badgeBackground.toString() : "", t = this.badgeForeground ? this.badgeForeground.toString() : "", i = this.badgeBorder ? this.badgeBorder.toString() : "";
      this.element.style.backgroundColor = e, this.element.style.color = t, this.element.style.borderWidth = i ? "1px" : "", this.element.style.borderStyle = i ? "solid" : "", this.element.style.borderColor = i;
    }
  }
}
const mV = "done", vV = "active", y1 = "infinite", _V = "discrete", t_e = {
  progressBarBackground: ne.fromHex("#0E70C0")
};
class i_e extends Ce {
  constructor(e, t) {
    super(), this.options = t || /* @__PURE__ */ Object.create(null), vh(this.options, t_e, !1), this.workedVal = 0, this.progressBarBackground = this.options.progressBarBackground, this._register(this.showDelayedScheduler = new ro(() => d5(this.element), 0)), this.create(e);
  }
  create(e) {
    this.element = document.createElement("div"), this.element.classList.add("monaco-progress-container"), this.element.setAttribute("role", "progressbar"), this.element.setAttribute("aria-valuemin", "0"), e.appendChild(this.element), this.bit = document.createElement("div"), this.bit.classList.add("progress-bit"), this.element.appendChild(this.bit), this.applyStyles();
  }
  off() {
    this.bit.style.width = "inherit", this.bit.style.opacity = "1", this.element.classList.remove(vV, y1, _V), this.workedVal = 0, this.totalWork = void 0;
  }
  /**
   * Stops the progressbar from showing any progress instantly without fading out.
   */
  stop() {
    return this.doDone(!1);
  }
  doDone(e) {
    return this.element.classList.add(mV), this.element.classList.contains(y1) ? (this.bit.style.opacity = "0", e ? setTimeout(() => this.off(), 200) : this.off()) : (this.bit.style.width = "inherit", e ? setTimeout(() => this.off(), 200) : this.off()), this;
  }
  /**
   * Use this mode to indicate progress that has no total number of work units.
   */
  infinite() {
    return this.bit.style.width = "2%", this.bit.style.opacity = "1", this.element.classList.remove(_V, mV), this.element.classList.add(vV, y1), this;
  }
  getContainer() {
    return this.element;
  }
  style(e) {
    this.progressBarBackground = e.progressBarBackground, this.applyStyles();
  }
  applyStyles() {
    if (this.bit) {
      const e = this.progressBarBackground ? this.progressBarBackground.toString() : "";
      this.bit.style.backgroundColor = e;
    }
  }
}
const n_e = {
  buttonBackground: ne.fromHex("#0E639C"),
  buttonHoverBackground: ne.fromHex("#006BB3"),
  buttonForeground: ne.white
};
class CV extends Ce {
  constructor(e, t) {
    super(), this._onDidClick = this._register(new q()), this.options = t || /* @__PURE__ */ Object.create(null), vh(this.options, n_e, !1), this.buttonForeground = this.options.buttonForeground, this.buttonBackground = this.options.buttonBackground, this.buttonHoverBackground = this.options.buttonHoverBackground, this.buttonSecondaryForeground = this.options.buttonSecondaryForeground, this.buttonSecondaryBackground = this.options.buttonSecondaryBackground, this.buttonSecondaryHoverBackground = this.options.buttonSecondaryHoverBackground, this.buttonBorder = this.options.buttonBorder, this._element = document.createElement("a"), this._element.classList.add("monaco-button"), this._element.tabIndex = 0, this._element.setAttribute("role", "button"), e.appendChild(this._element), this._register(ri.addTarget(this._element)), [Ge.CLICK, Ri.Tap].forEach((i) => {
      this._register(be(this._element, i, (r) => {
        if (!this.enabled) {
          gi.stop(r);
          return;
        }
        this._onDidClick.fire(r);
      }));
    }), this._register(be(this._element, Ge.KEY_DOWN, (i) => {
      const r = new Yi(i);
      let o = !1;
      this.enabled && (r.equals(
        3
        /* Enter */
      ) || r.equals(
        10
        /* Space */
      )) ? (this._onDidClick.fire(i), o = !0) : r.equals(
        9
        /* Escape */
      ) && (this._element.blur(), o = !0), o && gi.stop(r, !0);
    })), this._register(be(this._element, Ge.MOUSE_OVER, (i) => {
      this._element.classList.contains("disabled") || this.setHoverBackground();
    })), this._register(be(this._element, Ge.MOUSE_OUT, (i) => {
      this.applyStyles();
    })), this.focusTracker = this._register(iE(this._element)), this._register(this.focusTracker.onDidFocus(() => this.setHoverBackground())), this._register(this.focusTracker.onDidBlur(() => this.applyStyles())), this.applyStyles();
  }
  get onDidClick() {
    return this._onDidClick.event;
  }
  setHoverBackground() {
    let e;
    this.options.secondary ? e = this.buttonSecondaryHoverBackground ? this.buttonSecondaryHoverBackground.toString() : null : e = this.buttonHoverBackground ? this.buttonHoverBackground.toString() : null, e && (this._element.style.backgroundColor = e);
  }
  style(e) {
    this.buttonForeground = e.buttonForeground, this.buttonBackground = e.buttonBackground, this.buttonHoverBackground = e.buttonHoverBackground, this.buttonSecondaryForeground = e.buttonSecondaryForeground, this.buttonSecondaryBackground = e.buttonSecondaryBackground, this.buttonSecondaryHoverBackground = e.buttonSecondaryHoverBackground, this.buttonBorder = e.buttonBorder, this.applyStyles();
  }
  applyStyles() {
    if (this._element) {
      let e, t;
      this.options.secondary ? (t = this.buttonSecondaryForeground ? this.buttonSecondaryForeground.toString() : "", e = this.buttonSecondaryBackground ? this.buttonSecondaryBackground.toString() : "") : (t = this.buttonForeground ? this.buttonForeground.toString() : "", e = this.buttonBackground ? this.buttonBackground.toString() : "");
      const i = this.buttonBorder ? this.buttonBorder.toString() : "";
      this._element.style.color = t, this._element.style.backgroundColor = e, this._element.style.borderWidth = i ? "1px" : "", this._element.style.borderStyle = i ? "solid" : "", this._element.style.borderColor = i;
    }
  }
  get element() {
    return this._element;
  }
  set label(e) {
    this._element.classList.add("monaco-text-button"), this.options.supportIcons ? nE(this._element, ...Iv(e)) : this._element.textContent = e, typeof this.options.title == "string" ? this._element.title = this.options.title : this.options.title && (this._element.title = e);
  }
  set enabled(e) {
    e ? (this._element.classList.remove("disabled"), this._element.setAttribute("aria-disabled", String(!1)), this._element.tabIndex = 0) : (this._element.classList.add("disabled"), this._element.setAttribute("aria-disabled", String(!0)));
  }
  get enabled() {
    return !this._element.classList.contains("disabled");
  }
}
var yV = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
const Fo = Xe, r_e = ya("quick-input-back", Hi.arrowLeft), HO = {
  iconClass: r_e.classNames,
  tooltip: b("quickInput.back", "Back"),
  handle: -1
  // TODO
};
class XE extends Ce {
  constructor(e) {
    super(), this.ui = e, this.visible = !1, this._enabled = !0, this._busy = !1, this._ignoreFocusOut = !1, this._buttons = [], this.noValidationMessage = XE.noPromptMessage, this._severity = mn.Ignore, this.buttonsUpdated = !1, this.onDidTriggerButtonEmitter = this._register(new q()), this.onDidHideEmitter = this._register(new q()), this.onDisposeEmitter = this._register(new q()), this.visibleDisposables = this._register(new dt()), this.onDidHide = this.onDidHideEmitter.event;
  }
  get title() {
    return this._title;
  }
  set title(e) {
    this._title = e, this.update();
  }
  get description() {
    return this._description;
  }
  set description(e) {
    this._description = e, this.update();
  }
  get step() {
    return this._steps;
  }
  set step(e) {
    this._steps = e, this.update();
  }
  get totalSteps() {
    return this._totalSteps;
  }
  set totalSteps(e) {
    this._totalSteps = e, this.update();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this.update();
  }
  get contextKey() {
    return this._contextKey;
  }
  set contextKey(e) {
    this._contextKey = e, this.update();
  }
  get busy() {
    return this._busy;
  }
  set busy(e) {
    this._busy = e, this.update();
  }
  get ignoreFocusOut() {
    return this._ignoreFocusOut;
  }
  set ignoreFocusOut(e) {
    this._ignoreFocusOut = e, this.update();
  }
  get buttons() {
    return this._buttons;
  }
  set buttons(e) {
    this._buttons = e, this.buttonsUpdated = !0, this.update();
  }
  get validationMessage() {
    return this._validationMessage;
  }
  set validationMessage(e) {
    this._validationMessage = e, this.update();
  }
  get severity() {
    return this._severity;
  }
  set severity(e) {
    this._severity = e, this.update();
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.onDidTriggerButton((e) => {
      this.buttons.indexOf(e) !== -1 && this.onDidTriggerButtonEmitter.fire(e);
    })), this.ui.show(this), this.visible = !0, this.update());
  }
  hide() {
    this.visible && this.ui.hide();
  }
  didHide(e = y_.Other) {
    this.visible = !1, this.visibleDisposables.clear(), this.onDidHideEmitter.fire({ reason: e });
  }
  update() {
    if (!this.visible)
      return;
    const e = this.getTitle();
    e && this.ui.title.textContent !== e ? this.ui.title.textContent = e : !e && this.ui.title.innerHTML !== "&nbsp;" && (this.ui.title.innerText = ";");
    const t = this.getDescription();
    if (this.ui.description1.textContent !== t && (this.ui.description1.textContent = t), this.ui.description2.textContent !== t && (this.ui.description2.textContent = t), this.busy && !this.busyDelay && (this.busyDelay = new oc(), this.busyDelay.setIfNotSet(() => {
      this.visible && this.ui.progressBar.infinite();
    }, 800)), !this.busy && this.busyDelay && (this.ui.progressBar.stop(), this.busyDelay.cancel(), this.busyDelay = void 0), this.buttonsUpdated) {
      this.buttonsUpdated = !1, this.ui.leftActionBar.clear();
      const r = this.buttons.filter((s) => s === HO);
      this.ui.leftActionBar.push(r.map((s, a) => {
        const l = new zl(`id-${a}`, "", s.iconClass || VO(s.iconPath), !0, () => yV(this, void 0, void 0, function* () {
          this.onDidTriggerButtonEmitter.fire(s);
        }));
        return l.tooltip = s.tooltip || "", l;
      }), { icon: !0, label: !1 }), this.ui.rightActionBar.clear();
      const o = this.buttons.filter((s) => s !== HO);
      this.ui.rightActionBar.push(o.map((s, a) => {
        const l = new zl(`id-${a}`, "", s.iconClass || VO(s.iconPath), !0, () => yV(this, void 0, void 0, function* () {
          this.onDidTriggerButtonEmitter.fire(s);
        }));
        return l.tooltip = s.tooltip || "", l;
      }), { icon: !0, label: !1 });
    }
    this.ui.ignoreFocusOut = this.ignoreFocusOut, this.ui.setEnabled(this.enabled), this.ui.setContextKey(this.contextKey);
    const i = this.validationMessage || this.noValidationMessage;
    this._lastValidationMessage !== i && (this._lastValidationMessage = i, nE(this.ui.message, ...Iv(i))), this._lastSeverity !== this.severity && (this._lastSeverity = this.severity, this.showMessageDecoration(this.severity));
  }
  getTitle() {
    return this.title && this.step ? `${this.title} (${this.getSteps()})` : this.title ? this.title : this.step ? this.getSteps() : "";
  }
  getDescription() {
    return this.description || "";
  }
  getSteps() {
    return this.step && this.totalSteps ? b("quickInput.steps", "{0}/{1}", this.step, this.totalSteps) : this.step ? String(this.step) : "";
  }
  showMessageDecoration(e) {
    if (this.ui.inputBox.showDecoration(e), e !== mn.Ignore) {
      const t = this.ui.inputBox.stylesForType(e);
      this.ui.message.style.color = t.foreground ? `${t.foreground}` : "", this.ui.message.style.backgroundColor = t.background ? `${t.background}` : "", this.ui.message.style.border = t.border ? `1px solid ${t.border}` : "", this.ui.message.style.paddingBottom = "4px";
    } else
      this.ui.message.style.color = "", this.ui.message.style.backgroundColor = "", this.ui.message.style.border = "", this.ui.message.style.paddingBottom = "";
  }
  dispose() {
    this.hide(), this.onDisposeEmitter.fire(), super.dispose();
  }
}
XE.noPromptMessage = b("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
class w_ extends XE {
  constructor() {
    super(...arguments), this._value = "", this.onDidChangeValueEmitter = this._register(new q()), this.onWillAcceptEmitter = this._register(new q()), this.onDidAcceptEmitter = this._register(new q()), this.onDidCustomEmitter = this._register(new q()), this._items = [], this.itemsUpdated = !1, this._canSelectMany = !1, this._canAcceptInBackground = !1, this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._sortByLabel = !0, this._autoFocusOnList = !0, this._itemActivation = this.ui.isScreenReaderOptimized() ? ka.NONE : ka.FIRST, this._activeItems = [], this.activeItemsUpdated = !1, this.activeItemsToConfirm = [], this.onDidChangeActiveEmitter = this._register(new q()), this._selectedItems = [], this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = [], this.onDidChangeSelectionEmitter = this._register(new q()), this.onDidTriggerItemButtonEmitter = this._register(new q()), this.valueSelectionUpdated = !0, this._ok = "default", this._customButton = !1, this.filterValue = (e) => e, this.onDidChangeValue = this.onDidChangeValueEmitter.event, this.onWillAccept = this.onWillAcceptEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event, this.onDidChangeActive = this.onDidChangeActiveEmitter.event, this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event, this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event;
  }
  get quickNavigate() {
    return this._quickNavigate;
  }
  set quickNavigate(e) {
    this._quickNavigate = e, this.update();
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this._value !== e && (this._value = e || "", this.update(), this.onDidChangeValueEmitter.fire(this._value));
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.update();
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this._placeholder = e, this.update();
  }
  get items() {
    return this._items;
  }
  set items(e) {
    this._items = e, this.itemsUpdated = !0, this.update();
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(e) {
    this._canSelectMany = e, this.update();
  }
  get canAcceptInBackground() {
    return this._canAcceptInBackground;
  }
  set canAcceptInBackground(e) {
    this._canAcceptInBackground = e;
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(e) {
    this._matchOnDescription = e, this.update();
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(e) {
    this._matchOnDetail = e, this.update();
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(e) {
    this._matchOnLabel = e, this.update();
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(e) {
    this._sortByLabel = e, this.update();
  }
  get autoFocusOnList() {
    return this._autoFocusOnList;
  }
  set autoFocusOnList(e) {
    this._autoFocusOnList = e, this.update();
  }
  get itemActivation() {
    return this._itemActivation;
  }
  set itemActivation(e) {
    this._itemActivation = e;
  }
  get activeItems() {
    return this._activeItems;
  }
  set activeItems(e) {
    this._activeItems = e, this.activeItemsUpdated = !0, this.update();
  }
  get selectedItems() {
    return this._selectedItems;
  }
  set selectedItems(e) {
    this._selectedItems = e, this.selectedItemsUpdated = !0, this.update();
  }
  get keyMods() {
    return this._quickNavigate ? Lve : this.ui.keyMods;
  }
  set valueSelection(e) {
    this._valueSelection = e, this.valueSelectionUpdated = !0, this.update();
  }
  get customButton() {
    return this._customButton;
  }
  set customButton(e) {
    this._customButton = e, this.update();
  }
  get customLabel() {
    return this._customButtonLabel;
  }
  set customLabel(e) {
    this._customButtonLabel = e, this.update();
  }
  get customHover() {
    return this._customButtonHover;
  }
  set customHover(e) {
    this._customButtonHover = e, this.update();
  }
  get ok() {
    return this._ok;
  }
  set ok(e) {
    this._ok = e, this.update();
  }
  get hideInput() {
    return !!this._hideInput;
  }
  set hideInput(e) {
    this._hideInput = e, this.update();
  }
  trySelectFirst() {
    this.autoFocusOnList && (this.canSelectMany || this.ui.list.focus(qi.First));
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
      if (e === this.value)
        return;
      this._value = e, this.ui.list.filter(this.filterValue(this.ui.inputBox.value)) && this.trySelectFirst(), this.onDidChangeValueEmitter.fire(e);
    })), this.visibleDisposables.add(this.ui.inputBox.onMouseDown((e) => {
      this.autoFocusOnList || this.ui.list.clearFocus();
    })), this.visibleDisposables.add((this._hideInput ? this.ui.list : this.ui.inputBox).onKeyDown((e) => {
      switch (e.keyCode) {
        case 18:
          this.ui.list.focus(qi.Next), this.canSelectMany && this.ui.list.domFocus(), gi.stop(e, !0);
          break;
        case 16:
          this.ui.list.getFocusedElements().length ? this.ui.list.focus(qi.Previous) : this.ui.list.focus(qi.Last), this.canSelectMany && this.ui.list.domFocus(), gi.stop(e, !0);
          break;
        case 12:
          this.ui.list.focus(qi.NextPage), this.canSelectMany && this.ui.list.domFocus(), gi.stop(e, !0);
          break;
        case 11:
          this.ui.list.focus(qi.PreviousPage), this.canSelectMany && this.ui.list.domFocus(), gi.stop(e, !0);
          break;
        case 17:
          if (!this._canAcceptInBackground || !this.ui.inputBox.isSelectionAtEnd())
            return;
          this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!0));
          break;
        case 14:
          (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && (this.ui.list.focus(qi.First), gi.stop(e, !0));
          break;
        case 13:
          (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && (this.ui.list.focus(qi.Last), gi.stop(e, !0));
          break;
      }
    })), this.visibleDisposables.add(this.ui.onDidAccept(() => {
      !this.canSelectMany && this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems)), this.handleAccept(!1);
    })), this.visibleDisposables.add(this.ui.onDidCustom(() => {
      this.onDidCustomEmitter.fire();
    })), this.visibleDisposables.add(this.ui.list.onDidChangeFocus((e) => {
      this.activeItemsUpdated || this.activeItemsToConfirm !== this._activeItems && Yu(e, this._activeItems, (t, i) => t === i) || (this._activeItems = e, this.onDidChangeActiveEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: e, event: t }) => {
      if (this.canSelectMany) {
        e.length && this.ui.list.setSelectedElements([]);
        return;
      }
      this.selectedItemsToConfirm !== this._selectedItems && Yu(e, this._selectedItems, (i, r) => i === r) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e), e.length && this.handleAccept(
        t instanceof MouseEvent && t.button === 1
        /* mouse middle click */
      ));
    })), this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((e) => {
      this.canSelectMany && (this.selectedItemsToConfirm !== this._selectedItems && Yu(e, this._selectedItems, (t, i) => t === i) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e)));
    })), this.visibleDisposables.add(this.ui.list.onButtonTriggered((e) => this.onDidTriggerItemButtonEmitter.fire(e))), this.visibleDisposables.add(this.registerQuickNavigation()), this.valueSelectionUpdated = !0), super.show();
  }
  handleAccept(e) {
    let t = !1;
    this.onWillAcceptEmitter.fire({ veto: () => t = !0 }), t || this.onDidAcceptEmitter.fire({ inBackground: e });
  }
  registerQuickNavigation() {
    return be(this.ui.container, Ge.KEY_UP, (e) => {
      if (this.canSelectMany || !this._quickNavigate)
        return;
      const t = new Yi(e), i = t.keyCode;
      this._quickNavigate.keybindings.some((s) => {
        const [a, l] = s.getParts();
        return l ? !1 : a.shiftKey && i === 4 ? !(t.ctrlKey || t.altKey || t.metaKey) : !!(a.altKey && i === 6 || a.ctrlKey && i === 5 || a.metaKey && i === 57);
      }) && (this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!1)), this._quickNavigate = void 0);
    });
  }
  update() {
    if (!this.visible)
      return;
    const e = !!this._hideInput && this._items.length > 0;
    this.ui.container.classList.toggle("hidden-input", e && !this.description);
    const t = {
      title: !!this.title || !!this.step || !!this.buttons.length,
      description: !!this.description,
      checkAll: this.canSelectMany && !this._hideCheckAll,
      checkBox: this.canSelectMany,
      inputBox: !e,
      progressBar: !e,
      visibleCount: !0,
      count: this.canSelectMany,
      ok: this.ok === "default" ? this.canSelectMany : this.ok,
      list: !0,
      message: !!this.validationMessage,
      customButton: this.customButton
    };
    this.ui.setVisibilities(t), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || "");
    const i = this.ariaLabel || this.placeholder || w_.DEFAULT_ARIA_LABEL;
    if (this.ui.inputBox.ariaLabel !== i && (this.ui.inputBox.ariaLabel = i), this.ui.list.matchOnDescription = this.matchOnDescription, this.ui.list.matchOnDetail = this.matchOnDetail, this.ui.list.matchOnLabel = this.matchOnLabel, this.ui.list.sortByLabel = this.sortByLabel, this.itemsUpdated)
      switch (this.itemsUpdated = !1, this.ui.list.setElements(this.items), this.ui.list.filter(this.filterValue(this.ui.inputBox.value)), this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked(), this.ui.visibleCount.setCount(this.ui.list.getVisibleCount()), this.ui.count.setCount(this.ui.list.getCheckedCount()), this._itemActivation) {
        case ka.NONE:
          this._itemActivation = ka.FIRST;
          break;
        case ka.SECOND:
          this.ui.list.focus(qi.Second), this._itemActivation = ka.FIRST;
          break;
        case ka.LAST:
          this.ui.list.focus(qi.Last), this._itemActivation = ka.FIRST;
          break;
        default:
          this.trySelectFirst();
          break;
      }
    this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany && (this.canSelectMany ? this.ui.list.clearFocus() : this.trySelectFirst()), this.activeItemsUpdated && (this.activeItemsUpdated = !1, this.activeItemsToConfirm = this._activeItems, this.ui.list.setFocusedElements(this.activeItems), this.activeItemsToConfirm === this._activeItems && (this.activeItemsToConfirm = null)), this.selectedItemsUpdated && (this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = this._selectedItems, this.canSelectMany ? this.ui.list.setCheckedElements(this.selectedItems) : this.ui.list.setSelectedElements(this.selectedItems), this.selectedItemsToConfirm === this._selectedItems && (this.selectedItemsToConfirm = null)), this.ui.customButton.label = this.customLabel || "", this.ui.customButton.element.title = this.customHover || "", this.ui.setComboboxAccessibility(!0), t.inputBox || (this.ui.list.domFocus(), this.canSelectMany && this.ui.list.focus(qi.First));
  }
}
w_.DEFAULT_ARIA_LABEL = b("quickInputBox.ariaLabel", "Type to narrow down results.");
class ZE extends Ce {
  constructor(e) {
    super(), this.options = e, this.comboboxAccessibility = !1, this.enabled = !0, this.onDidAcceptEmitter = this._register(new q()), this.onDidCustomEmitter = this._register(new q()), this.onDidTriggerButtonEmitter = this._register(new q()), this.keyMods = { ctrlCmd: !1, alt: !1 }, this.controller = null, this.onShowEmitter = this._register(new q()), this.onShow = this.onShowEmitter.event, this.onHideEmitter = this._register(new q()), this.onHide = this.onHideEmitter.event, this.idPrefix = e.idPrefix, this.parentElement = e.container, this.styles = e.styles, this.registerKeyModsListeners();
  }
  registerKeyModsListeners() {
    const e = (t) => {
      this.keyMods.ctrlCmd = t.ctrlKey || t.metaKey, this.keyMods.alt = t.altKey;
    };
    this._register(be(window, Ge.KEY_DOWN, e, !0)), this._register(be(window, Ge.KEY_UP, e, !0)), this._register(be(window, Ge.MOUSE_DOWN, e, !0));
  }
  getUI() {
    if (this.ui)
      return this.ui;
    const e = Me(this.parentElement, Fo(".quick-input-widget.show-file-icons"));
    e.tabIndex = -1, e.style.display = "none";
    const t = As(e), i = Me(e, Fo(".quick-input-titlebar")), r = this._register(new lg(i));
    r.domNode.classList.add("quick-input-left-action-bar");
    const o = Me(i, Fo(".quick-input-title")), s = this._register(new lg(i));
    s.domNode.classList.add("quick-input-right-action-bar");
    const a = Me(e, Fo(".quick-input-description")), l = Me(e, Fo(".quick-input-header")), u = Me(l, Fo("input.quick-input-check-all"));
    u.type = "checkbox", this._register(io(u, Ge.CHANGE, (x) => {
      const R = u.checked;
      S.setAllVisibleChecked(R);
    })), this._register(be(u, Ge.CLICK, (x) => {
      (x.x || x.y) && f.setFocus();
    }));
    const c = Me(l, Fo(".quick-input-description")), h = Me(l, Fo(".quick-input-and-message")), d = Me(h, Fo(".quick-input-filter")), f = this._register(new Jve(d));
    f.setAttribute("aria-describedby", `${this.idPrefix}message`);
    const p = Me(d, Fo(".quick-input-visible-count"));
    p.setAttribute("aria-live", "polite"), p.setAttribute("aria-atomic", "true");
    const g = new gV(p, { countFormat: b({ key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."] }, "{0} Results") }), _ = Me(d, Fo(".quick-input-count"));
    _.setAttribute("aria-live", "polite");
    const m = new gV(_, { countFormat: b({ key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."] }, "{0} Selected") }), v = Me(l, Fo(".quick-input-action")), C = new CV(v);
    C.label = b("ok", "OK"), this._register(C.onDidClick((x) => {
      this.onDidAcceptEmitter.fire();
    }));
    const y = Me(l, Fo(".quick-input-action")), w = new CV(y);
    w.label = b("custom", "Custom"), this._register(w.onDidClick((x) => {
      this.onDidCustomEmitter.fire();
    }));
    const L = Me(h, Fo(`#${this.idPrefix}message.quick-input-message`)), S = this._register(new dP(e, this.idPrefix + "list", this.options));
    this._register(S.onChangedAllVisibleChecked((x) => {
      u.checked = x;
    })), this._register(S.onChangedVisibleCount((x) => {
      g.setCount(x);
    })), this._register(S.onChangedCheckedCount((x) => {
      m.setCount(x);
    })), this._register(S.onLeave(() => {
      setTimeout(() => {
        f.setFocus(), this.controller instanceof w_ && this.controller.canSelectMany && S.clearFocus();
      }, 0);
    })), this._register(S.onDidChangeFocus(() => {
      this.comboboxAccessibility && this.getUI().inputBox.setAttribute("aria-activedescendant", this.getUI().list.getActiveDescendant() || "");
    }));
    const E = new i_e(e);
    E.getContainer().classList.add("quick-input-progress");
    const D = iE(e);
    return this._register(D), this._register(be(e, Ge.FOCUS, (x) => {
      this.previousFocusElement = x.relatedTarget instanceof HTMLElement ? x.relatedTarget : void 0;
    }, !0)), this._register(D.onDidBlur(() => {
      !this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut() && this.hide(y_.Blur), this.previousFocusElement = void 0;
    })), this._register(be(e, Ge.FOCUS, (x) => {
      f.setFocus();
    })), this._register(be(e, Ge.KEY_DOWN, (x) => {
      const R = new Yi(x);
      switch (R.keyCode) {
        case 3:
          gi.stop(x, !0), this.onDidAcceptEmitter.fire();
          break;
        case 9:
          gi.stop(x, !0), this.hide(y_.Gesture);
          break;
        case 2:
          if (!R.altKey && !R.ctrlKey && !R.metaKey) {
            const A = [".action-label.codicon"];
            e.classList.contains("show-checkboxes") ? A.push("input") : A.push("input[type=text]"), this.getUI().list.isDisplayed() && A.push(".monaco-list");
            const M = e.querySelectorAll(A.join(", "));
            R.shiftKey && R.target === M[0] ? (gi.stop(x, !0), M[M.length - 1].focus()) : !R.shiftKey && R.target === M[M.length - 1] && (gi.stop(x, !0), M[0].focus());
          }
          break;
      }
    })), this.ui = {
      container: e,
      styleSheet: t,
      leftActionBar: r,
      titleBar: i,
      title: o,
      description1: a,
      description2: c,
      rightActionBar: s,
      checkAll: u,
      filterContainer: d,
      inputBox: f,
      visibleCountContainer: p,
      visibleCount: g,
      countContainer: _,
      count: m,
      okContainer: v,
      ok: C,
      message: L,
      customButtonContainer: y,
      customButton: w,
      list: S,
      progressBar: E,
      onDidAccept: this.onDidAcceptEmitter.event,
      onDidCustom: this.onDidCustomEmitter.event,
      onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
      ignoreFocusOut: !1,
      keyMods: this.keyMods,
      isScreenReaderOptimized: () => this.options.isScreenReaderOptimized(),
      show: (x) => this.show(x),
      hide: () => this.hide(),
      setVisibilities: (x) => this.setVisibilities(x),
      setComboboxAccessibility: (x) => this.setComboboxAccessibility(x),
      setEnabled: (x) => this.setEnabled(x),
      setContextKey: (x) => this.options.setContextKey(x)
    }, this.updateStyles(), this.ui;
  }
  pick(e, t = {}, i = Ko.None) {
    return new Promise((r, o) => {
      let s = (c) => {
        s = r, t.onKeyMods && t.onKeyMods(a.keyMods), r(c);
      };
      if (i.isCancellationRequested) {
        s(void 0);
        return;
      }
      const a = this.createQuickPick();
      let l;
      const u = [
        a,
        a.onDidAccept(() => {
          if (a.canSelectMany)
            s(a.selectedItems.slice()), a.hide();
          else {
            const c = a.activeItems[0];
            c && (s(c), a.hide());
          }
        }),
        a.onDidChangeActive((c) => {
          const h = c[0];
          h && t.onDidFocus && t.onDidFocus(h);
        }),
        a.onDidChangeSelection((c) => {
          if (!a.canSelectMany) {
            const h = c[0];
            h && (s(h), a.hide());
          }
        }),
        a.onDidTriggerItemButton((c) => t.onDidTriggerItemButton && t.onDidTriggerItemButton(Object.assign(Object.assign({}, c), { removeItem: () => {
          const h = a.items.indexOf(c.item);
          if (h !== -1) {
            const d = a.items.slice(), f = d.splice(h, 1), p = a.activeItems.filter((g) => g !== f[0]);
            a.items = d, p && (a.activeItems = p);
          }
        } }))),
        a.onDidChangeValue((c) => {
          l && !c && (a.activeItems.length !== 1 || a.activeItems[0] !== l) && (a.activeItems = [l]);
        }),
        i.onCancellationRequested(() => {
          a.hide();
        }),
        a.onDidHide(() => {
          bi(u), s(void 0);
        })
      ];
      a.title = t.title, a.canSelectMany = !!t.canPickMany, a.placeholder = t.placeHolder, a.ignoreFocusOut = !!t.ignoreFocusLost, a.matchOnDescription = !!t.matchOnDescription, a.matchOnDetail = !!t.matchOnDetail, a.matchOnLabel = t.matchOnLabel === void 0 || t.matchOnLabel, a.autoFocusOnList = t.autoFocusOnList === void 0 || t.autoFocusOnList, a.quickNavigate = t.quickNavigate, a.contextKey = t.contextKey, a.busy = !0, Promise.all([e, t.activeItem]).then(([c, h]) => {
        l = h, a.busy = !1, a.items = c, a.canSelectMany && (a.selectedItems = c.filter((d) => d.type !== "separator" && d.picked)), l && (a.activeItems = [l]);
      }), a.show(), Promise.resolve(e).then(void 0, (c) => {
        o(c), a.hide();
      });
    });
  }
  createQuickPick() {
    const e = this.getUI();
    return new w_(e);
  }
  show(e) {
    const t = this.getUI();
    this.onShowEmitter.fire();
    const i = this.controller;
    this.controller = e, i && i.didHide(), this.setEnabled(!0), t.leftActionBar.clear(), t.title.textContent = "", t.description1.textContent = "", t.description2.textContent = "", t.rightActionBar.clear(), t.checkAll.checked = !1, t.inputBox.placeholder = "", t.inputBox.password = !1, t.inputBox.showDecoration(mn.Ignore), t.visibleCount.setCount(0), t.count.setCount(0), nE(t.message), t.progressBar.stop(), t.list.setElements([]), t.list.matchOnDescription = !1, t.list.matchOnDetail = !1, t.list.matchOnLabel = !0, t.list.sortByLabel = !0, t.ignoreFocusOut = !1, this.setComboboxAccessibility(!1), t.inputBox.ariaLabel = "";
    const r = this.options.backKeybindingLabel();
    HO.tooltip = r ? b("quickInput.backWithKeybinding", "Back ({0})", r) : b("quickInput.back", "Back"), t.container.style.display = "", this.updateLayout(), t.inputBox.setFocus();
  }
  setVisibilities(e) {
    const t = this.getUI();
    t.title.style.display = e.title ? "" : "none", t.description1.style.display = e.description && (e.inputBox || e.checkAll) ? "" : "none", t.description2.style.display = e.description && !(e.inputBox || e.checkAll) ? "" : "none", t.checkAll.style.display = e.checkAll ? "" : "none", t.filterContainer.style.display = e.inputBox ? "" : "none", t.visibleCountContainer.style.display = e.visibleCount ? "" : "none", t.countContainer.style.display = e.count ? "" : "none", t.okContainer.style.display = e.ok ? "" : "none", t.customButtonContainer.style.display = e.customButton ? "" : "none", t.message.style.display = e.message ? "" : "none", t.progressBar.getContainer().style.display = e.progressBar ? "" : "none", t.list.display(!!e.list), t.container.classList[e.checkBox ? "add" : "remove"]("show-checkboxes"), this.updateLayout();
  }
  setComboboxAccessibility(e) {
    if (e !== this.comboboxAccessibility) {
      const t = this.getUI();
      this.comboboxAccessibility = e, this.comboboxAccessibility ? (t.inputBox.setAttribute("role", "combobox"), t.inputBox.setAttribute("aria-haspopup", "true"), t.inputBox.setAttribute("aria-autocomplete", "list"), t.inputBox.setAttribute("aria-activedescendant", t.list.getActiveDescendant() || "")) : (t.inputBox.removeAttribute("role"), t.inputBox.removeAttribute("aria-haspopup"), t.inputBox.removeAttribute("aria-autocomplete"), t.inputBox.removeAttribute("aria-activedescendant"));
    }
  }
  setEnabled(e) {
    if (e !== this.enabled) {
      this.enabled = e;
      for (const t of this.getUI().leftActionBar.viewItems)
        t.getAction().enabled = e;
      for (const t of this.getUI().rightActionBar.viewItems)
        t.getAction().enabled = e;
      this.getUI().checkAll.disabled = !e, this.getUI().ok.enabled = e, this.getUI().list.enabled = e;
    }
  }
  hide(e) {
    var t;
    const i = this.controller;
    if (i) {
      const r = !(!((t = this.ui) === null || t === void 0) && t.container.contains(document.activeElement));
      this.controller = null, this.onHideEmitter.fire(), this.getUI().container.style.display = "none", r || (this.previousFocusElement && this.previousFocusElement.offsetParent ? (this.previousFocusElement.focus(), this.previousFocusElement = void 0) : this.options.returnFocus()), i.didHide(e);
    }
  }
  layout(e, t) {
    this.dimension = e, this.titleBarOffset = t, this.updateLayout();
  }
  updateLayout() {
    if (this.ui) {
      this.ui.container.style.top = `${this.titleBarOffset}px`;
      const e = this.ui.container.style, t = Math.min(this.dimension.width * 0.62, ZE.MAX_WIDTH);
      e.width = t + "px", e.marginLeft = "-" + t / 2 + "px", this.ui.inputBox.layout(), this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
    }
  }
  applyStyles(e) {
    this.styles = e, this.updateStyles();
  }
  updateStyles() {
    if (this.ui) {
      const { quickInputTitleBackground: e, quickInputBackground: t, quickInputForeground: i, contrastBorder: r, widgetShadow: o } = this.styles.widget;
      this.ui.titleBar.style.backgroundColor = e ? e.toString() : "", this.ui.container.style.backgroundColor = t ? t.toString() : "", this.ui.container.style.color = i ? i.toString() : "", this.ui.container.style.border = r ? `1px solid ${r}` : "", this.ui.container.style.boxShadow = o ? `0 0 8px 2px ${o}` : "", this.ui.inputBox.style(this.styles.inputBox), this.ui.count.style(this.styles.countBadge), this.ui.ok.style(this.styles.button), this.ui.customButton.style(this.styles.button), this.ui.progressBar.style(this.styles.progressBar), this.ui.list.style(this.styles.list);
      const s = [];
      this.styles.list.pickerGroupBorder && s.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.list.pickerGroupBorder}; }`), this.styles.list.pickerGroupForeground && s.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.list.pickerGroupForeground}; }`), (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) && (s.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {"), this.styles.keybindingLabel.keybindingLabelBackground && s.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`), this.styles.keybindingLabel.keybindingLabelBorder && s.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`), this.styles.keybindingLabel.keybindingLabelBottomBorder && s.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`), this.styles.keybindingLabel.keybindingLabelShadow && s.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`), this.styles.keybindingLabel.keybindingLabelForeground && s.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`), s.push("}"));
      const a = s.join(`
`);
      a !== this.ui.styleSheet.textContent && (this.ui.styleSheet.textContent = a);
    }
  }
}
ZE.MAX_WIDTH = 600;
const EU = Vt("quickInputService");
var GO;
(function(n) {
  n[n.PRESERVE = 0] = "PRESERVE", n[n.LAST = 1] = "LAST";
})(GO || (GO = {}));
const LU = {
  Quickaccess: "workbench.contributions.quickaccess"
};
class o_e {
  constructor() {
    this.providers = [], this.defaultProvider = void 0;
  }
  registerQuickAccessProvider(e) {
    return e.prefix.length === 0 ? this.defaultProvider = e : this.providers.push(e), this.providers.sort((t, i) => i.prefix.length - t.prefix.length), Oi(() => {
      this.providers.splice(this.providers.indexOf(e), 1), this.defaultProvider === e && (this.defaultProvider = void 0);
    });
  }
  getQuickAccessProviders() {
    return oae([this.defaultProvider, ...this.providers]);
  }
  getQuickAccessProvider(e) {
    return e && this.providers.find((i) => e.startsWith(i.prefix)) || void 0 || this.defaultProvider;
  }
}
Jn.add(LU.Quickaccess, new o_e());
var s_e = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, wV = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let UO = class extends Ce {
  constructor(e, t) {
    super(), this.quickInputService = e, this.instantiationService = t, this.registry = Jn.as(LU.Quickaccess), this.mapProviderToDescriptor = /* @__PURE__ */ new Map(), this.lastAcceptedPickerValues = /* @__PURE__ */ new Map(), this.visibleQuickAccess = void 0;
  }
  show(e = "", t) {
    this.doShowOrPick(e, !1, t);
  }
  doShowOrPick(e, t, i) {
    var r;
    const [o, s] = this.getOrInstantiateProvider(e), a = this.visibleQuickAccess, l = a == null ? void 0 : a.descriptor;
    if (a && s && l === s) {
      e !== s.prefix && !(i != null && i.preserveValue) && (a.picker.value = e), this.adjustValueSelection(a.picker, s, i);
      return;
    }
    if (s && !(i != null && i.preserveValue)) {
      let p;
      if (a && l && l !== s) {
        const g = a.value.substr(l.prefix.length);
        g && (p = `${s.prefix}${g}`);
      }
      if (!p) {
        const g = o == null ? void 0 : o.defaultFilterValue;
        g === GO.LAST ? p = this.lastAcceptedPickerValues.get(s) : typeof g == "string" && (p = `${s.prefix}${g}`);
      }
      typeof p == "string" && (e = p);
    }
    const u = new dt(), c = u.add(this.quickInputService.createQuickPick());
    c.value = e, this.adjustValueSelection(c, s, i), c.placeholder = s == null ? void 0 : s.placeholder, c.quickNavigate = i == null ? void 0 : i.quickNavigateConfiguration, c.hideInput = !!c.quickNavigate && !a, (typeof (i == null ? void 0 : i.itemActivation) == "number" || i != null && i.quickNavigateConfiguration) && (c.itemActivation = (r = i == null ? void 0 : i.itemActivation) !== null && r !== void 0 ? r : ka.SECOND), c.contextKey = s == null ? void 0 : s.contextKey, c.filterValue = (p) => p.substring(s ? s.prefix.length : 0), s != null && s.placeholder && (c.ariaLabel = s == null ? void 0 : s.placeholder);
    let h, d;
    t && (h = new Promise((p) => d = p), u.add(sg(c.onWillAccept)((p) => {
      p.veto(), c.hide();
    }))), u.add(this.registerPickerListeners(c, o, s, e));
    const f = u.add(new mh());
    if (o && u.add(o.provide(c, f.token)), sg(c.onDidHide)(() => {
      c.selectedItems.length === 0 && f.cancel(), u.dispose(), d == null || d(c.selectedItems);
    }), c.show(), t)
      return h;
  }
  adjustValueSelection(e, t, i) {
    var r;
    let o;
    i != null && i.preserveValue ? o = [e.value.length, e.value.length] : o = [(r = t == null ? void 0 : t.prefix.length) !== null && r !== void 0 ? r : 0, e.value.length], e.valueSelection = o;
  }
  registerPickerListeners(e, t, i, r) {
    const o = new dt(), s = this.visibleQuickAccess = { picker: e, descriptor: i, value: r };
    return o.add(Oi(() => {
      s === this.visibleQuickAccess && (this.visibleQuickAccess = void 0);
    })), o.add(e.onDidChangeValue((a) => {
      const [l] = this.getOrInstantiateProvider(a);
      l !== t ? this.show(
        a,
        { preserveValue: !0 }
        /* do not rewrite value from user typing! */
      ) : s.value = a;
    })), i && o.add(e.onDidAccept(() => {
      this.lastAcceptedPickerValues.set(i, e.value);
    })), o;
  }
  getOrInstantiateProvider(e) {
    const t = this.registry.getQuickAccessProvider(e);
    if (!t)
      return [void 0, void 0];
    let i = this.mapProviderToDescriptor.get(t);
    return i || (i = this.instantiationService.createInstance(t.ctor), this.mapProviderToDescriptor.set(t, i)), [i, t];
  }
};
UO = s_e([
  wV(0, EU),
  wV(1, no)
], UO);
var a_e = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, qm = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let zO = class extends Fle {
  constructor(e, t, i, r, o) {
    super(i), this.instantiationService = e, this.contextKeyService = t, this.accessibilityService = r, this.layoutService = o, this.contexts = /* @__PURE__ */ new Map();
  }
  get controller() {
    return this._controller || (this._controller = this._register(this.createController())), this._controller;
  }
  get quickAccess() {
    return this._quickAccess || (this._quickAccess = this._register(this.instantiationService.createInstance(UO))), this._quickAccess;
  }
  createController(e = this.layoutService, t) {
    var i, r;
    const o = {
      idPrefix: "quickInput_",
      container: e.container,
      ignoreFocusOut: () => !1,
      isScreenReaderOptimized: () => this.accessibilityService.isScreenReaderOptimized(),
      backKeybindingLabel: () => {
      },
      setContextKey: (a) => this.setContextKey(a),
      returnFocus: () => e.focus(),
      createList: (a, l, u, c, h) => this.instantiationService.createInstance(PO, a, l, u, c, h),
      styles: this.computeStyles()
    }, s = this._register(new ZE(Object.assign(Object.assign({}, o), t)));
    return s.layout(e.dimension, (r = (i = e.offset) === null || i === void 0 ? void 0 : i.top) !== null && r !== void 0 ? r : 0), this._register(e.onDidLayout((a) => {
      var l, u;
      return s.layout(a, (u = (l = e.offset) === null || l === void 0 ? void 0 : l.top) !== null && u !== void 0 ? u : 0);
    })), this._register(s.onShow(() => this.resetContextKeys())), this._register(s.onHide(() => this.resetContextKeys())), s;
  }
  setContextKey(e) {
    let t;
    e && (t = this.contexts.get(e), t || (t = new nt(e, !1).bindTo(this.contextKeyService), this.contexts.set(e, t))), !(t && t.get()) && (this.resetContextKeys(), t && t.set(!0));
  }
  resetContextKeys() {
    this.contexts.forEach((e) => {
      e.get() && e.reset();
    });
  }
  pick(e, t = {}, i = Ko.None) {
    return this.controller.pick(e, t, i);
  }
  createQuickPick() {
    return this.controller.createQuickPick();
  }
  updateStyles() {
    this.controller.applyStyles(this.computeStyles());
  }
  computeStyles() {
    return {
      widget: Object.assign({}, Va(this.theme, {
        quickInputBackground: V2,
        quickInputForeground: Wce,
        quickInputTitleBackground: Vce,
        contrastBorder: pr,
        widgetShadow: zb
      })),
      inputBox: Va(this.theme, {
        inputForeground: _ce,
        inputBackground: vce,
        inputBorder: Cce,
        inputValidationInfoBackground: yce,
        inputValidationInfoForeground: wce,
        inputValidationInfoBorder: bce,
        inputValidationWarningBackground: Sce,
        inputValidationWarningForeground: Ece,
        inputValidationWarningBorder: Lce,
        inputValidationErrorBackground: Dce,
        inputValidationErrorForeground: Rce,
        inputValidationErrorBorder: Tce
      }),
      countBadge: Va(this.theme, {
        badgeBackground: G3,
        badgeForeground: U3,
        badgeBorder: pr
      }),
      button: Va(this.theme, {
        buttonForeground: Oce,
        buttonBackground: eO,
        buttonHoverBackground: xce,
        buttonBorder: pr
      }),
      progressBar: Va(this.theme, {
        progressBarBackground: Nce
      }),
      keybindingLabel: Va(this.theme, {
        keybindingLabelBackground: Gce,
        keybindingLabelForeground: Uce,
        keybindingLabelBorder: zce,
        keybindingLabelBottomBorder: jce,
        keybindingLabelShadow: zb
      }),
      list: Va(this.theme, {
        listBackground: V2,
        // Look like focused when inactive.
        listInactiveFocusForeground: fhe,
        listInactiveFocusBackground: phe,
        listFocusOutline: Ms,
        listInactiveFocusOutline: Ms,
        pickerGroupBorder: Hce,
        pickerGroupForeground: Bce
      })
    };
  }
};
zO = a_e([
  qm(0, no),
  qm(1, xi),
  qm(2, er),
  qm(3, ks),
  qm(4, GE)
], zO);
var DU = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, o = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(n, e, t, i);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (s = n[a]) && (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
  return r > 3 && o && Object.defineProperty(e, t, o), o;
}, nd = globalThis && globalThis.__param || function(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
};
let jO = class extends zO {
  constructor(e, t, i, r, o, s) {
    super(t, i, r, o, s), this.host = void 0;
    const a = fg.get(e);
    this.host = {
      _serviceBrand: void 0,
      get container() {
        return a.widget.getDomNode();
      },
      get dimension() {
        return e.getLayoutInfo();
      },
      get onDidLayout() {
        return e.onDidLayoutChange;
      },
      focus: () => e.focus()
    };
  }
  createController() {
    return super.createController(this.host);
  }
};
jO = DU([
  nd(1, no),
  nd(2, xi),
  nd(3, er),
  nd(4, ks),
  nd(5, GE)
], jO);
let $O = class {
  constructor(e, t) {
    this.instantiationService = e, this.codeEditorService = t, this.mapEditorToService = /* @__PURE__ */ new Map();
  }
  get activeService() {
    const e = this.codeEditorService.getFocusedCodeEditor();
    if (!e)
      throw new Error("Quick input service needs a focused editor to work.");
    let t = this.mapEditorToService.get(e);
    if (!t) {
      const i = t = this.instantiationService.createInstance(jO, e);
      this.mapEditorToService.set(e, t), sg(e.onDidDispose)(() => {
        i.dispose(), this.mapEditorToService.delete(e);
      });
    }
    return t;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  pick(e, t = {}, i = Ko.None) {
    return this.activeService.pick(e, t, i);
  }
  createQuickPick() {
    return this.activeService.createQuickPick();
  }
};
$O = DU([
  nd(0, no),
  nd(1, mr)
], $O);
class fg {
  constructor(e) {
    this.editor = e, this.widget = new QE(this.editor);
  }
  static get(e) {
    return e.getContribution(fg.ID);
  }
  dispose() {
    this.widget.dispose();
  }
}
fg.ID = "editor.controller.quickInput";
class QE {
  constructor(e) {
    this.codeEditor = e, this.domNode = document.createElement("div"), this.codeEditor.addOverlayWidget(this);
  }
  getId() {
    return QE.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      preference: 2
      /* TOP_CENTER */
    };
  }
  dispose() {
    this.codeEditor.removeOverlayWidget(this);
  }
}
QE.ID = "editor.contrib.quickInputWidget";
E3(fg.ID, fg);
var Ft;
(function(n) {
  const e = new f_();
  class t {
    constructor(l, u) {
      this._serviceId = l, this._factory = u, this._value = null;
    }
    get id() {
      return this._serviceId;
    }
    get(l) {
      if (!this._value) {
        if (l && (this._value = l[this._serviceId.toString()]), this._value || (this._value = this._factory(l)), !this._value)
          throw new Error("Service " + this._serviceId + " is missing!");
        e.set(this._serviceId, this._value);
      }
      return this._value;
    }
  }
  n.LazyStaticService = t;
  let i = [];
  function r(a, l) {
    let u = new t(a, l);
    return i.push(u), u;
  }
  function o(a) {
    let l = new f_();
    for (const [c, h] of tpe())
      l.set(c, h);
    for (let c in a)
      a.hasOwnProperty(c) && l.set(Vt(c), a[c]);
    i.forEach((c) => l.set(c.id, c.get(a)));
    let u = new dS(l, !0);
    return l.set(no, u), [l, u];
  }
  n.init = o, n.instantiationService = r(no, () => new dS(e, !0));
  const s = new p3();
  n.configurationService = r(_r, () => s), n.resourceConfigurationService = r(z5, () => new Rle(s)), n.resourcePropertiesService = r(j5, () => new $T(s)), n.contextService = r(wle, () => new mE()), n.labelService = r(eme, () => new xle()), n.telemetryService = r(EE, () => new Tle()), n.dialogService = r(J7, () => new Lle()), n.notificationService = r(al, () => new gE()), n.markerService = r(pU, () => new Al()), n.modeService = r(QN, (a) => new Bpe()), n.standaloneThemeService = r(J_, () => new vge()), n.logService = r(K_, () => new cae(new uae())), n.undoRedoService = r(VI, (a) => new CS(n.dialogService.get(a), n.notificationService.get(a))), n.modelService = r(ao, (a) => new aS(n.configurationService.get(a), n.resourcePropertiesService.get(a), n.standaloneThemeService.get(a), n.logService.get(a), n.undoRedoService.get(a))), n.markerDecorationsService = r(g3, (a) => new FO(n.modelService.get(a), n.markerService.get(a))), n.contextKeyService = r(xi, (a) => new vO(n.configurationService.get(a))), n.codeEditorService = r(mr, (a) => new rS(null, n.contextKeyService.get(a), n.standaloneThemeService.get(a))), n.editorProgressService = r(WE, () => new pE()), n.storageService = r(vve, () => new _ve()), n.editorWorkerService = r(sc, (a) => new HT(n.modelService.get(a), n.resourceConfigurationService.get(a), n.logService.get(a)));
})(Ft || (Ft = {}));
class l_e extends Ce {
  constructor(e, t) {
    super();
    const [i, r] = Ft.init(t);
    this._serviceCollection = i, this._instantiationService = r;
    const o = this.get(_r), s = this.get(al), a = this.get(EE), l = this.get(er), u = this.get(K_), c = this.get(xi);
    let h = (_, m) => {
      let v = null;
      return t && (v = t[_.toString()]), v || (v = m()), this._serviceCollection.set(_, v), v;
    };
    h(ks, () => new kO(c, o)), h(ou, () => new NO(l));
    let d = h(Xo, () => new Dle(this._instantiationService)), f = h(xo, () => this._register(new f3(c, d, a, s, u, e))), p = h(GE, () => new Nle(Ft.codeEditorService.get(mr), e));
    h(EU, () => new $O(r, Ft.codeEditorService.get(mr)));
    let g = h(Bg, () => this._register(new LO(p)));
    h(kE, () => new bve()), h(FE, () => {
      const _ = new EO(a, s, g, f, l);
      return _.configure({ blockMouse: !1 }), this._register(_);
    }), h(y3, () => new AO(d)), h(Wae, () => new Ole(Ft.modelService.get(ao)));
  }
  get(e) {
    let t = this._serviceCollection.get(e);
    if (!t)
      throw new Error("Missing service " + e);
    return t;
  }
  set(e, t) {
    this._serviceCollection.set(e, t);
  }
  has(e) {
    return this._serviceCollection.has(e);
  }
}
function RU(n, e, t) {
  let i = new l_e(n, e), r = null;
  i.has(bb) || (r = new jT(Ft.modelService.get()), i.set(bb, r)), i.has(_k) || i.set(_k, new yT(i.get(mr), i.get(Xo)));
  let o = t(i);
  return r && r.setEditor(o), o;
}
function u_e(n, e, t) {
  return RU(n, t || {}, (i) => new pO(n, e, i, i.get(no), i.get(mr), i.get(Xo), i.get(xi), i.get(xo), i.get(Bg), i.get(J_), i.get(al), i.get(_r), i.get(ks), i.get(ao), i.get(QN)));
}
function c_e(n) {
  return Ft.codeEditorService.get().onCodeEditorAdd((e) => {
    n(e);
  });
}
function h_e(n, e, t) {
  return RU(n, t || {}, (i) => new gO(n, e, i, i.get(no), i.get(xi), i.get(xo), i.get(Bg), i.get(sc), i.get(mr), i.get(J_), i.get(al), i.get(_r), i.get(FE), i.get(WE), i.get(kE)));
}
function d_e(n, e) {
  return new Woe(n, e);
}
function f_e(n, e, t) {
  return R7(Ft.modelService.get(), Ft.modeService.get(), n, e, t);
}
function p_e(n, e) {
  Ft.modelService.get().setMode(n, Ft.modeService.get().create(e));
}
function g_e(n, e, t) {
  n && Ft.markerService.get().changeOne(e, n.uri, t);
}
function m_e(n) {
  return Ft.markerService.get().read(n);
}
function v_e(n) {
  return Ft.markerService.get().onMarkerChanged(n);
}
function __e(n) {
  return Ft.modelService.get().getModel(n);
}
function C_e() {
  return Ft.modelService.get().getModels();
}
function y_e(n) {
  return Ft.modelService.get().onModelAdded(n);
}
function w_e(n) {
  return Ft.modelService.get().onModelRemoved(n);
}
function b_e(n) {
  return Ft.modelService.get().onModelModeChanged((e) => {
    n({
      model: e.model,
      oldLanguage: e.oldModeId
    });
  });
}
function S_e(n) {
  return gae(Ft.modelService.get(), n);
}
function E_e(n, e) {
  const t = Ft.standaloneThemeService.get();
  return t.registerEditorContainer(n), oI.colorizeElement(t, Ft.modeService.get(), n, e);
}
function L_e(n, e, t) {
  return Ft.standaloneThemeService.get().registerEditorContainer(document.body), oI.colorize(Ft.modeService.get(), n, e, t);
}
function D_e(n, e, t = 4) {
  return Ft.standaloneThemeService.get().registerEditorContainer(document.body), oI.colorizeModelLine(n, e, t);
}
function R_e(n) {
  let e = cn.get(n);
  return e || {
    getInitialState: () => sE,
    tokenize: (t, i, r, o) => Cse(n, t, r, o)
  };
}
function T_e(n, e) {
  Ft.modeService.get().triggerMode(e);
  let i = R_e(e), r = z_(n), o = [], s = i.getInitialState();
  for (let a = 0, l = r.length; a < l; a++) {
    let u = r[a], c = i.tokenize(u, !0, s, 0);
    o[a] = c.tokens, s = c.endState;
  }
  return o;
}
function O_e(n, e) {
  Ft.standaloneThemeService.get().defineTheme(n, e);
}
function x_e(n) {
  Ft.standaloneThemeService.get().setTheme(n);
}
function N_e() {
  jle();
}
function I_e(n, e) {
  return Qn.registerCommand({ id: n, handler: e });
}
function P_e() {
  return {
    // methods
    create: u_e,
    onDidCreateEditor: c_e,
    createDiffEditor: h_e,
    createDiffNavigator: d_e,
    createModel: f_e,
    setModelLanguage: p_e,
    setModelMarkers: g_e,
    getModelMarkers: m_e,
    onDidChangeMarkers: v_e,
    getModels: C_e,
    getModel: __e,
    onDidCreateModel: y_e,
    onWillDisposeModel: w_e,
    onDidChangeModelLanguage: b_e,
    createWebWorker: S_e,
    colorizeElement: E_e,
    colorize: L_e,
    colorizeModelLine: D_e,
    tokenize: T_e,
    defineTheme: O_e,
    setTheme: x_e,
    remeasureFonts: N_e,
    registerCommand: I_e,
    // enums
    AccessibilitySupport: DR,
    ContentWidgetPositionPreference: NR,
    CursorChangeReason: IR,
    DefaultEndOfLine: PR,
    EditorAutoIndentStrategy: MR,
    EditorOption: FR,
    EndOfLinePreference: kR,
    EndOfLineSequence: WR,
    MinimapPosition: jR,
    MouseTargetType: $R,
    OverlayWidgetPositionPreference: KR,
    OverviewRulerLane: qR,
    RenderLineNumbersType: YR,
    RenderMinimap: XR,
    ScrollbarVisibility: QR,
    ScrollType: ZR,
    TextEditorCursorBlinkingStyle: nT,
    TextEditorCursorStyle: rT,
    TrackedRangeStickiness: oT,
    WrappingIndent: sT,
    // classes
    ConfigurationChangedEvent: kG,
    BareFontInfo: Zp,
    FontInfo: bT,
    TextModelResolvedOptions: aw,
    FindMatch: Zv,
    // vars
    EditorType: $_,
    EditorOptions: sf
  };
}
function A_e(n, e) {
  if (!e || !Array.isArray(e))
    return !1;
  for (const t of e)
    if (!n(t))
      return !1;
  return !0;
}
function $y(n, e) {
  return typeof n == "boolean" ? n : e;
}
function bV(n, e) {
  return typeof n == "string" ? n : e;
}
function M_e(n) {
  const e = {};
  for (const t of n)
    e[t] = !0;
  return e;
}
function SV(n, e = !1) {
  e && (n = n.map(function(i) {
    return i.toLowerCase();
  }));
  const t = M_e(n);
  return e ? function(i) {
    return t[i.toLowerCase()] !== void 0 && t.hasOwnProperty(i.toLowerCase());
  } : function(i) {
    return t[i] !== void 0 && t.hasOwnProperty(i);
  };
}
function KO(n, e) {
  e = e.replace(/@@/g, "");
  let t = 0, i;
  do
    i = !1, e = e.replace(/@(\w+)/g, function(o, s) {
      i = !0;
      let a = "";
      if (typeof n[s] == "string")
        a = n[s];
      else if (n[s] && n[s] instanceof RegExp)
        a = n[s].source;
      else
        throw n[s] === void 0 ? ei(n, "language definition does not contain attribute '" + s + "', used at: " + e) : ei(n, "attribute reference '" + s + "' must be a string, used at: " + e);
      return qf(a) ? "" : "(?:" + a + ")";
    }), t++;
  while (i && t < 5);
  e = e.replace(/\x01/g, "@");
  let r = (n.ignoreCase ? "i" : "") + (n.unicode ? "u" : "");
  return new RegExp(e, r);
}
function F_e(n, e, t, i) {
  if (i < 0)
    return n;
  if (i < e.length)
    return e[i];
  if (i >= 100) {
    i = i - 100;
    let r = t.split(".");
    if (r.unshift(t), i < r.length)
      return r[i];
  }
  return null;
}
function k_e(n, e, t, i) {
  let r = -1, o = t, s = t.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
  s && (s[3] && (r = parseInt(s[3]), s[2] && (r = r + 100)), o = s[4]);
  let a = "~", l = o;
  !o || o.length === 0 ? (a = "!=", l = "") : /^\w*$/.test(l) ? a = "==" : (s = o.match(/^(@|!@|~|!~|==|!=)(.*)$/), s && (a = s[1], l = s[2]));
  let u;
  if ((a === "~" || a === "!~") && /^(\w|\|)*$/.test(l)) {
    let c = SV(l.split("|"), n.ignoreCase);
    u = function(h) {
      return a === "~" ? c(h) : !c(h);
    };
  } else if (a === "@" || a === "!@") {
    let c = n[l];
    if (!c)
      throw ei(n, "the @ match target '" + l + "' is not defined, in rule: " + e);
    if (!A_e(function(d) {
      return typeof d == "string";
    }, c))
      throw ei(n, "the @ match target '" + l + "' must be an array of strings, in rule: " + e);
    let h = SV(c, n.ignoreCase);
    u = function(d) {
      return a === "@" ? h(d) : !h(d);
    };
  } else if (a === "~" || a === "!~")
    if (l.indexOf("$") < 0) {
      let c = KO(n, "^" + l + "$");
      u = function(h) {
        return a === "~" ? c.test(h) : !c.test(h);
      };
    } else
      u = function(c, h, d, f) {
        return KO(n, "^" + Bc(n, l, h, d, f) + "$").test(c);
      };
  else if (l.indexOf("$") < 0) {
    let c = eh(n, l);
    u = function(h) {
      return a === "==" ? h === c : h !== c;
    };
  } else {
    let c = eh(n, l);
    u = function(h, d, f, p, g) {
      let _ = Bc(n, c, d, f, p);
      return a === "==" ? h === _ : h !== _;
    };
  }
  return r === -1 ? {
    name: t,
    value: i,
    test: function(c, h, d, f) {
      return u(c, c, h, d, f);
    }
  } : {
    name: t,
    value: i,
    test: function(c, h, d, f) {
      let p = F_e(c, h, d, r);
      return u(p || "", c, h, d, f);
    }
  };
}
function qO(n, e, t) {
  if (t) {
    if (typeof t == "string")
      return t;
    if (t.token || t.token === "") {
      if (typeof t.token != "string")
        throw ei(n, "a 'token' attribute must be of type string, in rule: " + e);
      {
        let i = { token: t.token };
        if (t.token.indexOf("$") >= 0 && (i.tokenSubst = !0), typeof t.bracket == "string")
          if (t.bracket === "@open")
            i.bracket = 1;
          else if (t.bracket === "@close")
            i.bracket = -1;
          else
            throw ei(n, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + e);
        if (t.next) {
          if (typeof t.next != "string")
            throw ei(n, "the next state must be a string value in rule: " + e);
          {
            let r = t.next;
            if (!/^(@pop|@push|@popall)$/.test(r) && (r[0] === "@" && (r = r.substr(1)), r.indexOf("$") < 0 && !Iae(n, Bc(n, r, "", [], ""))))
              throw ei(n, "the next state '" + t.next + "' is not defined in rule: " + e);
            i.next = r;
          }
        }
        return typeof t.goBack == "number" && (i.goBack = t.goBack), typeof t.switchTo == "string" && (i.switchTo = t.switchTo), typeof t.log == "string" && (i.log = t.log), typeof t.nextEmbedded == "string" && (i.nextEmbedded = t.nextEmbedded, n.usesEmbedded = !0), i;
      }
    } else if (Array.isArray(t)) {
      let i = [];
      for (let r = 0, o = t.length; r < o; r++)
        i[r] = qO(n, e, t[r]);
      return { group: i };
    } else if (t.cases) {
      let i = [];
      for (let o in t.cases)
        if (t.cases.hasOwnProperty(o)) {
          const s = qO(n, e, t.cases[o]);
          o === "@default" || o === "@" || o === "" ? i.push({ test: void 0, value: s, name: o }) : o === "@eos" ? i.push({ test: function(a, l, u, c) {
            return c;
          }, value: s, name: o }) : i.push(k_e(n, e, o, s));
        }
      const r = n.defaultToken;
      return {
        test: function(o, s, a, l) {
          for (const u of i)
            if (!u.test || u.test(o, s, a, l))
              return u.value;
          return r;
        }
      };
    } else
      throw ei(n, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + e);
  } else
    return { token: "" };
}
class W_e {
  constructor(e) {
    this.regex = new RegExp(""), this.action = { token: "" }, this.matchOnlyAtLineStart = !1, this.name = "", this.name = e;
  }
  setRegex(e, t) {
    let i;
    if (typeof t == "string")
      i = t;
    else if (t instanceof RegExp)
      i = t.source;
    else
      throw ei(e, "rules must start with a match string or regular expression: " + this.name);
    this.matchOnlyAtLineStart = i.length > 0 && i[0] === "^", this.name = this.name + ": " + i, this.regex = KO(e, "^(?:" + (this.matchOnlyAtLineStart ? i.substr(1) : i) + ")");
  }
  setAction(e, t) {
    this.action = qO(e, this.name, t);
  }
}
function V_e(n, e) {
  if (!e || typeof e != "object")
    throw new Error("Monarch: expecting a language definition object");
  let t = {};
  t.languageId = n, t.includeLF = $y(e.includeLF, !1), t.noThrow = !1, t.maxStack = 100, t.start = typeof e.start == "string" ? e.start : null, t.ignoreCase = $y(e.ignoreCase, !1), t.unicode = $y(e.unicode, !1), t.tokenPostfix = bV(e.tokenPostfix, "." + t.languageId), t.defaultToken = bV(e.defaultToken, "source"), t.usesEmbedded = !1;
  let i = e;
  i.languageId = n, i.includeLF = t.includeLF, i.ignoreCase = t.ignoreCase, i.unicode = t.unicode, i.noThrow = t.noThrow, i.usesEmbedded = t.usesEmbedded, i.stateNames = e.tokenizer, i.defaultToken = t.defaultToken;
  function r(s, a, l) {
    for (const u of l) {
      let c = u.include;
      if (c) {
        if (typeof c != "string")
          throw ei(t, "an 'include' attribute must be a string at: " + s);
        if (c[0] === "@" && (c = c.substr(1)), !e.tokenizer[c])
          throw ei(t, "include target '" + c + "' is not defined at: " + s);
        r(s + "." + c, a, e.tokenizer[c]);
      } else {
        const h = new W_e(s);
        if (Array.isArray(u) && u.length >= 1 && u.length <= 3)
          if (h.setRegex(i, u[0]), u.length >= 3)
            if (typeof u[1] == "string")
              h.setAction(i, { token: u[1], next: u[2] });
            else if (typeof u[1] == "object") {
              const d = u[1];
              d.next = u[2], h.setAction(i, d);
            } else
              throw ei(t, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + s);
          else
            h.setAction(i, u[1]);
        else {
          if (!u.regex)
            throw ei(t, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + s);
          u.name && typeof u.name == "string" && (h.name = u.name), u.matchOnlyAtStart && (h.matchOnlyAtLineStart = $y(u.matchOnlyAtLineStart, !1)), h.setRegex(i, u.regex), h.setAction(i, u.action);
        }
        a.push(h);
      }
    }
  }
  if (!e.tokenizer || typeof e.tokenizer != "object")
    throw ei(t, "a language definition must define the 'tokenizer' attribute as an object");
  t.tokenizer = [];
  for (let s in e.tokenizer)
    if (e.tokenizer.hasOwnProperty(s)) {
      t.start || (t.start = s);
      const a = e.tokenizer[s];
      t.tokenizer[s] = new Array(), r("tokenizer." + s, t.tokenizer[s], a);
    }
  if (t.usesEmbedded = i.usesEmbedded, e.brackets) {
    if (!Array.isArray(e.brackets))
      throw ei(t, "the 'brackets' attribute must be defined as an array");
  } else
    e.brackets = [
      { open: "{", close: "}", token: "delimiter.curly" },
      { open: "[", close: "]", token: "delimiter.square" },
      { open: "(", close: ")", token: "delimiter.parenthesis" },
      { open: "<", close: ">", token: "delimiter.angle" }
    ];
  let o = [];
  for (let s of e.brackets) {
    let a = s;
    if (a && Array.isArray(a) && a.length === 3 && (a = { token: a[2], open: a[0], close: a[1] }), a.open === a.close)
      throw ei(t, "open and close brackets in a 'brackets' attribute must be different: " + a.open + `
 hint: use the 'bracket' attribute if matching on equal brackets is required.`);
    if (typeof a.open == "string" && typeof a.token == "string" && typeof a.close == "string")
      o.push({
        token: a.token + t.tokenPostfix,
        open: eh(t, a.open),
        close: eh(t, a.close)
      });
    else
      throw ei(t, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
  }
  return t.brackets = o, t.noThrow = !0, t;
}
function B_e(n) {
  Rd.registerLanguage(n);
}
function H_e() {
  let n = [];
  return n = n.concat(Rd.getLanguages()), n;
}
function G_e(n) {
  let e = Ft.modeService.get().getLanguageIdentifier(n);
  return e ? e.id : 0;
}
function U_e(n, e) {
  let t = Ft.modeService.get().onDidCreateMode((i) => {
    i.getId() === n && (t.dispose(), e());
  });
  return t;
}
function z_e(n, e) {
  let t = Ft.modeService.get().getLanguageIdentifier(n);
  if (!t)
    throw new Error(`Cannot set configuration for unknown language ${n}`);
  return ui.register(t, e, 100);
}
class j_e {
  constructor(e, t) {
    this._languageIdentifier = e, this._actual = t;
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  tokenize(e, t, i, r) {
    if (typeof this._actual.tokenize == "function")
      return b_.adaptTokenize(this._languageIdentifier.language, this._actual, e, i, r);
    throw new Error("Not supported!");
  }
  tokenize2(e, t, i) {
    let r = this._actual.tokenizeEncoded(e, i);
    return new eE(r.tokens, r.endState);
  }
}
class b_ {
  constructor(e, t, i) {
    this._standaloneThemeService = e, this._languageIdentifier = t, this._actual = i;
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  static _toClassicTokens(e, t, i) {
    let r = [], o = 0;
    for (let s = 0, a = e.length; s < a; s++) {
      const l = e[s];
      let u = l.startIndex;
      s === 0 ? u = 0 : u < o && (u = o), r[s] = new JS(u + i, l.scopes, t), o = u;
    }
    return r;
  }
  static adaptTokenize(e, t, i, r, o) {
    let s = t.tokenize(i, r), a = b_._toClassicTokens(s.tokens, e, o), l;
    return s.endState.equals(r) ? l = r : l = s.endState, new PN(a, l);
  }
  tokenize(e, t, i, r) {
    return b_.adaptTokenize(this._languageIdentifier.language, this._actual, e, i, r);
  }
  _toBinaryTokens(e, t) {
    const i = this._languageIdentifier.id, r = this._standaloneThemeService.getColorTheme().tokenTheme;
    let o = [], s = 0, a = 0;
    for (let u = 0, c = e.length; u < c; u++) {
      const h = e[u], d = r.match(i, h.scopes);
      if (s > 0 && o[s - 1] === d)
        continue;
      let f = h.startIndex;
      u === 0 ? f = 0 : f < a && (f = a), o[s++] = f + t, o[s++] = d, a = f;
    }
    let l = new Uint32Array(s);
    for (let u = 0; u < s; u++)
      l[u] = o[u];
    return l;
  }
  tokenize2(e, t, i, r) {
    let o = this._actual.tokenize(e, i), s = this._toBinaryTokens(o.tokens, r), a;
    return o.endState.equals(i) ? a = i : a = o.endState, new eE(s, a);
  }
}
function $_e(n) {
  return "tokenizeEncoded" in n;
}
function TU(n) {
  return n && typeof n.then == "function";
}
function K_e(n) {
  if (n) {
    const e = [null];
    for (let t = 1, i = n.length; t < i; t++)
      e[t] = ne.fromHex(n[t]);
    Ft.standaloneThemeService.get().setColorMapOverride(e);
  } else
    Ft.standaloneThemeService.get().setColorMapOverride(null);
}
function q_e(n, e) {
  let t = Ft.modeService.get().getLanguageIdentifier(n);
  if (!t)
    throw new Error(`Cannot set tokens provider for unknown language ${n}`);
  const i = (r) => $_e(r) ? new j_e(t, r) : new b_(Ft.standaloneThemeService.get(), t, r);
  return TU(e) ? cn.registerPromise(n, e.then((r) => i(r))) : cn.register(n, i(e));
}
function Y_e(n, e) {
  const t = (i) => Mae(Ft.modeService.get(), Ft.standaloneThemeService.get(), n, V_e(n, i));
  return TU(e) ? cn.registerPromise(n, e.then((i) => t(i))) : cn.register(n, t(e));
}
function X_e(n, e) {
  return ST.register(n, e);
}
function Z_e(n, e) {
  return ET.register(n, e);
}
function Q_e(n, e) {
  return LT.register(n, e);
}
function J_e(n, e) {
  return DT.register(n, {
    provideHover: (t, i, r) => {
      let o = t.getWordAtPosition(i);
      return Promise.resolve(e.provideHover(t, i, r)).then((s) => {
        if (s)
          return !s.range && o && (s.range = new G(i.lineNumber, o.startColumn, i.lineNumber, o.endColumn)), s.range || (s.range = new G(i.lineNumber, i.column, i.lineNumber, i.column)), s;
      });
    }
  });
}
function eCe(n, e) {
  return RT.register(n, e);
}
function tCe(n, e) {
  return TT.register(n, e);
}
function iCe(n, e) {
  return pse.register(n, e);
}
function nCe(n, e) {
  return OT.register(n, e);
}
function rCe(n, e) {
  return NT.register(n, e);
}
function oCe(n, e) {
  return IT.register(n, e);
}
function sCe(n, e) {
  return PT.register(n, e);
}
function aCe(n, e) {
  return AT.register(n, {
    provideCodeActions: (t, i, r, o) => {
      let s = Ft.markerService.get().read({ resource: t.uri }).filter((a) => G.areIntersectingOrTouching(a, i));
      return e.provideCodeActions(t, i, { markers: s, only: r.only }, o);
    }
  });
}
function lCe(n, e) {
  return gv.register(n, e);
}
function uCe(n, e) {
  return Gu.register(n, e);
}
function cCe(n, e) {
  return I5.register(n, e);
}
function hCe(n, e) {
  return P5.register(n, e);
}
function dCe(n, e) {
  return Cb.register(n, e);
}
function fCe(n, e) {
  return gse.register(n, e);
}
function pCe(n, e) {
  return vse.register(n, e);
}
function gCe(n, e) {
  return xT.register(n, e);
}
function mCe(n, e) {
  return mse.register(n, e);
}
function vCe(n, e) {
  return yb.register(n, e);
}
function _Ce(n, e) {
  return A5.register(n, e);
}
function CCe(n, e) {
  return fse.register(n, e);
}
function yCe() {
  return {
    register: B_e,
    getLanguages: H_e,
    onLanguage: U_e,
    getEncodedLanguageId: G_e,
    // provider methods
    setLanguageConfiguration: z_e,
    setColorMap: K_e,
    setTokensProvider: q_e,
    setMonarchTokensProvider: Y_e,
    registerReferenceProvider: X_e,
    registerRenameProvider: Z_e,
    registerCompletionItemProvider: dCe,
    registerSignatureHelpProvider: Q_e,
    registerHoverProvider: J_e,
    registerDocumentSymbolProvider: eCe,
    registerDocumentHighlightProvider: tCe,
    registerLinkedEditingRangeProvider: iCe,
    registerDefinitionProvider: nCe,
    registerImplementationProvider: rCe,
    registerTypeDefinitionProvider: oCe,
    registerCodeLensProvider: sCe,
    registerCodeActionProvider: aCe,
    registerDocumentFormattingEditProvider: lCe,
    registerDocumentRangeFormattingEditProvider: uCe,
    registerOnTypeFormattingEditProvider: cCe,
    registerLinkProvider: hCe,
    registerColorProvider: fCe,
    registerFoldingRangeProvider: pCe,
    registerDeclarationProvider: gCe,
    registerSelectionRangeProvider: mCe,
    registerDocumentSemanticTokensProvider: vCe,
    registerDocumentRangeSemanticTokensProvider: _Ce,
    registerInlineCompletionsProvider: CCe,
    // enums
    DocumentHighlightKind: AR,
    CompletionItemKind: TR,
    CompletionItemTag: OR,
    CompletionItemInsertTextRule: RR,
    SymbolKind: tT,
    SymbolTag: iT,
    IndentAction: VR,
    CompletionTriggerKind: xR,
    SignatureHelpTriggerKind: eT,
    InlayHintKind: BR,
    InlineCompletionTriggerKind: HR,
    // classes
    FoldingRangeKind: Bd
  };
}
class S_ {
  static _handleEolEdits(e, t) {
    let i, r = [];
    for (let o of t)
      typeof o.eol == "number" && (i = o.eol), o.range && typeof o.text == "string" && r.push(o);
    return typeof i == "number" && e.hasModel() && e.getModel().pushEOL(i), r;
  }
  static _isFullModelReplaceEdit(e, t) {
    if (!e.hasModel())
      return !1;
    const i = e.getModel(), r = i.validateRange(t.range);
    return i.getFullModelRange().equalsRange(r);
  }
  static execute(e, t, i) {
    i && e.pushUndoStop();
    const r = S_._handleEolEdits(e, t);
    r.length === 1 && S_._isFullModelReplaceEdit(e, r[0]) ? e.executeEdits("formatEditsCommand", r.map((o) => UT.replace(G.lift(o.range), o.text))) : e.executeEdits("formatEditsCommand", r.map((o) => UT.replaceMove(G.lift(o.range), o.text))), i && e.pushUndoStop();
  }
}
class w1 {
  constructor(e) {
    this.value = e, this._lower = e.toLowerCase();
  }
  /**
   * Gives the value by which to index (for equality).
   */
  static toKey(e) {
    return typeof e == "string" ? e.toLowerCase() : e._lower;
  }
}
var pf = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(c) {
      try {
        u(i.next(c));
      } catch (h) {
        s(h);
      }
    }
    function l(c) {
      try {
        u(i.throw(c));
      } catch (h) {
        s(h);
      }
    }
    function u(c) {
      c.done ? o(c.value) : r(c.value).then(a, l);
    }
    u((i = i.apply(n, e || [])).next());
  });
};
function OU(n) {
  if (n = n.filter((r) => r.range), !n.length)
    return;
  let { range: e } = n[0];
  for (let r = 1; r < n.length; r++)
    e = G.plusRange(e, n[r].range);
  const { startLineNumber: t, endLineNumber: i } = e;
  t === i ? n.length === 1 ? ld(b("hint11", "Made 1 formatting edit on line {0}", t)) : ld(b("hintn1", "Made {0} formatting edits on line {1}", n.length, t)) : n.length === 1 ? ld(b("hint1n", "Made 1 formatting edit between lines {0} and {1}", t, i)) : ld(b("hintnn", "Made {0} formatting edits between lines {1} and {2}", n.length, t, i));
}
function xU(n) {
  const e = [], t = /* @__PURE__ */ new Set(), i = gv.ordered(n);
  for (const o of i)
    e.push(o), o.extensionId && t.add(w1.toKey(o.extensionId));
  const r = Gu.ordered(n);
  for (const o of r) {
    if (o.extensionId) {
      if (t.has(w1.toKey(o.extensionId)))
        continue;
      t.add(w1.toKey(o.extensionId));
    }
    e.push({
      displayName: o.displayName,
      extensionId: o.extensionId,
      provideDocumentFormattingEdits(s, a, l) {
        return o.provideDocumentRangeFormattingEdits(s, s.getFullModelRange(), a, l);
      }
    });
  }
  return e;
}
class Qd {
  static setFormatterSelector(e) {
    return { dispose: Qd._selectors.unshift(e) };
  }
  static select(e, t, i) {
    return pf(this, void 0, void 0, function* () {
      if (e.length === 0)
        return;
      const r = Ct.first(Qd._selectors);
      if (r)
        return yield r(e, t, i);
    });
  }
}
Qd._selectors = new fa();
function Ebe(n, e, t, i, r, o) {
  return pf(this, void 0, void 0, function* () {
    const s = n.get(no), a = uh(e) ? e.getModel() : e, l = Gu.ordered(a), u = yield Qd.select(l, a, i);
    u && (r.report(u), yield s.invokeFunction(wCe, u, e, t, o));
  });
}
function wCe(n, e, t, i, r) {
  return pf(this, void 0, void 0, function* () {
    const o = n.get(sc);
    let s, a;
    uh(t) ? (s = t.getModel(), a = new v7(t, 5, void 0, r)) : (s = t, a = new _7(t, r));
    let l = [], u = 0;
    for (let h of aae(i).sort(G.compareRangesUsingStarts))
      u > 0 && G.areIntersectingOrTouching(l[u - 1], h) ? l[u - 1] = G.fromPositions(l[u - 1].getStartPosition(), h.getEndPosition()) : u = l.push(h);
    const c = [];
    for (let h of l)
      try {
        const d = yield e.provideDocumentRangeFormattingEdits(s, h, s.getFormattingOptions(), a.token), f = yield o.computeMoreMinimalEdits(s.uri, d);
        if (f && c.push(...f), a.token.isCancellationRequested)
          return !0;
      } finally {
        a.dispose();
      }
    if (c.length === 0)
      return !1;
    if (uh(t))
      S_.execute(t, c, !0), OU(c), t.revealPositionInCenterIfOutsideViewport(
        t.getPosition(),
        1
        /* Immediate */
      );
    else {
      const [{ range: h }] = c, d = new Ut(h.startLineNumber, h.startColumn, h.endLineNumber, h.endColumn);
      s.pushEditOperations([d], c.map((f) => ({
        text: f.text,
        range: G.lift(f.range),
        forceMoveMarkers: !0
      })), (f) => {
        for (const { range: p } of f)
          if (G.areIntersectingOrTouching(p, d))
            return [new Ut(p.startLineNumber, p.startColumn, p.endLineNumber, p.endColumn)];
        return null;
      });
    }
    return !0;
  });
}
function Lbe(n, e, t, i, r) {
  return pf(this, void 0, void 0, function* () {
    const o = n.get(no), s = uh(e) ? e.getModel() : e, a = xU(s), l = yield Qd.select(a, s, t);
    l && (i.report(l), yield o.invokeFunction(bCe, l, e, t, r));
  });
}
function bCe(n, e, t, i, r) {
  return pf(this, void 0, void 0, function* () {
    const o = n.get(sc);
    let s, a;
    uh(t) ? (s = t.getModel(), a = new v7(t, 5, void 0, r)) : (s = t, a = new _7(t, r));
    let l;
    try {
      const u = yield e.provideDocumentFormattingEdits(s, s.getFormattingOptions(), a.token);
      if (l = yield o.computeMoreMinimalEdits(s.uri, u), a.token.isCancellationRequested)
        return !0;
    } finally {
      a.dispose();
    }
    if (!l || l.length === 0)
      return !1;
    if (uh(t))
      S_.execute(
        t,
        l,
        i !== 2
        /* Silent */
      ), i !== 2 && (OU(l), t.revealPositionInCenterIfOutsideViewport(
        t.getPosition(),
        1
        /* Immediate */
      ));
    else {
      const [{ range: u }] = l, c = new Ut(u.startLineNumber, u.startColumn, u.endLineNumber, u.endColumn);
      s.pushEditOperations([c], l.map((h) => ({
        text: h.text,
        range: G.lift(h.range),
        forceMoveMarkers: !0
      })), (h) => {
        for (const { range: d } of h)
          if (G.areIntersectingOrTouching(d, c))
            return [new Ut(d.startLineNumber, d.startColumn, d.endLineNumber, d.endColumn)];
        return null;
      });
    }
    return !0;
  });
}
function SCe(n, e, t, i, r) {
  return pf(this, void 0, void 0, function* () {
    const o = Gu.ordered(e);
    for (const s of o) {
      let a = yield Promise.resolve(s.provideDocumentRangeFormattingEdits(e, t, i, r)).catch(k_);
      if (tI(a))
        return yield n.computeMoreMinimalEdits(e.uri, a);
    }
  });
}
function ECe(n, e, t, i) {
  return pf(this, void 0, void 0, function* () {
    const r = xU(e);
    for (const o of r) {
      let s = yield Promise.resolve(o.provideDocumentFormattingEdits(e, t, i)).catch(k_);
      if (tI(s))
        return yield n.computeMoreMinimalEdits(e.uri, s);
    }
  });
}
function LCe(n, e, t, i, r) {
  const o = I5.ordered(e);
  return o.length === 0 || o[0].autoFormatTriggerCharacters.indexOf(i) < 0 ? Promise.resolve(void 0) : Promise.resolve(o[0].provideOnTypeFormattingEdits(e, t, i, r, Ko.None)).catch(k_).then((s) => n.computeMoreMinimalEdits(e.uri, s));
}
Qn.registerCommand("_executeFormatRangeProvider", function(n, ...e) {
  const [t, i, r] = e;
  $o(ft.isUri(t)), $o(G.isIRange(i));
  const o = n.get(ao).getModel(t);
  if (!o)
    throw V_("resource");
  return SCe(n.get(sc), o, G.lift(i), r, Ko.None);
});
Qn.registerCommand("_executeFormatDocumentProvider", function(n, ...e) {
  const [t, i] = e;
  $o(ft.isUri(t));
  const r = n.get(ao).getModel(t);
  if (!r)
    throw V_("resource");
  return ECe(n.get(sc), r, i, Ko.None);
});
Qn.registerCommand("_executeFormatOnTypeProvider", function(n, ...e) {
  const [t, i, r, o] = e;
  $o(ft.isUri(t)), $o(ie.isIPosition(i)), $o(typeof r == "string");
  const s = n.get(ao).getModel(t);
  if (!s)
    throw V_("resource");
  return LCe(n.get(sc), s, ie.lift(i), r, o);
});
var b1;
sf.wrappingIndent.defaultValue = 0;
sf.glyphMargin.defaultValue = !1;
sf.autoIndent.defaultValue = 3;
sf.overviewRulerLanes.defaultValue = 2;
Qd.setFormatterSelector((n, e, t) => Promise.resolve(n[0]));
const Vr = qG();
Vr.editor = P_e();
Vr.languages = yCe();
const Dbe = Vr.CancellationTokenSource, Rbe = Vr.Emitter, Tbe = Vr.KeyCode, Obe = Vr.KeyMod, xbe = Vr.Position, Nbe = Vr.Range, Ibe = Vr.Selection, Pbe = Vr.SelectionDirection, Abe = Vr.MarkerSeverity, Mbe = Vr.MarkerTag, Fbe = Vr.Uri, kbe = Vr.Token, Wbe = Vr.editor, Ky = Vr.languages;
(!((b1 = vn.MonacoEnvironment) === null || b1 === void 0) && b1.globalAPI || typeof define == "function" && define.amd) && (self.monaco = Vr);
typeof self.require < "u" && typeof self.require.config == "function" && self.require.config({
  ignoreDuplicateModules: [
    "vscode-languageserver-types",
    "vscode-languageserver-types/main",
    "vscode-languageserver-textdocument",
    "vscode-languageserver-textdocument/main",
    "vscode-nls",
    "vscode-nls/vscode-nls",
    "jsonc-parser",
    "jsonc-parser/main",
    "vscode-uri",
    "vscode-uri/index",
    "vs/basic-languages/typescript/typescript"
  ]
});
var NU = {}, S1 = {}, DCe = (
  /** @class */
  function() {
    function n(e) {
      var t = this;
      this._languageId = e, this._loadingTriggered = !1, this._lazyLoadPromise = new Promise(function(i, r) {
        t._lazyLoadPromiseResolve = i, t._lazyLoadPromiseReject = r;
      });
    }
    return n.getOrCreate = function(e) {
      return S1[e] || (S1[e] = new n(e)), S1[e];
    }, n.prototype.whenLoaded = function() {
      return this._lazyLoadPromise;
    }, n.prototype.load = function() {
      var e = this;
      return this._loadingTriggered || (this._loadingTriggered = !0, NU[this._languageId].loader().then(function(t) {
        return e._lazyLoadPromiseResolve(t);
      }, function(t) {
        return e._lazyLoadPromiseReject(t);
      })), this._lazyLoadPromise;
    }, n;
  }()
);
function RCe(n) {
  var e = n.id;
  NU[e] = n, Ky.register(n);
  var t = DCe.getOrCreate(e);
  Ky.setMonarchTokensProvider(e, t.whenLoaded().then(function(i) {
    return i.language;
  })), Ky.onLanguage(e, function() {
    t.load().then(function(i) {
      Ky.setLanguageConfiguration(e, i.conf);
    });
  });
}
RCe({
  id: "graphql",
  extensions: [".graphql", ".gql"],
  aliases: ["GraphQL", "graphql", "gql"],
  mimetypes: ["application/graphql"],
  loader: function() {
    return Promise.resolve().then(() => xCe);
  }
});
var TCe = {
  comments: {
    lineComment: "#"
  },
  brackets: [
    ["{", "}"],
    ["[", "]"],
    ["(", ")"]
  ],
  autoClosingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: '"""', close: '"""', notIn: ["string", "comment"] },
    { open: '"', close: '"', notIn: ["string", "comment"] }
  ],
  surroundingPairs: [
    { open: "{", close: "}" },
    { open: "[", close: "]" },
    { open: "(", close: ")" },
    { open: '"""', close: '"""' },
    { open: '"', close: '"' }
  ],
  folding: {
    offSide: !0
  }
}, OCe = {
  // Set defaultToken to invalid to see what you do not tokenize yet
  defaultToken: "invalid",
  tokenPostfix: ".gql",
  keywords: [
    "null",
    "true",
    "false",
    "query",
    "mutation",
    "subscription",
    "extend",
    "schema",
    "directive",
    "scalar",
    "type",
    "interface",
    "union",
    "enum",
    "input",
    "implements",
    "fragment",
    "on"
  ],
  typeKeywords: ["Int", "Float", "String", "Boolean", "ID"],
  directiveLocations: [
    "SCHEMA",
    "SCALAR",
    "OBJECT",
    "FIELD_DEFINITION",
    "ARGUMENT_DEFINITION",
    "INTERFACE",
    "UNION",
    "ENUM",
    "ENUM_VALUE",
    "INPUT_OBJECT",
    "INPUT_FIELD_DEFINITION",
    "QUERY",
    "MUTATION",
    "SUBSCRIPTION",
    "FIELD",
    "FRAGMENT_DEFINITION",
    "FRAGMENT_SPREAD",
    "INLINE_FRAGMENT",
    "VARIABLE_DEFINITION"
  ],
  operators: ["=", "!", "?", ":", "&", "|"],
  // we include these common regular expressions
  symbols: /[=!?:&|]+/,
  // https://facebook.github.io/graphql/draft/#sec-String-Value
  escapes: /\\(?:["\\\/bfnrt]|u[0-9A-Fa-f]{4})/,
  // The main tokenizer for our languages
  tokenizer: {
    root: [
      // fields and argument names
      [
        /[a-z_][\w$]*/,
        {
          cases: {
            "@keywords": "keyword",
            "@default": "key.identifier"
          }
        }
      ],
      // identify typed input variables
      [
        /[$][\w$]*/,
        {
          cases: {
            "@keywords": "keyword",
            "@default": "argument.identifier"
          }
        }
      ],
      // to show class names nicely
      [
        /[A-Z][\w\$]*/,
        {
          cases: {
            "@typeKeywords": "keyword",
            "@default": "type.identifier"
          }
        }
      ],
      // whitespace
      { include: "@whitespace" },
      // delimiters and operators
      [/[{}()\[\]]/, "@brackets"],
      [/@symbols/, { cases: { "@operators": "operator", "@default": "" } }],
      // @ annotations.
      // As an example, we emit a debugging log message on these tokens.
      // Note: message are supressed during the first load -- change some lines to see them.
      [/@\s*[a-zA-Z_\$][\w\$]*/, { token: "annotation", log: "annotation token: $0" }],
      // numbers
      [/\d*\.\d+([eE][\-+]?\d+)?/, "number.float"],
      [/0[xX][0-9a-fA-F]+/, "number.hex"],
      [/\d+/, "number"],
      // delimiter: after number because of .\d floats
      [/[;,.]/, "delimiter"],
      [/"""/, { token: "string", next: "@mlstring", nextEmbedded: "markdown" }],
      // strings
      [/"([^"\\]|\\.)*$/, "string.invalid"],
      [/"/, { token: "string.quote", bracket: "@open", next: "@string" }]
    ],
    mlstring: [
      [/[^"]+/, "string"],
      ['"""', { token: "string", next: "@pop", nextEmbedded: "@pop" }]
    ],
    string: [
      [/[^\\"]+/, "string"],
      [/@escapes/, "string.escape"],
      [/\\./, "string.escape.invalid"],
      [/"/, { token: "string.quote", bracket: "@close", next: "@pop" }]
    ],
    whitespace: [
      [/[ \t\r\n]+/, ""],
      [/#.*$/, "comment"]
    ]
  }
};
const xCe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  conf: TCe,
  language: OCe
}, Symbol.toStringTag, { value: "Module" }));
export {
  kn as $,
  T as A,
  qe as B,
  oa as C,
  V_ as D,
  F as E,
  UCe as F,
  He as G,
  Ywe as H,
  nt as I,
  xi as J,
  E3 as K,
  OG as L,
  ht as M,
  PS as N,
  jCe as O,
  Le as P,
  Eo as Q,
  zCe as R,
  S3 as S,
  Ut as T,
  b as U,
  ld as V,
  q_ as W,
  Re as X,
  Jne as Y,
  ee as Z,
  Ad as _,
  HCe as a,
  mye as a$,
  km as a0,
  Xv as a1,
  wa as a2,
  yv as a3,
  si as a4,
  Ce as a5,
  ro as a6,
  G as a7,
  ie as a8,
  Rwe as a9,
  Ze as aA,
  Xne as aB,
  oc as aC,
  bce as aD,
  jl as aE,
  yce as aF,
  wce as aG,
  FE as aH,
  xo as aI,
  ZS as aJ,
  lf as aK,
  qa as aL,
  zl as aM,
  q as aN,
  Hi as aO,
  ri as aP,
  uye as aQ,
  be as aR,
  Xr as aS,
  Xu as aT,
  pwe as aU,
  gwe as aV,
  pI as aW,
  DE as aX,
  no as aY,
  Pi as aZ,
  ZG as a_,
  Twe as aa,
  Mt as ab,
  _o as ac,
  cv as ad,
  to as ae,
  dI as af,
  mr as ag,
  kE as ah,
  XS as ai,
  Ub as aj,
  cce as ak,
  Qn as al,
  ft as am,
  ao as an,
  Ko as ao,
  mpe as ap,
  _7 as aq,
  W_ as ar,
  k_ as as,
  AT as at,
  Yu as au,
  Mye as av,
  oae as aw,
  tI as ax,
  dt as ay,
  Mg as az,
  GCe as b,
  ma as b$,
  pU as b0,
  WE as b1,
  Wae as b2,
  Xo as b3,
  EE as b4,
  al as b5,
  J5 as b6,
  fr as b7,
  Xp as b8,
  $o as b9,
  Ge as bA,
  b5 as bB,
  vi as bC,
  Ro as bD,
  gye as bE,
  Toe as bF,
  er as bG,
  ks as bH,
  tS as bI,
  vh as bJ,
  ne as bK,
  Xh as bL,
  ds as bM,
  u5 as bN,
  ik as bO,
  CU as bP,
  lI as bQ,
  Ri as bR,
  gi as bS,
  Yi as bT,
  Tv as bU,
  y7 as bV,
  rp as bW,
  Is as bX,
  wt as bY,
  u3 as bZ,
  ja as b_,
  PT as ba,
  Dwe as bb,
  hwe as bc,
  Iv as bd,
  Xe as be,
  nE as bf,
  Vt as bg,
  vve as bh,
  zN as bi,
  dT as bj,
  sg as bk,
  aV as bl,
  g7 as bm,
  Rye as bn,
  Uoe as bo,
  As as bp,
  FN as bq,
  hT as br,
  Oi as bs,
  kI as bt,
  EU as bu,
  gse as bv,
  _r as bw,
  Nt as bx,
  u7 as by,
  Me as bz,
  Ae as c,
  L3 as c$,
  qv as c0,
  ZT as c1,
  m3 as c2,
  Wle as c3,
  pr as c4,
  Ms as c5,
  io as c6,
  lg as c7,
  Ps as c8,
  d5 as c9,
  wU as cA,
  yye as cB,
  _be as cC,
  p5 as cD,
  We as cE,
  pa as cF,
  Xwe as cG,
  Fre as cH,
  mk as cI,
  Dye as cJ,
  Fwe as cK,
  QN as cL,
  cn as cM,
  Gye as cN,
  DT as cO,
  aae as cP,
  xwe as cQ,
  Owe as cR,
  oo as cS,
  eg as cT,
  eo as cU,
  nI as cV,
  Pg as cW,
  vs as cX,
  Kt as cY,
  _5 as cZ,
  GN as c_,
  nk as ca,
  mn as cb,
  Swe as cc,
  Ewe as cd,
  Lwe as ce,
  _k as cf,
  y3 as cg,
  eme as ch,
  ws as ci,
  z2 as cj,
  Pce as ck,
  mw as cl,
  SI as cm,
  nh as cn,
  z3 as co,
  Ap as cp,
  Yye as cq,
  l7 as cr,
  bi as cs,
  z_ as ct,
  rae as cu,
  mT as cv,
  fa as cw,
  Vg as cx,
  g3 as cy,
  oV as cz,
  $Ce as d,
  fE as d$,
  D3 as d0,
  Z2 as d1,
  Tk as d2,
  UT as d3,
  fse as d4,
  Fr as d5,
  uk as d6,
  zG as d7,
  cre as d8,
  _ye as d9,
  Yv as dA,
  Kn as dB,
  Sd as dC,
  $a as dD,
  gW as dE,
  hye as dF,
  o5 as dG,
  pb as dH,
  vye as dI,
  x7 as dJ,
  Ave as dK,
  Kwe as dL,
  Oye as dM,
  $l as dN,
  VD as dO,
  Z_ as dP,
  fhe as dQ,
  phe as dR,
  BD as dS,
  ahe as dT,
  df as dU,
  Fl as dV,
  dg as dW,
  ng as dX,
  Fa as dY,
  Xye as dZ,
  Iye as d_,
  eoe as da,
  ui as db,
  mwe as dc,
  vwe as dd,
  _we as de,
  Cwe as df,
  wle as dg,
  Cre as dh,
  Aye as di,
  bb as dj,
  Cb as dk,
  xg as dl,
  Yne as dm,
  Td as dn,
  K_ as dp,
  xye as dq,
  fv as dr,
  cS as ds,
  qwe as dt,
  ak as du,
  $we as dv,
  Gk as dw,
  sae as dx,
  sc as dy,
  mh as dz,
  Wt as e,
  vce as e$,
  Uo as e0,
  QG as e1,
  NN as e2,
  kt as e3,
  PE as e4,
  wre as e5,
  H2 as e6,
  ap as e7,
  Vre as e8,
  cye as e9,
  awe as eA,
  uwe as eB,
  lwe as eC,
  cwe as eD,
  Os as eE,
  Bg as eF,
  U_ as eG,
  Tg as eH,
  Qp as eI,
  ywe as eJ,
  bwe as eK,
  pye as eL,
  Pye as eM,
  Gf as eN,
  qhe as eO,
  Go as eP,
  Zye as eQ,
  Jye as eR,
  Qye as eS,
  i5 as eT,
  Zu as eU,
  zb as eV,
  Cbe as eW,
  AN as eX,
  iE as eY,
  pT as eZ,
  jre as e_,
  bye as ea,
  So as eb,
  qo as ec,
  OT as ed,
  xT as ee,
  NT as ef,
  IT as eg,
  ST as eh,
  gV as ei,
  Zwe as ej,
  Zd as ek,
  VI as el,
  ove as em,
  XW as en,
  nV as eo,
  rbe as ep,
  ou as eq,
  bp as er,
  uh as es,
  jye as et,
  v7 as eu,
  aye as ev,
  Nye as ew,
  Ere as ex,
  op as ey,
  dO as ez,
  Z as f,
  z5 as f$,
  _ce as f0,
  Cce as f1,
  Sce as f2,
  Ece as f3,
  Lce as f4,
  Dce as f5,
  Rce as f6,
  Tce as f7,
  e5 as f8,
  Wwe as f9,
  Ebe as fA,
  Lbe as fB,
  RT as fC,
  Ct as fD,
  Gc as fE,
  Pk as fF,
  fwe as fG,
  dwe as fH,
  $v as fI,
  Ng as fJ,
  Rn as fK,
  Iwe as fL,
  Vi as fM,
  pse as fN,
  ck as fO,
  lye as fP,
  P5 as fQ,
  fD as fR,
  Cye as fS,
  TT as fT,
  wwe as fU,
  sr as fV,
  YT as fW,
  Ok as fX,
  LT as fY,
  sye as fZ,
  wye as f_,
  r5 as fa,
  B2 as fb,
  iwe as fc,
  nwe as fd,
  owe as fe,
  rwe as ff,
  swe as fg,
  Kye as fh,
  ewe as fi,
  zye as fj,
  Hye as fk,
  gr as fl,
  Mp as fm,
  qye as fn,
  vse as fo,
  Bd as fp,
  xs as fq,
  j_ as fr,
  il as fs,
  Noe as ft,
  vb as fu,
  I5 as fv,
  LCe as fw,
  S_ as fx,
  OU as fy,
  Gu as fz,
  Md as g,
  LV as g$,
  Jn as g0,
  Ag as g1,
  ET as g2,
  ad as g3,
  Iu as g4,
  mse as g5,
  Uye as g6,
  Jk as g7,
  J7 as g8,
  A5 as g9,
  kae as gA,
  Nwe as gB,
  a2 as gC,
  rw as gD,
  fye as gE,
  dye as gF,
  Nk as gG,
  c2 as gH,
  H7 as gI,
  Dge as gJ,
  jwe as gK,
  zI as gL,
  Uge as gM,
  u2 as gN,
  h2 as gO,
  Dbe as gP,
  Tbe as gQ,
  Obe as gR,
  Abe as gS,
  Mbe as gT,
  xbe as gU,
  Nbe as gV,
  Ibe as gW,
  Pbe as gX,
  kbe as gY,
  Fbe as gZ,
  Wbe as g_,
  k7 as ga,
  OW as gb,
  F7 as gc,
  Gpe as gd,
  j3 as ge,
  twe as gf,
  xk as gg,
  Ife as gh,
  ibe as gi,
  tg as gj,
  sf as gk,
  xt as gl,
  at as gm,
  Pwe as gn,
  St as go,
  o2 as gp,
  jve as gq,
  J_ as gr,
  s2 as gs,
  sE as gt,
  Cse as gu,
  M5 as gv,
  la as gw,
  LU as gx,
  l2 as gy,
  kye as gz,
  Bx as h,
  kV as h0,
  dR as h1,
  WCe as h2,
  L_ as h3,
  ACe as h4,
  JCe as h5,
  VCe as h6,
  kCe as h7,
  BCe as h8,
  fi as i,
  Se as j,
  To as k,
  oR as l,
  QCe as m,
  XCe as n,
  YCe as o,
  ZCe as p,
  gt as q,
  MCe as r,
  qCe as s,
  HS as t,
  Jd as u,
  FCe as v,
  eye as w,
  Ky as x,
  Rbe as y,
  RCe as z
};
